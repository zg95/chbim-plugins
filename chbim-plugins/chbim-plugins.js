var xy = Object.defineProperty;
var wy = (x, a, s) => a in x ? xy(x, a, { enumerable: !0, configurable: !0, writable: !0, value: s }) : x[a] = s;
var vl = (x, a, s) => (wy(x, typeof a != "symbol" ? a + "" : a, s), s);
import { openBlock as Zu, createElementBlock as Ju, normalizeClass as Np, renderSlot as Fp, defineComponent as of, ref as Fc, onMounted as sf, createElementVNode as Mr, toDisplayString as Ty, createApp as xp } from "vue";
const My = (x, a) => {
  const s = x.__vccOpts || x;
  for (const [c, d] of a)
    s[c] = d;
  return s;
}, Sy = {
  name: "MukButton"
}, Ey = /* @__PURE__ */ Object.assign(Sy, {
  props: {
    size: {
      type: String,
      default: "middle"
    },
    type: {
      type: String,
      default: "default"
    }
  },
  setup(x) {
    return (a, s) => (Zu(), Ju("button", {
      class: Np(["muk-btn", [x.size, x.type]])
    }, [
      Fp(a.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), by = /* @__PURE__ */ My(Ey, [["__scopeId", "data-v-0e6d93cd"]]);
class Cy {
  constructor() {
    this.dom = {
      mask: document.querySelector(".js-mask"),
      slices: [...document.querySelectorAll(".js-mask__slice")],
      lines: [...document.querySelectorAll(".js-mask-line")],
      logo: document.querySelector(".js-logo"),
      titles: [...document.querySelectorAll(".js-transition-title")]
    }, this.tl = null, this.state = !1, this.init();
  }
  resetScroll() {
    window.scrollTo(0, 0);
  }
  createTimeline() {
    this.tl = new TimelineMax({
      paused: !0,
      onComplete: () => {
        this.state = !1;
      }
    }), this.tl.set(this.dom.titles, {
      yPercent: 0
    }).set(this.dom.mask, {
      autoAlpha: 1
    }).staggerFromTo(
      this.dom.slices,
      1.5,
      {
        xPercent: 100
      },
      {
        xPercent: 0,
        ease: Expo.easeInOut
      },
      -0.075
    ).addCallback(this.resetScroll.bind(this)).addLabel("loaderStart").set(this.dom.titles, {
      yPercent: -100
    }).set([this.dom.lines[0], this.dom.logo], {
      autoAlpha: 1
    }).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: -100,
        rotation: 10
      },
      {
        yPercent: 0,
        rotation: 0,
        ease: Expo.easeOut
      }
    ).addLabel("intermediateFrame").staggerFromTo(
      this.dom.lines,
      0.5,
      {
        scaleX: 0
      },
      {
        scaleX: 1,
        ease: Expo.easeInOut
      },
      0.75,
      "-=1"
    ).set(this.dom.lines, {
      transformOrigin: "right"
    }).fromTo(
      this.dom.lines[0],
      1,
      {
        scaleX: 1
      },
      {
        scaleX: 0,
        ease: Expo.easeInOut
      }
    ).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: 0
      },
      {
        yPercent: 105,
        ease: Expo.easeOut
      },
      "-=1"
    ).staggerFromTo(
      this.dom.slices,
      0.5,
      {
        xPercent: 0
      },
      {
        xPercent: 100,
        ease: Expo.easeInOut
      },
      0.075
    ).set(this.dom.mask, {
      autoAlpha: 0
    }).addLabel("imagesStart", "-=0.85").staggerFromTo(
      this.dom.titles,
      1.5,
      {
        yPercent: 100
      },
      {
        yPercent: 0,
        ease: Expo.easeInOut
      },
      0.05,
      "imagesStart"
    ).addLabel("loaderEnd");
  }
  continuation() {
    this.init(), this.resetScroll(), this.tl.tweenFromTo("loaderStart", "loaderEnd");
  }
  show() {
    this.init(), this.tl.tweenFromTo("loaderStart", "intermediateFrame");
  }
  hide() {
    this.resetScroll(), this.tl.tweenFromTo("intermediateFrame", "loaderEnd");
  }
  init() {
    document.querySelector(".mask-line.js-mask-line") && document.querySelector(".mask-line.js-mask-line").removeAttribute("style"), document.querySelector(".mask-line__inner.js-mask-line") && document.querySelector(".mask-line__inner.js-mask-line").removeAttribute("style"), this.createTimeline();
  }
}
const Ay = { class: "mask js-mask" }, Py = /* @__PURE__ */ Mr("div", { class: "mask__slice js-mask__slice" }, null, -1), Ly = /* @__PURE__ */ Mr("div", { class: "mask__slice js-mask__slice" }, null, -1), Ry = /* @__PURE__ */ Mr("div", { class: "mask__slice js-mask__slice" }, null, -1), Oy = { class: "mask__inner" }, Iy = { class: "logo logo--mask" }, Dy = {
  class: "js-logo",
  style: { color: "#fff" }
}, zy = /* @__PURE__ */ Mr("div", { class: "mask-line js-mask-line" }, [
  /* @__PURE__ */ Mr("div", { class: "mask-line__inner js-mask-line" })
], -1), ky = {
  name: "BimCutscenes"
}, By = /* @__PURE__ */ of({
  ...ky,
  props: {
    text: {
      type: String,
      default: "CHBIM云平台"
    }
  },
  setup(x, { expose: a }) {
    const s = Fc(null), c = () => {
      s.value === null && (s.value = new Cy());
    }, d = () => {
      c(), s.value.continuation();
    };
    return sf(() => {
      c();
    }), a({
      continuation: d
    }), (u, m) => (Zu(), Ju("div", Ay, [
      Py,
      Ly,
      Ry,
      Mr("div", Oy, [
        Mr("figure", Iy, [
          Mr("p", Dy, Ty(x.text), 1)
        ]),
        zy
      ])
    ]));
  }
});
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
var hn = typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window;
(hn._gsQueue || (hn._gsQueue = [])).push(function() {
  hn._gsDefine(
    "TweenMax",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(x, a, s) {
      var c = function(E) {
        var L, T = [], M = E.length;
        for (L = 0; L !== M; T.push(E[L++]))
          ;
        return T;
      }, d = function(E, L, T) {
        var M, R, b = E.cycle;
        for (M in b)
          R = b[M], E[M] = typeof R == "function" ? R(T, L[T]) : R[T % R.length];
        delete E.cycle;
      }, u = function(E, L, T) {
        s.call(this, E, L, T), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = u.prototype.render;
      }, m = 1e-10, g = s._internals, _ = g.isSelector, S = g.isArray, C = u.prototype = s.to({}, 0.1, {}), O = [];
      u.version = "2.0.2", C.constructor = u, C.kill()._gc = !1, u.killTweensOf = u.killDelayedCallsTo = s.killTweensOf, u.getTweensOf = s.getTweensOf, u.lagSmoothing = s.lagSmoothing, u.ticker = s.ticker, u.render = s.render, C.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), s.prototype.invalidate.call(this);
      }, C.updateTo = function(E, L) {
        var T, M = this.ratio, R = this.vars.immediateRender || E.immediateRender;
        L && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
        for (T in E)
          this.vars[T] = E[T];
        if (this._initted || R) {
          if (L)
            this._initted = !1, R && this.render(0, !0, !0);
          else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && s._onPluginEvent("_onDisable", this), this._time / this._duration > 0.998) {
            var b = this._totalTime;
            this.render(0, !0, !1), this._initted = !1, this.render(b, !0, !1);
          } else if (this._initted = !1, this._init(), this._time > 0 || R)
            for (var U, N = 1 / (1 - M), j = this._firstPT; j; )
              U = j.s + j.c, j.c *= N, j.s = U - j.c, j = j._next;
        }
        return this;
      }, C.render = function(E, L, T) {
        this._initted || this._duration === 0 && this.vars.repeat && this.invalidate();
        var M, R, b, U, N, j, J, K, ct, It = this._dirty ? this.totalDuration() : this._totalDuration, et = this._time, _t = this._totalTime, G = this._cycle, Pt = this._duration, Et = this._rawPrevTime;
        if (E >= It - 1e-7 && E >= 0 ? (this._totalTime = It, this._cycle = this._repeat, this._yoyo && 1 & this._cycle ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = Pt, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (M = !0, R = "onComplete", T = T || this._timeline.autoRemoveChildren), Pt === 0 && (this._initted || !this.vars.lazy || T) && (this._startTime === this._timeline._duration && (E = 0), (0 > Et || 0 >= E && E >= -1e-7 || Et === m && this.data !== "isPause") && Et !== E && (T = !0, Et > m && (R = "onReverseComplete")), this._rawPrevTime = K = !L || E || Et === E ? E : m)) : 1e-7 > E ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (_t !== 0 || Pt === 0 && Et > 0) && (R = "onReverseComplete", M = this._reversed), 0 > E && (this._active = !1, Pt === 0 && (this._initted || !this.vars.lazy || T) && (Et >= 0 && (T = !0), this._rawPrevTime = K = !L || E || Et === E ? E : m)), this._initted || (T = !0)) : (this._totalTime = this._time = E, this._repeat !== 0 && (U = Pt + this._repeatDelay, this._cycle = this._totalTime / U >> 0, this._cycle !== 0 && this._cycle === this._totalTime / U && E >= _t && this._cycle--, this._time = this._totalTime - this._cycle * U, this._yoyo && 1 & this._cycle && (this._time = Pt - this._time, ct = this._yoyoEase || this.vars.yoyoEase, ct && (this._yoyoEase || (ct !== !0 || this._initted ? this._yoyoEase = ct = ct === !0 ? this._ease : ct instanceof Ease ? ct : Ease.map[ct] : (ct = this.vars.ease, this._yoyoEase = ct = ct ? ct instanceof Ease ? ct : typeof ct == "function" ? new Ease(ct, this.vars.easeParams) : Ease.map[ct] || s.defaultEase : s.defaultEase)), this.ratio = ct ? 1 - ct.getRatio((Pt - this._time) / Pt) : 0)), this._time > Pt ? this._time = Pt : this._time < 0 && (this._time = 0)), this._easeType && !ct ? (N = this._time / Pt, j = this._easeType, J = this._easePower, (j === 1 || j === 3 && N >= 0.5) && (N = 1 - N), j === 3 && (N *= 2), J === 1 ? N *= N : J === 2 ? N *= N * N : J === 3 ? N *= N * N * N : J === 4 && (N *= N * N * N * N), j === 1 ? this.ratio = 1 - N : j === 2 ? this.ratio = N : this._time / Pt < 0.5 ? this.ratio = N / 2 : this.ratio = 1 - N / 2) : ct || (this.ratio = this._ease.getRatio(this._time / Pt))), et === this._time && !T && G === this._cycle)
          return void (_t !== this._totalTime && this._onUpdate && (L || this._callback("onUpdate")));
        if (!this._initted) {
          if (this._init(), !this._initted || this._gc)
            return;
          if (!T && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
            return this._time = et, this._totalTime = _t, this._rawPrevTime = Et, this._cycle = G, g.lazyTweens.push(this), void (this._lazy = [E, L]);
          !this._time || M || ct ? M && this._ease._calcEnd && !ct && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / Pt);
        }
        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== et && E >= 0 && (this._active = !0), _t === 0 && (this._initted === 2 && E > 0 && this._init(), this._startAt && (E >= 0 ? this._startAt.render(E, !0, T) : R || (R = "_dummyGS")), this.vars.onStart && (this._totalTime !== 0 || Pt === 0) && (L || this._callback("onStart"))), b = this._firstPT; b; )
          b.f ? b.t[b.p](b.c * this.ratio + b.s) : b.t[b.p] = b.c * this.ratio + b.s, b = b._next;
        this._onUpdate && (0 > E && this._startAt && this._startTime && this._startAt.render(E, !0, T), L || (this._totalTime !== _t || R) && this._callback("onUpdate")), this._cycle !== G && (L || this._gc || this.vars.onRepeat && this._callback("onRepeat")), R && (!this._gc || T) && (0 > E && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(E, !0, T), M && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !L && this.vars[R] && this._callback(R), Pt === 0 && this._rawPrevTime === m && K !== m && (this._rawPrevTime = 0));
      }, u.to = function(E, L, T) {
        return new u(E, L, T);
      }, u.from = function(E, L, T) {
        return T.runBackwards = !0, T.immediateRender = T.immediateRender != 0, new u(E, L, T);
      }, u.fromTo = function(E, L, T, M) {
        return M.startAt = T, M.immediateRender = M.immediateRender != 0 && T.immediateRender != 0, new u(E, L, M);
      }, u.staggerTo = u.allTo = function(E, L, T, M, R, b, U) {
        M = M || 0;
        var N, j, J, K, ct = 0, It = [], et = function() {
          T.onComplete && T.onComplete.apply(T.onCompleteScope || this, arguments), R.apply(U || T.callbackScope || this, b || O);
        }, _t = T.cycle, G = T.startAt && T.startAt.cycle;
        for (S(E) || (typeof E == "string" && (E = s.selector(E) || E), _(E) && (E = c(E))), E = E || [], 0 > M && (E = c(E), E.reverse(), M *= -1), N = E.length - 1, J = 0; N >= J; J++) {
          j = {};
          for (K in T)
            j[K] = T[K];
          if (_t && (d(j, E, J), j.duration != null && (L = j.duration, delete j.duration)), G) {
            G = j.startAt = {};
            for (K in T.startAt)
              G[K] = T.startAt[K];
            d(j.startAt, E, J);
          }
          j.delay = ct + (j.delay || 0), J === N && R && (j.onComplete = et), It[J] = new u(E[J], L, j), ct += M;
        }
        return It;
      }, u.staggerFrom = u.allFrom = function(E, L, T, M, R, b, U) {
        return T.runBackwards = !0, T.immediateRender = T.immediateRender != 0, u.staggerTo(E, L, T, M, R, b, U);
      }, u.staggerFromTo = u.allFromTo = function(E, L, T, M, R, b, U, N) {
        return M.startAt = T, M.immediateRender = M.immediateRender != 0 && T.immediateRender != 0, u.staggerTo(E, L, M, R, b, U, N);
      }, u.delayedCall = function(E, L, T, M, R) {
        return new u(L, 0, {
          delay: E,
          onComplete: L,
          onCompleteParams: T,
          callbackScope: M,
          onReverseComplete: L,
          onReverseCompleteParams: T,
          immediateRender: !1,
          useFrames: R,
          overwrite: 0
        });
      }, u.set = function(E, L) {
        return new u(E, 0, L);
      }, u.isTweening = function(E) {
        return s.getTweensOf(E, !0).length > 0;
      };
      var k = function(E, L) {
        for (var T = [], M = 0, R = E._first; R; )
          R instanceof s ? T[M++] = R : (L && (T[M++] = R), T = T.concat(k(R, L)), M = T.length), R = R._next;
        return T;
      }, D = u.getAllTweens = function(E) {
        return k(x._rootTimeline, E).concat(k(x._rootFramesTimeline, E));
      };
      u.killAll = function(E, L, T, M) {
        L == null && (L = !0), T == null && (T = !0);
        var R, b, U, N = D(M != 0), j = N.length, J = L && T && M;
        for (U = 0; j > U; U++)
          b = N[U], (J || b instanceof a || (R = b.target === b.vars.onComplete) && T || L && !R) && (E ? b.totalTime(b._reversed ? 0 : b.totalDuration()) : b._enabled(!1, !1));
      }, u.killChildTweensOf = function(E, L) {
        if (E != null) {
          var T, M, R, b, U, N = g.tweenLookup;
          if (typeof E == "string" && (E = s.selector(E) || E), _(E) && (E = c(E)), S(E))
            for (b = E.length; --b > -1; )
              u.killChildTweensOf(E[b], L);
          else {
            T = [];
            for (R in N)
              for (M = N[R].target.parentNode; M; )
                M === E && (T = T.concat(N[R].tweens)), M = M.parentNode;
            for (U = T.length, b = 0; U > b; b++)
              L && T[b].totalTime(T[b].totalDuration()), T[b]._enabled(!1, !1);
          }
        }
      };
      var F = function(E, L, T, M) {
        L = L !== !1, T = T !== !1, M = M !== !1;
        for (var R, b, U = D(M), N = L && T && M, j = U.length; --j > -1; )
          b = U[j], (N || b instanceof a || (R = b.target === b.vars.onComplete) && T || L && !R) && b.paused(E);
      };
      return u.pauseAll = function(E, L, T) {
        F(!0, E, L, T);
      }, u.resumeAll = function(E, L, T) {
        F(!1, E, L, T);
      }, u.globalTimeScale = function(E) {
        var L = x._rootTimeline, T = s.ticker.time;
        return arguments.length ? (E = E || m, L._startTime = T - (T - L._startTime) * L._timeScale / E, L = x._rootFramesTimeline, T = s.ticker.frame, L._startTime = T - (T - L._startTime) * L._timeScale / E, L._timeScale = x._rootTimeline._timeScale = E, E) : L._timeScale;
      }, C.progress = function(E, L) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - E : E) + this._cycle * (this._duration + this._repeatDelay),
          L
        ) : this._time / this.duration();
      }, C.totalProgress = function(E, L) {
        return arguments.length ? this.totalTime(this.totalDuration() * E, L) : this._totalTime / this.totalDuration();
      }, C.time = function(E, L) {
        return arguments.length ? (this._dirty && this.totalDuration(), E > this._duration && (E = this._duration), this._yoyo && 1 & this._cycle ? E = this._duration - E + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (E += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(E, L)) : this._time;
      }, C.duration = function(E) {
        return arguments.length ? x.prototype.duration.call(this, E) : this._duration;
      }, C.totalDuration = function(E) {
        return arguments.length ? this._repeat === -1 ? this : this.duration(
          (E - this._repeat * this._repeatDelay) / (this._repeat + 1)
        ) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration);
      }, C.repeat = function(E) {
        return arguments.length ? (this._repeat = E, this._uncache(!0)) : this._repeat;
      }, C.repeatDelay = function(E) {
        return arguments.length ? (this._repeatDelay = E, this._uncache(!0)) : this._repeatDelay;
      }, C.yoyo = function(E) {
        return arguments.length ? (this._yoyo = E, this) : this._yoyo;
      }, u;
    },
    !0
  ), hn._gsDefine(
    "TimelineLite",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(x, a, s) {
      var c = function(T) {
        a.call(this, T), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
        var M, R, b = this.vars;
        for (R in b)
          M = b[R], _(M) && M.join("").indexOf("{self}") !== -1 && (b[R] = this._swapSelfInParams(M));
        _(b.tweens) && this.add(b.tweens, 0, b.align, b.stagger);
      }, d = 1e-10, u = s._internals, m = c._internals = {}, g = u.isSelector, _ = u.isArray, S = u.lazyTweens, C = u.lazyRender, O = hn._gsDefine.globals, k = function(T) {
        var M, R = {};
        for (M in T)
          R[M] = T[M];
        return R;
      }, D = function(T, M, R) {
        var b, U, N = T.cycle;
        for (b in N)
          U = N[b], T[b] = typeof U == "function" ? U(R, M[R]) : U[R % U.length];
        delete T.cycle;
      }, F = m.pauseCallback = function() {
      }, E = function(T) {
        var M, R = [], b = T.length;
        for (M = 0; M !== b; R.push(T[M++]))
          ;
        return R;
      }, L = c.prototype = new a();
      return c.version = "2.0.2", L.constructor = c, L.kill()._gc = L._forcingPlayhead = L._hasPause = !1, L.to = function(T, M, R, b) {
        var U = R.repeat && O.TweenMax || s;
        return M ? this.add(new U(T, M, R), b) : this.set(T, R, b);
      }, L.from = function(T, M, R, b) {
        return this.add((R.repeat && O.TweenMax || s).from(T, M, R), b);
      }, L.fromTo = function(T, M, R, b, U) {
        var N = b.repeat && O.TweenMax || s;
        return M ? this.add(N.fromTo(T, M, R, b), U) : this.set(T, b, U);
      }, L.staggerTo = function(T, M, R, b, U, N, j, J) {
        var K, ct, It = new c({
          onComplete: N,
          onCompleteParams: j,
          callbackScope: J,
          smoothChildTiming: this.smoothChildTiming
        }), et = R.cycle;
        for (typeof T == "string" && (T = s.selector(T) || T), T = T || [], g(T) && (T = E(T)), b = b || 0, 0 > b && (T = E(T), T.reverse(), b *= -1), ct = 0; ct < T.length; ct++)
          K = k(R), K.startAt && (K.startAt = k(K.startAt), K.startAt.cycle && D(K.startAt, T, ct)), et && (D(K, T, ct), K.duration != null && (M = K.duration, delete K.duration)), It.to(T[ct], M, K, ct * b);
        return this.add(It, U);
      }, L.staggerFrom = function(T, M, R, b, U, N, j, J) {
        return R.immediateRender = R.immediateRender != 0, R.runBackwards = !0, this.staggerTo(T, M, R, b, U, N, j, J);
      }, L.staggerFromTo = function(T, M, R, b, U, N, j, J, K) {
        return b.startAt = R, b.immediateRender = b.immediateRender != 0 && R.immediateRender != 0, this.staggerTo(T, M, b, U, N, j, J, K);
      }, L.call = function(T, M, R, b) {
        return this.add(s.delayedCall(0, T, M, R), b);
      }, L.set = function(T, M, R) {
        return R = this._parseTimeOrLabel(R, 0, !0), M.immediateRender == null && (M.immediateRender = R === this._time && !this._paused), this.add(new s(T, 0, M), R);
      }, c.exportRoot = function(T, M) {
        T = T || {}, T.smoothChildTiming == null && (T.smoothChildTiming = !0);
        var R, b, U, N, j = new c(T), J = j._timeline;
        for (M == null && (M = !0), J._remove(j, !0), j._startTime = 0, j._rawPrevTime = j._time = j._totalTime = J._time, U = J._first; U; )
          N = U._next, M && U instanceof s && U.target === U.vars.onComplete || (b = U._startTime - U._delay, 0 > b && (R = 1), j.add(U, b)), U = N;
        return J.add(j, 0), R && j.totalDuration(), j;
      }, L.add = function(T, M, R, b) {
        var U, N, j, J, K, ct;
        if (typeof M != "number" && (M = this._parseTimeOrLabel(M, 0, !0, T)), !(T instanceof x)) {
          if (T instanceof Array || T && T.push && _(T)) {
            for (R = R || "normal", b = b || 0, U = M, N = T.length, j = 0; N > j; j++)
              _(J = T[j]) && (J = new c({ tweens: J })), this.add(J, U), typeof J != "string" && typeof J != "function" && (R === "sequence" ? U = J._startTime + J.totalDuration() / J._timeScale : R === "start" && (J._startTime -= J.delay())), U += b;
            return this._uncache(!0);
          }
          if (typeof T == "string")
            return this.addLabel(T, M);
          if (typeof T != "function")
            throw "Cannot add " + T + " into the timeline; it is not a tween, timeline, function, or string.";
          T = s.delayedCall(0, T);
        }
        if (a.prototype.add.call(this, T, M), T._time && (U = Math.max(
          0,
          Math.min(
            T.totalDuration(),
            (this.rawTime() - T._startTime) * T._timeScale
          )
        ), Math.abs(U - T._totalTime) > 1e-5 && T.render(U, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
          for (K = this, ct = K.rawTime() > T._startTime; K._timeline; )
            ct && K._timeline.smoothChildTiming ? K.totalTime(K._totalTime, !0) : K._gc && K._enabled(!0, !1), K = K._timeline;
        return this;
      }, L.remove = function(T) {
        if (T instanceof x) {
          this._remove(T, !1);
          var M = T._timeline = T.vars.useFrames ? x._rootFramesTimeline : x._rootTimeline;
          return T._startTime = (T._paused ? T._pauseTime : M._time) - (T._reversed ? T.totalDuration() - T._totalTime : T._totalTime) / T._timeScale, this;
        }
        if (T instanceof Array || T && T.push && _(T)) {
          for (var R = T.length; --R > -1; )
            this.remove(T[R]);
          return this;
        }
        return typeof T == "string" ? this.removeLabel(T) : this.kill(null, T);
      }, L._remove = function(T, M) {
        a.prototype._remove.call(this, T, M);
        var R = this._last;
        return R ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this;
      }, L.append = function(T, M) {
        return this.add(T, this._parseTimeOrLabel(null, M, !0, T));
      }, L.insert = L.insertMultiple = function(T, M, R, b) {
        return this.add(T, M || 0, R, b);
      }, L.appendMultiple = function(T, M, R, b) {
        return this.add(T, this._parseTimeOrLabel(null, M, !0, T), R, b);
      }, L.addLabel = function(T, M) {
        return this._labels[T] = this._parseTimeOrLabel(M), this;
      }, L.addPause = function(T, M, R, b) {
        var U = s.delayedCall(0, F, R, b || this);
        return U.vars.onComplete = U.vars.onReverseComplete = M, U.data = "isPause", this._hasPause = !0, this.add(U, T);
      }, L.removeLabel = function(T) {
        return delete this._labels[T], this;
      }, L.getLabelTime = function(T) {
        return this._labels[T] != null ? this._labels[T] : -1;
      }, L._parseTimeOrLabel = function(T, M, R, b) {
        var U, N;
        if (b instanceof x && b.timeline === this)
          this.remove(b);
        else if (b && (b instanceof Array || b.push && _(b)))
          for (N = b.length; --N > -1; )
            b[N] instanceof x && b[N].timeline === this && this.remove(b[N]);
        if (U = typeof T != "number" || M ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, typeof M == "string")
          return this._parseTimeOrLabel(
            M,
            R && typeof T == "number" && this._labels[M] == null ? T - U : 0,
            R
          );
        if (M = M || 0, typeof T != "string" || !isNaN(T) && this._labels[T] == null)
          T == null && (T = U);
        else {
          if (N = T.indexOf("="), N === -1)
            return this._labels[T] == null ? R ? this._labels[T] = U + M : M : this._labels[T] + M;
          M = parseInt(T.charAt(N - 1) + "1", 10) * Number(T.substr(N + 1)), T = N > 1 ? this._parseTimeOrLabel(T.substr(0, N - 1), 0, R) : U;
        }
        return Number(T) + M;
      }, L.seek = function(T, M) {
        return this.totalTime(
          typeof T == "number" ? T : this._parseTimeOrLabel(T),
          M !== !1
        );
      }, L.stop = function() {
        return this.paused(!0);
      }, L.gotoAndPlay = function(T, M) {
        return this.play(T, M);
      }, L.gotoAndStop = function(T, M) {
        return this.pause(T, M);
      }, L.render = function(T, M, R) {
        this._gc && this._enabled(!0, !1);
        var b, U, N, j, J, K, ct, It = this._time, et = this._dirty ? this.totalDuration() : this._totalDuration, _t = this._startTime, G = this._timeScale, Pt = this._paused;
        if (It !== this._time && (T += this._time - It), T >= et - 1e-7 && T >= 0)
          this._totalTime = this._time = et, this._reversed || this._hasPausedChild() || (U = !0, j = "onComplete", J = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= T && T >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === d) && this._rawPrevTime !== T && this._first && (J = !0, this._rawPrevTime > d && (j = "onReverseComplete"))), this._rawPrevTime = this._duration || !M || T || this._rawPrevTime === T ? T : d, T = et + 1e-4;
        else if (1e-7 > T)
          if (this._totalTime = this._time = 0, (It !== 0 || this._duration === 0 && this._rawPrevTime !== d && (this._rawPrevTime > 0 || 0 > T && this._rawPrevTime >= 0)) && (j = "onReverseComplete", U = this._reversed), 0 > T)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (J = U = !0, j = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (J = !0), this._rawPrevTime = T;
          else {
            if (this._rawPrevTime = this._duration || !M || T || this._rawPrevTime === T ? T : d, T === 0 && U)
              for (b = this._first; b && b._startTime === 0; )
                b._duration || (U = !1), b = b._next;
            T = 0, this._initted || (J = !0);
          }
        else {
          if (this._hasPause && !this._forcingPlayhead && !M) {
            if (T >= It)
              for (b = this._first; b && b._startTime <= T && !K; )
                b._duration || b.data !== "isPause" || b.ratio || b._startTime === 0 && this._rawPrevTime === 0 || (K = b), b = b._next;
            else
              for (b = this._last; b && b._startTime >= T && !K; )
                b._duration || b.data === "isPause" && b._rawPrevTime > 0 && (K = b), b = b._prev;
            K && (this._time = T = K._startTime, this._totalTime = T + this._cycle * (this._totalDuration + this._repeatDelay));
          }
          this._totalTime = this._time = this._rawPrevTime = T;
        }
        if (this._time !== It && this._first || R || J || K) {
          if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== It && T > 0 && (this._active = !0), It === 0 && this.vars.onStart && (this._time === 0 && this._duration || M || this._callback("onStart")), ct = this._time, ct >= It)
            for (b = this._first; b && (N = b._next, ct === this._time && (!this._paused || Pt)); )
              (b._active || b._startTime <= ct && !b._paused && !b._gc) && (K === b && this.pause(), b._reversed ? b.render(
                (b._dirty ? b.totalDuration() : b._totalDuration) - (T - b._startTime) * b._timeScale,
                M,
                R
              ) : b.render((T - b._startTime) * b._timeScale, M, R)), b = N;
          else
            for (b = this._last; b && (N = b._prev, ct === this._time && (!this._paused || Pt)); ) {
              if (b._active || b._startTime <= It && !b._paused && !b._gc) {
                if (K === b) {
                  for (K = b._prev; K && K.endTime() > this._time; )
                    K.render(
                      K._reversed ? K.totalDuration() - (T - K._startTime) * K._timeScale : (T - K._startTime) * K._timeScale,
                      M,
                      R
                    ), K = K._prev;
                  K = null, this.pause();
                }
                b._reversed ? b.render(
                  (b._dirty ? b.totalDuration() : b._totalDuration) - (T - b._startTime) * b._timeScale,
                  M,
                  R
                ) : b.render((T - b._startTime) * b._timeScale, M, R);
              }
              b = N;
            }
          this._onUpdate && (M || (S.length && C(), this._callback("onUpdate"))), j && (this._gc || (_t === this._startTime || G !== this._timeScale) && (this._time === 0 || et >= this.totalDuration()) && (U && (S.length && C(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !M && this.vars[j] && this._callback(j)));
        }
      }, L._hasPausedChild = function() {
        for (var T = this._first; T; ) {
          if (T._paused || T instanceof c && T._hasPausedChild())
            return !0;
          T = T._next;
        }
        return !1;
      }, L.getChildren = function(T, M, R, b) {
        b = b || -9999999999;
        for (var U = [], N = this._first, j = 0; N; )
          N._startTime < b || (N instanceof s ? M !== !1 && (U[j++] = N) : (R !== !1 && (U[j++] = N), T !== !1 && (U = U.concat(N.getChildren(!0, M, R)), j = U.length))), N = N._next;
        return U;
      }, L.getTweensOf = function(T, M) {
        var R, b, U = this._gc, N = [], j = 0;
        for (U && this._enabled(!0, !0), R = s.getTweensOf(T), b = R.length; --b > -1; )
          (R[b].timeline === this || M && this._contains(R[b])) && (N[j++] = R[b]);
        return U && this._enabled(!1, !0), N;
      }, L.recent = function() {
        return this._recent;
      }, L._contains = function(T) {
        for (var M = T.timeline; M; ) {
          if (M === this)
            return !0;
          M = M.timeline;
        }
        return !1;
      }, L.shiftChildren = function(T, M, R) {
        R = R || 0;
        for (var b, U = this._first, N = this._labels; U; )
          U._startTime >= R && (U._startTime += T), U = U._next;
        if (M)
          for (b in N)
            N[b] >= R && (N[b] += T);
        return this._uncache(!0);
      }, L._kill = function(T, M) {
        if (!T && !M)
          return this._enabled(!1, !1);
        for (var R = M ? this.getTweensOf(M) : this.getChildren(!0, !0, !1), b = R.length, U = !1; --b > -1; )
          R[b]._kill(T, M) && (U = !0);
        return U;
      }, L.clear = function(T) {
        var M = this.getChildren(!1, !0, !0), R = M.length;
        for (this._time = this._totalTime = 0; --R > -1; )
          M[R]._enabled(!1, !1);
        return T !== !1 && (this._labels = {}), this._uncache(!0);
      }, L.invalidate = function() {
        for (var T = this._first; T; )
          T.invalidate(), T = T._next;
        return x.prototype.invalidate.call(this);
      }, L._enabled = function(T, M) {
        if (T === this._gc)
          for (var R = this._first; R; )
            R._enabled(T, !0), R = R._next;
        return a.prototype._enabled.call(this, T, M);
      }, L.totalTime = function(T, M, R) {
        this._forcingPlayhead = !0;
        var b = x.prototype.totalTime.apply(this, arguments);
        return this._forcingPlayhead = !1, b;
      }, L.duration = function(T) {
        return arguments.length ? (this.duration() !== 0 && T !== 0 && this.timeScale(this._duration / T), this) : (this._dirty && this.totalDuration(), this._duration);
      }, L.totalDuration = function(T) {
        if (!arguments.length) {
          if (this._dirty) {
            for (var M, R, b = 0, U = this._last, N = 999999999999; U; )
              M = U._prev, U._dirty && U.totalDuration(), U._startTime > N && this._sortChildren && !U._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(U, U._startTime - U._delay), this._calculatingDuration = 0) : N = U._startTime, U._startTime < 0 && !U._paused && (b -= U._startTime, this._timeline.smoothChildTiming && (this._startTime += U._startTime / this._timeScale, this._time -= U._startTime, this._totalTime -= U._startTime, this._rawPrevTime -= U._startTime), this.shiftChildren(-U._startTime, !1, -9999999999), N = 0), R = U._startTime + U._totalDuration / U._timeScale, R > b && (b = R), U = M;
            this._duration = this._totalDuration = b, this._dirty = !1;
          }
          return this._totalDuration;
        }
        return T && this.totalDuration() ? this.timeScale(this._totalDuration / T) : this;
      }, L.paused = function(T) {
        if (!T)
          for (var M = this._first, R = this._time; M; )
            M._startTime === R && M.data === "isPause" && (M._rawPrevTime = 0), M = M._next;
        return x.prototype.paused.apply(this, arguments);
      }, L.usesFrames = function() {
        for (var T = this._timeline; T._timeline; )
          T = T._timeline;
        return T === x._rootFramesTimeline;
      }, L.rawTime = function(T) {
        return T && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(T) - this._startTime) * this._timeScale;
      }, c;
    },
    !0
  ), hn._gsDefine(
    "TimelineMax",
    ["TimelineLite", "TweenLite", "easing.Ease"],
    function(x, a, s) {
      var c = function(O) {
        x.call(this, O), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0;
      }, d = 1e-10, u = a._internals, m = u.lazyTweens, g = u.lazyRender, _ = hn._gsDefine.globals, S = new s(null, null, 1, 0), C = c.prototype = new x();
      return C.constructor = c, C.kill()._gc = !1, c.version = "2.0.2", C.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), x.prototype.invalidate.call(this);
      }, C.addCallback = function(O, k, D, F) {
        return this.add(a.delayedCall(0, O, D, F), k);
      }, C.removeCallback = function(O, k) {
        if (O)
          if (k == null)
            this._kill(null, O);
          else
            for (var D = this.getTweensOf(O, !1), F = D.length, E = this._parseTimeOrLabel(k); --F > -1; )
              D[F]._startTime === E && D[F]._enabled(!1, !1);
        return this;
      }, C.removePause = function(O) {
        return this.removeCallback(x._internals.pauseCallback, O);
      }, C.tweenTo = function(O, k) {
        k = k || {};
        var D, F, E, L = {
          ease: S,
          useFrames: this.usesFrames(),
          immediateRender: !1,
          lazy: !1
        }, T = k.repeat && _.TweenMax || a;
        for (F in k)
          L[F] = k[F];
        return L.time = this._parseTimeOrLabel(O), D = Math.abs(Number(L.time) - this._time) / this._timeScale || 1e-3, E = new T(this, D, L), L.onStart = function() {
          E.target.paused(!0), E.vars.time === E.target.time() || D !== E.duration() || E.isFromTo || E.duration(
            Math.abs(E.vars.time - E.target.time()) / E.target._timeScale
          ).render(E.time(), !0, !0), k.onStart && k.onStart.apply(
            k.onStartScope || k.callbackScope || E,
            k.onStartParams || []
          );
        }, E;
      }, C.tweenFromTo = function(O, k, D) {
        D = D || {}, O = this._parseTimeOrLabel(O), D.startAt = {
          onComplete: this.seek,
          onCompleteParams: [O],
          callbackScope: this
        }, D.immediateRender = D.immediateRender !== !1;
        var F = this.tweenTo(k, D);
        return F.isFromTo = 1, F.duration(Math.abs(F.vars.time - O) / this._timeScale || 1e-3);
      }, C.render = function(O, k, D) {
        this._gc && this._enabled(!0, !1);
        var F, E, L, T, M, R, b, U, N = this._time, j = this._dirty ? this.totalDuration() : this._totalDuration, J = this._duration, K = this._totalTime, ct = this._startTime, It = this._timeScale, et = this._rawPrevTime, _t = this._paused, G = this._cycle;
        if (N !== this._time && (O += this._time - N), O >= j - 1e-7 && O >= 0)
          this._locked || (this._totalTime = j, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (E = !0, T = "onComplete", M = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= O && O >= -1e-7 || 0 > et || et === d) && et !== O && this._first && (M = !0, et > d && (T = "onReverseComplete"))), this._rawPrevTime = this._duration || !k || O || this._rawPrevTime === O ? O : d, this._yoyo && 1 & this._cycle ? this._time = O = 0 : (this._time = J, O = J + 1e-4);
        else if (1e-7 > O)
          if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (N !== 0 || J === 0 && et !== d && (et > 0 || 0 > O && et >= 0) && !this._locked) && (T = "onReverseComplete", E = this._reversed), 0 > O)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (M = E = !0, T = "onReverseComplete") : et >= 0 && this._first && (M = !0), this._rawPrevTime = O;
          else {
            if (this._rawPrevTime = J || !k || O || this._rawPrevTime === O ? O : d, O === 0 && E)
              for (F = this._first; F && F._startTime === 0; )
                F._duration || (E = !1), F = F._next;
            O = 0, this._initted || (M = !0);
          }
        else if (J === 0 && 0 > et && (M = !0), this._time = this._rawPrevTime = O, this._locked || (this._totalTime = O, this._repeat !== 0 && (R = J + this._repeatDelay, this._cycle = this._totalTime / R >> 0, this._cycle !== 0 && this._cycle === this._totalTime / R && O >= K && this._cycle--, this._time = this._totalTime - this._cycle * R, this._yoyo && 1 & this._cycle && (this._time = J - this._time), this._time > J ? (this._time = J, O = J + 1e-4) : this._time < 0 ? this._time = O = 0 : O = this._time)), this._hasPause && !this._forcingPlayhead && !k) {
          if (O = this._time, O >= N || this._repeat && G !== this._cycle)
            for (F = this._first; F && F._startTime <= O && !b; )
              F._duration || F.data !== "isPause" || F.ratio || F._startTime === 0 && this._rawPrevTime === 0 || (b = F), F = F._next;
          else
            for (F = this._last; F && F._startTime >= O && !b; )
              F._duration || F.data === "isPause" && F._rawPrevTime > 0 && (b = F), F = F._prev;
          b && b._startTime < J && (this._time = O = b._startTime, this._totalTime = O + this._cycle * (this._totalDuration + this._repeatDelay));
        }
        if (this._cycle !== G && !this._locked) {
          var Pt = this._yoyo && (1 & G) !== 0, Et = Pt === (this._yoyo && (1 & this._cycle) !== 0), At = this._totalTime, fe = this._cycle, re = this._rawPrevTime, Ft = this._time;
          if (this._totalTime = G * J, this._cycle < G ? Pt = !Pt : this._totalTime += J, this._time = N, this._rawPrevTime = J === 0 ? et - 1e-4 : et, this._cycle = G, this._locked = !0, N = Pt ? 0 : J, this.render(N, k, J === 0), k || this._gc || this.vars.onRepeat && (this._cycle = fe, this._locked = !1, this._callback("onRepeat")), N !== this._time || (Et && (this._cycle = G, this._locked = !0, N = Pt ? J + 1e-4 : -1e-4, this.render(N, !0, !1)), this._locked = !1, this._paused && !_t))
            return;
          this._time = Ft, this._totalTime = At, this._cycle = fe, this._rawPrevTime = re;
        }
        if (!(this._time !== N && this._first || D || M || b))
          return void (K !== this._totalTime && this._onUpdate && (k || this._callback("onUpdate")));
        if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== K && O > 0 && (this._active = !0), K === 0 && this.vars.onStart && (this._totalTime === 0 && this._totalDuration || k || this._callback("onStart")), U = this._time, U >= N)
          for (F = this._first; F && (L = F._next, U === this._time && (!this._paused || _t)); )
            (F._active || F._startTime <= this._time && !F._paused && !F._gc) && (b === F && this.pause(), F._reversed ? F.render(
              (F._dirty ? F.totalDuration() : F._totalDuration) - (O - F._startTime) * F._timeScale,
              k,
              D
            ) : F.render((O - F._startTime) * F._timeScale, k, D)), F = L;
        else
          for (F = this._last; F && (L = F._prev, U === this._time && (!this._paused || _t)); ) {
            if (F._active || F._startTime <= N && !F._paused && !F._gc) {
              if (b === F) {
                for (b = F._prev; b && b.endTime() > this._time; )
                  b.render(
                    b._reversed ? b.totalDuration() - (O - b._startTime) * b._timeScale : (O - b._startTime) * b._timeScale,
                    k,
                    D
                  ), b = b._prev;
                b = null, this.pause();
              }
              F._reversed ? F.render(
                (F._dirty ? F.totalDuration() : F._totalDuration) - (O - F._startTime) * F._timeScale,
                k,
                D
              ) : F.render((O - F._startTime) * F._timeScale, k, D);
            }
            F = L;
          }
        this._onUpdate && (k || (m.length && g(), this._callback("onUpdate"))), T && (this._locked || this._gc || (ct === this._startTime || It !== this._timeScale) && (this._time === 0 || j >= this.totalDuration()) && (E && (m.length && g(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !k && this.vars[T] && this._callback(T)));
      }, C.getActive = function(O, k, D) {
        O == null && (O = !0), k == null && (k = !0), D == null && (D = !1);
        var F, E, L = [], T = this.getChildren(O, k, D), M = 0, R = T.length;
        for (F = 0; R > F; F++)
          E = T[F], E.isActive() && (L[M++] = E);
        return L;
      }, C.getLabelAfter = function(O) {
        O || O !== 0 && (O = this._time);
        var k, D = this.getLabelsArray(), F = D.length;
        for (k = 0; F > k; k++)
          if (D[k].time > O)
            return D[k].name;
        return null;
      }, C.getLabelBefore = function(O) {
        O == null && (O = this._time);
        for (var k = this.getLabelsArray(), D = k.length; --D > -1; )
          if (k[D].time < O)
            return k[D].name;
        return null;
      }, C.getLabelsArray = function() {
        var O, k = [], D = 0;
        for (O in this._labels)
          k[D++] = { time: this._labels[O], name: O };
        return k.sort(function(F, E) {
          return F.time - E.time;
        }), k;
      }, C.invalidate = function() {
        return this._locked = !1, x.prototype.invalidate.call(this);
      }, C.progress = function(O, k) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - O : O) + this._cycle * (this._duration + this._repeatDelay),
          k
        ) : this._time / this.duration() || 0;
      }, C.totalProgress = function(O, k) {
        return arguments.length ? this.totalTime(this.totalDuration() * O, k) : this._totalTime / this.totalDuration() || 0;
      }, C.totalDuration = function(O) {
        return arguments.length ? this._repeat !== -1 && O ? this.timeScale(this.totalDuration() / O) : this : (this._dirty && (x.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration);
      }, C.time = function(O, k) {
        return arguments.length ? (this._dirty && this.totalDuration(), O > this._duration && (O = this._duration), this._yoyo && 1 & this._cycle ? O = this._duration - O + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (O += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(O, k)) : this._time;
      }, C.repeat = function(O) {
        return arguments.length ? (this._repeat = O, this._uncache(!0)) : this._repeat;
      }, C.repeatDelay = function(O) {
        return arguments.length ? (this._repeatDelay = O, this._uncache(!0)) : this._repeatDelay;
      }, C.yoyo = function(O) {
        return arguments.length ? (this._yoyo = O, this) : this._yoyo;
      }, C.currentLabel = function(O) {
        return arguments.length ? this.seek(O, !0) : this.getLabelBefore(this._time + 1e-8);
      }, c;
    },
    !0
  ), function() {
    var x = 180 / Math.PI, a = [], s = [], c = [], d = {}, u = hn._gsDefine.globals, m = function(T, M, R, b) {
      R === b && (R = b - (b - M) / 1e6), T === M && (M = T + (R - T) / 1e6), this.a = T, this.b = M, this.c = R, this.d = b, this.da = b - T, this.ca = R - T, this.ba = M - T;
    }, g = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", _ = function(T, M, R, b) {
      var U = { a: T }, N = {}, j = {}, J = { c: b }, K = (T + M) / 2, ct = (M + R) / 2, It = (R + b) / 2, et = (K + ct) / 2, _t = (ct + It) / 2, G = (_t - et) / 8;
      return U.b = K + (T - K) / 4, N.b = et + G, U.c = N.a = (U.b + N.b) / 2, N.c = j.a = (et + _t) / 2, j.b = _t - G, J.b = It + (b - It) / 4, j.c = J.a = (j.b + J.b) / 2, [U, N, j, J];
    }, S = function(T, M, R, b, U) {
      var N, j, J, K, ct, It, et, _t, G, Pt, Et, At, fe, re = T.length - 1, Ft = 0, Ot = T[0].a;
      for (N = 0; re > N; N++)
        ct = T[Ft], j = ct.a, J = ct.d, K = T[Ft + 1].d, U ? (Et = a[N], At = s[N], fe = (At + Et) * M * 0.25 / (b ? 0.5 : c[N] || 0.5), It = J - (J - j) * (b ? 0.5 * M : Et !== 0 ? fe / Et : 0), et = J + (K - J) * (b ? 0.5 * M : At !== 0 ? fe / At : 0), _t = J - (It + ((et - It) * (3 * Et / (Et + At) + 0.5) / 4 || 0))) : (It = J - (J - j) * M * 0.5, et = J + (K - J) * M * 0.5, _t = J - (It + et) / 2), It += _t, et += _t, ct.c = G = It, N !== 0 ? ct.b = Ot : ct.b = Ot = ct.a + 0.6 * (ct.c - ct.a), ct.da = J - j, ct.ca = G - j, ct.ba = Ot - j, R ? (Pt = _(j, Ot, G, J), T.splice(Ft, 1, Pt[0], Pt[1], Pt[2], Pt[3]), Ft += 4) : Ft++, Ot = et;
      ct = T[Ft], ct.b = Ot, ct.c = Ot + 0.4 * (ct.d - Ot), ct.da = ct.d - ct.a, ct.ca = ct.c - ct.a, ct.ba = Ot - ct.a, R && (Pt = _(ct.a, Ot, ct.c, ct.d), T.splice(Ft, 1, Pt[0], Pt[1], Pt[2], Pt[3]));
    }, C = function(T, M, R, b) {
      var U, N, j, J, K, ct, It = [];
      if (b)
        for (T = [b].concat(T), N = T.length; --N > -1; )
          typeof (ct = T[N][M]) == "string" && ct.charAt(1) === "=" && (T[N][M] = b[M] + Number(ct.charAt(0) + ct.substr(2)));
      if (U = T.length - 2, 0 > U)
        return It[0] = new m(T[0][M], 0, 0, T[0][M]), It;
      for (N = 0; U > N; N++)
        j = T[N][M], J = T[N + 1][M], It[N] = new m(j, 0, 0, J), R && (K = T[N + 2][M], a[N] = (a[N] || 0) + (J - j) * (J - j), s[N] = (s[N] || 0) + (K - J) * (K - J));
      return It[N] = new m(T[N][M], 0, 0, T[N + 1][M]), It;
    }, O = function(T, M, R, b, U, N) {
      var j, J, K, ct, It, et, _t, G, Pt = {}, Et = [], At = N || T[0];
      U = typeof U == "string" ? "," + U + "," : g, M == null && (M = 1);
      for (J in T[0])
        Et.push(J);
      if (T.length > 1) {
        for (G = T[T.length - 1], _t = !0, j = Et.length; --j > -1; )
          if (J = Et[j], Math.abs(At[J] - G[J]) > 0.05) {
            _t = !1;
            break;
          }
        _t && (T = T.concat(), N && T.unshift(N), T.push(T[1]), N = T[T.length - 3]);
      }
      for (a.length = s.length = c.length = 0, j = Et.length; --j > -1; )
        J = Et[j], d[J] = U.indexOf("," + J + ",") !== -1, Pt[J] = C(T, J, d[J], N);
      for (j = a.length; --j > -1; )
        a[j] = Math.sqrt(a[j]), s[j] = Math.sqrt(s[j]);
      if (!b) {
        for (j = Et.length; --j > -1; )
          if (d[J])
            for (K = Pt[Et[j]], et = K.length - 1, ct = 0; et > ct; ct++)
              It = K[ct + 1].da / s[ct] + K[ct].da / a[ct] || 0, c[ct] = (c[ct] || 0) + It * It;
        for (j = c.length; --j > -1; )
          c[j] = Math.sqrt(c[j]);
      }
      for (j = Et.length, ct = R ? 4 : 1; --j > -1; )
        J = Et[j], K = Pt[J], S(K, M, R, b, d[J]), _t && (K.splice(0, ct), K.splice(K.length - ct, ct));
      return Pt;
    }, k = function(T, M, R) {
      M = M || "soft";
      var b, U, N, j, J, K, ct, It, et, _t, G, Pt = {}, Et = M === "cubic" ? 3 : 2, At = M === "soft", fe = [];
      if (At && R && (T = [R].concat(T)), T == null || T.length < Et + 1)
        throw "invalid Bezier data";
      for (et in T[0])
        fe.push(et);
      for (K = fe.length; --K > -1; ) {
        for (et = fe[K], Pt[et] = J = [], _t = 0, It = T.length, ct = 0; It > ct; ct++)
          b = R == null ? T[ct][et] : typeof (G = T[ct][et]) == "string" && G.charAt(1) === "=" ? R[et] + Number(G.charAt(0) + G.substr(2)) : Number(G), At && ct > 1 && It - 1 > ct && (J[_t++] = (b + J[_t - 2]) / 2), J[_t++] = b;
        for (It = _t - Et + 1, _t = 0, ct = 0; It > ct; ct += Et)
          b = J[ct], U = J[ct + 1], N = J[ct + 2], j = Et === 2 ? 0 : J[ct + 3], J[_t++] = G = Et === 3 ? new m(b, U, N, j) : new m(b, (2 * U + b) / 3, (2 * U + N) / 3, N);
        J.length = _t;
      }
      return Pt;
    }, D = function(T, M, R) {
      for (var b, U, N, j, J, K, ct, It, et, _t, G, Pt = 1 / R, Et = T.length; --Et > -1; )
        for (_t = T[Et], N = _t.a, j = _t.d - N, J = _t.c - N, K = _t.b - N, b = U = 0, It = 1; R >= It; It++)
          ct = Pt * It, et = 1 - ct, b = U - (U = (ct * ct * j + 3 * et * (ct * J + et * K)) * ct), G = Et * R + It - 1, M[G] = (M[G] || 0) + b * b;
    }, F = function(T, M) {
      M = M >> 0 || 6;
      var R, b, U, N, j = [], J = [], K = 0, ct = 0, It = M - 1, et = [], _t = [];
      for (R in T)
        D(T[R], j, M);
      for (U = j.length, b = 0; U > b; b++)
        K += Math.sqrt(j[b]), N = b % M, _t[N] = K, N === It && (ct += K, N = b / M >> 0, et[N] = _t, J[N] = ct, K = 0, _t = []);
      return { length: ct, lengths: J, segments: et };
    }, E = hn._gsDefine.plugin({
      propName: "bezier",
      priority: -1,
      version: "1.3.8",
      API: 2,
      global: !0,
      init: function(T, M, R) {
        this._target = T, M instanceof Array && (M = { values: M }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = M.timeResolution == null ? 6 : parseInt(M.timeResolution, 10);
        var b, U, N, j, J, K = M.values || [], ct = {}, It = K[0], et = M.autoRotate || R.vars.orientToBezier;
        this._autoRotate = et ? et instanceof Array ? et : [["x", "y", "rotation", et === !0 ? 0 : Number(et) || 0]] : null;
        for (b in It)
          this._props.push(b);
        for (N = this._props.length; --N > -1; )
          b = this._props[N], this._overwriteProps.push(b), U = this._func[b] = typeof T[b] == "function", ct[b] = U ? T[b.indexOf("set") || typeof T["get" + b.substr(3)] != "function" ? b : "get" + b.substr(3)]() : parseFloat(T[b]), J || ct[b] !== K[0][b] && (J = ct);
        if (this._beziers = M.type !== "cubic" && M.type !== "quadratic" && M.type !== "soft" ? O(
          K,
          isNaN(M.curviness) ? 1 : M.curviness,
          !1,
          M.type === "thruBasic",
          M.correlate,
          J
        ) : k(K, M.type, ct), this._segCount = this._beziers[b].length, this._timeRes) {
          var _t = F(this._beziers, this._timeRes);
          this._length = _t.length, this._lengths = _t.lengths, this._segments = _t.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length;
        }
        if (et = this._autoRotate)
          for (this._initialRotations = [], et[0] instanceof Array || (this._autoRotate = et = [et]), N = et.length; --N > -1; ) {
            for (j = 0; 3 > j; j++)
              b = et[N][j], this._func[b] = typeof T[b] == "function" ? T[b.indexOf("set") || typeof T["get" + b.substr(3)] != "function" ? b : "get" + b.substr(3)] : !1;
            b = et[N][2], this._initialRotations[N] = (this._func[b] ? this._func[b].call(this._target) : this._target[b]) || 0, this._overwriteProps.push(b);
          }
        return this._startRatio = R.vars.runBackwards ? 1 : 0, !0;
      },
      set: function(T) {
        var M, R, b, U, N, j, J, K, ct, It, et = this._segCount, _t = this._func, G = this._target, Pt = T !== this._startRatio;
        if (this._timeRes) {
          if (ct = this._lengths, It = this._curSeg, T *= this._length, b = this._li, T > this._l2 && et - 1 > b) {
            for (K = et - 1; K > b && (this._l2 = ct[++b]) <= T; )
              ;
            this._l1 = ct[b - 1], this._li = b, this._curSeg = It = this._segments[b], this._s2 = It[this._s1 = this._si = 0];
          } else if (T < this._l1 && b > 0) {
            for (; b > 0 && (this._l1 = ct[--b]) >= T; )
              ;
            b === 0 && T < this._l1 ? this._l1 = 0 : b++, this._l2 = ct[b], this._li = b, this._curSeg = It = this._segments[b], this._s1 = It[(this._si = It.length - 1) - 1] || 0, this._s2 = It[this._si];
          }
          if (M = b, T -= this._l1, b = this._si, T > this._s2 && b < It.length - 1) {
            for (K = It.length - 1; K > b && (this._s2 = It[++b]) <= T; )
              ;
            this._s1 = It[b - 1], this._si = b;
          } else if (T < this._s1 && b > 0) {
            for (; b > 0 && (this._s1 = It[--b]) >= T; )
              ;
            b === 0 && T < this._s1 ? this._s1 = 0 : b++, this._s2 = It[b], this._si = b;
          }
          j = (b + (T - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
        } else
          M = 0 > T ? 0 : T >= 1 ? et - 1 : et * T >> 0, j = (T - M * (1 / et)) * et;
        for (R = 1 - j, b = this._props.length; --b > -1; )
          U = this._props[b], N = this._beziers[U][M], J = (j * j * N.da + 3 * R * (j * N.ca + R * N.ba)) * j + N.a, this._mod[U] && (J = this._mod[U](J, G)), _t[U] ? G[U](J) : G[U] = J;
        if (this._autoRotate) {
          var Et, At, fe, re, Ft, Ot, Bt, ke = this._autoRotate;
          for (b = ke.length; --b > -1; )
            U = ke[b][2], Ot = ke[b][3] || 0, Bt = ke[b][4] === !0 ? 1 : x, N = this._beziers[ke[b][0]], Et = this._beziers[ke[b][1]], N && Et && (N = N[M], Et = Et[M], At = N.a + (N.b - N.a) * j, re = N.b + (N.c - N.b) * j, At += (re - At) * j, re += (N.c + (N.d - N.c) * j - re) * j, fe = Et.a + (Et.b - Et.a) * j, Ft = Et.b + (Et.c - Et.b) * j, fe += (Ft - fe) * j, Ft += (Et.c + (Et.d - Et.c) * j - Ft) * j, J = Pt ? Math.atan2(Ft - fe, re - At) * Bt + Ot : this._initialRotations[b], this._mod[U] && (J = this._mod[U](J, G)), _t[U] ? G[U](J) : G[U] = J);
        }
      }
    }), L = E.prototype;
    E.bezierThrough = O, E.cubicToQuadratic = _, E._autoCSS = !0, E.quadraticToCubic = function(T, M, R) {
      return new m(T, (2 * M + T) / 3, (2 * M + R) / 3, R);
    }, E._cssRegister = function() {
      var T = u.CSSPlugin;
      if (T) {
        var M = T._internals, R = M._parseToProxy, b = M._setPluginRatio, U = M.CSSPropTween;
        M._registerComplexSpecialProp("bezier", {
          parser: function(N, j, J, K, ct, It) {
            j instanceof Array && (j = { values: j }), It = new E();
            var et, _t, G, Pt = j.values, Et = Pt.length - 1, At = [], fe = {};
            if (0 > Et)
              return ct;
            for (et = 0; Et >= et; et++)
              G = R(N, Pt[et], K, ct, It, Et !== et), At[et] = G.end;
            for (_t in j)
              fe[_t] = j[_t];
            return fe.values = At, ct = new U(N, "bezier", 0, 0, G.pt, 2), ct.data = G, ct.plugin = It, ct.setRatio = b, fe.autoRotate === 0 && (fe.autoRotate = !0), !fe.autoRotate || fe.autoRotate instanceof Array || (et = fe.autoRotate === !0 ? 0 : Number(fe.autoRotate), fe.autoRotate = G.end.left != null ? [["left", "top", "rotation", et, !1]] : G.end.x != null ? [["x", "y", "rotation", et, !1]] : !1), fe.autoRotate && (K._transform || K._enableTransforms(!1), G.autoRotate = K._target._gsTransform, G.proxy.rotation = G.autoRotate.rotation || 0, K._overwriteProps.push("rotation")), It._onInitTween(G.proxy, fe, K._tween), ct;
          }
        });
      }
    }, L._mod = function(T) {
      for (var M, R = this._overwriteProps, b = R.length; --b > -1; )
        M = T[R[b]], M && typeof M == "function" && (this._mod[R[b]] = M);
    }, L._kill = function(T) {
      var M, R, b = this._props;
      for (M in this._beziers)
        if (M in T)
          for (delete this._beziers[M], delete this._func[M], R = b.length; --R > -1; )
            b[R] === M && b.splice(R, 1);
      if (b = this._autoRotate)
        for (R = b.length; --R > -1; )
          T[b[R][2]] && b.splice(R, 1);
      return this._super._kill.call(this, T);
    };
  }(), hn._gsDefine(
    "plugins.CSSPlugin",
    ["plugins.TweenPlugin", "TweenLite"],
    function(x, a) {
      var s, c, d, u, m = function() {
        x.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = m.prototype.setRatio;
      }, g = hn._gsDefine.globals, _ = {}, S = m.prototype = new x("css");
      S.constructor = m, m.version = "2.0.2", m.API = 2, m.defaultTransformPerspective = 0, m.defaultSkewType = "compensated", m.defaultSmoothOrigin = !0, S = "px", m.suffixMap = {
        top: S,
        right: S,
        bottom: S,
        left: S,
        width: S,
        height: S,
        fontSize: S,
        padding: S,
        margin: S,
        perspective: S,
        lineHeight: ""
      };
      var C, O, k, D, F, E, L, T, M = /(?:\-|\.|\b)(\d|\.|e\-)+/g, R = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, U = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, N = /(?:\d|\-|\+|=|#|\.)*/g, j = /opacity *= *([^)]*)/i, J = /opacity:([^;]*)/i, K = /alpha\(opacity *=.+?\)/i, ct = /^(rgb|hsl)/, It = /([A-Z])/g, et = /-([a-z])/gi, _t = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, G = function(V, tt) {
        return tt.toUpperCase();
      }, Pt = /(?:Left|Right|Width)/i, Et = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, At = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, fe = /,(?=[^\)]*(?:\(|$))/gi, re = /[\s,\(]/i, Ft = Math.PI / 180, Ot = 180 / Math.PI, Bt = {}, ke = { style: {} }, ce = hn.document || {
        createElement: function() {
          return ke;
        }
      }, Yt = function(V, tt) {
        return ce.createElementNS ? ce.createElementNS(tt || "http://www.w3.org/1999/xhtml", V) : ce.createElement(V);
      }, $e = Yt("div"), Li = Yt("img"), Oe = m._internals = { _specialProps: _ }, Ge = (hn.navigator || {}).userAgent || "", pi = function() {
        var V = Ge.indexOf("Android"), tt = Yt("a");
        return k = Ge.indexOf("Safari") !== -1 && Ge.indexOf("Chrome") === -1 && (V === -1 || parseFloat(Ge.substr(V + 8, 2)) > 3), F = k && parseFloat(Ge.substr(Ge.indexOf("Version/") + 8, 2)) < 6, D = Ge.indexOf("Firefox") !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Ge) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Ge)) && (E = parseFloat(RegExp.$1)), tt ? (tt.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(tt.style.opacity)) : !1;
      }(), Ri = function(V) {
        return j.test(
          typeof V == "string" ? V : (V.currentStyle ? V.currentStyle.filter : V.style.filter) || ""
        ) ? parseFloat(RegExp.$1) / 100 : 1;
      }, cn = function(V) {
        hn.console && console.log(V);
      }, Ji = "", W = "", Jt = function(V, tt) {
        tt = tt || $e;
        var lt, at, X = tt.style;
        if (X[V] !== void 0)
          return V;
        for (V = V.charAt(0).toUpperCase() + V.substr(1), lt = ["O", "Moz", "ms", "Ms", "Webkit"], at = 5; --at > -1 && X[lt[at] + V] === void 0; )
          ;
        return at >= 0 ? (W = at === 3 ? "ms" : lt[at], Ji = "-" + W.toLowerCase() + "-", W + V) : null;
      }, Wt = (typeof window < "u" ? window : ce.defaultView || { getComputedStyle: function() {
      } }).getComputedStyle, pt = m.getStyle = function(V, tt, lt, at, X) {
        var St;
        return pi || tt !== "opacity" ? (!at && V.style[tt] ? St = V.style[tt] : (lt = lt || Wt(V)) ? St = lt[tt] || lt.getPropertyValue(tt) || lt.getPropertyValue(tt.replace(It, "-$1").toLowerCase()) : V.currentStyle && (St = V.currentStyle[tt]), X == null || St && St !== "none" && St !== "auto" && St !== "auto auto" ? St : X) : Ri(V);
      }, dt = Oe.convertToPixels = function(V, tt, lt, at, X) {
        if (at === "px" || !at && tt !== "lineHeight")
          return lt;
        if (at === "auto" || !lt)
          return 0;
        var St, ht, Rt, Ht = Pt.test(tt), kt = V, Mt = $e.style, he = 0 > lt, se = lt === 1;
        if (he && (lt = -lt), se && (lt *= 100), tt !== "lineHeight" || at)
          if (at === "%" && tt.indexOf("border") !== -1)
            St = lt / 100 * (Ht ? V.clientWidth : V.clientHeight);
          else {
            if (Mt.cssText = "border:0 solid red;position:" + pt(V, "position") + ";line-height:0;", at !== "%" && kt.appendChild && at.charAt(0) !== "v" && at !== "rem")
              Mt[Ht ? "borderLeftWidth" : "borderTopWidth"] = lt + at;
            else {
              if (kt = V.parentNode || ce.body, pt(kt, "display").indexOf("flex") !== -1 && (Mt.position = "absolute"), ht = kt._gsCache, Rt = a.ticker.frame, ht && Ht && ht.time === Rt)
                return ht.width * lt / 100;
              Mt[Ht ? "width" : "height"] = lt + at;
            }
            kt.appendChild($e), St = parseFloat($e[Ht ? "offsetWidth" : "offsetHeight"]), kt.removeChild($e), Ht && at === "%" && m.cacheWidths !== !1 && (ht = kt._gsCache = kt._gsCache || {}, ht.time = Rt, ht.width = St / lt * 100), St !== 0 || X || (St = dt(V, tt, lt, at, !0));
          }
        else
          ht = Wt(V).lineHeight, V.style.lineHeight = lt, St = parseFloat(Wt(V).lineHeight), V.style.lineHeight = ht;
        return se && (St /= 100), he ? -St : St;
      }, Dt = Oe.calculateOffset = function(V, tt, lt) {
        if (pt(V, "position", lt) !== "absolute")
          return 0;
        var at = tt === "left" ? "Left" : "Top", X = pt(V, "margin" + at, lt);
        return V["offset" + at] - (dt(V, tt, parseFloat(X), X.replace(N, "")) || 0);
      }, ie = function(V, tt) {
        var lt, at, X, St = {};
        if (tt = tt || Wt(V, null))
          if (lt = tt.length)
            for (; --lt > -1; )
              X = tt[lt], (X.indexOf("-transform") === -1 || qs === X) && (St[X.replace(et, G)] = tt.getPropertyValue(X));
          else
            for (lt in tt)
              (lt.indexOf("Transform") === -1 || xn === lt) && (St[lt] = tt[lt]);
        else if (tt = V.currentStyle || V.style)
          for (lt in tt)
            typeof lt == "string" && St[lt] === void 0 && (St[lt.replace(et, G)] = tt[lt]);
        return pi || (St.opacity = Ri(V)), at = oo(V, tt, !1), St.rotation = at.rotation, St.skewX = at.skewX, St.scaleX = at.scaleX, St.scaleY = at.scaleY, St.x = at.x, St.y = at.y, dr && (St.z = at.z, St.rotationX = at.rotationX, St.rotationY = at.rotationY, St.scaleZ = at.scaleZ), St.filters && delete St.filters, St;
      }, Kt = function(V, tt, lt, at, X) {
        var St, ht, Rt, Ht = {}, kt = V.style;
        for (ht in lt)
          ht !== "cssText" && ht !== "length" && isNaN(ht) && (tt[ht] !== (St = lt[ht]) || X && X[ht]) && ht.indexOf("Origin") === -1 && (typeof St == "number" || typeof St == "string") && (Ht[ht] = St !== "auto" || ht !== "left" && ht !== "top" ? St !== "" && St !== "auto" && St !== "none" || typeof tt[ht] != "string" || tt[ht].replace(U, "") === "" ? St : 0 : Dt(V, ht), kt[ht] !== void 0 && (Rt = new ni(kt, ht, kt[ht], Rt)));
        if (at)
          for (ht in at)
            ht !== "className" && (Ht[ht] = at[ht]);
        return { difs: Ht, firstMPT: Rt };
      }, z = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, Q = ["marginLeft", "marginRight", "marginTop", "marginBottom"], st = function(V, tt, lt) {
        if ((V.nodeName + "").toLowerCase() === "svg")
          return (lt || Wt(V))[tt] || 0;
        if (V.getCTM && Na(V))
          return V.getBBox()[tt] || 0;
        var at = parseFloat(tt === "width" ? V.offsetWidth : V.offsetHeight), X = z[tt], St = X.length;
        for (lt = lt || Wt(V, null); --St > -1; )
          at -= parseFloat(pt(V, "padding" + X[St], lt, !0)) || 0, at -= parseFloat(pt(V, "border" + X[St] + "Width", lt, !0)) || 0;
        return at;
      }, nt = function(V, tt) {
        if (V === "contain" || V === "auto" || V === "auto auto")
          return V + " ";
        (V == null || V === "") && (V = "0 0");
        var lt, at = V.split(" "), X = V.indexOf("left") !== -1 ? "0%" : V.indexOf("right") !== -1 ? "100%" : at[0], St = V.indexOf("top") !== -1 ? "0%" : V.indexOf("bottom") !== -1 ? "100%" : at[1];
        if (at.length > 3 && !tt) {
          for (at = V.split(", ").join(",").split(","), V = [], lt = 0; lt < at.length; lt++)
            V.push(nt(at[lt]));
          return V.join(",");
        }
        return St == null ? St = X === "center" ? "50%" : "0" : St === "center" && (St = "50%"), (X === "center" || isNaN(parseFloat(X)) && (X + "").indexOf("=") === -1) && (X = "50%"), V = X + " " + St + (at.length > 2 ? " " + at[2] : ""), tt && (tt.oxp = X.indexOf("%") !== -1, tt.oyp = St.indexOf("%") !== -1, tt.oxr = X.charAt(1) === "=", tt.oyr = St.charAt(1) === "=", tt.ox = parseFloat(X.replace(U, "")), tt.oy = parseFloat(St.replace(U, "")), tt.v = V), tt || V;
      }, vt = function(V, tt) {
        return typeof V == "function" && (V = V(T, L)), typeof V == "string" && V.charAt(1) === "=" ? parseInt(V.charAt(0) + "1", 10) * parseFloat(V.substr(2)) : parseFloat(V) - parseFloat(tt) || 0;
      }, Gt = function(V, tt) {
        typeof V == "function" && (V = V(T, L));
        var lt = typeof V == "string" && V.charAt(1) === "=";
        return typeof V == "string" && V.charAt(V.length - 2) === "v" && (V = (lt ? V.substr(0, 2) : 0) + window["inner" + (V.substr(-2) === "vh" ? "Height" : "Width")] * (parseFloat(lt ? V.substr(2) : V) / 100)), V == null ? tt : lt ? parseInt(V.charAt(0) + "1", 10) * parseFloat(V.substr(2)) + tt : parseFloat(V) || 0;
      }, Xt = function(V, tt, lt, at) {
        var X, St, ht, Rt, Ht, kt = 1e-6;
        return typeof V == "function" && (V = V(T, L)), V == null ? Rt = tt : typeof V == "number" ? Rt = V : (X = 360, St = V.split("_"), Ht = V.charAt(1) === "=", ht = (Ht ? parseInt(V.charAt(0) + "1", 10) * parseFloat(St[0].substr(2)) : parseFloat(St[0])) * (V.indexOf("rad") === -1 ? 1 : Ot) - (Ht ? 0 : tt), St.length && (at && (at[lt] = tt + ht), V.indexOf("short") !== -1 && (ht %= X, ht !== ht % (X / 2) && (ht = 0 > ht ? ht + X : ht - X)), V.indexOf("_cw") !== -1 && 0 > ht ? ht = (ht + 9999999999 * X) % X - (ht / X | 0) * X : V.indexOf("ccw") !== -1 && ht > 0 && (ht = (ht - 9999999999 * X) % X - (ht / X | 0) * X)), Rt = tt + ht), kt > Rt && Rt > -kt && (Rt = 0), Rt;
      }, jt = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      }, Ne = function(V, tt, lt) {
        return V = 0 > V ? V + 1 : V > 1 ? V - 1 : V, 255 * (1 > 6 * V ? tt + (lt - tt) * V * 6 : 0.5 > V ? lt : 2 > 3 * V ? tt + (lt - tt) * (2 / 3 - V) * 6 : tt) + 0.5 | 0;
      }, Re = m.parseColor = function(V, tt) {
        var lt, at, X, St, ht, Rt, Ht, kt, Mt, he, se;
        if (V)
          if (typeof V == "number")
            lt = [V >> 16, V >> 8 & 255, 255 & V];
          else {
            if (V.charAt(V.length - 1) === "," && (V = V.substr(0, V.length - 1)), jt[V])
              lt = jt[V];
            else if (V.charAt(0) === "#")
              V.length === 4 && (at = V.charAt(1), X = V.charAt(2), St = V.charAt(3), V = "#" + at + at + X + X + St + St), V = parseInt(V.substr(1), 16), lt = [V >> 16, V >> 8 & 255, 255 & V];
            else if (V.substr(0, 3) === "hsl")
              if (lt = se = V.match(M), tt) {
                if (V.indexOf("=") !== -1)
                  return V.match(R);
              } else
                ht = Number(lt[0]) % 360 / 360, Rt = Number(lt[1]) / 100, Ht = Number(lt[2]) / 100, X = 0.5 >= Ht ? Ht * (Rt + 1) : Ht + Rt - Ht * Rt, at = 2 * Ht - X, lt.length > 3 && (lt[3] = Number(lt[3])), lt[0] = Ne(ht + 1 / 3, at, X), lt[1] = Ne(ht, at, X), lt[2] = Ne(ht - 1 / 3, at, X);
            else
              lt = V.match(M) || jt.transparent;
            lt[0] = Number(lt[0]), lt[1] = Number(lt[1]), lt[2] = Number(lt[2]), lt.length > 3 && (lt[3] = Number(lt[3]));
          }
        else
          lt = jt.black;
        return tt && !se && (at = lt[0] / 255, X = lt[1] / 255, St = lt[2] / 255, kt = Math.max(at, X, St), Mt = Math.min(at, X, St), Ht = (kt + Mt) / 2, kt === Mt ? ht = Rt = 0 : (he = kt - Mt, Rt = Ht > 0.5 ? he / (2 - kt - Mt) : he / (kt + Mt), ht = kt === at ? (X - St) / he + (St > X ? 6 : 0) : kt === X ? (St - at) / he + 2 : (at - X) / he + 4, ht *= 60), lt[0] = ht + 0.5 | 0, lt[1] = 100 * Rt + 0.5 | 0, lt[2] = 100 * Ht + 0.5 | 0), lt;
      }, ge = function(V, tt) {
        var lt, at, X, St = V.match(we) || [], ht = 0, Rt = "";
        if (!St.length)
          return V;
        for (lt = 0; lt < St.length; lt++)
          at = St[lt], X = V.substr(ht, V.indexOf(at, ht) - ht), ht += X.length + at.length, at = Re(at, tt), at.length === 3 && at.push(1), Rt += X + (tt ? "hsla(" + at[0] + "," + at[1] + "%," + at[2] + "%," + at[3] : "rgba(" + at.join(",")) + ")";
        return Rt + V.substr(ht);
      }, we = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
      for (S in jt)
        we += "|" + S + "\\b";
      we = new RegExp(we + ")", "gi"), m.colorStringFilter = function(V) {
        var tt, lt = V[0] + " " + V[1];
        we.test(lt) && (tt = lt.indexOf("hsl(") !== -1 || lt.indexOf("hsla(") !== -1, V[0] = ge(V[0], tt), V[1] = ge(V[1], tt)), we.lastIndex = 0;
      }, a.defaultStringFilter || (a.defaultStringFilter = m.colorStringFilter);
      var vi = function(V, tt, lt, at) {
        if (V == null)
          return function(se) {
            return se;
          };
        var X, St = tt ? (V.match(we) || [""])[0] : "", ht = V.split(St).join("").match(b) || [], Rt = V.substr(0, V.indexOf(ht[0])), Ht = V.charAt(V.length - 1) === ")" ? ")" : "", kt = V.indexOf(" ") !== -1 ? " " : ",", Mt = ht.length, he = Mt > 0 ? ht[0].replace(M, "") : "";
        return Mt ? X = tt ? function(se) {
          var te, ye, ue, je;
          if (typeof se == "number")
            se += he;
          else if (at && fe.test(se)) {
            for (je = se.replace(fe, "|").split("|"), ue = 0; ue < je.length; ue++)
              je[ue] = X(je[ue]);
            return je.join(",");
          }
          if (te = (se.match(we) || [St])[0], ye = se.split(te).join("").match(b) || [], ue = ye.length, Mt > ue--)
            for (; ++ue < Mt; )
              ye[ue] = lt ? ye[(ue - 1) / 2 | 0] : ht[ue];
          return Rt + ye.join(kt) + kt + te + Ht + (se.indexOf("inset") !== -1 ? " inset" : "");
        } : function(se) {
          var te, ye, ue;
          if (typeof se == "number")
            se += he;
          else if (at && fe.test(se)) {
            for (ye = se.replace(fe, "|").split("|"), ue = 0; ue < ye.length; ue++)
              ye[ue] = X(ye[ue]);
            return ye.join(",");
          }
          if (te = se.match(b) || [], ue = te.length, Mt > ue--)
            for (; ++ue < Mt; )
              te[ue] = lt ? te[(ue - 1) / 2 | 0] : ht[ue];
          return Rt + te.join(kt) + Ht;
        } : function(se) {
          return se;
        };
      }, Mi = function(V) {
        return V = V.split(","), function(tt, lt, at, X, St, ht, Rt) {
          var Ht, kt = (lt + "").split(" ");
          for (Rt = {}, Ht = 0; 4 > Ht; Ht++)
            Rt[V[Ht]] = kt[Ht] = kt[Ht] || kt[(Ht - 1) / 2 >> 0];
          return X.parse(tt, Rt, St, ht);
        };
      }, ni = (Oe._setPluginRatio = function(V) {
        this.plugin.setRatio(V);
        for (var tt, lt, at, X, St, ht = this.data, Rt = ht.proxy, Ht = ht.firstMPT, kt = 1e-6; Ht; )
          tt = Rt[Ht.v], Ht.r ? tt = Ht.r(tt) : kt > tt && tt > -kt && (tt = 0), Ht.t[Ht.p] = tt, Ht = Ht._next;
        if (ht.autoRotate && (ht.autoRotate.rotation = ht.mod ? ht.mod.call(this._tween, Rt.rotation, this.t, this._tween) : Rt.rotation), V === 1 || V === 0)
          for (Ht = ht.firstMPT, St = V === 1 ? "e" : "b"; Ht; ) {
            if (lt = Ht.t, lt.type) {
              if (lt.type === 1) {
                for (X = lt.xs0 + lt.s + lt.xs1, at = 1; at < lt.l; at++)
                  X += lt["xn" + at] + lt["xs" + (at + 1)];
                lt[St] = X;
              }
            } else
              lt[St] = lt.s + lt.xs0;
            Ht = Ht._next;
          }
      }, function(V, tt, lt, at, X) {
        this.t = V, this.p = tt, this.v = lt, this.r = X, at && (at._prev = this, this._next = at);
      }), Si = (Oe._parseToProxy = function(V, tt, lt, at, X, St) {
        var ht, Rt, Ht, kt, Mt, he = at, se = {}, te = {}, ye = lt._transform, ue = Bt;
        for (lt._transform = null, Bt = tt, at = Mt = lt.parse(V, tt, at, X), Bt = ue, St && (lt._transform = ye, he && (he._prev = null, he._prev && (he._prev._next = null))); at && at !== he; ) {
          if (at.type <= 1 && (Rt = at.p, te[Rt] = at.s + at.c, se[Rt] = at.s, St || (kt = new ni(at, "s", Rt, kt, at.r), at.c = 0), at.type === 1))
            for (ht = at.l; --ht > 0; )
              Ht = "xn" + ht, Rt = at.p + "_" + Ht, te[Rt] = at.data[Ht], se[Rt] = at[Ht], St || (kt = new ni(at, Ht, Rt, kt, at.rxp[Ht]));
          at = at._next;
        }
        return { proxy: se, end: te, firstMPT: kt, pt: Mt };
      }, Oe.CSSPropTween = function(V, tt, lt, at, X, St, ht, Rt, Ht, kt, Mt) {
        this.t = V, this.p = tt, this.s = lt, this.c = at, this.n = ht || tt, V instanceof Si || u.push(this.n), this.r = Rt && (typeof Rt == "function" ? Rt : Math.round), this.type = St || 0, Ht && (this.pr = Ht, s = !0), this.b = kt === void 0 ? lt : kt, this.e = Mt === void 0 ? lt + at : Mt, X && (this._next = X, X._prev = this);
      }), Gr = function(V, tt, lt, at, X, St) {
        var ht = new Si(V, tt, lt, at - lt, X, -1, St);
        return ht.b = lt, ht.e = ht.xs0 = at, ht;
      }, er = m.parseComplex = function(V, tt, lt, at, X, St, ht, Rt, Ht, kt) {
        lt = lt || St || "", typeof at == "function" && (at = at(T, L)), ht = new Si(V, tt, 0, 0, ht, kt ? 2 : 1, null, !1, Rt, lt, at), at += "", X && we.test(at + lt) && (at = [lt, at], m.colorStringFilter(at), lt = at[0], at = at[1]);
        var Mt, he, se, te, ye, ue, je, He, ui, Be, _e, Fe, pe, di = lt.split(", ").join(",").split(" "), Pe = at.split(", ").join(",").split(" "), xe = di.length, Le = C !== !1;
        for ((at.indexOf(",") !== -1 || lt.indexOf(",") !== -1) && ((at + lt).indexOf("rgb") !== -1 || (at + lt).indexOf("hsl") !== -1 ? (di = di.join(" ").replace(fe, ", ").split(" "), Pe = Pe.join(" ").replace(fe, ", ").split(" ")) : (di = di.join(" ").split(",").join(", ").split(" "), Pe = Pe.join(" ").split(",").join(", ").split(" ")), xe = di.length), xe !== Pe.length && (di = (St || "").split(" "), xe = di.length), ht.plugin = Ht, ht.setRatio = kt, we.lastIndex = 0, Mt = 0; xe > Mt; Mt++)
          if (te = di[Mt], ye = Pe[Mt] + "", He = parseFloat(te), He || He === 0)
            ht.appendXtra(
              "",
              He,
              vt(ye, He),
              ye.replace(R, ""),
              Le && ye.indexOf("px") !== -1 ? Math.round : !1,
              !0
            );
          else if (X && we.test(te))
            Fe = ye.indexOf(")") + 1, Fe = ")" + (Fe ? ye.substr(Fe) : ""), pe = ye.indexOf("hsl") !== -1 && pi, Be = ye, te = Re(te, pe), ye = Re(ye, pe), ui = te.length + ye.length > 6, ui && !pi && ye[3] === 0 ? (ht["xs" + ht.l] += ht.l ? " transparent" : "transparent", ht.e = ht.e.split(Pe[Mt]).join("transparent")) : (pi || (ui = !1), pe ? ht.appendXtra(
              Be.substr(0, Be.indexOf("hsl")) + (ui ? "hsla(" : "hsl("),
              te[0],
              vt(ye[0], te[0]),
              ",",
              !1,
              !0
            ).appendXtra("", te[1], vt(ye[1], te[1]), "%,", !1).appendXtra(
              "",
              te[2],
              vt(ye[2], te[2]),
              ui ? "%," : "%" + Fe,
              !1
            ) : ht.appendXtra(
              Be.substr(0, Be.indexOf("rgb")) + (ui ? "rgba(" : "rgb("),
              te[0],
              ye[0] - te[0],
              ",",
              Math.round,
              !0
            ).appendXtra("", te[1], ye[1] - te[1], ",", Math.round).appendXtra(
              "",
              te[2],
              ye[2] - te[2],
              ui ? "," : Fe,
              Math.round
            ), ui && (te = te.length < 4 ? 1 : te[3], ht.appendXtra(
              "",
              te,
              (ye.length < 4 ? 1 : ye[3]) - te,
              Fe,
              !1
            ))), we.lastIndex = 0;
          else if (ue = te.match(M)) {
            if (je = ye.match(R), !je || je.length !== ue.length)
              return ht;
            for (se = 0, he = 0; he < ue.length; he++)
              _e = ue[he], Be = te.indexOf(_e, se), ht.appendXtra(
                te.substr(se, Be - se),
                Number(_e),
                vt(je[he], _e),
                "",
                Le && te.substr(Be + _e.length, 2) === "px" ? Math.round : !1,
                he === 0
              ), se = Be + _e.length;
            ht["xs" + ht.l] += te.substr(se);
          } else
            ht["xs" + ht.l] += ht.l || ht["xs" + ht.l] ? " " + ye : ye;
        if (at.indexOf("=") !== -1 && ht.data) {
          for (Fe = ht.xs0 + ht.data.s, Mt = 1; Mt < ht.l; Mt++)
            Fe += ht["xs" + Mt] + ht.data["xn" + Mt];
          ht.e = Fe + ht["xs" + Mt];
        }
        return ht.l || (ht.type = -1, ht.xs0 = ht.e), ht.xfirst || ht;
      }, rn = 9;
      for (S = Si.prototype, S.l = S.pr = 0; --rn > 0; )
        S["xn" + rn] = 0, S["xs" + rn] = "";
      S.xs0 = "", S._next = S._prev = S.xfirst = S.data = S.plugin = S.setRatio = S.rxp = null, S.appendXtra = function(V, tt, lt, at, X, St) {
        var ht = this, Rt = ht.l;
        return ht["xs" + Rt] += St && (Rt || ht["xs" + Rt]) ? " " + V : V || "", lt || Rt === 0 || ht.plugin ? (ht.l++, ht.type = ht.setRatio ? 2 : 1, ht["xs" + ht.l] = at || "", Rt > 0 ? (ht.data["xn" + Rt] = tt + lt, ht.rxp["xn" + Rt] = X, ht["xn" + Rt] = tt, ht.plugin || (ht.xfirst = new Si(
          ht,
          "xn" + Rt,
          tt,
          lt,
          ht.xfirst || ht,
          0,
          ht.n,
          X,
          ht.pr
        ), ht.xfirst.xs0 = 0), ht) : (ht.data = { s: tt + lt }, ht.rxp = {}, ht.s = tt, ht.c = lt, ht.r = X, ht)) : (ht["xs" + Rt] += tt + (at || ""), ht);
      };
      var Co = function(V, tt) {
        tt = tt || {}, this.p = tt.prefix && Jt(V) || V, _[V] = _[this.p] = this, this.format = tt.formatter || vi(tt.defaultValue, tt.color, tt.collapsible, tt.multi), tt.parser && (this.parse = tt.parser), this.clrs = tt.color, this.multi = tt.multi, this.keyword = tt.keyword, this.dflt = tt.defaultValue, this.pr = tt.priority || 0;
      }, Oi = Oe._registerComplexSpecialProp = function(V, tt, lt) {
        typeof tt != "object" && (tt = { parser: lt });
        var at, X = V.split(","), St = tt.defaultValue;
        for (lt = lt || [St], at = 0; at < X.length; at++)
          tt.prefix = at === 0 && tt.prefix, tt.defaultValue = lt[at] || St, new Co(X[at], tt);
      }, Go = Oe._registerPluginProp = function(V) {
        if (!_[V]) {
          var tt = V.charAt(0).toUpperCase() + V.substr(1) + "Plugin";
          Oi(V, {
            parser: function(lt, at, X, St, ht, Rt, Ht) {
              var kt = g.com.greensock.plugins[tt];
              return kt ? (kt._cssRegister(), _[X].parse(lt, at, X, St, ht, Rt, Ht)) : (cn("Error: " + tt + " js file not loaded."), ht);
            }
          });
        }
      };
      S = Co.prototype, S.parseComplex = function(V, tt, lt, at, X, St) {
        var ht, Rt, Ht, kt, Mt, he, se = this.keyword;
        if (this.multi && (fe.test(lt) || fe.test(tt) ? (Rt = tt.replace(fe, "|").split("|"), Ht = lt.replace(fe, "|").split("|")) : se && (Rt = [tt], Ht = [lt])), Ht) {
          for (kt = Ht.length > Rt.length ? Ht.length : Rt.length, ht = 0; kt > ht; ht++)
            tt = Rt[ht] = Rt[ht] || this.dflt, lt = Ht[ht] = Ht[ht] || this.dflt, se && (Mt = tt.indexOf(se), he = lt.indexOf(se), Mt !== he && (he === -1 ? Rt[ht] = Rt[ht].split(se).join("") : Mt === -1 && (Rt[ht] += " " + se)));
          tt = Rt.join(", "), lt = Ht.join(", ");
        }
        return er(V, this.p, tt, lt, this.clrs, this.dflt, at, this.pr, X, St);
      }, S.parse = function(V, tt, lt, at, X, St, ht) {
        return this.parseComplex(
          V.style,
          this.format(pt(V, this.p, d, !1, this.dflt)),
          this.format(tt),
          X,
          St
        );
      }, m.registerSpecialProp = function(V, tt, lt) {
        Oi(V, {
          parser: function(at, X, St, ht, Rt, Ht, kt) {
            var Mt = new Si(at, St, 0, 0, Rt, 2, St, !1, lt);
            return Mt.plugin = Ht, Mt.setRatio = tt(at, X, ht._tween, St), Mt;
          },
          priority: lt
        });
      }, m.useSVGTransformAttr = !0;
      var io, Pl = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(
        ","
      ), xn = Jt("transform"), qs = Ji + "transform", us = Jt("transformOrigin"), dr = Jt("perspective") !== null, Ys = Oe.Transform = function() {
        this.perspective = parseFloat(m.defaultTransformPerspective) || 0, this.force3D = m.defaultForce3D !== !1 && dr ? m.defaultForce3D || "auto" : !1;
      }, ka = hn.SVGElement, Ll = function(V, tt, lt) {
        var at, X = ce.createElementNS("http://www.w3.org/2000/svg", V), St = /([a-z])([A-Z])/g;
        for (at in lt)
          X.setAttributeNS(null, at.replace(St, "$1-$2").toLowerCase(), lt[at]);
        return tt.appendChild(X), X;
      }, no = ce.documentElement || {}, mh = function() {
        var V, tt, lt, at = E || /Android/i.test(Ge) && !hn.chrome;
        return ce.createElementNS && !at && (V = Ll("svg", no), tt = Ll("rect", V, { width: 100, height: 50, x: 100 }), lt = tt.getBoundingClientRect().width, tt.style[us] = "50% 50%", tt.style[xn] = "scaleX(0.5)", at = lt === tt.getBoundingClientRect().width && !(D && dr), no.removeChild(V)), at;
      }(), Zs = function(V, tt, lt, at, X, St) {
        var ht, Rt, Ht, kt, Mt, he, se, te, ye, ue, je, He, ui, Be, _e = V._gsTransform, Fe = $s(V, !0);
        _e && (ui = _e.xOrigin, Be = _e.yOrigin), (!at || (ht = at.split(" ")).length < 2) && (se = V.getBBox(), se.x === 0 && se.y === 0 && se.width + se.height === 0 && (se = {
          x: parseFloat(
            V.hasAttribute("x") ? V.getAttribute("x") : V.hasAttribute("cx") ? V.getAttribute("cx") : 0
          ) || 0,
          y: parseFloat(
            V.hasAttribute("y") ? V.getAttribute("y") : V.hasAttribute("cy") ? V.getAttribute("cy") : 0
          ) || 0,
          width: 0,
          height: 0
        }), tt = nt(tt).split(" "), ht = [
          (tt[0].indexOf("%") !== -1 ? parseFloat(tt[0]) / 100 * se.width : parseFloat(tt[0])) + se.x,
          (tt[1].indexOf("%") !== -1 ? parseFloat(tt[1]) / 100 * se.height : parseFloat(tt[1])) + se.y
        ]), lt.xOrigin = kt = parseFloat(ht[0]), lt.yOrigin = Mt = parseFloat(ht[1]), at && Fe !== Js && (he = Fe[0], se = Fe[1], te = Fe[2], ye = Fe[3], ue = Fe[4], je = Fe[5], He = he * ye - se * te, He && (Rt = kt * (ye / He) + Mt * (-te / He) + (te * je - ye * ue) / He, Ht = kt * (-se / He) + Mt * (he / He) - (he * je - se * ue) / He, kt = lt.xOrigin = ht[0] = Rt, Mt = lt.yOrigin = ht[1] = Ht)), _e && (St && (lt.xOffset = _e.xOffset, lt.yOffset = _e.yOffset, _e = lt), X || X !== !1 && m.defaultSmoothOrigin !== !1 ? (Rt = kt - ui, Ht = Mt - Be, _e.xOffset += Rt * Fe[0] + Ht * Fe[2] - Rt, _e.yOffset += Rt * Fe[1] + Ht * Fe[3] - Ht) : _e.xOffset = _e.yOffset = 0), St || V.setAttribute("data-svg-origin", ht.join(" "));
      }, Ba = function(V) {
        var tt, lt = Yt(
          "svg",
          this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"
        ), at = this.parentNode, X = this.nextSibling, St = this.style.cssText;
        if (no.appendChild(lt), lt.appendChild(this), this.style.display = "block", V)
          try {
            tt = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ba;
          } catch {
          }
        else
          this._originalGetBBox && (tt = this._originalGetBBox());
        return X ? at.insertBefore(this, X) : at.appendChild(this), no.removeChild(lt), this.style.cssText = St, tt;
      }, ro = function(V) {
        try {
          return V.getBBox();
        } catch {
          return Ba.call(V, !0);
        }
      }, Na = function(V) {
        return !(!ka || !V.getCTM || V.parentNode && !V.ownerSVGElement || !ro(V));
      }, Js = [1, 0, 0, 1, 0, 0], $s = function(V, tt) {
        var lt, at, X, St, ht, Rt, Ht = V._gsTransform || new Ys(), kt = 1e5, Mt = V.style;
        if (xn ? at = pt(V, qs, null, !0) : V.currentStyle && (at = V.currentStyle.filter.match(Et), at = at && at.length === 4 ? [
          at[0].substr(4),
          Number(at[2].substr(4)),
          Number(at[1].substr(4)),
          at[3].substr(4),
          Ht.x || 0,
          Ht.y || 0
        ].join(",") : ""), lt = !at || at === "none" || at === "matrix(1, 0, 0, 1, 0, 0)", !xn || !(Rt = !Wt(V) || Wt(V).display === "none") && V.parentNode || (Rt && (St = Mt.display, Mt.display = "block"), V.parentNode || (ht = 1, no.appendChild(V)), at = pt(V, qs, null, !0), lt = !at || at === "none" || at === "matrix(1, 0, 0, 1, 0, 0)", St ? Mt.display = St : Rt && cs(Mt, "display"), ht && no.removeChild(V)), (Ht.svg || V.getCTM && Na(V)) && (lt && (Mt[xn] + "").indexOf("matrix") !== -1 && (at = Mt[xn], lt = 0), X = V.getAttribute("transform"), lt && X && (X = V.transform.baseVal.consolidate().matrix, at = "matrix(" + X.a + "," + X.b + "," + X.c + "," + X.d + "," + X.e + "," + X.f + ")", lt = 0)), lt)
          return Js;
        for (X = (at || "").match(M) || [], rn = X.length; --rn > -1; )
          St = Number(X[rn]), X[rn] = (ht = St - (St |= 0)) ? (ht * kt + (0 > ht ? -0.5 : 0.5) | 0) / kt + St : St;
        return tt && X.length > 6 ? [X[0], X[1], X[4], X[5], X[12], X[13]] : X;
      }, oo = Oe.getTransform = function(V, tt, lt, at) {
        if (V._gsTransform && lt && !at)
          return V._gsTransform;
        var X, St, ht, Rt, Ht, kt, Mt = lt ? V._gsTransform || new Ys() : new Ys(), he = Mt.scaleX < 0, se = 2e-5, te = 1e5, ye = dr && (parseFloat(pt(V, us, tt, !1, "0 0 0").split(" ")[2]) || Mt.zOrigin) || 0, ue = parseFloat(m.defaultTransformPerspective) || 0;
        if (Mt.svg = !(!V.getCTM || !Na(V)), Mt.svg && (Zs(
          V,
          pt(V, us, tt, !1, "50% 50%") + "",
          Mt,
          V.getAttribute("data-svg-origin")
        ), io = m.useSVGTransformAttr || mh), X = $s(V), X !== Js) {
          if (X.length === 16) {
            var je, He, ui, Be, _e, Fe = X[0], pe = X[1], di = X[2], Pe = X[3], xe = X[4], Le = X[5], wn = X[6], Hn = X[7], Ii = X[8], Di = X[9], Ui = X[10], Qi = X[12], tn = X[13], sn = X[14], an = X[11], Fi = Math.atan2(wn, Ui);
            Mt.zOrigin && (sn = -Mt.zOrigin, Qi = Ii * sn - X[12], tn = Di * sn - X[13], sn = Ui * sn + Mt.zOrigin - X[14]), Mt.rotationX = Fi * Ot, Fi && (Be = Math.cos(-Fi), _e = Math.sin(-Fi), je = xe * Be + Ii * _e, He = Le * Be + Di * _e, ui = wn * Be + Ui * _e, Ii = xe * -_e + Ii * Be, Di = Le * -_e + Di * Be, Ui = wn * -_e + Ui * Be, an = Hn * -_e + an * Be, xe = je, Le = He, wn = ui), Fi = Math.atan2(-di, Ui), Mt.rotationY = Fi * Ot, Fi && (Be = Math.cos(-Fi), _e = Math.sin(-Fi), je = Fe * Be - Ii * _e, He = pe * Be - Di * _e, ui = di * Be - Ui * _e, Di = pe * _e + Di * Be, Ui = di * _e + Ui * Be, an = Pe * _e + an * Be, Fe = je, pe = He, di = ui), Fi = Math.atan2(pe, Fe), Mt.rotation = Fi * Ot, Fi && (Be = Math.cos(Fi), _e = Math.sin(Fi), je = Fe * Be + pe * _e, He = xe * Be + Le * _e, ui = Ii * Be + Di * _e, pe = pe * Be - Fe * _e, Le = Le * Be - xe * _e, Di = Di * Be - Ii * _e, Fe = je, xe = He, Ii = ui), Mt.rotationX && Math.abs(Mt.rotationX) + Math.abs(Mt.rotation) > 359.9 && (Mt.rotationX = Mt.rotation = 0, Mt.rotationY = 180 - Mt.rotationY), Fi = Math.atan2(xe, Le), Mt.scaleX = (Math.sqrt(Fe * Fe + pe * pe + di * di) * te + 0.5 | 0) / te, Mt.scaleY = (Math.sqrt(Le * Le + wn * wn) * te + 0.5 | 0) / te, Mt.scaleZ = (Math.sqrt(Ii * Ii + Di * Di + Ui * Ui) * te + 0.5 | 0) / te, Fe /= Mt.scaleX, xe /= Mt.scaleY, pe /= Mt.scaleX, Le /= Mt.scaleY, Math.abs(Fi) > se ? (Mt.skewX = Fi * Ot, xe = 0, Mt.skewType !== "simple" && (Mt.scaleY *= 1 / Math.cos(Fi))) : Mt.skewX = 0, Mt.perspective = an ? 1 / (0 > an ? -an : an) : 0, Mt.x = Qi, Mt.y = tn, Mt.z = sn, Mt.svg && (Mt.x -= Mt.xOrigin - (Mt.xOrigin * Fe - Mt.yOrigin * xe), Mt.y -= Mt.yOrigin - (Mt.yOrigin * pe - Mt.xOrigin * Le));
          } else if (!dr || at || !X.length || Mt.x !== X[4] || Mt.y !== X[5] || !Mt.rotationX && !Mt.rotationY) {
            var zi = X.length >= 6, Vi = zi ? X[0] : 1, mi = X[1] || 0, so = X[2] || 0, Bn = zi ? X[3] : 1;
            Mt.x = X[4] || 0, Mt.y = X[5] || 0, ht = Math.sqrt(Vi * Vi + mi * mi), Rt = Math.sqrt(Bn * Bn + so * so), Ht = Vi || mi ? Math.atan2(mi, Vi) * Ot : Mt.rotation || 0, kt = so || Bn ? Math.atan2(so, Bn) * Ot + Ht : Mt.skewX || 0, Mt.scaleX = ht, Mt.scaleY = Rt, Mt.rotation = Ht, Mt.skewX = kt, dr && (Mt.rotationX = Mt.rotationY = Mt.z = 0, Mt.perspective = ue, Mt.scaleZ = 1), Mt.svg && (Mt.x -= Mt.xOrigin - (Mt.xOrigin * Vi + Mt.yOrigin * so), Mt.y -= Mt.yOrigin - (Mt.xOrigin * mi + Mt.yOrigin * Bn));
          }
          Math.abs(Mt.skewX) > 90 && Math.abs(Mt.skewX) < 270 && (he ? (Mt.scaleX *= -1, Mt.skewX += Mt.rotation <= 0 ? 180 : -180, Mt.rotation += Mt.rotation <= 0 ? 180 : -180) : (Mt.scaleY *= -1, Mt.skewX += Mt.skewX <= 0 ? 180 : -180)), Mt.zOrigin = ye;
          for (St in Mt)
            Mt[St] < se && Mt[St] > -se && (Mt[St] = 0);
        }
        return lt && (V._gsTransform = Mt, Mt.svg && (io && V.style[xn] ? a.delayedCall(1e-3, function() {
          cs(V.style, xn);
        }) : !io && V.getAttribute("transform") && a.delayedCall(1e-3, function() {
          V.removeAttribute("transform");
        }))), Mt;
      }, Rl = function(V) {
        var tt, lt, at = this.data, X = -at.rotation * Ft, St = X + at.skewX * Ft, ht = 1e5, Rt = (Math.cos(X) * at.scaleX * ht | 0) / ht, Ht = (Math.sin(X) * at.scaleX * ht | 0) / ht, kt = (Math.sin(St) * -at.scaleY * ht | 0) / ht, Mt = (Math.cos(St) * at.scaleY * ht | 0) / ht, he = this.t.style, se = this.t.currentStyle;
        if (se) {
          lt = Ht, Ht = -kt, kt = -lt, tt = se.filter, he.filter = "";
          var te, ye, ue = this.t.offsetWidth, je = this.t.offsetHeight, He = se.position !== "absolute", ui = "progid:DXImageTransform.Microsoft.Matrix(M11=" + Rt + ", M12=" + Ht + ", M21=" + kt + ", M22=" + Mt, Be = at.x + ue * at.xPercent / 100, _e = at.y + je * at.yPercent / 100;
          if (at.ox != null && (te = (at.oxp ? ue * at.ox * 0.01 : at.ox) - ue / 2, ye = (at.oyp ? je * at.oy * 0.01 : at.oy) - je / 2, Be += te - (te * Rt + ye * Ht), _e += ye - (te * kt + ye * Mt)), He ? (te = ue / 2, ye = je / 2, ui += ", Dx=" + (te - (te * Rt + ye * Ht) + Be) + ", Dy=" + (ye - (te * kt + ye * Mt) + _e) + ")") : ui += ", sizingMethod='auto expand')", tt.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? he.filter = tt.replace(At, ui) : he.filter = ui + " " + tt, (V === 0 || V === 1) && Rt === 1 && Ht === 0 && kt === 0 && Mt === 1 && (He && ui.indexOf("Dx=0, Dy=0") === -1 || j.test(tt) && parseFloat(RegExp.$1) !== 100 || tt.indexOf(tt.indexOf("Alpha")) === -1 && he.removeAttribute("filter")), !He) {
            var Fe, pe, di, Pe = 8 > E ? 1 : -1;
            for (te = at.ieOffsetX || 0, ye = at.ieOffsetY || 0, at.ieOffsetX = Math.round(
              (ue - ((0 > Rt ? -Rt : Rt) * ue + (0 > Ht ? -Ht : Ht) * je)) / 2 + Be
            ), at.ieOffsetY = Math.round(
              (je - ((0 > Mt ? -Mt : Mt) * je + (0 > kt ? -kt : kt) * ue)) / 2 + _e
            ), rn = 0; 4 > rn; rn++)
              pe = Q[rn], Fe = se[pe], lt = Fe.indexOf("px") !== -1 ? parseFloat(Fe) : dt(this.t, pe, parseFloat(Fe), Fe.replace(N, "")) || 0, di = lt !== at[pe] ? 2 > rn ? -at.ieOffsetX : -at.ieOffsetY : 2 > rn ? te - at.ieOffsetX : ye - at.ieOffsetY, he[pe] = (at[pe] = Math.round(
                lt - di * (rn === 0 || rn === 2 ? 1 : Pe)
              )) + "px";
          }
        }
      }, gh = Oe.set3DTransformRatio = Oe.setTransformRatio = function(V) {
        var tt, lt, at, X, St, ht, Rt, Ht, kt, Mt, he, se, te, ye, ue, je, He, ui, Be, _e, Fe, pe, di, Pe = this.data, xe = this.t.style, Le = Pe.rotation, wn = Pe.rotationX, Hn = Pe.rotationY, Ii = Pe.scaleX, Di = Pe.scaleY, Ui = Pe.scaleZ, Qi = Pe.x, tn = Pe.y, sn = Pe.z, an = Pe.svg, Fi = Pe.perspective, zi = Pe.force3D, Vi = Pe.skewY, mi = Pe.skewX;
        if (Vi && (mi += Vi, Le += Vi), ((V === 1 || V === 0) && zi === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !zi) && !sn && !Fi && !Hn && !wn && Ui === 1 || io && an || !dr)
          return void (Le || mi || an ? (Le *= Ft, pe = mi * Ft, di = 1e5, lt = Math.cos(Le) * Ii, St = Math.sin(Le) * Ii, at = Math.sin(Le - pe) * -Di, ht = Math.cos(Le - pe) * Di, pe && Pe.skewType === "simple" && (tt = Math.tan(pe - Vi * Ft), tt = Math.sqrt(1 + tt * tt), at *= tt, ht *= tt, Vi && (tt = Math.tan(Vi * Ft), tt = Math.sqrt(1 + tt * tt), lt *= tt, St *= tt)), an && (Qi += Pe.xOrigin - (Pe.xOrigin * lt + Pe.yOrigin * at) + Pe.xOffset, tn += Pe.yOrigin - (Pe.xOrigin * St + Pe.yOrigin * ht) + Pe.yOffset, io && (Pe.xPercent || Pe.yPercent) && (ue = this.t.getBBox(), Qi += 0.01 * Pe.xPercent * ue.width, tn += 0.01 * Pe.yPercent * ue.height), ue = 1e-6, ue > Qi && Qi > -ue && (Qi = 0), ue > tn && tn > -ue && (tn = 0)), Be = (lt * di | 0) / di + "," + (St * di | 0) / di + "," + (at * di | 0) / di + "," + (ht * di | 0) / di + "," + Qi + "," + tn + ")", an && io ? this.t.setAttribute("transform", "matrix(" + Be) : xe[xn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix(" : "matrix(") + Be) : xe[xn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix(" : "matrix(") + Ii + ",0,0," + Di + "," + Qi + "," + tn + ")");
        if (D && (ue = 1e-4, ue > Ii && Ii > -ue && (Ii = Ui = 2e-5), ue > Di && Di > -ue && (Di = Ui = 2e-5), !Fi || Pe.z || Pe.rotationX || Pe.rotationY || (Fi = 0)), Le || mi)
          Le *= Ft, je = lt = Math.cos(Le), He = St = Math.sin(Le), mi && (Le -= mi * Ft, je = Math.cos(Le), He = Math.sin(Le), Pe.skewType === "simple" && (tt = Math.tan((mi - Vi) * Ft), tt = Math.sqrt(1 + tt * tt), je *= tt, He *= tt, Pe.skewY && (tt = Math.tan(Vi * Ft), tt = Math.sqrt(1 + tt * tt), lt *= tt, St *= tt))), at = -He, ht = je;
        else {
          if (!(Hn || wn || Ui !== 1 || Fi || an))
            return void (xe[xn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) translate3d(" : "translate3d(") + Qi + "px," + tn + "px," + sn + "px)" + (Ii !== 1 || Di !== 1 ? " scale(" + Ii + "," + Di + ")" : ""));
          lt = ht = 1, at = St = 0;
        }
        Mt = 1, X = Rt = Ht = kt = he = se = 0, te = Fi ? -1 / Fi : 0, ye = Pe.zOrigin, ue = 1e-6, _e = ",", Fe = "0", Le = Hn * Ft, Le && (je = Math.cos(Le), He = Math.sin(Le), Ht = -He, he = te * -He, X = lt * He, Rt = St * He, Mt = je, te *= je, lt *= je, St *= je), Le = wn * Ft, Le && (je = Math.cos(Le), He = Math.sin(Le), tt = at * je + X * He, ui = ht * je + Rt * He, kt = Mt * He, se = te * He, X = at * -He + X * je, Rt = ht * -He + Rt * je, Mt *= je, te *= je, at = tt, ht = ui), Ui !== 1 && (X *= Ui, Rt *= Ui, Mt *= Ui, te *= Ui), Di !== 1 && (at *= Di, ht *= Di, kt *= Di, se *= Di), Ii !== 1 && (lt *= Ii, St *= Ii, Ht *= Ii, he *= Ii), (ye || an) && (ye && (Qi += X * -ye, tn += Rt * -ye, sn += Mt * -ye + ye), an && (Qi += Pe.xOrigin - (Pe.xOrigin * lt + Pe.yOrigin * at) + Pe.xOffset, tn += Pe.yOrigin - (Pe.xOrigin * St + Pe.yOrigin * ht) + Pe.yOffset), ue > Qi && Qi > -ue && (Qi = Fe), ue > tn && tn > -ue && (tn = Fe), ue > sn && sn > -ue && (sn = 0)), Be = Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix3d(" : "matrix3d(", Be += (ue > lt && lt > -ue ? Fe : lt) + _e + (ue > St && St > -ue ? Fe : St) + _e + (ue > Ht && Ht > -ue ? Fe : Ht), Be += _e + (ue > he && he > -ue ? Fe : he) + _e + (ue > at && at > -ue ? Fe : at) + _e + (ue > ht && ht > -ue ? Fe : ht), wn || Hn || Ui !== 1 ? (Be += _e + (ue > kt && kt > -ue ? Fe : kt) + _e + (ue > se && se > -ue ? Fe : se) + _e + (ue > X && X > -ue ? Fe : X), Be += _e + (ue > Rt && Rt > -ue ? Fe : Rt) + _e + (ue > Mt && Mt > -ue ? Fe : Mt) + _e + (ue > te && te > -ue ? Fe : te) + _e) : Be += ",0,0,0,0,1,0,", Be += Qi + _e + tn + _e + sn + _e + (Fi ? 1 + -sn / Fi : 1) + ")", xe[xn] = Be;
      };
      S = Ys.prototype, S.x = S.y = S.z = S.skewX = S.skewY = S.rotation = S.rotationX = S.rotationY = S.zOrigin = S.xPercent = S.yPercent = S.xOffset = S.yOffset = 0, S.scaleX = S.scaleY = S.scaleZ = 1, Oi(
        "transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",
        {
          parser: function(V, tt, lt, at, X, St, ht) {
            if (at._lastParsedTransform === ht)
              return X;
            at._lastParsedTransform = ht;
            var Rt, Ht = ht.scale && typeof ht.scale == "function" ? ht.scale : 0;
            typeof ht[lt] == "function" && (Rt = ht[lt], ht[lt] = tt), Ht && (ht.scale = Ht(T, V));
            var kt, Mt, he, se, te, ye, ue, je, He, ui = V._gsTransform, Be = V.style, _e = 1e-6, Fe = Pl.length, pe = ht, di = {}, Pe = "transformOrigin", xe = oo(V, d, !0, pe.parseTransform), Le = pe.transform && (typeof pe.transform == "function" ? pe.transform(T, L) : pe.transform);
            if (xe.skewType = pe.skewType || xe.skewType || m.defaultSkewType, at._transform = xe, "rotationZ" in pe && (pe.rotation = pe.rotationZ), Le && typeof Le == "string" && xn)
              Mt = $e.style, Mt[xn] = Le, Mt.display = "block", Mt.position = "absolute", Le.indexOf("%") !== -1 && (Mt.width = pt(V, "width"), Mt.height = pt(V, "height")), ce.body.appendChild($e), kt = oo($e, null, !1), xe.skewType === "simple" && (kt.scaleY *= Math.cos(kt.skewX * Ft)), xe.svg && (ye = xe.xOrigin, ue = xe.yOrigin, kt.x -= xe.xOffset, kt.y -= xe.yOffset, (pe.transformOrigin || pe.svgOrigin) && (Le = {}, Zs(
                V,
                nt(pe.transformOrigin),
                Le,
                pe.svgOrigin,
                pe.smoothOrigin,
                !0
              ), ye = Le.xOrigin, ue = Le.yOrigin, kt.x -= Le.xOffset - xe.xOffset, kt.y -= Le.yOffset - xe.yOffset), (ye || ue) && (je = $s($e, !0), kt.x -= ye - (ye * je[0] + ue * je[2]), kt.y -= ue - (ye * je[1] + ue * je[3]))), ce.body.removeChild($e), kt.perspective || (kt.perspective = xe.perspective), pe.xPercent != null && (kt.xPercent = Gt(pe.xPercent, xe.xPercent)), pe.yPercent != null && (kt.yPercent = Gt(pe.yPercent, xe.yPercent));
            else if (typeof pe == "object") {
              if (kt = {
                scaleX: Gt(
                  pe.scaleX != null ? pe.scaleX : pe.scale,
                  xe.scaleX
                ),
                scaleY: Gt(
                  pe.scaleY != null ? pe.scaleY : pe.scale,
                  xe.scaleY
                ),
                scaleZ: Gt(pe.scaleZ, xe.scaleZ),
                x: Gt(pe.x, xe.x),
                y: Gt(pe.y, xe.y),
                z: Gt(pe.z, xe.z),
                xPercent: Gt(pe.xPercent, xe.xPercent),
                yPercent: Gt(pe.yPercent, xe.yPercent),
                perspective: Gt(pe.transformPerspective, xe.perspective)
              }, te = pe.directionalRotation, te != null)
                if (typeof te == "object")
                  for (Mt in te)
                    pe[Mt] = te[Mt];
                else
                  pe.rotation = te;
              typeof pe.x == "string" && pe.x.indexOf("%") !== -1 && (kt.x = 0, kt.xPercent = Gt(pe.x, xe.xPercent)), typeof pe.y == "string" && pe.y.indexOf("%") !== -1 && (kt.y = 0, kt.yPercent = Gt(pe.y, xe.yPercent)), kt.rotation = Xt(
                "rotation" in pe ? pe.rotation : "shortRotation" in pe ? pe.shortRotation + "_short" : xe.rotation,
                xe.rotation,
                "rotation",
                di
              ), dr && (kt.rotationX = Xt(
                "rotationX" in pe ? pe.rotationX : "shortRotationX" in pe ? pe.shortRotationX + "_short" : xe.rotationX || 0,
                xe.rotationX,
                "rotationX",
                di
              ), kt.rotationY = Xt(
                "rotationY" in pe ? pe.rotationY : "shortRotationY" in pe ? pe.shortRotationY + "_short" : xe.rotationY || 0,
                xe.rotationY,
                "rotationY",
                di
              )), kt.skewX = Xt(pe.skewX, xe.skewX), kt.skewY = Xt(pe.skewY, xe.skewY);
            }
            for (dr && pe.force3D != null && (xe.force3D = pe.force3D, se = !0), he = xe.force3D || xe.z || xe.rotationX || xe.rotationY || kt.z || kt.rotationX || kt.rotationY || kt.perspective, he || pe.scale == null || (kt.scaleZ = 1); --Fe > -1; )
              He = Pl[Fe], Le = kt[He] - xe[He], (Le > _e || -_e > Le || pe[He] != null || Bt[He] != null) && (se = !0, X = new Si(xe, He, xe[He], Le, X), He in di && (X.e = di[He]), X.xs0 = 0, X.plugin = St, at._overwriteProps.push(X.n));
            return Le = pe.transformOrigin, xe.svg && (Le || pe.svgOrigin) && (ye = xe.xOffset, ue = xe.yOffset, Zs(V, nt(Le), kt, pe.svgOrigin, pe.smoothOrigin), X = Gr(
              xe,
              "xOrigin",
              (ui ? xe : kt).xOrigin,
              kt.xOrigin,
              X,
              Pe
            ), X = Gr(
              xe,
              "yOrigin",
              (ui ? xe : kt).yOrigin,
              kt.yOrigin,
              X,
              Pe
            ), (ye !== xe.xOffset || ue !== xe.yOffset) && (X = Gr(
              xe,
              "xOffset",
              ui ? ye : xe.xOffset,
              xe.xOffset,
              X,
              Pe
            ), X = Gr(
              xe,
              "yOffset",
              ui ? ue : xe.yOffset,
              xe.yOffset,
              X,
              Pe
            )), Le = "0px 0px"), (Le || dr && he && xe.zOrigin) && (xn ? (se = !0, He = us, Le = (Le || pt(V, He, d, !1, "50% 50%")) + "", X = new Si(Be, He, 0, 0, X, -1, Pe), X.b = Be[He], X.plugin = St, dr ? (Mt = xe.zOrigin, Le = Le.split(" "), xe.zOrigin = (Le.length > 2 && (Mt === 0 || Le[2] !== "0px") ? parseFloat(Le[2]) : Mt) || 0, X.xs0 = X.e = Le[0] + " " + (Le[1] || "50%") + " 0px", X = new Si(xe, "zOrigin", 0, 0, X, -1, X.n), X.b = Mt, X.xs0 = X.e = xe.zOrigin) : X.xs0 = X.e = Le) : nt(Le + "", xe)), se && (at._transformType = xe.svg && io || !he && this._transformType !== 3 ? 2 : 3), Rt && (ht[lt] = Rt), Ht && (ht.scale = Ht), X;
          },
          prefix: !0
        }
      ), Oi("boxShadow", {
        defaultValue: "0px 0px 0px 0px #999",
        prefix: !0,
        color: !0,
        multi: !0,
        keyword: "inset"
      }), Oi("borderRadius", {
        defaultValue: "0px",
        parser: function(V, tt, lt, at, X, St) {
          tt = this.format(tt);
          var ht, Rt, Ht, kt, Mt, he, se, te, ye, ue, je, He, ui, Be, _e, Fe, pe = [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomRightRadius",
            "borderBottomLeftRadius"
          ], di = V.style;
          for (ye = parseFloat(V.offsetWidth), ue = parseFloat(V.offsetHeight), ht = tt.split(" "), Rt = 0; Rt < pe.length; Rt++)
            this.p.indexOf("border") && (pe[Rt] = Jt(pe[Rt])), Mt = kt = pt(V, pe[Rt], d, !1, "0px"), Mt.indexOf(" ") !== -1 && (kt = Mt.split(" "), Mt = kt[0], kt = kt[1]), he = Ht = ht[Rt], se = parseFloat(Mt), He = Mt.substr((se + "").length), ui = he.charAt(1) === "=", ui ? (te = parseInt(he.charAt(0) + "1", 10), he = he.substr(2), te *= parseFloat(he), je = he.substr((te + "").length - (0 > te ? 1 : 0)) || "") : (te = parseFloat(he), je = he.substr((te + "").length)), je === "" && (je = c[lt] || He), je !== He && (Be = dt(V, "borderLeft", se, He), _e = dt(V, "borderTop", se, He), je === "%" ? (Mt = Be / ye * 100 + "%", kt = _e / ue * 100 + "%") : je === "em" ? (Fe = dt(V, "borderLeft", 1, "em"), Mt = Be / Fe + "em", kt = _e / Fe + "em") : (Mt = Be + "px", kt = _e + "px"), ui && (he = parseFloat(Mt) + te + je, Ht = parseFloat(kt) + te + je)), X = er(di, pe[Rt], Mt + " " + kt, he + " " + Ht, !1, "0px", X);
          return X;
        },
        prefix: !0,
        formatter: vi("0px 0px 0px 0px", !1, !0)
      }), Oi(
        "borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius",
        {
          defaultValue: "0px",
          parser: function(V, tt, lt, at, X, St) {
            return er(
              V.style,
              lt,
              this.format(pt(V, lt, d, !1, "0px 0px")),
              this.format(tt),
              !1,
              "0px",
              X
            );
          },
          prefix: !0,
          formatter: vi("0px 0px", !1, !0)
        }
      ), Oi("backgroundPosition", {
        defaultValue: "0 0",
        parser: function(V, tt, lt, at, X, St) {
          var ht, Rt, Ht, kt, Mt, he, se = "background-position", te = d || Wt(V, null), ye = this.format(
            (te ? E ? te.getPropertyValue(se + "-x") + " " + te.getPropertyValue(se + "-y") : te.getPropertyValue(se) : V.currentStyle.backgroundPositionX + " " + V.currentStyle.backgroundPositionY) || "0 0"
          ), ue = this.format(tt);
          if (ye.indexOf("%") !== -1 != (ue.indexOf("%") !== -1) && ue.split(",").length < 2 && (he = pt(V, "backgroundImage").replace(_t, ""), he && he !== "none")) {
            for (ht = ye.split(" "), Rt = ue.split(" "), Li.setAttribute("src", he), Ht = 2; --Ht > -1; )
              ye = ht[Ht], kt = ye.indexOf("%") !== -1, kt !== (Rt[Ht].indexOf("%") !== -1) && (Mt = Ht === 0 ? V.offsetWidth - Li.width : V.offsetHeight - Li.height, ht[Ht] = kt ? parseFloat(ye) / 100 * Mt + "px" : parseFloat(ye) / Mt * 100 + "%");
            ye = ht.join(" ");
          }
          return this.parseComplex(V.style, ye, ue, X, St);
        },
        formatter: nt
      }), Oi("backgroundSize", {
        defaultValue: "0 0",
        formatter: function(V) {
          return V += "", V.substr(0, 2) === "co" ? V : nt(V.indexOf(" ") === -1 ? V + " " + V : V);
        }
      }), Oi("perspective", { defaultValue: "0px", prefix: !0 }), Oi("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), Oi("transformStyle", { prefix: !0 }), Oi("backfaceVisibility", { prefix: !0 }), Oi("userSelect", { prefix: !0 }), Oi("margin", {
        parser: Mi("marginTop,marginRight,marginBottom,marginLeft")
      }), Oi("padding", {
        parser: Mi("paddingTop,paddingRight,paddingBottom,paddingLeft")
      }), Oi("clip", {
        defaultValue: "rect(0px,0px,0px,0px)",
        parser: function(V, tt, lt, at, X, St) {
          var ht, Rt, Ht;
          return 9 > E ? (Rt = V.currentStyle, Ht = 8 > E ? " " : ",", ht = "rect(" + Rt.clipTop + Ht + Rt.clipRight + Ht + Rt.clipBottom + Ht + Rt.clipLeft + ")", tt = this.format(tt).split(",").join(Ht)) : (ht = this.format(pt(V, this.p, d, !1, this.dflt)), tt = this.format(tt)), this.parseComplex(V.style, ht, tt, X, St);
        }
      }), Oi("textShadow", {
        defaultValue: "0px 0px 0px #999",
        color: !0,
        multi: !0
      }), Oi("autoRound,strictUnits", {
        parser: function(V, tt, lt, at, X) {
          return X;
        }
      }), Oi("border", {
        defaultValue: "0px solid #000",
        parser: function(V, tt, lt, at, X, St) {
          var ht = pt(V, "borderTopWidth", d, !1, "0px"), Rt = this.format(tt).split(" "), Ht = Rt[0].replace(N, "");
          return Ht !== "px" && (ht = parseFloat(ht) / dt(V, "borderTopWidth", 1, Ht) + Ht), this.parseComplex(
            V.style,
            this.format(
              ht + " " + pt(V, "borderTopStyle", d, !1, "solid") + " " + pt(V, "borderTopColor", d, !1, "#000")
            ),
            Rt.join(" "),
            X,
            St
          );
        },
        color: !0,
        formatter: function(V) {
          var tt = V.split(" ");
          return tt[0] + " " + (tt[1] || "solid") + " " + (V.match(we) || ["#000"])[0];
        }
      }), Oi("borderWidth", {
        parser: Mi(
          "borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth"
        )
      }), Oi("float,cssFloat,styleFloat", {
        parser: function(V, tt, lt, at, X, St) {
          var ht = V.style, Rt = "cssFloat" in ht ? "cssFloat" : "styleFloat";
          return new Si(ht, Rt, 0, 0, X, -1, lt, !1, 0, ht[Rt], tt);
        }
      });
      var vh = function(V) {
        var tt, lt = this.t, at = lt.filter || pt(this.data, "filter") || "", X = this.s + this.c * V | 0;
        X === 100 && (at.indexOf("atrix(") === -1 && at.indexOf("radient(") === -1 && at.indexOf("oader(") === -1 ? (lt.removeAttribute("filter"), tt = !pt(this.data, "filter")) : (lt.filter = at.replace(K, ""), tt = !0)), tt || (this.xn1 && (lt.filter = at = at || "alpha(opacity=" + X + ")"), at.indexOf("pacity") === -1 ? X === 0 && this.xn1 || (lt.filter = at + " alpha(opacity=" + X + ")") : lt.filter = at.replace(j, "opacity=" + X));
      };
      Oi("opacity,alpha,autoAlpha", {
        defaultValue: "1",
        parser: function(V, tt, lt, at, X, St) {
          var ht = parseFloat(pt(V, "opacity", d, !1, "1")), Rt = V.style, Ht = lt === "autoAlpha";
          return typeof tt == "string" && tt.charAt(1) === "=" && (tt = (tt.charAt(0) === "-" ? -1 : 1) * parseFloat(tt.substr(2)) + ht), Ht && ht === 1 && pt(V, "visibility", d) === "hidden" && tt !== 0 && (ht = 0), pi ? X = new Si(Rt, "opacity", ht, tt - ht, X) : (X = new Si(Rt, "opacity", 100 * ht, 100 * (tt - ht), X), X.xn1 = Ht ? 1 : 0, Rt.zoom = 1, X.type = 2, X.b = "alpha(opacity=" + X.s + ")", X.e = "alpha(opacity=" + (X.s + X.c) + ")", X.data = V, X.plugin = St, X.setRatio = vh), Ht && (X = new Si(
            Rt,
            "visibility",
            0,
            0,
            X,
            -1,
            null,
            !1,
            0,
            ht !== 0 ? "inherit" : "hidden",
            tt === 0 ? "hidden" : "inherit"
          ), X.xs0 = "inherit", at._overwriteProps.push(X.n), at._overwriteProps.push(lt)), X;
        }
      });
      var cs = function(V, tt) {
        tt && (V.removeProperty ? ((tt.substr(0, 2) === "ms" || tt.substr(0, 6) === "webkit") && (tt = "-" + tt), V.removeProperty(tt.replace(It, "-$1").toLowerCase())) : V.removeAttribute(tt));
      }, fs = function(V) {
        if (this.t._gsClassPT = this, V === 1 || V === 0) {
          this.t.setAttribute("class", V === 0 ? this.b : this.e);
          for (var tt = this.data, lt = this.t.style; tt; )
            tt.v ? lt[tt.p] = tt.v : cs(lt, tt.p), tt = tt._next;
          V === 1 && this.t._gsClassPT === this && (this.t._gsClassPT = null);
        } else
          this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
      };
      Oi("className", {
        parser: function(V, tt, lt, at, X, St, ht) {
          var Rt, Ht, kt, Mt, he, se = V.getAttribute("class") || "", te = V.style.cssText;
          if (X = at._classNamePT = new Si(V, lt, 0, 0, X, 2), X.setRatio = fs, X.pr = -11, s = !0, X.b = se, Ht = ie(V, d), kt = V._gsClassPT) {
            for (Mt = {}, he = kt.data; he; )
              Mt[he.p] = 1, he = he._next;
            kt.setRatio(1);
          }
          return V._gsClassPT = X, X.e = tt.charAt(1) !== "=" ? tt : se.replace(
            new RegExp("(?:\\s|^)" + tt.substr(2) + "(?![\\w-])"),
            ""
          ) + (tt.charAt(0) === "+" ? " " + tt.substr(2) : ""), V.setAttribute("class", X.e), Rt = Kt(V, Ht, ie(V), ht, Mt), V.setAttribute("class", se), X.data = Rt.firstMPT, V.style.cssText = te, X = X.xfirst = at.parse(V, Rt.difs, X, St);
        }
      });
      var Ol = function(V) {
        if ((V === 1 || V === 0) && this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
          var tt, lt, at, X, St, ht = this.t.style, Rt = _.transform.parse;
          if (this.e === "all")
            ht.cssText = "", X = !0;
          else
            for (tt = this.e.split(" ").join("").split(","), at = tt.length; --at > -1; )
              lt = tt[at], _[lt] && (_[lt].parse === Rt ? X = !0 : lt = lt === "transformOrigin" ? us : _[lt].p), cs(ht, lt);
          X && (cs(ht, xn), St = this.t._gsTransform, St && (St.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform));
        }
      };
      for (Oi("clearProps", {
        parser: function(V, tt, lt, at, X) {
          return X = new Si(V, lt, 0, 0, X, 2), X.setRatio = Ol, X.e = tt, X.pr = -10, X.data = at._tween, s = !0, X;
        }
      }), S = "bezier,throwProps,physicsProps,physics2D".split(","), rn = S.length; rn--; )
        Go(S[rn]);
      S = m.prototype, S._firstPT = S._lastParsedTransform = S._transform = null, S._onInitTween = function(V, tt, lt, at) {
        if (!V.nodeType)
          return !1;
        this._target = L = V, this._tween = lt, this._vars = tt, T = at, C = tt.autoRound, s = !1, c = tt.suffixMap || m.suffixMap, d = Wt(V, ""), u = this._overwriteProps;
        var X, St, ht, Rt, Ht, kt, Mt, he, se, te = V.style;
        if (O && te.zIndex === "" && (X = pt(V, "zIndex", d), (X === "auto" || X === "") && this._addLazySet(te, "zIndex", 0)), typeof tt == "string" && (Rt = te.cssText, X = ie(V, d), te.cssText = Rt + ";" + tt, X = Kt(V, X, ie(V)).difs, !pi && J.test(tt) && (X.opacity = parseFloat(RegExp.$1)), tt = X, te.cssText = Rt), tt.className ? this._firstPT = St = _.className.parse(
          V,
          tt.className,
          "className",
          this,
          null,
          null,
          tt
        ) : this._firstPT = St = this.parse(V, tt, null), this._transformType) {
          for (se = this._transformType === 3, xn ? k && (O = !0, te.zIndex === "" && (Mt = pt(V, "zIndex", d), (Mt === "auto" || Mt === "") && this._addLazySet(te, "zIndex", 0)), F && this._addLazySet(
            te,
            "WebkitBackfaceVisibility",
            this._vars.WebkitBackfaceVisibility || (se ? "visible" : "hidden")
          )) : te.zoom = 1, ht = St; ht && ht._next; )
            ht = ht._next;
          he = new Si(V, "transform", 0, 0, null, 2), this._linkCSSP(he, null, ht), he.setRatio = xn ? gh : Rl, he.data = this._transform || oo(V, d, !0), he.tween = lt, he.pr = -1, u.pop();
        }
        if (s) {
          for (; St; ) {
            for (kt = St._next, ht = Rt; ht && ht.pr > St.pr; )
              ht = ht._next;
            (St._prev = ht ? ht._prev : Ht) ? St._prev._next = St : Rt = St, (St._next = ht) ? ht._prev = St : Ht = St, St = kt;
          }
          this._firstPT = Rt;
        }
        return !0;
      }, S.parse = function(V, tt, lt, at) {
        var X, St, ht, Rt, Ht, kt, Mt, he, se, te, ye = V.style;
        for (X in tt) {
          if (kt = tt[X], typeof kt == "function" && (kt = kt(T, L)), St = _[X])
            lt = St.parse(V, kt, X, this, lt, at, tt);
          else {
            if (X.substr(0, 2) === "--") {
              this._tween._propLookup[X] = this._addTween.call(
                this._tween,
                V.style,
                "setProperty",
                Wt(V).getPropertyValue(X) + "",
                kt + "",
                X,
                !1,
                X
              );
              continue;
            }
            Ht = pt(V, X, d) + "", se = typeof kt == "string", X === "color" || X === "fill" || X === "stroke" || X.indexOf("Color") !== -1 || se && ct.test(kt) ? (se || (kt = Re(kt), kt = (kt.length > 3 ? "rgba(" : "rgb(") + kt.join(",") + ")"), lt = er(ye, X, Ht, kt, !0, "transparent", lt, 0, at)) : se && re.test(kt) ? lt = er(ye, X, Ht, kt, !0, null, lt, 0, at) : (ht = parseFloat(Ht), Mt = ht || ht === 0 ? Ht.substr((ht + "").length) : "", (Ht === "" || Ht === "auto") && (X === "width" || X === "height" ? (ht = st(V, X, d), Mt = "px") : X === "left" || X === "top" ? (ht = Dt(V, X, d), Mt = "px") : (ht = X !== "opacity" ? 0 : 1, Mt = "")), te = se && kt.charAt(1) === "=", te ? (Rt = parseInt(kt.charAt(0) + "1", 10), kt = kt.substr(2), Rt *= parseFloat(kt), he = kt.replace(N, "")) : (Rt = parseFloat(kt), he = se ? kt.replace(N, "") : ""), he === "" && (he = X in c ? c[X] : Mt), kt = Rt || Rt === 0 ? (te ? Rt + ht : Rt) + he : tt[X], Mt !== he && (he !== "" || X === "lineHeight") && (Rt || Rt === 0) && ht && (ht = dt(V, X, ht, Mt), he === "%" ? (ht /= dt(V, X, 100, "%") / 100, tt.strictUnits !== !0 && (Ht = ht + "%")) : he === "em" || he === "rem" || he === "vw" || he === "vh" ? ht /= dt(V, X, 1, he) : he !== "px" && (Rt = dt(V, X, Rt, he), he = "px"), te && (Rt || Rt === 0) && (kt = Rt + ht + he)), te && (Rt += ht), !ht && ht !== 0 || !Rt && Rt !== 0 ? ye[X] !== void 0 && (kt || kt + "" != "NaN" && kt != null) ? (lt = new Si(
              ye,
              X,
              Rt || ht || 0,
              0,
              lt,
              -1,
              X,
              !1,
              0,
              Ht,
              kt
            ), lt.xs0 = kt !== "none" || X !== "display" && X.indexOf("Style") === -1 ? kt : Ht) : cn("invalid " + X + " tween value: " + tt[X]) : (lt = new Si(
              ye,
              X,
              ht,
              Rt - ht,
              lt,
              0,
              X,
              C !== !1 && (he === "px" || X === "zIndex"),
              0,
              Ht,
              kt
            ), lt.xs0 = he));
          }
          at && lt && !lt.plugin && (lt.plugin = at);
        }
        return lt;
      }, S.setRatio = function(V) {
        var tt, lt, at, X = this._firstPT, St = 1e-6;
        if (V !== 1 || this._tween._time !== this._tween._duration && this._tween._time !== 0)
          if (V || this._tween._time !== this._tween._duration && this._tween._time !== 0 || this._tween._rawPrevTime === -1e-6)
            for (; X; ) {
              if (tt = X.c * V + X.s, X.r ? tt = X.r(tt) : St > tt && tt > -St && (tt = 0), X.type)
                if (X.type === 1)
                  if (at = X.l, at === 2)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2;
                  else if (at === 3)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2 + X.xn2 + X.xs3;
                  else if (at === 4)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2 + X.xn2 + X.xs3 + X.xn3 + X.xs4;
                  else if (at === 5)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2 + X.xn2 + X.xs3 + X.xn3 + X.xs4 + X.xn4 + X.xs5;
                  else {
                    for (lt = X.xs0 + tt + X.xs1, at = 1; at < X.l; at++)
                      lt += X["xn" + at] + X["xs" + (at + 1)];
                    X.t[X.p] = lt;
                  }
                else
                  X.type === -1 ? X.t[X.p] = X.xs0 : X.setRatio && X.setRatio(V);
              else
                X.t[X.p] = tt + X.xs0;
              X = X._next;
            }
          else
            for (; X; )
              X.type !== 2 ? X.t[X.p] = X.b : X.setRatio(V), X = X._next;
        else
          for (; X; ) {
            if (X.type !== 2)
              if (X.r && X.type !== -1)
                if (tt = X.r(X.s + X.c), X.type) {
                  if (X.type === 1) {
                    for (at = X.l, lt = X.xs0 + tt + X.xs1, at = 1; at < X.l; at++)
                      lt += X["xn" + at] + X["xs" + (at + 1)];
                    X.t[X.p] = lt;
                  }
                } else
                  X.t[X.p] = tt + X.xs0;
              else
                X.t[X.p] = X.e;
            else
              X.setRatio(V);
            X = X._next;
          }
      }, S._enableTransforms = function(V) {
        this._transform = this._transform || oo(this._target, d, !0), this._transformType = this._transform.svg && io || !V && this._transformType !== 3 ? 2 : 3;
      };
      var Il = function(V) {
        this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
      };
      S._addLazySet = function(V, tt, lt) {
        var at = this._firstPT = new Si(V, tt, 0, 0, this._firstPT, 2);
        at.e = lt, at.setRatio = Il, at.data = this;
      }, S._linkCSSP = function(V, tt, lt, at) {
        return V && (tt && (tt._prev = V), V._next && (V._next._prev = V._prev), V._prev ? V._prev._next = V._next : this._firstPT === V && (this._firstPT = V._next, at = !0), lt ? lt._next = V : at || this._firstPT !== null || (this._firstPT = V), V._next = tt, V._prev = lt), V;
      }, S._mod = function(V) {
        for (var tt = this._firstPT; tt; )
          typeof V[tt.p] == "function" && (tt.r = V[tt.p]), tt = tt._next;
      }, S._kill = function(V) {
        var tt, lt, at, X = V;
        if (V.autoAlpha || V.alpha) {
          X = {};
          for (lt in V)
            X[lt] = V[lt];
          X.opacity = 1, X.autoAlpha && (X.visibility = 1);
        }
        for (V.className && (tt = this._classNamePT) && (at = tt.xfirst, at && at._prev ? this._linkCSSP(at._prev, tt._next, at._prev._prev) : at === this._firstPT && (this._firstPT = tt._next), tt._next && this._linkCSSP(tt._next, tt._next._next, at._prev), this._classNamePT = null), tt = this._firstPT; tt; )
          tt.plugin && tt.plugin !== lt && tt.plugin._kill && (tt.plugin._kill(V), lt = tt.plugin), tt = tt._next;
        return x.prototype._kill.call(this, X);
      };
      var Hr = function(V, tt, lt) {
        var at, X, St, ht;
        if (V.slice)
          for (X = V.length; --X > -1; )
            Hr(V[X], tt, lt);
        else
          for (at = V.childNodes, X = at.length; --X > -1; )
            St = at[X], ht = St.type, St.style && (tt.push(ie(St)), lt && lt.push(St)), ht !== 1 && ht !== 9 && ht !== 11 || !St.childNodes.length || Hr(St, tt, lt);
      };
      return m.cascadeTo = function(V, tt, lt) {
        var at, X, St, ht, Rt = a.to(V, tt, lt), Ht = [Rt], kt = [], Mt = [], he = [], se = a._internals.reservedProps;
        for (V = Rt._targets || Rt.target, Hr(V, kt, he), Rt.render(tt, !0, !0), Hr(V, Mt), Rt.render(0, !0, !0), Rt._enabled(!0), at = he.length; --at > -1; )
          if (X = Kt(he[at], kt[at], Mt[at]), X.firstMPT) {
            X = X.difs;
            for (St in lt)
              se[St] && (X[St] = lt[St]);
            ht = {};
            for (St in X)
              ht[St] = kt[at][St];
            Ht.push(a.fromTo(he[at], tt, ht, X));
          }
        return Ht;
      }, x.activate([m]), m;
    },
    !0
  ), function() {
    var x = hn._gsDefine.plugin({
      propName: "roundProps",
      version: "1.7.0",
      priority: -1,
      API: 2,
      init: function(d, u, m) {
        return this._tween = m, !0;
      }
    }), a = function(d) {
      var u = 1 > d ? Math.pow(10, (d + "").length - 2) : 1;
      return function(m) {
        return (Math.round(m / d) * d * u | 0) / u;
      };
    }, s = function(d, u) {
      for (; d; )
        d.f || d.blob || (d.m = u || Math.round), d = d._next;
    }, c = x.prototype;
    c._onInitAllProps = function() {
      var d, u, m, g, _ = this._tween, S = _.vars.roundProps, C = {}, O = _._propLookup.roundProps;
      if (typeof S != "object" || S.push)
        for (typeof S == "string" && (S = S.split(",")), m = S.length; --m > -1; )
          C[S[m]] = Math.round;
      else
        for (g in S)
          C[g] = a(S[g]);
      for (g in C)
        for (d = _._firstPT; d; )
          u = d._next, d.pg ? d.t._mod(C) : d.n === g && (d.f === 2 && d.t ? s(d.t._firstPT, C[g]) : (this._add(d.t, g, d.s, d.c, C[g]), u && (u._prev = d._prev), d._prev ? d._prev._next = u : _._firstPT === d && (_._firstPT = u), d._next = d._prev = null, _._propLookup[g] = O)), d = u;
      return !1;
    }, c._add = function(d, u, m, g, _) {
      this._addTween(d, u, m, m + g, u, _ || Math.round), this._overwriteProps.push(u);
    };
  }(), function() {
    hn._gsDefine.plugin({
      propName: "attr",
      API: 2,
      version: "0.6.1",
      init: function(x, a, s, c) {
        var d, u;
        if (typeof x.setAttribute != "function")
          return !1;
        for (d in a)
          u = a[d], typeof u == "function" && (u = u(c, x)), this._addTween(
            x,
            "setAttribute",
            x.getAttribute(d) + "",
            u + "",
            d,
            !1,
            d
          ), this._overwriteProps.push(d);
        return !0;
      }
    });
  }(), hn._gsDefine.plugin({
    propName: "directionalRotation",
    version: "0.3.1",
    API: 2,
    init: function(x, a, s, c) {
      typeof a != "object" && (a = { rotation: a }), this.finals = {};
      var d, u, m, g, _, S, C = a.useRadians === !0 ? 2 * Math.PI : 360, O = 1e-6;
      for (d in a)
        d !== "useRadians" && (g = a[d], typeof g == "function" && (g = g(c, x)), S = (g + "").split("_"), u = S[0], m = parseFloat(
          typeof x[d] != "function" ? x[d] : x[d.indexOf("set") || typeof x["get" + d.substr(3)] != "function" ? d : "get" + d.substr(3)]()
        ), g = this.finals[d] = typeof u == "string" && u.charAt(1) === "=" ? m + parseInt(u.charAt(0) + "1", 10) * Number(u.substr(2)) : Number(u) || 0, _ = g - m, S.length && (u = S.join("_"), u.indexOf("short") !== -1 && (_ %= C, _ !== _ % (C / 2) && (_ = 0 > _ ? _ + C : _ - C)), u.indexOf("_cw") !== -1 && 0 > _ ? _ = (_ + 9999999999 * C) % C - (_ / C | 0) * C : u.indexOf("ccw") !== -1 && _ > 0 && (_ = (_ - 9999999999 * C) % C - (_ / C | 0) * C)), (_ > O || -O > _) && (this._addTween(x, d, m, m + _, d), this._overwriteProps.push(d)));
      return !0;
    },
    set: function(x) {
      var a;
      if (x !== 1)
        this._super.setRatio.call(this, x);
      else
        for (a = this._firstPT; a; )
          a.f ? a.t[a.p](this.finals[a.p]) : a.t[a.p] = this.finals[a.p], a = a._next;
    }
  })._autoCSS = !0, hn._gsDefine(
    "easing.Back",
    ["easing.Ease"],
    function(x) {
      var a, s, c, d, u = hn.GreenSockGlobals || hn, m = u.com.greensock, g = 2 * Math.PI, _ = Math.PI / 2, S = m._class, C = function(M, R) {
        var b = S("easing." + M, function() {
        }, !0), U = b.prototype = new x();
        return U.constructor = b, U.getRatio = R, b;
      }, O = x.register || function() {
      }, k = function(M, R, b, U, N) {
        var j = S(
          "easing." + M,
          { easeOut: new R(), easeIn: new b(), easeInOut: new U() },
          !0
        );
        return O(j, M), j;
      }, D = function(M, R, b) {
        this.t = M, this.v = R, b && (this.next = b, b.prev = this, this.c = b.v - R, this.gap = b.t - M);
      }, F = function(M, R) {
        var b = S(
          "easing." + M,
          function(N) {
            this._p1 = N || N === 0 ? N : 1.70158, this._p2 = 1.525 * this._p1;
          },
          !0
        ), U = b.prototype = new x();
        return U.constructor = b, U.getRatio = R, U.config = function(N) {
          return new b(N);
        }, b;
      }, E = k(
        "Back",
        F("BackOut", function(M) {
          return (M -= 1) * M * ((this._p1 + 1) * M + this._p1) + 1;
        }),
        F("BackIn", function(M) {
          return M * M * ((this._p1 + 1) * M - this._p1);
        }),
        F("BackInOut", function(M) {
          return (M *= 2) < 1 ? 0.5 * M * M * ((this._p2 + 1) * M - this._p2) : 0.5 * ((M -= 2) * M * ((this._p2 + 1) * M + this._p2) + 2);
        })
      ), L = S(
        "easing.SlowMo",
        function(M, R, b) {
          R = R || R === 0 ? R : 0.7, M == null ? M = 0.7 : M > 1 && (M = 1), this._p = M !== 1 ? R : 0, this._p1 = (1 - M) / 2, this._p2 = M, this._p3 = this._p1 + this._p2, this._calcEnd = b === !0;
        },
        !0
      ), T = L.prototype = new x();
      return T.constructor = L, T.getRatio = function(M) {
        var R = M + (0.5 - M) * this._p;
        return M < this._p1 ? this._calcEnd ? 1 - (M = 1 - M / this._p1) * M : R - (M = 1 - M / this._p1) * M * M * M * R : M > this._p3 ? this._calcEnd ? M === 1 ? 0 : 1 - (M = (M - this._p3) / this._p1) * M : R + (M - R) * (M = (M - this._p3) / this._p1) * M * M * M : this._calcEnd ? 1 : R;
      }, L.ease = new L(0.7, 0.7), T.config = L.config = function(M, R, b) {
        return new L(M, R, b);
      }, a = S(
        "easing.SteppedEase",
        function(M, R) {
          M = M || 1, this._p1 = 1 / M, this._p2 = M + (R ? 0 : 1), this._p3 = R ? 1 : 0;
        },
        !0
      ), T = a.prototype = new x(), T.constructor = a, T.getRatio = function(M) {
        return 0 > M ? M = 0 : M >= 1 && (M = 0.999999999), ((this._p2 * M | 0) + this._p3) * this._p1;
      }, T.config = a.config = function(M, R) {
        return new a(M, R);
      }, s = S(
        "easing.ExpoScaleEase",
        function(M, R, b) {
          this._p1 = Math.log(R / M), this._p2 = R - M, this._p3 = M, this._ease = b;
        },
        !0
      ), T = s.prototype = new x(), T.constructor = s, T.getRatio = function(M) {
        return this._ease && (M = this._ease.getRatio(M)), (this._p3 * Math.exp(this._p1 * M) - this._p3) / this._p2;
      }, T.config = s.config = function(M, R, b) {
        return new s(M, R, b);
      }, c = S(
        "easing.RoughEase",
        function(M) {
          M = M || {};
          for (var R, b, U, N, j, J, K = M.taper || "none", ct = [], It = 0, et = 0 | (M.points || 20), _t = et, G = M.randomize !== !1, Pt = M.clamp === !0, Et = M.template instanceof x ? M.template : null, At = typeof M.strength == "number" ? 0.4 * M.strength : 0.4; --_t > -1; )
            R = G ? Math.random() : 1 / et * _t, b = Et ? Et.getRatio(R) : R, K === "none" ? U = At : K === "out" ? (N = 1 - R, U = N * N * At) : K === "in" ? U = R * R * At : 0.5 > R ? (N = 2 * R, U = N * N * 0.5 * At) : (N = 2 * (1 - R), U = N * N * 0.5 * At), G ? b += Math.random() * U - 0.5 * U : _t % 2 ? b += 0.5 * U : b -= 0.5 * U, Pt && (b > 1 ? b = 1 : 0 > b && (b = 0)), ct[It++] = { x: R, y: b };
          for (ct.sort(function(fe, re) {
            return fe.x - re.x;
          }), J = new D(1, 1, null), _t = et; --_t > -1; )
            j = ct[_t], J = new D(j.x, j.y, J);
          this._prev = new D(0, 0, J.t !== 0 ? J : J.next);
        },
        !0
      ), T = c.prototype = new x(), T.constructor = c, T.getRatio = function(M) {
        var R = this._prev;
        if (M > R.t) {
          for (; R.next && M >= R.t; )
            R = R.next;
          R = R.prev;
        } else
          for (; R.prev && M <= R.t; )
            R = R.prev;
        return this._prev = R, R.v + (M - R.t) / R.gap * R.c;
      }, T.config = function(M) {
        return new c(M);
      }, c.ease = new c(), k(
        "Bounce",
        C("BounceOut", function(M) {
          return 1 / 2.75 > M ? 7.5625 * M * M : 2 / 2.75 > M ? 7.5625 * (M -= 1.5 / 2.75) * M + 0.75 : 2.5 / 2.75 > M ? 7.5625 * (M -= 2.25 / 2.75) * M + 0.9375 : 7.5625 * (M -= 2.625 / 2.75) * M + 0.984375;
        }),
        C("BounceIn", function(M) {
          return (M = 1 - M) < 1 / 2.75 ? 1 - 7.5625 * M * M : 2 / 2.75 > M ? 1 - (7.5625 * (M -= 1.5 / 2.75) * M + 0.75) : 2.5 / 2.75 > M ? 1 - (7.5625 * (M -= 2.25 / 2.75) * M + 0.9375) : 1 - (7.5625 * (M -= 2.625 / 2.75) * M + 0.984375);
        }),
        C("BounceInOut", function(M) {
          var R = 0.5 > M;
          return M = R ? 1 - 2 * M : 2 * M - 1, M = 1 / 2.75 > M ? 7.5625 * M * M : 2 / 2.75 > M ? 7.5625 * (M -= 1.5 / 2.75) * M + 0.75 : 2.5 / 2.75 > M ? 7.5625 * (M -= 2.25 / 2.75) * M + 0.9375 : 7.5625 * (M -= 2.625 / 2.75) * M + 0.984375, R ? 0.5 * (1 - M) : 0.5 * M + 0.5;
        })
      ), k(
        "Circ",
        C("CircOut", function(M) {
          return Math.sqrt(1 - (M -= 1) * M);
        }),
        C("CircIn", function(M) {
          return -(Math.sqrt(1 - M * M) - 1);
        }),
        C("CircInOut", function(M) {
          return (M *= 2) < 1 ? -0.5 * (Math.sqrt(1 - M * M) - 1) : 0.5 * (Math.sqrt(1 - (M -= 2) * M) + 1);
        })
      ), d = function(M, R, b) {
        var U = S(
          "easing." + M,
          function(j, J) {
            this._p1 = j >= 1 ? j : 1, this._p2 = (J || b) / (1 > j ? j : 1), this._p3 = this._p2 / g * (Math.asin(1 / this._p1) || 0), this._p2 = g / this._p2;
          },
          !0
        ), N = U.prototype = new x();
        return N.constructor = U, N.getRatio = R, N.config = function(j, J) {
          return new U(j, J);
        }, U;
      }, k(
        "Elastic",
        d(
          "ElasticOut",
          function(M) {
            return this._p1 * Math.pow(2, -10 * M) * Math.sin((M - this._p3) * this._p2) + 1;
          },
          0.3
        ),
        d(
          "ElasticIn",
          function(M) {
            return -(this._p1 * Math.pow(2, 10 * (M -= 1)) * Math.sin((M - this._p3) * this._p2));
          },
          0.3
        ),
        d(
          "ElasticInOut",
          function(M) {
            return (M *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (M -= 1)) * Math.sin((M - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (M -= 1)) * Math.sin((M - this._p3) * this._p2) * 0.5 + 1;
          },
          0.45
        )
      ), k(
        "Expo",
        C("ExpoOut", function(M) {
          return 1 - Math.pow(2, -10 * M);
        }),
        C("ExpoIn", function(M) {
          return Math.pow(2, 10 * (M - 1)) - 1e-3;
        }),
        C("ExpoInOut", function(M) {
          return (M *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (M - 1)) : 0.5 * (2 - Math.pow(2, -10 * (M - 1)));
        })
      ), k(
        "Sine",
        C("SineOut", function(M) {
          return Math.sin(M * _);
        }),
        C("SineIn", function(M) {
          return -Math.cos(M * _) + 1;
        }),
        C("SineInOut", function(M) {
          return -0.5 * (Math.cos(Math.PI * M) - 1);
        })
      ), S(
        "easing.EaseLookup",
        {
          find: function(M) {
            return x.map[M];
          }
        },
        !0
      ), O(u.SlowMo, "SlowMo", "ease,"), O(c, "RoughEase", "ease,"), O(a, "SteppedEase", "ease,"), E;
    },
    !0
  );
}), hn._gsDefine && hn._gsQueue.pop()(), function(x, a) {
  var s = {}, c = x.document, d = x.GreenSockGlobals = x.GreenSockGlobals || x, u = d[a];
  if (u)
    return typeof module < "u" && module.exports && (module.exports = u), u;
  var m, g, _, S, C, O = function(z) {
    var Q, st = z.split("."), nt = d;
    for (Q = 0; Q < st.length; Q++)
      nt[st[Q]] = nt = nt[st[Q]] || {};
    return nt;
  }, k = O("com.greensock"), D = 1e-10, F = function(z) {
    var Q, st = [], nt = z.length;
    for (Q = 0; Q !== nt; st.push(z[Q++]))
      ;
    return st;
  }, E = function() {
  }, L = function() {
    var z = Object.prototype.toString, Q = z.call([]);
    return function(st) {
      return st != null && (st instanceof Array || typeof st == "object" && !!st.push && z.call(st) === Q);
    };
  }(), T = {}, M = function(z, Q, st, nt) {
    this.sc = T[z] ? T[z].sc : [], T[z] = this, this.gsClass = null, this.func = st;
    var vt = [];
    this.check = function(Gt) {
      for (var Xt, jt, Ne, Re, ge = Q.length, we = ge; --ge > -1; )
        (Xt = T[Q[ge]] || new M(Q[ge], [])).gsClass ? (vt[ge] = Xt.gsClass, we--) : Gt && Xt.sc.push(this);
      if (we === 0 && st) {
        if (jt = ("com.greensock." + z).split("."), Ne = jt.pop(), Re = O(jt.join("."))[Ne] = this.gsClass = st.apply(st, vt), nt)
          if (d[Ne] = s[Ne] = Re, typeof module < "u" && module.exports)
            if (z === a) {
              module.exports = s[a] = Re;
              for (ge in s)
                Re[ge] = s[ge];
            } else
              s[a] && (s[a][Ne] = Re);
          else
            typeof define == "function" && define.amd && define(
              (x.GreenSockAMDPath ? x.GreenSockAMDPath + "/" : "") + z.split(".").pop(),
              [],
              function() {
                return Re;
              }
            );
        for (ge = 0; ge < this.sc.length; ge++)
          this.sc[ge].check();
      }
    }, this.check(!0);
  }, R = x._gsDefine = function(z, Q, st, nt) {
    return new M(z, Q, st, nt);
  }, b = k._class = function(z, Q, st) {
    return Q = Q || function() {
    }, R(
      z,
      [],
      function() {
        return Q;
      },
      st
    ), Q;
  };
  R.globals = d;
  var U = [0, 0, 1, 1], N = b(
    "easing.Ease",
    function(z, Q, st, nt) {
      this._func = z, this._type = st || 0, this._power = nt || 0, this._params = Q ? U.concat(Q) : U;
    },
    !0
  ), j = N.map = {}, J = N.register = function(z, Q, st, nt) {
    for (var vt, Gt, Xt, jt, Ne = Q.split(","), Re = Ne.length, ge = (st || "easeIn,easeOut,easeInOut").split(","); --Re > -1; )
      for (Gt = Ne[Re], vt = nt ? b("easing." + Gt, null, !0) : k.easing[Gt] || {}, Xt = ge.length; --Xt > -1; )
        jt = ge[Xt], j[Gt + "." + jt] = j[jt + Gt] = vt[jt] = z.getRatio ? z : z[jt] || new z();
  };
  for (_ = N.prototype, _._calcEnd = !1, _.getRatio = function(z) {
    if (this._func)
      return this._params[0] = z, this._func.apply(null, this._params);
    var Q = this._type, st = this._power, nt = Q === 1 ? 1 - z : Q === 2 ? z : 0.5 > z ? 2 * z : 2 * (1 - z);
    return st === 1 ? nt *= nt : st === 2 ? nt *= nt * nt : st === 3 ? nt *= nt * nt * nt : st === 4 && (nt *= nt * nt * nt * nt), Q === 1 ? 1 - nt : Q === 2 ? nt : 0.5 > z ? nt / 2 : 1 - nt / 2;
  }, m = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], g = m.length; --g > -1; )
    _ = m[g] + ",Power" + g, J(new N(null, null, 1, g), _, "easeOut", !0), J(new N(null, null, 2, g), _, "easeIn" + (g === 0 ? ",easeNone" : "")), J(new N(null, null, 3, g), _, "easeInOut");
  j.linear = k.easing.Linear.easeIn, j.swing = k.easing.Quad.easeInOut;
  var K = b("events.EventDispatcher", function(z) {
    this._listeners = {}, this._eventTarget = z || this;
  });
  _ = K.prototype, _.addEventListener = function(z, Q, st, nt, vt) {
    vt = vt || 0;
    var Gt, Xt, jt = this._listeners[z], Ne = 0;
    for (this !== S || C || S.wake(), jt == null && (this._listeners[z] = jt = []), Xt = jt.length; --Xt > -1; )
      Gt = jt[Xt], Gt.c === Q && Gt.s === st ? jt.splice(Xt, 1) : Ne === 0 && Gt.pr < vt && (Ne = Xt + 1);
    jt.splice(Ne, 0, { c: Q, s: st, up: nt, pr: vt });
  }, _.removeEventListener = function(z, Q) {
    var st, nt = this._listeners[z];
    if (nt) {
      for (st = nt.length; --st > -1; )
        if (nt[st].c === Q)
          return void nt.splice(st, 1);
    }
  }, _.dispatchEvent = function(z) {
    var Q, st, nt, vt = this._listeners[z];
    if (vt)
      for (Q = vt.length, Q > 1 && (vt = vt.slice(0)), st = this._eventTarget; --Q > -1; )
        nt = vt[Q], nt && (nt.up ? nt.c.call(nt.s || st, { type: z, target: st }) : nt.c.call(nt.s || st));
  };
  var ct = x.requestAnimationFrame, It = x.cancelAnimationFrame, et = Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  }, _t = et();
  for (m = ["ms", "moz", "webkit", "o"], g = m.length; --g > -1 && !ct; )
    ct = x[m[g] + "RequestAnimationFrame"], It = x[m[g] + "CancelAnimationFrame"] || x[m[g] + "CancelRequestAnimationFrame"];
  b("Ticker", function(z, Q) {
    var st, nt, vt, Gt, Xt, jt = this, Ne = et(), Re = Q !== !1 && ct ? "auto" : !1, ge = 500, we = 33, vi = "tick", Mi = function(ni) {
      var Si, Gr, er = et() - _t;
      er > ge && (Ne += er - we), _t += er, jt.time = (_t - Ne) / 1e3, Si = jt.time - Xt, (!st || Si > 0 || ni === !0) && (jt.frame++, Xt += Si + (Si >= Gt ? 4e-3 : Gt - Si), Gr = !0), ni !== !0 && (vt = nt(Mi)), Gr && jt.dispatchEvent(vi);
    };
    K.call(jt), jt.time = jt.frame = 0, jt.tick = function() {
      Mi(!0);
    }, jt.lagSmoothing = function(ni, Si) {
      return arguments.length ? (ge = ni || 1 / D, void (we = Math.min(Si, ge, 0))) : 1 / D > ge;
    }, jt.sleep = function() {
      vt != null && (Re && It ? It(vt) : clearTimeout(vt), nt = E, vt = null, jt === S && (C = !1));
    }, jt.wake = function(ni) {
      vt !== null ? jt.sleep() : ni ? Ne += -_t + (_t = et()) : jt.frame > 10 && (_t = et() - ge + 5), nt = st === 0 ? E : Re && ct ? ct : function(Si) {
        return setTimeout(Si, 1e3 * (Xt - jt.time) + 1 | 0);
      }, jt === S && (C = !0), Mi(2);
    }, jt.fps = function(ni) {
      return arguments.length ? (st = ni, Gt = 1 / (st || 60), Xt = this.time + Gt, void jt.wake()) : st;
    }, jt.useRAF = function(ni) {
      return arguments.length ? (jt.sleep(), Re = ni, void jt.fps(st)) : Re;
    }, jt.fps(z), setTimeout(function() {
      Re === "auto" && jt.frame < 5 && (c || {}).visibilityState !== "hidden" && jt.useRAF(!1);
    }, 1500);
  }), _ = k.Ticker.prototype = new k.events.EventDispatcher(), _.constructor = k.Ticker;
  var G = b("core.Animation", function(z, Q) {
    if (this.vars = Q = Q || {}, this._duration = this._totalDuration = z || 0, this._delay = Number(Q.delay) || 0, this._timeScale = 1, this._active = Q.immediateRender === !0, this.data = Q.data, this._reversed = Q.reversed === !0, W) {
      C || S.wake();
      var st = this.vars.useFrames ? Ji : W;
      st.add(this, st._time), this.vars.paused && this.paused(!0);
    }
  });
  S = G.ticker = new k.Ticker(), _ = G.prototype, _._dirty = _._gc = _._initted = _._paused = !1, _._totalTime = _._time = 0, _._rawPrevTime = -1, _._next = _._last = _._onUpdate = _._timeline = _.timeline = null, _._paused = !1;
  var Pt = function() {
    C && et() - _t > 2e3 && ((c || {}).visibilityState !== "hidden" || !S.lagSmoothing()) && S.wake();
    var z = setTimeout(Pt, 2e3);
    z.unref && z.unref();
  };
  Pt(), _.play = function(z, Q) {
    return z != null && this.seek(z, Q), this.reversed(!1).paused(!1);
  }, _.pause = function(z, Q) {
    return z != null && this.seek(z, Q), this.paused(!0);
  }, _.resume = function(z, Q) {
    return z != null && this.seek(z, Q), this.paused(!1);
  }, _.seek = function(z, Q) {
    return this.totalTime(Number(z), Q !== !1);
  }, _.restart = function(z, Q) {
    return this.reversed(!1).paused(!1).totalTime(z ? -this._delay : 0, Q !== !1, !0);
  }, _.reverse = function(z, Q) {
    return z != null && this.seek(z || this.totalDuration(), Q), this.reversed(!0).paused(!1);
  }, _.render = function(z, Q, st) {
  }, _.invalidate = function() {
    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this;
  }, _.isActive = function() {
    var z, Q = this._timeline, st = this._startTime;
    return !Q || !this._gc && !this._paused && Q.isActive() && (z = Q.rawTime(!0)) >= st && z < st + this.totalDuration() / this._timeScale - 1e-7;
  }, _._enabled = function(z, Q) {
    return C || S.wake(), this._gc = !z, this._active = this.isActive(), Q !== !0 && (z && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !z && this.timeline && this._timeline._remove(this, !0)), !1;
  }, _._kill = function(z, Q) {
    return this._enabled(!1, !1);
  }, _.kill = function(z, Q) {
    return this._kill(z, Q), this;
  }, _._uncache = function(z) {
    for (var Q = z ? this : this.timeline; Q; )
      Q._dirty = !0, Q = Q.timeline;
    return this;
  }, _._swapSelfInParams = function(z) {
    for (var Q = z.length, st = z.concat(); --Q > -1; )
      z[Q] === "{self}" && (st[Q] = this);
    return st;
  }, _._callback = function(z) {
    var Q = this.vars, st = Q[z], nt = Q[z + "Params"], vt = Q[z + "Scope"] || Q.callbackScope || this, Gt = nt ? nt.length : 0;
    switch (Gt) {
      case 0:
        st.call(vt);
        break;
      case 1:
        st.call(vt, nt[0]);
        break;
      case 2:
        st.call(vt, nt[0], nt[1]);
        break;
      default:
        st.apply(vt, nt);
    }
  }, _.eventCallback = function(z, Q, st, nt) {
    if ((z || "").substr(0, 2) === "on") {
      var vt = this.vars;
      if (arguments.length === 1)
        return vt[z];
      Q == null ? delete vt[z] : (vt[z] = Q, vt[z + "Params"] = L(st) && st.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(st) : st, vt[z + "Scope"] = nt), z === "onUpdate" && (this._onUpdate = Q);
    }
    return this;
  }, _.delay = function(z) {
    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + z - this._delay), this._delay = z, this) : this._delay;
  }, _.duration = function(z) {
    return arguments.length ? (this._duration = this._totalDuration = z, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && z !== 0 && this.totalTime(this._totalTime * (z / this._duration), !0), this) : (this._dirty = !1, this._duration);
  }, _.totalDuration = function(z) {
    return this._dirty = !1, arguments.length ? this.duration(z) : this._totalDuration;
  }, _.time = function(z, Q) {
    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(z > this._duration ? this._duration : z, Q)) : this._time;
  }, _.totalTime = function(z, Q, st) {
    if (C || S.wake(), !arguments.length)
      return this._totalTime;
    if (this._timeline) {
      if (0 > z && !st && (z += this.totalDuration()), this._timeline.smoothChildTiming) {
        this._dirty && this.totalDuration();
        var nt = this._totalDuration, vt = this._timeline;
        if (z > nt && !st && (z = nt), this._startTime = (this._paused ? this._pauseTime : vt._time) - (this._reversed ? nt - z : z) / this._timeScale, vt._dirty || this._uncache(!1), vt._timeline)
          for (; vt._timeline; )
            vt._timeline._time !== (vt._startTime + vt._totalTime) / vt._timeScale && vt.totalTime(vt._totalTime, !0), vt = vt._timeline;
      }
      this._gc && this._enabled(!0, !1), (this._totalTime !== z || this._duration === 0) && (Ft.length && Wt(), this.render(z, Q, !1), Ft.length && Wt());
    }
    return this;
  }, _.progress = _.totalProgress = function(z, Q) {
    var st = this.duration();
    return arguments.length ? this.totalTime(st * z, Q) : st ? this._time / st : this.ratio;
  }, _.startTime = function(z) {
    return arguments.length ? (z !== this._startTime && (this._startTime = z, this.timeline && this.timeline._sortChildren && this.timeline.add(this, z - this._delay)), this) : this._startTime;
  }, _.endTime = function(z) {
    return this._startTime + (z != 0 ? this.totalDuration() : this.duration()) / this._timeScale;
  }, _.timeScale = function(z) {
    if (!arguments.length)
      return this._timeScale;
    var Q, st;
    for (z = z || D, this._timeline && this._timeline.smoothChildTiming && (Q = this._pauseTime, st = Q || Q === 0 ? Q : this._timeline.totalTime(), this._startTime = st - (st - this._startTime) * this._timeScale / z), this._timeScale = z, st = this.timeline; st && st.timeline; )
      st._dirty = !0, st.totalDuration(), st = st.timeline;
    return this;
  }, _.reversed = function(z) {
    return arguments.length ? (z != this._reversed && (this._reversed = z, this.totalTime(
      this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime,
      !0
    )), this) : this._reversed;
  }, _.paused = function(z) {
    if (!arguments.length)
      return this._paused;
    var Q, st, nt = this._timeline;
    return z != this._paused && nt && (C || z || S.wake(), Q = nt.rawTime(), st = Q - this._pauseTime, !z && nt.smoothChildTiming && (this._startTime += st, this._uncache(!1)), this._pauseTime = z ? Q : null, this._paused = z, this._active = this.isActive(), !z && st !== 0 && this._initted && this.duration() && (Q = nt.smoothChildTiming ? this._totalTime : (Q - this._startTime) / this._timeScale, this.render(Q, Q === this._totalTime, !0))), this._gc && !z && this._enabled(!0, !1), this;
  };
  var Et = b("core.SimpleTimeline", function(z) {
    G.call(this, 0, z), this.autoRemoveChildren = this.smoothChildTiming = !0;
  });
  _ = Et.prototype = new G(), _.constructor = Et, _.kill()._gc = !1, _._first = _._last = _._recent = null, _._sortChildren = !1, _.add = _.insert = function(z, Q, st, nt) {
    var vt, Gt;
    if (z._startTime = Number(Q || 0) + z._delay, z._paused && this !== z._timeline && (z._pauseTime = this.rawTime() - (z._timeline.rawTime() - z._pauseTime)), z.timeline && z.timeline._remove(z, !0), z.timeline = z._timeline = this, z._gc && z._enabled(!0, !0), vt = this._last, this._sortChildren)
      for (Gt = z._startTime; vt && vt._startTime > Gt; )
        vt = vt._prev;
    return vt ? (z._next = vt._next, vt._next = z) : (z._next = this._first, this._first = z), z._next ? z._next._prev = z : this._last = z, z._prev = vt, this._recent = z, this._timeline && this._uncache(!0), this;
  }, _._remove = function(z, Q) {
    return z.timeline === this && (Q || z._enabled(!1, !0), z._prev ? z._prev._next = z._next : this._first === z && (this._first = z._next), z._next ? z._next._prev = z._prev : this._last === z && (this._last = z._prev), z._next = z._prev = z.timeline = null, z === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this;
  }, _.render = function(z, Q, st) {
    var nt, vt = this._first;
    for (this._totalTime = this._time = this._rawPrevTime = z; vt; )
      nt = vt._next, (vt._active || z >= vt._startTime && !vt._paused && !vt._gc) && (vt._reversed ? vt.render(
        (vt._dirty ? vt.totalDuration() : vt._totalDuration) - (z - vt._startTime) * vt._timeScale,
        Q,
        st
      ) : vt.render((z - vt._startTime) * vt._timeScale, Q, st)), vt = nt;
  }, _.rawTime = function() {
    return C || S.wake(), this._totalTime;
  };
  var At = b(
    "TweenLite",
    function(z, Q, st) {
      if (G.call(this, Q, st), this.render = At.prototype.render, z == null)
        throw "Cannot tween a null target.";
      this.target = z = typeof z != "string" ? z : At.selector(z) || z;
      var nt, vt, Gt, Xt = z.jquery || z.length && z !== x && z[0] && (z[0] === x || z[0].nodeType && z[0].style && !z.nodeType), jt = this.vars.overwrite;
      if (this._overwrite = jt = jt == null ? cn[At.defaultOverwrite] : typeof jt == "number" ? jt >> 0 : cn[jt], (Xt || z instanceof Array || z.push && L(z)) && typeof z[0] != "number")
        for (this._targets = Gt = F(z), this._propLookup = [], this._siblings = [], nt = 0; nt < Gt.length; nt++)
          vt = Gt[nt], vt ? typeof vt != "string" ? vt.length && vt !== x && vt[0] && (vt[0] === x || vt[0].nodeType && vt[0].style && !vt.nodeType) ? (Gt.splice(nt--, 1), this._targets = Gt = Gt.concat(F(vt))) : (this._siblings[nt] = pt(vt, this, !1), jt === 1 && this._siblings[nt].length > 1 && Dt(vt, this, null, 1, this._siblings[nt])) : (vt = Gt[nt--] = At.selector(vt), typeof vt == "string" && Gt.splice(nt + 1, 1)) : Gt.splice(nt--, 1);
      else
        this._propLookup = {}, this._siblings = pt(z, this, !1), jt === 1 && this._siblings.length > 1 && Dt(z, this, null, 1, this._siblings);
      (this.vars.immediateRender || Q === 0 && this._delay === 0 && this.vars.immediateRender !== !1) && (this._time = -D, this.render(Math.min(0, -this._delay)));
    },
    !0
  ), fe = function(z) {
    return z && z.length && z !== x && z[0] && (z[0] === x || z[0].nodeType && z[0].style && !z.nodeType);
  }, re = function(z, Q) {
    var st, nt = {};
    for (st in z)
      Ri[st] || st in Q && st !== "transform" && st !== "x" && st !== "y" && st !== "width" && st !== "height" && st !== "className" && st !== "border" || !(!Oe[st] || Oe[st] && Oe[st]._autoCSS) || (nt[st] = z[st], delete z[st]);
    z.css = nt;
  };
  _ = At.prototype = new G(), _.constructor = At, _.kill()._gc = !1, _.ratio = 0, _._firstPT = _._targets = _._overwrittenProps = _._startAt = null, _._notifyPluginsOfEnabled = _._lazy = !1, At.version = "2.0.2", At.defaultEase = _._ease = new N(null, null, 1, 1), At.defaultOverwrite = "auto", At.ticker = S, At.autoSleep = 120, At.lagSmoothing = function(z, Q) {
    S.lagSmoothing(z, Q);
  }, At.selector = x.$ || x.jQuery || function(z) {
    var Q = x.$ || x.jQuery;
    return Q ? (At.selector = Q, Q(z)) : (c || (c = x.document), c ? c.querySelectorAll ? c.querySelectorAll(z) : c.getElementById(z.charAt(0) === "#" ? z.substr(1) : z) : z);
  };
  var Ft = [], Ot = {}, Bt = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, ke = /[\+-]=-?[\.\d]/, ce = function(z) {
    for (var Q, st = this._firstPT, nt = 1e-6; st; )
      Q = st.blob ? z === 1 && this.end != null ? this.end : z ? this.join("") : this.start : st.c * z + st.s, st.m ? Q = st.m.call(this._tween, Q, this._target || st.t, this._tween) : nt > Q && Q > -nt && !st.blob && (Q = 0), st.f ? st.fp ? st.t[st.p](st.fp, Q) : st.t[st.p](Q) : st.t[st.p] = Q, st = st._next;
  }, Yt = function(z, Q, st, nt) {
    var vt, Gt, Xt, jt, Ne, Re, ge, we = [], vi = 0, Mi = "", ni = 0;
    for (we.start = z, we.end = Q, z = we[0] = z + "", Q = we[1] = Q + "", st && (st(we), z = we[0], Q = we[1]), we.length = 0, vt = z.match(Bt) || [], Gt = Q.match(Bt) || [], nt && (nt._next = null, nt.blob = 1, we._firstPT = we._applyPT = nt), Ne = Gt.length, jt = 0; Ne > jt; jt++)
      ge = Gt[jt], Re = Q.substr(vi, Q.indexOf(ge, vi) - vi), Mi += Re || !jt ? Re : ",", vi += Re.length, ni ? ni = (ni + 1) % 5 : Re.substr(-5) === "rgba(" && (ni = 1), ge === vt[jt] || vt.length <= jt ? Mi += ge : (Mi && (we.push(Mi), Mi = ""), Xt = parseFloat(vt[jt]), we.push(Xt), we._firstPT = {
        _next: we._firstPT,
        t: we,
        p: we.length - 1,
        s: Xt,
        c: (ge.charAt(1) === "=" ? parseInt(ge.charAt(0) + "1", 10) * parseFloat(ge.substr(2)) : parseFloat(ge) - Xt) || 0,
        f: 0,
        m: ni && 4 > ni ? Math.round : 0
      }), vi += ge.length;
    return Mi += Q.substr(vi), Mi && we.push(Mi), we.setRatio = ce, ke.test(Q) && (we.end = null), we;
  }, $e = function(z, Q, st, nt, vt, Gt, Xt, jt, Ne) {
    typeof nt == "function" && (nt = nt(Ne || 0, z));
    var Re, ge = typeof z[Q], we = ge !== "function" ? "" : Q.indexOf("set") || typeof z["get" + Q.substr(3)] != "function" ? Q : "get" + Q.substr(3), vi = st !== "get" ? st : we ? Xt ? z[we](Xt) : z[we]() : z[Q], Mi = typeof nt == "string" && nt.charAt(1) === "=", ni = {
      t: z,
      p: Q,
      s: vi,
      f: ge === "function",
      pg: 0,
      n: vt || Q,
      m: Gt ? typeof Gt == "function" ? Gt : Math.round : 0,
      pr: 0,
      c: Mi ? parseInt(nt.charAt(0) + "1", 10) * parseFloat(nt.substr(2)) : parseFloat(nt) - vi || 0
    };
    return (typeof vi != "number" || typeof nt != "number" && !Mi) && (Xt || isNaN(vi) || !Mi && isNaN(nt) || typeof vi == "boolean" || typeof nt == "boolean" ? (ni.fp = Xt, Re = Yt(
      vi,
      Mi ? parseFloat(ni.s) + ni.c + (ni.s + "").replace(/[0-9\-\.]/g, "") : nt,
      jt || At.defaultStringFilter,
      ni
    ), ni = {
      t: Re,
      p: "setRatio",
      s: 0,
      c: 1,
      f: 2,
      pg: 0,
      n: vt || Q,
      pr: 0,
      m: 0
    }) : (ni.s = parseFloat(vi), Mi || (ni.c = parseFloat(nt) - ni.s || 0))), ni.c ? ((ni._next = this._firstPT) && (ni._next._prev = ni), this._firstPT = ni, ni) : void 0;
  }, Li = At._internals = {
    isArray: L,
    isSelector: fe,
    lazyTweens: Ft,
    blobDif: Yt
  }, Oe = At._plugins = {}, Ge = Li.tweenLookup = {}, pi = 0, Ri = Li.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1
  }, cn = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    true: 1,
    false: 0
  }, Ji = G._rootFramesTimeline = new Et(), W = G._rootTimeline = new Et(), Jt = 30, Wt = Li.lazyRender = function() {
    var z, Q = Ft.length;
    for (Ot = {}; --Q > -1; )
      z = Ft[Q], z && z._lazy !== !1 && (z.render(z._lazy[0], z._lazy[1], !0), z._lazy = !1);
    Ft.length = 0;
  };
  W._startTime = S.time, Ji._startTime = S.frame, W._active = Ji._active = !0, setTimeout(Wt, 1), G._updateRoot = At.render = function() {
    var z, Q, st;
    if (Ft.length && Wt(), W.render((S.time - W._startTime) * W._timeScale, !1, !1), Ji.render((S.frame - Ji._startTime) * Ji._timeScale, !1, !1), Ft.length && Wt(), S.frame >= Jt) {
      Jt = S.frame + (parseInt(At.autoSleep, 10) || 120);
      for (st in Ge) {
        for (Q = Ge[st].tweens, z = Q.length; --z > -1; )
          Q[z]._gc && Q.splice(z, 1);
        Q.length === 0 && delete Ge[st];
      }
      if (st = W._first, (!st || st._paused) && At.autoSleep && !Ji._first && S._listeners.tick.length === 1) {
        for (; st && st._paused; )
          st = st._next;
        st || S.sleep();
      }
    }
  }, S.addEventListener("tick", G._updateRoot);
  var pt = function(z, Q, st) {
    var nt, vt, Gt = z._gsTweenID;
    if (Ge[Gt || (z._gsTweenID = Gt = "t" + pi++)] || (Ge[Gt] = { target: z, tweens: [] }), Q && (nt = Ge[Gt].tweens, nt[vt = nt.length] = Q, st))
      for (; --vt > -1; )
        nt[vt] === Q && nt.splice(vt, 1);
    return Ge[Gt].tweens;
  }, dt = function(z, Q, st, nt) {
    var vt, Gt, Xt = z.vars.onOverwrite;
    return Xt && (vt = Xt(z, Q, st, nt)), Xt = At.onOverwrite, Xt && (Gt = Xt(z, Q, st, nt)), vt !== !1 && Gt !== !1;
  }, Dt = function(z, Q, st, nt, vt) {
    var Gt, Xt, jt, Ne;
    if (nt === 1 || nt >= 4) {
      for (Ne = vt.length, Gt = 0; Ne > Gt; Gt++)
        if ((jt = vt[Gt]) !== Q)
          jt._gc || jt._kill(null, z, Q) && (Xt = !0);
        else if (nt === 5)
          break;
      return Xt;
    }
    var Re, ge = Q._startTime + D, we = [], vi = 0, Mi = Q._duration === 0;
    for (Gt = vt.length; --Gt > -1; )
      (jt = vt[Gt]) === Q || jt._gc || jt._paused || (jt._timeline !== Q._timeline ? (Re = Re || ie(Q, 0, Mi), ie(jt, Re, Mi) === 0 && (we[vi++] = jt)) : jt._startTime <= ge && jt._startTime + jt.totalDuration() / jt._timeScale > ge && ((Mi || !jt._initted) && ge - jt._startTime <= 2e-10 || (we[vi++] = jt)));
    for (Gt = vi; --Gt > -1; )
      if (jt = we[Gt], Ne = jt._firstPT, nt === 2 && jt._kill(st, z, Q) && (Xt = !0), nt !== 2 || !jt._firstPT && jt._initted && Ne) {
        if (nt !== 2 && !dt(jt, Q))
          continue;
        jt._enabled(!1, !1) && (Xt = !0);
      }
    return Xt;
  }, ie = function(z, Q, st) {
    for (var nt = z._timeline, vt = nt._timeScale, Gt = z._startTime; nt._timeline; ) {
      if (Gt += nt._startTime, vt *= nt._timeScale, nt._paused)
        return -100;
      nt = nt._timeline;
    }
    return Gt /= vt, Gt > Q ? Gt - Q : st && Gt === Q || !z._initted && 2 * D > Gt - Q ? D : (Gt += z.totalDuration() / z._timeScale / vt) > Q + D ? 0 : Gt - Q - D;
  };
  _._init = function() {
    var z, Q, st, nt, vt, Gt, Xt = this.vars, jt = this._overwrittenProps, Ne = this._duration, Re = !!Xt.immediateRender, ge = Xt.ease;
    if (Xt.startAt) {
      this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), vt = {};
      for (nt in Xt.startAt)
        vt[nt] = Xt.startAt[nt];
      if (vt.data = "isStart", vt.overwrite = !1, vt.immediateRender = !0, vt.lazy = Re && Xt.lazy !== !1, vt.startAt = vt.delay = null, vt.onUpdate = Xt.onUpdate, vt.onUpdateParams = Xt.onUpdateParams, vt.onUpdateScope = Xt.onUpdateScope || Xt.callbackScope || this, this._startAt = At.to(this.target || {}, 0, vt), Re) {
        if (this._time > 0)
          this._startAt = null;
        else if (Ne !== 0)
          return;
      }
    } else if (Xt.runBackwards && Ne !== 0)
      if (this._startAt)
        this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
      else {
        this._time !== 0 && (Re = !1), st = {};
        for (nt in Xt)
          Ri[nt] && nt !== "autoCSS" || (st[nt] = Xt[nt]);
        if (st.overwrite = 0, st.data = "isFromStart", st.lazy = Re && Xt.lazy !== !1, st.immediateRender = Re, this._startAt = At.to(this.target, 0, st), Re) {
          if (this._time === 0)
            return;
        } else
          this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null);
      }
    if (this._ease = ge = ge ? ge instanceof N ? ge : typeof ge == "function" ? new N(ge, Xt.easeParams) : j[ge] || At.defaultEase : At.defaultEase, Xt.easeParams instanceof Array && ge.config && (this._ease = ge.config.apply(ge, Xt.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
      for (Gt = this._targets.length, z = 0; Gt > z; z++)
        this._initProps(
          this._targets[z],
          this._propLookup[z] = {},
          this._siblings[z],
          jt ? jt[z] : null,
          z
        ) && (Q = !0);
    else
      Q = this._initProps(
        this.target,
        this._propLookup,
        this._siblings,
        jt,
        0
      );
    if (Q && At._onPluginEvent("_onInitAllProps", this), jt && (this._firstPT || typeof this.target != "function" && this._enabled(!1, !1)), Xt.runBackwards)
      for (st = this._firstPT; st; )
        st.s += st.c, st.c = -st.c, st = st._next;
    this._onUpdate = Xt.onUpdate, this._initted = !0;
  }, _._initProps = function(z, Q, st, nt, vt) {
    var Gt, Xt, jt, Ne, Re, ge;
    if (z == null)
      return !1;
    Ot[z._gsTweenID] && Wt(), this.vars.css || z.style && z !== x && z.nodeType && Oe.css && this.vars.autoCSS !== !1 && re(this.vars, z);
    for (Gt in this.vars)
      if (ge = this.vars[Gt], Ri[Gt])
        ge && (ge instanceof Array || ge.push && L(ge)) && ge.join("").indexOf("{self}") !== -1 && (this.vars[Gt] = ge = this._swapSelfInParams(ge, this));
      else if (Oe[Gt] && (Ne = new Oe[Gt]())._onInitTween(z, this.vars[Gt], this, vt)) {
        for (this._firstPT = Re = {
          _next: this._firstPT,
          t: Ne,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: Gt,
          pg: 1,
          pr: Ne._priority,
          m: 0
        }, Xt = Ne._overwriteProps.length; --Xt > -1; )
          Q[Ne._overwriteProps[Xt]] = this._firstPT;
        (Ne._priority || Ne._onInitAllProps) && (jt = !0), (Ne._onDisable || Ne._onEnable) && (this._notifyPluginsOfEnabled = !0), Re._next && (Re._next._prev = Re);
      } else
        Q[Gt] = $e.call(
          this,
          z,
          Gt,
          "get",
          ge,
          Gt,
          0,
          null,
          this.vars.stringFilter,
          vt
        );
    return nt && this._kill(nt, z) ? this._initProps(z, Q, st, nt, vt) : this._overwrite > 1 && this._firstPT && st.length > 1 && Dt(z, this, Q, this._overwrite, st) ? (this._kill(Q, z), this._initProps(z, Q, st, nt, vt)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (Ot[z._gsTweenID] = !0), jt);
  }, _.render = function(z, Q, st) {
    var nt, vt, Gt, Xt, jt = this._time, Ne = this._duration, Re = this._rawPrevTime;
    if (z >= Ne - 1e-7 && z >= 0)
      this._totalTime = this._time = Ne, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (nt = !0, vt = "onComplete", st = st || this._timeline.autoRemoveChildren), Ne === 0 && (this._initted || !this.vars.lazy || st) && (this._startTime === this._timeline._duration && (z = 0), (0 > Re || 0 >= z && z >= -1e-7 || Re === D && this.data !== "isPause") && Re !== z && (st = !0, Re > D && (vt = "onReverseComplete")), this._rawPrevTime = Xt = !Q || z || Re === z ? z : D);
    else if (1e-7 > z)
      this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (jt !== 0 || Ne === 0 && Re > 0) && (vt = "onReverseComplete", nt = this._reversed), 0 > z && (this._active = !1, Ne === 0 && (this._initted || !this.vars.lazy || st) && (Re >= 0 && (Re !== D || this.data !== "isPause") && (st = !0), this._rawPrevTime = Xt = !Q || z || Re === z ? z : D)), (!this._initted || this._startAt && this._startAt.progress()) && (st = !0);
    else if (this._totalTime = this._time = z, this._easeType) {
      var ge = z / Ne, we = this._easeType, vi = this._easePower;
      (we === 1 || we === 3 && ge >= 0.5) && (ge = 1 - ge), we === 3 && (ge *= 2), vi === 1 ? ge *= ge : vi === 2 ? ge *= ge * ge : vi === 3 ? ge *= ge * ge * ge : vi === 4 && (ge *= ge * ge * ge * ge), we === 1 ? this.ratio = 1 - ge : we === 2 ? this.ratio = ge : 0.5 > z / Ne ? this.ratio = ge / 2 : this.ratio = 1 - ge / 2;
    } else
      this.ratio = this._ease.getRatio(z / Ne);
    if (this._time !== jt || st) {
      if (!this._initted) {
        if (this._init(), !this._initted || this._gc)
          return;
        if (!st && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
          return this._time = this._totalTime = jt, this._rawPrevTime = Re, Ft.push(this), void (this._lazy = [z, Q]);
        this._time && !nt ? this.ratio = this._ease.getRatio(this._time / Ne) : nt && this._ease._calcEnd && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1));
      }
      for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== jt && z >= 0 && (this._active = !0), jt === 0 && (this._startAt && (z >= 0 ? this._startAt.render(z, !0, st) : vt || (vt = "_dummyGS")), this.vars.onStart && (this._time !== 0 || Ne === 0) && (Q || this._callback("onStart"))), Gt = this._firstPT; Gt; )
        Gt.f ? Gt.t[Gt.p](Gt.c * this.ratio + Gt.s) : Gt.t[Gt.p] = Gt.c * this.ratio + Gt.s, Gt = Gt._next;
      this._onUpdate && (0 > z && this._startAt && z !== -1e-4 && this._startAt.render(z, !0, st), Q || (this._time !== jt || nt || st) && this._callback("onUpdate")), vt && (!this._gc || st) && (0 > z && this._startAt && !this._onUpdate && z !== -1e-4 && this._startAt.render(z, !0, st), nt && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !Q && this.vars[vt] && this._callback(vt), Ne === 0 && this._rawPrevTime === D && Xt !== D && (this._rawPrevTime = 0));
    }
  }, _._kill = function(z, Q, st) {
    if (z === "all" && (z = null), z == null && (Q == null || Q === this.target))
      return this._lazy = !1, this._enabled(!1, !1);
    Q = typeof Q != "string" ? Q || this._targets || this.target : At.selector(Q) || Q;
    var nt, vt, Gt, Xt, jt, Ne, Re, ge, we, vi = st && this._time && st._startTime === this._startTime && this._timeline === st._timeline, Mi = this._firstPT;
    if ((L(Q) || fe(Q)) && typeof Q[0] != "number")
      for (nt = Q.length; --nt > -1; )
        this._kill(z, Q[nt], st) && (Ne = !0);
    else {
      if (this._targets) {
        for (nt = this._targets.length; --nt > -1; )
          if (Q === this._targets[nt]) {
            jt = this._propLookup[nt] || {}, this._overwrittenProps = this._overwrittenProps || [], vt = this._overwrittenProps[nt] = z ? this._overwrittenProps[nt] || {} : "all";
            break;
          }
      } else {
        if (Q !== this.target)
          return !1;
        jt = this._propLookup, vt = this._overwrittenProps = z ? this._overwrittenProps || {} : "all";
      }
      if (jt) {
        if (Re = z || jt, ge = z !== vt && vt !== "all" && z !== jt && (typeof z != "object" || !z._tempKill), st && (At.onOverwrite || this.vars.onOverwrite)) {
          for (Gt in Re)
            jt[Gt] && (we || (we = []), we.push(Gt));
          if ((we || !z) && !dt(this, st, Q, we))
            return !1;
        }
        for (Gt in Re)
          (Xt = jt[Gt]) && (vi && (Xt.f ? Xt.t[Xt.p](Xt.s) : Xt.t[Xt.p] = Xt.s, Ne = !0), Xt.pg && Xt.t._kill(Re) && (Ne = !0), Xt.pg && Xt.t._overwriteProps.length !== 0 || (Xt._prev ? Xt._prev._next = Xt._next : Xt === this._firstPT && (this._firstPT = Xt._next), Xt._next && (Xt._next._prev = Xt._prev), Xt._next = Xt._prev = null), delete jt[Gt]), ge && (vt[Gt] = 1);
        !this._firstPT && this._initted && Mi && this._enabled(!1, !1);
      }
    }
    return Ne;
  }, _.invalidate = function() {
    return this._notifyPluginsOfEnabled && At._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], G.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -D, this.render(Math.min(0, -this._delay))), this;
  }, _._enabled = function(z, Q) {
    if (C || S.wake(), z && this._gc) {
      var st, nt = this._targets;
      if (nt)
        for (st = nt.length; --st > -1; )
          this._siblings[st] = pt(nt[st], this, !0);
      else
        this._siblings = pt(this.target, this, !0);
    }
    return G.prototype._enabled.call(this, z, Q), this._notifyPluginsOfEnabled && this._firstPT ? At._onPluginEvent(z ? "_onEnable" : "_onDisable", this) : !1;
  }, At.to = function(z, Q, st) {
    return new At(z, Q, st);
  }, At.from = function(z, Q, st) {
    return st.runBackwards = !0, st.immediateRender = st.immediateRender != 0, new At(z, Q, st);
  }, At.fromTo = function(z, Q, st, nt) {
    return nt.startAt = st, nt.immediateRender = nt.immediateRender != 0 && st.immediateRender != 0, new At(z, Q, nt);
  }, At.delayedCall = function(z, Q, st, nt, vt) {
    return new At(Q, 0, {
      delay: z,
      onComplete: Q,
      onCompleteParams: st,
      callbackScope: nt,
      onReverseComplete: Q,
      onReverseCompleteParams: st,
      immediateRender: !1,
      lazy: !1,
      useFrames: vt,
      overwrite: 0
    });
  }, At.set = function(z, Q) {
    return new At(z, 0, Q);
  }, At.getTweensOf = function(z, Q) {
    if (z == null)
      return [];
    z = typeof z != "string" ? z : At.selector(z) || z;
    var st, nt, vt, Gt;
    if ((L(z) || fe(z)) && typeof z[0] != "number") {
      for (st = z.length, nt = []; --st > -1; )
        nt = nt.concat(At.getTweensOf(z[st], Q));
      for (st = nt.length; --st > -1; )
        for (Gt = nt[st], vt = st; --vt > -1; )
          Gt === nt[vt] && nt.splice(st, 1);
    } else if (z._gsTweenID)
      for (nt = pt(z).concat(), st = nt.length; --st > -1; )
        (nt[st]._gc || Q && !nt[st].isActive()) && nt.splice(st, 1);
    return nt || [];
  }, At.killTweensOf = At.killDelayedCallsTo = function(z, Q, st) {
    typeof Q == "object" && (st = Q, Q = !1);
    for (var nt = At.getTweensOf(z, Q), vt = nt.length; --vt > -1; )
      nt[vt]._kill(st, z);
  };
  var Kt = b(
    "plugins.TweenPlugin",
    function(z, Q) {
      this._overwriteProps = (z || "").split(","), this._propName = this._overwriteProps[0], this._priority = Q || 0, this._super = Kt.prototype;
    },
    !0
  );
  if (_ = Kt.prototype, Kt.version = "1.19.0", Kt.API = 2, _._firstPT = null, _._addTween = $e, _.setRatio = ce, _._kill = function(z) {
    var Q, st = this._overwriteProps, nt = this._firstPT;
    if (z[this._propName] != null)
      this._overwriteProps = [];
    else
      for (Q = st.length; --Q > -1; )
        z[st[Q]] != null && st.splice(Q, 1);
    for (; nt; )
      z[nt.n] != null && (nt._next && (nt._next._prev = nt._prev), nt._prev ? (nt._prev._next = nt._next, nt._prev = null) : this._firstPT === nt && (this._firstPT = nt._next)), nt = nt._next;
    return !1;
  }, _._mod = _._roundProps = function(z) {
    for (var Q, st = this._firstPT; st; )
      Q = z[this._propName] || st.n != null && z[st.n.split(this._propName + "_").join("")], Q && typeof Q == "function" && (st.f === 2 ? st.t._applyPT.m = Q : st.m = Q), st = st._next;
  }, At._onPluginEvent = function(z, Q) {
    var st, nt, vt, Gt, Xt, jt = Q._firstPT;
    if (z === "_onInitAllProps") {
      for (; jt; ) {
        for (Xt = jt._next, nt = vt; nt && nt.pr > jt.pr; )
          nt = nt._next;
        (jt._prev = nt ? nt._prev : Gt) ? jt._prev._next = jt : vt = jt, (jt._next = nt) ? nt._prev = jt : Gt = jt, jt = Xt;
      }
      jt = Q._firstPT = vt;
    }
    for (; jt; )
      jt.pg && typeof jt.t[z] == "function" && jt.t[z]() && (st = !0), jt = jt._next;
    return st;
  }, Kt.activate = function(z) {
    for (var Q = z.length; --Q > -1; )
      z[Q].API === Kt.API && (Oe[new z[Q]()._propName] = z[Q]);
    return !0;
  }, R.plugin = function(z) {
    if (!(z && z.propName && z.init && z.API))
      throw "illegal plugin definition.";
    var Q, st = z.propName, nt = z.priority || 0, vt = z.overwriteProps, Gt = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    }, Xt = b(
      "plugins." + st.charAt(0).toUpperCase() + st.substr(1) + "Plugin",
      function() {
        Kt.call(this, st, nt), this._overwriteProps = vt || [];
      },
      z.global === !0
    ), jt = Xt.prototype = new Kt(st);
    jt.constructor = Xt, Xt.API = z.API;
    for (Q in Gt)
      typeof z[Q] == "function" && (jt[Gt[Q]] = z[Q]);
    return Xt.version = z.version, Kt.activate([Xt]), Xt;
  }, m = x._gsQueue) {
    for (g = 0; g < m.length; g++)
      m[g]();
    for (_ in T)
      T[_].func || x.console.log("GSAP encountered missing dependency: " + _);
  }
  C = !1;
}(
  typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window,
  "TweenMax"
);
const Ny = { class: "modal-background" }, Fy = ["innerHTML"], Uy = {
  name: "MapModali"
}, Gy = /* @__PURE__ */ of({
  ...Uy,
  props: {
    // text: {
    //   type: String,
    //   default: "CHBIM云平台",
    // },
  },
  setup(x, { expose: a }) {
    const s = Fc(""), c = Fc(""), d = (m) => {
      c.value = m, s.value = "five";
    }, u = () => {
      s.value = s.value + " out";
    };
    return sf(() => {
    }), a({
      text: c,
      show: d,
      hide: u
    }), (m, g) => (Zu(), Ju("div", {
      id: "modal-container",
      class: Np(s.value),
      onClick: u
    }, [
      Mr("div", Ny, [
        Mr("div", {
          class: "modal",
          onClick: g[0] || (g[0] = (_) => {
            _.stopPropagation();
          })
        }, [
          Mr("p", {
            style: { "white-space": "pre-line", "line-height": "1", margin: "0", color: "#fff" },
            innerHTML: c.value
          }, null, 8, Fy)
        ])
      ])
    ], 2));
  }
});
const Hy = { class: "bim_background_plate" }, Vy = { class: "content" }, Wy = /* @__PURE__ */ Mr("canvas", { class: "landscape" }, null, -1), jy = { class: "content__title" }, Xy = /* @__PURE__ */ Mr("div", { class: "overlay" }, null, -1), qy = {
  name: "BimBackgroundPlate"
}, Yy = /* @__PURE__ */ of({
  ...qy,
  setup(x) {
    const a = () => {
      let d = `
          vec3 mod289(vec3 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 mod289(vec4 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 permute(vec4 x)
          {
          	return mod289(((x*34.0)+1.0)*x);
          }

          vec4 taylorInvSqrt(vec4 r)
          {
          	return 1.79284291400159 - 0.85373472095314 * r;
          }

          vec3 fade(vec3 t) {
          	return t*t*t*(t*(t*6.0-15.0)+10.0);
          }

          // Classic Perlin noise
          float cnoise(vec3 P)
          {
          	vec3 Pi0 = floor(P); // Integer part for indexing
          	vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          // Classic Perlin noise, periodic variant
          float pnoise(vec3 P, vec3 rep)
          {
          	vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
          	vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          #define PI 3.1415926535897932384626433832795

          uniform float time;
          uniform float scroll;
          uniform float maxHeight;
          uniform float speed;
          uniform float distortCenter;
          uniform float roadWidth;
          varying float vDisplace;

          varying float fogDepth;

          void main(){

          	float t = time * speed;
          	float wRoad = distortCenter;
          	float wRoad2 = wRoad * 0.5;

          	float angleCenter = uv.y * PI*4.0;
          	angleCenter += t * 0.9;

          	float centerOff = (
          		sin(angleCenter) +
          		sin(angleCenter*0.5)
          	) * wRoad;


          	vec3 noiseIn = vec3(uv, 1.0)*10.0;
          	float noise = cnoise(vec3(noiseIn.x, noiseIn.y + scroll, noiseIn.z));
          	noise += 1.0;
          	float h = noise;
          	float angle = (uv.x - centerOff) * PI;
          	float f = abs(cos(angle));
          	h *= pow(f, 1.5 + roadWidth);


          	vDisplace = h;


          	h*=maxHeight;

          	vec3 transformed = vec3( position.x, position.y, position.z + h );


          	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
          	gl_Position = projectionMatrix * mvPosition;

          	fogDepth = -mvPosition.z;

          }
`, u = `
   uniform float time;
          uniform vec3 color;
          uniform sampler2D pallete;
          varying float vDisplace;

          uniform vec3 fogColor;
          uniform float fogNear;
          uniform float fogFar;
          varying float fogDepth;

          void main(){

          	vec2 stripPos = vec2( 0.0, vDisplace * (sin(time)*0.5+0.7) );
          	vec4 stripColor = texture2D( pallete, stripPos );
          	stripColor *= pow(1.0-vDisplace, 1.0);

          	gl_FragColor = stripColor;

          	#ifdef USE_FOG
          		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
          		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
          	#endif
          }`;
      var m = document.querySelector(".landscape"), g = window.innerWidth, _ = window.innerHeight, S, C, O, k, D = { x: 0, y: 0, xDamped: 0, yDamped: 0 }, F = typeof window.orientation < "u";
      E();
      function E() {
        L(), T(), M(), N(), F ? window.addEventListener("touchmove", U, { passive: !1 }) : window.addEventListener("mousemove", U), window.addEventListener("resize", b), b();
      }
      function L() {
        S = new THREE.Scene();
        var K = new THREE.Color(3355443);
        S.background = K, S.fog = new THREE.Fog(K, 0, 400), R(), O = new THREE.PerspectiveCamera(60, g / _, 0.1, 1e4), O.position.y = 8, O.position.z = 4;
        let ct = new THREE.AmbientLight(16777215, 1);
        S.add(ct), C = new THREE.WebGLRenderer({
          canvas: m,
          antialias: !0
        }), C.setPixelRatio = devicePixelRatio, C.setSize(g, _);
      }
      function T() {
        var K = new THREE.PlaneBufferGeometry(100, 400, 400, 400), ct = {
          time: { type: "f", value: 0 },
          scroll: { type: "f", value: 0 },
          distortCenter: { type: "f", value: 0.1 },
          roadWidth: { type: "f", value: 0.5 },
          pallete: { type: "t", value: null },
          speed: { type: "f", value: 3 },
          maxHeight: { type: "f", value: 10 },
          color: new THREE.Color(1, 1, 1)
        }, It = new THREE.ShaderMaterial({
          uniforms: THREE.UniformsUtils.merge([
            THREE.ShaderLib.basic.uniforms,
            ct
          ]),
          vertexShader: d,
          fragmentShader: u,
          wireframe: !1,
          fog: !0
        });
        k = new THREE.Mesh(K, It), k.position.z = -180, k.rotation.x = -Math.PI / 2, S.add(k);
      }
      function M() {
        new THREE.TextureLoader().load("", function(K) {
          k.material.uniforms.pallete.value = K, k.material.needsUpdate = !0;
        });
      }
      function R() {
        R = new THREE.Sky(), R.scale.setScalar(45e4), R.material.uniforms.turbidity.value = 13, R.material.uniforms.rayleigh.value = 1.2, R.material.uniforms.luminance.value = 1, R.material.uniforms.mieCoefficient.value = 0.1, R.material.uniforms.mieDirectionalG.value = 0.58, S.add(R);
        let K = new THREE.Mesh(
          new THREE.SphereBufferGeometry(2e4, 16, 8),
          new THREE.MeshBasicMaterial({ color: 16777215 })
        );
        K.visible = !1, S.add(K);
        var ct = Math.PI * -2e-3, It = 2 * Math.PI * -0.25;
        K.position.x = 4e5 * Math.cos(It), K.position.y = 4e5 * Math.sin(It) * Math.sin(ct), K.position.z = 4e5 * Math.sin(It) * Math.cos(ct), R.material.uniforms.sunPosition.value.copy(K.position);
      }
      function b() {
        g = window.innerWidth, _ = window.innerHeight, O.aspect = g / _, O.updateProjectionMatrix(), C.setSize(g, _);
      }
      function U(K) {
        K.preventDefault();
        var ct, It;
        K.type == "mousemove" ? (ct = K.clientX, It = K.clientY) : (ct = K.changedTouches[0].clientX, It = K.changedTouches[0].clientY), D.x = ct, D.y = It;
      }
      function N() {
        requestAnimationFrame(N), D.xDamped = J(D.xDamped, D.x, 0.1), D.yDamped = J(D.yDamped, D.y, 0.1);
        var K = performance.now() * 1e-3;
        k.material.uniforms.time.value = K, k.material.uniforms.scroll.value = K + j(D.yDamped, 0, _, 0, 4), k.material.uniforms.distortCenter.value = Math.sin(K) * 0.1, k.material.uniforms.roadWidth.value = j(
          D.xDamped,
          0,
          g,
          1,
          4.5
        ), O.position.y = j(D.yDamped, 0, _, 4, 11), C.render(S, O);
      }
      function j(K, ct, It, et, _t) {
        return et + (_t - et) * ((K - ct) / (It - ct));
      }
      function J(K, ct, It) {
        return (1 - It) * K + It * ct;
      }
    }, s = () => {
      const d = document.querySelector(".overlay"), u = document.querySelector(".content__title");
      charming(u);
      const m = Array.from(u.querySelectorAll("span"));
      TweenMax.to(d, 2, {
        ease: Quad.easeOut,
        opacity: 0
      }), TweenMax.set(m, { opacity: 0 }), TweenMax.staggerTo(
        m,
        1.5,
        {
          ease: Expo.easeOut,
          startAt: { rotationX: -100, z: -1e3 },
          opacity: 1,
          rotationX: 0,
          z: 0
        },
        0.1
      );
    }, c = () => {
      a(), s();
    };
    return sf(() => {
      c();
    }), (d, u) => (Zu(), Ju("div", Hy, [
      Mr("div", Vy, [
        Wy,
        Mr("h2", jy, [
          Fp(d.$slots, "default")
        ])
      ]),
      Xy
    ]));
  }
});
(function(x, a) {
  typeof exports == "object" && typeof module < "u" ? a(exports) : typeof define == "function" && define.amd ? define(["exports"], a) : a(x.THREE = {});
})(window, function(x) {
  function a() {
  }
  function s(t, e) {
    this.x = t || 0, this.y = e || 0;
  }
  function c() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function d(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = n !== void 0 ? n : 1;
  }
  function u(t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0;
  }
  function m() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function g(t, e, i, n, o, l, f, p, y, w) {
    Object.defineProperty(this, "id", { value: Is++ }), this.uuid = fi.generateUUID(), this.name = "", this.image = t !== void 0 ? t : g.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = e !== void 0 ? e : g.DEFAULT_MAPPING, this.wrapS = i !== void 0 ? i : 1001, this.wrapT = n !== void 0 ? n : 1001, this.magFilter = o !== void 0 ? o : 1006, this.minFilter = l !== void 0 ? l : 1008, this.anisotropy = y !== void 0 ? y : 1, this.format = f !== void 0 ? f : 1023, this.type = p !== void 0 ? p : 1009, this.offset = new s(0, 0), this.repeat = new s(1, 1), this.center = new s(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new m(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = w !== void 0 ? w : 3e3, this.version = 0, this.onUpdate = null;
  }
  function _(t, e, i, n) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n !== void 0 ? n : 1;
  }
  function S(t, e, i) {
    this.width = t, this.height = e, this.scissor = new _(0, 0, t, e), this.scissorTest = !1, this.viewport = new _(0, 0, t, e), i = i || {}, i.minFilter === void 0 && (i.minFilter = 1006), this.texture = new g(
      void 0,
      void 0,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    ), this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !0, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !0, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null;
  }
  function C(t, e, i) {
    S.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0;
  }
  function O(t, e, i, n, o, l, f, p, y, w, A, P) {
    g.call(this, null, l, f, p, y, w, n, o, A, P), this.image = { data: t, width: e, height: i }, this.magFilter = y !== void 0 ? y : 1003, this.minFilter = w !== void 0 ? w : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1;
  }
  function k(t, e) {
    this.min = t !== void 0 ? t : new u(1 / 0, 1 / 0, 1 / 0), this.max = e !== void 0 ? e : new u(-1 / 0, -1 / 0, -1 / 0);
  }
  function D(t, e) {
    this.center = t !== void 0 ? t : new u(), this.radius = e !== void 0 ? e : 0;
  }
  function F(t, e) {
    this.normal = t !== void 0 ? t : new u(1, 0, 0), this.constant = e !== void 0 ? e : 0;
  }
  function E(t, e, i, n, o, l) {
    this.planes = [
      t !== void 0 ? t : new F(),
      e !== void 0 ? e : new F(),
      i !== void 0 ? i : new F(),
      n !== void 0 ? n : new F(),
      o !== void 0 ? o : new F(),
      l !== void 0 ? l : new F()
    ];
  }
  function L(t, e, i) {
    return e === void 0 && i === void 0 ? this.set(t) : this.setRGB(t, e, i);
  }
  function T() {
    function t(o, l) {
      i !== !1 && (n(o, l), e.requestAnimationFrame(t));
    }
    var e = null, i = !1, n = null;
    return {
      start: function() {
        i !== !0 && n !== null && (e.requestAnimationFrame(t), i = !0);
      },
      stop: function() {
        i = !1;
      },
      setAnimationLoop: function(o) {
        n = o;
      },
      setContext: function(o) {
        e = o;
      }
    };
  }
  function M(t) {
    function e(n, o) {
      var l = n.array, f = n.dynamic ? 35048 : 35044, p = t.createBuffer();
      return t.bindBuffer(o, p), t.bufferData(o, l, f), n.onUploadCallback(), o = 5126, l instanceof Float32Array ? o = 5126 : l instanceof Float64Array ? console.warn(
        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
      ) : l instanceof Uint16Array ? o = 5123 : l instanceof Int16Array ? o = 5122 : l instanceof Uint32Array ? o = 5125 : l instanceof Int32Array ? o = 5124 : l instanceof Int8Array ? o = 5120 : l instanceof Uint8Array && (o = 5121), {
        buffer: p,
        type: o,
        bytesPerElement: l.BYTES_PER_ELEMENT,
        version: n.version
      };
    }
    var i = /* @__PURE__ */ new WeakMap();
    return {
      get: function(n) {
        return n.isInterleavedBufferAttribute && (n = n.data), i.get(n);
      },
      remove: function(n) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var o = i.get(n);
        o && (t.deleteBuffer(o.buffer), i.delete(n));
      },
      update: function(n, o) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var l = i.get(n);
        if (l === void 0)
          i.set(n, e(n, o));
        else if (l.version < n.version) {
          var f = n, p = f.array, y = f.updateRange;
          t.bindBuffer(o, l.buffer), f.dynamic === !1 ? t.bufferData(o, p, 35044) : y.count === -1 ? t.bufferSubData(o, 0, p) : y.count === 0 ? console.error(
            "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
          ) : (t.bufferSubData(
            o,
            y.offset * p.BYTES_PER_ELEMENT,
            p.subarray(y.offset, y.offset + y.count)
          ), y.count = -1), l.version = n.version;
        }
      }
    };
  }
  function R(t, e, i, n, o, l) {
    this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new u(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new L(), this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = l !== void 0 ? l : 0;
  }
  function b(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || b.DefaultOrder;
  }
  function U() {
    this.mask = 1;
  }
  function N() {
    Object.defineProperty(this, "id", { value: ic++ }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = N.DefaultUp.clone();
    var t = new u(), e = new b(), i = new d(), n = new u(1, 1, 1);
    e.onChange(function() {
      i.setFromEuler(e, !1);
    }), i.onChange(function() {
      e.setFromQuaternion(i, void 0, !1);
    }), Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: t },
      rotation: { configurable: !0, enumerable: !0, value: e },
      quaternion: { configurable: !0, enumerable: !0, value: i },
      scale: { configurable: !0, enumerable: !0, value: n },
      modelViewMatrix: { value: new c() },
      normalMatrix: { value: new m() }
    }), this.matrix = new c(), this.matrixWorld = new c(), this.matrixAutoUpdate = N.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new U(), this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
  }
  function j() {
    Object.defineProperty(this, "id", { value: nc += 2 }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function J(t, e, i) {
    if (Array.isArray(t))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i === !0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function K(t, e, i) {
    J.call(this, new Int8Array(t), e, i);
  }
  function ct(t, e, i) {
    J.call(this, new Uint8Array(t), e, i);
  }
  function It(t, e, i) {
    J.call(this, new Uint8ClampedArray(t), e, i);
  }
  function et(t, e, i) {
    J.call(this, new Int16Array(t), e, i);
  }
  function _t(t, e, i) {
    J.call(this, new Uint16Array(t), e, i);
  }
  function G(t, e, i) {
    J.call(this, new Int32Array(t), e, i);
  }
  function Pt(t, e, i) {
    J.call(this, new Uint32Array(t), e, i);
  }
  function Et(t, e, i) {
    J.call(this, new Float32Array(t), e, i);
  }
  function At(t, e, i) {
    J.call(this, new Float64Array(t), e, i);
  }
  function fe() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function re(t) {
    if (t.length === 0)
      return -1 / 0;
    for (var e = t[0], i = 1, n = t.length; i < n; ++i)
      t[i] > e && (e = t[i]);
    return e;
  }
  function Ft() {
    Object.defineProperty(this, "id", { value: rc += 2 }), this.uuid = fi.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  function Ot(t, e, i, n, o, l) {
    j.call(this), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: o,
      depthSegments: l
    }, this.fromBufferGeometry(new Bt(t, e, i, n, o, l)), this.mergeVertices();
  }
  function Bt(t, e, i, n, o, l) {
    function f(q, $, rt, xt, gt, Ct, wt, Vt, Z, ot, zt) {
      var ee = Ct / Z, $t = wt / ot, qt = Ct / 2, Te = wt / 2, me = Vt / 2;
      wt = Z + 1;
      var Ie = ot + 1, be = Ct = 0, ae, We, Qe = new u();
      for (We = 0; We < Ie; We++) {
        var ci = We * $t - Te;
        for (ae = 0; ae < wt; ae++)
          Qe[q] = (ae * ee - qt) * xt, Qe[$] = ci * gt, Qe[rt] = me, w.push(Qe.x, Qe.y, Qe.z), Qe[q] = 0, Qe[$] = 0, Qe[rt] = 0 < Vt ? 1 : -1, A.push(Qe.x, Qe.y, Qe.z), P.push(ae / Z), P.push(1 - We / ot), Ct += 1;
      }
      for (We = 0; We < ot; We++)
        for (ae = 0; ae < Z; ae++)
          q = B + ae + wt * (We + 1), $ = B + (ae + 1) + wt * (We + 1), rt = B + (ae + 1) + wt * We, y.push(B + ae + wt * We, q, rt), y.push(q, $, rt), be += 6;
      p.addGroup(H, be, zt), H += be, B += Ct;
    }
    Ft.call(this), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: o,
      depthSegments: l
    };
    var p = this;
    t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, l = Math.floor(l) || 1;
    var y = [], w = [], A = [], P = [], B = 0, H = 0;
    f("z", "y", "x", -1, -1, i, e, t, l, o, 0), f("z", "y", "x", 1, -1, i, e, -t, l, o, 1), f("x", "z", "y", 1, 1, t, i, e, n, l, 2), f("x", "z", "y", 1, -1, t, i, -e, n, l, 3), f("x", "y", "z", 1, -1, t, e, i, n, o, 4), f("x", "y", "z", -1, -1, t, e, -i, n, o, 5), this.setIndex(y), this.addAttribute("position", new Et(w, 3)), this.addAttribute("normal", new Et(A, 3)), this.addAttribute("uv", new Et(P, 2));
  }
  function ke(t, e, i, n) {
    j.call(this), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, this.fromBufferGeometry(new ce(t, e, i, n)), this.mergeVertices();
  }
  function ce(t, e, i, n) {
    Ft.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, t = t || 1, e = e || 1;
    var o = t / 2, l = e / 2;
    i = Math.floor(i) || 1, n = Math.floor(n) || 1;
    var f = i + 1, p = n + 1, y = t / i, w = e / n, A = [], P = [], B = [], H = [];
    for (t = 0; t < p; t++) {
      var q = t * w - l;
      for (e = 0; e < f; e++)
        P.push(e * y - o, -q, 0), B.push(0, 0, 1), H.push(e / i), H.push(1 - t / n);
    }
    for (t = 0; t < n; t++)
      for (e = 0; e < i; e++)
        o = e + f * (t + 1), l = e + 1 + f * (t + 1), p = e + 1 + f * t, A.push(e + f * t, o, p), A.push(o, l, p);
    this.setIndex(A), this.addAttribute("position", new Et(P, 3)), this.addAttribute("normal", new Et(B, 3)), this.addAttribute("uv", new Et(H, 2));
  }
  function Yt() {
    Object.defineProperty(this, "id", { value: mu++ }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0;
  }
  function $e(t) {
    Yt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, t !== void 0 && (t.attributes !== void 0 && console.error(
      "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
    ), this.setValues(t));
  }
  function Li(t, e) {
    this.origin = t !== void 0 ? t : new u(), this.direction = e !== void 0 ? e : new u();
  }
  function Oe(t, e, i) {
    this.a = t !== void 0 ? t : new u(), this.b = e !== void 0 ? e : new u(), this.c = i !== void 0 ? i : new u();
  }
  function Ge(t) {
    Yt.call(this), this.type = "MeshBasicMaterial", this.color = new L(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function pi(t, e) {
    N.call(this), this.type = "Mesh", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Ge({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets();
  }
  function Ri(t, e, i, n) {
    function o(w, A) {
      e.buffers.color.setClear(w.r, w.g, w.b, A, n);
    }
    var l = new L(0), f = 0, p, y;
    return {
      getClearColor: function() {
        return l;
      },
      setClearColor: function(w, A) {
        l.set(w), f = A !== void 0 ? A : 1, o(l, f);
      },
      getClearAlpha: function() {
        return f;
      },
      setClearAlpha: function(w) {
        f = w, o(l, f);
      },
      render: function(w, A, P, B) {
        A = A.background, A === null ? o(l, f) : A && A.isColor && (o(A, 1), B = !0), (t.autoClear || B) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), A && (A.isCubeTexture || A.isWebGLRenderTargetCube) ? (y === void 0 && (y = new pi(
          new Bt(1, 1, 1),
          new $e({
            type: "BackgroundCubeMaterial",
            uniforms: Dn.clone(go.cube.uniforms),
            vertexShader: go.cube.vertexShader,
            fragmentShader: go.cube.fragmentShader,
            side: 1,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), y.geometry.removeAttribute("normal"), y.geometry.removeAttribute("uv"), y.onBeforeRender = function(H, q, $) {
          this.matrixWorld.copyPosition($.matrixWorld);
        }, i.update(y)), y.material.uniforms.tCube.value = A.isWebGLRenderTargetCube ? A.texture : A, y.material.uniforms.tFlip.value = A.isWebGLRenderTargetCube ? 1 : -1, w.push(y, y.geometry, y.material, 0, null)) : A && A.isTexture && (p === void 0 && (p = new pi(
          new ce(2, 2),
          new $e({
            type: "BackgroundMaterial",
            uniforms: Dn.clone(go.background.uniforms),
            vertexShader: go.background.vertexShader,
            fragmentShader: go.background.fragmentShader,
            side: 0,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), p.geometry.removeAttribute("normal"), i.update(p)), p.material.uniforms.t2D.value = A, A.matrixAutoUpdate === !0 && A.updateMatrix(), p.material.uniforms.uvTransform.value.copy(A.matrix), w.push(p, p.geometry, p.material, 0, null));
      }
    };
  }
  function cn(t, e, i, n) {
    var o;
    this.setMode = function(l) {
      o = l;
    }, this.render = function(l, f) {
      t.drawArrays(o, l, f), i.update(f, o);
    }, this.renderInstances = function(l, f, p) {
      if (n.isWebGL2)
        var y = t;
      else if (y = e.get("ANGLE_instanced_arrays"), y === null) {
        console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      y[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](
        o,
        f,
        p,
        l.maxInstancedCount
      ), i.update(p, o, l.maxInstancedCount);
    };
  }
  function Ji(t, e, i) {
    function n(xt) {
      if (xt === "highp") {
        if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision)
          return "highp";
        xt = "mediump";
      }
      return xt === "mediump" && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var o, l = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext, f = i.precision !== void 0 ? i.precision : "highp", p = n(f);
    p !== f && (console.warn(
      "THREE.WebGLRenderer:",
      f,
      "not supported, using",
      p,
      "instead."
    ), f = p), i = i.logarithmicDepthBuffer === !0, p = t.getParameter(34930);
    var y = t.getParameter(35660), w = t.getParameter(3379), A = t.getParameter(34076), P = t.getParameter(34921), B = t.getParameter(36347), H = t.getParameter(36348), q = t.getParameter(36349), $ = 0 < y, rt = l || !!e.get("OES_texture_float");
    return {
      isWebGL2: l,
      getMaxAnisotropy: function() {
        if (o !== void 0)
          return o;
        var xt = e.get("EXT_texture_filter_anisotropic");
        return o = xt !== null ? t.getParameter(xt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      },
      getMaxPrecision: n,
      precision: f,
      logarithmicDepthBuffer: i,
      maxTextures: p,
      maxVertexTextures: y,
      maxTextureSize: w,
      maxCubemapSize: A,
      maxAttributes: P,
      maxVertexUniforms: B,
      maxVaryings: H,
      maxFragmentUniforms: q,
      vertexTextures: $,
      floatFragmentTextures: rt,
      floatVertexTextures: $ && rt
    };
  }
  function W() {
    function t() {
      w.value !== n && (w.value = n, w.needsUpdate = 0 < o), i.numPlanes = o, i.numIntersection = 0;
    }
    function e(A, P, B, H) {
      var q = A !== null ? A.length : 0, $ = null;
      if (q !== 0) {
        if ($ = w.value, H !== !0 || $ === null)
          for (H = B + 4 * q, P = P.matrixWorldInverse, y.getNormalMatrix(P), ($ === null || $.length < H) && ($ = new Float32Array(H)), H = 0; H !== q; ++H, B += 4)
            p.copy(A[H]).applyMatrix4(P, y), p.normal.toArray($, B), $[B + 3] = p.constant;
        w.value = $, w.needsUpdate = !0;
      }
      return i.numPlanes = q, $;
    }
    var i = this, n = null, o = 0, l = !1, f = !1, p = new F(), y = new m(), w = { value: null, needsUpdate: !1 };
    this.uniform = w, this.numIntersection = this.numPlanes = 0, this.init = function(A, P, B) {
      var H = A.length !== 0 || P || o !== 0 || l;
      return l = P, n = e(A, B, 0), o = A.length, H;
    }, this.beginShadows = function() {
      f = !0, e(null);
    }, this.endShadows = function() {
      f = !1, t();
    }, this.setState = function(A, P, B, H, q, $) {
      if (!l || A === null || A.length === 0 || f && !B)
        f ? e(null) : t();
      else {
        B = f ? 0 : o;
        var rt = 4 * B, xt = q.clippingState || null;
        for (w.value = xt, xt = e(A, H, rt, $), A = 0; A !== rt; ++A)
          xt[A] = n[A];
        q.clippingState = xt, this.numIntersection = P ? this.numPlanes : 0, this.numPlanes += B;
      }
    };
  }
  function Jt(t) {
    var e = {};
    return {
      get: function(i) {
        if (e[i] !== void 0)
          return e[i];
        switch (i) {
          case "WEBGL_depth_texture":
            var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = t.getExtension(i);
        }
        return n === null && console.warn(
          "THREE.WebGLRenderer: " + i + " extension not supported."
        ), e[i] = n;
      }
    };
  }
  function Wt(t, e, i) {
    function n(f) {
      var p = f.target;
      f = o[p.id], f.index !== null && e.remove(f.index);
      for (var y in f.attributes)
        e.remove(f.attributes[y]);
      p.removeEventListener("dispose", n), delete o[p.id], (y = l[f.id]) && (e.remove(y), delete l[f.id]), i.memory.geometries--;
    }
    var o = {}, l = {};
    return {
      get: function(f, p) {
        var y = o[p.id];
        return y || (p.addEventListener("dispose", n), p.isBufferGeometry ? y = p : p.isGeometry && (p._bufferGeometry === void 0 && (p._bufferGeometry = new Ft().setFromObject(f)), y = p._bufferGeometry), o[p.id] = y, i.memory.geometries++, y);
      },
      update: function(f) {
        var p = f.index, y = f.attributes;
        p !== null && e.update(p, 34963);
        for (var w in y)
          e.update(y[w], 34962);
        f = f.morphAttributes;
        for (w in f) {
          p = f[w], y = 0;
          for (var A = p.length; y < A; y++)
            e.update(p[y], 34962);
        }
      },
      getWireframeAttribute: function(f) {
        var p = l[f.id];
        if (p)
          return p;
        p = [];
        var y = f.index, w = f.attributes;
        if (y !== null) {
          y = y.array, w = 0;
          for (var A = y.length; w < A; w += 3) {
            var P = y[w + 0], B = y[w + 1], H = y[w + 2];
            p.push(P, B, B, H, H, P);
          }
        } else
          for (y = w.position.array, w = 0, A = y.length / 3 - 1; w < A; w += 3)
            P = w + 0, B = w + 1, H = w + 2, p.push(P, B, B, H, H, P);
        return p = new (65535 < re(p) ? Pt : _t)(p, 1), e.update(p, 34963), l[f.id] = p;
      }
    };
  }
  function pt(t, e, i, n) {
    var o, l, f;
    this.setMode = function(p) {
      o = p;
    }, this.setIndex = function(p) {
      l = p.type, f = p.bytesPerElement;
    }, this.render = function(p, y) {
      t.drawElements(o, y, l, p * f), i.update(y, o);
    }, this.renderInstances = function(p, y, w) {
      if (n.isWebGL2)
        var A = t;
      else if (A = e.get("ANGLE_instanced_arrays"), A === null) {
        console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      A[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](
        o,
        w,
        l,
        y * f,
        p.maxInstancedCount
      ), i.update(w, o, p.maxInstancedCount);
    };
  }
  function dt(t) {
    var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function() {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      },
      update: function(i, n, o) {
        switch (o = o || 1, e.calls++, n) {
          case 4:
            e.triangles += i / 3 * o;
            break;
          case 5:
          case 6:
            e.triangles += o * (i - 2);
            break;
          case 1:
            e.lines += i / 2 * o;
            break;
          case 3:
            e.lines += o * (i - 1);
            break;
          case 2:
            e.lines += o * i;
            break;
          case 0:
            e.points += o * i;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      }
    };
  }
  function Dt(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function ie(t) {
    var e = {}, i = new Float32Array(8);
    return {
      update: function(n, o, l, f) {
        var p = n.morphTargetInfluences, y = p.length;
        if (n = e[o.id], n === void 0) {
          n = [];
          for (var w = 0; w < y; w++)
            n[w] = [w, 0];
          e[o.id] = n;
        }
        var A = l.morphTargets && o.morphAttributes.position;
        for (l = l.morphNormals && o.morphAttributes.normal, w = 0; w < y; w++) {
          var P = n[w];
          P[1] !== 0 && (A && o.removeAttribute("morphTarget" + w), l && o.removeAttribute("morphNormal" + w));
        }
        for (w = 0; w < y; w++)
          P = n[w], P[0] = w, P[1] = p[w];
        for (n.sort(Dt), w = 0; 8 > w; w++) {
          if ((P = n[w]) && (p = P[0], y = P[1])) {
            A && o.addAttribute("morphTarget" + w, A[p]), l && o.addAttribute("morphNormal" + w, l[p]), i[w] = y;
            continue;
          }
          i[w] = 0;
        }
        f.getUniforms().setValue(t, "morphTargetInfluences", i);
      }
    };
  }
  function Kt(t, e) {
    var i = {};
    return {
      update: function(n) {
        var o = e.render.frame, l = n.geometry, f = t.get(n, l);
        return i[f.id] !== o && (l.isGeometry && f.updateFromObject(n), t.update(f), i[f.id] = o), f;
      },
      dispose: function() {
        i = {};
      }
    };
  }
  function z(t, e, i, n, o, l, f, p, y, w) {
    t = t !== void 0 ? t : [], g.call(this, t, e !== void 0 ? e : 301, i, n, o, l, f, p, y, w), this.flipY = !1;
  }
  function Q(t, e, i, n) {
    g.call(this, null), this.image = { data: t, width: e, height: i, depth: n }, this.minFilter = this.magFilter = 1003, this.flipY = this.generateMipmaps = !1;
  }
  function st(t, e, i) {
    var n = t[0];
    if (0 >= n || 0 < n)
      return t;
    var o = e * i, l = ql[o];
    if (l === void 0 && (l = new Float32Array(o), ql[o] = l), e !== 0)
      for (n.toArray(l, 0), n = 1, o = 0; n !== e; ++n)
        o += i, t[n].toArray(l, o);
    return l;
  }
  function nt(t, e) {
    if (t.length !== e.length)
      return !1;
    for (var i = 0, n = t.length; i < n; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  function vt(t, e) {
    for (var i = 0, n = e.length; i < n; i++)
      t[i] = e[i];
  }
  function Gt(t, e) {
    var i = xa[e];
    i === void 0 && (i = new Int32Array(e), xa[e] = i);
    for (var n = 0; n !== e; ++n)
      i[n] = t.allocTextureUnit();
    return i;
  }
  function Xt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e);
  }
  function jt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e);
  }
  function Ne(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : nt(i, e) || (t.uniform2fv(this.addr, e), vt(i, e));
  }
  function Re(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : e.r !== void 0 ? (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : nt(i, e) || (t.uniform3fv(this.addr, e), vt(i, e));
  }
  function ge(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : nt(i, e) || (t.uniform4fv(this.addr, e), vt(i, e));
  }
  function we(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? nt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), vt(i, e)) : nt(i, n) || (Rh.set(n), t.uniformMatrix2fv(this.addr, !1, Rh), vt(i, n));
  }
  function vi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? nt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), vt(i, e)) : nt(i, n) || (vu.set(n), t.uniformMatrix3fv(this.addr, !1, vu), vt(i, n));
  }
  function Mi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? nt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), vt(i, e)) : nt(i, n) || (hl.set(n), t.uniformMatrix4fv(this.addr, !1, hl), vt(i, n));
  }
  function ni(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTexture2D(e || Lh, o);
  }
  function Si(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTexture3D(e || oc, o);
  }
  function Gr(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTextureCube(e || gu, o);
  }
  function er(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform2iv(this.addr, e), vt(i, e));
  }
  function rn(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform3iv(this.addr, e), vt(i, e));
  }
  function Co(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform4iv(this.addr, e), vt(i, e));
  }
  function Oi(t) {
    switch (t) {
      case 5126:
        return Xt;
      case 35664:
        return Ne;
      case 35665:
        return Re;
      case 35666:
        return ge;
      case 35674:
        return we;
      case 35675:
        return vi;
      case 35676:
        return Mi;
      case 35678:
      case 36198:
        return ni;
      case 35679:
        return Si;
      case 35680:
        return Gr;
      case 5124:
      case 35670:
        return jt;
      case 35667:
      case 35671:
        return er;
      case 35668:
      case 35672:
        return rn;
      case 35669:
      case 35673:
        return Co;
    }
  }
  function Go(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform1fv(this.addr, e), vt(i, e));
  }
  function io(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform1iv(this.addr, e), vt(i, e));
  }
  function Pl(t, e) {
    var i = this.cache;
    e = st(e, this.size, 2), nt(i, e) || (t.uniform2fv(this.addr, e), this.updateCache(e));
  }
  function xn(t, e) {
    var i = this.cache;
    e = st(e, this.size, 3), nt(i, e) || (t.uniform3fv(this.addr, e), this.updateCache(e));
  }
  function qs(t, e) {
    var i = this.cache;
    e = st(e, this.size, 4), nt(i, e) || (t.uniform4fv(this.addr, e), this.updateCache(e));
  }
  function us(t, e) {
    var i = this.cache;
    e = st(e, this.size, 4), nt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), this.updateCache(e));
  }
  function dr(t, e) {
    var i = this.cache;
    e = st(e, this.size, 9), nt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), this.updateCache(e));
  }
  function Ys(t, e) {
    var i = this.cache;
    e = st(e, this.size, 16), nt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), this.updateCache(e));
  }
  function ka(t, e, i) {
    var n = this.cache, o = e.length, l = Gt(i, o);
    for (nt(n, l) === !1 && (t.uniform1iv(this.addr, l), vt(n, l)), t = 0; t !== o; ++t)
      i.setTexture2D(e[t] || Lh, l[t]);
  }
  function Ll(t, e, i) {
    var n = this.cache, o = e.length, l = Gt(i, o);
    for (nt(n, l) === !1 && (t.uniform1iv(this.addr, l), vt(n, l)), t = 0; t !== o; ++t)
      i.setTextureCube(e[t] || gu, l[t]);
  }
  function no(t) {
    switch (t) {
      case 5126:
        return Go;
      case 35664:
        return Pl;
      case 35665:
        return xn;
      case 35666:
        return qs;
      case 35674:
        return us;
      case 35675:
        return dr;
      case 35676:
        return Ys;
      case 35678:
        return ka;
      case 35680:
        return Ll;
      case 5124:
      case 35670:
        return io;
      case 35667:
      case 35671:
        return er;
      case 35668:
      case 35672:
        return rn;
      case 35669:
      case 35673:
        return Co;
    }
  }
  function mh(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.setValue = Oi(e.type);
  }
  function Zs(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = no(e.type);
  }
  function Ba(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  function ro(t, e, i) {
    this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, 35718);
    for (var n = 0; n < i; ++n) {
      var o = t.getActiveUniform(e, n), l = t.getUniformLocation(e, o.name), f = this, p = o.name, y = p.length;
      for (Oh.lastIndex = 0; ; ) {
        var w = Oh.exec(p), A = Oh.lastIndex, P = w[1], B = w[3];
        if (w[2] === "]" && (P |= 0), B === void 0 || B === "[" && A + 2 === y) {
          p = f, o = B === void 0 ? new mh(P, o, l) : new Zs(P, o, l), p.seq.push(o), p.map[o.id] = o;
          break;
        } else
          B = f.map[P], B === void 0 && (B = new Ba(P), P = f, f = B, P.seq.push(f), P.map[f.id] = f), f = B;
      }
    }
  }
  function Na(t) {
    t = t.split(`
`);
    for (var e = 0; e < t.length; e++)
      t[e] = e + 1 + ": " + t[e];
    return t.join(`
`);
  }
  function Js(t, e, i) {
    var n = t.createShader(e);
    return t.shaderSource(n, i), t.compileShader(n), t.getShaderParameter(n, 35713) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), t.getShaderInfoLog(n) !== "" && console.warn(
      "THREE.WebGLShader: gl.getShaderInfoLog()",
      e === 35633 ? "vertex" : "fragment",
      t.getShaderInfoLog(n),
      Na(i)
    ), n;
  }
  function $s(t) {
    switch (t) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw Error("unsupported encoding: " + t);
    }
  }
  function oo(t, e) {
    return e = $s(e), "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }";
  }
  function Rl(t, e) {
    return e = $s(e), "vec4 " + t + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
  }
  function gh(t, e) {
    switch (e) {
      case 1:
        e = "Linear";
        break;
      case 2:
        e = "Reinhard";
        break;
      case 3:
        e = "Uncharted2";
        break;
      case 4:
        e = "OptimizedCineon";
        break;
      default:
        throw Error("unsupported toneMapping: " + e);
    }
    return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
  }
  function vh(t, e, i) {
    return t = t || {}, [
      t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
      (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
      t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
      (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ].filter(fs).join(`
`);
  }
  function cs(t) {
    var e = [], i;
    for (i in t) {
      var n = t[i];
      n !== !1 && e.push("#define " + i + " " + n);
    }
    return e.join(`
`);
  }
  function fs(t) {
    return t !== "";
  }
  function Ol(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
  }
  function Il(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
  }
  function Hr(t) {
    return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, i) {
      if (e = Ei[i], e === void 0)
        throw Error("Can not resolve #include <" + i + ">");
      return Hr(e);
    });
  }
  function V(t) {
    return t.replace(
      /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      function(e, i, n, o) {
        for (e = "", i = parseInt(i); i < parseInt(n); i++)
          e += o.replace(/\[ i \]/g, "[ " + i + " ]");
        return e;
      }
    );
  }
  function tt(t, e, i, n, o, l, f) {
    var p = t.context, y = n.defines, w = o.vertexShader, A = o.fragmentShader, P = "SHADOWMAP_TYPE_BASIC";
    l.shadowMapType === 1 ? P = "SHADOWMAP_TYPE_PCF" : l.shadowMapType === 2 && (P = "SHADOWMAP_TYPE_PCF_SOFT");
    var B = "ENVMAP_TYPE_CUBE", H = "ENVMAP_MODE_REFLECTION", q = "ENVMAP_BLENDING_MULTIPLY";
    if (l.envMap) {
      switch (n.envMap.mapping) {
        case 301:
        case 302:
          B = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          B = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          B = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          B = "ENVMAP_TYPE_SPHERE";
      }
      switch (n.envMap.mapping) {
        case 302:
        case 304:
          H = "ENVMAP_MODE_REFRACTION";
      }
      switch (n.combine) {
        case 0:
          q = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          q = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          q = "ENVMAP_BLENDING_ADD";
      }
    }
    var $ = 0 < t.gammaFactor ? t.gammaFactor : 1, rt = f.isWebGL2 ? "" : vh(n.extensions, l, e), xt = cs(y), gt = p.createProgram();
    n.isRawShaderMaterial ? (y = [xt].filter(fs).join(`
`), 0 < y.length && (y += `
`), e = [rt, xt].filter(fs).join(`
`), 0 < e.length && (e += `
`)) : (y = [
      "precision " + l.precision + " float;",
      "precision " + l.precision + " int;",
      "#define SHADER_NAME " + o.name,
      xt,
      l.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + $,
      "#define MAX_BONES " + l.maxBones,
      l.useFog && l.fog ? "#define USE_FOG" : "",
      l.useFog && l.fogExp ? "#define FOG_EXP2" : "",
      l.map ? "#define USE_MAP" : "",
      l.envMap ? "#define USE_ENVMAP" : "",
      l.envMap ? "#define " + H : "",
      l.lightMap ? "#define USE_LIGHTMAP" : "",
      l.aoMap ? "#define USE_AOMAP" : "",
      l.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      l.bumpMap ? "#define USE_BUMPMAP" : "",
      l.normalMap ? "#define USE_NORMALMAP" : "",
      l.normalMap && l.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      l.displacementMap && l.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      l.specularMap ? "#define USE_SPECULARMAP" : "",
      l.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      l.metalnessMap ? "#define USE_METALNESSMAP" : "",
      l.alphaMap ? "#define USE_ALPHAMAP" : "",
      l.vertexColors ? "#define USE_COLOR" : "",
      l.flatShading ? "#define FLAT_SHADED" : "",
      l.skinning ? "#define USE_SKINNING" : "",
      l.useVertexTexture ? "#define BONE_TEXTURE" : "",
      l.morphTargets ? "#define USE_MORPHTARGETS" : "",
      l.morphNormals && l.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
      l.doubleSided ? "#define DOUBLE_SIDED" : "",
      l.flipSided ? "#define FLIP_SIDED" : "",
      l.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      l.shadowMapEnabled ? "#define " + P : "",
      l.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      l.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      l.logarithmicDepthBuffer && (f.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(fs).join(`
`), e = [
      rt,
      "precision " + l.precision + " float;",
      "precision " + l.precision + " int;",
      "#define SHADER_NAME " + o.name,
      xt,
      l.alphaTest ? "#define ALPHATEST " + l.alphaTest + (l.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + $,
      l.useFog && l.fog ? "#define USE_FOG" : "",
      l.useFog && l.fogExp ? "#define FOG_EXP2" : "",
      l.map ? "#define USE_MAP" : "",
      l.envMap ? "#define USE_ENVMAP" : "",
      l.envMap ? "#define " + B : "",
      l.envMap ? "#define " + H : "",
      l.envMap ? "#define " + q : "",
      l.lightMap ? "#define USE_LIGHTMAP" : "",
      l.aoMap ? "#define USE_AOMAP" : "",
      l.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      l.bumpMap ? "#define USE_BUMPMAP" : "",
      l.normalMap ? "#define USE_NORMALMAP" : "",
      l.normalMap && l.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      l.specularMap ? "#define USE_SPECULARMAP" : "",
      l.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      l.metalnessMap ? "#define USE_METALNESSMAP" : "",
      l.alphaMap ? "#define USE_ALPHAMAP" : "",
      l.vertexColors ? "#define USE_COLOR" : "",
      l.gradientMap ? "#define USE_GRADIENTMAP" : "",
      l.flatShading ? "#define FLAT_SHADED" : "",
      l.doubleSided ? "#define DOUBLE_SIDED" : "",
      l.flipSided ? "#define FLIP_SIDED" : "",
      l.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      l.shadowMapEnabled ? "#define " + P : "",
      l.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      l.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      l.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      l.logarithmicDepthBuffer && (f.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      l.envMap && (f.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      l.toneMapping !== 0 ? "#define TONE_MAPPING" : "",
      l.toneMapping !== 0 ? Ei.tonemapping_pars_fragment : "",
      l.toneMapping !== 0 ? gh("toneMapping", l.toneMapping) : "",
      l.dithering ? "#define DITHERING" : "",
      l.outputEncoding || l.mapEncoding || l.matcapEncoding || l.envMapEncoding || l.emissiveMapEncoding ? Ei.encodings_pars_fragment : "",
      l.mapEncoding ? oo("mapTexelToLinear", l.mapEncoding) : "",
      l.matcapEncoding ? oo("matcapTexelToLinear", l.matcapEncoding) : "",
      l.envMapEncoding ? oo("envMapTexelToLinear", l.envMapEncoding) : "",
      l.emissiveMapEncoding ? oo("emissiveMapTexelToLinear", l.emissiveMapEncoding) : "",
      l.outputEncoding ? Rl("linearToOutputTexel", l.outputEncoding) : "",
      l.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
      `
`
    ].filter(fs).join(`
`)), w = Hr(w), w = Ol(w, l), w = Il(w, l), A = Hr(A), A = Ol(A, l), A = Il(A, l), w = V(w), A = V(A), f.isWebGL2 && !n.isRawShaderMaterial && (f = !1, P = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && w.match(P) !== null && A.match(P) !== null && (f = !0, w = w.replace(P, ""), A = A.replace(P, "")), y = `#version 300 es

#define attribute in
#define varying out
#define texture2D texture
` + y, e = [
      `#version 300 es

#define varying in`,
      f ? "" : "out highp vec4 pc_fragColor;",
      f ? "" : "#define gl_FragColor pc_fragColor",
      `#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad`
    ].join(`
`) + `
` + e), A = e + A, w = Js(p, 35633, y + w), A = Js(p, 35632, A), p.attachShader(gt, w), p.attachShader(gt, A), n.index0AttributeName !== void 0 ? p.bindAttribLocation(gt, 0, n.index0AttributeName) : l.morphTargets === !0 && p.bindAttribLocation(gt, 0, "position"), p.linkProgram(gt), l = p.getProgramInfoLog(gt).trim(), f = p.getShaderInfoLog(w).trim(), P = p.getShaderInfoLog(A).trim(), H = B = !0, p.getProgramParameter(gt, 35714) === !1 ? (B = !1, console.error(
      "THREE.WebGLProgram: shader error: ",
      p.getError(),
      "35715",
      p.getProgramParameter(gt, 35715),
      "gl.getProgramInfoLog",
      l,
      f,
      P
    )) : l !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", l) : (f === "" || P === "") && (H = !1), H && (this.diagnostics = {
      runnable: B,
      material: n,
      programLog: l,
      vertexShader: { log: f, prefix: y },
      fragmentShader: { log: P, prefix: e }
    }), p.deleteShader(w), p.deleteShader(A);
    var Ct;
    this.getUniforms = function() {
      return Ct === void 0 && (Ct = new ro(p, gt, t)), Ct;
    };
    var wt;
    return this.getAttributes = function() {
      if (wt === void 0) {
        for (var Vt = {}, Z = p.getProgramParameter(gt, 35721), ot = 0; ot < Z; ot++) {
          var zt = p.getActiveAttrib(gt, ot).name;
          Vt[zt] = p.getAttribLocation(gt, zt);
        }
        wt = Vt;
      }
      return wt;
    }, this.destroy = function() {
      p.deleteProgram(gt), this.program = void 0;
    }, Object.defineProperties(this, {
      uniforms: {
        get: function() {
          return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
        }
      },
      attributes: {
        get: function() {
          return console.warn(
            "THREE.WebGLProgram: .attributes is now .getAttributes()."
          ), this.getAttributes();
        }
      }
    }), this.name = o.name, this.id = ko++, this.code = i, this.usedTimes = 1, this.program = gt, this.vertexShader = w, this.fragmentShader = A, this;
  }
  function lt(t, e, i) {
    function n(p, y) {
      if (p)
        p.isTexture ? w = p.encoding : p.isWebGLRenderTarget && (console.warn(
          "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
        ), w = p.texture.encoding);
      else
        var w = 3e3;
      return w === 3e3 && y && (w = 3007), w;
    }
    var o = [], l = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "phong",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    }, f = "precision supportsVertexTextures map mapEncoding matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(
      " "
    );
    this.getParameters = function(p, y, w, A, P, B, H) {
      var q = l[p.type];
      if (H.isSkinnedMesh) {
        var $ = H.skeleton.bones;
        if (i.floatVertexTextures)
          $ = 1024;
        else {
          var rt = Math.min(
            Math.floor((i.maxVertexUniforms - 20) / 4),
            $.length
          );
          rt < $.length ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " + $.length + " bones. This GPU supports " + rt + "."
          ), $ = 0) : $ = rt;
        }
      } else
        $ = 0;
      rt = i.precision, p.precision !== null && (rt = i.getMaxPrecision(p.precision), rt !== p.precision && console.warn(
        "THREE.WebGLProgram.getParameters:",
        p.precision,
        "not supported, using",
        rt,
        "instead."
      ));
      var xt = t.getRenderTarget();
      return {
        shaderID: q,
        precision: rt,
        supportsVertexTextures: i.vertexTextures,
        outputEncoding: n(xt ? xt.texture : null, t.gammaOutput),
        map: !!p.map,
        mapEncoding: n(p.map, t.gammaInput),
        matcap: !!p.matcap,
        matcapEncoding: n(p.matcap, t.gammaInput),
        envMap: !!p.envMap,
        envMapMode: p.envMap && p.envMap.mapping,
        envMapEncoding: n(p.envMap, t.gammaInput),
        envMapCubeUV: !!p.envMap && (p.envMap.mapping === 306 || p.envMap.mapping === 307),
        lightMap: !!p.lightMap,
        aoMap: !!p.aoMap,
        emissiveMap: !!p.emissiveMap,
        emissiveMapEncoding: n(p.emissiveMap, t.gammaInput),
        bumpMap: !!p.bumpMap,
        normalMap: !!p.normalMap,
        objectSpaceNormalMap: p.normalMapType === 1,
        displacementMap: !!p.displacementMap,
        roughnessMap: !!p.roughnessMap,
        metalnessMap: !!p.metalnessMap,
        specularMap: !!p.specularMap,
        alphaMap: !!p.alphaMap,
        gradientMap: !!p.gradientMap,
        combine: p.combine,
        vertexColors: p.vertexColors,
        fog: !!A,
        useFog: p.fog,
        fogExp: A && A.isFogExp2,
        flatShading: p.flatShading,
        sizeAttenuation: p.sizeAttenuation,
        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
        skinning: p.skinning && 0 < $,
        maxBones: $,
        useVertexTexture: i.floatVertexTextures,
        morphTargets: p.morphTargets,
        morphNormals: p.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: y.directional.length,
        numPointLights: y.point.length,
        numSpotLights: y.spot.length,
        numRectAreaLights: y.rectArea.length,
        numHemiLights: y.hemi.length,
        numClippingPlanes: P,
        numClipIntersection: B,
        dithering: p.dithering,
        shadowMapEnabled: t.shadowMap.enabled && H.receiveShadow && 0 < w.length,
        shadowMapType: t.shadowMap.type,
        toneMapping: t.toneMapping,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: p.premultipliedAlpha,
        alphaTest: p.alphaTest,
        doubleSided: p.side === 2,
        flipSided: p.side === 1,
        depthPacking: p.depthPacking !== void 0 ? p.depthPacking : !1
      };
    }, this.getProgramCode = function(p, y) {
      var w = [];
      if (y.shaderID ? w.push(y.shaderID) : (w.push(p.fragmentShader), w.push(p.vertexShader)), p.defines !== void 0)
        for (var A in p.defines)
          w.push(A), w.push(p.defines[A]);
      for (A = 0; A < f.length; A++)
        w.push(y[f[A]]);
      return w.push(p.onBeforeCompile.toString()), w.push(t.gammaOutput), w.push(t.gammaFactor), w.join();
    }, this.acquireProgram = function(p, y, w, A) {
      for (var P, B = 0, H = o.length; B < H; B++) {
        var q = o[B];
        if (q.code === A) {
          P = q, ++P.usedTimes;
          break;
        }
      }
      return P === void 0 && (P = new tt(t, e, A, p, y, w, i), o.push(P)), P;
    }, this.releaseProgram = function(p) {
      if (--p.usedTimes === 0) {
        var y = o.indexOf(p);
        o[y] = o[o.length - 1], o.pop(), p.destroy();
      }
    }, this.programs = o;
  }
  function at() {
    var t = /* @__PURE__ */ new WeakMap();
    return {
      get: function(e) {
        var i = t.get(e);
        return i === void 0 && (i = {}, t.set(e, i)), i;
      },
      remove: function(e) {
        t.delete(e);
      },
      update: function(e, i, n) {
        t.get(e)[i] = n;
      },
      dispose: function() {
        t = /* @__PURE__ */ new WeakMap();
      }
    };
  }
  function X(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
  }
  function St(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
  }
  function ht() {
    var t = [], e = 0, i = [], n = [];
    return {
      opaque: i,
      transparent: n,
      init: function() {
        e = 0, i.length = 0, n.length = 0;
      },
      push: function(o, l, f, p, y) {
        var w = t[e];
        w === void 0 ? (w = {
          id: o.id,
          object: o,
          geometry: l,
          material: f,
          program: f.program,
          renderOrder: o.renderOrder,
          z: p,
          group: y
        }, t[e] = w) : (w.id = o.id, w.object = o, w.geometry = l, w.material = f, w.program = f.program, w.renderOrder = o.renderOrder, w.z = p, w.group = y), (f.transparent === !0 ? n : i).push(w), e++;
      },
      sort: function() {
        1 < i.length && i.sort(X), 1 < n.length && n.sort(St);
      }
    };
  }
  function Rt() {
    var t = {};
    return {
      get: function(e, i) {
        return e = e.id + "," + i.id, i = t[e], i === void 0 && (i = new ht(), t[e] = i), i;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function Ht() {
    var t = {};
    return {
      get: function(e) {
        if (t[e.id] !== void 0)
          return t[e.id];
        switch (e.type) {
          case "DirectionalLight":
            var i = {
              direction: new u(),
              color: new L(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new s()
            };
            break;
          case "SpotLight":
            i = {
              position: new u(),
              direction: new u(),
              color: new L(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new s()
            };
            break;
          case "PointLight":
            i = {
              position: new u(),
              color: new L(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new s(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case "HemisphereLight":
            i = { direction: new u(), skyColor: new L(), groundColor: new L() };
            break;
          case "RectAreaLight":
            i = {
              color: new L(),
              position: new u(),
              halfWidth: new u(),
              halfHeight: new u()
            };
        }
        return t[e.id] = i;
      }
    };
  }
  function kt() {
    var t = new Ht(), e = {
      id: Ih++,
      hash: {
        stateID: -1,
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        shadowsLength: -1
      },
      ambient: [0, 0, 0],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    }, i = new u(), n = new c(), o = new c();
    return {
      setup: function(l, f, p) {
        var y = 0, w = 0, A = 0, P = 0, B = 0, H = 0, q = 0, $ = 0;
        p = p.matrixWorldInverse;
        for (var rt = 0, xt = l.length; rt < xt; rt++) {
          var gt = l[rt], Ct = gt.color, wt = gt.intensity, Vt = gt.distance, Z = gt.shadow && gt.shadow.map ? gt.shadow.map.texture : null;
          if (gt.isAmbientLight)
            y += Ct.r * wt, w += Ct.g * wt, A += Ct.b * wt;
          else if (gt.isDirectionalLight) {
            var ot = t.get(gt);
            ot.color.copy(gt.color).multiplyScalar(gt.intensity), ot.direction.setFromMatrixPosition(gt.matrixWorld), i.setFromMatrixPosition(gt.target.matrixWorld), ot.direction.sub(i), ot.direction.transformDirection(p), (ot.shadow = gt.castShadow) && (Ct = gt.shadow, ot.shadowBias = Ct.bias, ot.shadowRadius = Ct.radius, ot.shadowMapSize = Ct.mapSize), e.directionalShadowMap[P] = Z, e.directionalShadowMatrix[P] = gt.shadow.matrix, e.directional[P] = ot, P++;
          } else
            gt.isSpotLight ? (ot = t.get(gt), ot.position.setFromMatrixPosition(gt.matrixWorld), ot.position.applyMatrix4(p), ot.color.copy(Ct).multiplyScalar(wt), ot.distance = Vt, ot.direction.setFromMatrixPosition(gt.matrixWorld), i.setFromMatrixPosition(gt.target.matrixWorld), ot.direction.sub(i), ot.direction.transformDirection(p), ot.coneCos = Math.cos(gt.angle), ot.penumbraCos = Math.cos(gt.angle * (1 - gt.penumbra)), ot.decay = gt.decay, (ot.shadow = gt.castShadow) && (Ct = gt.shadow, ot.shadowBias = Ct.bias, ot.shadowRadius = Ct.radius, ot.shadowMapSize = Ct.mapSize), e.spotShadowMap[H] = Z, e.spotShadowMatrix[H] = gt.shadow.matrix, e.spot[H] = ot, H++) : gt.isRectAreaLight ? (ot = t.get(gt), ot.color.copy(Ct).multiplyScalar(wt), ot.position.setFromMatrixPosition(gt.matrixWorld), ot.position.applyMatrix4(p), o.identity(), n.copy(gt.matrixWorld), n.premultiply(p), o.extractRotation(n), ot.halfWidth.set(0.5 * gt.width, 0, 0), ot.halfHeight.set(0, 0.5 * gt.height, 0), ot.halfWidth.applyMatrix4(o), ot.halfHeight.applyMatrix4(o), e.rectArea[q] = ot, q++) : gt.isPointLight ? (ot = t.get(gt), ot.position.setFromMatrixPosition(gt.matrixWorld), ot.position.applyMatrix4(p), ot.color.copy(gt.color).multiplyScalar(gt.intensity), ot.distance = gt.distance, ot.decay = gt.decay, (ot.shadow = gt.castShadow) && (Ct = gt.shadow, ot.shadowBias = Ct.bias, ot.shadowRadius = Ct.radius, ot.shadowMapSize = Ct.mapSize, ot.shadowCameraNear = Ct.camera.near, ot.shadowCameraFar = Ct.camera.far), e.pointShadowMap[B] = Z, e.pointShadowMatrix[B] = gt.shadow.matrix, e.point[B] = ot, B++) : gt.isHemisphereLight && (ot = t.get(gt), ot.direction.setFromMatrixPosition(gt.matrixWorld), ot.direction.transformDirection(p), ot.direction.normalize(), ot.skyColor.copy(gt.color).multiplyScalar(wt), ot.groundColor.copy(gt.groundColor).multiplyScalar(wt), e.hemi[$] = ot, $++);
        }
        e.ambient[0] = y, e.ambient[1] = w, e.ambient[2] = A, e.directional.length = P, e.spot.length = H, e.rectArea.length = q, e.point.length = B, e.hemi.length = $, e.hash.stateID = e.id, e.hash.directionalLength = P, e.hash.pointLength = B, e.hash.spotLength = H, e.hash.rectAreaLength = q, e.hash.hemiLength = $, e.hash.shadowsLength = f.length;
      },
      state: e
    };
  }
  function Mt() {
    var t = new kt(), e = [], i = [];
    return {
      init: function() {
        e.length = 0, i.length = 0;
      },
      state: { lightsArray: e, shadowsArray: i, lights: t },
      setupLights: function(n) {
        t.setup(e, i, n);
      },
      pushLight: function(n) {
        e.push(n);
      },
      pushShadow: function(n) {
        i.push(n);
      }
    };
  }
  function he() {
    var t = {};
    return {
      get: function(e, i) {
        if (t[e.id] === void 0) {
          var n = new Mt();
          t[e.id] = {}, t[e.id][i.id] = n;
        } else
          t[e.id][i.id] === void 0 ? (n = new Mt(), t[e.id][i.id] = n) : n = t[e.id][i.id];
        return n;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function se(t) {
    Yt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t);
  }
  function te(t) {
    Yt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new u(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t);
  }
  function ye(t, e, i) {
    function n(Z, ot, zt, ee, $t, qt) {
      var Te = Z.geometry, me = P, Ie = Z.customDepthMaterial;
      return zt && (me = B, Ie = Z.customDistanceMaterial), Ie ? me = Ie : (Ie = !1, ot.morphTargets && (Te && Te.isBufferGeometry ? Ie = Te.morphAttributes && Te.morphAttributes.position && 0 < Te.morphAttributes.position.length : Te && Te.isGeometry && (Ie = Te.morphTargets && 0 < Te.morphTargets.length)), Z.isSkinnedMesh && ot.skinning === !1 && console.warn(
        "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
        Z
      ), Z = Z.isSkinnedMesh && ot.skinning, Te = 0, Ie && (Te |= 1), Z && (Te |= 2), me = me[Te]), t.localClippingEnabled && ot.clipShadows === !0 && ot.clippingPlanes.length !== 0 && (Te = me.uuid, Ie = ot.uuid, Z = H[Te], Z === void 0 && (Z = {}, H[Te] = Z), Te = Z[Ie], Te === void 0 && (Te = me.clone(), Z[Ie] = Te), me = Te), me.visible = ot.visible, me.wireframe = ot.wireframe, me.side = ot.shadowSide != null ? ot.shadowSide : q[ot.side], me.clipShadows = ot.clipShadows, me.clippingPlanes = ot.clippingPlanes, me.clipIntersection = ot.clipIntersection, me.wireframeLinewidth = ot.wireframeLinewidth, me.linewidth = ot.linewidth, zt && me.isMeshDistanceMaterial && (me.referencePosition.copy(ee), me.nearDistance = $t, me.farDistance = qt), me;
    }
    function o(Z, ot, zt, ee) {
      if (Z.visible !== !1) {
        if (Z.layers.test(ot.layers) && (Z.isMesh || Z.isLine || Z.isPoints) && Z.castShadow && (!Z.frustumCulled || l.intersectsObject(Z))) {
          Z.modelViewMatrix.multiplyMatrices(
            zt.matrixWorldInverse,
            Z.matrixWorld
          );
          var $t = e.update(Z), qt = Z.material;
          if (Array.isArray(qt))
            for (var Te = $t.groups, me = 0, Ie = Te.length; me < Ie; me++) {
              var be = Te[me], ae = qt[be.materialIndex];
              ae && ae.visible && (ae = n(Z, ae, ee, A, zt.near, zt.far), t.renderBufferDirect(zt, null, $t, ae, Z, be));
            }
          else
            qt.visible && (ae = n(Z, qt, ee, A, zt.near, zt.far), t.renderBufferDirect(zt, null, $t, ae, Z, null));
        }
        for (Z = Z.children, $t = 0, qt = Z.length; $t < qt; $t++)
          o(Z[$t], ot, zt, ee);
      }
    }
    var l = new E(), f = new c(), p = new s(), y = new s(i, i), w = new u(), A = new u(), P = Array(4), B = Array(4), H = {}, q = { 0: 1, 1: 0, 2: 2 }, $ = [
      new u(1, 0, 0),
      new u(-1, 0, 0),
      new u(0, 0, 1),
      new u(0, 0, -1),
      new u(0, 1, 0),
      new u(0, -1, 0)
    ], rt = [
      new u(0, 1, 0),
      new u(0, 1, 0),
      new u(0, 1, 0),
      new u(0, 1, 0),
      new u(0, 0, 1),
      new u(0, 0, -1)
    ], xt = [new _(), new _(), new _(), new _(), new _(), new _()];
    for (i = 0; i !== 4; ++i) {
      var gt = (i & 1) !== 0, Ct = (i & 2) !== 0, wt = new se({ depthPacking: 3201, morphTargets: gt, skinning: Ct });
      P[i] = wt, gt = new te({ morphTargets: gt, skinning: Ct }), B[i] = gt;
    }
    var Vt = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(Z, ot, zt) {
      if (Vt.enabled !== !1 && (Vt.autoUpdate !== !1 || Vt.needsUpdate !== !1) && Z.length !== 0) {
        var ee = t.state;
        ee.disable(3042), ee.buffers.color.setClear(1, 1, 1, 1), ee.buffers.depth.setTest(!0), ee.setScissorTest(!1);
        for (var $t, qt = 0, Te = Z.length; qt < Te; qt++) {
          var me = Z[qt];
          $t = me.shadow;
          var Ie = me && me.isPointLight;
          if ($t === void 0)
            console.warn("THREE.WebGLShadowMap:", me, "has no shadow.");
          else {
            var be = $t.camera;
            if (p.copy($t.mapSize), p.min(y), Ie) {
              var ae = p.x, We = p.y;
              xt[0].set(2 * ae, We, ae, We), xt[1].set(0, We, ae, We), xt[2].set(3 * ae, We, ae, We), xt[3].set(ae, We, ae, We), xt[4].set(3 * ae, 0, ae, We), xt[5].set(ae, 0, ae, We), p.x *= 4, p.y *= 2;
            }
            for ($t.map === null && ($t.map = new S(p.x, p.y, {
              minFilter: 1003,
              magFilter: 1003,
              format: 1023
            }), $t.map.texture.name = me.name + ".shadowMap", be.updateProjectionMatrix()), $t.isSpotLightShadow && $t.update(me), ae = $t.map, We = $t.matrix, A.setFromMatrixPosition(me.matrixWorld), be.position.copy(A), Ie ? ($t = 6, We.makeTranslation(-A.x, -A.y, -A.z)) : ($t = 1, w.setFromMatrixPosition(me.target.matrixWorld), be.lookAt(w), be.updateMatrixWorld(), We.set(
              0.5,
              0,
              0,
              0.5,
              0,
              0.5,
              0,
              0.5,
              0,
              0,
              0.5,
              0.5,
              0,
              0,
              0,
              1
            ), We.multiply(be.projectionMatrix), We.multiply(be.matrixWorldInverse)), t.setRenderTarget(ae), t.clear(), me = 0; me < $t; me++)
              Ie && (w.copy(be.position), w.add($[me]), be.up.copy(rt[me]), be.lookAt(w), be.updateMatrixWorld(), ee.viewport(xt[me])), f.multiplyMatrices(be.projectionMatrix, be.matrixWorldInverse), l.setFromMatrix(f), o(ot, zt, be, Ie);
          }
        }
        Vt.needsUpdate = !1;
      }
    };
  }
  function ue(t, e, i, n) {
    function o(Ut, Ye, ei) {
      var Hi = new Uint8Array(4), Ae = t.createTexture();
      for (t.bindTexture(Ut, Ae), t.texParameteri(Ut, 10241, 9728), t.texParameteri(Ut, 10240, 9728), Ut = 0; Ut < ei; Ut++)
        t.texImage2D(Ye + Ut, 0, 6408, 1, 1, 0, 6408, 5121, Hi);
      return Ae;
    }
    function l(Ut, Ye) {
      xt[Ut] = 1, gt[Ut] === 0 && (t.enableVertexAttribArray(Ut), gt[Ut] = 1), Ct[Ut] !== Ye && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](Ut, Ye), Ct[Ut] = Ye);
    }
    function f(Ut) {
      wt[Ut] !== !0 && (t.enable(Ut), wt[Ut] = !0);
    }
    function p(Ut) {
      wt[Ut] !== !1 && (t.disable(Ut), wt[Ut] = !1);
    }
    function y(Ut, Ye, ei, Hi, Ae, Xe, ri, Ci) {
      if (Ut === 0)
        ot && (p(3042), ot = !1);
      else if (ot || (f(3042), ot = !0), Ut !== 5) {
        if (Ut !== zt || Ci !== be) {
          if ((ee !== 100 || Te !== 100) && (t.blendEquation(32774), Te = ee = 100), Ci)
            switch (Ut) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Ut);
            }
          else
            switch (Ut) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Ut);
            }
          Ie = me = qt = $t = null, zt = Ut, be = Ci;
        }
      } else
        Ae = Ae || Ye, Xe = Xe || ei, ri = ri || Hi, (Ye !== ee || Ae !== Te) && (t.blendEquationSeparate(i.convert(Ye), i.convert(Ae)), ee = Ye, Te = Ae), (ei !== $t || Hi !== qt || Xe !== me || ri !== Ie) && (t.blendFuncSeparate(
          i.convert(ei),
          i.convert(Hi),
          i.convert(Xe),
          i.convert(ri)
        ), $t = ei, qt = Hi, me = Xe, Ie = ri), zt = Ut, be = null;
    }
    function w(Ut) {
      ae !== Ut && (Ut ? t.frontFace(2304) : t.frontFace(2305), ae = Ut);
    }
    function A(Ut) {
      Ut !== 0 ? (f(2884), Ut !== We && (Ut === 1 ? t.cullFace(1029) : Ut === 2 ? t.cullFace(1028) : t.cullFace(1032))) : p(2884), We = Ut;
    }
    function P(Ut, Ye, ei) {
      Ut ? (f(32823), (ci !== Ye || Sn !== ei) && (t.polygonOffset(Ye, ei), ci = Ye, Sn = ei)) : p(32823);
    }
    function B(Ut) {
      Ut === void 0 && (Ut = 33984 + mn - 1), Gi !== Ut && (t.activeTexture(Ut), Gi = Ut);
    }
    var H = new function() {
      var Ut = !1, Ye = new _(), ei = null, Hi = new _(0, 0, 0, 0);
      return {
        setMask: function(Ae) {
          ei === Ae || Ut || (t.colorMask(Ae, Ae, Ae, Ae), ei = Ae);
        },
        setLocked: function(Ae) {
          Ut = Ae;
        },
        setClear: function(Ae, Xe, ri, Ci, bi) {
          bi === !0 && (Ae *= Ci, Xe *= Ci, ri *= Ci), Ye.set(Ae, Xe, ri, Ci), Hi.equals(Ye) === !1 && (t.clearColor(Ae, Xe, ri, Ci), Hi.copy(Ye));
        },
        reset: function() {
          Ut = !1, ei = null, Hi.set(-1, 0, 0, 0);
        }
      };
    }(), q = new function() {
      var Ut = !1, Ye = null, ei = null, Hi = null;
      return {
        setTest: function(Ae) {
          Ae ? f(2929) : p(2929);
        },
        setMask: function(Ae) {
          Ye === Ae || Ut || (t.depthMask(Ae), Ye = Ae);
        },
        setFunc: function(Ae) {
          if (ei !== Ae) {
            if (Ae)
              switch (Ae) {
                case 0:
                  t.depthFunc(512);
                  break;
                case 1:
                  t.depthFunc(519);
                  break;
                case 2:
                  t.depthFunc(513);
                  break;
                case 3:
                  t.depthFunc(515);
                  break;
                case 4:
                  t.depthFunc(514);
                  break;
                case 5:
                  t.depthFunc(518);
                  break;
                case 6:
                  t.depthFunc(516);
                  break;
                case 7:
                  t.depthFunc(517);
                  break;
                default:
                  t.depthFunc(515);
              }
            else
              t.depthFunc(515);
            ei = Ae;
          }
        },
        setLocked: function(Ae) {
          Ut = Ae;
        },
        setClear: function(Ae) {
          Hi !== Ae && (t.clearDepth(Ae), Hi = Ae);
        },
        reset: function() {
          Ut = !1, Hi = ei = Ye = null;
        }
      };
    }(), $ = new function() {
      var Ut = !1, Ye = null, ei = null, Hi = null, Ae = null, Xe = null, ri = null, Ci = null, bi = null;
      return {
        setTest: function(ne) {
          ne ? f(2960) : p(2960);
        },
        setMask: function(ne) {
          Ye === ne || Ut || (t.stencilMask(ne), Ye = ne);
        },
        setFunc: function(ne, ii, Ze) {
          (ei !== ne || Hi !== ii || Ae !== Ze) && (t.stencilFunc(ne, ii, Ze), ei = ne, Hi = ii, Ae = Ze);
        },
        setOp: function(ne, ii, Ze) {
          (Xe !== ne || ri !== ii || Ci !== Ze) && (t.stencilOp(ne, ii, Ze), Xe = ne, ri = ii, Ci = Ze);
        },
        setLocked: function(ne) {
          Ut = ne;
        },
        setClear: function(ne) {
          bi !== ne && (t.clearStencil(ne), bi = ne);
        },
        reset: function() {
          Ut = !1, bi = Ci = ri = Xe = Ae = Hi = ei = Ye = null;
        }
      };
    }(), rt = t.getParameter(34921), xt = new Uint8Array(rt), gt = new Uint8Array(rt), Ct = new Uint8Array(rt), wt = {}, Vt = null, Z = null, ot = null, zt = null, ee = null, $t = null, qt = null, Te = null, me = null, Ie = null, be = !1, ae = null, We = null, Qe = null, ci = null, Sn = null, mn = t.getParameter(35661), ji = !1;
    rt = 0, rt = t.getParameter(7938), rt.indexOf("WebGL") !== -1 ? (rt = parseFloat(/^WebGL ([0-9])/.exec(rt)[1]), ji = 1 <= rt) : rt.indexOf("OpenGL ES") !== -1 && (rt = parseFloat(/^OpenGL ES ([0-9])/.exec(rt)[1]), ji = 2 <= rt);
    var Gi = null, en = {}, En = new _(), Ce = new _(), ti = {};
    return ti[3553] = o(3553, 3553, 1), ti[34067] = o(34067, 34069, 6), H.setClear(0, 0, 0, 1), q.setClear(1), $.setClear(0), f(2929), q.setFunc(3), w(!1), A(1), f(2884), y(0), {
      buffers: { color: H, depth: q, stencil: $ },
      initAttributes: function() {
        for (var Ut = 0, Ye = xt.length; Ut < Ye; Ut++)
          xt[Ut] = 0;
      },
      enableAttribute: function(Ut) {
        l(Ut, 0);
      },
      enableAttributeAndDivisor: l,
      disableUnusedAttributes: function() {
        for (var Ut = 0, Ye = gt.length; Ut !== Ye; ++Ut)
          gt[Ut] !== xt[Ut] && (t.disableVertexAttribArray(Ut), gt[Ut] = 0);
      },
      enable: f,
      disable: p,
      getCompressedTextureFormats: function() {
        if (Vt === null && (Vt = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
          for (var Ut = t.getParameter(34467), Ye = 0; Ye < Ut.length; Ye++)
            Vt.push(Ut[Ye]);
        return Vt;
      },
      useProgram: function(Ut) {
        return Z !== Ut ? (t.useProgram(Ut), Z = Ut, !0) : !1;
      },
      setBlending: y,
      setMaterial: function(Ut, Ye) {
        Ut.side === 2 ? p(2884) : f(2884);
        var ei = Ut.side === 1;
        Ye && (ei = !ei), w(ei), Ut.blending === 1 && Ut.transparent === !1 ? y(0) : y(
          Ut.blending,
          Ut.blendEquation,
          Ut.blendSrc,
          Ut.blendDst,
          Ut.blendEquationAlpha,
          Ut.blendSrcAlpha,
          Ut.blendDstAlpha,
          Ut.premultipliedAlpha
        ), q.setFunc(Ut.depthFunc), q.setTest(Ut.depthTest), q.setMask(Ut.depthWrite), H.setMask(Ut.colorWrite), P(Ut.polygonOffset, Ut.polygonOffsetFactor, Ut.polygonOffsetUnits);
      },
      setFlipSided: w,
      setCullFace: A,
      setLineWidth: function(Ut) {
        Ut !== Qe && (ji && t.lineWidth(Ut), Qe = Ut);
      },
      setPolygonOffset: P,
      setScissorTest: function(Ut) {
        Ut ? f(3089) : p(3089);
      },
      activeTexture: B,
      bindTexture: function(Ut, Ye) {
        Gi === null && B();
        var ei = en[Gi];
        ei === void 0 && (ei = { type: void 0, texture: void 0 }, en[Gi] = ei), (ei.type !== Ut || ei.texture !== Ye) && (t.bindTexture(Ut, Ye || ti[Ut]), ei.type = Ut, ei.texture = Ye);
      },
      compressedTexImage2D: function() {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      texImage2D: function() {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      texImage3D: function() {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      scissor: function(Ut) {
        En.equals(Ut) === !1 && (t.scissor(Ut.x, Ut.y, Ut.z, Ut.w), En.copy(Ut));
      },
      viewport: function(Ut) {
        Ce.equals(Ut) === !1 && (t.viewport(Ut.x, Ut.y, Ut.z, Ut.w), Ce.copy(Ut));
      },
      reset: function() {
        for (var Ut = 0; Ut < gt.length; Ut++)
          gt[Ut] === 1 && (t.disableVertexAttribArray(Ut), gt[Ut] = 0);
        wt = {}, Gi = Vt = null, en = {}, We = ae = zt = Z = null, H.reset(), q.reset(), $.reset();
      }
    };
  }
  function je(t, e, i, n, o, l, f) {
    function p(Z, ot) {
      if (Z.width > ot || Z.height > ot) {
        if ("data" in Z) {
          console.warn(
            "THREE.WebGLRenderer: image in DataTexture is too big (" + Z.width + "x" + Z.height + ")."
          );
          return;
        }
        ot /= Math.max(Z.width, Z.height);
        var zt = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return zt.width = Math.floor(Z.width * ot), zt.height = Math.floor(Z.height * ot), zt.getContext("2d").drawImage(
          Z,
          0,
          0,
          Z.width,
          Z.height,
          0,
          0,
          zt.width,
          zt.height
        ), console.warn(
          "THREE.WebGLRenderer: image is too big (" + Z.width + "x" + Z.height + "). Resized to " + zt.width + "x" + zt.height
        ), zt;
      }
      return Z;
    }
    function y(Z) {
      return fi.isPowerOfTwo(Z.width) && fi.isPowerOfTwo(Z.height);
    }
    function w(Z, ot) {
      return Z.generateMipmaps && ot && Z.minFilter !== 1003 && Z.minFilter !== 1006;
    }
    function A(Z, ot, zt, ee) {
      t.generateMipmap(Z), n.get(ot).__maxMipLevel = Math.log(Math.max(zt, ee)) * Math.LOG2E;
    }
    function P(Z, ot) {
      if (!o.isWebGL2)
        return Z;
      if (Z === 6403) {
        if (ot === 5126)
          return 33326;
        if (ot === 5131)
          return 33325;
        if (ot === 5121)
          return 33321;
      }
      if (Z === 6407) {
        if (ot === 5126)
          return 34837;
        if (ot === 5131)
          return 34843;
        if (ot === 5121)
          return 32849;
      }
      if (Z === 6408) {
        if (ot === 5126)
          return 34836;
        if (ot === 5131)
          return 34842;
        if (ot === 5121)
          return 32856;
      }
      return Z;
    }
    function B(Z) {
      return Z === 1003 || Z === 1004 || Z === 1005 ? 9728 : 9729;
    }
    function H(Z) {
      Z = Z.target, Z.removeEventListener("dispose", H);
      t: {
        var ot = n.get(Z);
        if (Z.image && ot.__image__webglTextureCube)
          t.deleteTexture(ot.__image__webglTextureCube);
        else {
          if (ot.__webglInit === void 0)
            break t;
          t.deleteTexture(ot.__webglTexture);
        }
        n.remove(Z);
      }
      Z.isVideoTexture && delete wt[Z.id], f.memory.textures--;
    }
    function q(Z) {
      Z = Z.target, Z.removeEventListener("dispose", q);
      var ot = n.get(Z), zt = n.get(Z.texture);
      if (Z) {
        if (zt.__webglTexture !== void 0 && t.deleteTexture(zt.__webglTexture), Z.depthTexture && Z.depthTexture.dispose(), Z.isWebGLRenderTargetCube)
          for (zt = 0; 6 > zt; zt++)
            t.deleteFramebuffer(ot.__webglFramebuffer[zt]), ot.__webglDepthbuffer && t.deleteRenderbuffer(ot.__webglDepthbuffer[zt]);
        else
          t.deleteFramebuffer(ot.__webglFramebuffer), ot.__webglDepthbuffer && t.deleteRenderbuffer(ot.__webglDepthbuffer);
        n.remove(Z.texture), n.remove(Z);
      }
      f.memory.textures--;
    }
    function $(Z, ot) {
      var zt = n.get(Z);
      if (Z.isVideoTexture) {
        var ee = Z.id, $t = f.render.frame;
        wt[ee] !== $t && (wt[ee] = $t, Z.update());
      }
      if (0 < Z.version && zt.__version !== Z.version)
        if (ee = Z.image, ee === void 0)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined"
          );
        else if (ee.complete === !1)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        else {
          xt(zt, Z, ot);
          return;
        }
      i.activeTexture(33984 + ot), i.bindTexture(3553, zt.__webglTexture);
    }
    function rt(Z, ot, zt) {
      zt ? (t.texParameteri(Z, 10242, l.convert(ot.wrapS)), t.texParameteri(Z, 10243, l.convert(ot.wrapT)), t.texParameteri(Z, 10240, l.convert(ot.magFilter)), t.texParameteri(Z, 10241, l.convert(ot.minFilter))) : (t.texParameteri(Z, 10242, 33071), t.texParameteri(Z, 10243, 33071), ot.wrapS === 1001 && ot.wrapT === 1001 || console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
      ), t.texParameteri(Z, 10240, B(ot.magFilter)), t.texParameteri(Z, 10241, B(ot.minFilter)), ot.minFilter !== 1003 && ot.minFilter !== 1006 && console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
      )), !(zt = e.get("EXT_texture_filter_anisotropic")) || ot.type === 1015 && e.get("OES_texture_float_linear") === null || ot.type === 1016 && (o.isWebGL2 || e.get("OES_texture_half_float_linear")) === null || !(1 < ot.anisotropy || n.get(ot).__currentAnisotropy) || (t.texParameterf(
        Z,
        zt.TEXTURE_MAX_ANISOTROPY_EXT,
        Math.min(ot.anisotropy, o.getMaxAnisotropy())
      ), n.get(ot).__currentAnisotropy = ot.anisotropy);
    }
    function xt(Z, ot, zt) {
      var ee = ot.isDataTexture3D ? 32879 : 3553;
      Z.__webglInit === void 0 && (Z.__webglInit = !0, ot.addEventListener("dispose", H), Z.__webglTexture = t.createTexture(), f.memory.textures++), i.activeTexture(33984 + zt), i.bindTexture(ee, Z.__webglTexture), t.pixelStorei(37440, ot.flipY), t.pixelStorei(37441, ot.premultiplyAlpha), t.pixelStorei(3317, ot.unpackAlignment), zt = p(ot.image, o.maxTextureSize);
      var $t = o.isWebGL2 ? !1 : ot.wrapS !== 1001 || ot.wrapT !== 1001 || ot.minFilter !== 1003 && ot.minFilter !== 1006;
      $t && y(zt) === !1 && (zt instanceof HTMLImageElement || zt instanceof HTMLCanvasElement || zt instanceof ImageBitmap) && (Vt === void 0 && (Vt = document.createElementNS(
        "http://www.w3.org/1999/xhtml",
        "canvas"
      )), Vt.width = fi.floorPowerOfTwo(zt.width), Vt.height = fi.floorPowerOfTwo(zt.height), Vt.getContext("2d").drawImage(zt, 0, 0, Vt.width, Vt.height), console.warn(
        "THREE.WebGLRenderer: image is not power of two (" + zt.width + "x" + zt.height + "). Resized to " + Vt.width + "x" + Vt.height
      ), zt = Vt), $t = y(zt);
      var qt = l.convert(ot.format), Te = l.convert(ot.type), me = P(qt, Te);
      rt(ee, ot, $t);
      var Ie = ot.mipmaps;
      if (ot.isDepthTexture) {
        if (me = 6402, ot.type === 1015) {
          if (!o.isWebGL2)
            throw Error("Float Depth Texture only supported in WebGL2.0");
          me = 36012;
        } else
          o.isWebGL2 && (me = 33189);
        ot.format === 1026 && me === 6402 && ot.type !== 1012 && ot.type !== 1014 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
        ), ot.type = 1012, Te = l.convert(ot.type)), ot.format === 1027 && (me = 34041, ot.type !== 1020 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
        ), ot.type = 1020, Te = l.convert(ot.type))), i.texImage2D(3553, 0, me, zt.width, zt.height, 0, qt, Te, null);
      } else if (ot.isDataTexture)
        if (0 < Ie.length && $t) {
          for (var be = 0, ae = Ie.length; be < ae; be++)
            ee = Ie[be], i.texImage2D(3553, be, me, ee.width, ee.height, 0, qt, Te, ee.data);
          ot.generateMipmaps = !1, Z.__maxMipLevel = Ie.length - 1;
        } else
          i.texImage2D(3553, 0, me, zt.width, zt.height, 0, qt, Te, zt.data), Z.__maxMipLevel = 0;
      else if (ot.isCompressedTexture) {
        for (be = 0, ae = Ie.length; be < ae; be++)
          ee = Ie[be], ot.format !== 1023 && ot.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(qt) ? i.compressedTexImage2D(
            3553,
            be,
            me,
            ee.width,
            ee.height,
            0,
            ee.data
          ) : console.warn(
            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
          ) : i.texImage2D(3553, be, me, ee.width, ee.height, 0, qt, Te, ee.data);
        Z.__maxMipLevel = Ie.length - 1;
      } else if (ot.isDataTexture3D)
        i.texImage3D(32879, 0, me, zt.width, zt.height, zt.depth, 0, qt, Te, zt.data), Z.__maxMipLevel = 0;
      else if (0 < Ie.length && $t) {
        for (be = 0, ae = Ie.length; be < ae; be++)
          ee = Ie[be], i.texImage2D(3553, be, me, qt, Te, ee);
        ot.generateMipmaps = !1, Z.__maxMipLevel = Ie.length - 1;
      } else
        i.texImage2D(3553, 0, me, qt, Te, zt), Z.__maxMipLevel = 0;
      w(ot, $t) && A(3553, ot, zt.width, zt.height), Z.__version = ot.version, ot.onUpdate && ot.onUpdate(ot);
    }
    function gt(Z, ot, zt, ee) {
      var $t = l.convert(ot.texture.format), qt = l.convert(ot.texture.type), Te = P($t, qt);
      i.texImage2D(ee, 0, Te, ot.width, ot.height, 0, $t, qt, null), t.bindFramebuffer(36160, Z), t.framebufferTexture2D(36160, zt, ee, n.get(ot.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }
    function Ct(Z, ot) {
      t.bindRenderbuffer(36161, Z), ot.depthBuffer && !ot.stencilBuffer ? (t.renderbufferStorage(36161, 33189, ot.width, ot.height), t.framebufferRenderbuffer(36160, 36096, 36161, Z)) : ot.depthBuffer && ot.stencilBuffer ? (t.renderbufferStorage(36161, 34041, ot.width, ot.height), t.framebufferRenderbuffer(36160, 33306, 36161, Z)) : t.renderbufferStorage(36161, 32854, ot.width, ot.height), t.bindRenderbuffer(36161, null);
    }
    var wt = {}, Vt;
    this.setTexture2D = $, this.setTexture3D = function(Z, ot) {
      var zt = n.get(Z);
      0 < Z.version && zt.__version !== Z.version ? xt(zt, Z, ot) : (i.activeTexture(33984 + ot), i.bindTexture(32879, zt.__webglTexture));
    }, this.setTextureCube = function(Z, ot) {
      var zt = n.get(Z);
      if (Z.image.length === 6)
        if (0 < Z.version && zt.__version !== Z.version) {
          zt.__image__webglTextureCube || (Z.addEventListener("dispose", H), zt.__image__webglTextureCube = t.createTexture(), f.memory.textures++), i.activeTexture(33984 + ot), i.bindTexture(34067, zt.__image__webglTextureCube), t.pixelStorei(37440, Z.flipY), ot = Z && Z.isCompressedTexture;
          for (var ee = Z.image[0] && Z.image[0].isDataTexture, $t = [], qt = 0; 6 > qt; qt++)
            $t[qt] = ot || ee ? ee ? Z.image[qt].image : Z.image[qt] : p(Z.image[qt], o.maxCubemapSize);
          var Te = $t[0], me = y(Te), Ie = l.convert(Z.format), be = l.convert(Z.type), ae = P(Ie, be);
          for (rt(34067, Z, me), qt = 0; 6 > qt; qt++)
            if (ot)
              for (var We, Qe = $t[qt].mipmaps, ci = 0, Sn = Qe.length; ci < Sn; ci++)
                We = Qe[ci], Z.format !== 1023 && Z.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(Ie) ? i.compressedTexImage2D(
                  34069 + qt,
                  ci,
                  ae,
                  We.width,
                  We.height,
                  0,
                  We.data
                ) : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                ) : i.texImage2D(
                  34069 + qt,
                  ci,
                  ae,
                  We.width,
                  We.height,
                  0,
                  Ie,
                  be,
                  We.data
                );
            else
              ee ? i.texImage2D(
                34069 + qt,
                0,
                ae,
                $t[qt].width,
                $t[qt].height,
                0,
                Ie,
                be,
                $t[qt].data
              ) : i.texImage2D(34069 + qt, 0, ae, Ie, be, $t[qt]);
          zt.__maxMipLevel = ot ? Qe.length - 1 : 0, w(Z, me) && A(34067, Z, Te.width, Te.height), zt.__version = Z.version, Z.onUpdate && Z.onUpdate(Z);
        } else
          i.activeTexture(33984 + ot), i.bindTexture(34067, zt.__image__webglTextureCube);
    }, this.setTextureCubeDynamic = function(Z, ot) {
      i.activeTexture(33984 + ot), i.bindTexture(34067, n.get(Z).__webglTexture);
    }, this.setupRenderTarget = function(Z) {
      var ot = n.get(Z), zt = n.get(Z.texture);
      Z.addEventListener("dispose", q), zt.__webglTexture = t.createTexture(), f.memory.textures++;
      var ee = Z.isWebGLRenderTargetCube === !0, $t = y(Z);
      if (ee) {
        ot.__webglFramebuffer = [];
        for (var qt = 0; 6 > qt; qt++)
          ot.__webglFramebuffer[qt] = t.createFramebuffer();
      } else
        ot.__webglFramebuffer = t.createFramebuffer();
      if (ee) {
        for (i.bindTexture(34067, zt.__webglTexture), rt(34067, Z.texture, $t), qt = 0; 6 > qt; qt++)
          gt(ot.__webglFramebuffer[qt], Z, 36064, 34069 + qt);
        w(Z.texture, $t) && A(34067, Z.texture, Z.width, Z.height), i.bindTexture(34067, null);
      } else
        i.bindTexture(3553, zt.__webglTexture), rt(3553, Z.texture, $t), gt(ot.__webglFramebuffer, Z, 36064, 3553), w(Z.texture, $t) && A(3553, Z.texture, Z.width, Z.height), i.bindTexture(3553, null);
      if (Z.depthBuffer) {
        if (ot = n.get(Z), zt = Z.isWebGLRenderTargetCube === !0, Z.depthTexture) {
          if (zt)
            throw Error(
              "target.depthTexture not supported in Cube render targets"
            );
          if (Z && Z.isWebGLRenderTargetCube)
            throw Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (t.bindFramebuffer(36160, ot.__webglFramebuffer), !Z.depthTexture || !Z.depthTexture.isDepthTexture)
            throw Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          if (n.get(Z.depthTexture).__webglTexture && Z.depthTexture.image.width === Z.width && Z.depthTexture.image.height === Z.height || (Z.depthTexture.image.width = Z.width, Z.depthTexture.image.height = Z.height, Z.depthTexture.needsUpdate = !0), $(Z.depthTexture, 0), ot = n.get(Z.depthTexture).__webglTexture, Z.depthTexture.format === 1026)
            t.framebufferTexture2D(36160, 36096, 3553, ot, 0);
          else if (Z.depthTexture.format === 1027)
            t.framebufferTexture2D(36160, 33306, 3553, ot, 0);
          else
            throw Error("Unknown depthTexture format");
        } else if (zt)
          for (ot.__webglDepthbuffer = [], zt = 0; 6 > zt; zt++)
            t.bindFramebuffer(36160, ot.__webglFramebuffer[zt]), ot.__webglDepthbuffer[zt] = t.createRenderbuffer(), Ct(ot.__webglDepthbuffer[zt], Z);
        else
          t.bindFramebuffer(36160, ot.__webglFramebuffer), ot.__webglDepthbuffer = t.createRenderbuffer(), Ct(ot.__webglDepthbuffer, Z);
        t.bindFramebuffer(36160, null);
      }
    }, this.updateRenderTargetMipmap = function(Z) {
      var ot = Z.texture, zt = y(Z);
      if (w(ot, zt)) {
        zt = Z.isWebGLRenderTargetCube ? 34067 : 3553;
        var ee = n.get(ot).__webglTexture;
        i.bindTexture(zt, ee), A(zt, ot, Z.width, Z.height), i.bindTexture(zt, null);
      }
    };
  }
  function He(t, e, i) {
    return {
      convert: function(n) {
        if (n === 1e3)
          return 10497;
        if (n === 1001)
          return 33071;
        if (n === 1002)
          return 33648;
        if (n === 1003)
          return 9728;
        if (n === 1004)
          return 9984;
        if (n === 1005)
          return 9986;
        if (n === 1006)
          return 9729;
        if (n === 1007)
          return 9985;
        if (n === 1008)
          return 9987;
        if (n === 1009)
          return 5121;
        if (n === 1017)
          return 32819;
        if (n === 1018)
          return 32820;
        if (n === 1019)
          return 33635;
        if (n === 1010)
          return 5120;
        if (n === 1011)
          return 5122;
        if (n === 1012)
          return 5123;
        if (n === 1013)
          return 5124;
        if (n === 1014)
          return 5125;
        if (n === 1015)
          return 5126;
        if (n === 1016) {
          if (i.isWebGL2)
            return 5131;
          var o = e.get("OES_texture_half_float");
          if (o !== null)
            return o.HALF_FLOAT_OES;
        }
        if (n === 1021)
          return 6406;
        if (n === 1022)
          return 6407;
        if (n === 1023)
          return 6408;
        if (n === 1024)
          return 6409;
        if (n === 1025)
          return 6410;
        if (n === 1026)
          return 6402;
        if (n === 1027)
          return 34041;
        if (n === 1028)
          return 6403;
        if (n === 100)
          return 32774;
        if (n === 101)
          return 32778;
        if (n === 102)
          return 32779;
        if (n === 200)
          return 0;
        if (n === 201)
          return 1;
        if (n === 202)
          return 768;
        if (n === 203)
          return 769;
        if (n === 204)
          return 770;
        if (n === 205)
          return 771;
        if (n === 206)
          return 772;
        if (n === 207)
          return 773;
        if (n === 208)
          return 774;
        if (n === 209)
          return 775;
        if (n === 210)
          return 776;
        if ((n === 33776 || n === 33777 || n === 33778 || n === 33779) && (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null)) {
          if (n === 33776)
            return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (n === 33777)
            return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (n === 33778)
            return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (n === 33779)
            return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if ((n === 35840 || n === 35841 || n === 35842 || n === 35843) && (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null)) {
          if (n === 35840)
            return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (n === 35841)
            return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (n === 35842)
            return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (n === 35843)
            return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (n === 36196 && (o = e.get("WEBGL_compressed_texture_etc1"), o !== null))
          return o.COMPRESSED_RGB_ETC1_WEBGL;
        if ((n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821) && (o = e.get("WEBGL_compressed_texture_astc"), o !== null))
          return n;
        if (n === 103 || n === 104) {
          if (i.isWebGL2) {
            if (n === 103)
              return 32775;
            if (n === 104)
              return 32776;
          }
          if (o = e.get("EXT_blend_minmax"), o !== null) {
            if (n === 103)
              return o.MIN_EXT;
            if (n === 104)
              return o.MAX_EXT;
          }
        }
        if (n === 1020) {
          if (i.isWebGL2)
            return 34042;
          if (o = e.get("WEBGL_depth_texture"), o !== null)
            return o.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      }
    };
  }
  function ui() {
    N.call(this), this.type = "Group";
  }
  function Be() {
    N.call(this), this.type = "Camera", this.matrixWorldInverse = new c(), this.projectionMatrix = new c(), this.projectionMatrixInverse = new c();
  }
  function _e(t, e, i, n) {
    Be.call(this), this.type = "PerspectiveCamera", this.fov = t !== void 0 ? t : 50, this.zoom = 1, this.near = i !== void 0 ? i : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = e !== void 0 ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  function Fe(t) {
    _e.call(this), this.cameras = t || [];
  }
  function pe(t, e, i) {
    es.setFromMatrixPosition(e.matrixWorld), yr.setFromMatrixPosition(i.matrixWorld);
    var n = es.distanceTo(yr), o = e.projectionMatrix.elements, l = i.projectionMatrix.elements, f = o[14] / (o[10] - 1);
    i = o[14] / (o[10] + 1);
    var p = (o[9] + 1) / o[5], y = (o[9] - 1) / o[5], w = (o[8] - 1) / o[0], A = (l[8] + 1) / l[0];
    o = f * w, l = f * A, A = n / (-w + A), w = A * -w, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(w), t.translateZ(A), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = f + A, f = i + A, t.projectionMatrix.makePerspective(
      o - w,
      l + (n - w),
      p * i / f * e,
      y * i / f * e,
      e,
      f
    );
  }
  function di(t) {
    function e() {
      return o !== null && o.isPresenting === !0;
    }
    function i() {
      if (e()) {
        var Z = o.getEyeParameters("left"), ot = Z.renderWidth * A;
        Z = Z.renderHeight * A, Ct = t.getPixelRatio(), gt = t.getSize(), t.setDrawingBufferSize(2 * ot, Z, 1), Vt.start();
      } else
        n.enabled && t.setDrawingBufferSize(gt.width, gt.height, Ct), Vt.stop();
    }
    var n = this, o = null, l = null, f = null, p = [], y = new c(), w = new c(), A = 1, P = "stage";
    typeof window < "u" && "VRFrameData" in window && (l = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", i, !1));
    var B = new c(), H = new d(), q = new u(), $ = new _e();
    $.bounds = new _(0, 0, 0.5, 1), $.layers.enable(1);
    var rt = new _e();
    rt.bounds = new _(0.5, 0, 0.5, 1), rt.layers.enable(2);
    var xt = new Fe([$, rt]);
    xt.layers.enable(1), xt.layers.enable(2);
    var gt, Ct, wt = [];
    this.enabled = !1, this.getController = function(Z) {
      var ot = p[Z];
      return ot === void 0 && (ot = new ui(), ot.matrixAutoUpdate = !1, ot.visible = !1, p[Z] = ot), ot;
    }, this.getDevice = function() {
      return o;
    }, this.setDevice = function(Z) {
      Z !== void 0 && (o = Z), Vt.setContext(Z);
    }, this.setFramebufferScaleFactor = function(Z) {
      A = Z;
    }, this.setFrameOfReferenceType = function(Z) {
      P = Z;
    }, this.setPoseTarget = function(Z) {
      Z !== void 0 && (f = Z);
    }, this.getCamera = function(Z) {
      var ot = P === "stage" ? 1.6 : 0;
      if (o === null)
        return Z.position.set(0, ot, 0), Z;
      if (o.depthNear = Z.near, o.depthFar = Z.far, o.getFrameData(l), P === "stage") {
        var zt = o.stageParameters;
        zt ? y.fromArray(zt.sittingToStandingTransform) : y.makeTranslation(0, ot, 0);
      }
      if (ot = l.pose, zt = f !== null ? f : Z, zt.matrix.copy(y), zt.matrix.decompose(zt.position, zt.quaternion, zt.scale), ot.orientation !== null && (H.fromArray(ot.orientation), zt.quaternion.multiply(H)), ot.position !== null && (H.setFromRotationMatrix(y), q.fromArray(ot.position), q.applyQuaternion(H), zt.position.add(q)), zt.updateMatrixWorld(), o.isPresenting === !1)
        return Z;
      $.near = Z.near, rt.near = Z.near, $.far = Z.far, rt.far = Z.far, $.matrixWorldInverse.fromArray(l.leftViewMatrix), rt.matrixWorldInverse.fromArray(l.rightViewMatrix), w.getInverse(y), P === "stage" && ($.matrixWorldInverse.multiply(w), rt.matrixWorldInverse.multiply(w)), Z = zt.parent, Z !== null && (B.getInverse(Z.matrixWorld), $.matrixWorldInverse.multiply(B), rt.matrixWorldInverse.multiply(B)), $.matrixWorld.getInverse($.matrixWorldInverse), rt.matrixWorld.getInverse(rt.matrixWorldInverse), $.projectionMatrix.fromArray(l.leftProjectionMatrix), rt.projectionMatrix.fromArray(l.rightProjectionMatrix), pe(xt, $, rt), Z = o.getLayers(), Z.length && (Z = Z[0], Z.leftBounds !== null && Z.leftBounds.length === 4 && $.bounds.fromArray(Z.leftBounds), Z.rightBounds !== null && Z.rightBounds.length === 4 && rt.bounds.fromArray(Z.rightBounds));
      t:
        for (Z = 0; Z < p.length; Z++) {
          ot = p[Z];
          e: {
            zt = Z;
            for (var ee = navigator.getGamepads && navigator.getGamepads(), $t = 0, qt = 0, Te = ee.length; $t < Te; $t++) {
              var me = ee[$t];
              if (me && (me.id === "Daydream Controller" || me.id === "Gear VR Controller" || me.id === "Oculus Go Controller" || me.id === "OpenVR Gamepad" || me.id.startsWith("Oculus Touch") || me.id.startsWith("Spatial Controller"))) {
                if (qt === zt) {
                  zt = me;
                  break e;
                }
                qt++;
              }
            }
            zt = void 0;
          }
          if (zt !== void 0 && zt.pose !== void 0) {
            if (zt.pose === null)
              break t;
            ee = zt.pose, ee.hasPosition === !1 && ot.position.set(0.2, -0.6, -0.05), ee.position !== null && ot.position.fromArray(ee.position), ee.orientation !== null && ot.quaternion.fromArray(ee.orientation), ot.matrix.compose(ot.position, ot.quaternion, ot.scale), ot.matrix.premultiply(y), ot.matrix.decompose(ot.position, ot.quaternion, ot.scale), ot.matrixWorldNeedsUpdate = !0, ot.visible = !0, ee = zt.id === "Daydream Controller" ? 0 : 1, wt[Z] !== zt.buttons[ee].pressed && (wt[Z] = zt.buttons[ee].pressed, wt[Z] === !0 ? ot.dispatchEvent({ type: "selectstart" }) : (ot.dispatchEvent({ type: "selectend" }), ot.dispatchEvent({ type: "select" })));
          } else
            ot.visible = !1;
        }
      return xt;
    }, this.getStandingMatrix = function() {
      return y;
    }, this.isPresenting = e;
    var Vt = new T();
    this.setAnimationLoop = function(Z) {
      Vt.setAnimationLoop(Z);
    }, this.submitFrame = function() {
      e() && o.submitFrame();
    }, this.dispose = function() {
      typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", i);
    };
  }
  function Pe(t) {
    function e() {
      return p !== null && w !== null;
    }
    function i(Ct) {
      var wt = B[H.indexOf(Ct.inputSource)];
      wt && wt.dispatchEvent({ type: Ct.type });
    }
    function n() {
      t.setFramebuffer(null), gt.stop();
    }
    function o(Ct, wt) {
      wt === null ? Ct.matrixWorld.copy(Ct.matrix) : Ct.matrixWorld.multiplyMatrices(wt.matrixWorld, Ct.matrix), Ct.matrixWorldInverse.getInverse(Ct.matrixWorld);
    }
    var l = t.context, f = null, p = null, y = 1, w = null, A = "stage", P = null, B = [], H = [], q = new _e();
    q.layers.enable(1), q.viewport = new _();
    var $ = new _e();
    $.layers.enable(2), $.viewport = new _();
    var rt = new Fe([q, $]);
    rt.layers.enable(1), rt.layers.enable(2), this.enabled = !1, this.getController = function(Ct) {
      var wt = B[Ct];
      return wt === void 0 && (wt = new ui(), wt.matrixAutoUpdate = !1, wt.visible = !1, B[Ct] = wt), wt;
    }, this.getDevice = function() {
      return f;
    }, this.setDevice = function(Ct) {
      Ct !== void 0 && (f = Ct), Ct instanceof XRDevice && l.setCompatibleXRDevice(Ct);
    }, this.setFramebufferScaleFactor = function(Ct) {
      y = Ct;
    }, this.setFrameOfReferenceType = function(Ct) {
      A = Ct;
    }, this.setSession = function(Ct) {
      p = Ct, p !== null && (p.addEventListener("select", i), p.addEventListener("selectstart", i), p.addEventListener("selectend", i), p.addEventListener("end", n), p.baseLayer = new XRWebGLLayer(p, l, { framebufferScaleFactor: y }), p.requestFrameOfReference(A).then(function(wt) {
        w = wt, t.setFramebuffer(p.baseLayer.framebuffer), gt.setContext(p), gt.start();
      }), H = p.getInputSources(), p.addEventListener("inputsourceschange", function() {
        H = p.getInputSources(), console.log(H);
        for (var wt = 0; wt < B.length; wt++)
          B[wt].userData.inputSource = H[wt];
      }));
    }, this.getCamera = function(Ct) {
      if (e()) {
        var wt = Ct.parent, Vt = rt.cameras;
        o(rt, wt);
        for (var Z = 0; Z < Vt.length; Z++)
          o(Vt[Z], wt);
        for (Ct.matrixWorld.copy(rt.matrixWorld), Ct = Ct.children, Z = 0, wt = Ct.length; Z < wt; Z++)
          Ct[Z].updateMatrixWorld(!0);
        return pe(rt, q, $), rt;
      }
      return Ct;
    }, this.isPresenting = e;
    var xt = null, gt = new T();
    gt.setAnimationLoop(function(Ct, wt) {
      if (P = wt.getDevicePose(w), P !== null)
        for (var Vt = p.baseLayer, Z = wt.views, ot = 0; ot < Z.length; ot++) {
          var zt = Z[ot], ee = Vt.getViewport(zt), $t = P.getViewMatrix(zt), qt = rt.cameras[ot];
          qt.matrix.fromArray($t).getInverse(qt.matrix), qt.projectionMatrix.fromArray(zt.projectionMatrix), qt.viewport.set(ee.x, ee.y, ee.width, ee.height), ot === 0 && rt.matrix.copy(qt.matrix);
        }
      for (ot = 0; ot < B.length; ot++) {
        if (Vt = B[ot], (Z = H[ot]) && (Z = wt.getInputPose(Z, w), Z !== null)) {
          "targetRay" in Z ? Vt.matrix.elements = Z.targetRay.transformMatrix : "pointerMatrix" in Z && (Vt.matrix.elements = Z.pointerMatrix), Vt.matrix.decompose(Vt.position, Vt.rotation, Vt.scale), Vt.visible = !0;
          continue;
        }
        Vt.visible = !1;
      }
      xt && xt(Ct);
    }), this.setAnimationLoop = function(Ct) {
      xt = Ct;
    }, this.dispose = function() {
    }, this.getStandingMatrix = function() {
      return console.warn(
        "THREE.WebXRManager: getStandingMatrix() is no longer needed."
      ), new THREE.Matrix4();
    }, this.submitFrame = function() {
    };
  }
  function xe(t) {
    var e;
    function i() {
      ii = new Jt(ne), Ze = new Ji(ne, ii, t), Ze.isWebGL2 || (ii.get("WEBGL_depth_texture"), ii.get("OES_texture_float"), ii.get("OES_texture_half_float"), ii.get("OES_texture_half_float_linear"), ii.get("OES_standard_derivatives"), ii.get("OES_element_index_uint"), ii.get("ANGLE_instanced_arrays")), ii.get("OES_texture_float_linear"), Ln = new He(ne, ii, Ze), ai = new ue(ne, ii, Ln, Ze), ai.scissor(ji.copy(Ye).multiplyScalar(ti)), ai.viewport(mn.copy(Ut).multiplyScalar(ti)), gn = new dt(), bn = new at(), Bo = new je(ne, ii, ai, bn, Ze, Ln, gn), Ta = new M(ne), zh = new Wt(ne, Ta, gn), Ma = new Kt(zh, gn), kh = new ie(ne), zs = new lt(qt, ii, Ze), pl = new Rt(), ks = new he(), ns = new Ri(qt, ai, Ma, Z), Bh = new cn(ne, ii, gn, Ze), Qn = new pt(ne, ii, gn, Ze), gn.programs = zs.programs, qt.context = ne, qt.capabilities = Ze, qt.extensions = ii, qt.properties = bn, qt.renderLists = pl, qt.state = ai, qt.info = gn;
    }
    function n(ft) {
      ft.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), Te = !0;
    }
    function o() {
      console.log("THREE.WebGLRenderer: Context Restored."), Te = !1, i();
    }
    function l(ft) {
      ft = ft.target, ft.removeEventListener("dispose", l), f(ft), bn.remove(ft);
    }
    function f(ft) {
      var Tt = bn.get(ft).program;
      ft.program = void 0, Tt !== void 0 && zs.releaseProgram(Tt);
    }
    function p(ft, Tt) {
      ft.render(function(mt) {
        qt.renderBufferImmediate(mt, Tt);
      });
    }
    function y(ft, Tt, mt) {
      if (ft.visible !== !1) {
        if (ft.layers.test(Tt.layers)) {
          if (ft.isLight)
            $t.pushLight(ft), ft.castShadow && $t.pushShadow(ft);
          else if (ft.isSprite) {
            if (!ft.frustumCulled || Hi.intersectsSprite(ft)) {
              mt && bi.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Ci);
              var Me = Ma.update(ft), De = ft.material;
              ee.push(ft, Me, De, bi.z, null);
            }
          } else if (ft.isImmediateRenderObject)
            mt && bi.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Ci), ee.push(ft, null, ft.material, bi.z, null);
          else if ((ft.isMesh || ft.isLine || ft.isPoints) && (ft.isSkinnedMesh && ft.skeleton.update(), !ft.frustumCulled || Hi.intersectsObject(ft)))
            if (mt && bi.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Ci), Me = Ma.update(ft), De = ft.material, Array.isArray(De))
              for (var Ve = Me.groups, Se = 0, Ke = Ve.length; Se < Ke; Se++) {
                var Pi = Ve[Se], Zi = De[Pi.materialIndex];
                Zi && Zi.visible && ee.push(ft, Me, Zi, bi.z, Pi);
              }
            else
              De.visible && ee.push(ft, Me, De, bi.z, null);
        }
        for (ft = ft.children, Se = 0, Ke = ft.length; Se < Ke; Se++)
          y(ft[Se], Tt, mt);
      }
    }
    function w(ft, Tt, mt, Me) {
      for (var De = 0, Ve = ft.length; De < Ve; De++) {
        var Se = ft[De], Ke = Se.object, Pi = Se.geometry, Zi = Me === void 0 ? Se.material : Me;
        if (Se = Se.group, mt.isArrayCamera) {
          Sn = mt;
          for (var ve = mt.cameras, _r = 0, zn = ve.length; _r < zn; _r++) {
            var on = ve[_r];
            if (Ke.layers.test(on.layers)) {
              if ("viewport" in on)
                ai.viewport(mn.copy(on.viewport));
              else {
                var hr = on.bounds;
                ai.viewport(
                  mn.set(hr.x * En, hr.y * Ce, hr.z * En, hr.w * Ce).multiplyScalar(ti)
                );
              }
              $t.setupLights(on), A(Ke, Tt, on, Pi, Zi, Se);
            }
          }
        } else
          Sn = null, A(Ke, Tt, mt, Pi, Zi, Se);
      }
    }
    function A(ft, Tt, mt, Me, De, Ve) {
      if (ft.onBeforeRender(qt, Tt, mt, Me, De, Ve), $t = ks.get(Tt, Sn || mt), ft.modelViewMatrix.multiplyMatrices(mt.matrixWorldInverse, ft.matrixWorld), ft.normalMatrix.getNormalMatrix(ft.modelViewMatrix), ft.isImmediateRenderObject) {
        ai.setMaterial(De);
        var Se = B(mt, Tt.fog, De, ft);
        We = e = null, Qe = !1, p(ft, Se);
      } else
        qt.renderBufferDirect(mt, Tt.fog, Me, De, ft, Ve);
      ft.onAfterRender(qt, Tt, mt, Me, De, Ve), $t = ks.get(Tt, Sn || mt);
    }
    function P(ft, Tt, mt) {
      var Me = bn.get(ft), De = $t.state.lights, Ve = Me.lightsHash, Se = De.state.hash;
      mt = zs.getParameters(
        ft,
        De.state,
        $t.state.shadowsArray,
        Tt,
        Ae.numPlanes,
        Ae.numIntersection,
        mt
      );
      var Ke = zs.getProgramCode(ft, mt), Pi = Me.program, Zi = !0;
      if (Pi === void 0)
        ft.addEventListener("dispose", l);
      else if (Pi.code !== Ke)
        f(ft);
      else {
        if (Ve.stateID !== Se.stateID || Ve.directionalLength !== Se.directionalLength || Ve.pointLength !== Se.pointLength || Ve.spotLength !== Se.spotLength || Ve.rectAreaLength !== Se.rectAreaLength || Ve.hemiLength !== Se.hemiLength || Ve.shadowsLength !== Se.shadowsLength)
          Ve.stateID = Se.stateID, Ve.directionalLength = Se.directionalLength, Ve.pointLength = Se.pointLength, Ve.spotLength = Se.spotLength, Ve.rectAreaLength = Se.rectAreaLength, Ve.hemiLength = Se.hemiLength, Ve.shadowsLength = Se.shadowsLength;
        else if (mt.shaderID !== void 0)
          return;
        Zi = !1;
      }
      if (Zi && (mt.shaderID ? (Ke = go[mt.shaderID], Me.shader = {
        name: ft.type,
        uniforms: Dn.clone(Ke.uniforms),
        vertexShader: Ke.vertexShader,
        fragmentShader: Ke.fragmentShader
      }) : Me.shader = {
        name: ft.type,
        uniforms: ft.uniforms,
        vertexShader: ft.vertexShader,
        fragmentShader: ft.fragmentShader
      }, ft.onBeforeCompile(Me.shader, qt), Ke = zs.getProgramCode(ft, mt), Pi = zs.acquireProgram(ft, Me.shader, mt, Ke), Me.program = Pi, ft.program = Pi), mt = Pi.getAttributes(), ft.morphTargets)
        for (Ke = ft.numSupportedMorphTargets = 0; Ke < qt.maxMorphTargets; Ke++)
          0 <= mt["morphTarget" + Ke] && ft.numSupportedMorphTargets++;
      if (ft.morphNormals)
        for (Ke = ft.numSupportedMorphNormals = 0; Ke < qt.maxMorphNormals; Ke++)
          0 <= mt["morphNormal" + Ke] && ft.numSupportedMorphNormals++;
      mt = Me.shader.uniforms, (!ft.isShaderMaterial && !ft.isRawShaderMaterial || ft.clipping === !0) && (Me.numClippingPlanes = Ae.numPlanes, Me.numIntersection = Ae.numIntersection, mt.clippingPlanes = Ae.uniform), Me.fog = Tt, Ve === void 0 && (Me.lightsHash = Ve = {}), Ve.stateID = Se.stateID, Ve.directionalLength = Se.directionalLength, Ve.pointLength = Se.pointLength, Ve.spotLength = Se.spotLength, Ve.rectAreaLength = Se.rectAreaLength, Ve.hemiLength = Se.hemiLength, Ve.shadowsLength = Se.shadowsLength, ft.lights && (mt.ambientLightColor.value = De.state.ambient, mt.directionalLights.value = De.state.directional, mt.spotLights.value = De.state.spot, mt.rectAreaLights.value = De.state.rectArea, mt.pointLights.value = De.state.point, mt.hemisphereLights.value = De.state.hemi, mt.directionalShadowMap.value = De.state.directionalShadowMap, mt.directionalShadowMatrix.value = De.state.directionalShadowMatrix, mt.spotShadowMap.value = De.state.spotShadowMap, mt.spotShadowMatrix.value = De.state.spotShadowMatrix, mt.pointShadowMap.value = De.state.pointShadowMap, mt.pointShadowMatrix.value = De.state.pointShadowMatrix), ft = Me.program.getUniforms(), ft = ro.seqWithValue(ft.seq, mt), Me.uniformsList = ft;
    }
    function B(ft, Tt, mt, Me) {
      en = 0;
      var De = bn.get(mt), Ve = De.lightsHash, Se = $t.state.lights.state.hash;
      Xe && (ri || ft !== ci) && Ae.setState(
        mt.clippingPlanes,
        mt.clipIntersection,
        mt.clipShadows,
        ft,
        De,
        ft === ci && mt.id === ae
      ), mt.needsUpdate === !1 && (De.program === void 0 || mt.fog && De.fog !== Tt ? mt.needsUpdate = !0 : (!mt.lights || Ve.stateID === Se.stateID && Ve.directionalLength === Se.directionalLength && Ve.pointLength === Se.pointLength && Ve.spotLength === Se.spotLength && Ve.rectAreaLength === Se.rectAreaLength && Ve.hemiLength === Se.hemiLength && Ve.shadowsLength === Se.shadowsLength) && (De.numClippingPlanes === void 0 || De.numClippingPlanes === Ae.numPlanes && De.numIntersection === Ae.numIntersection) || (mt.needsUpdate = !0)), mt.needsUpdate && (P(mt, Tt, Me), mt.needsUpdate = !1);
      var Ke = !1, Pi = !1, Zi = !1;
      Ve = De.program, Se = Ve.getUniforms();
      var ve = De.shader.uniforms;
      if (ai.useProgram(Ve.program) && (Zi = Pi = Ke = !0), mt.id !== ae && (ae = mt.id, Pi = !0), (Ke || ci !== ft) && (Se.setValue(ne, "projectionMatrix", ft.projectionMatrix), Ze.logarithmicDepthBuffer && Se.setValue(ne, "logDepthBufFC", 2 / (Math.log(ft.far + 1) / Math.LN2)), ci !== ft && (ci = ft, Zi = Pi = !0), (mt.isShaderMaterial || mt.isMeshPhongMaterial || mt.isMeshStandardMaterial || mt.envMap) && (Ke = Se.map.cameraPosition, Ke !== void 0 && Ke.setValue(ne, bi.setFromMatrixPosition(ft.matrixWorld))), (mt.isMeshPhongMaterial || mt.isMeshLambertMaterial || mt.isMeshBasicMaterial || mt.isMeshStandardMaterial || mt.isShaderMaterial || mt.skinning) && Se.setValue(ne, "viewMatrix", ft.matrixWorldInverse)), mt.skinning && (Se.setOptional(ne, Me, "bindMatrix"), Se.setOptional(ne, Me, "bindMatrixInverse"), ft = Me.skeleton))
        if (Ke = ft.bones, Ze.floatVertexTextures) {
          if (ft.boneTexture === void 0) {
            Ke = Math.sqrt(4 * Ke.length), Ke = fi.ceilPowerOfTwo(Ke), Ke = Math.max(Ke, 4);
            var _r = new Float32Array(Ke * Ke * 4);
            _r.set(ft.boneMatrices);
            var zn = new O(_r, Ke, Ke, 1023, 1015);
            zn.needsUpdate = !0, ft.boneMatrices = _r, ft.boneTexture = zn, ft.boneTextureSize = Ke;
          }
          Se.setValue(ne, "boneTexture", ft.boneTexture), Se.setValue(ne, "boneTextureSize", ft.boneTextureSize);
        } else
          Se.setOptional(ne, ft, "boneMatrices");
      return Pi && (Se.setValue(ne, "toneMappingExposure", qt.toneMappingExposure), Se.setValue(ne, "toneMappingWhitePoint", qt.toneMappingWhitePoint), mt.lights && (Pi = Zi, ve.ambientLightColor.needsUpdate = Pi, ve.directionalLights.needsUpdate = Pi, ve.pointLights.needsUpdate = Pi, ve.spotLights.needsUpdate = Pi, ve.rectAreaLights.needsUpdate = Pi, ve.hemisphereLights.needsUpdate = Pi), Tt && mt.fog && (ve.fogColor.value = Tt.color, Tt.isFog ? (ve.fogNear.value = Tt.near, ve.fogFar.value = Tt.far) : Tt.isFogExp2 && (ve.fogDensity.value = Tt.density)), mt.isMeshBasicMaterial ? H(ve, mt) : mt.isMeshLambertMaterial ? (H(ve, mt), mt.emissiveMap && (ve.emissiveMap.value = mt.emissiveMap)) : mt.isMeshPhongMaterial ? (H(ve, mt), mt.isMeshToonMaterial ? (q(ve, mt), mt.gradientMap && (ve.gradientMap.value = mt.gradientMap)) : q(ve, mt)) : mt.isMeshStandardMaterial ? (H(ve, mt), mt.isMeshPhysicalMaterial ? ($(ve, mt), ve.reflectivity.value = mt.reflectivity, ve.clearCoat.value = mt.clearCoat, ve.clearCoatRoughness.value = mt.clearCoatRoughness) : $(ve, mt)) : mt.isMeshMatcapMaterial ? (H(ve, mt), mt.matcap && (ve.matcap.value = mt.matcap), mt.bumpMap && (ve.bumpMap.value = mt.bumpMap, ve.bumpScale.value = mt.bumpScale, mt.side === 1 && (ve.bumpScale.value *= -1)), mt.normalMap && (ve.normalMap.value = mt.normalMap, ve.normalScale.value.copy(mt.normalScale), mt.side === 1 && ve.normalScale.value.negate()), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias)) : mt.isMeshDepthMaterial ? (H(ve, mt), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias)) : mt.isMeshDistanceMaterial ? (H(ve, mt), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias), ve.referencePosition.value.copy(mt.referencePosition), ve.nearDistance.value = mt.nearDistance, ve.farDistance.value = mt.farDistance) : mt.isMeshNormalMaterial ? (H(ve, mt), mt.bumpMap && (ve.bumpMap.value = mt.bumpMap, ve.bumpScale.value = mt.bumpScale, mt.side === 1 && (ve.bumpScale.value *= -1)), mt.normalMap && (ve.normalMap.value = mt.normalMap, ve.normalScale.value.copy(mt.normalScale), mt.side === 1 && ve.normalScale.value.negate()), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias)) : mt.isLineBasicMaterial ? (ve.diffuse.value = mt.color, ve.opacity.value = mt.opacity, mt.isLineDashedMaterial && (ve.dashSize.value = mt.dashSize, ve.totalSize.value = mt.dashSize + mt.gapSize, ve.scale.value = mt.scale)) : mt.isPointsMaterial ? (ve.diffuse.value = mt.color, ve.opacity.value = mt.opacity, ve.size.value = mt.size * ti, ve.scale.value = 0.5 * Ce, ve.map.value = mt.map, mt.map !== null && (mt.map.matrixAutoUpdate === !0 && mt.map.updateMatrix(), ve.uvTransform.value.copy(mt.map.matrix))) : mt.isSpriteMaterial ? (ve.diffuse.value = mt.color, ve.opacity.value = mt.opacity, ve.rotation.value = mt.rotation, ve.map.value = mt.map, mt.map !== null && (mt.map.matrixAutoUpdate === !0 && mt.map.updateMatrix(), ve.uvTransform.value.copy(mt.map.matrix))) : mt.isShadowMaterial && (ve.color.value = mt.color, ve.opacity.value = mt.opacity), ve.ltc_1 !== void 0 && (ve.ltc_1.value = qe.LTC_1), ve.ltc_2 !== void 0 && (ve.ltc_2.value = qe.LTC_2), ro.upload(ne, De.uniformsList, ve, qt)), mt.isShaderMaterial && mt.uniformsNeedUpdate === !0 && (ro.upload(ne, De.uniformsList, ve, qt), mt.uniformsNeedUpdate = !1), mt.isSpriteMaterial && Se.setValue(ne, "center", Me.center), Se.setValue(ne, "modelViewMatrix", Me.modelViewMatrix), Se.setValue(ne, "normalMatrix", Me.normalMatrix), Se.setValue(ne, "modelMatrix", Me.matrixWorld), Ve;
    }
    function H(ft, Tt) {
      if (ft.opacity.value = Tt.opacity, Tt.color && (ft.diffuse.value = Tt.color), Tt.emissive && ft.emissive.value.copy(Tt.emissive).multiplyScalar(Tt.emissiveIntensity), Tt.map && (ft.map.value = Tt.map), Tt.alphaMap && (ft.alphaMap.value = Tt.alphaMap), Tt.specularMap && (ft.specularMap.value = Tt.specularMap), Tt.envMap && (ft.envMap.value = Tt.envMap, ft.flipEnvMap.value = Tt.envMap && Tt.envMap.isCubeTexture ? -1 : 1, ft.reflectivity.value = Tt.reflectivity, ft.refractionRatio.value = Tt.refractionRatio, ft.maxMipLevel.value = bn.get(Tt.envMap).__maxMipLevel), Tt.lightMap && (ft.lightMap.value = Tt.lightMap, ft.lightMapIntensity.value = Tt.lightMapIntensity), Tt.aoMap && (ft.aoMap.value = Tt.aoMap, ft.aoMapIntensity.value = Tt.aoMapIntensity), Tt.map)
        var mt = Tt.map;
      else
        Tt.specularMap ? mt = Tt.specularMap : Tt.displacementMap ? mt = Tt.displacementMap : Tt.normalMap ? mt = Tt.normalMap : Tt.bumpMap ? mt = Tt.bumpMap : Tt.roughnessMap ? mt = Tt.roughnessMap : Tt.metalnessMap ? mt = Tt.metalnessMap : Tt.alphaMap ? mt = Tt.alphaMap : Tt.emissiveMap && (mt = Tt.emissiveMap);
      mt !== void 0 && (mt.isWebGLRenderTarget && (mt = mt.texture), mt.matrixAutoUpdate === !0 && mt.updateMatrix(), ft.uvTransform.value.copy(mt.matrix));
    }
    function q(ft, Tt) {
      ft.specular.value = Tt.specular, ft.shininess.value = Math.max(Tt.shininess, 1e-4), Tt.emissiveMap && (ft.emissiveMap.value = Tt.emissiveMap), Tt.bumpMap && (ft.bumpMap.value = Tt.bumpMap, ft.bumpScale.value = Tt.bumpScale, Tt.side === 1 && (ft.bumpScale.value *= -1)), Tt.normalMap && (ft.normalMap.value = Tt.normalMap, ft.normalScale.value.copy(Tt.normalScale), Tt.side === 1 && ft.normalScale.value.negate()), Tt.displacementMap && (ft.displacementMap.value = Tt.displacementMap, ft.displacementScale.value = Tt.displacementScale, ft.displacementBias.value = Tt.displacementBias);
    }
    function $(ft, Tt) {
      ft.roughness.value = Tt.roughness, ft.metalness.value = Tt.metalness, Tt.roughnessMap && (ft.roughnessMap.value = Tt.roughnessMap), Tt.metalnessMap && (ft.metalnessMap.value = Tt.metalnessMap), Tt.emissiveMap && (ft.emissiveMap.value = Tt.emissiveMap), Tt.bumpMap && (ft.bumpMap.value = Tt.bumpMap, ft.bumpScale.value = Tt.bumpScale, Tt.side === 1 && (ft.bumpScale.value *= -1)), Tt.normalMap && (ft.normalMap.value = Tt.normalMap, ft.normalScale.value.copy(Tt.normalScale), Tt.side === 1 && ft.normalScale.value.negate()), Tt.displacementMap && (ft.displacementMap.value = Tt.displacementMap, ft.displacementScale.value = Tt.displacementScale, ft.displacementBias.value = Tt.displacementBias), Tt.envMap && (ft.envMapIntensity.value = Tt.envMapIntensity);
    }
    console.log("THREE.WebGLRenderer", "98"), t = t || {};
    var rt = t.canvas !== void 0 ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), xt = t.context !== void 0 ? t.context : null, gt = t.alpha !== void 0 ? t.alpha : !1, Ct = t.depth !== void 0 ? t.depth : !0, wt = t.stencil !== void 0 ? t.stencil : !0, Vt = t.antialias !== void 0 ? t.antialias : !1, Z = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, ot = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, zt = t.powerPreference !== void 0 ? t.powerPreference : "default", ee = null, $t = null;
    this.domElement = rt, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
    var qt = this, Te = !1, me = null, Ie = null, be = null, ae = -1, We = e = null, Qe = !1, ci = null, Sn = null, mn = new _(), ji = new _(), Gi = null, en = 0, En = rt.width, Ce = rt.height, ti = 1, Ut = new _(0, 0, En, Ce), Ye = new _(0, 0, En, Ce), ei = !1, Hi = new E(), Ae = new W(), Xe = !1, ri = !1, Ci = new c(), bi = new u();
    try {
      gt = {
        alpha: gt,
        depth: Ct,
        stencil: wt,
        antialias: Vt,
        premultipliedAlpha: Z,
        preserveDrawingBuffer: ot,
        powerPreference: zt
      }, rt.addEventListener("webglcontextlost", n, !1), rt.addEventListener("webglcontextrestored", o, !1);
      var ne = xt || rt.getContext("webgl", gt) || rt.getContext("experimental-webgl", gt);
      if (ne === null)
        throw rt.getContext("webgl") !== null ? Error(
          "Error creating WebGL context with your selected attributes."
        ) : Error("Error creating WebGL context.");
      ne.getShaderPrecisionFormat === void 0 && (ne.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (ft) {
      console.error("THREE.WebGLRenderer: " + ft.message);
    }
    var ii, Ze, ai, gn, bn, Bo, Ta, zh, Ma, zs, pl, ks, ns, kh, Bh, Qn, Ln;
    i();
    var _o = null;
    typeof navigator < "u" && (_o = "xr" in navigator ? new Pe(qt) : new di(qt)), this.vr = _o;
    var wu = new ye(qt, Ma, Ze.maxTextureSize);
    this.shadowMap = wu, this.getContext = function() {
      return ne;
    }, this.getContextAttributes = function() {
      return ne.getContextAttributes();
    }, this.forceContextLoss = function() {
      var ft = ii.get("WEBGL_lose_context");
      ft && ft.loseContext();
    }, this.forceContextRestore = function() {
      var ft = ii.get("WEBGL_lose_context");
      ft && ft.restoreContext();
    }, this.getPixelRatio = function() {
      return ti;
    }, this.setPixelRatio = function(ft) {
      ft !== void 0 && (ti = ft, this.setSize(En, Ce, !1));
    }, this.getSize = function() {
      return { width: En, height: Ce };
    }, this.setSize = function(ft, Tt, mt) {
      _o.isPresenting() ? console.warn(
        "THREE.WebGLRenderer: Can't change size while VR device is presenting."
      ) : (En = ft, Ce = Tt, rt.width = ft * ti, rt.height = Tt * ti, mt !== !1 && (rt.style.width = ft + "px", rt.style.height = Tt + "px"), this.setViewport(0, 0, ft, Tt));
    }, this.getDrawingBufferSize = function() {
      return { width: En * ti, height: Ce * ti };
    }, this.setDrawingBufferSize = function(ft, Tt, mt) {
      En = ft, Ce = Tt, ti = mt, rt.width = ft * mt, rt.height = Tt * mt, this.setViewport(0, 0, ft, Tt);
    }, this.getCurrentViewport = function() {
      return mn;
    }, this.setViewport = function(ft, Tt, mt, Me) {
      Ut.set(ft, Ce - Tt - Me, mt, Me), ai.viewport(mn.copy(Ut).multiplyScalar(ti));
    }, this.setScissor = function(ft, Tt, mt, Me) {
      Ye.set(ft, Ce - Tt - Me, mt, Me), ai.scissor(ji.copy(Ye).multiplyScalar(ti));
    }, this.setScissorTest = function(ft) {
      ai.setScissorTest(ei = ft);
    }, this.getClearColor = function() {
      return ns.getClearColor();
    }, this.setClearColor = function() {
      ns.setClearColor.apply(ns, arguments);
    }, this.getClearAlpha = function() {
      return ns.getClearAlpha();
    }, this.setClearAlpha = function() {
      ns.setClearAlpha.apply(ns, arguments);
    }, this.clear = function(ft, Tt, mt) {
      var Me = 0;
      (ft === void 0 || ft) && (Me |= 16384), (Tt === void 0 || Tt) && (Me |= 256), (mt === void 0 || mt) && (Me |= 1024), ne.clear(Me);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      rt.removeEventListener("webglcontextlost", n, !1), rt.removeEventListener("webglcontextrestored", o, !1), pl.dispose(), ks.dispose(), bn.dispose(), Ma.dispose(), _o.dispose(), No.stop();
    }, this.renderBufferImmediate = function(ft, Tt) {
      ai.initAttributes();
      var mt = bn.get(ft);
      ft.hasPositions && !mt.position && (mt.position = ne.createBuffer()), ft.hasNormals && !mt.normal && (mt.normal = ne.createBuffer()), ft.hasUvs && !mt.uv && (mt.uv = ne.createBuffer()), ft.hasColors && !mt.color && (mt.color = ne.createBuffer()), Tt = Tt.getAttributes(), ft.hasPositions && (ne.bindBuffer(34962, mt.position), ne.bufferData(34962, ft.positionArray, 35048), ai.enableAttribute(Tt.position), ne.vertexAttribPointer(Tt.position, 3, 5126, !1, 0, 0)), ft.hasNormals && (ne.bindBuffer(34962, mt.normal), ne.bufferData(34962, ft.normalArray, 35048), ai.enableAttribute(Tt.normal), ne.vertexAttribPointer(Tt.normal, 3, 5126, !1, 0, 0)), ft.hasUvs && (ne.bindBuffer(34962, mt.uv), ne.bufferData(34962, ft.uvArray, 35048), ai.enableAttribute(Tt.uv), ne.vertexAttribPointer(Tt.uv, 2, 5126, !1, 0, 0)), ft.hasColors && (ne.bindBuffer(34962, mt.color), ne.bufferData(34962, ft.colorArray, 35048), ai.enableAttribute(Tt.color), ne.vertexAttribPointer(Tt.color, 3, 5126, !1, 0, 0)), ai.disableUnusedAttributes(), ne.drawArrays(4, 0, ft.count), ft.count = 0;
    }, this.renderBufferDirect = function(ft, Tt, mt, Me, De, Ve) {
      var Se = De.isMesh && 0 > De.normalMatrix.determinant();
      ai.setMaterial(Me, Se);
      var Ke = B(ft, Tt, Me, De), Pi = !1;
      (e !== mt.id || We !== Ke.id || Qe !== (Me.wireframe === !0)) && (e = mt.id, We = Ke.id, Qe = Me.wireframe === !0, Pi = !0), De.morphTargetInfluences && (kh.update(De, mt, Me, Ke), Pi = !0), Se = mt.index;
      var Zi = mt.attributes.position;
      if (Tt = 1, Me.wireframe === !0 && (Se = zh.getWireframeAttribute(mt), Tt = 2), ft = Bh, Se !== null) {
        var ve = Ta.get(Se);
        ft = Qn, ft.setIndex(ve);
      }
      if (Pi) {
        if (mt && mt.isInstancedBufferGeometry & !Ze.isWebGL2 && ii.get("ANGLE_instanced_arrays") === null)
          console.error(
            "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        else {
          ai.initAttributes(), Pi = mt.attributes, Ke = Ke.getAttributes();
          var _r = Me.defaultAttributeValues;
          for (tr in Ke) {
            var zn = Ke[tr];
            if (0 <= zn) {
              var on = Pi[tr];
              if (on !== void 0) {
                var hr = on.normalized, Nh = on.itemSize, xo = Ta.get(on);
                if (xo !== void 0) {
                  var Fh = xo.buffer, Ql = xo.type;
                  if (xo = xo.bytesPerElement, on.isInterleavedBufferAttribute) {
                    var Ea = on.data, Tu = Ea.stride;
                    on = on.offset, Ea && Ea.isInstancedInterleavedBuffer ? (ai.enableAttributeAndDivisor(zn, Ea.meshPerAttribute), mt.maxInstancedCount === void 0 && (mt.maxInstancedCount = Ea.meshPerAttribute * Ea.count)) : ai.enableAttribute(zn), ne.bindBuffer(34962, Fh), ne.vertexAttribPointer(zn, Nh, Ql, hr, Tu * xo, on * xo);
                  } else
                    on.isInstancedBufferAttribute ? (ai.enableAttributeAndDivisor(zn, on.meshPerAttribute), mt.maxInstancedCount === void 0 && (mt.maxInstancedCount = on.meshPerAttribute * on.count)) : ai.enableAttribute(zn), ne.bindBuffer(34962, Fh), ne.vertexAttribPointer(zn, Nh, Ql, hr, 0, 0);
                }
              } else if (_r !== void 0 && (hr = _r[tr], hr !== void 0))
                switch (hr.length) {
                  case 2:
                    ne.vertexAttrib2fv(zn, hr);
                    break;
                  case 3:
                    ne.vertexAttrib3fv(zn, hr);
                    break;
                  case 4:
                    ne.vertexAttrib4fv(zn, hr);
                    break;
                  default:
                    ne.vertexAttrib1fv(zn, hr);
                }
            }
          }
          ai.disableUnusedAttributes();
        }
        Se !== null && ne.bindBuffer(34963, ve.buffer);
      }
      ve = 1 / 0, Se !== null ? ve = Se.count : Zi !== void 0 && (ve = Zi.count), Se = mt.drawRange.start * Tt, Zi = Ve !== null ? Ve.start * Tt : 0;
      var tr = Math.max(Se, Zi);
      if (Ve = Math.max(
        0,
        Math.min(
          ve,
          Se + mt.drawRange.count * Tt,
          Zi + (Ve !== null ? Ve.count * Tt : 1 / 0)
        ) - 1 - tr + 1
      ), Ve !== 0) {
        if (De.isMesh)
          if (Me.wireframe === !0)
            ai.setLineWidth(Me.wireframeLinewidth * (Ie === null ? ti : 1)), ft.setMode(1);
          else
            switch (De.drawMode) {
              case 0:
                ft.setMode(4);
                break;
              case 1:
                ft.setMode(5);
                break;
              case 2:
                ft.setMode(6);
            }
        else
          De.isLine ? (Me = Me.linewidth, Me === void 0 && (Me = 1), ai.setLineWidth(Me * (Ie === null ? ti : 1)), De.isLineSegments ? ft.setMode(1) : De.isLineLoop ? ft.setMode(2) : ft.setMode(3)) : De.isPoints ? ft.setMode(0) : De.isSprite && ft.setMode(4);
        mt && mt.isInstancedBufferGeometry ? 0 < mt.maxInstancedCount && ft.renderInstances(mt, tr, Ve) : ft.render(tr, Ve);
      }
    }, this.compile = function(ft, Tt) {
      $t = ks.get(ft, Tt), $t.init(), ft.traverse(function(mt) {
        mt.isLight && ($t.pushLight(mt), mt.castShadow && $t.pushShadow(mt));
      }), $t.setupLights(Tt), ft.traverse(function(mt) {
        if (mt.material)
          if (Array.isArray(mt.material))
            for (var Me = 0; Me < mt.material.length; Me++)
              P(mt.material[Me], ft.fog, mt);
          else
            P(mt.material, ft.fog, mt);
      });
    };
    var Sa = null, No = new T();
    No.setAnimationLoop(function(ft) {
      _o.isPresenting() || Sa && Sa(ft);
    }), typeof window < "u" && No.setContext(window), this.setAnimationLoop = function(ft) {
      Sa = ft, _o.setAnimationLoop(ft), No.start();
    }, this.render = function(ft, Tt, mt, Me) {
      if (!Tt || !Tt.isCamera)
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
      else if (!Te) {
        We = e = null, Qe = !1, ae = -1, ci = null, ft.autoUpdate === !0 && ft.updateMatrixWorld(), Tt.parent === null && Tt.updateMatrixWorld(), _o.enabled && (Tt = _o.getCamera(Tt)), $t = ks.get(ft, Tt), $t.init(), ft.onBeforeRender(qt, ft, Tt, mt), Ci.multiplyMatrices(Tt.projectionMatrix, Tt.matrixWorldInverse), Hi.setFromMatrix(Ci), ri = this.localClippingEnabled, Xe = Ae.init(this.clippingPlanes, ri, Tt), ee = pl.get(ft, Tt), ee.init(), y(ft, Tt, qt.sortObjects), qt.sortObjects === !0 && ee.sort(), Xe && Ae.beginShadows(), wu.render($t.state.shadowsArray, ft, Tt), $t.setupLights(Tt), Xe && Ae.endShadows(), this.info.autoReset && this.info.reset(), mt === void 0 && (mt = null), this.setRenderTarget(mt), ns.render(ee, ft, Tt, Me), Me = ee.opaque;
        var De = ee.transparent;
        if (ft.overrideMaterial) {
          var Ve = ft.overrideMaterial;
          Me.length && w(Me, ft, Tt, Ve), De.length && w(De, ft, Tt, Ve);
        } else
          Me.length && w(Me, ft, Tt), De.length && w(De, ft, Tt);
        mt && Bo.updateRenderTargetMipmap(mt), ai.buffers.depth.setTest(!0), ai.buffers.depth.setMask(!0), ai.buffers.color.setMask(!0), ai.setPolygonOffset(!1), ft.onAfterRender(qt, ft, Tt), _o.enabled && _o.submitFrame(), $t = ee = null;
      }
    }, this.allocTextureUnit = function() {
      var ft = en;
      return ft >= Ze.maxTextures && console.warn(
        "THREE.WebGLRenderer: Trying to use " + ft + " texture units while this GPU supports only " + Ze.maxTextures
      ), en += 1, ft;
    }, this.setTexture2D = function() {
      var ft = !1;
      return function(Tt, mt) {
        Tt && Tt.isWebGLRenderTarget && (ft || (console.warn(
          "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
        ), ft = !0), Tt = Tt.texture), Bo.setTexture2D(Tt, mt);
      };
    }(), this.setTexture3D = function() {
      return function(ft, Tt) {
        Bo.setTexture3D(ft, Tt);
      };
    }(), this.setTexture = function() {
      var ft = !1;
      return function(Tt, mt) {
        ft || (console.warn(
          "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
        ), ft = !0), Bo.setTexture2D(Tt, mt);
      };
    }(), this.setTextureCube = function() {
      var ft = !1;
      return function(Tt, mt) {
        Tt && Tt.isWebGLRenderTargetCube && (ft || (console.warn(
          "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ), ft = !0), Tt = Tt.texture), Tt && Tt.isCubeTexture || Array.isArray(Tt.image) && Tt.image.length === 6 ? Bo.setTextureCube(Tt, mt) : Bo.setTextureCubeDynamic(Tt, mt);
      };
    }(), this.setFramebuffer = function(ft) {
      me = ft;
    }, this.getRenderTarget = function() {
      return Ie;
    }, this.setRenderTarget = function(ft) {
      (Ie = ft) && bn.get(ft).__webglFramebuffer === void 0 && Bo.setupRenderTarget(ft);
      var Tt = me, mt = !1;
      ft ? (Tt = bn.get(ft).__webglFramebuffer, ft.isWebGLRenderTargetCube && (Tt = Tt[ft.activeCubeFace], mt = !0), mn.copy(ft.viewport), ji.copy(ft.scissor), Gi = ft.scissorTest) : (mn.copy(Ut).multiplyScalar(ti), ji.copy(Ye).multiplyScalar(ti), Gi = ei), be !== Tt && (ne.bindFramebuffer(36160, Tt), be = Tt), ai.viewport(mn), ai.scissor(ji), ai.setScissorTest(Gi), mt && (mt = bn.get(ft.texture), ne.framebufferTexture2D(
        36160,
        36064,
        34069 + ft.activeCubeFace,
        mt.__webglTexture,
        ft.activeMipMapLevel
      ));
    }, this.readRenderTargetPixels = function(ft, Tt, mt, Me, De, Ve) {
      if (ft && ft.isWebGLRenderTarget) {
        var Se = bn.get(ft).__webglFramebuffer;
        if (Se) {
          var Ke = !1;
          Se !== be && (ne.bindFramebuffer(36160, Se), Ke = !0);
          try {
            var Pi = ft.texture, Zi = Pi.format, ve = Pi.type;
            Zi !== 1023 && Ln.convert(Zi) !== ne.getParameter(35739) ? console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            ) : ve === 1009 || Ln.convert(ve) === ne.getParameter(35738) || ve === 1015 && (Ze.isWebGL2 || ii.get("OES_texture_float") || ii.get("WEBGL_color_buffer_float")) || ve === 1016 && (Ze.isWebGL2 ? ii.get("EXT_color_buffer_float") : ii.get("EXT_color_buffer_half_float")) ? ne.checkFramebufferStatus(36160) === 36053 ? 0 <= Tt && Tt <= ft.width - Me && 0 <= mt && mt <= ft.height - De && ne.readPixels(Tt, mt, Me, De, Ln.convert(Zi), Ln.convert(ve), Ve) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
            ) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          } finally {
            Ke && ne.bindFramebuffer(36160, be);
          }
        }
      } else
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
    }, this.copyFramebufferToTexture = function(ft, Tt, mt) {
      var Me = Tt.image.width, De = Tt.image.height, Ve = Ln.convert(Tt.format);
      this.setTexture2D(Tt, 0), ne.copyTexImage2D(3553, mt || 0, Ve, ft.x, ft.y, Me, De, 0);
    }, this.copyTextureToTexture = function(ft, Tt, mt, Me) {
      var De = Tt.image.width, Ve = Tt.image.height, Se = Ln.convert(mt.format), Ke = Ln.convert(mt.type);
      this.setTexture2D(mt, 0), Tt.isDataTexture ? ne.texSubImage2D(3553, Me || 0, ft.x, ft.y, De, Ve, Se, Ke, Tt.image.data) : ne.texSubImage2D(3553, Me || 0, ft.x, ft.y, Se, Ke, Tt.image);
    };
  }
  function Le(t, e) {
    this.name = "", this.color = new L(t), this.density = e !== void 0 ? e : 25e-5;
  }
  function wn(t, e, i) {
    this.name = "", this.color = new L(t), this.near = e !== void 0 ? e : 1, this.far = i !== void 0 ? i : 1e3;
  }
  function Hn() {
    N.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0;
  }
  function Ii(t, e) {
    this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function Di(t, e, i, n) {
    this.data = t, this.itemSize = e, this.offset = i, this.normalized = n === !0;
  }
  function Ui(t) {
    Yt.call(this), this.type = "SpriteMaterial", this.color = new L(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t);
  }
  function Qi(t) {
    if (N.call(this), this.type = "Sprite", wa === void 0) {
      wa = new Ft();
      var e = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      e = new Ii(e, 5), wa.setIndex([0, 1, 2, 0, 2, 3]), wa.addAttribute("position", new Di(e, 3, 0, !1)), wa.addAttribute("uv", new Di(e, 2, 3, !1));
    }
    this.geometry = wa, this.material = t !== void 0 ? t : new Ui(), this.center = new s(0.5, 0.5);
  }
  function tn() {
    N.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
  }
  function sn(t, e) {
    if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), e === void 0)
      this.calculateInverses();
    else if (this.bones.length === e.length)
      this.boneInverses = e.slice(0);
    else
      for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++)
        this.boneInverses.push(new c());
  }
  function an() {
    N.call(this), this.type = "Bone";
  }
  function Fi(t, e) {
    pi.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new c(), this.bindMatrixInverse = new c(), t = this.initBones(), t = new sn(t), this.bind(t, this.matrixWorld), this.normalizeSkinWeights();
  }
  function zi(t) {
    Yt.call(this), this.type = "LineBasicMaterial", this.color = new L(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t);
  }
  function Vi(t, e, i) {
    i === 1 && console.error(
      "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
    ), N.call(this), this.type = "Line", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new zi({ color: 16777215 * Math.random() });
  }
  function mi(t, e) {
    Vi.call(this, t, e), this.type = "LineSegments";
  }
  function so(t, e) {
    Vi.call(this, t, e), this.type = "LineLoop";
  }
  function Bn(t) {
    Yt.call(this), this.type = "PointsMaterial", this.color = new L(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(t);
  }
  function Ks(t, e) {
    N.call(this), this.type = "Points", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Bn({ color: 16777215 * Math.random() });
  }
  function yh(t, e, i, n, o, l, f, p, y) {
    g.call(this, t, e, i, n, o, l, f, p, y), this.generateMipmaps = !1;
  }
  function Ho(t, e, i, n, o, l, f, p, y, w, A, P) {
    g.call(this, null, l, f, p, y, w, n, o, A, P), this.image = { width: e, height: i }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1;
  }
  function Fa(t, e, i, n, o, l, f, p, y) {
    g.call(this, t, e, i, n, o, l, f, p, y), this.needsUpdate = !0;
  }
  function Ua(t, e, i, n, o, l, f, p, y, w) {
    if (w = w !== void 0 ? w : 1026, w !== 1026 && w !== 1027)
      throw Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && w === 1026 && (i = 1012), i === void 0 && w === 1027 && (i = 1020), g.call(this, null, n, o, l, f, p, w, i, y), this.image = { width: t, height: e }, this.magFilter = f !== void 0 ? f : 1003, this.minFilter = p !== void 0 ? p : 1003, this.generateMipmaps = this.flipY = !1;
  }
  function Qs(t) {
    Ft.call(this), this.type = "WireframeGeometry";
    var e = [], i, n, o, l = [0, 0], f = {}, p = ["a", "b", "c"];
    if (t && t.isGeometry) {
      var y = t.faces, w = 0;
      for (n = y.length; w < n; w++) {
        var A = y[w];
        for (i = 0; 3 > i; i++) {
          var P = A[p[i]], B = A[p[(i + 1) % 3]];
          l[0] = Math.min(P, B), l[1] = Math.max(P, B), P = l[0] + "," + l[1], f[P] === void 0 && (f[P] = { index1: l[0], index2: l[1] });
        }
      }
      for (P in f)
        w = f[P], p = t.vertices[w.index1], e.push(p.x, p.y, p.z), p = t.vertices[w.index2], e.push(p.x, p.y, p.z);
    } else if (t && t.isBufferGeometry)
      if (p = new u(), t.index !== null) {
        y = t.attributes.position, A = t.index;
        var H = t.groups;
        for (H.length === 0 && (H = [{ start: 0, count: A.count, materialIndex: 0 }]), t = 0, o = H.length; t < o; ++t)
          for (w = H[t], i = w.start, n = w.count, w = i, n = i + n; w < n; w += 3)
            for (i = 0; 3 > i; i++)
              P = A.getX(w + i), B = A.getX(w + (i + 1) % 3), l[0] = Math.min(P, B), l[1] = Math.max(P, B), P = l[0] + "," + l[1], f[P] === void 0 && (f[P] = { index1: l[0], index2: l[1] });
        for (P in f)
          w = f[P], p.fromBufferAttribute(y, w.index1), e.push(p.x, p.y, p.z), p.fromBufferAttribute(y, w.index2), e.push(p.x, p.y, p.z);
      } else
        for (y = t.attributes.position, w = 0, n = y.count / 3; w < n; w++)
          for (i = 0; 3 > i; i++)
            f = 3 * w + i, p.fromBufferAttribute(y, f), e.push(p.x, p.y, p.z), f = 3 * w + (i + 1) % 3, p.fromBufferAttribute(y, f), e.push(p.x, p.y, p.z);
    this.addAttribute("position", new Et(e, 3));
  }
  function Ga(t, e, i) {
    j.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: i }, this.fromBufferGeometry(new ta(t, e, i)), this.mergeVertices();
  }
  function ta(t, e, i) {
    Ft.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: i };
    var n = [], o = [], l = [], f = [], p = new u(), y = new u(), w = new u(), A = new u(), P = new u(), B, H;
    3 > t.length && console.error(
      "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
    );
    var q = e + 1;
    for (B = 0; B <= i; B++) {
      var $ = B / i;
      for (H = 0; H <= e; H++) {
        var rt = H / e;
        t(rt, $, y), o.push(y.x, y.y, y.z), 0 <= rt - 1e-5 ? (t(rt - 1e-5, $, w), A.subVectors(y, w)) : (t(rt + 1e-5, $, w), A.subVectors(w, y)), 0 <= $ - 1e-5 ? (t(rt, $ - 1e-5, w), P.subVectors(y, w)) : (t(rt, $ + 1e-5, w), P.subVectors(w, y)), p.crossVectors(A, P).normalize(), l.push(p.x, p.y, p.z), f.push(rt, $);
      }
    }
    for (B = 0; B < i; B++)
      for (H = 0; H < e; H++)
        t = B * q + H + 1, p = (B + 1) * q + H + 1, y = (B + 1) * q + H, n.push(B * q + H, t, y), n.push(t, p, y);
    this.setIndex(n), this.addAttribute("position", new Et(o, 3)), this.addAttribute("normal", new Et(l, 3)), this.addAttribute("uv", new Et(f, 2));
  }
  function Wi(t, e, i, n) {
    j.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, this.fromBufferGeometry(new _i(t, e, i, n)), this.mergeVertices();
  }
  function _i(t, e, i, n) {
    function o(w) {
      p.push(w.x, w.y, w.z);
    }
    function l(w, A) {
      w *= 3, A.x = t[w + 0], A.y = t[w + 1], A.z = t[w + 2];
    }
    function f(w, A, P, B) {
      0 > B && w.x === 1 && (y[A] = w.x - 1), P.x === 0 && P.z === 0 && (y[A] = B / 2 / Math.PI + 0.5);
    }
    Ft.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, i = i || 1, n = n || 0;
    var p = [], y = [];
    (function(w) {
      for (var A = new u(), P = new u(), B = new u(), H = 0; H < e.length; H += 3) {
        l(e[H + 0], A), l(e[H + 1], P), l(e[H + 2], B);
        var q, $, rt = A, xt = P, gt = B, Ct = Math.pow(2, w), wt = [];
        for ($ = 0; $ <= Ct; $++) {
          wt[$] = [];
          var Vt = rt.clone().lerp(gt, $ / Ct), Z = xt.clone().lerp(gt, $ / Ct), ot = Ct - $;
          for (q = 0; q <= ot; q++)
            wt[$][q] = q === 0 && $ === Ct ? Vt : Vt.clone().lerp(Z, q / ot);
        }
        for ($ = 0; $ < Ct; $++)
          for (q = 0; q < 2 * (Ct - $) - 1; q++)
            rt = Math.floor(q / 2), q % 2 === 0 ? (o(wt[$][rt + 1]), o(wt[$ + 1][rt]), o(wt[$][rt])) : (o(wt[$][rt + 1]), o(wt[$ + 1][rt + 1]), o(wt[$ + 1][rt]));
      }
    })(n), function(w) {
      for (var A = new u(), P = 0; P < p.length; P += 3)
        A.x = p[P + 0], A.y = p[P + 1], A.z = p[P + 2], A.normalize().multiplyScalar(w), p[P + 0] = A.x, p[P + 1] = A.y, p[P + 2] = A.z;
    }(i), function() {
      for (var w = new u(), A = 0; A < p.length; A += 3)
        w.x = p[A + 0], w.y = p[A + 1], w.z = p[A + 2], y.push(
          Math.atan2(w.z, -w.x) / 2 / Math.PI + 0.5,
          1 - (Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z)) / Math.PI + 0.5)
        );
      w = new u(), A = new u();
      for (var P = new u(), B = new u(), H = new s(), q = new s(), $ = new s(), rt = 0, xt = 0; rt < p.length; rt += 9, xt += 6) {
        w.set(p[rt + 0], p[rt + 1], p[rt + 2]), A.set(p[rt + 3], p[rt + 4], p[rt + 5]), P.set(p[rt + 6], p[rt + 7], p[rt + 8]), H.set(y[xt + 0], y[xt + 1]), q.set(y[xt + 2], y[xt + 3]), $.set(y[xt + 4], y[xt + 5]), B.copy(w).add(A).add(P).divideScalar(3);
        var gt = Math.atan2(B.z, -B.x);
        f(H, xt + 0, w, gt), f(q, xt + 2, A, gt), f($, xt + 4, P, gt);
      }
      for (w = 0; w < y.length; w += 6)
        A = y[w + 0], P = y[w + 2], B = y[w + 4], H = Math.min(A, P, B), 0.9 < Math.max(A, P, B) && 0.1 > H && (0.2 > A && (y[w + 0] += 1), 0.2 > P && (y[w + 2] += 1), 0.2 > B && (y[w + 4] += 1));
    }(), this.addAttribute("position", new Et(p, 3)), this.addAttribute("normal", new Et(p.slice(), 3)), this.addAttribute("uv", new Et(y, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Ha(t, e) {
    j.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ea(t, e)), this.mergeVertices();
  }
  function ea(t, e) {
    _i.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Va(t, e) {
    j.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ps(t, e)), this.mergeVertices();
  }
  function ps(t, e) {
    _i.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Wa(t, e) {
    j.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ia(t, e)), this.mergeVertices();
  }
  function ia(t, e) {
    var i = (1 + Math.sqrt(5)) / 2;
    _i.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1
      ],
      [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ],
      t,
      e
    ), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function na(t, e) {
    j.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ra(t, e)), this.mergeVertices();
  }
  function ra(t, e) {
    var i = (1 + Math.sqrt(5)) / 2, n = 1 / i;
    _i.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n
      ],
      [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ],
      t,
      e
    ), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function fn(t, e, i, n, o, l) {
    j.call(this), this.type = "TubeGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: o
    }, l !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed."), t = new Vo(t, e, i, n, o), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices();
  }
  function Vo(t, e, i, n, o) {
    function l(xt) {
      A = t.getPointAt(xt / e, A);
      var gt = f.normals[xt];
      for (xt = f.binormals[xt], B = 0; B <= n; B++) {
        var Ct = B / n * Math.PI * 2, wt = Math.sin(Ct);
        Ct = -Math.cos(Ct), y.x = Ct * gt.x + wt * xt.x, y.y = Ct * gt.y + wt * xt.y, y.z = Ct * gt.z + wt * xt.z, y.normalize(), q.push(y.x, y.y, y.z), p.x = A.x + i * y.x, p.y = A.y + i * y.y, p.z = A.z + i * y.z, H.push(p.x, p.y, p.z);
      }
    }
    Ft.call(this), this.type = "TubeBufferGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: o
    }, e = e || 64, i = i || 1, n = n || 8, o = o || !1;
    var f = t.computeFrenetFrames(e, o);
    this.tangents = f.tangents, this.normals = f.normals, this.binormals = f.binormals;
    var p = new u(), y = new u(), w = new s(), A = new u(), P, B, H = [], q = [], $ = [], rt = [];
    for (P = 0; P < e; P++)
      l(P);
    for (l(o === !1 ? e : 0), P = 0; P <= e; P++)
      for (B = 0; B <= n; B++)
        w.x = P / e, w.y = B / n, $.push(w.x, w.y);
    (function() {
      for (B = 1; B <= e; B++)
        for (P = 1; P <= n; P++) {
          var xt = (n + 1) * B + (P - 1), gt = (n + 1) * B + P, Ct = (n + 1) * (B - 1) + P;
          rt.push((n + 1) * (B - 1) + (P - 1), xt, Ct), rt.push(xt, gt, Ct);
        }
    })(), this.setIndex(rt), this.addAttribute("position", new Et(H, 3)), this.addAttribute("normal", new Et(q, 3)), this.addAttribute("uv", new Et($, 2));
  }
  function Vr(t, e, i, n, o, l, f) {
    j.call(this), this.type = "TorusKnotGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: o,
      q: l
    }, f !== void 0 && console.warn(
      "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
    ), this.fromBufferGeometry(new ds(t, e, i, n, o, l)), this.mergeVertices();
  }
  function ds(t, e, i, n, o, l) {
    function f(Z, ot, zt, ee, $t) {
      var qt = Math.sin(Z);
      ot = zt / ot * Z, zt = Math.cos(ot), $t.x = ee * (2 + zt) * 0.5 * Math.cos(Z), $t.y = ee * (2 + zt) * qt * 0.5, $t.z = ee * Math.sin(ot) * 0.5;
    }
    Ft.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: o,
      q: l
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, l = l || 3;
    var p = [], y = [], w = [], A = [], P, B = new u(), H = new u(), q = new u(), $ = new u(), rt = new u(), xt = new u(), gt = new u();
    for (P = 0; P <= i; ++P) {
      var Ct = P / i * o * Math.PI * 2;
      for (f(Ct, o, l, t, q), f(Ct + 0.01, o, l, t, $), xt.subVectors($, q), gt.addVectors($, q), rt.crossVectors(xt, gt), gt.crossVectors(rt, xt), rt.normalize(), gt.normalize(), Ct = 0; Ct <= n; ++Ct) {
        var wt = Ct / n * Math.PI * 2, Vt = -e * Math.cos(wt);
        wt = e * Math.sin(wt), B.x = q.x + (Vt * gt.x + wt * rt.x), B.y = q.y + (Vt * gt.y + wt * rt.y), B.z = q.z + (Vt * gt.z + wt * rt.z), y.push(B.x, B.y, B.z), H.subVectors(B, q).normalize(), w.push(H.x, H.y, H.z), A.push(P / i), A.push(Ct / n);
      }
    }
    for (Ct = 1; Ct <= i; Ct++)
      for (P = 1; P <= n; P++)
        t = (n + 1) * Ct + (P - 1), e = (n + 1) * Ct + P, o = (n + 1) * (Ct - 1) + P, p.push((n + 1) * (Ct - 1) + (P - 1), t, o), p.push(t, e, o);
    this.setIndex(p), this.addAttribute("position", new Et(y, 3)), this.addAttribute("normal", new Et(w, 3)), this.addAttribute("uv", new Et(A, 2));
  }
  function ms(t, e, i, n, o) {
    j.call(this), this.type = "TorusGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: o
    }, this.fromBufferGeometry(new Nn(t, e, i, n, o)), this.mergeVertices();
  }
  function Nn(t, e, i, n, o) {
    Ft.call(this), this.type = "TorusBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: o
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
    var l = [], f = [], p = [], y = [], w = new u(), A = new u(), P = new u(), B, H;
    for (B = 0; B <= i; B++)
      for (H = 0; H <= n; H++) {
        var q = H / n * o, $ = B / i * Math.PI * 2;
        A.x = (t + e * Math.cos($)) * Math.cos(q), A.y = (t + e * Math.cos($)) * Math.sin(q), A.z = e * Math.sin($), f.push(A.x, A.y, A.z), w.x = t * Math.cos(q), w.y = t * Math.sin(q), P.subVectors(A, w).normalize(), p.push(P.x, P.y, P.z), y.push(H / n), y.push(B / i);
      }
    for (B = 1; B <= i; B++)
      for (H = 1; H <= n; H++)
        t = (n + 1) * (B - 1) + H - 1, e = (n + 1) * (B - 1) + H, o = (n + 1) * B + H, l.push((n + 1) * B + H - 1, t, o), l.push(t, e, o);
    this.setIndex(l), this.addAttribute("position", new Et(f, 3)), this.addAttribute("normal", new Et(p, 3)), this.addAttribute("uv", new Et(y, 2));
  }
  function _h(t, e, i, n, o) {
    for (var l, f = 0, p = e, y = i - n; p < i; p += n)
      f += (t[y] - t[p]) * (t[p + 1] + t[y + 1]), y = p;
    if (o === 0 < f)
      for (o = e; o < i; o += n)
        l = kl(o, t[o], t[o + 1], l);
    else
      for (o = i - n; o >= e; o -= n)
        l = kl(o, t[o], t[o + 1], l);
    return l && gs(l, l.next) && (Xi(l), l = l.next), l;
  }
  function oa(t, e) {
    if (!t)
      return t;
    e || (e = t);
    do {
      var i = !1;
      if (t.steiner || !gs(t, t.next) && Yi(t.prev, t, t.next) !== 0)
        t = t.next;
      else {
        if (Xi(t), t = e = t.prev, t === t.next)
          break;
        i = !0;
      }
    } while (i || t !== e);
    return e;
  }
  function sa(t, e, i, n, o, l, f) {
    if (t) {
      if (!f && l) {
        var p = t, y = p;
        do
          y.z === null && (y.z = Dl(y.x, y.y, n, o, l)), y.prevZ = y.prev, y = y.nextZ = y.next;
        while (y !== p);
        y.prevZ.nextZ = null, y.prevZ = null, p = y;
        var w, A, P, B, H = 1;
        do {
          y = p;
          var q = p = null;
          for (A = 0; y; ) {
            A++;
            var $ = y;
            for (w = P = 0; w < H && (P++, $ = $.nextZ, $); w++)
              ;
            for (B = H; 0 < P || 0 < B && $; )
              P !== 0 && (B === 0 || !$ || y.z <= $.z) ? (w = y, y = y.nextZ, P--) : (w = $, $ = $.nextZ, B--), q ? q.nextZ = w : p = w, w.prevZ = q, q = w;
            y = $;
          }
          q.nextZ = null, H *= 2;
        } while (1 < A);
      }
      for (p = t; t.prev !== t.next; ) {
        if (y = t.prev, $ = t.next, l)
          t: {
            q = t, B = n;
            var rt = o, xt = l;
            if (A = q.prev, P = q, H = q.next, 0 <= Yi(A, P, H))
              q = !1;
            else {
              var gt = A.x > P.x ? A.x > H.x ? A.x : H.x : P.x > H.x ? P.x : H.x, Ct = A.y > P.y ? A.y > H.y ? A.y : H.y : P.y > H.y ? P.y : H.y;
              for (w = Dl(
                A.x < P.x ? A.x < H.x ? A.x : H.x : P.x < H.x ? P.x : H.x,
                A.y < P.y ? A.y < H.y ? A.y : H.y : P.y < H.y ? P.y : H.y,
                B,
                rt,
                xt
              ), B = Dl(gt, Ct, B, rt, xt), rt = q.nextZ; rt && rt.z <= B; ) {
                if (rt !== q.prev && rt !== q.next && zl(A.x, A.y, P.x, P.y, H.x, H.y, rt.x, rt.y) && 0 <= Yi(rt.prev, rt, rt.next)) {
                  q = !1;
                  break t;
                }
                rt = rt.nextZ;
              }
              for (rt = q.prevZ; rt && rt.z >= w; ) {
                if (rt !== q.prev && rt !== q.next && zl(A.x, A.y, P.x, P.y, H.x, H.y, rt.x, rt.y) && 0 <= Yi(rt.prev, rt, rt.next)) {
                  q = !1;
                  break t;
                }
                rt = rt.prevZ;
              }
              q = !0;
            }
          }
        else
          t:
            if (q = t, A = q.prev, P = q, H = q.next, 0 <= Yi(A, P, H))
              q = !1;
            else {
              for (w = q.next.next; w !== q.prev; ) {
                if (zl(A.x, A.y, P.x, P.y, H.x, H.y, w.x, w.y) && 0 <= Yi(w.prev, w, w.next)) {
                  q = !1;
                  break t;
                }
                w = w.next;
              }
              q = !0;
            }
        if (q)
          e.push(y.i / i), e.push(t.i / i), e.push($.i / i), Xi(t), p = t = $.next;
        else if (t = $, t === p) {
          if (!f)
            sa(oa(t), e, i, n, o, l, 1);
          else if (f === 1) {
            f = e, p = i, y = t;
            do
              $ = y.prev, q = y.next.next, !gs($, q) && xh($, y, y.next, q) && Sr($, q) && Sr(q, $) && (f.push($.i / p), f.push(y.i / p), f.push(q.i / p), Xi(y), Xi(y.next), y = t = q), y = y.next;
            while (y !== t);
            t = y, sa(t, e, i, n, o, l, 2);
          } else if (f === 2)
            t: {
              f = t;
              do {
                for (p = f.next.next; p !== f.prev; ) {
                  if (y = f.i !== p.i) {
                    if (y = f, $ = p, q = y.next.i !== $.i && y.prev.i !== $.i) {
                      e: {
                        q = y;
                        do {
                          if (q.i !== y.i && q.next.i !== y.i && q.i !== $.i && q.next.i !== $.i && xh(q, q.next, y, $)) {
                            q = !0;
                            break e;
                          }
                          q = q.next;
                        } while (q !== y);
                        q = !1;
                      }
                      q = !q;
                    }
                    if (q = q && Sr(y, $) && Sr($, y)) {
                      q = y, A = !1, P = (y.x + $.x) / 2, $ = (y.y + $.y) / 2;
                      do
                        q.y > $ != q.next.y > $ && q.next.y !== q.y && P < (q.next.x - q.x) * ($ - q.y) / (q.next.y - q.y) + q.x && (A = !A), q = q.next;
                      while (q !== y);
                      q = A;
                    }
                    y = q;
                  }
                  if (y) {
                    t = ja(f, p), f = oa(f, f.next), t = oa(t, t.next), sa(f, e, i, n, o, l), sa(t, e, i, n, o, l);
                    break t;
                  }
                  p = p.next;
                }
                f = f.next;
              } while (f !== t);
            }
          break;
        }
      }
    }
  }
  function ru(t, e) {
    return t.x - e.x;
  }
  function ou(t, e) {
    var i = e, n = t.x, o = t.y, l = -1 / 0;
    do {
      if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
        var f = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
        if (f <= n && f > l) {
          if (l = f, f === n) {
            if (o === i.y)
              return i;
            if (o === i.next.y)
              return i.next;
          }
          var p = i.x < i.next.x ? i : i.next;
        }
      }
      i = i.next;
    } while (i !== e);
    if (!p)
      return null;
    if (n === l)
      return p.prev;
    e = p, f = p.x;
    var y = p.y, w = 1 / 0;
    for (i = p.next; i !== e; ) {
      if (n >= i.x && i.x >= f && n !== i.x && zl(o < y ? n : l, o, f, y, o < y ? l : n, o, i.x, i.y)) {
        var A = Math.abs(o - i.y) / (n - i.x);
        (A < w || A === w && i.x > p.x) && Sr(i, t) && (p = i, w = A);
      }
      i = i.next;
    }
    return p;
  }
  function Dl(t, e, i, n, o) {
    return t = 32767 * (t - i) * o, e = 32767 * (e - n) * o, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, (t | t << 1) & 1431655765 | ((e | e << 1) & 1431655765) << 1;
  }
  function mr(t) {
    var e = t, i = t;
    do
      e.x < i.x && (i = e), e = e.next;
    while (e !== t);
    return i;
  }
  function zl(t, e, i, n, o, l, f, p) {
    return 0 <= (o - f) * (e - p) - (t - f) * (l - p) && 0 <= (t - f) * (n - p) - (i - f) * (e - p) && 0 <= (i - f) * (l - p) - (o - f) * (n - p);
  }
  function Yi(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function gs(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function xh(t, e, i, n) {
    return gs(t, e) && gs(i, n) || gs(t, n) && gs(i, e) ? !0 : 0 < Yi(t, e, i) != 0 < Yi(t, e, n) && 0 < Yi(i, n, t) != 0 < Yi(i, n, e);
  }
  function Sr(t, e) {
    return 0 > Yi(t.prev, t, t.next) ? 0 <= Yi(t, e, t.next) && 0 <= Yi(t, t.prev, e) : 0 > Yi(t, e, t.prev) || 0 > Yi(t, t.next, e);
  }
  function ja(t, e) {
    var i = new ao(t.i, t.x, t.y), n = new ao(e.i, e.x, e.y), o = t.next, l = e.prev;
    return t.next = e, e.prev = t, i.next = o, o.prev = i, n.next = i, i.prev = n, l.next = n, n.prev = l, n;
  }
  function kl(t, e, i, n) {
    return t = new ao(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t;
  }
  function Xi(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function ao(t, e, i) {
    this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1;
  }
  function Bl(t) {
    var e = t.length;
    2 < e && t[e - 1].equals(t[0]) && t.pop();
  }
  function su(t, e) {
    for (var i = 0; i < e.length; i++)
      t.push(e[i].x), t.push(e[i].y);
  }
  function Ao(t, e) {
    j.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new lo(t, e)), this.mergeVertices();
  }
  function lo(t, e) {
    function i(y) {
      function w(Xe, ri, Ci) {
        return ri || console.error("THREE.ExtrudeGeometry: vec does not exist"), ri.clone().multiplyScalar(Ci).add(Xe);
      }
      function A(Xe, ri, Ci) {
        var bi = Xe.x - ri.x, ne = Xe.y - ri.y, ii = Ci.x - Xe.x, Ze = Ci.y - Xe.y, ai = bi * bi + ne * ne;
        if (Math.abs(bi * Ze - ne * ii) > Number.EPSILON) {
          var gn = Math.sqrt(ai), bn = Math.sqrt(ii * ii + Ze * Ze);
          if (ai = ri.x - ne / gn, ri = ri.y + bi / gn, Ze = ((Ci.x - Ze / bn - ai) * Ze - (Ci.y + ii / bn - ri) * ii) / (bi * Ze - ne * ii), ii = ai + bi * Ze - Xe.x, bi = ri + ne * Ze - Xe.y, ne = ii * ii + bi * bi, 2 >= ne)
            return new s(ii, bi);
          ne = Math.sqrt(ne / 2);
        } else
          Xe = !1, bi > Number.EPSILON ? ii > Number.EPSILON && (Xe = !0) : bi < -Number.EPSILON ? ii < -Number.EPSILON && (Xe = !0) : Math.sign(ne) === Math.sign(Ze) && (Xe = !0), Xe ? (ii = -ne, ne = Math.sqrt(ai)) : (ii = bi, bi = ne, ne = Math.sqrt(ai / 2));
        return new s(ii / ne, bi / ne);
      }
      function P(Xe, ri) {
        for (Ce = Xe.length; 0 <= --Ce; ) {
          var Ci = Ce, bi = Ce - 1;
          0 > bi && (bi = Xe.length - 1);
          var ne, ii = gt + 2 * ot;
          for (ne = 0; ne < ii; ne++) {
            var Ze = Gi * ne, ai = Gi * (ne + 1), gn = ri + bi + Ze, bn = ri + bi + ai;
            ai = ri + Ci + ai, q(ri + Ci + Ze), q(gn), q(ai), q(gn), q(bn), q(ai), Ze = o.length / 3, Ze = ee.generateSideWallUV(n, o, Ze - 6, Ze - 3, Ze - 2, Ze - 1), $(Ze[0]), $(Ze[1]), $(Ze[3]), $(Ze[1]), $(Ze[2]), $(Ze[3]);
          }
        }
      }
      function B(Xe, ri, Ci) {
        rt.push(Xe), rt.push(ri), rt.push(Ci);
      }
      function H(Xe, ri, Ci) {
        q(Xe), q(ri), q(Ci), Xe = o.length / 3, Xe = ee.generateTopUV(n, o, Xe - 3, Xe - 2, Xe - 1), $(Xe[0]), $(Xe[1]), $(Xe[2]);
      }
      function q(Xe) {
        o.push(rt[3 * Xe]), o.push(rt[3 * Xe + 1]), o.push(rt[3 * Xe + 2]);
      }
      function $(Xe) {
        l.push(Xe.x), l.push(Xe.y);
      }
      var rt = [], xt = e.curveSegments !== void 0 ? e.curveSegments : 12, gt = e.steps !== void 0 ? e.steps : 1, Ct = e.depth !== void 0 ? e.depth : 100, wt = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, Vt = e.bevelThickness !== void 0 ? e.bevelThickness : 6, Z = e.bevelSize !== void 0 ? e.bevelSize : Vt - 2, ot = e.bevelSegments !== void 0 ? e.bevelSegments : 3, zt = e.extrudePath, ee = e.UVGenerator !== void 0 ? e.UVGenerator : ul;
      e.amount !== void 0 && (console.warn(
        "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
      ), Ct = e.amount);
      var $t = !1;
      if (zt) {
        var qt = zt.getSpacedPoints(gt);
        $t = !0, wt = !1;
        var Te = zt.computeFrenetFrames(gt, !1), me = new u(), Ie = new u(), be = new u();
      }
      wt || (Z = Vt = ot = 0);
      var ae;
      xt = y.extractPoints(xt), y = xt.shape;
      var We = xt.holes;
      if (!vo.isClockWise(y)) {
        y = y.reverse();
        var Qe = 0;
        for (ae = We.length; Qe < ae; Qe++) {
          var ci = We[Qe];
          vo.isClockWise(ci) && (We[Qe] = ci.reverse());
        }
      }
      var Sn = vo.triangulateShape(y, We), mn = y;
      for (Qe = 0, ae = We.length; Qe < ae; Qe++)
        ci = We[Qe], y = y.concat(ci);
      var ji, Gi = y.length, en, En = Sn.length;
      xt = [];
      var Ce = 0, ti = mn.length, Ut = ti - 1;
      for (ji = Ce + 1; Ce < ti; Ce++, Ut++, ji++)
        Ut === ti && (Ut = 0), ji === ti && (ji = 0), xt[Ce] = A(mn[Ce], mn[Ut], mn[ji]);
      zt = [];
      var Ye = xt.concat();
      for (Qe = 0, ae = We.length; Qe < ae; Qe++) {
        ci = We[Qe];
        var ei = [];
        for (Ce = 0, ti = ci.length, Ut = ti - 1, ji = Ce + 1; Ce < ti; Ce++, Ut++, ji++)
          Ut === ti && (Ut = 0), ji === ti && (ji = 0), ei[Ce] = A(ci[Ce], ci[Ut], ci[ji]);
        zt.push(ei), Ye = Ye.concat(ei);
      }
      for (Ut = 0; Ut < ot; Ut++) {
        ti = Ut / ot;
        var Hi = Vt * Math.cos(ti * Math.PI / 2);
        for (ji = Z * Math.sin(ti * Math.PI / 2), Ce = 0, ti = mn.length; Ce < ti; Ce++) {
          var Ae = w(mn[Ce], xt[Ce], ji);
          B(Ae.x, Ae.y, -Hi);
        }
        for (Qe = 0, ae = We.length; Qe < ae; Qe++)
          for (ci = We[Qe], ei = zt[Qe], Ce = 0, ti = ci.length; Ce < ti; Ce++)
            Ae = w(ci[Ce], ei[Ce], ji), B(Ae.x, Ae.y, -Hi);
      }
      for (ji = Z, Ce = 0; Ce < Gi; Ce++)
        Ae = wt ? w(y[Ce], Ye[Ce], ji) : y[Ce], $t ? (Ie.copy(Te.normals[0]).multiplyScalar(Ae.x), me.copy(Te.binormals[0]).multiplyScalar(Ae.y), be.copy(qt[0]).add(Ie).add(me), B(be.x, be.y, be.z)) : B(Ae.x, Ae.y, 0);
      for (ti = 1; ti <= gt; ti++)
        for (Ce = 0; Ce < Gi; Ce++)
          Ae = wt ? w(y[Ce], Ye[Ce], ji) : y[Ce], $t ? (Ie.copy(Te.normals[ti]).multiplyScalar(Ae.x), me.copy(Te.binormals[ti]).multiplyScalar(Ae.y), be.copy(qt[ti]).add(Ie).add(me), B(be.x, be.y, be.z)) : B(Ae.x, Ae.y, Ct / gt * ti);
      for (Ut = ot - 1; 0 <= Ut; Ut--) {
        for (ti = Ut / ot, Hi = Vt * Math.cos(ti * Math.PI / 2), ji = Z * Math.sin(ti * Math.PI / 2), Ce = 0, ti = mn.length; Ce < ti; Ce++)
          Ae = w(mn[Ce], xt[Ce], ji), B(Ae.x, Ae.y, Ct + Hi);
        for (Qe = 0, ae = We.length; Qe < ae; Qe++)
          for (ci = We[Qe], ei = zt[Qe], Ce = 0, ti = ci.length; Ce < ti; Ce++)
            Ae = w(ci[Ce], ei[Ce], ji), $t ? B(Ae.x, Ae.y + qt[gt - 1].y, qt[gt - 1].x + Hi) : B(Ae.x, Ae.y, Ct + Hi);
      }
      (function() {
        var Xe = o.length / 3;
        if (wt) {
          var ri = 0 * Gi;
          for (Ce = 0; Ce < En; Ce++)
            en = Sn[Ce], H(en[2] + ri, en[1] + ri, en[0] + ri);
          for (ri = Gi * (gt + 2 * ot), Ce = 0; Ce < En; Ce++)
            en = Sn[Ce], H(en[0] + ri, en[1] + ri, en[2] + ri);
        } else {
          for (Ce = 0; Ce < En; Ce++)
            en = Sn[Ce], H(en[2], en[1], en[0]);
          for (Ce = 0; Ce < En; Ce++)
            en = Sn[Ce], H(en[0] + Gi * gt, en[1] + Gi * gt, en[2] + Gi * gt);
        }
        n.addGroup(Xe, o.length / 3 - Xe, 0);
      })(), function() {
        var Xe = o.length / 3, ri = 0;
        for (P(mn, ri), ri += mn.length, Qe = 0, ae = We.length; Qe < ae; Qe++)
          ci = We[Qe], P(ci, ri), ri += ci.length;
        n.addGroup(Xe, o.length / 3 - Xe, 1);
      }();
    }
    Ft.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
    for (var n = this, o = [], l = [], f = 0, p = t.length; f < p; f++)
      i(t[f]);
    this.addAttribute("position", new Et(o, 3)), this.addAttribute("uv", new Et(l, 2)), this.computeVertexNormals();
  }
  function au(t, e, i) {
    if (i.shapes = [], Array.isArray(t))
      for (var n = 0, o = t.length; n < o; n++)
        i.shapes.push(t[n].uuid);
    else
      i.shapes.push(t.uuid);
    return e.extrudePath !== void 0 && (i.options.extrudePath = e.extrudePath.toJSON()), i;
  }
  function Xa(t, e) {
    j.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new vs(t, e)), this.mergeVertices();
  }
  function vs(t, e) {
    e = e || {};
    var i = e.font;
    if (!i || !i.isFont)
      return console.error(
        "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
      ), new j();
    t = i.generateShapes(t, e.size), e.depth = e.height !== void 0 ? e.height : 50, e.bevelThickness === void 0 && (e.bevelThickness = 10), e.bevelSize === void 0 && (e.bevelSize = 8), e.bevelEnabled === void 0 && (e.bevelEnabled = !1), lo.call(this, t, e), this.type = "TextBufferGeometry";
  }
  function Wo(t, e, i, n, o, l, f) {
    j.call(this), this.type = "SphereGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: o,
      thetaStart: l,
      thetaLength: f
    }, this.fromBufferGeometry(new Er(t, e, i, n, o, l, f)), this.mergeVertices();
  }
  function Er(t, e, i, n, o, l, f) {
    Ft.call(this), this.type = "SphereBufferGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: o,
      thetaStart: l,
      thetaLength: f
    }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = n !== void 0 ? n : 0, o = o !== void 0 ? o : 2 * Math.PI, l = l !== void 0 ? l : 0, f = f !== void 0 ? f : Math.PI;
    var p = l + f, y, w, A = 0, P = [], B = new u(), H = new u(), q = [], $ = [], rt = [], xt = [];
    for (w = 0; w <= i; w++) {
      var gt = [], Ct = w / i;
      for (y = 0; y <= e; y++) {
        var wt = y / e;
        B.x = -t * Math.cos(n + wt * o) * Math.sin(l + Ct * f), B.y = t * Math.cos(l + Ct * f), B.z = t * Math.sin(n + wt * o) * Math.sin(l + Ct * f), $.push(B.x, B.y, B.z), H.set(B.x, B.y, B.z).normalize(), rt.push(H.x, H.y, H.z), xt.push(wt, 1 - Ct), gt.push(A++);
      }
      P.push(gt);
    }
    for (w = 0; w < i; w++)
      for (y = 0; y < e; y++)
        t = P[w][y + 1], n = P[w][y], o = P[w + 1][y], f = P[w + 1][y + 1], (w !== 0 || 0 < l) && q.push(t, n, f), (w !== i - 1 || p < Math.PI) && q.push(n, o, f);
    this.setIndex(q), this.addAttribute("position", new Et($, 3)), this.addAttribute("normal", new Et(rt, 3)), this.addAttribute("uv", new Et(xt, 2));
  }
  function qa(t, e, i, n, o, l) {
    j.call(this), this.type = "RingGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: o,
      thetaLength: l
    }, this.fromBufferGeometry(new ys(t, e, i, n, o, l)), this.mergeVertices();
  }
  function ys(t, e, i, n, o, l) {
    Ft.call(this), this.type = "RingBufferGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: o,
      thetaLength: l
    }, t = t || 0.5, e = e || 1, o = o !== void 0 ? o : 0, l = l !== void 0 ? l : 2 * Math.PI, i = i !== void 0 ? Math.max(3, i) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
    var f = [], p = [], y = [], w = [], A = t, P = (e - t) / n, B = new u(), H = new s(), q, $;
    for (q = 0; q <= n; q++) {
      for ($ = 0; $ <= i; $++)
        t = o + $ / i * l, B.x = A * Math.cos(t), B.y = A * Math.sin(t), p.push(B.x, B.y, B.z), y.push(0, 0, 1), H.x = (B.x / e + 1) / 2, H.y = (B.y / e + 1) / 2, w.push(H.x, H.y);
      A += P;
    }
    for (q = 0; q < n; q++)
      for (e = q * (i + 1), $ = 0; $ < i; $++)
        t = $ + e, o = t + i + 1, l = t + i + 2, A = t + 1, f.push(t, o, A), f.push(o, l, A);
    this.setIndex(f), this.addAttribute("position", new Et(p, 3)), this.addAttribute("normal", new Et(y, 3)), this.addAttribute("uv", new Et(w, 2));
  }
  function aa(t, e, i, n) {
    j.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, this.fromBufferGeometry(new jo(t, e, i, n)), this.mergeVertices();
  }
  function jo(t, e, i, n) {
    Ft.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = fi.clamp(n, 0, 2 * Math.PI);
    var o = [], l = [], f = [], p = 1 / e, y = new u(), w = new s(), A;
    for (A = 0; A <= e; A++) {
      var P = i + A * p * n, B = Math.sin(P), H = Math.cos(P);
      for (P = 0; P <= t.length - 1; P++)
        y.x = t[P].x * B, y.y = t[P].y, y.z = t[P].x * H, l.push(y.x, y.y, y.z), w.x = A / e, w.y = P / (t.length - 1), f.push(w.x, w.y);
    }
    for (A = 0; A < e; A++)
      for (P = 0; P < t.length - 1; P++)
        i = P + A * t.length, p = i + t.length, y = i + t.length + 1, w = i + 1, o.push(i, p, w), o.push(p, y, w);
    if (this.setIndex(o), this.addAttribute("position", new Et(l, 3)), this.addAttribute("uv", new Et(f, 2)), this.computeVertexNormals(), n === 2 * Math.PI)
      for (n = this.attributes.normal.array, o = new u(), l = new u(), f = new u(), i = e * t.length * 3, P = A = 0; A < t.length; A++, P += 3)
        o.x = n[P + 0], o.y = n[P + 1], o.z = n[P + 2], l.x = n[i + P + 0], l.y = n[i + P + 1], l.z = n[i + P + 2], f.addVectors(o, l).normalize(), n[P + 0] = n[i + P + 0] = f.x, n[P + 1] = n[i + P + 1] = f.y, n[P + 2] = n[i + P + 2] = f.z;
  }
  function Po(t, e) {
    j.call(this), this.type = "ShapeGeometry", typeof e == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new Xo(t, e)), this.mergeVertices();
  }
  function Xo(t, e) {
    function i(A) {
      var P, B = o.length / 3;
      A = A.extractPoints(e);
      var H = A.shape, q = A.holes;
      if (vo.isClockWise(H) === !1)
        for (H = H.reverse(), A = 0, P = q.length; A < P; A++) {
          var $ = q[A];
          vo.isClockWise($) === !0 && (q[A] = $.reverse());
        }
      var rt = vo.triangulateShape(H, q);
      for (A = 0, P = q.length; A < P; A++)
        $ = q[A], H = H.concat($);
      for (A = 0, P = H.length; A < P; A++)
        $ = H[A], o.push($.x, $.y, 0), l.push(0, 0, 1), f.push($.x, $.y);
      for (A = 0, P = rt.length; A < P; A++)
        H = rt[A], n.push(H[0] + B, H[1] + B, H[2] + B), y += 3;
    }
    Ft.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12;
    var n = [], o = [], l = [], f = [], p = 0, y = 0;
    if (Array.isArray(t) === !1)
      i(t);
    else
      for (var w = 0; w < t.length; w++)
        i(t[w]), this.addGroup(p, y, w), p += y, y = 0;
    this.setIndex(n), this.addAttribute("position", new Et(o, 3)), this.addAttribute("normal", new Et(l, 3)), this.addAttribute("uv", new Et(f, 2));
  }
  function lu(t, e) {
    if (e.shapes = [], Array.isArray(t))
      for (var i = 0, n = t.length; i < n; i++)
        e.shapes.push(t[i].uuid);
    else
      e.shapes.push(t.uuid);
    return e;
  }
  function qo(t, e) {
    Ft.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e };
    var i = [];
    e = Math.cos(fi.DEG2RAD * (e !== void 0 ? e : 1));
    var n = [0, 0], o = {}, l = ["a", "b", "c"];
    if (t.isBufferGeometry) {
      var f = new j();
      f.fromBufferGeometry(t);
    } else
      f = t.clone();
    f.mergeVertices(), f.computeFaceNormals(), t = f.vertices, f = f.faces;
    for (var p = 0, y = f.length; p < y; p++)
      for (var w = f[p], A = 0; 3 > A; A++) {
        var P = w[l[A]], B = w[l[(A + 1) % 3]];
        n[0] = Math.min(P, B), n[1] = Math.max(P, B), P = n[0] + "," + n[1], o[P] === void 0 ? o[P] = { index1: n[0], index2: n[1], face1: p, face2: void 0 } : o[P].face2 = p;
      }
    for (P in o)
      n = o[P], (n.face2 === void 0 || f[n.face1].normal.dot(f[n.face2].normal) <= e) && (l = t[n.index1], i.push(l.x, l.y, l.z), l = t[n.index2], i.push(l.x, l.y, l.z));
    this.addAttribute("position", new Et(i, 3));
  }
  function Lo(t, e, i, n, o, l, f, p) {
    j.call(this), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: o,
      openEnded: l,
      thetaStart: f,
      thetaLength: p
    }, this.fromBufferGeometry(new Ro(t, e, i, n, o, l, f, p)), this.mergeVertices();
  }
  function Ro(t, e, i, n, o, l, f, p) {
    function y(gt) {
      var Ct, wt = new s(), Vt = new u(), Z = 0, ot = gt === !0 ? t : e, zt = gt === !0 ? 1 : -1, ee = q;
      for (Ct = 1; Ct <= n; Ct++)
        P.push(0, rt * zt, 0), B.push(0, zt, 0), H.push(0.5, 0.5), q++;
      var $t = q;
      for (Ct = 0; Ct <= n; Ct++) {
        var qt = Ct / n * p + f, Te = Math.cos(qt);
        qt = Math.sin(qt), Vt.x = ot * qt, Vt.y = rt * zt, Vt.z = ot * Te, P.push(Vt.x, Vt.y, Vt.z), B.push(0, zt, 0), wt.x = 0.5 * Te + 0.5, wt.y = 0.5 * qt * zt + 0.5, H.push(wt.x, wt.y), q++;
      }
      for (Ct = 0; Ct < n; Ct++)
        wt = ee + Ct, Vt = $t + Ct, gt === !0 ? A.push(Vt, Vt + 1, wt) : A.push(Vt + 1, Vt, wt), Z += 3;
      w.addGroup(xt, Z, gt === !0 ? 1 : 2), xt += Z;
    }
    Ft.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: o,
      openEnded: l,
      thetaStart: f,
      thetaLength: p
    };
    var w = this;
    t = t !== void 0 ? t : 1, e = e !== void 0 ? e : 1, i = i || 1, n = Math.floor(n) || 8, o = Math.floor(o) || 1, l = l !== void 0 ? l : !1, f = f !== void 0 ? f : 0, p = p !== void 0 ? p : 2 * Math.PI;
    var A = [], P = [], B = [], H = [], q = 0, $ = [], rt = i / 2, xt = 0;
    (function() {
      var gt, Ct, wt = new u(), Vt = new u(), Z = 0, ot = (e - t) / i;
      for (Ct = 0; Ct <= o; Ct++) {
        var zt = [], ee = Ct / o, $t = ee * (e - t) + t;
        for (gt = 0; gt <= n; gt++) {
          var qt = gt / n, Te = qt * p + f, me = Math.sin(Te);
          Te = Math.cos(Te), Vt.x = $t * me, Vt.y = -ee * i + rt, Vt.z = $t * Te, P.push(Vt.x, Vt.y, Vt.z), wt.set(me, ot, Te).normalize(), B.push(wt.x, wt.y, wt.z), H.push(qt, 1 - ee), zt.push(q++);
        }
        $.push(zt);
      }
      for (gt = 0; gt < n; gt++)
        for (Ct = 0; Ct < o; Ct++)
          wt = $[Ct + 1][gt], Vt = $[Ct + 1][gt + 1], ot = $[Ct][gt + 1], A.push($[Ct][gt], wt, ot), A.push(wt, Vt, ot), Z += 6;
      w.addGroup(xt, Z, 0), xt += Z;
    })(), l === !1 && (0 < t && y(!0), 0 < e && y(!1)), this.setIndex(A), this.addAttribute("position", new Et(P, 3)), this.addAttribute("normal", new Et(B, 3)), this.addAttribute("uv", new Et(H, 2));
  }
  function la(t, e, i, n, o, l, f) {
    Lo.call(this, 0, t, e, i, n, o, l, f), this.type = "ConeGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: o,
      thetaStart: l,
      thetaLength: f
    };
  }
  function Fn(t, e, i, n, o, l, f) {
    Ro.call(this, 0, t, e, i, n, o, l, f), this.type = "ConeBufferGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: o,
      thetaStart: l,
      thetaLength: f
    };
  }
  function _s(t, e, i, n) {
    j.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new ho(t, e, i, n)), this.mergeVertices();
  }
  function ho(t, e, i, n) {
    Ft.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, t = t || 1, e = e !== void 0 ? Math.max(3, e) : 8, i = i !== void 0 ? i : 0, n = n !== void 0 ? n : 2 * Math.PI;
    var o = [], l = [], f = [], p = [], y, w = new u(), A = new s();
    l.push(0, 0, 0), f.push(0, 0, 1), p.push(0.5, 0.5);
    var P = 0;
    for (y = 3; P <= e; P++, y += 3) {
      var B = i + P / e * n;
      w.x = t * Math.cos(B), w.y = t * Math.sin(B), l.push(w.x, w.y, w.z), f.push(0, 0, 1), A.x = (l[y] / t + 1) / 2, A.y = (l[y + 1] / t + 1) / 2, p.push(A.x, A.y);
    }
    for (y = 1; y <= e; y++)
      o.push(y, y + 1, 0);
    this.setIndex(o), this.addAttribute("position", new Et(l, 3)), this.addAttribute("normal", new Et(f, 3)), this.addAttribute("uv", new Et(p, 2));
  }
  function Yo(t) {
    Yt.call(this), this.type = "ShadowMaterial", this.color = new L(0), this.transparent = !0, this.setValues(t);
  }
  function xs(t) {
    $e.call(this, t), this.type = "RawShaderMaterial";
  }
  function uo(t) {
    Yt.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new L(16777215), this.metalness = this.roughness = 0.5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new s(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function ws(t) {
    uo.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t);
  }
  function Wr(t) {
    Yt.call(this), this.type = "MeshPhongMaterial", this.color = new L(16777215), this.specular = new L(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new s(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Ts(t) {
    Wr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t);
  }
  function Ms(t) {
    Yt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new s(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t);
  }
  function br(t) {
    Yt.call(this), this.type = "MeshLambertMaterial", this.color = new L(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Ss(t) {
    if (Yt.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new L(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new s(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t), this.matcap === null) {
      t = document.createElement("canvas"), t.width = 1, t.height = 1;
      var e = t.getContext("2d");
      e.fillStyle = "#fff", e.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t);
    }
  }
  function Es(t) {
    zi.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
  }
  function Zn(t, e, i, n) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i;
  }
  function Ya(t, e, i, n) {
    Zn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function Cr(t, e, i, n) {
    Zn.call(this, t, e, i, n);
  }
  function bs(t, e, i, n) {
    Zn.call(this, t, e, i, n);
  }
  function Un(t, e, i, n) {
    if (t === void 0)
      throw Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = Wn.convertArray(e, this.TimeBufferType), this.values = Wn.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  function Nl(t, e, i) {
    Un.call(this, t, e, i);
  }
  function Fl(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function jr(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function ir(t, e, i, n) {
    Zn.call(this, t, e, i, n);
  }
  function ha(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function Ul(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function ua(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function gr(t, e, i) {
    this.name = t, this.tracks = i, this.duration = e !== void 0 ? e : -1, this.uuid = fi.generateUUID(), 0 > this.duration && this.resetDuration();
  }
  function tc(t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return jr;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ua;
      case "color":
        return Fl;
      case "quaternion":
        return ha;
      case "bool":
      case "boolean":
        return Nl;
      case "string":
        return Ul;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }
  function ec(t) {
    if (t.type === void 0)
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var e = tc(t.type);
    if (t.times === void 0) {
      var i = [], n = [];
      Wn.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n;
    }
    return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
  }
  function Zo(t, e, i) {
    var n = this, o = !1, l = 0, f = 0, p = void 0;
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(y) {
      f++, o === !1 && n.onStart !== void 0 && n.onStart(y, l, f), o = !0;
    }, this.itemEnd = function(y) {
      l++, n.onProgress !== void 0 && n.onProgress(y, l, f), l === f && (o = !1, n.onLoad !== void 0) && n.onLoad();
    }, this.itemError = function(y) {
      n.onError !== void 0 && n.onError(y);
    }, this.resolveURL = function(y) {
      return p ? p(y) : y;
    }, this.setURLModifier = function(y) {
      return p = y, this;
    };
  }
  function Lt(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Qt(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Zt(t) {
    this.manager = t !== void 0 ? t : Kn, this._parser = null;
  }
  function Ue(t) {
    this.manager = t !== void 0 ? t : Kn, this._parser = null;
  }
  function si(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function ki(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function ln(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Ee() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  function Jn(t, e, i, n, o, l, f, p) {
    Ee.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = o || 0, this.aEndAngle = l || 2 * Math.PI, this.aClockwise = f || !1, this.aRotation = p || 0;
  }
  function ca(t, e, i, n, o, l) {
    Jn.call(this, t, e, i, i, n, o, l), this.type = "ArcCurve";
  }
  function nr() {
    var t = 0, e = 0, i = 0, n = 0;
    return {
      initCatmullRom: function(o, l, f, p, y) {
        o = y * (f - o), p = y * (p - l), t = l, e = o, i = -3 * l + 3 * f - 2 * o - p, n = 2 * l - 2 * f + o + p;
      },
      initNonuniformCatmullRom: function(o, l, f, p, y, w, A) {
        o = ((l - o) / y - (f - o) / (y + w) + (f - l) / w) * w, p = ((f - l) / w - (p - l) / (w + A) + (p - f) / A) * w, t = l, e = o, i = -3 * l + 3 * f - 2 * o - p, n = 2 * l - 2 * f + o + p;
      },
      calc: function(o) {
        var l = o * o;
        return t + e * o + i * l + n * l * o;
      }
    };
  }
  function Pn(t, e, i, n) {
    Ee.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || 0.5;
  }
  function hu(t, e, i, n, o) {
    e = 0.5 * (n - e), o = 0.5 * (o - i);
    var l = t * t;
    return (2 * i - 2 * n + e + o) * t * l + (-3 * i + 3 * n - 2 * e - o) * l + e * t + i;
  }
  function co(t, e, i, n) {
    var o = 1 - t;
    return o * o * e + 2 * (1 - t) * t * i + t * t * n;
  }
  function Jo(t, e, i, n, o) {
    var l = 1 - t, f = 1 - t;
    return l * l * l * e + 3 * f * f * t * i + 3 * (1 - t) * t * t * n + t * t * t * o;
  }
  function rr(t, e, i, n) {
    Ee.call(this), this.type = "CubicBezierCurve", this.v0 = t || new s(), this.v1 = e || new s(), this.v2 = i || new s(), this.v3 = n || new s();
  }
  function wi(t, e, i, n) {
    Ee.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new u(), this.v1 = e || new u(), this.v2 = i || new u(), this.v3 = n || new u();
  }
  function or(t, e) {
    Ee.call(this), this.type = "LineCurve", this.v1 = t || new s(), this.v2 = e || new s();
  }
  function Ar(t, e) {
    Ee.call(this), this.type = "LineCurve3", this.v1 = t || new u(), this.v2 = e || new u();
  }
  function sr(t, e, i) {
    Ee.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new s(), this.v1 = e || new s(), this.v2 = i || new s();
  }
  function fo(t, e, i) {
    Ee.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new u(), this.v1 = e || new u(), this.v2 = i || new u();
  }
  function Xr(t) {
    Ee.call(this), this.type = "SplineCurve", this.points = t || [];
  }
  function Oo() {
    Ee.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  function ar(t) {
    Oo.call(this), this.type = "Path", this.currentPoint = new s(), t && this.setFromPoints(t);
  }
  function $n(t) {
    ar.call(this, t), this.uuid = fi.generateUUID(), this.type = "Shape", this.holes = [];
  }
  function $i(t, e) {
    N.call(this), this.type = "Light", this.color = new L(t), this.intensity = e !== void 0 ? e : 1, this.receiveShadow = void 0;
  }
  function Za(t, e, i) {
    $i.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(N.DefaultUp), this.updateMatrix(), this.groundColor = new L(e);
  }
  function po(t) {
    this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new s(512, 512), this.map = null, this.matrix = new c();
  }
  function Ja() {
    po.call(this, new _e(50, 1, 0.5, 500));
  }
  function $a(t, e, i, n, o, l) {
    $i.call(this, t, e), this.type = "SpotLight", this.position.copy(N.DefaultUp), this.updateMatrix(), this.target = new N(), Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(f) {
        this.intensity = f / Math.PI;
      }
    }), this.distance = i !== void 0 ? i : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = o !== void 0 ? o : 0, this.decay = l !== void 0 ? l : 1, this.shadow = new Ja();
  }
  function Cs(t, e, i, n) {
    $i.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
      get: function() {
        return 4 * this.intensity * Math.PI;
      },
      set: function(o) {
        this.intensity = o / (4 * Math.PI);
      }
    }), this.distance = i !== void 0 ? i : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new po(new _e(90, 1, 0.5, 500));
  }
  function fa(t, e, i, n, o, l) {
    Be.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t !== void 0 ? t : -1, this.right = e !== void 0 ? e : 1, this.top = i !== void 0 ? i : 1, this.bottom = n !== void 0 ? n : -1, this.near = o !== void 0 ? o : 0.1, this.far = l !== void 0 ? l : 2e3, this.updateProjectionMatrix();
  }
  function $o() {
    po.call(this, new fa(-5, 5, 5, -5, 0.5, 500));
  }
  function mo(t, e) {
    $i.call(this, t, e), this.type = "DirectionalLight", this.position.copy(N.DefaultUp), this.updateMatrix(), this.target = new N(), this.shadow = new $o();
  }
  function As(t, e) {
    $i.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0;
  }
  function Gl(t, e, i, n) {
    $i.call(this, t, e), this.type = "RectAreaLight", this.width = i !== void 0 ? i : 10, this.height = n !== void 0 ? n : 10;
  }
  function Hl(t) {
    this.manager = t !== void 0 ? t : Kn, this.textures = {};
  }
  function wh(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Io() {
  }
  function Ps(t) {
    typeof t == "boolean" && (console.warn(
      "THREE.JSONLoader: showStatus parameter has been removed from constructor."
    ), t = void 0), this.manager = t !== void 0 ? t : Kn, this.withCredentials = !1;
  }
  function Ka(t) {
    this.manager = t !== void 0 ? t : Kn, this.resourcePath = "";
  }
  function Th(t) {
    typeof createImageBitmap > "u" && console.warn(
      "THREE.ImageBitmapLoader: createImageBitmap() not supported."
    ), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = t !== void 0 ? t : Kn, this.options = void 0;
  }
  function Vl() {
    this.type = "ShapePath", this.color = new L(), this.subPaths = [], this.currentPath = null;
  }
  function Mh(t) {
    this.type = "Font", this.data = t;
  }
  function uu(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function pn(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Gn() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new _e(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new _e(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
  }
  function Qa(t, e, i, n) {
    N.call(this), this.type = "CubeCamera";
    var o = new _e(90, 1, t, e);
    o.up.set(0, -1, 0), o.lookAt(new u(1, 0, 0)), this.add(o);
    var l = new _e(90, 1, t, e);
    l.up.set(0, -1, 0), l.lookAt(new u(-1, 0, 0)), this.add(l);
    var f = new _e(90, 1, t, e);
    f.up.set(0, 0, 1), f.lookAt(new u(0, 1, 0)), this.add(f);
    var p = new _e(90, 1, t, e);
    p.up.set(0, 0, -1), p.lookAt(new u(0, -1, 0)), this.add(p);
    var y = new _e(90, 1, t, e);
    y.up.set(0, -1, 0), y.lookAt(new u(0, 0, 1)), this.add(y);
    var w = new _e(90, 1, t, e);
    w.up.set(0, -1, 0), w.lookAt(new u(0, 0, -1)), this.add(w), n = n || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new C(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(A, P) {
      this.parent === null && this.updateMatrixWorld();
      var B = this.renderTarget, H = B.texture.generateMipmaps;
      B.texture.generateMipmaps = !1, B.activeCubeFace = 0, A.render(P, o, B), B.activeCubeFace = 1, A.render(P, l, B), B.activeCubeFace = 2, A.render(P, f, B), B.activeCubeFace = 3, A.render(P, p, B), B.activeCubeFace = 4, A.render(P, y, B), B.texture.generateMipmaps = H, B.activeCubeFace = 5, A.render(P, w, B), A.setRenderTarget(null);
    }, this.clear = function(A, P, B, H) {
      for (var q = this.renderTarget, $ = 0; 6 > $; $++)
        q.activeCubeFace = $, A.setRenderTarget(q), A.clear(P, B, H);
      A.setRenderTarget(null);
    };
  }
  function Sh(t) {
    this.autoStart = t !== void 0 ? t : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1;
  }
  function Wl() {
    N.call(this), this.type = "AudioListener", this.context = Dh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0;
  }
  function pa(t) {
    N.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
  }
  function tl(t) {
    pa.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
  }
  function Ls(t, e) {
    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e !== void 0 ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
  }
  function el(t, e, i) {
    switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
      case "quaternion":
        e = this._slerp;
        break;
      case "string":
      case "bool":
        t = Array, e = this._select;
        break;
      default:
        e = this._lerp;
    }
    this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function Rs(t, e, i) {
    i = i || Tn.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }
  function Tn(t, e, i) {
    this.path = e, this.parsedPath = i || Tn.parseTrackName(e), this.node = Tn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
  }
  function da() {
    this.uuid = fi.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var e = 0, i = arguments.length; e !== i; ++e)
      t[arguments[e].uuid] = e;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  function il(t, e, i) {
    this._mixer = t, this._clip = e, this._localRoot = i || null, t = e.tracks, e = t.length, i = Array(e);
    for (var n = { endingStart: 2400, endingEnd: 2400 }, o = 0; o !== e; ++o) {
      var l = t[o].createInterpolant(null);
      i[o] = l, l.settings = n;
    }
    this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function Ko(t) {
    this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
  }
  function jl(t, e) {
    typeof t == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t;
  }
  function Eh() {
    Ft.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
  }
  function bh(t, e, i) {
    Ii.call(this, t, e), this.meshPerAttribute = i || 1;
  }
  function Ch(t, e, i, n) {
    typeof i == "number" && (n = i, i = !1, console.error(
      "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
    )), J.call(this, t, e, i), this.meshPerAttribute = n || 1;
  }
  function cu(t, e, i, n) {
    this.ray = new Li(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    }, Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          return console.warn(
            "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
          ), this.Points;
        }
      }
    });
  }
  function nl(t, e) {
    return t.distance - e.distance;
  }
  function Os(t, e, i, n) {
    if (t.visible !== !1 && (t.raycast(e, i), n === !0)) {
      t = t.children, n = 0;
      for (var o = t.length; n < o; n++)
        Os(t[n], e, i, !0);
    }
  }
  function Ah(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.phi = e !== void 0 ? e : 0, this.theta = i !== void 0 ? i : 0, this;
  }
  function it(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.theta = e !== void 0 ? e : 0, this.y = i !== void 0 ? i : 0, this;
  }
  function Qo(t, e) {
    this.min = t !== void 0 ? t : new s(1 / 0, 1 / 0), this.max = e !== void 0 ? e : new s(-1 / 0, -1 / 0);
  }
  function ma(t, e) {
    this.start = t !== void 0 ? t : new u(), this.end = e !== void 0 ? e : new u();
  }
  function Vn(t) {
    N.call(this), this.material = t, this.render = function() {
    };
  }
  function yi(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16711680, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new Ft(), e = new Et(6 * e, 3), i.addAttribute("position", e), mi.call(this, i, new zi({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function ga(t, e) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new Ft(), e = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (var i = 0, n = 1; 32 > i; i++, n++) {
      var o = i / 32 * Math.PI * 2, l = n / 32 * Math.PI * 2;
      e.push(Math.cos(o), Math.sin(o), 1, Math.cos(l), Math.sin(l), 1);
    }
    t.addAttribute("position", new Et(e, 3)), e = new zi({ fog: !1 }), this.cone = new mi(t, e), this.add(this.cone), this.update();
  }
  function fu(t) {
    var e = [];
    t && t.isBone && e.push(t);
    for (var i = 0; i < t.children.length; i++)
      e.push.apply(e, fu(t.children[i]));
    return e;
  }
  function va(t) {
    for (var e = fu(t), i = new Ft(), n = [], o = [], l = new L(0, 0, 1), f = new L(0, 1, 0), p = 0; p < e.length; p++) {
      var y = e[p];
      y.parent && y.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), o.push(l.r, l.g, l.b), o.push(f.r, f.g, f.b));
    }
    i.addAttribute("position", new Et(n, 3)), i.addAttribute("color", new Et(o, 3)), n = new zi({
      vertexColors: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), mi.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
  }
  function Pr(t, e, i) {
    this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new Er(e, 4, 2), e = new Ge({ wireframe: !0, fog: !1 }), pi.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  function ya(t, e) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new zi({ fog: !1 }), e = new Ft(), e.addAttribute("position", new J(new Float32Array(15), 3)), this.line = new Vi(e, t), this.add(this.line), this.update();
  }
  function _a(t, e, i) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t = new ps(e), t.rotateY(0.5 * Math.PI), this.material = new Ge({ wireframe: !0, fog: !1 }), this.color === void 0 && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new J(e, 3)), this.add(new pi(t, this.material)), this.update();
  }
  function rl(t, e, i, n) {
    t = t || 10, e = e || 10, i = new L(i !== void 0 ? i : 4473924), n = new L(n !== void 0 ? n : 8947848);
    var o = e / 2, l = t / e, f = t / 2;
    t = [];
    for (var p = [], y = 0, w = 0, A = -f; y <= e; y++, A += l) {
      t.push(-f, 0, A, f, 0, A), t.push(A, 0, -f, A, 0, f);
      var P = y === o ? i : n;
      P.toArray(p, w), w += 3, P.toArray(p, w), w += 3, P.toArray(p, w), w += 3, P.toArray(p, w), w += 3;
    }
    e = new Ft(), e.addAttribute("position", new Et(t, 3)), e.addAttribute("color", new Et(p, 3)), i = new zi({ vertexColors: 2 }), mi.call(this, e, i);
  }
  function Xl(t, e, i, n, o, l) {
    t = t || 10, e = e || 16, i = i || 8, n = n || 64, o = new L(o !== void 0 ? o : 4473924), l = new L(l !== void 0 ? l : 8947848);
    var f = [], p = [], y;
    for (y = 0; y <= e; y++) {
      var w = y / e * 2 * Math.PI, A = Math.sin(w) * t;
      w = Math.cos(w) * t, f.push(0, 0, 0), f.push(A, 0, w);
      var P = y & 1 ? o : l;
      p.push(P.r, P.g, P.b), p.push(P.r, P.g, P.b);
    }
    for (y = 0; y <= i; y++) {
      P = y & 1 ? o : l;
      var B = t - t / i * y;
      for (e = 0; e < n; e++)
        w = e / n * 2 * Math.PI, A = Math.sin(w) * B, w = Math.cos(w) * B, f.push(A, 0, w), p.push(P.r, P.g, P.b), w = (e + 1) / n * 2 * Math.PI, A = Math.sin(w) * B, w = Math.cos(w) * B, f.push(A, 0, w), p.push(P.r, P.g, P.b);
    }
    t = new Ft(), t.addAttribute("position", new Et(f, 3)), t.addAttribute("color", new Et(p, 3)), f = new zi({ vertexColors: 2 }), mi.call(this, t, f);
  }
  function ol(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16776960, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn(
      "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
    ), i = new Ft(), e = new Et(6 * e, 3), i.addAttribute("position", e), mi.call(this, i, new zi({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function lr(t, e, i) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, e === void 0 && (e = 1), t = new Ft(), t.addAttribute(
      "position",
      new Et([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    ), e = new zi({ fog: !1 }), this.lightPlane = new Vi(t, e), this.add(this.lightPlane), t = new Ft(), t.addAttribute("position", new Et([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Vi(t, e), this.add(this.targetLine), this.update();
  }
  function sl(t) {
    function e(H, q, $) {
      i(H, $), i(q, $);
    }
    function i(H, q) {
      l.push(0, 0, 0), f.push(q.r, q.g, q.b), p[H] === void 0 && (p[H] = []), p[H].push(l.length / 3 - 1);
    }
    var n = new Ft(), o = new zi({ color: 16777215, vertexColors: 1 }), l = [], f = [], p = {}, y = new L(16755200), w = new L(16711680), A = new L(43775), P = new L(16777215), B = new L(3355443);
    e("n1", "n2", y), e("n2", "n4", y), e("n4", "n3", y), e("n3", "n1", y), e("f1", "f2", y), e("f2", "f4", y), e("f4", "f3", y), e("f3", "f1", y), e("n1", "f1", y), e("n2", "f2", y), e("n3", "f3", y), e("n4", "f4", y), e("p", "n1", w), e("p", "n2", w), e("p", "n3", w), e("p", "n4", w), e("u1", "u2", A), e("u2", "u3", A), e("u3", "u1", A), e("c", "t", P), e("p", "c", B), e("cn1", "cn2", B), e("cn3", "cn4", B), e("cf1", "cf2", B), e("cf3", "cf4", B), n.addAttribute("position", new Et(l, 3)), n.addAttribute("color", new Et(f, 3)), mi.call(this, n, o), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = p, this.update();
  }
  function Do(t, e) {
    this.object = t, e === void 0 && (e = 16776960), t = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Float32Array(24), n = new Ft();
    n.setIndex(new J(t, 1)), n.addAttribute("position", new J(i, 3)), mi.call(this, n, new zi({ color: e })), this.matrixAutoUpdate = !1, this.update();
  }
  function al(t, e) {
    this.type = "Box3Helper", this.box = t, t = e !== void 0 ? e : 16776960, e = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Ft();
    i.setIndex(new J(e, 1)), i.addAttribute(
      "position",
      new Et(
        [
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          -1
        ],
        3
      )
    ), mi.call(this, i, new zi({ color: t })), this.geometry.computeBoundingSphere();
  }
  function ll(t, e, i) {
    this.type = "PlaneHelper", this.plane = t, this.size = e === void 0 ? 1 : e, t = i !== void 0 ? i : 16776960, e = new Ft(), e.addAttribute(
      "position",
      new Et(
        [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        3
      )
    ), e.computeBoundingSphere(), Vi.call(this, e, new zi({ color: t })), e = new Ft(), e.addAttribute(
      "position",
      new Et([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    ), e.computeBoundingSphere(), this.add(
      new pi(
        e,
        new Ge({ color: t, opacity: 0.2, transparent: !0, depthWrite: !1 })
      )
    );
  }
  function zo(t, e, i, n, o, l) {
    N.call(this), t === void 0 && (t = new THREE.Vector3(0, 0, 1)), e === void 0 && (e = new THREE.Vector3(0, 0, 0)), i === void 0 && (i = 1), n === void 0 && (n = 16776960), o === void 0 && (o = 0.2 * i), l === void 0 && (l = 0.2 * o), Kl === void 0 && (Kl = new Ft(), Kl.addAttribute("position", new Et([0, 0, 0, 0, 1, 0], 3)), fl = new Ro(0, 0.5, 1, 5, 1), fl.translate(0, -0.5, 0)), this.position.copy(e), this.line = new Vi(Kl, new zi({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new pi(fl, new Ge({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, o, l);
  }
  function vr(t) {
    t = t || 1;
    var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
    t = new Ft(), t.addAttribute("position", new Et(e, 3)), t.addAttribute(
      "color",
      new Et([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
    ), e = new zi({ vertexColors: 2 }), mi.call(this, t, e);
  }
  function pu(t) {
    console.warn(
      "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), Pn.call(this, t), this.type = "catmullrom", this.closed = !0;
  }
  function du(t) {
    console.warn(
      "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), Pn.call(this, t), this.type = "catmullrom";
  }
  function Ph(t) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
    ), Pn.call(this, t), this.type = "catmullrom";
  }
  Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52)), Number.isInteger === void 0 && (Number.isInteger = function(t) {
    return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
  }), Math.sign === void 0 && (Math.sign = function(t) {
    return 0 > t ? -1 : 0 < t ? 1 : +t;
  }), !("name" in Function.prototype) && Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  }), Object.assign === void 0 && function() {
    Object.assign = function(t) {
      if (t == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var e = Object(t), i = 1; i < arguments.length; i++) {
        var n = arguments[i];
        if (n != null)
          for (var o in n)
            Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    };
  }(), Object.assign(a.prototype, {
    addEventListener: function(t, e) {
      this._listeners === void 0 && (this._listeners = {});
      var i = this._listeners;
      i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
    },
    hasEventListener: function(t, e) {
      if (this._listeners === void 0)
        return !1;
      var i = this._listeners;
      return i[t] !== void 0 && i[t].indexOf(e) !== -1;
    },
    removeEventListener: function(t, e) {
      this._listeners !== void 0 && (t = this._listeners[t], t !== void 0 && (e = t.indexOf(e), e !== -1 && t.splice(e, 1)));
    },
    dispatchEvent: function(t) {
      if (this._listeners !== void 0) {
        var e = this._listeners[t.type];
        if (e !== void 0) {
          t.target = this, e = e.slice(0);
          for (var i = 0, n = e.length; i < n; i++)
            e[i].call(this, t);
        }
      }
    }
  });
  var fi = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      for (var t = [], e = 0; 256 > e; e++)
        t[e] = (16 > e ? "0" : "") + e.toString(16);
      return function() {
        var i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, o = 4294967295 * Math.random() | 0, l = 4294967295 * Math.random() | 0;
        return (t[i & 255] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255] + "-" + t[n & 255] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[o & 63 | 128] + t[o >> 8 & 255] + "-" + t[o >> 16 & 255] + t[o >> 24 & 255] + t[l & 255] + t[l >> 8 & 255] + t[l >> 16 & 255] + t[l >> 24 & 255]).toUpperCase();
      };
    }(),
    clamp: function(t, e, i) {
      return Math.max(e, Math.min(i, t));
    },
    euclideanModulo: function(t, e) {
      return (t % e + e) % e;
    },
    mapLinear: function(t, e, i, n, o) {
      return n + (t - e) * (o - n) / (i - e);
    },
    lerp: function(t, e, i) {
      return (1 - i) * t + i * e;
    },
    smoothstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * (3 - 2 * t));
    },
    smootherstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * t * (t * (6 * t - 15) + 10));
    },
    randInt: function(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function(t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function(t) {
      return t * (0.5 - Math.random());
    },
    degToRad: function(t) {
      return t * fi.DEG2RAD;
    },
    radToDeg: function(t) {
      return t * fi.RAD2DEG;
    },
    isPowerOfTwo: function(t) {
      return (t & t - 1) === 0 && t !== 0;
    },
    ceilPowerOfTwo: function(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    },
    floorPowerOfTwo: function(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }
  };
  Object.defineProperties(s.prototype, {
    width: {
      get: function() {
        return this.x;
      },
      set: function(t) {
        this.x = t;
      }
    },
    height: {
      get: function() {
        return this.y;
      },
      set: function(t) {
        this.y = t;
      }
    }
  }), Object.assign(s.prototype, {
    isVector2: !0,
    set: function(t, e) {
      return this.x = t, this.y = e, this;
    },
    setScalar: function(t) {
      return this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    },
    multiply: function(t) {
      return this.x *= t.x, this.y *= t.y, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this;
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    applyMatrix3: function(t) {
      var e = this.x, i = this.y;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this;
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    },
    clampScalar: function() {
      var t = new s(), e = new s();
      return function(i, n) {
        return t.set(i, i), e.set(n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y;
    },
    cross: function(t) {
      return this.x * t.y - this.y * t.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var t = Math.atan2(this.y, this.x);
      return 0 > t && (t += 2 * Math.PI), t;
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x;
      return t = this.y - t.y, e * e + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this;
    },
    rotateAround: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = this.x - t.x, o = this.y - t.y;
      return this.x = n * i - o * e + t.x, this.y = n * e + o * i + t.y, this;
    }
  }), Object.assign(c.prototype, {
    isMatrix4: !0,
    set: function(t, e, i, n, o, l, f, p, y, w, A, P, B, H, q, $) {
      var rt = this.elements;
      return rt[0] = t, rt[4] = e, rt[8] = i, rt[12] = n, rt[1] = o, rt[5] = l, rt[9] = f, rt[13] = p, rt[2] = y, rt[6] = w, rt[10] = A, rt[14] = P, rt[3] = B, rt[7] = H, rt[11] = q, rt[15] = $, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new c().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this;
    },
    copyPosition: function(t) {
      var e = this.elements;
      return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this;
    },
    extractBasis: function(t, e, i) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
    },
    makeBasis: function(t, e, i) {
      return this.set(
        t.x,
        e.x,
        i.x,
        0,
        t.y,
        e.y,
        i.y,
        0,
        t.z,
        e.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    extractRotation: function() {
      var t = new u();
      return function(e) {
        var i = this.elements, n = e.elements, o = 1 / t.setFromMatrixColumn(e, 0).length(), l = 1 / t.setFromMatrixColumn(e, 1).length();
        return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * o, i[1] = n[1] * o, i[2] = n[2] * o, i[3] = 0, i[4] = n[4] * l, i[5] = n[5] * l, i[6] = n[6] * l, i[7] = 0, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
      };
    }(),
    makeRotationFromEuler: function(t) {
      t && t.isEuler || console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
      var e = this.elements, i = t.x, n = t.y, o = t.z, l = Math.cos(i);
      i = Math.sin(i);
      var f = Math.cos(n);
      n = Math.sin(n);
      var p = Math.cos(o);
      if (o = Math.sin(o), t.order === "XYZ") {
        t = l * p;
        var y = l * o, w = i * p, A = i * o;
        e[0] = f * p, e[4] = -f * o, e[8] = n, e[1] = y + w * n, e[5] = t - A * n, e[9] = -i * f, e[2] = A - t * n, e[6] = w + y * n, e[10] = l * f;
      } else
        t.order === "YXZ" ? (t = f * p, y = f * o, w = n * p, A = n * o, e[0] = t + A * i, e[4] = w * i - y, e[8] = l * n, e[1] = l * o, e[5] = l * p, e[9] = -i, e[2] = y * i - w, e[6] = A + t * i, e[10] = l * f) : t.order === "ZXY" ? (t = f * p, y = f * o, w = n * p, A = n * o, e[0] = t - A * i, e[4] = -l * o, e[8] = w + y * i, e[1] = y + w * i, e[5] = l * p, e[9] = A - t * i, e[2] = -l * n, e[6] = i, e[10] = l * f) : t.order === "ZYX" ? (t = l * p, y = l * o, w = i * p, A = i * o, e[0] = f * p, e[4] = w * n - y, e[8] = t * n + A, e[1] = f * o, e[5] = A * n + t, e[9] = y * n - w, e[2] = -n, e[6] = i * f, e[10] = l * f) : t.order === "YZX" ? (t = l * f, y = l * n, w = i * f, A = i * n, e[0] = f * p, e[4] = A - t * o, e[8] = w * o + y, e[1] = o, e[5] = l * p, e[9] = -i * p, e[2] = -n * p, e[6] = y * o + w, e[10] = t - A * o) : t.order === "XZY" && (t = l * f, y = l * n, w = i * f, A = i * n, e[0] = f * p, e[4] = -o, e[8] = n * p, e[1] = t * o + A, e[5] = l * p, e[9] = y * o - w, e[2] = w * o - y, e[6] = i * p, e[10] = A * o + t);
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    },
    makeRotationFromQuaternion: function() {
      var t = new u(0, 0, 0), e = new u(1, 1, 1);
      return function(i) {
        return this.compose(t, i, e);
      };
    }(),
    lookAt: function() {
      var t = new u(), e = new u(), i = new u();
      return function(n, o, l) {
        var f = this.elements;
        return i.subVectors(n, o), i.lengthSq() === 0 && (i.z = 1), i.normalize(), t.crossVectors(l, i), t.lengthSq() === 0 && (Math.abs(l.z) === 1 ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(l, i)), t.normalize(), e.crossVectors(i, t), f[0] = t.x, f[4] = e.x, f[8] = i.x, f[1] = t.y, f[5] = e.y, f[9] = i.y, f[2] = t.z, f[6] = e.z, f[10] = i.z, this;
      };
    }(),
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
      ), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var o = i[4], l = i[8], f = i[12], p = i[1], y = i[5], w = i[9], A = i[13], P = i[2], B = i[6], H = i[10], q = i[14], $ = i[3], rt = i[7], xt = i[11];
      i = i[15];
      var gt = n[0], Ct = n[4], wt = n[8], Vt = n[12], Z = n[1], ot = n[5], zt = n[9], ee = n[13], $t = n[2], qt = n[6], Te = n[10], me = n[14], Ie = n[3], be = n[7], ae = n[11];
      return n = n[15], e[0] = t * gt + o * Z + l * $t + f * Ie, e[4] = t * Ct + o * ot + l * qt + f * be, e[8] = t * wt + o * zt + l * Te + f * ae, e[12] = t * Vt + o * ee + l * me + f * n, e[1] = p * gt + y * Z + w * $t + A * Ie, e[5] = p * Ct + y * ot + w * qt + A * be, e[9] = p * wt + y * zt + w * Te + A * ae, e[13] = p * Vt + y * ee + w * me + A * n, e[2] = P * gt + B * Z + H * $t + q * Ie, e[6] = P * Ct + B * ot + H * qt + q * be, e[10] = P * wt + B * zt + H * Te + q * ae, e[14] = P * Vt + B * ee + H * me + q * n, e[3] = $ * gt + rt * Z + xt * $t + i * Ie, e[7] = $ * Ct + rt * ot + xt * qt + i * be, e[11] = $ * wt + rt * zt + xt * Te + i * ae, e[15] = $ * Vt + rt * ee + xt * me + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    },
    applyToBufferAttribute: function() {
      var t = new u();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    determinant: function() {
      var t = this.elements, e = t[0], i = t[4], n = t[8], o = t[12], l = t[1], f = t[5], p = t[9], y = t[13], w = t[2], A = t[6], P = t[10], B = t[14];
      return t[3] * (+o * p * A - n * y * A - o * f * P + i * y * P + n * f * B - i * p * B) + t[7] * (+e * p * B - e * y * P + o * l * P - n * l * B + n * y * w - o * p * w) + t[11] * (+e * y * A - e * f * B - o * l * A + i * l * B + o * f * w - i * y * w) + t[15] * (-n * f * w - e * p * A + e * f * P + n * l * A - i * l * P + i * p * w);
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    },
    setPosition: function(t) {
      var e = this.elements;
      return e[12] = t.x, e[13] = t.y, e[14] = t.z, this;
    },
    getInverse: function(t, e) {
      var i = this.elements, n = t.elements;
      t = n[0];
      var o = n[1], l = n[2], f = n[3], p = n[4], y = n[5], w = n[6], A = n[7], P = n[8], B = n[9], H = n[10], q = n[11], $ = n[12], rt = n[13], xt = n[14];
      n = n[15];
      var gt = B * xt * A - rt * H * A + rt * w * q - y * xt * q - B * w * n + y * H * n, Ct = $ * H * A - P * xt * A - $ * w * q + p * xt * q + P * w * n - p * H * n, wt = P * rt * A - $ * B * A + $ * y * q - p * rt * q - P * y * n + p * B * n, Vt = $ * B * w - P * rt * w - $ * y * H + p * rt * H + P * y * xt - p * B * xt, Z = t * gt + o * Ct + l * wt + f * Vt;
      if (Z === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / Z, i[0] = gt * e, i[1] = (rt * H * f - B * xt * f - rt * l * q + o * xt * q + B * l * n - o * H * n) * e, i[2] = (y * xt * f - rt * w * f + rt * l * A - o * xt * A - y * l * n + o * w * n) * e, i[3] = (B * w * f - y * H * f - B * l * A + o * H * A + y * l * q - o * w * q) * e, i[4] = Ct * e, i[5] = (P * xt * f - $ * H * f + $ * l * q - t * xt * q - P * l * n + t * H * n) * e, i[6] = ($ * w * f - p * xt * f - $ * l * A + t * xt * A + p * l * n - t * w * n) * e, i[7] = (p * H * f - P * w * f + P * l * A - t * H * A - p * l * q + t * w * q) * e, i[8] = wt * e, i[9] = ($ * B * f - P * rt * f - $ * o * q + t * rt * q + P * o * n - t * B * n) * e, i[10] = (p * rt * f - $ * y * f + $ * o * A - t * rt * A - p * o * n + t * y * n) * e, i[11] = (P * y * f - p * B * f - P * o * A + t * B * A + p * o * q - t * y * q) * e, i[12] = Vt * e, i[13] = (P * rt * l - $ * B * l + $ * o * H - t * rt * H - P * o * xt + t * B * xt) * e, i[14] = ($ * y * l - p * rt * l - $ * o * w + t * rt * w + p * o * xt - t * y * xt) * e, i[15] = (p * B * l - P * y * l + P * o * w - t * B * w - p * o * H + t * y * H) * e, this;
    },
    scale: function(t) {
      var e = this.elements, i = t.x, n = t.y;
      return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this;
    },
    getMaxScaleOnAxis: function() {
      var t = this.elements;
      return Math.sqrt(
        Math.max(
          t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
        )
      );
    },
    makeTranslation: function(t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
    },
    makeRotationX: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = 1 - i, o = t.x, l = t.y;
      t = t.z;
      var f = n * o, p = n * l;
      return this.set(
        f * o + i,
        f * l - e * t,
        f * t + e * l,
        0,
        f * l + e * t,
        p * l + i,
        p * t - e * o,
        0,
        f * t - e * l,
        p * t + e * o,
        n * t * t + i,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    makeScale: function(t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    },
    makeShear: function(t, e, i) {
      return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    },
    compose: function(t, e, i) {
      var n = this.elements, o = e._x, l = e._y, f = e._z, p = e._w, y = o + o, w = l + l, A = f + f;
      e = o * y;
      var P = o * w;
      o *= A;
      var B = l * w;
      l *= A, f *= A, y *= p, w *= p, p *= A, A = i.x;
      var H = i.y;
      return i = i.z, n[0] = (1 - (B + f)) * A, n[1] = (P + p) * A, n[2] = (o - w) * A, n[3] = 0, n[4] = (P - p) * H, n[5] = (1 - (e + f)) * H, n[6] = (l + y) * H, n[7] = 0, n[8] = (o + w) * i, n[9] = (l - y) * i, n[10] = (1 - (e + B)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
    },
    decompose: function() {
      var t = new u(), e = new c();
      return function(i, n, o) {
        var l = this.elements, f = t.set(l[0], l[1], l[2]).length(), p = t.set(l[4], l[5], l[6]).length(), y = t.set(l[8], l[9], l[10]).length();
        0 > this.determinant() && (f = -f), i.x = l[12], i.y = l[13], i.z = l[14], e.copy(this), i = 1 / f, l = 1 / p;
        var w = 1 / y;
        return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= l, e.elements[5] *= l, e.elements[6] *= l, e.elements[8] *= w, e.elements[9] *= w, e.elements[10] *= w, n.setFromRotationMatrix(e), o.x = f, o.y = p, o.z = y, this;
      };
    }(),
    makePerspective: function(t, e, i, n, o, l) {
      l === void 0 && console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
      var f = this.elements;
      return f[0] = 2 * o / (e - t), f[4] = 0, f[8] = (e + t) / (e - t), f[12] = 0, f[1] = 0, f[5] = 2 * o / (i - n), f[9] = (i + n) / (i - n), f[13] = 0, f[2] = 0, f[6] = 0, f[10] = -(l + o) / (l - o), f[14] = -2 * l * o / (l - o), f[3] = 0, f[7] = 0, f[11] = -1, f[15] = 0, this;
    },
    makeOrthographic: function(t, e, i, n, o, l) {
      var f = this.elements, p = 1 / (e - t), y = 1 / (i - n), w = 1 / (l - o);
      return f[0] = 2 * p, f[4] = 0, f[8] = 0, f[12] = -((e + t) * p), f[1] = 0, f[5] = 2 * y, f[9] = 0, f[13] = -((i + n) * y), f[2] = 0, f[6] = 0, f[10] = -2 * w, f[14] = -((l + o) * w), f[3] = 0, f[7] = 0, f[11] = 0, f[15] = 1, this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 16 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 16 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
    }
  }), Object.assign(d, {
    slerp: function(t, e, i, n) {
      return i.copy(t).slerp(e, n);
    },
    slerpFlat: function(t, e, i, n, o, l, f) {
      var p = i[n + 0], y = i[n + 1], w = i[n + 2];
      i = i[n + 3], n = o[l + 0];
      var A = o[l + 1], P = o[l + 2];
      if (o = o[l + 3], i !== o || p !== n || y !== A || w !== P) {
        l = 1 - f;
        var B = p * n + y * A + w * P + i * o, H = 0 <= B ? 1 : -1, q = 1 - B * B;
        q > Number.EPSILON && (q = Math.sqrt(q), B = Math.atan2(q, B * H), l = Math.sin(l * B) / q, f = Math.sin(f * B) / q), H *= f, p = p * l + n * H, y = y * l + A * H, w = w * l + P * H, i = i * l + o * H, l === 1 - f && (f = 1 / Math.sqrt(p * p + y * y + w * w + i * i), p *= f, y *= f, w *= f, i *= f);
      }
      t[e] = p, t[e + 1] = y, t[e + 2] = w, t[e + 3] = i;
    }
  }), Object.defineProperties(d.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(t) {
        this._w = t, this.onChangeCallback();
      }
    }
  }), Object.assign(d.prototype, {
    isQuaternion: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this;
    },
    setFromEuler: function(t, e) {
      if (!t || !t.isEuler)
        throw Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      var i = t._x, n = t._y, o = t._z;
      t = t.order;
      var l = Math.cos, f = Math.sin, p = l(i / 2), y = l(n / 2);
      return l = l(o / 2), i = f(i / 2), n = f(n / 2), o = f(o / 2), t === "XYZ" ? (this._x = i * y * l + p * n * o, this._y = p * n * l - i * y * o, this._z = p * y * o + i * n * l, this._w = p * y * l - i * n * o) : t === "YXZ" ? (this._x = i * y * l + p * n * o, this._y = p * n * l - i * y * o, this._z = p * y * o - i * n * l, this._w = p * y * l + i * n * o) : t === "ZXY" ? (this._x = i * y * l - p * n * o, this._y = p * n * l + i * y * o, this._z = p * y * o + i * n * l, this._w = p * y * l - i * n * o) : t === "ZYX" ? (this._x = i * y * l - p * n * o, this._y = p * n * l + i * y * o, this._z = p * y * o - i * n * l, this._w = p * y * l + i * n * o) : t === "YZX" ? (this._x = i * y * l + p * n * o, this._y = p * n * l + i * y * o, this._z = p * y * o - i * n * l, this._w = p * y * l - i * n * o) : t === "XZY" && (this._x = i * y * l - p * n * o, this._y = p * n * l - i * y * o, this._z = p * y * o + i * n * l, this._w = p * y * l + i * n * o), e !== !1 && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(t, e) {
      e /= 2;
      var i = Math.sin(e);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t) {
      var e = t.elements, i = e[0];
      t = e[4];
      var n = e[8], o = e[1], l = e[5], f = e[9], p = e[2], y = e[6];
      e = e[10];
      var w = i + l + e;
      return 0 < w ? (i = 0.5 / Math.sqrt(w + 1), this._w = 0.25 / i, this._x = (y - f) * i, this._y = (n - p) * i, this._z = (o - t) * i) : i > l && i > e ? (i = 2 * Math.sqrt(1 + i - l - e), this._w = (y - f) / i, this._x = 0.25 * i, this._y = (t + o) / i, this._z = (n + p) / i) : l > e ? (i = 2 * Math.sqrt(1 + l - i - e), this._w = (n - p) / i, this._x = (t + o) / i, this._y = 0.25 * i, this._z = (f + y) / i) : (i = 2 * Math.sqrt(1 + e - i - l), this._w = (o - t) / i, this._x = (n + p) / i, this._y = (f + y) / i, this._z = 0.25 * i), this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
      var t = new u(), e;
      return function(i, n) {
        return t === void 0 && (t = new u()), e = i.dot(n) + 1, 1e-6 > e ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize();
      };
    }(),
    angleTo: function(t) {
      return 2 * Math.acos(Math.abs(fi.clamp(this.dot(t), -1, 1)));
    },
    rotateTowards: function(t, e) {
      var i = this.angleTo(t);
      return i === 0 ? this : (this.slerp(t, Math.min(1, e / i)), this);
    },
    inverse: function() {
      return this.conjugate();
    },
    conjugate: function() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    },
    lengthSq: function() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
      return Math.sqrt(
        this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      );
    },
    normalize: function() {
      var t = this.length();
      return t === 0 ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
      ), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    },
    premultiply: function(t) {
      return this.multiplyQuaternions(t, this);
    },
    multiplyQuaternions: function(t, e) {
      var i = t._x, n = t._y, o = t._z;
      t = t._w;
      var l = e._x, f = e._y, p = e._z;
      return e = e._w, this._x = i * e + t * l + n * p - o * f, this._y = n * e + t * f + o * l - i * p, this._z = o * e + t * p + i * f - n * l, this._w = t * e - i * l - n * f - o * p, this.onChangeCallback(), this;
    },
    slerp: function(t, e) {
      if (e === 0)
        return this;
      if (e === 1)
        return this.copy(t);
      var i = this._x, n = this._y, o = this._z, l = this._w, f = l * t._w + i * t._x + n * t._y + o * t._z;
      if (0 > f ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, f = -f) : this.copy(t), 1 <= f)
        return this._w = l, this._x = i, this._y = n, this._z = o, this;
      if (t = 1 - f * f, t <= Number.EPSILON)
        return f = 1 - e, this._w = f * l + e * this._w, this._x = f * i + e * this._x, this._y = f * n + e * this._y, this._z = f * o + e * this._z, this.normalize();
      t = Math.sqrt(t);
      var p = Math.atan2(t, f);
      return f = Math.sin((1 - e) * p) / t, e = Math.sin(e * p) / t, this._w = l * f + this._w * e, this._x = i * f + this._x * e, this._y = n * f + this._y * e, this._z = o * f + this._z * e, this.onChangeCallback(), this;
    },
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(u.prototype, {
    isVector3: !0,
    set: function(t, e, i) {
      return this.x = t, this.y = e, this.z = i, this;
    },
    setScalar: function(t) {
      return this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
      ), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    },
    multiplyVectors: function(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    },
    applyEuler: function() {
      var t = new d();
      return function(e) {
        return e && e.isEuler || console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ), this.applyQuaternion(t.setFromEuler(e));
      };
    }(),
    applyAxisAngle: function() {
      var t = new d();
      return function(e, i) {
        return this.applyQuaternion(t.setFromAxisAngle(e, i));
      };
    }(),
    applyMatrix3: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z;
      t = t.elements;
      var o = 1 / (t[3] * e + t[7] * i + t[11] * n + t[15]);
      return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * o, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * o, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * o, this;
    },
    applyQuaternion: function(t) {
      var e = this.x, i = this.y, n = this.z, o = t.x, l = t.y, f = t.z;
      t = t.w;
      var p = t * e + l * n - f * i, y = t * i + f * e - o * n, w = t * n + o * i - l * e;
      return e = -o * e - l * i - f * n, this.x = p * t + e * -o + y * -f - w * -l, this.y = y * t + e * -l + w * -o - p * -f, this.z = w * t + e * -f + p * -l - y * -o, this;
    },
    project: function(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    },
    unproject: function() {
      var t = new c();
      return function(e) {
        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(
          e.matrixWorld
        );
      };
    }(),
    transformDirection: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize();
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    },
    clampScalar: function() {
      var t = new u(), e = new u();
      return function(i, n) {
        return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    cross: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
      ), this.crossVectors(t, e)) : this.crossVectors(this, t);
    },
    crossVectors: function(t, e) {
      var i = t.x, n = t.y;
      t = t.z;
      var o = e.x, l = e.y;
      return e = e.z, this.x = n * e - t * l, this.y = t * o - i * e, this.z = i * l - n * o, this;
    },
    projectOnVector: function(t) {
      var e = t.dot(this) / t.lengthSq();
      return this.copy(t).multiplyScalar(e);
    },
    projectOnPlane: function() {
      var t = new u();
      return function(e) {
        return t.copy(this).projectOnVector(e), this.sub(t);
      };
    }(),
    reflect: function() {
      var t = new u();
      return function(e) {
        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
      };
    }(),
    angleTo: function(t) {
      return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(fi.clamp(t, -1, 1));
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x, i = this.y - t.y;
      return t = this.z - t.z, e * e + i * i + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    },
    setFromSpherical: function(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    },
    setFromSphericalCoords: function(t, e, i) {
      var n = Math.sin(e) * t;
      return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
    },
    setFromCylindrical: function(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    },
    setFromCylindricalCoords: function(t, e, i) {
      return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
    },
    setFromMatrixPosition: function(t) {
      return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this;
    },
    setFromMatrixScale: function(t) {
      var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length();
      return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this;
    },
    setFromMatrixColumn: function(t, e) {
      return this.fromArray(t.elements, 4 * e);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
  }), Object.assign(m.prototype, {
    isMatrix3: !0,
    set: function(t, e, i, n, o, l, f, p, y) {
      var w = this.elements;
      return w[0] = t, w[1] = n, w[2] = f, w[3] = e, w[4] = o, w[5] = p, w[6] = i, w[7] = l, w[8] = y, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this;
    },
    setFromMatrix4: function(t) {
      return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    },
    applyToBufferAttribute: function() {
      var t = new u();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    multiply: function(t) {
      return this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var o = i[3], l = i[6], f = i[1], p = i[4], y = i[7], w = i[2], A = i[5];
      i = i[8];
      var P = n[0], B = n[3], H = n[6], q = n[1], $ = n[4], rt = n[7], xt = n[2], gt = n[5];
      return n = n[8], e[0] = t * P + o * q + l * xt, e[3] = t * B + o * $ + l * gt, e[6] = t * H + o * rt + l * n, e[1] = f * P + p * q + y * xt, e[4] = f * B + p * $ + y * gt, e[7] = f * H + p * rt + y * n, e[2] = w * P + A * q + i * xt, e[5] = w * B + A * $ + i * gt, e[8] = w * H + A * rt + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    },
    determinant: function() {
      var t = this.elements, e = t[0], i = t[1], n = t[2], o = t[3], l = t[4], f = t[5], p = t[6], y = t[7];
      return t = t[8], e * l * t - e * f * y - i * o * t + i * f * p + n * o * y - n * l * p;
    },
    getInverse: function(t, e) {
      t && t.isMatrix4 && console.error(
        "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
      );
      var i = t.elements;
      t = this.elements;
      var n = i[0], o = i[1], l = i[2], f = i[3], p = i[4], y = i[5], w = i[6], A = i[7];
      i = i[8];
      var P = i * p - y * A, B = y * w - i * f, H = A * f - p * w, q = n * P + o * B + l * H;
      if (q === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / q, t[0] = P * e, t[1] = (l * A - i * o) * e, t[2] = (y * o - l * p) * e, t[3] = B * e, t[4] = (i * n - l * w) * e, t[5] = (l * f - y * n) * e, t[6] = H * e, t[7] = (o * w - A * n) * e, t[8] = (p * n - o * f) * e, this;
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    },
    getNormalMatrix: function(t) {
      return this.setFromMatrix4(t).getInverse(this).transpose();
    },
    transposeIntoArray: function(t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    },
    setUvTransform: function(t, e, i, n, o, l, f) {
      var p = Math.cos(o);
      o = Math.sin(o), this.set(
        i * p,
        i * o,
        -i * (p * l + o * f) + l + t,
        -n * o,
        n * p,
        -n * (-o * l + p * f) + f + e,
        0,
        0,
        1
      );
    },
    scale: function(t, e) {
      var i = this.elements;
      return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this;
    },
    rotate: function(t) {
      var e = Math.cos(t);
      t = Math.sin(t);
      var i = this.elements, n = i[0], o = i[3], l = i[6], f = i[1], p = i[4], y = i[7];
      return i[0] = e * n + t * f, i[3] = e * o + t * p, i[6] = e * l + t * y, i[1] = -t * n + e * f, i[4] = -t * o + e * p, i[7] = -t * l + e * y, this;
    },
    translate: function(t, e) {
      var i = this.elements;
      return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 9 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 9 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
    }
  });
  var ts = {
    getDataURL: function(t) {
      if (typeof HTMLCanvasElement > "u")
        return t.src;
      if (t instanceof HTMLCanvasElement)
        var e = t;
      else {
        e = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        ), e.width = t.width, e.height = t.height;
        var i = e.getContext("2d");
        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height);
      }
      return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
    }
  }, Is = 0;
  g.DEFAULT_IMAGE = void 0, g.DEFAULT_MAPPING = 300, g.prototype = Object.assign(Object.create(a.prototype), {
    constructor: g,
    isTexture: !0,
    updateMatrix: function() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
    },
    toJSON: function(t) {
      var e = t === void 0 || typeof t == "string";
      if (!e && t.textures[this.uuid] !== void 0)
        return t.textures[this.uuid];
      var i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY
      };
      if (this.image !== void 0) {
        var n = this.image;
        if (n.uuid === void 0 && (n.uuid = fi.generateUUID()), !e && t.images[n.uuid] === void 0) {
          if (Array.isArray(n))
            for (var o = [], l = 0, f = n.length; l < f; l++)
              o.push(ts.getDataURL(n[l]));
          else
            o = ts.getDataURL(n);
          t.images[n.uuid] = { uuid: n.uuid, url: o };
        }
        i.image = n.uuid;
      }
      return e || (t.textures[this.uuid] = i), i;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function(t) {
      if (this.mapping !== 300)
        return t;
      if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x)
        switch (this.wrapS) {
          case 1e3:
            t.x -= Math.floor(t.x);
            break;
          case 1001:
            t.x = 0 > t.x ? 0 : 1;
            break;
          case 1002:
            t.x = Math.abs(Math.floor(t.x) % 2) === 1 ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x);
        }
      if (0 > t.y || 1 < t.y)
        switch (this.wrapT) {
          case 1e3:
            t.y -= Math.floor(t.y);
            break;
          case 1001:
            t.y = 0 > t.y ? 0 : 1;
            break;
          case 1002:
            t.y = Math.abs(Math.floor(t.y) % 2) === 1 ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y);
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
  }), Object.defineProperty(g.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(_.prototype, {
    isVector4: !0,
    set: function(t, e, i, n) {
      return this.x = t, this.y = e, this.z = i, this.w = n, this;
    },
    setScalar: function(t) {
      return this.w = this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setW: function(t) {
      return this.w = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z, o = this.w;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * o, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * o, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * o, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * o, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    setAxisAngleFromQuaternion: function(t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    },
    setAxisAngleFromRotationMatrix: function(t) {
      t = t.elements;
      var e = t[0], i = t[4], n = t[8], o = t[1], l = t[5], f = t[9], p = t[2], y = t[6], w = t[10];
      return 0.01 > Math.abs(i - o) && 0.01 > Math.abs(n - p) && 0.01 > Math.abs(f - y) ? 0.1 > Math.abs(i + o) && 0.1 > Math.abs(n + p) && 0.1 > Math.abs(f + y) && 0.1 > Math.abs(e + l + w - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, e = (e + 1) / 2, l = (l + 1) / 2, w = (w + 1) / 2, i = (i + o) / 4, n = (n + p) / 4, f = (f + y) / 4, e > l && e > w ? 0.01 > e ? (y = 0, i = p = 0.707106781) : (y = Math.sqrt(e), p = i / y, i = n / y) : l > w ? 0.01 > l ? (y = 0.707106781, p = 0, i = 0.707106781) : (p = Math.sqrt(l), y = i / p, i = f / p) : 0.01 > w ? (p = y = 0.707106781, i = 0) : (i = Math.sqrt(w), y = n / i, p = f / i), this.set(y, p, i, t), this) : (t = Math.sqrt((y - f) * (y - f) + (n - p) * (n - p) + (o - i) * (o - i)), 1e-3 > Math.abs(t) && (t = 1), this.x = (y - f) / t, this.y = (n - p) / t, this.z = (o - i) / t, this.w = Math.acos((e + l + w - 1) / 2), this);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    },
    clampScalar: function() {
      var t, e;
      return function(i, n) {
        return t === void 0 && (t = new _(), e = new _()), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
  }), S.prototype = Object.assign(Object.create(a.prototype), {
    constructor: S,
    isWebGLRenderTarget: !0,
    setSize: function(t, e) {
      (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), C.prototype = Object.create(S.prototype), C.prototype.constructor = C, C.prototype.isWebGLRenderTargetCube = !0, O.prototype = Object.create(g.prototype), O.prototype.constructor = O, O.prototype.isDataTexture = !0, Object.assign(k.prototype, {
    isBox3: !0,
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromArray: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, o = -1 / 0, l = -1 / 0, f = -1 / 0, p = 0, y = t.length; p < y; p += 3) {
        var w = t[p], A = t[p + 1], P = t[p + 2];
        w < e && (e = w), A < i && (i = A), P < n && (n = P), w > o && (o = w), A > l && (l = A), P > f && (f = P);
      }
      return this.min.set(e, i, n), this.max.set(o, l, f), this;
    },
    setFromBufferAttribute: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, o = -1 / 0, l = -1 / 0, f = -1 / 0, p = 0, y = t.count; p < y; p++) {
        var w = t.getX(p), A = t.getY(p), P = t.getZ(p);
        w < e && (e = w), A < i && (i = A), P < n && (n = P), w > o && (o = w), A > l && (l = A), P > f && (f = P);
      }
      return this.min.set(e, i, n), this.max.set(o, l, f), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new u();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    setFromObject: function(t) {
      return this.makeEmpty(), this.expandByObject(t);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new u()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), t = new u()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    expandByObject: function() {
      function t(l) {
        var f = l.geometry;
        if (f !== void 0) {
          if (f.isGeometry)
            for (f = f.vertices, i = 0, n = f.length; i < n; i++)
              o.copy(f[i]), o.applyMatrix4(l.matrixWorld), e.expandByPoint(o);
          else if (f.isBufferGeometry && (f = f.attributes.position, f !== void 0))
            for (i = 0, n = f.count; i < n; i++)
              o.fromBufferAttribute(f, i).applyMatrix4(l.matrixWorld), e.expandByPoint(o);
        }
      }
      var e, i, n, o = new u();
      return function(l) {
        return e = this, l.updateMatrixWorld(!0), l.traverse(t), this;
      };
    }(),
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new u()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    },
    intersectsSphere: function() {
      var t = new u();
      return function(e) {
        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius;
      };
    }(),
    intersectsPlane: function(t) {
      if (0 < t.normal.x)
        var e = t.normal.x * this.min.x, i = t.normal.x * this.max.x;
      else
        e = t.normal.x * this.max.x, i = t.normal.x * this.min.x;
      return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
    },
    intersectsTriangle: function() {
      function t(P) {
        var B, H = 0;
        for (B = P.length - 3; H <= B; H += 3) {
          p.fromArray(P, H);
          var q = w.x * Math.abs(p.x) + w.y * Math.abs(p.y) + w.z * Math.abs(p.z), $ = e.dot(p), rt = i.dot(p), xt = n.dot(p);
          if (Math.max(-Math.max($, rt, xt), Math.min($, rt, xt)) > q)
            return !1;
        }
        return !0;
      }
      var e = new u(), i = new u(), n = new u(), o = new u(), l = new u(), f = new u(), p = new u(), y = new u(), w = new u(), A = new u();
      return function(P) {
        return this.isEmpty() || (this.getCenter(y), w.subVectors(this.max, y), e.subVectors(P.a, y), i.subVectors(P.b, y), n.subVectors(P.c, y), o.subVectors(i, e), l.subVectors(n, i), f.subVectors(e, n), P = [
          0,
          -o.z,
          o.y,
          0,
          -l.z,
          l.y,
          0,
          -f.z,
          f.y,
          o.z,
          0,
          -o.x,
          l.z,
          0,
          -l.x,
          f.z,
          0,
          -f.x,
          -o.y,
          o.x,
          0,
          -l.y,
          l.x,
          0,
          -f.y,
          f.x,
          0
        ], !t(P)) || (P = [1, 0, 0, 0, 1, 0, 0, 0, 1], !t(P)) ? !1 : (A.crossVectors(o, l), P = [A.x, A.y, A.z], t(P));
      };
    }(),
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new u()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new u();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    getBoundingSphere: function() {
      var t = new u();
      return function(e) {
        return e === void 0 && (console.warn(
          "THREE.Box3: .getBoundingSphere() target is now required"
        ), e = new D()), this.getCenter(e.center), e.radius = 0.5 * this.getSize(t).length(), e;
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    applyMatrix4: function() {
      var t = [
        new u(),
        new u(),
        new u(),
        new u(),
        new u(),
        new u(),
        new u(),
        new u()
      ];
      return function(e) {
        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this);
      };
    }(),
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(D.prototype, {
    set: function(t, e) {
      return this.center.copy(t), this.radius = e, this;
    },
    setFromPoints: function() {
      var t = new k();
      return function(e, i) {
        var n = this.center;
        i !== void 0 ? n.copy(i) : t.setFromPoints(e).getCenter(n);
        for (var o = i = 0, l = e.length; o < l; o++)
          i = Math.max(i, n.distanceToSquared(e[o]));
        return this.radius = Math.sqrt(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    },
    empty: function() {
      return 0 >= this.radius;
    },
    containsPoint: function(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(t) {
      return t.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    },
    intersectsBox: function(t) {
      return t.intersectsSphere(this);
    },
    intersectsPlane: function(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(t, e) {
      var i = this.center.distanceToSquared(t);
      return e === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new u()), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    },
    getBoundingBox: function(t) {
      return t === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new k()), t.set(this.center, this.center), t.expandByScalar(this.radius), t;
    },
    applyMatrix4: function(t) {
      return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this;
    },
    translate: function(t) {
      return this.center.add(t), this;
    },
    equals: function(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
  }), Object.assign(F.prototype, {
    set: function(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    },
    setComponents: function(t, e, i, n) {
      return this.normal.set(t, e, i), this.constant = n, this;
    },
    setFromNormalAndCoplanarPoint: function(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
      var t = new u(), e = new u();
      return function(i, n, o) {
        return n = t.subVectors(o, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    },
    normalize: function() {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    },
    negate: function() {
      return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(t) {
      return this.normal.dot(t) + this.constant;
    },
    distanceToSphere: function(t) {
      return this.distanceToPoint(t.center) - t.radius;
    },
    projectPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new u()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    },
    intersectLine: function() {
      var t = new u();
      return function(e, i) {
        i === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new u());
        var n = e.delta(t), o = this.normal.dot(n);
        if (o === 0) {
          if (this.distanceToPoint(e.start) === 0)
            return i.copy(e.start);
        } else if (o = -(e.start.dot(this.normal) + this.constant) / o, !(0 > o || 1 < o))
          return i.copy(n).multiplyScalar(o).add(e.start);
      };
    }(),
    intersectsLine: function(t) {
      var e = this.distanceToPoint(t.start);
      return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e;
    },
    intersectsBox: function(t) {
      return t.intersectsPlane(this);
    },
    intersectsSphere: function(t) {
      return t.intersectsPlane(this);
    },
    coplanarPoint: function(t) {
      return t === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new u()), t.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
      var t = new u(), e = new m();
      return function(i, n) {
        return n = n || e.getNormalMatrix(i), i = this.coplanarPoint(t).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this;
      };
    }(),
    translate: function(t) {
      return this.constant -= t.dot(this.normal), this;
    },
    equals: function(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
  }), Object.assign(E.prototype, {
    set: function(t, e, i, n, o, l) {
      var f = this.planes;
      return f[0].copy(t), f[1].copy(e), f[2].copy(i), f[3].copy(n), f[4].copy(o), f[5].copy(l), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        e[i].copy(t.planes[i]);
      return this;
    },
    setFromMatrix: function(t) {
      var e = this.planes, i = t.elements;
      t = i[0];
      var n = i[1], o = i[2], l = i[3], f = i[4], p = i[5], y = i[6], w = i[7], A = i[8], P = i[9], B = i[10], H = i[11], q = i[12], $ = i[13], rt = i[14];
      return i = i[15], e[0].setComponents(l - t, w - f, H - A, i - q).normalize(), e[1].setComponents(l + t, w + f, H + A, i + q).normalize(), e[2].setComponents(l + n, w + p, H + P, i + $).normalize(), e[3].setComponents(l - n, w - p, H - P, i - $).normalize(), e[4].setComponents(l - o, w - y, H - B, i - rt).normalize(), e[5].setComponents(l + o, w + y, H + B, i + rt).normalize(), this;
    },
    intersectsObject: function() {
      var t = new D();
      return function(e) {
        var i = e.geometry;
        return i.boundingSphere === null && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSprite: function() {
      var t = new D();
      return function(e) {
        return t.center.set(0, 0, 0), t.radius = 0.7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSphere: function(t) {
      var e = this.planes, i = t.center;
      t = -t.radius;
      for (var n = 0; 6 > n; n++)
        if (e[n].distanceToPoint(i) < t)
          return !1;
      return !0;
    },
    intersectsBox: function() {
      var t = new u();
      return function(e) {
        for (var i = this.planes, n = 0; 6 > n; n++) {
          var o = i[n];
          if (t.x = 0 < o.normal.x ? e.max.x : e.min.x, t.y = 0 < o.normal.y ? e.max.y : e.min.y, t.z = 0 < o.normal.z ? e.max.z : e.min.z, 0 > o.distanceToPoint(t))
            return !1;
        }
        return !0;
      };
    }(),
    containsPoint: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        if (0 > e[i].distanceToPoint(t))
          return !1;
      return !0;
    }
  });
  var Ei = {
    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif
`,
    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
`,
    alphatest_fragment: `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif
`,
    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif
`,
    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    begin_vertex: `
vec3 transformed = vec3( position );
`,
    beginnormal_vertex: `
vec3 objectNormal = vec3( normal );
`,
    bsdfs: `float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`,
    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif
`,
    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
	}
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;
		}
		if ( clipped ) discard;
	#endif
#endif
`,
    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
		varying vec3 vViewPosition;
	#endif
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif
`,
    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	varying vec3 vViewPosition;
#endif
`,
    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	vViewPosition = - mvPosition.xyz;
#endif
`,
    color_fragment: `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,
    color_pars_fragment: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif
`,
    color_pars_vertex: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,
    color_vertex: `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`,
    common: `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
`,
    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_textureSize (1024.0)
int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}
#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;
	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	float powScale = exp2_packed.x * exp2_packed.y;
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;
	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);
	float rcpPowScale = 1.0 / powScale;
	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}
#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
vec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;
	level0 += min( floor( s + 0.5 ), 5.0 );
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
	vec4 result = mix(color10, color20, t);
	return vec4(result.rgb, 1.0);
}
#endif
`,
    defaultnormal_vertex: `vec3 transformedNormal = normalMatrix * objectNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
`,
    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif
`,
    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
#endif
`,
    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif
`,
    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif
`,
    encodings_fragment: `  gl_FragColor = linearToOutputTexel( gl_FragColor );
`,
    encodings_pars_fragment: `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`,
    envmap_fragment: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToVertex, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		vec2 sampleUV;
		reflectVec = normalize( reflectVec );
		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	envColor = envMapTexelToLinear( envColor );
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif
`,
    envmap_pars_fragment: `#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif
#ifdef USE_ENVMAP
	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif
`,
    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif
`,
    envmap_physical_pars_fragment: `#if defined( USE_ENVMAP ) && defined( PHYSICAL )
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
		#else
			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif
`,
    envmap_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif
`,
    fog_vertex: `#ifdef USE_FOG
	fogDepth = -mvPosition.z;
#endif
`,
    fog_pars_vertex: `#ifdef USE_FOG
	varying float fogDepth;
#endif
`,
    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`,
    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
`,
    gradientmap_pars_fragment: `#ifdef TOON
	uniform sampler2D gradientMap;
	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
		#ifdef USE_GRADIENTMAP
			return texture2D( gradientMap, coord ).rgb;
		#else
			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
		#endif
	}
#endif
`,
    lightmap_fragment: `#ifdef USE_LIGHTMAP
	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
#endif
`,
    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    lights_lambert_vertex: `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
#endif
`,
    lights_pars_begin: `uniform vec3 ambientLightColor;
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif
`,
    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,
    lights_phong_pars_fragment: `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	#ifdef TOON
		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#else
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;
	#endif
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
`,
    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`,
    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	#ifndef STANDARD
		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
	#ifndef STANDARD
		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}
`,
    lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
#endif
#if defined( RE_IndirectDiffuse )
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );
#endif
`,
    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif
#endif
`,
    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
#endif
`,
    logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
#endif
`,
    logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#else
		uniform float logDepthBufFC;
	#endif
#endif
`,
    logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
	#else
		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
		gl_Position.z *= gl_Position.w;
	#endif
#endif
`,
    map_fragment: `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif
`,
    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif
`,
    map_particle_fragment: `#ifdef USE_MAP
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
`,
    map_particle_pars_fragment: `#ifdef USE_MAP
	uniform mat3 uvTransform;
	uniform sampler2D map;
#endif
`,
    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif
`,
    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif
`,
    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
	#endif
#endif
`,
    normal_fragment_begin: `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
#endif
`,
    normal_fragment_maps: `#ifdef USE_NORMALMAP
	#ifdef OBJECTSPACE_NORMALMAP
		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
		#ifdef FLIP_SIDED
			normal = - normal;
		#endif
		#ifdef DOUBLE_SIDED
			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		normal = normalize( normalMatrix * normal );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif
`,
    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	#ifdef OBJECTSPACE_NORMALMAP
		uniform mat3 normalMatrix;
	#else
		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
			vec2 st0 = dFdx( vUv.st );
			vec2 st1 = dFdy( vUv.st );
			float scale = sign( st1.t * st0.s - st0.t * st1.s );
			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
			vec3 N = normalize( surf_norm );
			mat3 tsn = mat3( S, T, N );
			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
			mapN.xy *= normalScale;
			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			return normalize( tsn * mapN );
		}
	#endif
#endif
`,
    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,
    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
`,
    project_vertex: `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
gl_Position = projectionMatrix * mvPosition;
`,
    dithering_fragment: `#if defined( DITHERING )
  gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif
`,
    dithering_pars_fragment: `#if defined( DITHERING )
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif
`,
    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif
`,
    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    shadowmap_pars_fragment: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
		const vec2 offset = vec2( 0.0, 1.0 );
		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
		vec2 f = fract( uv * size + 0.5 );
		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );
		return c;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif
`,
    shadowmap_pars_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
#endif
`,
    shadowmap_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#endif
#endif
`,
    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#endif
	#endif
	return shadow;
}
`,
    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif
`,
    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif
`,
    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif
`,
    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    tonemapping_fragment: `#if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif
`,
    tonemapping_pars_fragment: `#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
`,
    uv_pars_fragment: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
#endif`,
    uv_pars_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
`,
    uv_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
#endif`,
    uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = uv2;
#endif`,
    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
#endif
`,
    background_frag: `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
}
`,
    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position, 1.0 );
	gl_Position.z = 1.0;
}
`,
    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor.a *= opacity;
}
`,
    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}
`,
    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
	#endif
}
`,
    depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
`,
    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}
`,
    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}
`,
    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV;
	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;
	gl_FragColor = texture2D( tEquirect, sampleUV );
}
`,
    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}
`,
    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	vLineDistance = scale * lineDistance;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`,
    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`,
    meshlambert_frag: `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshlambert_vert: `#define LAMBERT
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	vec4 matcapColor = texture2D( matcap, uv );
	matcapColor = matcapTexelToLinear( matcapColor );
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}
`,
    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshphysical_frag: `#define PHYSICAL
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphysical_vert: `#define PHYSICAL
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    normal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}
`,
    normal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	vViewPosition = - mvPosition.xyz;
#endif
}
`,
    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}
`,
    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <fog_fragment>
}
`,
    shadow_vert: `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`
  }, Dn = {
    merge: function(t) {
      for (var e = {}, i = 0; i < t.length; i++) {
        var n = this.clone(t[i]), o;
        for (o in n)
          e[o] = n[o];
      }
      return e;
    },
    clone: function(t) {
      var e = {}, i;
      for (i in t) {
        e[i] = {};
        for (var n in t[i]) {
          var o = t[i][n];
          o && (o.isColor || o.isMatrix3 || o.isMatrix4 || o.isVector2 || o.isVector3 || o.isVector4 || o.isTexture) ? e[i][n] = o.clone() : Array.isArray(o) ? e[i][n] = o.slice() : e[i][n] = o;
        }
      }
      return e;
    }
  }, qr = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Object.assign(L.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function(t) {
      return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this;
    },
    setScalar: function(t) {
      return this.b = this.g = this.r = t, this;
    },
    setHex: function(t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, this;
    },
    setRGB: function(t, e, i) {
      return this.r = t, this.g = e, this.b = i, this;
    },
    setHSL: function() {
      function t(e, i, n) {
        return 0 > n && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (i - e) * n : 0.5 > n ? i : n < 2 / 3 ? e + 6 * (i - e) * (2 / 3 - n) : e;
      }
      return function(e, i, n) {
        return e = fi.euclideanModulo(e, 1), i = fi.clamp(i, 0, 1), n = fi.clamp(n, 0, 1), i === 0 ? this.r = this.g = this.b = n : (i = 0.5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this;
      };
    }(),
    setStyle: function(t) {
      function e(f) {
        f !== void 0 && 1 > parseFloat(f) && console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
      }
      var i;
      if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
        var n = i[2];
        switch (i[1]) {
          case "rgb":
          case "rgba":
            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
            if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
            break;
          case "hsl":
          case "hsla":
            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            )) {
              n = parseFloat(i[1]) / 360;
              var o = parseInt(i[2], 10) / 100, l = parseInt(i[3], 10) / 100;
              return e(i[5]), this.setHSL(n, o, l);
            }
        }
      } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
        if (i = i[1], n = i.length, n === 3)
          return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
        if (n === 6)
          return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this;
      }
      return t && 0 < t.length && (i = qr[t], i !== void 0 ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    },
    copyGammaToLinear: function(t, e) {
      return e === void 0 && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    copyLinearToGamma: function(t, e) {
      return e === void 0 && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    convertGammaToLinear: function(t) {
      return this.copyGammaToLinear(this, t), this;
    },
    convertLinearToGamma: function(t) {
      return this.copyLinearToGamma(this, t), this;
    },
    copySRGBToLinear: function() {
      function t(e) {
        return 0.04045 > e ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    copyLinearToSRGB: function() {
      function t(e) {
        return 31308e-7 > e ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    convertSRGBToLinear: function() {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function() {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(t) {
      t === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });
      var e = this.r, i = this.g, n = this.b, o = Math.max(e, i, n), l = Math.min(e, i, n), f, p = (l + o) / 2;
      if (l === o)
        l = f = 0;
      else {
        var y = o - l;
        switch (l = 0.5 >= p ? y / (o + l) : y / (2 - o - l), o) {
          case e:
            f = (i - n) / y + (i < n ? 6 : 0);
            break;
          case i:
            f = (n - e) / y + 2;
            break;
          case n:
            f = (e - i) / y + 4;
        }
        f /= 6;
      }
      return t.h = f, t.s = l, t.l = p, t;
    },
    getStyle: function() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function() {
      var t = {};
      return function(e, i, n) {
        return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this;
      };
    }(),
    add: function(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    },
    addColors: function(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    },
    addScalar: function(t) {
      return this.r += t, this.g += t, this.b += t, this;
    },
    sub: function(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    },
    multiply: function(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    },
    multiplyScalar: function(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    },
    lerp: function(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    },
    lerpHSL: function() {
      var t = { h: 0, s: 0, l: 0 }, e = { h: 0, s: 0, l: 0 };
      return function(i, n) {
        this.getHSL(t), i.getHSL(e), i = fi.lerp(t.h, e.h, n);
        var o = fi.lerp(t.s, e.s, n);
        return n = fi.lerp(t.l, e.l, n), this.setHSL(i, o, n), this;
      };
    }(),
    equals: function(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  var qe = {
    common: {
      diffuse: { value: new L(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new m() },
      alphaMap: { value: null }
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new s(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new L(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} }
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} }
      }
    },
    points: {
      diffuse: { value: new L(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      uvTransform: { value: new m() }
    },
    sprite: {
      diffuse: { value: new L(15658734) },
      opacity: { value: 1 },
      center: { value: new s(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      uvTransform: { value: new m() }
    }
  }, go = {
    basic: {
      uniforms: Dn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.fog
      ]),
      vertexShader: Ei.meshbasic_vert,
      fragmentShader: Ei.meshbasic_frag
    },
    lambert: {
      uniforms: Dn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.fog,
        qe.lights,
        { emissive: { value: new L(0) } }
      ]),
      vertexShader: Ei.meshlambert_vert,
      fragmentShader: Ei.meshlambert_frag
    },
    phong: {
      uniforms: Dn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.gradientmap,
        qe.fog,
        qe.lights,
        {
          emissive: { value: new L(0) },
          specular: { value: new L(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: Ei.meshphong_vert,
      fragmentShader: Ei.meshphong_frag
    },
    standard: {
      uniforms: Dn.merge([
        qe.common,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.roughnessmap,
        qe.metalnessmap,
        qe.fog,
        qe.lights,
        {
          emissive: { value: new L(0) },
          roughness: { value: 0.5 },
          metalness: { value: 0.5 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: Ei.meshphysical_vert,
      fragmentShader: Ei.meshphysical_frag
    },
    matcap: {
      uniforms: Dn.merge([
        qe.common,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: Ei.meshmatcap_vert,
      fragmentShader: Ei.meshmatcap_frag
    },
    points: {
      uniforms: Dn.merge([qe.points, qe.fog]),
      vertexShader: Ei.points_vert,
      fragmentShader: Ei.points_frag
    },
    dashed: {
      uniforms: Dn.merge([
        qe.common,
        qe.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: Ei.linedashed_vert,
      fragmentShader: Ei.linedashed_frag
    },
    depth: {
      uniforms: Dn.merge([qe.common, qe.displacementmap]),
      vertexShader: Ei.depth_vert,
      fragmentShader: Ei.depth_frag
    },
    normal: {
      uniforms: Dn.merge([
        qe.common,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: Ei.normal_vert,
      fragmentShader: Ei.normal_frag
    },
    sprite: {
      uniforms: Dn.merge([qe.sprite, qe.fog]),
      vertexShader: Ei.sprite_vert,
      fragmentShader: Ei.sprite_frag
    },
    background: {
      uniforms: { uvTransform: { value: new m() }, t2D: { value: null } },
      vertexShader: Ei.background_vert,
      fragmentShader: Ei.background_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: Ei.cube_vert,
      fragmentShader: Ei.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ei.equirect_vert,
      fragmentShader: Ei.equirect_frag
    },
    distanceRGBA: {
      uniforms: Dn.merge([
        qe.common,
        qe.displacementmap,
        {
          referencePosition: { value: new u() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: Ei.distanceRGBA_vert,
      fragmentShader: Ei.distanceRGBA_frag
    },
    shadow: {
      uniforms: Dn.merge([
        qe.lights,
        qe.fog,
        { color: { value: new L(0) }, opacity: { value: 1 } }
      ]),
      vertexShader: Ei.shadow_vert,
      fragmentShader: Ei.shadow_frag
    }
  };
  go.physical = {
    uniforms: Dn.merge([
      go.standard.uniforms,
      { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }
    ]),
    vertexShader: Ei.meshphysical_vert,
    fragmentShader: Ei.meshphysical_frag
  }, Object.assign(R.prototype, {
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
      for (var e = 0, i = t.vertexNormals.length; e < i; e++)
        this.vertexNormals[e] = t.vertexNormals[e].clone();
      for (e = 0, i = t.vertexColors.length; e < i; e++)
        this.vertexColors[e] = t.vertexColors[e].clone();
      return this;
    }
  }), b.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), b.DefaultOrder = "XYZ", Object.defineProperties(b.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(t) {
        this._order = t, this.onChangeCallback();
      }
    }
  }), Object.assign(b.prototype, {
    isEuler: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t, e, i) {
      var n = fi.clamp, o = t.elements;
      t = o[0];
      var l = o[4], f = o[8], p = o[1], y = o[5], w = o[9], A = o[2], P = o[6];
      return o = o[10], e = e || this._order, e === "XYZ" ? (this._y = Math.asin(n(f, -1, 1)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(-w, o), this._z = Math.atan2(-l, t)) : (this._x = Math.atan2(P, y), this._z = 0)) : e === "YXZ" ? (this._x = Math.asin(-n(w, -1, 1)), 0.99999 > Math.abs(w) ? (this._y = Math.atan2(f, o), this._z = Math.atan2(p, y)) : (this._y = Math.atan2(-A, t), this._z = 0)) : e === "ZXY" ? (this._x = Math.asin(n(P, -1, 1)), 0.99999 > Math.abs(P) ? (this._y = Math.atan2(-A, o), this._z = Math.atan2(-l, y)) : (this._y = 0, this._z = Math.atan2(p, t))) : e === "ZYX" ? (this._y = Math.asin(-n(A, -1, 1)), 0.99999 > Math.abs(A) ? (this._x = Math.atan2(P, o), this._z = Math.atan2(p, t)) : (this._x = 0, this._z = Math.atan2(-l, y))) : e === "YZX" ? (this._z = Math.asin(n(p, -1, 1)), 0.99999 > Math.abs(p) ? (this._x = Math.atan2(-w, y), this._y = Math.atan2(-A, t)) : (this._x = 0, this._y = Math.atan2(f, o))) : e === "XZY" ? (this._z = Math.asin(-n(l, -1, 1)), 0.99999 > Math.abs(l) ? (this._x = Math.atan2(P, y), this._y = Math.atan2(f, t)) : (this._x = Math.atan2(-w, o), this._y = 0)) : console.warn(
        "THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e
      ), this._order = e, i !== !1 && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
      var t = new c();
      return function(e, i, n) {
        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n);
      };
    }(),
    setFromVector3: function(t, e) {
      return this.set(t.x, t.y, t.z, e || this._order);
    },
    reorder: function() {
      var t = new d();
      return function(e) {
        return t.setFromEuler(this), this.setFromQuaternion(t, e);
      };
    }(),
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    },
    fromArray: function(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    },
    toVector3: function(t) {
      return t ? t.set(this._x, this._y, this._z) : new u(this._x, this._y, this._z);
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(U.prototype, {
    set: function(t) {
      this.mask = 1 << t | 0;
    },
    enable: function(t) {
      this.mask = this.mask | 1 << t | 0;
    },
    toggle: function(t) {
      this.mask ^= 1 << t | 0;
    },
    disable: function(t) {
      this.mask &= ~(1 << t | 0);
    },
    test: function(t) {
      return (this.mask & t.mask) !== 0;
    }
  });
  var ic = 0;
  N.DefaultUp = new u(0, 1, 0), N.DefaultMatrixAutoUpdate = !0, N.prototype = Object.assign(Object.create(a.prototype), {
    constructor: N,
    isObject3D: !0,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix: function(t) {
      this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(t) {
      return this.quaternion.premultiply(t), this;
    },
    setRotationFromAxisAngle: function(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    },
    setRotationFromEuler: function(t) {
      this.quaternion.setFromEuler(t, !0);
    },
    setRotationFromMatrix: function(t) {
      this.quaternion.setFromRotationMatrix(t);
    },
    setRotationFromQuaternion: function(t) {
      this.quaternion.copy(t);
    },
    rotateOnAxis: function() {
      var t = new d();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this;
      };
    }(),
    rotateOnWorldAxis: function() {
      var t = new d();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this;
      };
    }(),
    rotateX: function() {
      var t = new u(1, 0, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateY: function() {
      var t = new u(0, 1, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateZ: function() {
      var t = new u(0, 0, 1);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    translateOnAxis: function() {
      var t = new u();
      return function(e, i) {
        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this;
      };
    }(),
    translateX: function() {
      var t = new u(1, 0, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateY: function() {
      var t = new u(0, 1, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateZ: function() {
      var t = new u(0, 0, 1);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    localToWorld: function(t) {
      return t.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
      var t = new c();
      return function(e) {
        return e.applyMatrix4(t.getInverse(this.matrixWorld));
      };
    }(),
    lookAt: function() {
      var t = new d(), e = new c(), i = new u(), n = new u();
      return function(o, l, f) {
        o.isVector3 ? i.copy(o) : i.set(o, l, f), o = this.parent, this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), o && (e.extractRotation(o.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()));
      };
    }(),
    add: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.add(arguments[e]);
        return this;
      }
      return t === this ? (console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        t
      ), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error(
        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
        t
      ), this);
    },
    remove: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.remove(arguments[e]);
        return this;
      }
      return e = this.children.indexOf(t), e !== -1 && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(e, 1)), this;
    },
    getObjectById: function(t) {
      return this.getObjectByProperty("id", t);
    },
    getObjectByName: function(t) {
      return this.getObjectByProperty("name", t);
    },
    getObjectByProperty: function(t, e) {
      if (this[t] === e)
        return this;
      for (var i = 0, n = this.children.length; i < n; i++) {
        var o = this.children[i].getObjectByProperty(t, e);
        if (o !== void 0)
          return o;
      }
    },
    getWorldPosition: function(t) {
      return t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldPosition() target is now required"
      ), t = new u()), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
      var t = new u(), e = new u();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldQuaternion() target is now required"
        ), i = new d()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i;
      };
    }(),
    getWorldScale: function() {
      var t = new u(), e = new d();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldScale() target is now required"
        ), i = new u()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i;
      };
    }(),
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldDirection() target is now required"
      ), t = new u()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(t) {
      t(this);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].traverse(t);
    },
    traverseVisible: function(t) {
      if (this.visible !== !1) {
        t(this);
        for (var e = this.children, i = 0, n = e.length; i < n; i++)
          e[i].traverseVisible(t);
      }
    },
    traverseAncestors: function(t) {
      var e = this.parent;
      e !== null && (t(e), e.traverseAncestors(t));
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), this.matrixWorldNeedsUpdate = !1, t = !0);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].updateMatrixWorld(t);
    },
    updateWorldMatrix: function(t, e) {
      var i = this.parent;
      if (t === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), e === !0)
        for (t = this.children, e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0);
    },
    toJSON: function(t) {
      function e(A, P) {
        return A[P.uuid] === void 0 && (A[P.uuid] = P.toJSON(t)), P.uuid;
      }
      function i(A) {
        var P = [], B;
        for (B in A) {
          var H = A[B];
          delete H.metadata, P.push(H);
        }
        return P;
      }
      var n = t === void 0 || typeof t == "string", o = {};
      n && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      }, o.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var l = {};
      if (l.uuid = this.uuid, l.type = this.type, this.name !== "" && (l.name = this.name), this.castShadow === !0 && (l.castShadow = !0), this.receiveShadow === !0 && (l.receiveShadow = !0), this.visible === !1 && (l.visible = !1), this.frustumCulled === !1 && (l.frustumCulled = !1), this.renderOrder !== 0 && (l.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (l.userData = this.userData), l.layers = this.layers.mask, l.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (l.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
        l.geometry = e(t.geometries, this.geometry);
        var f = this.geometry.parameters;
        if (f !== void 0 && f.shapes !== void 0)
          if (f = f.shapes, Array.isArray(f))
            for (var p = 0, y = f.length; p < y; p++)
              e(t.shapes, f[p]);
          else
            e(t.shapes, f);
      }
      if (this.material !== void 0)
        if (Array.isArray(this.material)) {
          for (f = [], p = 0, y = this.material.length; p < y; p++)
            f.push(e(t.materials, this.material[p]));
          l.material = f;
        } else
          l.material = e(t.materials, this.material);
      if (0 < this.children.length)
        for (l.children = [], p = 0; p < this.children.length; p++)
          l.children.push(this.children[p].toJSON(t).object);
      if (n) {
        n = i(t.geometries), p = i(t.materials), y = i(t.textures);
        var w = i(t.images);
        f = i(t.shapes), 0 < n.length && (o.geometries = n), 0 < p.length && (o.materials = p), 0 < y.length && (o.textures = y), 0 < w.length && (o.images = w), 0 < f.length && (o.shapes = f);
      }
      return o.object = l, o;
    },
    clone: function(t) {
      return new this.constructor().copy(this, t);
    },
    copy: function(t, e) {
      if (e === void 0 && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
        for (e = 0; e < t.children.length; e++)
          this.add(t.children[e].clone());
      return this;
    }
  });
  var nc = 0;
  j.prototype = Object.assign(Object.create(a.prototype), {
    constructor: j,
    isGeometry: !0,
    applyMatrix: function(t) {
      for (var e = new m().getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++)
        this.vertices[i].applyMatrix4(t);
      for (i = 0, n = this.faces.length; i < n; i++) {
        t = this.faces[i], t.normal.applyMatrix3(e).normalize();
        for (var o = 0, l = t.vertexNormals.length; o < l; o++)
          t.vertexNormals[o].applyMatrix3(e).normalize();
      }
      return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
    },
    rotateX: function() {
      var t = new c();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new c();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new c();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new c();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new c();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new N();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    fromBufferGeometry: function(t) {
      function e(q, $, rt, xt) {
        var gt = p === void 0 ? [] : [i.colors[q].clone(), i.colors[$].clone(), i.colors[rt].clone()], Ct = f === void 0 ? [] : [
          new u().fromArray(f, 3 * q),
          new u().fromArray(f, 3 * $),
          new u().fromArray(f, 3 * rt)
        ];
        xt = new R(q, $, rt, Ct, gt, xt), i.faces.push(xt), y !== void 0 && i.faceVertexUvs[0].push([
          new s().fromArray(y, 2 * q),
          new s().fromArray(y, 2 * $),
          new s().fromArray(y, 2 * rt)
        ]), w !== void 0 && i.faceVertexUvs[1].push([
          new s().fromArray(w, 2 * q),
          new s().fromArray(w, 2 * $),
          new s().fromArray(w, 2 * rt)
        ]);
      }
      var i = this, n = t.index !== null ? t.index.array : void 0, o = t.attributes, l = o.position.array, f = o.normal !== void 0 ? o.normal.array : void 0, p = o.color !== void 0 ? o.color.array : void 0, y = o.uv !== void 0 ? o.uv.array : void 0, w = o.uv2 !== void 0 ? o.uv2.array : void 0;
      w !== void 0 && (this.faceVertexUvs[1] = []);
      for (var A = o = 0; o < l.length; o += 3, A += 2)
        i.vertices.push(new u().fromArray(l, o)), p !== void 0 && i.colors.push(new L().fromArray(p, o));
      var P = t.groups;
      if (0 < P.length)
        for (o = 0; o < P.length; o++) {
          l = P[o];
          var B = l.start, H = l.count;
          for (A = B, B += H; A < B; A += 3)
            n !== void 0 ? e(n[A], n[A + 1], n[A + 2], l.materialIndex) : e(A, A + 1, A + 2, l.materialIndex);
        }
      else if (n !== void 0)
        for (o = 0; o < n.length; o += 3)
          e(n[o], n[o + 1], n[o + 2]);
      else
        for (o = 0; o < l.length / 3; o += 3)
          e(o, o + 1, o + 2);
      return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
    },
    center: function() {
      var t = new u();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    normalize: function() {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center, e = this.boundingSphere.radius;
      e = e === 0 ? 1 : 1 / e;
      var i = new c();
      return i.set(
        e,
        0,
        0,
        -e * t.x,
        0,
        e,
        0,
        -e * t.y,
        0,
        0,
        e,
        -e * t.z,
        0,
        0,
        0,
        1
      ), this.applyMatrix(i), this;
    },
    computeFaceNormals: function() {
      for (var t = new u(), e = new u(), i = 0, n = this.faces.length; i < n; i++) {
        var o = this.faces[i], l = this.vertices[o.a], f = this.vertices[o.b];
        t.subVectors(this.vertices[o.c], f), e.subVectors(l, f), t.cross(e), t.normalize(), o.normal.copy(t);
      }
    },
    computeVertexNormals: function(t) {
      t === void 0 && (t = !0);
      var e, i = Array(this.vertices.length), n = 0;
      for (e = this.vertices.length; n < e; n++)
        i[n] = new u();
      if (t) {
        var o = new u(), l = new u();
        for (t = 0, n = this.faces.length; t < n; t++) {
          e = this.faces[t];
          var f = this.vertices[e.a], p = this.vertices[e.b], y = this.vertices[e.c];
          o.subVectors(y, p), l.subVectors(f, p), o.cross(l), i[e.a].add(o), i[e.b].add(o), i[e.c].add(o);
        }
      } else
        for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++)
          e = this.faces[t], i[e.a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal);
      for (n = 0, e = this.vertices.length; n < e; n++)
        i[n].normalize();
      for (t = 0, n = this.faces.length; t < n; t++)
        e = this.faces[t], f = e.vertexNormals, f.length === 3 ? (f[0].copy(i[e.a]), f[1].copy(i[e.b]), f[2].copy(i[e.c])) : (f[0] = i[e.a].clone(), f[1] = i[e.b].clone(), f[2] = i[e.c].clone());
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function() {
      var t;
      this.computeFaceNormals();
      var e = 0;
      for (t = this.faces.length; e < t; e++) {
        var i = this.faces[e], n = i.vertexNormals;
        n.length === 3 ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone());
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function() {
      var t, e, i = 0;
      for (e = this.faces.length; i < e; i++) {
        var n = this.faces[i];
        n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
        var o = 0;
        for (t = n.vertexNormals.length; o < t; o++)
          n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone();
      }
      var l = new j();
      for (l.faces = this.faces, o = 0, t = this.morphTargets.length; o < t; o++) {
        if (!this.morphNormals[o]) {
          this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
          var f = this.morphNormals[o].vertexNormals;
          for (i = 0, e = this.faces.length; i < e; i++) {
            var p = new u(), y = { a: new u(), b: new u(), c: new u() };
            n.push(p), f.push(y);
          }
        }
        for (f = this.morphNormals[o], l.vertices = this.morphTargets[o].vertices, l.computeFaceNormals(), l.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++)
          n = this.faces[i], p = f.faceNormals[i], y = f.vertexNormals[i], p.copy(n.normal), y.a.copy(n.vertexNormals[0]), y.b.copy(n.vertexNormals[1]), y.c.copy(n.vertexNormals[2]);
      }
      for (i = 0, e = this.faces.length; i < e; i++)
        n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new k()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      this.boundingSphere === null && (this.boundingSphere = new D()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(t, e, i) {
      if (t && t.isGeometry) {
        var n, o = this.vertices.length, l = this.vertices, f = t.vertices, p = this.faces, y = t.faces, w = this.faceVertexUvs[0], A = t.faceVertexUvs[0], P = this.colors, B = t.colors;
        i === void 0 && (i = 0), e !== void 0 && (n = new m().getNormalMatrix(e)), t = 0;
        for (var H = f.length; t < H; t++) {
          var q = f[t].clone();
          e !== void 0 && q.applyMatrix4(e), l.push(q);
        }
        for (t = 0, H = B.length; t < H; t++)
          P.push(B[t].clone());
        for (t = 0, H = y.length; t < H; t++) {
          f = y[t];
          var $ = f.vertexNormals;
          for (B = f.vertexColors, P = new R(f.a + o, f.b + o, f.c + o), P.normal.copy(f.normal), n !== void 0 && P.normal.applyMatrix3(n).normalize(), e = 0, l = $.length; e < l; e++)
            q = $[e].clone(), n !== void 0 && q.applyMatrix3(n).normalize(), P.vertexNormals.push(q);
          for (P.color.copy(f.color), e = 0, l = B.length; e < l; e++)
            q = B[e], P.vertexColors.push(q.clone());
          P.materialIndex = f.materialIndex + i, p.push(P);
        }
        for (t = 0, H = A.length; t < H; t++)
          if (i = A[t], n = [], i !== void 0) {
            for (e = 0, l = i.length; e < l; e++)
              n.push(i[e].clone());
            w.push(n);
          }
      } else
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          t
        );
    },
    mergeMesh: function(t) {
      t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error(
        "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
        t
      );
    },
    mergeVertices: function() {
      var t = {}, e = [], i = [], n = Math.pow(10, 4), o, l = 0;
      for (o = this.vertices.length; l < o; l++) {
        var f = this.vertices[l];
        f = Math.round(f.x * n) + "_" + Math.round(f.y * n) + "_" + Math.round(f.z * n), t[f] === void 0 ? (t[f] = l, e.push(this.vertices[l]), i[l] = e.length - 1) : i[l] = i[t[f]];
      }
      for (t = [], l = 0, o = this.faces.length; l < o; l++)
        for (n = this.faces[l], n.a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], f = 0; 3 > f; f++)
          if (n[f] === n[(f + 1) % 3]) {
            t.push(l);
            break;
          }
      for (l = t.length - 1; 0 <= l; l--)
        for (n = t[l], this.faces.splice(n, 1), i = 0, o = this.faceVertexUvs.length; i < o; i++)
          this.faceVertexUvs[i].splice(n, 1);
      return l = this.vertices.length - e.length, this.vertices = e, l;
    },
    setFromPoints: function(t) {
      this.vertices = [];
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.vertices.push(new u(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++)
        t[i]._id = i;
      t.sort(function(y, w) {
        return y.materialIndex - w.materialIndex;
      });
      var n = this.faceVertexUvs[0], o = this.faceVertexUvs[1], l, f;
      for (n && n.length === e && (l = []), o && o.length === e && (f = []), i = 0; i < e; i++) {
        var p = t[i]._id;
        l && l.push(n[p]), f && f.push(o[p]);
      }
      l && (this.faceVertexUvs[0] = l), f && (this.faceVertexUvs[1] = f);
    },
    toJSON: function() {
      function t(Vt, Z, ot) {
        return ot ? Vt | 1 << Z : Vt & ~(1 << Z);
      }
      function e(Vt) {
        var Z = Vt.x.toString() + Vt.y.toString() + Vt.z.toString();
        return w[Z] !== void 0 || (w[Z] = y.length / 3, y.push(Vt.x, Vt.y, Vt.z)), w[Z];
      }
      function i(Vt) {
        var Z = Vt.r.toString() + Vt.g.toString() + Vt.b.toString();
        return P[Z] !== void 0 || (P[Z] = A.length, A.push(Vt.getHex())), P[Z];
      }
      function n(Vt) {
        var Z = Vt.x.toString() + Vt.y.toString();
        return H[Z] !== void 0 || (H[Z] = B.length / 2, B.push(Vt.x, Vt.y)), H[Z];
      }
      var o = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      if (o.uuid = this.uuid, o.type = this.type, this.name !== "" && (o.name = this.name), this.parameters !== void 0) {
        var l = this.parameters, f;
        for (f in l)
          l[f] !== void 0 && (o[f] = l[f]);
        return o;
      }
      for (l = [], f = 0; f < this.vertices.length; f++) {
        var p = this.vertices[f];
        l.push(p.x, p.y, p.z);
      }
      p = [];
      var y = [], w = {}, A = [], P = {}, B = [], H = {};
      for (f = 0; f < this.faces.length; f++) {
        var q = this.faces[f], $ = this.faceVertexUvs[0][f] !== void 0, rt = 0 < q.normal.length(), xt = 0 < q.vertexNormals.length, gt = q.color.r !== 1 || q.color.g !== 1 || q.color.b !== 1, Ct = 0 < q.vertexColors.length, wt = 0;
        wt = t(wt, 0, 0), wt = t(wt, 1, !0), wt = t(wt, 2, !1), wt = t(wt, 3, $), wt = t(wt, 4, rt), wt = t(wt, 5, xt), wt = t(wt, 6, gt), wt = t(wt, 7, Ct), p.push(wt), p.push(q.a, q.b, q.c), p.push(q.materialIndex), $ && ($ = this.faceVertexUvs[0][f], p.push(n($[0]), n($[1]), n($[2]))), rt && p.push(e(q.normal)), xt && (rt = q.vertexNormals, p.push(e(rt[0]), e(rt[1]), e(rt[2]))), gt && p.push(i(q.color)), Ct && (q = q.vertexColors, p.push(i(q[0]), i(q[1]), i(q[2])));
      }
      return o.data = {}, o.data.vertices = l, o.data.normals = y, 0 < A.length && (o.data.colors = A), 0 < B.length && (o.data.uvs = [B]), o.data.faces = p, o;
    },
    clone: function() {
      return new j().copy(this);
    },
    copy: function(t) {
      var e, i, n;
      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var o = t.vertices, l = 0;
      for (e = o.length; l < e; l++)
        this.vertices.push(o[l].clone());
      for (o = t.colors, l = 0, e = o.length; l < e; l++)
        this.colors.push(o[l].clone());
      for (o = t.faces, l = 0, e = o.length; l < e; l++)
        this.faces.push(o[l].clone());
      for (l = 0, e = t.faceVertexUvs.length; l < e; l++) {
        var f = t.faceVertexUvs[l];
        for (this.faceVertexUvs[l] === void 0 && (this.faceVertexUvs[l] = []), o = 0, i = f.length; o < i; o++) {
          var p = f[o], y = [], w = 0;
          for (n = p.length; w < n; w++)
            y.push(p[w].clone());
          this.faceVertexUvs[l].push(y);
        }
      }
      for (w = t.morphTargets, l = 0, e = w.length; l < e; l++) {
        if (n = {}, n.name = w[l].name, w[l].vertices !== void 0)
          for (n.vertices = [], o = 0, i = w[l].vertices.length; o < i; o++)
            n.vertices.push(w[l].vertices[o].clone());
        if (w[l].normals !== void 0)
          for (n.normals = [], o = 0, i = w[l].normals.length; o < i; o++)
            n.normals.push(w[l].normals[o].clone());
        this.morphTargets.push(n);
      }
      for (w = t.morphNormals, l = 0, e = w.length; l < e; l++) {
        if (n = {}, w[l].vertexNormals !== void 0)
          for (n.vertexNormals = [], o = 0, i = w[l].vertexNormals.length; o < i; o++)
            f = w[l].vertexNormals[o], p = {}, p.a = f.a.clone(), p.b = f.b.clone(), p.c = f.c.clone(), n.vertexNormals.push(p);
        if (w[l].faceNormals !== void 0)
          for (n.faceNormals = [], o = 0, i = w[l].faceNormals.length; o < i; o++)
            n.faceNormals.push(w[l].faceNormals[o].clone());
        this.morphNormals.push(n);
      }
      for (o = t.skinWeights, l = 0, e = o.length; l < e; l++)
        this.skinWeights.push(o[l].clone());
      for (o = t.skinIndices, l = 0, e = o.length; l < e; l++)
        this.skinIndices.push(o[l].clone());
      for (o = t.lineDistances, l = 0, e = o.length; l < e; l++)
        this.lineDistances.push(o[l]);
      return l = t.boundingBox, l !== null && (this.boundingBox = l.clone()), l = t.boundingSphere, l !== null && (this.boundingSphere = l.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Object.defineProperty(J.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(J.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.itemSize : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.itemSize, i *= e.itemSize;
      for (var n = 0, o = this.itemSize; n < o; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    copyArray: function(t) {
      return this.array.set(t), this;
    },
    copyColorsArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var l = t[n];
        l === void 0 && (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          n
        ), l = new L()), e[i++] = l.r, e[i++] = l.g, e[i++] = l.b;
      }
      return this;
    },
    copyVector2sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var l = t[n];
        l === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          n
        ), l = new s()), e[i++] = l.x, e[i++] = l.y;
      }
      return this;
    },
    copyVector3sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var l = t[n];
        l === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          n
        ), l = new u()), e[i++] = l.x, e[i++] = l.y, e[i++] = l.z;
      }
      return this;
    },
    copyVector4sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var l = t[n];
        l === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          n
        ), l = new _()), e[i++] = l.x, e[i++] = l.y, e[i++] = l.z, e[i++] = l.w;
      }
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    getX: function(t) {
      return this.array[t * this.itemSize];
    },
    setX: function(t, e) {
      return this.array[t * this.itemSize] = e, this;
    },
    getY: function(t) {
      return this.array[t * this.itemSize + 1];
    },
    setY: function(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    },
    getZ: function(t) {
      return this.array[t * this.itemSize + 2];
    },
    setZ: function(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    },
    getW: function(t) {
      return this.array[t * this.itemSize + 3];
    },
    setW: function(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    },
    setXY: function(t, e, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, o) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = o, this;
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }), K.prototype = Object.create(J.prototype), K.prototype.constructor = K, ct.prototype = Object.create(J.prototype), ct.prototype.constructor = ct, It.prototype = Object.create(J.prototype), It.prototype.constructor = It, et.prototype = Object.create(J.prototype), et.prototype.constructor = et, _t.prototype = Object.create(J.prototype), _t.prototype.constructor = _t, G.prototype = Object.create(J.prototype), G.prototype.constructor = G, Pt.prototype = Object.create(J.prototype), Pt.prototype.constructor = Pt, Et.prototype = Object.create(J.prototype), Et.prototype.constructor = Et, At.prototype = Object.create(J.prototype), At.prototype.constructor = At, Object.assign(fe.prototype, {
    computeGroups: function(t) {
      var e = [], i = void 0;
      t = t.faces;
      for (var n = 0; n < t.length; n++) {
        var o = t[n];
        if (o.materialIndex !== i) {
          i = o.materialIndex, l !== void 0 && (l.count = 3 * n - l.start, e.push(l));
          var l = { start: 3 * n, materialIndex: i };
        }
      }
      l !== void 0 && (l.count = 3 * n - l.start, e.push(l)), this.groups = e;
    },
    fromGeometry: function(t) {
      var e = t.faces, i = t.vertices, n = t.faceVertexUvs, o = n[0] && 0 < n[0].length, l = n[1] && 0 < n[1].length, f = t.morphTargets, p = f.length;
      if (0 < p) {
        for (var y = [], w = 0; w < p; w++)
          y[w] = { name: f[w].name, data: [] };
        this.morphTargets.position = y;
      }
      var A = t.morphNormals, P = A.length;
      if (0 < P) {
        var B = [];
        for (w = 0; w < P; w++)
          B[w] = { name: A[w].name, data: [] };
        this.morphTargets.normal = B;
      }
      var H = t.skinIndices, q = t.skinWeights, $ = H.length === i.length, rt = q.length === i.length;
      for (0 < i.length && e.length === 0 && console.error(
        "THREE.DirectGeometry: Faceless geometries are not supported."
      ), w = 0; w < e.length; w++) {
        var xt = e[w];
        this.vertices.push(i[xt.a], i[xt.b], i[xt.c]);
        var gt = xt.vertexNormals;
        for (gt.length === 3 ? this.normals.push(gt[0], gt[1], gt[2]) : (gt = xt.normal, this.normals.push(gt, gt, gt)), gt = xt.vertexColors, gt.length === 3 ? this.colors.push(gt[0], gt[1], gt[2]) : (gt = xt.color, this.colors.push(gt, gt, gt)), o === !0 && (gt = n[0][w], gt !== void 0 ? this.uvs.push(gt[0], gt[1], gt[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
          w
        ), this.uvs.push(new s(), new s(), new s()))), l === !0 && (gt = n[1][w], gt !== void 0 ? this.uvs2.push(gt[0], gt[1], gt[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
          w
        ), this.uvs2.push(new s(), new s(), new s()))), gt = 0; gt < p; gt++) {
          var Ct = f[gt].vertices;
          y[gt].data.push(Ct[xt.a], Ct[xt.b], Ct[xt.c]);
        }
        for (gt = 0; gt < P; gt++)
          Ct = A[gt].vertexNormals[w], B[gt].data.push(Ct.a, Ct.b, Ct.c);
        $ && this.skinIndices.push(H[xt.a], H[xt.b], H[xt.c]), rt && this.skinWeights.push(q[xt.a], q[xt.b], q[xt.c]);
      }
      return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    }
  });
  var rc = 1;
  Ft.prototype = Object.assign(Object.create(a.prototype), {
    constructor: Ft,
    isBufferGeometry: !0,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(t) {
      Array.isArray(t) ? this.index = new (65535 < re(t) ? Pt : _t)(t, 1) : this.index = t;
    },
    addAttribute: function(t, e, i) {
      return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? t === "index" ? (console.warn(
        "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
      ), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn(
        "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
      ), this.addAttribute(t, new J(e, i)));
    },
    getAttribute: function(t) {
      return this.attributes[t];
    },
    removeAttribute: function(t) {
      return delete this.attributes[t], this;
    },
    addGroup: function(t, e, i) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: i !== void 0 ? i : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    },
    applyMatrix: function(t) {
      var e = this.attributes.position;
      return e !== void 0 && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, e !== void 0 && (new m().getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    },
    rotateX: function() {
      var t = new c();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new c();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new c();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new c();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new c();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new N();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    center: function() {
      var t = new u();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    setFromObject: function(t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        t = new Et(3 * e.vertices.length, 3);
        var i = new Et(3 * e.colors.length, 3);
        this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new Et(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
      } else
        t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function(t) {
      for (var e = [], i = 0, n = t.length; i < n; i++) {
        var o = t[i];
        e.push(o.x, o.y, o.z || 0);
      }
      return this.addAttribute("position", new Et(e, 3)), this;
    },
    updateFromObject: function(t) {
      var e = t.geometry;
      if (t.isMesh) {
        var i = e.__directGeometry;
        if (e.elementsNeedUpdate === !0 && (i = void 0, e.elementsNeedUpdate = !1), i === void 0)
          return this.fromGeometry(e);
        i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i;
      }
      return e.verticesNeedUpdate === !0 && (i = this.attributes.position, i !== void 0 && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), e.normalsNeedUpdate === !0 && (i = this.attributes.normal, i !== void 0 && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), e.colorsNeedUpdate === !0 && (i = this.attributes.color, i !== void 0 && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, i !== void 0 && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, i !== void 0 && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
    },
    fromGeometry: function(t) {
      return t.__directGeometry = new fe().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
    },
    fromDirectGeometry: function(t) {
      var e = new Float32Array(3 * t.vertices.length);
      this.addAttribute("position", new J(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new J(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new J(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new J(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new J(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups;
      for (var i in t.morphTargets) {
        e = [];
        for (var n = t.morphTargets[i], o = 0, l = n.length; o < l; o++) {
          var f = n[o], p = new Et(3 * f.data.length, 3);
          p.name = f.name, e.push(p.copyVector3sArray(f.data));
        }
        this.morphAttributes[i] = e;
      }
      return 0 < t.skinIndices.length && (i = new Et(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new Et(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new k());
      var t = this.attributes.position;
      t !== void 0 ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error(
        'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
    },
    computeBoundingSphere: function() {
      var t = new k(), e = new u();
      return function() {
        this.boundingSphere === null && (this.boundingSphere = new D());
        var i = this.attributes.position;
        if (i) {
          var n = this.boundingSphere.center;
          t.setFromBufferAttribute(i), t.getCenter(n);
          for (var o = 0, l = 0, f = i.count; l < f; l++)
            e.x = i.getX(l), e.y = i.getY(l), e.z = i.getZ(l), o = Math.max(o, n.distanceToSquared(e));
          this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
        }
      };
    }(),
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
      var t = this.index, e = this.attributes;
      if (e.position) {
        var i = e.position.array;
        if (e.normal === void 0)
          this.addAttribute("normal", new J(new Float32Array(i.length), 3));
        else
          for (var n = e.normal.array, o = 0, l = n.length; o < l; o++)
            n[o] = 0;
        n = e.normal.array;
        var f = new u(), p = new u(), y = new u(), w = new u(), A = new u();
        if (t) {
          var P = t.array;
          for (o = 0, l = t.count; o < l; o += 3) {
            t = 3 * P[o + 0];
            var B = 3 * P[o + 1], H = 3 * P[o + 2];
            f.fromArray(i, t), p.fromArray(i, B), y.fromArray(i, H), w.subVectors(y, p), A.subVectors(f, p), w.cross(A), n[t] += w.x, n[t + 1] += w.y, n[t + 2] += w.z, n[B] += w.x, n[B + 1] += w.y, n[B + 2] += w.z, n[H] += w.x, n[H + 1] += w.y, n[H + 2] += w.z;
          }
        } else
          for (o = 0, l = i.length; o < l; o += 9)
            f.fromArray(i, o), p.fromArray(i, o + 3), y.fromArray(i, o + 6), w.subVectors(y, p), A.subVectors(f, p), w.cross(A), n[o] = w.x, n[o + 1] = w.y, n[o + 2] = w.z, n[o + 3] = w.x, n[o + 4] = w.y, n[o + 5] = w.z, n[o + 6] = w.x, n[o + 7] = w.y, n[o + 8] = w.z;
        this.normalizeNormals(), e.normal.needsUpdate = !0;
      }
    },
    merge: function(t, e) {
      if (t && t.isBufferGeometry) {
        e === void 0 && (e = 0, console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
        var i = this.attributes, n;
        for (n in i)
          if (t.attributes[n] !== void 0) {
            var o = i[n].array, l = t.attributes[n], f = l.array, p = 0;
            for (l = l.itemSize * e; p < f.length; p++, l++)
              o[l] = f[p];
          }
        return this;
      }
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
    },
    normalizeNormals: function() {
      var t = new u();
      return function() {
        for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z);
      };
    }(),
    toNonIndexed: function() {
      if (this.index === null)
        return console.warn(
          "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
        ), this;
      var t = new Ft(), e = this.index.array, i = this.attributes, n;
      for (n in i) {
        var o = i[n], l = o.array, f = o.itemSize, p = new l.constructor(e.length * f), y = 0;
        o = 0;
        for (var w = e.length; o < w; o++)
          for (var A = e[o] * f, P = 0; P < f; P++)
            p[y++] = l[A++];
        t.addAttribute(n, new J(p, f));
      }
      for (e = this.groups, o = 0, w = e.length; o < w; o++)
        i = e[o], t.addGroup(i.start, i.count, i.materialIndex);
      return t;
    },
    toJSON: function() {
      var t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), this.parameters !== void 0) {
        var e = this.parameters;
        for (o in e)
          e[o] !== void 0 && (t[o] = e[o]);
        return t;
      }
      t.data = { attributes: {} };
      var i = this.index;
      i !== null && (e = Array.prototype.slice.call(i.array), t.data.index = { type: i.array.constructor.name, array: e }), i = this.attributes;
      for (o in i) {
        var n = i[o];
        e = Array.prototype.slice.call(n.array), t.data.attributes[o] = {
          itemSize: n.itemSize,
          type: n.array.constructor.name,
          array: e,
          normalized: n.normalized
        };
      }
      var o = this.groups;
      return 0 < o.length && (t.data.groups = JSON.parse(JSON.stringify(o))), o = this.boundingSphere, o !== null && (t.data.boundingSphere = {
        center: o.center.toArray(),
        radius: o.radius
      }), t;
    },
    clone: function() {
      return new Ft().copy(this);
    },
    copy: function(t) {
      var e;
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var i = t.index;
      i !== null && this.setIndex(i.clone()), i = t.attributes;
      for (f in i)
        this.addAttribute(f, i[f].clone());
      var n = t.morphAttributes;
      for (f in n) {
        var o = [], l = n[f];
        for (i = 0, e = l.length; i < e; i++)
          o.push(l[i].clone());
        this.morphAttributes[f] = o;
      }
      var f = t.groups;
      for (i = 0, e = f.length; i < e; i++)
        n = f[i], this.addGroup(n.start, n.count, n.materialIndex);
      return f = t.boundingBox, f !== null && (this.boundingBox = f.clone()), f = t.boundingSphere, f !== null && (this.boundingSphere = f.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Ot.prototype = Object.create(j.prototype), Ot.prototype.constructor = Ot, Bt.prototype = Object.create(Ft.prototype), Bt.prototype.constructor = Bt, ke.prototype = Object.create(j.prototype), ke.prototype.constructor = ke, ce.prototype = Object.create(Ft.prototype), ce.prototype.constructor = ce;
  var mu = 0;
  Yt.prototype = Object.assign(Object.create(a.prototype), {
    constructor: Yt,
    isMaterial: !0,
    onBeforeCompile: function() {
    },
    setValues: function(t) {
      if (t !== void 0)
        for (var e in t) {
          var i = t[e];
          if (i === void 0)
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          else if (e === "shading")
            console.warn(
              "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
            ), this.flatShading = i === 1;
          else {
            var n = this[e];
            n === void 0 ? console.warn(
              "THREE." + this.type + ": '" + e + "' is not a property of this material."
            ) : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
          }
        }
    },
    toJSON: function(t) {
      function e(o) {
        var l = [], f;
        for (f in o) {
          var p = o[f];
          delete p.metadata, l.push(p);
        }
        return l;
      }
      var i = t === void 0 || typeof t == "string";
      i && (t = { textures: {}, images: {} });
      var n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      return n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearCoat !== void 0 && (n.clearCoat = this.clearCoat), this.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== 0 && (n.side = this.side), this.vertexColors !== 0 && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
      var e = t.clippingPlanes, i = null;
      if (e !== null) {
        var n = e.length;
        i = Array(n);
        for (var o = 0; o !== n; ++o)
          i[o] = e[o].clone();
      }
      return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), $e.prototype = Object.create(Yt.prototype), $e.prototype.constructor = $e, $e.prototype.isShaderMaterial = !0, $e.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Dn.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this;
  }, $e.prototype.toJSON = function(t) {
    var e = Yt.prototype.toJSON.call(this, t);
    e.uniforms = {};
    for (var i in this.uniforms) {
      var n = this.uniforms[i].value;
      e.uniforms[i] = n.isTexture ? { type: "t", value: n.toJSON(t).uuid } : n.isColor ? { type: "c", value: n.getHex() } : n.isVector2 ? { type: "v2", value: n.toArray() } : n.isVector3 ? { type: "v3", value: n.toArray() } : n.isVector4 ? { type: "v4", value: n.toArray() } : n.isMatrix4 ? { type: "m4", value: n.toArray() } : { value: n };
    }
    return 0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e;
  }, Object.assign(Li.prototype, {
    set: function(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Ray: .at() target is now required"), e = new u()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    },
    recast: function() {
      var t = new u();
      return function(e) {
        return this.origin.copy(this.at(e, t)), this;
      };
    }(),
    closestPointToPoint: function(t, e) {
      return e === void 0 && (console.warn(
        "THREE.Ray: .closestPointToPoint() target is now required"
      ), e = new u()), e.subVectors(t, this.origin), t = e.dot(this.direction), 0 > t ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    distanceToPoint: function(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    },
    distanceSqToPoint: function() {
      var t = new u();
      return function(e) {
        var i = t.subVectors(e, this.origin).dot(this.direction);
        return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e));
      };
    }(),
    distanceSqToSegment: function() {
      var t = new u(), e = new u(), i = new u();
      return function(n, o, l, f) {
        t.copy(n).add(o).multiplyScalar(0.5), e.copy(o).sub(n).normalize(), i.copy(this.origin).sub(t);
        var p = 0.5 * n.distanceTo(o), y = -this.direction.dot(e), w = i.dot(this.direction), A = -i.dot(e), P = i.lengthSq(), B = Math.abs(1 - y * y);
        if (0 < B) {
          n = y * A - w, o = y * w - A;
          var H = p * B;
          0 <= n ? o >= -H ? o <= H ? (p = 1 / B, n *= p, o *= p, y = n * (n + y * o + 2 * w) + o * (y * n + o + 2 * A) + P) : (o = p, n = Math.max(0, -(y * o + w)), y = -n * n + o * (o + 2 * A) + P) : (o = -p, n = Math.max(0, -(y * o + w)), y = -n * n + o * (o + 2 * A) + P) : o <= -H ? (n = Math.max(0, -(-y * p + w)), o = 0 < n ? -p : Math.min(Math.max(-p, -A), p), y = -n * n + o * (o + 2 * A) + P) : o <= H ? (n = 0, o = Math.min(Math.max(-p, -A), p), y = o * (o + 2 * A) + P) : (n = Math.max(0, -(y * p + w)), o = 0 < n ? p : Math.min(Math.max(-p, -A), p), y = -n * n + o * (o + 2 * A) + P);
        } else
          o = 0 < y ? -p : p, n = Math.max(0, -(y * o + w)), y = -n * n + o * (o + 2 * A) + P;
        return l && l.copy(this.direction).multiplyScalar(n).add(this.origin), f && f.copy(e).multiplyScalar(o).add(t), y;
      };
    }(),
    intersectSphere: function() {
      var t = new u();
      return function(e, i) {
        t.subVectors(e.center, this.origin);
        var n = t.dot(this.direction), o = t.dot(t) - n * n;
        return e = e.radius * e.radius, o > e ? null : (e = Math.sqrt(e - o), o = n - e, n += e, 0 > o && 0 > n ? null : 0 > o ? this.at(n, i) : this.at(o, i));
      };
    }(),
    intersectsSphere: function(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    },
    distanceToPlane: function(t) {
      var e = t.normal.dot(this.direction);
      return e === 0 ? t.distanceToPoint(this.origin) === 0 ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, 0 <= t ? t : null);
    },
    intersectPlane: function(t, e) {
      return t = this.distanceToPlane(t), t === null ? null : this.at(t, e);
    },
    intersectsPlane: function(t) {
      var e = t.distanceToPoint(this.origin);
      return e === 0 || 0 > t.normal.dot(this.direction) * e;
    },
    intersectBox: function(t, e) {
      var i = 1 / this.direction.x, n = 1 / this.direction.y, o = 1 / this.direction.z, l = this.origin;
      if (0 <= i) {
        var f = (t.min.x - l.x) * i;
        i *= t.max.x - l.x;
      } else
        f = (t.max.x - l.x) * i, i *= t.min.x - l.x;
      if (0 <= n) {
        var p = (t.min.y - l.y) * n;
        n *= t.max.y - l.y;
      } else
        p = (t.max.y - l.y) * n, n *= t.min.y - l.y;
      return f > n || p > i || ((p > f || f !== f) && (f = p), (n < i || i !== i) && (i = n), 0 <= o ? (p = (t.min.z - l.z) * o, t = (t.max.z - l.z) * o) : (p = (t.max.z - l.z) * o, t = (t.min.z - l.z) * o), f > t || p > i) ? null : ((p > f || f !== f) && (f = p), (t < i || i !== i) && (i = t), 0 > i ? null : this.at(0 <= f ? f : i, e));
    },
    intersectsBox: function() {
      var t = new u();
      return function(e) {
        return this.intersectBox(e, t) !== null;
      };
    }(),
    intersectTriangle: function() {
      var t = new u(), e = new u(), i = new u(), n = new u();
      return function(o, l, f, p, y) {
        if (e.subVectors(l, o), i.subVectors(f, o), n.crossVectors(e, i), l = this.direction.dot(n), 0 < l) {
          if (p)
            return null;
          p = 1;
        } else if (0 > l)
          p = -1, l = -l;
        else
          return null;
        return t.subVectors(this.origin, o), o = p * this.direction.dot(i.crossVectors(t, i)), 0 > o || (f = p * this.direction.dot(e.cross(t)), 0 > f || o + f > l) ? null : (o = -p * t.dot(n), 0 > o ? null : this.at(o / l, y));
      };
    }(),
    applyMatrix4: function(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    },
    equals: function(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
  }), Object.assign(Oe, {
    getNormal: function() {
      var t = new u();
      return function(e, i, n, o) {
        return o === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new u()), o.subVectors(n, i), t.subVectors(e, i), o.cross(t), e = o.lengthSq(), 0 < e ? o.multiplyScalar(1 / Math.sqrt(e)) : o.set(0, 0, 0);
      };
    }(),
    getBarycoord: function() {
      var t = new u(), e = new u(), i = new u();
      return function(n, o, l, f, p) {
        t.subVectors(f, o), e.subVectors(l, o), i.subVectors(n, o), n = t.dot(t), o = t.dot(e), l = t.dot(i);
        var y = e.dot(e);
        f = e.dot(i);
        var w = n * y - o * o;
        return p === void 0 && (console.warn(
          "THREE.Triangle: .getBarycoord() target is now required"
        ), p = new u()), w === 0 ? p.set(-2, -1, -1) : (w = 1 / w, y = (y * l - o * f) * w, n = (n * f - o * l) * w, p.set(1 - y - n, n, y));
      };
    }(),
    containsPoint: function() {
      var t = new u();
      return function(e, i, n, o) {
        return Oe.getBarycoord(e, i, n, o, t), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y;
      };
    }(),
    getUV: function() {
      var t = new u();
      return function(e, i, n, o, l, f, p, y) {
        return this.getBarycoord(e, i, n, o, t), y.set(0, 0), y.addScaledVector(l, t.x), y.addScaledVector(f, t.y), y.addScaledVector(p, t.z), y;
      };
    }()
  }), Object.assign(Oe.prototype, {
    set: function(t, e, i) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
    },
    setFromPointsAndIndices: function(t, e, i, n) {
      return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    },
    getArea: function() {
      var t = new u(), e = new u();
      return function() {
        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), 0.5 * t.cross(e).length();
      };
    }(),
    getMidpoint: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new u()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(t) {
      return Oe.getNormal(this.a, this.b, this.c, t);
    },
    getPlane: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new u()), t.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(t, e) {
      return Oe.getBarycoord(t, this.a, this.b, this.c, e);
    },
    containsPoint: function(t) {
      return Oe.containsPoint(t, this.a, this.b, this.c);
    },
    getUV: function(t, e, i, n, o) {
      return Oe.getUV(t, this.a, this.b, this.c, e, i, n, o);
    },
    intersectsBox: function(t) {
      return t.intersectsTriangle(this);
    },
    closestPointToPoint: function() {
      var t = new u(), e = new u(), i = new u(), n = new u(), o = new u(), l = new u();
      return function(f, p) {
        p === void 0 && (console.warn(
          "THREE.Triangle: .closestPointToPoint() target is now required"
        ), p = new u());
        var y = this.a, w = this.b, A = this.c;
        t.subVectors(w, y), e.subVectors(A, y), n.subVectors(f, y);
        var P = t.dot(n), B = e.dot(n);
        if (0 >= P && 0 >= B)
          return p.copy(y);
        o.subVectors(f, w);
        var H = t.dot(o), q = e.dot(o);
        if (0 <= H && q <= H)
          return p.copy(w);
        var $ = P * q - H * B;
        if (0 >= $ && 0 <= P && 0 >= H)
          return w = P / (P - H), p.copy(y).addScaledVector(t, w);
        l.subVectors(f, A), f = t.dot(l);
        var rt = e.dot(l);
        return 0 <= rt && f <= rt ? p.copy(A) : (P = f * B - P * rt, 0 >= P && 0 <= B && 0 >= rt ? ($ = B / (B - rt), p.copy(y).addScaledVector(e, $)) : (B = H * rt - f * q, 0 >= B && 0 <= q - H && 0 <= f - rt ? (i.subVectors(A, w), $ = (q - H) / (q - H + (f - rt)), p.copy(w).addScaledVector(i, $)) : (A = 1 / (B + P + $), w = P * A, $ *= A, p.copy(y).addScaledVector(t, w).addScaledVector(e, $))));
      };
    }(),
    equals: function(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }), Ge.prototype = Object.create(Yt.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isMeshBasicMaterial = !0, Ge.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
  }, pi.prototype = Object.assign(Object.create(N.prototype), {
    constructor: pi,
    isMesh: !0,
    setDrawMode: function(t) {
      this.drawMode = t;
    },
    copy: function(t) {
      return N.prototype.copy.call(this, t), this.drawMode = t.drawMode, t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign(
        {},
        t.morphTargetDictionary
      )), this;
    },
    updateMorphTargets: function() {
      var t = this.geometry;
      if (t.isBufferGeometry) {
        t = t.morphAttributes;
        var e = Object.keys(t);
        if (0 < e.length) {
          var i = t[e[0]];
          if (i !== void 0)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
              var n = i[t].name || String(t);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
            }
        }
      } else if (i = t.morphTargets, i !== void 0 && 0 < i.length)
        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++)
          n = i[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
    },
    raycast: function() {
      function t(rt, xt, gt, Ct, wt, Vt, Z, ot) {
        return (xt.side === 1 ? Ct.intersectTriangle(Z, Vt, wt, !0, ot) : Ct.intersectTriangle(wt, Vt, Z, xt.side !== 2, ot)) === null ? null : ($.copy(ot), $.applyMatrix4(rt.matrixWorld), xt = gt.ray.origin.distanceTo($), xt < gt.near || xt > gt.far ? null : { distance: xt, point: $.clone(), object: rt });
      }
      function e(rt, xt, gt, Ct, wt, Vt, Z, ot, zt) {
        return l.fromBufferAttribute(wt, Z), f.fromBufferAttribute(wt, ot), p.fromBufferAttribute(wt, zt), (rt = t(rt, xt, gt, Ct, l, f, p, q)) && (Vt && (P.fromBufferAttribute(Vt, Z), B.fromBufferAttribute(Vt, ot), H.fromBufferAttribute(Vt, zt), rt.uv = Oe.getUV(q, l, f, p, P, B, H, new s())), Vt = new R(Z, ot, zt), Oe.getNormal(l, f, p, Vt.normal), rt.face = Vt), rt;
      }
      var i = new c(), n = new Li(), o = new D(), l = new u(), f = new u(), p = new u(), y = new u(), w = new u(), A = new u(), P = new s(), B = new s(), H = new s(), q = new u(), $ = new u();
      return function(rt, xt) {
        var gt = this.geometry, Ct = this.material, wt = this.matrixWorld;
        if (Ct !== void 0 && (gt.boundingSphere === null && gt.computeBoundingSphere(), o.copy(gt.boundingSphere), o.applyMatrix4(wt), rt.ray.intersectsSphere(o) !== !1 && (i.getInverse(wt), n.copy(rt.ray).applyMatrix4(i), gt.boundingBox === null || n.intersectsBox(gt.boundingBox) !== !1))) {
          if (gt.isBufferGeometry) {
            var Vt = gt.index, Z = gt.attributes.position, ot = gt.attributes.uv, zt = gt.groups;
            gt = gt.drawRange;
            var ee;
            if (Vt !== null)
              if (Array.isArray(Ct)) {
                var $t = 0;
                for (ee = zt.length; $t < ee; $t++) {
                  var qt = zt[$t], Te = Ct[qt.materialIndex];
                  wt = Math.max(qt.start, gt.start);
                  var me = Math.min(qt.start + qt.count, gt.start + gt.count);
                  for (qt = wt; qt < me; qt += 3) {
                    wt = Vt.getX(qt);
                    var Ie = Vt.getX(qt + 1), be = Vt.getX(qt + 2);
                    (wt = e(this, Te, rt, n, Z, ot, wt, Ie, be)) && (wt.faceIndex = Math.floor(qt / 3), xt.push(wt));
                  }
                }
              } else
                for (wt = Math.max(0, gt.start), me = Math.min(Vt.count, gt.start + gt.count), $t = wt, ee = me; $t < ee; $t += 3)
                  wt = Vt.getX($t), Ie = Vt.getX($t + 1), be = Vt.getX($t + 2), (wt = e(this, Ct, rt, n, Z, ot, wt, Ie, be)) && (wt.faceIndex = Math.floor($t / 3), xt.push(wt));
            else if (Z !== void 0)
              if (Array.isArray(Ct))
                for ($t = 0, ee = zt.length; $t < ee; $t++)
                  for (qt = zt[$t], Te = Ct[qt.materialIndex], wt = Math.max(qt.start, gt.start), me = Math.min(qt.start + qt.count, gt.start + gt.count), qt = wt; qt < me; qt += 3)
                    wt = qt, Ie = qt + 1, be = qt + 2, (wt = e(this, Te, rt, n, Z, ot, wt, Ie, be)) && (wt.faceIndex = Math.floor(qt / 3), xt.push(wt));
              else
                for (wt = Math.max(0, gt.start), me = Math.min(Z.count, gt.start + gt.count), $t = wt, ee = me; $t < ee; $t += 3)
                  wt = $t, Ie = $t + 1, be = $t + 2, (wt = e(this, Ct, rt, n, Z, ot, wt, Ie, be)) && (wt.faceIndex = Math.floor($t / 3), xt.push(wt));
          } else if (gt.isGeometry) {
            for (Z = Array.isArray(Ct), ot = gt.vertices, zt = gt.faces, wt = gt.faceVertexUvs[0], 0 < wt.length && (Vt = wt), qt = 0, me = zt.length; qt < me; qt++)
              if (Ie = zt[qt], wt = Z ? Ct[Ie.materialIndex] : Ct, wt !== void 0) {
                if ($t = ot[Ie.a], ee = ot[Ie.b], Te = ot[Ie.c], wt.morphTargets === !0) {
                  be = gt.morphTargets;
                  var ae = this.morphTargetInfluences;
                  l.set(0, 0, 0), f.set(0, 0, 0), p.set(0, 0, 0);
                  for (var We = 0, Qe = be.length; We < Qe; We++) {
                    var ci = ae[We];
                    if (ci !== 0) {
                      var Sn = be[We].vertices;
                      l.addScaledVector(y.subVectors(Sn[Ie.a], $t), ci), f.addScaledVector(w.subVectors(Sn[Ie.b], ee), ci), p.addScaledVector(A.subVectors(Sn[Ie.c], Te), ci);
                    }
                  }
                  l.add($t), f.add(ee), p.add(Te), $t = l, ee = f, Te = p;
                }
                (wt = t(this, wt, rt, n, $t, ee, Te, q)) && (Vt && Vt[qt] && (be = Vt[qt], P.copy(be[0]), B.copy(be[1]), H.copy(be[2]), wt.uv = Oe.getUV(q, $t, ee, Te, P, B, H, new s())), wt.face = Ie, wt.faceIndex = qt, xt.push(wt));
              }
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), z.prototype = Object.create(g.prototype), z.prototype.constructor = z, z.prototype.isCubeTexture = !0, Object.defineProperty(z.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(t) {
      this.image = t;
    }
  }), Q.prototype = Object.create(g.prototype), Q.prototype.constructor = Q, Q.prototype.isDataTexture3D = !0;
  var Lh = new g(), oc = new Q(), gu = new z(), ql = [], xa = [], hl = new Float32Array(16), vu = new Float32Array(9), Rh = new Float32Array(4);
  Zs.prototype.updateCache = function(t) {
    var e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), vt(e, t);
  }, Ba.prototype.setValue = function(t, e, i) {
    for (var n = this.seq, o = 0, l = n.length; o !== l; ++o) {
      var f = n[o];
      f.setValue(t, e[f.id], i);
    }
  };
  var Oh = /([\w\d_]+)(\])?(\[|\.)?/g;
  ro.prototype.setValue = function(t, e, i) {
    e = this.map[e], e !== void 0 && e.setValue(t, i, this.renderer);
  }, ro.prototype.setOptional = function(t, e, i) {
    e = e[i], e !== void 0 && this.setValue(t, i, e);
  }, ro.upload = function(t, e, i, n) {
    for (var o = 0, l = e.length; o !== l; ++o) {
      var f = e[o], p = i[f.id];
      p.needsUpdate !== !1 && f.setValue(t, p.value, n);
    }
  }, ro.seqWithValue = function(t, e) {
    for (var i = [], n = 0, o = t.length; n !== o; ++n) {
      var l = t[n];
      l.id in e && i.push(l);
    }
    return i;
  };
  var ko = 0, Ih = 0;
  se.prototype = Object.create(Yt.prototype), se.prototype.constructor = se, se.prototype.isMeshDepthMaterial = !0, se.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }, te.prototype = Object.create(Yt.prototype), te.prototype.constructor = te, te.prototype.isMeshDistanceMaterial = !0, te.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }, ui.prototype = Object.assign(Object.create(N.prototype), {
    constructor: ui,
    isGroup: !0
  }), Be.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Be,
    isCamera: !0,
    copy: function(t, e) {
      return N.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    },
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Camera: .getWorldDirection() target is now required"
      ), t = new u()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(t) {
      N.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), _e.prototype = Object.assign(Object.create(Be.prototype), {
    constructor: _e,
    isPerspectiveCamera: !0,
    copy: function(t, e) {
      return Be.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    },
    setFocalLength: function(t) {
      t = 0.5 * this.getFilmHeight() / t, this.fov = 2 * fi.RAD2DEG * Math.atan(t), this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      var t = Math.tan(0.5 * fi.DEG2RAD * this.fov);
      return 0.5 * this.getFilmHeight() / t;
    },
    getEffectiveFOV: function() {
      return 2 * fi.RAD2DEG * Math.atan(Math.tan(0.5 * fi.DEG2RAD * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(t, e, i, n, o, l) {
      this.aspect = t / e, this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = this.near, e = t * Math.tan(0.5 * fi.DEG2RAD * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, o = -0.5 * n, l = this.view;
      if (this.view !== null && this.view.enabled) {
        var f = l.fullWidth, p = l.fullHeight;
        o += l.offsetX * n / f, e -= l.offsetY * i / p, n *= l.width / f, i *= l.height / p;
      }
      l = this.filmOffset, l !== 0 && (o += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = N.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }), Fe.prototype = Object.assign(Object.create(_e.prototype), {
    constructor: Fe,
    isArrayCamera: !0
  });
  var es = new u(), yr = new u();
  Le.prototype.isFogExp2 = !0, Le.prototype.clone = function() {
    return new Le(this.color, this.density);
  }, Le.prototype.toJSON = function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }, wn.prototype.isFog = !0, wn.prototype.clone = function() {
    return new wn(this.color, this.near, this.far);
  }, wn.prototype.toJSON = function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }, Hn.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Hn,
    copy: function(t, e) {
      return N.prototype.copy.call(this, t, e), t.background !== null && (this.background = t.background.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    },
    toJSON: function(t) {
      var e = N.prototype.toJSON.call(this, t);
      return this.background !== null && (e.object.background = this.background.toJSON(t)), this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
    }
  }), Object.defineProperty(Ii.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(Ii.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.stride : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.stride, i *= e.stride;
      for (var n = 0, o = this.stride; n < o; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    }
  }), Object.defineProperties(Di.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    }
  }), Object.assign(Di.prototype, {
    isInterleavedBufferAttribute: !0,
    setX: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    },
    setY: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    },
    setZ: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    },
    setW: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    },
    getX: function(t) {
      return this.data.array[t * this.data.stride + this.offset];
    },
    getY: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    },
    getZ: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    },
    getW: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    },
    setXY: function(t, e, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, o) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = o, this;
    }
  }), Ui.prototype = Object.create(Yt.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isSpriteMaterial = !0, Ui.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
  };
  var wa;
  Qi.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Qi,
    isSprite: !0,
    raycast: function() {
      function t(H, q, $, rt, xt, gt) {
        o.subVectors(H, $).addScalar(0.5).multiply(rt), xt !== void 0 ? (l.x = gt * o.x - xt * o.y, l.y = xt * o.x + gt * o.y) : l.copy(o), H.copy(q), H.x += l.x, H.y += l.y, H.applyMatrix4(f);
      }
      var e = new u(), i = new u(), n = new u(), o = new s(), l = new s(), f = new c(), p = new u(), y = new u(), w = new u(), A = new s(), P = new s(), B = new s();
      return function(H, q) {
        i.setFromMatrixScale(this.matrixWorld), f.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
        var $ = this.material.rotation;
        if ($ !== 0)
          var rt = Math.cos($), xt = Math.sin($);
        $ = this.center, t(p.set(-0.5, -0.5, 0), n, $, i, xt, rt), t(y.set(0.5, -0.5, 0), n, $, i, xt, rt), t(w.set(0.5, 0.5, 0), n, $, i, xt, rt), A.set(0, 0), P.set(1, 0), B.set(1, 1);
        var gt = H.ray.intersectTriangle(p, y, w, !1, e);
        gt === null && (t(y.set(-0.5, 0.5, 0), n, $, i, xt, rt), P.set(0, 1), gt = H.ray.intersectTriangle(p, w, y, !1, e), gt === null) || (xt = H.ray.origin.distanceTo(e), xt < H.near || xt > H.far || q.push({
          distance: xt,
          point: e.clone(),
          uv: Oe.getUV(e, p, y, w, A, P, B, new s()),
          face: null,
          object: this
        }));
      };
    }(),
    clone: function() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function(t) {
      return N.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this;
    }
  }), tn.prototype = Object.assign(Object.create(N.prototype), {
    constructor: tn,
    copy: function(t) {
      N.prototype.copy.call(this, t, !1), t = t.levels;
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.addLevel(n.object.clone(), n.distance);
      }
      return this;
    },
    addLevel: function(t, e) {
      e === void 0 && (e = 0), e = Math.abs(e);
      for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++)
        ;
      i.splice(n, 0, { distance: e, object: t }), this.add(t);
    },
    getObjectForDistance: function(t) {
      for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
        ;
      return e[i - 1].object;
    },
    raycast: function() {
      var t = new u();
      return function(e, i) {
        t.setFromMatrixPosition(this.matrixWorld);
        var n = e.ray.origin.distanceTo(t);
        this.getObjectForDistance(n).raycast(e, i);
      };
    }(),
    update: function() {
      var t = new u(), e = new u();
      return function(i) {
        var n = this.levels;
        if (1 < n.length) {
          t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0;
          for (var o = 1, l = n.length; o < l && i >= n[o].distance; o++)
            n[o - 1].object.visible = !1, n[o].object.visible = !0;
          for (; o < l; o++)
            n[o].object.visible = !1;
        }
      };
    }(),
    toJSON: function(t) {
      t = N.prototype.toJSON.call(this, t), t.object.levels = [];
      for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
        var o = e[i];
        t.object.levels.push({ object: o.object.uuid, distance: o.distance });
      }
      return t;
    }
  }), Object.assign(sn.prototype, {
    calculateInverses: function() {
      this.boneInverses = [];
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var i = new c();
        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i);
      }
    },
    pose: function() {
      var t, e, i = 0;
      for (e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
      for (i = 0, e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
    },
    update: function() {
      var t = new c(), e = new c();
      return function() {
        for (var i = this.bones, n = this.boneInverses, o = this.boneMatrices, l = this.boneTexture, f = 0, p = i.length; f < p; f++)
          t.multiplyMatrices(i[f] ? i[f].matrixWorld : e, n[f]), t.toArray(o, 16 * f);
        l !== void 0 && (l.needsUpdate = !0);
      };
    }(),
    clone: function() {
      return new sn(this.bones, this.boneInverses);
    },
    getBoneByName: function(t) {
      for (var e = 0, i = this.bones.length; e < i; e++) {
        var n = this.bones[e];
        if (n.name === t)
          return n;
      }
    }
  }), an.prototype = Object.assign(Object.create(N.prototype), {
    constructor: an,
    isBone: !0
  }), Fi.prototype = Object.assign(Object.create(pi.prototype), {
    constructor: Fi,
    isSkinnedMesh: !0,
    initBones: function() {
      var t = [], e;
      if (this.geometry && this.geometry.bones !== void 0) {
        var i = 0;
        for (e = this.geometry.bones.length; i < e; i++) {
          var n = this.geometry.bones[i], o = new an();
          t.push(o), o.name = n.name, o.position.fromArray(n.pos), o.quaternion.fromArray(n.rotq), n.scl !== void 0 && o.scale.fromArray(n.scl);
        }
        for (i = 0, e = this.geometry.bones.length; i < e; i++)
          n = this.geometry.bones[i], n.parent !== -1 && n.parent !== null && t[n.parent] !== void 0 ? t[n.parent].add(t[i]) : this.add(t[i]);
      }
      return this.updateMatrixWorld(!0), t;
    },
    bind: function(t, e) {
      this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      var t;
      if (this.geometry && this.geometry.isGeometry)
        for (t = 0; t < this.geometry.skinWeights.length; t++) {
          var e = this.geometry.skinWeights[t], i = 1 / e.manhattanLength();
          i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0);
        }
      else if (this.geometry && this.geometry.isBufferGeometry) {
        e = new _();
        var n = this.geometry.attributes.skinWeight;
        for (t = 0; t < n.count; t++)
          e.x = n.getX(t), e.y = n.getY(t), e.z = n.getZ(t), e.w = n.getW(t), i = 1 / e.manhattanLength(), i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), n.setXYZW(t, e.x, e.y, e.z, e.w);
      }
    },
    updateMatrixWorld: function(t) {
      pi.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn(
        "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
      );
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), zi.prototype = Object.create(Yt.prototype), zi.prototype.constructor = zi, zi.prototype.isLineBasicMaterial = !0, zi.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
  }, Vi.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Vi,
    isLine: !0,
    computeLineDistances: function() {
      var t = new u(), e = new u();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, o = [0], l = 1, f = n.count; l < f; l++)
              t.fromBufferAttribute(n, l - 1), e.fromBufferAttribute(n, l), o[l] = o[l - 1], o[l] += t.distanceTo(e);
            i.addAttribute("lineDistance", new Et(o, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, o = i.lineDistances, o[0] = 0, l = 1, f = n.length; l < f; l++)
            o[l] = o[l - 1], o[l] += n[l - 1].distanceTo(n[l]);
        return this;
      };
    }(),
    raycast: function() {
      var t = new c(), e = new Li(), i = new D();
      return function(n, o) {
        var l = n.linePrecision, f = this.geometry, p = this.matrixWorld;
        if (f.boundingSphere === null && f.computeBoundingSphere(), i.copy(f.boundingSphere), i.applyMatrix4(p), i.radius += l, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(p), e.copy(n.ray).applyMatrix4(t), l /= (this.scale.x + this.scale.y + this.scale.z) / 3, l *= l;
          var y = new u(), w = new u();
          p = new u();
          var A = new u(), P = this && this.isLineSegments ? 2 : 1;
          if (f.isBufferGeometry) {
            var B = f.index, H = f.attributes.position.array;
            if (B !== null) {
              B = B.array, f = 0;
              for (var q = B.length - 1; f < q; f += P) {
                var $ = B[f + 1];
                y.fromArray(H, 3 * B[f]), w.fromArray(H, 3 * $), $ = e.distanceSqToSegment(y, w, A, p), $ > l || (A.applyMatrix4(this.matrixWorld), $ = n.ray.origin.distanceTo(A), $ < n.near || $ > n.far || o.push({
                  distance: $,
                  point: p.clone().applyMatrix4(this.matrixWorld),
                  index: f,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
              }
            } else
              for (f = 0, q = H.length / 3 - 1; f < q; f += P)
                y.fromArray(H, 3 * f), w.fromArray(H, 3 * f + 3), $ = e.distanceSqToSegment(y, w, A, p), $ > l || (A.applyMatrix4(this.matrixWorld), $ = n.ray.origin.distanceTo(A), $ < n.near || $ > n.far || o.push({
                  distance: $,
                  point: p.clone().applyMatrix4(this.matrixWorld),
                  index: f,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
          } else if (f.isGeometry)
            for (y = f.vertices, w = y.length, f = 0; f < w - 1; f += P)
              $ = e.distanceSqToSegment(y[f], y[f + 1], A, p), $ > l || (A.applyMatrix4(this.matrixWorld), $ = n.ray.origin.distanceTo(A), $ < n.near || $ > n.far || o.push({
                distance: $,
                point: p.clone().applyMatrix4(this.matrixWorld),
                index: f,
                face: null,
                faceIndex: null,
                object: this
              }));
        }
      };
    }(),
    copy: function(t) {
      return N.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), mi.prototype = Object.assign(Object.create(Vi.prototype), {
    constructor: mi,
    isLineSegments: !0,
    computeLineDistances: function() {
      var t = new u(), e = new u();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, o = [], l = 0, f = n.count; l < f; l += 2)
              t.fromBufferAttribute(n, l), e.fromBufferAttribute(n, l + 1), o[l] = l === 0 ? 0 : o[l - 1], o[l + 1] = o[l] + t.distanceTo(e);
            i.addAttribute("lineDistance", new Et(o, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, o = i.lineDistances, l = 0, f = n.length; l < f; l += 2)
            t.copy(n[l]), e.copy(n[l + 1]), o[l] = l === 0 ? 0 : o[l - 1], o[l + 1] = o[l] + t.distanceTo(e);
        return this;
      };
    }()
  }), so.prototype = Object.assign(Object.create(Vi.prototype), {
    constructor: so,
    isLineLoop: !0
  }), Bn.prototype = Object.create(Yt.prototype), Bn.prototype.constructor = Bn, Bn.prototype.isPointsMaterial = !0, Bn.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
  }, Ks.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Ks,
    isPoints: !0,
    raycast: function() {
      var t = new c(), e = new Li(), i = new D();
      return function(n, o) {
        function l(rt, xt) {
          var gt = e.distanceSqToPoint(rt);
          gt < A && (e.closestPointToPoint(rt, P), P.applyMatrix4(y), rt = n.ray.origin.distanceTo(P), rt < n.near || rt > n.far || o.push({
            distance: rt,
            distanceToRay: Math.sqrt(gt),
            point: P.clone(),
            index: xt,
            face: null,
            object: f
          }));
        }
        var f = this, p = this.geometry, y = this.matrixWorld, w = n.params.Points.threshold;
        if (p.boundingSphere === null && p.computeBoundingSphere(), i.copy(p.boundingSphere), i.applyMatrix4(y), i.radius += w, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(y), e.copy(n.ray).applyMatrix4(t), w /= (this.scale.x + this.scale.y + this.scale.z) / 3;
          var A = w * w;
          w = new u();
          var P = new u();
          if (p.isBufferGeometry) {
            var B = p.index;
            if (p = p.attributes.position.array, B !== null) {
              var H = B.array;
              B = 0;
              for (var q = H.length; B < q; B++) {
                var $ = H[B];
                w.fromArray(p, 3 * $), l(w, $);
              }
            } else
              for (B = 0, H = p.length / 3; B < H; B++)
                w.fromArray(p, 3 * B), l(w, B);
          } else
            for (w = p.vertices, B = 0, H = w.length; B < H; B++)
              l(w[B], B);
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), yh.prototype = Object.assign(Object.create(g.prototype), {
    constructor: yh,
    isVideoTexture: !0,
    update: function() {
      var t = this.image;
      t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  }), Ho.prototype = Object.create(g.prototype), Ho.prototype.constructor = Ho, Ho.prototype.isCompressedTexture = !0, Fa.prototype = Object.create(g.prototype), Fa.prototype.constructor = Fa, Fa.prototype.isCanvasTexture = !0, Ua.prototype = Object.create(g.prototype), Ua.prototype.constructor = Ua, Ua.prototype.isDepthTexture = !0, Qs.prototype = Object.create(Ft.prototype), Qs.prototype.constructor = Qs, Ga.prototype = Object.create(j.prototype), Ga.prototype.constructor = Ga, ta.prototype = Object.create(Ft.prototype), ta.prototype.constructor = ta, Wi.prototype = Object.create(j.prototype), Wi.prototype.constructor = Wi, _i.prototype = Object.create(Ft.prototype), _i.prototype.constructor = _i, Ha.prototype = Object.create(j.prototype), Ha.prototype.constructor = Ha, ea.prototype = Object.create(_i.prototype), ea.prototype.constructor = ea, Va.prototype = Object.create(j.prototype), Va.prototype.constructor = Va, ps.prototype = Object.create(_i.prototype), ps.prototype.constructor = ps, Wa.prototype = Object.create(j.prototype), Wa.prototype.constructor = Wa, ia.prototype = Object.create(_i.prototype), ia.prototype.constructor = ia, na.prototype = Object.create(j.prototype), na.prototype.constructor = na, ra.prototype = Object.create(_i.prototype), ra.prototype.constructor = ra, fn.prototype = Object.create(j.prototype), fn.prototype.constructor = fn, Vo.prototype = Object.create(Ft.prototype), Vo.prototype.constructor = Vo, Vr.prototype = Object.create(j.prototype), Vr.prototype.constructor = Vr, ds.prototype = Object.create(Ft.prototype), ds.prototype.constructor = ds, ms.prototype = Object.create(j.prototype), ms.prototype.constructor = ms, Nn.prototype = Object.create(Ft.prototype), Nn.prototype.constructor = Nn;
  var yu = {
    triangulate: function(t, e, i) {
      i = i || 2;
      var n = e && e.length, o = n ? e[0] * i : t.length, l = _h(t, 0, o, i, !0), f = [];
      if (!l)
        return f;
      var p;
      if (n) {
        var y = i;
        n = [];
        var w, A = 0;
        for (w = e.length; A < w; A++) {
          var P = e[A] * y, B = A < w - 1 ? e[A + 1] * y : t.length;
          P = _h(t, P, B, y, !1), P === P.next && (P.steiner = !0), n.push(mr(P));
        }
        for (n.sort(ru), A = 0; A < n.length; A++)
          e = n[A], y = l, (y = ou(e, y)) && (e = ja(y, e), oa(e, e.next)), l = oa(l, l.next);
      }
      if (t.length > 80 * i) {
        var H = p = t[0], q = n = t[1];
        for (y = i; y < o; y += i)
          A = t[y], e = t[y + 1], A < H && (H = A), e < q && (q = e), A > p && (p = A), e > n && (n = e);
        p = Math.max(p - H, n - q), p = p !== 0 ? 1 / p : 0;
      }
      return sa(l, f, i, H, q, p), f;
    }
  }, vo = {
    area: function(t) {
      for (var e = t.length, i = 0, n = e - 1, o = 0; o < e; n = o++)
        i += t[n].x * t[o].y - t[o].x * t[n].y;
      return 0.5 * i;
    },
    isClockWise: function(t) {
      return 0 > vo.area(t);
    },
    triangulateShape: function(t, e) {
      var i = [], n = [], o = [];
      Bl(t), su(i, t);
      var l = t.length;
      for (e.forEach(Bl), t = 0; t < e.length; t++)
        n.push(l), l += e[t].length, su(i, e[t]);
      for (e = yu.triangulate(i, n), t = 0; t < e.length; t += 3)
        o.push(e.slice(t, t + 3));
      return o;
    }
  };
  Ao.prototype = Object.create(j.prototype), Ao.prototype.constructor = Ao, Ao.prototype.toJSON = function() {
    var t = j.prototype.toJSON.call(this);
    return au(this.parameters.shapes, this.parameters.options, t);
  }, lo.prototype = Object.create(Ft.prototype), lo.prototype.constructor = lo, lo.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return au(this.parameters.shapes, this.parameters.options, t);
  };
  var ul = {
    generateTopUV: function(t, e, i, n, o) {
      t = e[3 * n], n = e[3 * n + 1];
      var l = e[3 * o];
      return o = e[3 * o + 1], [new s(e[3 * i], e[3 * i + 1]), new s(t, n), new s(l, o)];
    },
    generateSideWallUV: function(t, e, i, n, o, l) {
      t = e[3 * i];
      var f = e[3 * i + 1];
      i = e[3 * i + 2];
      var p = e[3 * n], y = e[3 * n + 1];
      n = e[3 * n + 2];
      var w = e[3 * o], A = e[3 * o + 1];
      o = e[3 * o + 2];
      var P = e[3 * l], B = e[3 * l + 1];
      return e = e[3 * l + 2], 0.01 > Math.abs(f - y) ? [new s(t, 1 - i), new s(p, 1 - n), new s(w, 1 - o), new s(P, 1 - e)] : [new s(f, 1 - i), new s(y, 1 - n), new s(A, 1 - o), new s(B, 1 - e)];
    }
  };
  Xa.prototype = Object.create(j.prototype), Xa.prototype.constructor = Xa, vs.prototype = Object.create(lo.prototype), vs.prototype.constructor = vs, Wo.prototype = Object.create(j.prototype), Wo.prototype.constructor = Wo, Er.prototype = Object.create(Ft.prototype), Er.prototype.constructor = Er, qa.prototype = Object.create(j.prototype), qa.prototype.constructor = qa, ys.prototype = Object.create(Ft.prototype), ys.prototype.constructor = ys, aa.prototype = Object.create(j.prototype), aa.prototype.constructor = aa, jo.prototype = Object.create(Ft.prototype), jo.prototype.constructor = jo, Po.prototype = Object.create(j.prototype), Po.prototype.constructor = Po, Po.prototype.toJSON = function() {
    var t = j.prototype.toJSON.call(this);
    return lu(this.parameters.shapes, t);
  }, Xo.prototype = Object.create(Ft.prototype), Xo.prototype.constructor = Xo, Xo.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return lu(this.parameters.shapes, t);
  }, qo.prototype = Object.create(Ft.prototype), qo.prototype.constructor = qo, Lo.prototype = Object.create(j.prototype), Lo.prototype.constructor = Lo, Ro.prototype = Object.create(Ft.prototype), Ro.prototype.constructor = Ro, la.prototype = Object.create(Lo.prototype), la.prototype.constructor = la, Fn.prototype = Object.create(Ro.prototype), Fn.prototype.constructor = Fn, _s.prototype = Object.create(j.prototype), _s.prototype.constructor = _s, ho.prototype = Object.create(Ft.prototype), ho.prototype.constructor = ho;
  var dn = Object.freeze({
    WireframeGeometry: Qs,
    ParametricGeometry: Ga,
    ParametricBufferGeometry: ta,
    TetrahedronGeometry: Ha,
    TetrahedronBufferGeometry: ea,
    OctahedronGeometry: Va,
    OctahedronBufferGeometry: ps,
    IcosahedronGeometry: Wa,
    IcosahedronBufferGeometry: ia,
    DodecahedronGeometry: na,
    DodecahedronBufferGeometry: ra,
    PolyhedronGeometry: Wi,
    PolyhedronBufferGeometry: _i,
    TubeGeometry: fn,
    TubeBufferGeometry: Vo,
    TorusKnotGeometry: Vr,
    TorusKnotBufferGeometry: ds,
    TorusGeometry: ms,
    TorusBufferGeometry: Nn,
    TextGeometry: Xa,
    TextBufferGeometry: vs,
    SphereGeometry: Wo,
    SphereBufferGeometry: Er,
    RingGeometry: qa,
    RingBufferGeometry: ys,
    PlaneGeometry: ke,
    PlaneBufferGeometry: ce,
    LatheGeometry: aa,
    LatheBufferGeometry: jo,
    ShapeGeometry: Po,
    ShapeBufferGeometry: Xo,
    ExtrudeGeometry: Ao,
    ExtrudeBufferGeometry: lo,
    EdgesGeometry: qo,
    ConeGeometry: la,
    ConeBufferGeometry: Fn,
    CylinderGeometry: Lo,
    CylinderBufferGeometry: Ro,
    CircleGeometry: _s,
    CircleBufferGeometry: ho,
    BoxGeometry: Ot,
    BoxBufferGeometry: Bt
  });
  Yo.prototype = Object.create(Yt.prototype), Yo.prototype.constructor = Yo, Yo.prototype.isShadowMaterial = !0, Yo.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this;
  }, xs.prototype = Object.create($e.prototype), xs.prototype.constructor = xs, xs.prototype.isRawShaderMaterial = !0, uo.prototype = Object.create(Yt.prototype), uo.prototype.constructor = uo, uo.prototype.isMeshStandardMaterial = !0, uo.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, ws.prototype = Object.create(uo.prototype), ws.prototype.constructor = ws, ws.prototype.isMeshPhysicalMaterial = !0, ws.prototype.copy = function(t) {
    return uo.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this;
  }, Wr.prototype = Object.create(Yt.prototype), Wr.prototype.constructor = Wr, Wr.prototype.isMeshPhongMaterial = !0, Wr.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Ts.prototype = Object.create(Wr.prototype), Ts.prototype.constructor = Ts, Ts.prototype.isMeshToonMaterial = !0, Ts.prototype.copy = function(t) {
    return Wr.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this;
  }, Ms.prototype = Object.create(Yt.prototype), Ms.prototype.constructor = Ms, Ms.prototype.isMeshNormalMaterial = !0, Ms.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, br.prototype = Object.create(Yt.prototype), br.prototype.constructor = br, br.prototype.isMeshLambertMaterial = !0, br.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Ss.prototype = Object.create(Yt.prototype), Ss.prototype.constructor = Ss, Ss.prototype.isMeshMatcapMaterial = !0, Ss.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Es.prototype = Object.create(zi.prototype), Es.prototype.constructor = Es, Es.prototype.isLineDashedMaterial = !0, Es.prototype.copy = function(t) {
    return zi.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
  };
  var _u = Object.freeze({
    ShadowMaterial: Yo,
    SpriteMaterial: Ui,
    RawShaderMaterial: xs,
    ShaderMaterial: $e,
    PointsMaterial: Bn,
    MeshPhysicalMaterial: ws,
    MeshStandardMaterial: uo,
    MeshPhongMaterial: Wr,
    MeshToonMaterial: Ts,
    MeshNormalMaterial: Ms,
    MeshLambertMaterial: br,
    MeshDepthMaterial: se,
    MeshDistanceMaterial: te,
    MeshBasicMaterial: Ge,
    MeshMatcapMaterial: Ss,
    LineDashedMaterial: Es,
    LineBasicMaterial: zi,
    Material: Yt
  }), Wn = {
    arraySlice: function(t, e, i) {
      return Wn.isTypedArray(t) ? new t.constructor(t.subarray(e, i !== void 0 ? i : t.length)) : t.slice(e, i);
    },
    convertArray: function(t, e, i) {
      return !t || !i && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
    },
    isTypedArray: function(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function(t) {
      for (var e = t.length, i = Array(e), n = 0; n !== e; ++n)
        i[n] = n;
      return i.sort(function(o, l) {
        return t[o] - t[l];
      }), i;
    },
    sortedArray: function(t, e, i) {
      for (var n = t.length, o = new t.constructor(n), l = 0, f = 0; f !== n; ++l)
        for (var p = i[l] * e, y = 0; y !== e; ++y)
          o[f++] = t[p + y];
      return o;
    },
    flattenJSON: function(t, e, i, n) {
      for (var o = 1, l = t[0]; l !== void 0 && l[n] === void 0; )
        l = t[o++];
      if (l !== void 0) {
        var f = l[n];
        if (f !== void 0)
          if (Array.isArray(f))
            do
              f = l[n], f !== void 0 && (e.push(l.time), i.push.apply(i, f)), l = t[o++];
            while (l !== void 0);
          else if (f.toArray !== void 0)
            do
              f = l[n], f !== void 0 && (e.push(l.time), f.toArray(i, i.length)), l = t[o++];
            while (l !== void 0);
          else
            do
              f = l[n], f !== void 0 && (e.push(l.time), i.push(f)), l = t[o++];
            while (l !== void 0);
      }
    }
  };
  Object.assign(Zn.prototype, {
    evaluate: function(t) {
      var e = this.parameterPositions, i = this._cachedIndex, n = e[i], o = e[i - 1];
      t: {
        e: {
          i: {
            n:
              if (!(t < n)) {
                for (var l = i + 2; ; ) {
                  if (n === void 0) {
                    if (t < o)
                      break n;
                    return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, o);
                  }
                  if (i === l)
                    break;
                  if (o = n, n = e[++i], t < n)
                    break e;
                }
                n = e.length;
                break i;
              }
            if (t >= o)
              break t;
            for (l = e[1], t < l && (i = 2, o = l), l = i - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, n);
              if (i === l)
                break;
              if (n = o, o = e[--i - 1], t >= o)
                break e;
            }
            n = i, i = 0;
          }
          for (; i < n; )
            o = i + n >>> 1, t < e[o] ? n = o : i = o + 1;
          if (n = e[i], o = e[i - 1], o === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t, n);
          if (n === void 0)
            return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, o, t);
        }
        this._cachedIndex = i, this.intervalChanged_(i, o, n);
      }
      return this.interpolate_(i, o, t, n);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(t) {
      var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize;
      t *= n;
      for (var o = 0; o !== n; ++o)
        e[o] = i[t + o];
      return e;
    },
    interpolate_: function() {
      throw Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  }), Object.assign(Zn.prototype, {
    beforeStart_: Zn.prototype.copySampleValue_,
    afterEnd_: Zn.prototype.copySampleValue_
  }), Ya.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: Ya,
    DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
    intervalChanged_: function(t, e, i) {
      var n = this.parameterPositions, o = t - 2, l = t + 1, f = n[o], p = n[l];
      if (f === void 0)
        switch (this.getSettings_().endingStart) {
          case 2401:
            o = t, f = 2 * e - i;
            break;
          case 2402:
            o = n.length - 2, f = e + n[o] - n[o + 1];
            break;
          default:
            o = t, f = i;
        }
      if (p === void 0)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            l = t, p = 2 * i - e;
            break;
          case 2402:
            l = 1, p = i + n[1] - n[0];
            break;
          default:
            l = t - 1, p = e;
        }
      t = 0.5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - f), this._weightNext = t / (p - i), this._offsetPrev = o * n, this._offsetNext = l * n;
    },
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, l = this.sampleValues, f = this.valueSize;
      t *= f;
      var p = t - f, y = this._offsetPrev, w = this._offsetNext, A = this._weightPrev, P = this._weightNext, B = (i - e) / (n - e);
      for (i = B * B, n = i * B, e = -A * n + 2 * A * i - A * B, A = (1 + A) * n + (-1.5 - 2 * A) * i + (-0.5 + A) * B + 1, B = (-1 - P) * n + (1.5 + P) * i + 0.5 * B, P = P * n - P * i, i = 0; i !== f; ++i)
        o[i] = e * l[y + i] + A * l[p + i] + B * l[t + i] + P * l[w + i];
      return o;
    }
  }), Cr.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: Cr,
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, l = this.sampleValues, f = this.valueSize;
      t *= f;
      var p = t - f;
      for (e = (i - e) / (n - e), i = 1 - e, n = 0; n !== f; ++n)
        o[n] = l[p + n] * i + l[t + n] * e;
      return o;
    }
  }), bs.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: bs,
    interpolate_: function(t) {
      return this.copySampleValue_(t - 1);
    }
  }), Object.assign(Un, {
    toJSON: function(t) {
      var e = t.constructor;
      if (e.toJSON !== void 0)
        e = e.toJSON(t);
      else {
        e = {
          name: t.name,
          times: Wn.convertArray(t.times, Array),
          values: Wn.convertArray(t.values, Array)
        };
        var i = t.getInterpolation();
        i !== t.DefaultInterpolation && (e.interpolation = i);
      }
      return e.type = t.ValueTypeName, e;
    }
  }), Object.assign(Un.prototype, {
    constructor: Un,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function(t) {
      return new bs(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodLinear: function(t) {
      return new Cr(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: function(t) {
      return new Ya(this.times, this.values, this.getValueSize(), t);
    },
    setInterpolation: function(t) {
      switch (t) {
        case 2300:
          var e = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (e === void 0) {
        if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, this.createInterpolant === void 0)
          if (t !== this.DefaultInterpolation)
            this.setInterpolation(this.DefaultInterpolation);
          else
            throw Error(e);
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return this.createInterpolant = e, this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(t) {
      if (t !== 0)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] += t;
      return this;
    },
    scale: function(t) {
      if (t !== 1)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] *= t;
      return this;
    },
    trim: function(t, e) {
      for (var i = this.times, n = i.length, o = 0, l = n - 1; o !== n && i[o] < t; )
        ++o;
      for (; l !== -1 && i[l] > e; )
        --l;
      return ++l, (o !== 0 || l !== n) && (o >= l && (l = Math.max(l, 1), o = l - 1), t = this.getValueSize(), this.times = Wn.arraySlice(i, o, l), this.values = Wn.arraySlice(this.values, o * t, l * t)), this;
    },
    validate: function() {
      var t = !0, e = this.getValueSize();
      e - Math.floor(e) !== 0 && (console.error(
        "THREE.KeyframeTrack: Invalid value size in track.",
        this
      ), t = !1);
      var i = this.times;
      e = this.values;
      var n = i.length;
      n === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      for (var o = null, l = 0; l !== n; l++) {
        var f = i[l];
        if (typeof f == "number" && isNaN(f)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            l,
            f
          ), t = !1;
          break;
        }
        if (o !== null && o > f) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            l,
            f,
            o
          ), t = !1;
          break;
        }
        o = f;
      }
      if (e !== void 0 && Wn.isTypedArray(e)) {
        for (l = 0, i = e.length; l !== i; ++l)
          if (n = e[l], isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              l,
              n
            ), t = !1;
            break;
          }
      }
      return t;
    },
    optimize: function() {
      for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === 2302, o = 1, l = t.length - 1, f = 1; f < l; ++f) {
        var p = !1, y = t[f];
        if (y !== t[f + 1] && (f !== 1 || y !== y[0]))
          if (n)
            p = !0;
          else {
            var w = f * i, A = w - i, P = w + i;
            for (y = 0; y !== i; ++y) {
              var B = e[w + y];
              if (B !== e[A + y] || B !== e[P + y]) {
                p = !0;
                break;
              }
            }
          }
        if (p) {
          if (f !== o)
            for (t[o] = t[f], p = f * i, w = o * i, y = 0; y !== i; ++y)
              e[w + y] = e[p + y];
          ++o;
        }
      }
      if (0 < l) {
        for (t[o] = t[l], p = l * i, w = o * i, y = 0; y !== i; ++y)
          e[w + y] = e[p + y];
        ++o;
      }
      return o !== t.length && (this.times = Wn.arraySlice(t, 0, o), this.values = Wn.arraySlice(e, 0, o * i)), this;
    }
  }), Nl.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: Nl,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), Fl.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: Fl,
    ValueTypeName: "color"
  }), jr.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: jr,
    ValueTypeName: "number"
  }), ir.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: ir,
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, l = this.sampleValues, f = this.valueSize;
      for (t *= f, e = (i - e) / (n - e), i = t + f; t !== i; t += 4)
        d.slerpFlat(o, 0, l, t - f, l, t, e);
      return o;
    }
  }), ha.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: ha,
    ValueTypeName: "quaternion",
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodLinear: function(t) {
      return new ir(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: void 0
  }), Ul.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: Ul,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), ua.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: ua,
    ValueTypeName: "vector"
  }), Object.assign(gr, {
    parse: function(t) {
      for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), o = 0, l = i.length; o !== l; ++o)
        e.push(ec(i[o]).scale(n));
      return new gr(t.name, t.duration, e);
    },
    toJSON: function(t) {
      var e = [], i = t.tracks;
      t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid };
      for (var n = 0, o = i.length; n !== o; ++n)
        e.push(Un.toJSON(i[n]));
      return t;
    },
    CreateFromMorphTargetSequence: function(t, e, i, n) {
      for (var o = e.length, l = [], f = 0; f < o; f++) {
        var p = [], y = [];
        p.push((f + o - 1) % o, f, (f + 1) % o), y.push(0, 1, 0);
        var w = Wn.getKeyframeOrder(p);
        p = Wn.sortedArray(p, 1, w), y = Wn.sortedArray(y, 1, w), n || p[0] !== 0 || (p.push(o), y.push(y[0])), l.push(
          new jr(".morphTargetInfluences[" + e[f].name + "]", p, y).scale(1 / i)
        );
      }
      return new gr(t, -1, l);
    },
    findByName: function(t, e) {
      var i = t;
      for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)
        if (i[t].name === e)
          return i[t];
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(t, e, i) {
      for (var n = {}, o = /^([\w-]*?)([\d]+)$/, l = 0, f = t.length; l < f; l++) {
        var p = t[l], y = p.name.match(o);
        if (y && 1 < y.length) {
          var w = y[1];
          (y = n[w]) || (n[w] = y = []), y.push(p);
        }
      }
      t = [];
      for (w in n)
        t.push(gr.CreateFromMorphTargetSequence(w, n[w], e, i));
      return t;
    },
    parseAnimation: function(t, e) {
      if (!t)
        return console.error(
          "THREE.AnimationClip: No animation in JSONLoader data."
        ), null;
      var i = function($, rt, xt, gt, Ct) {
        if (xt.length !== 0) {
          var wt = [], Vt = [];
          Wn.flattenJSON(xt, wt, Vt, gt), wt.length !== 0 && Ct.push(new $(rt, wt, Vt));
        }
      }, n = [], o = t.name || "default", l = t.length || -1, f = t.fps || 30;
      t = t.hierarchy || [];
      for (var p = 0; p < t.length; p++) {
        var y = t[p].keys;
        if (y && y.length !== 0)
          if (y[0].morphTargets) {
            l = {};
            for (var w = 0; w < y.length; w++)
              if (y[w].morphTargets)
                for (var A = 0; A < y[w].morphTargets.length; A++)
                  l[y[w].morphTargets[A]] = -1;
            for (var P in l) {
              var B = [], H = [];
              for (A = 0; A !== y[w].morphTargets.length; ++A) {
                var q = y[w];
                B.push(q.time), H.push(q.morphTarget === P ? 1 : 0);
              }
              n.push(new jr(".morphTargetInfluence[" + P + "]", B, H));
            }
            l = l.length * (f || 1);
          } else
            w = ".bones[" + e[p].name + "]", i(ua, w + ".position", y, "pos", n), i(ha, w + ".quaternion", y, "rot", n), i(ua, w + ".scale", y, "scl", n);
      }
      return n.length === 0 ? null : new gr(o, l, n);
    }
  }), Object.assign(gr.prototype, {
    resetDuration: function() {
      for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
        var n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return this.duration = t, this;
    },
    trim: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    },
    validate: function() {
      for (var t = !0, e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    },
    optimize: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].optimize();
      return this;
    }
  });
  var yo = {
    enabled: !1,
    files: {},
    add: function(t, e) {
      this.enabled !== !1 && (this.files[t] = e);
    },
    get: function(t) {
      if (this.enabled !== !1)
        return this.files[t];
    },
    remove: function(t) {
      delete this.files[t];
    },
    clear: function() {
      this.files = {};
    }
  }, Kn = new Zo(), Lr = {};
  Object.assign(Lt.prototype, {
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var o = this, l = yo.get(t);
      if (l !== void 0)
        return o.manager.itemStart(t), setTimeout(function() {
          e && e(l), o.manager.itemEnd(t);
        }, 0), l;
      if (Lr[t] !== void 0)
        Lr[t].push({ onLoad: e, onProgress: i, onError: n });
      else {
        var f = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (f) {
          i = f[1];
          var p = !!f[2];
          f = f[3], f = decodeURIComponent(f), p && (f = atob(f));
          try {
            var y = (this.responseType || "").toLowerCase();
            switch (y) {
              case "arraybuffer":
              case "blob":
                var w = new Uint8Array(f.length);
                for (p = 0; p < f.length; p++)
                  w[p] = f.charCodeAt(p);
                var A = y === "blob" ? new Blob([w.buffer], { type: i }) : w.buffer;
                break;
              case "document":
                A = new DOMParser().parseFromString(f, i);
                break;
              case "json":
                A = JSON.parse(f);
                break;
              default:
                A = f;
            }
            setTimeout(function() {
              e && e(A), o.manager.itemEnd(t);
            }, 0);
          } catch (B) {
            setTimeout(function() {
              n && n(B), o.manager.itemError(t), o.manager.itemEnd(t);
            }, 0);
          }
        } else {
          Lr[t] = [], Lr[t].push({ onLoad: e, onProgress: i, onError: n });
          var P = new XMLHttpRequest();
          P.open("GET", t, !0), P.addEventListener(
            "load",
            function(B) {
              var H = this.response;
              yo.add(t, H);
              var q = Lr[t];
              if (delete Lr[t], this.status === 200 || this.status === 0) {
                this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var $ = 0, rt = q.length; $ < rt; $++) {
                  var xt = q[$];
                  xt.onLoad && xt.onLoad(H);
                }
              } else {
                for ($ = 0, rt = q.length; $ < rt; $++)
                  xt = q[$], xt.onError && xt.onError(B);
                o.manager.itemError(t);
              }
              o.manager.itemEnd(t);
            },
            !1
          ), P.addEventListener(
            "progress",
            function(B) {
              for (var H = Lr[t], q = 0, $ = H.length; q < $; q++) {
                var rt = H[q];
                rt.onProgress && rt.onProgress(B);
              }
            },
            !1
          ), P.addEventListener(
            "error",
            function(B) {
              var H = Lr[t];
              delete Lr[t];
              for (var q = 0, $ = H.length; q < $; q++) {
                var rt = H[q];
                rt.onError && rt.onError(B);
              }
              o.manager.itemError(t), o.manager.itemEnd(t);
            },
            !1
          ), P.addEventListener(
            "abort",
            function(B) {
              var H = Lr[t];
              delete Lr[t];
              for (var q = 0, $ = H.length; q < $; q++) {
                var rt = H[q];
                rt.onError && rt.onError(B);
              }
              o.manager.itemError(t), o.manager.itemEnd(t);
            },
            !1
          ), this.responseType !== void 0 && (P.responseType = this.responseType), this.withCredentials !== void 0 && (P.withCredentials = this.withCredentials), P.overrideMimeType && P.overrideMimeType(
            this.mimeType !== void 0 ? this.mimeType : "text/plain"
          );
          for (p in this.requestHeader)
            P.setRequestHeader(p, this.requestHeader[p]);
          P.send(null);
        }
        return o.manager.itemStart(t), P;
      }
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResponseType: function(t) {
      return this.responseType = t, this;
    },
    setWithCredentials: function(t) {
      return this.withCredentials = t, this;
    },
    setMimeType: function(t) {
      return this.mimeType = t, this;
    },
    setRequestHeader: function(t) {
      return this.requestHeader = t, this;
    }
  }), Object.assign(Qt.prototype, {
    load: function(t, e, i, n) {
      var o = this, l = new Lt(o.manager);
      l.setPath(o.path), l.load(
        t,
        function(f) {
          e(o.parse(JSON.parse(f)));
        },
        i,
        n
      );
    },
    parse: function(t, e) {
      for (var i = [], n = 0; n < t.length; n++) {
        var o = gr.parse(t[n]);
        i.push(o);
      }
      e(i);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Zt.prototype, {
    load: function(t, e, i, n) {
      function o(B) {
        y.load(
          t[B],
          function(H) {
            H = l._parser(H, !0), f[B] = {
              width: H.width,
              height: H.height,
              format: H.format,
              mipmaps: H.mipmaps
            }, w += 1, w === 6 && (H.mipmapCount === 1 && (p.minFilter = 1006), p.format = H.format, p.needsUpdate = !0, e && e(p));
          },
          i,
          n
        );
      }
      var l = this, f = [], p = new Ho();
      p.image = f;
      var y = new Lt(this.manager);
      if (y.setPath(this.path), y.setResponseType("arraybuffer"), Array.isArray(t))
        for (var w = 0, A = 0, P = t.length; A < P; ++A)
          o(A);
      else
        y.load(
          t,
          function(B) {
            if (B = l._parser(B, !0), B.isCubemap)
              for (var H = B.mipmaps.length / B.mipmapCount, q = 0; q < H; q++) {
                f[q] = { mipmaps: [] };
                for (var $ = 0; $ < B.mipmapCount; $++)
                  f[q].mipmaps.push(B.mipmaps[q * B.mipmapCount + $]), f[q].format = B.format, f[q].width = B.width, f[q].height = B.height;
              }
            else
              p.image.width = B.width, p.image.height = B.height, p.mipmaps = B.mipmaps;
            B.mipmapCount === 1 && (p.minFilter = 1006), p.format = B.format, p.needsUpdate = !0, e && e(p);
          },
          i,
          n
        );
      return p;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ue.prototype, {
    load: function(t, e, i, n) {
      var o = this, l = new O(), f = new Lt(this.manager);
      return f.setResponseType("arraybuffer"), f.setPath(this.path), f.load(
        t,
        function(p) {
          (p = o._parser(p)) && (p.image !== void 0 ? l.image = p.image : p.data !== void 0 && (l.image.width = p.width, l.image.height = p.height, l.image.data = p.data), l.wrapS = p.wrapS !== void 0 ? p.wrapS : 1001, l.wrapT = p.wrapT !== void 0 ? p.wrapT : 1001, l.magFilter = p.magFilter !== void 0 ? p.magFilter : 1006, l.minFilter = p.minFilter !== void 0 ? p.minFilter : 1008, l.anisotropy = p.anisotropy !== void 0 ? p.anisotropy : 1, p.format !== void 0 && (l.format = p.format), p.type !== void 0 && (l.type = p.type), p.mipmaps !== void 0 && (l.mipmaps = p.mipmaps), p.mipmapCount === 1 && (l.minFilter = 1006), l.needsUpdate = !0, e && e(l, p));
        },
        i,
        n
      ), l;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(si.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function o() {
        y.removeEventListener("load", o, !1), y.removeEventListener("error", l, !1), yo.add(t, this), e && e(this), f.manager.itemEnd(t);
      }
      function l(w) {
        y.removeEventListener("load", o, !1), y.removeEventListener("error", l, !1), n && n(w), f.manager.itemError(t), f.manager.itemEnd(t);
      }
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var f = this, p = yo.get(t);
      if (p !== void 0)
        return f.manager.itemStart(t), setTimeout(function() {
          e && e(p), f.manager.itemEnd(t);
        }, 0), p;
      var y = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      return y.addEventListener("load", o, !1), y.addEventListener("error", l, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (y.crossOrigin = this.crossOrigin), f.manager.itemStart(t), y.src = t, y;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(ki.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function o(y) {
        f.load(
          t[y],
          function(w) {
            l.images[y] = w, p++, p === 6 && (l.needsUpdate = !0, e && e(l));
          },
          void 0,
          n
        );
      }
      var l = new z(), f = new si(this.manager);
      f.setCrossOrigin(this.crossOrigin), f.setPath(this.path);
      var p = 0;
      for (i = 0; i < t.length; ++i)
        o(i);
      return l;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(ln.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = new g(), l = new si(this.manager);
      return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(
        t,
        function(f) {
          o.image = f, f = 0 < t.search(/\.jpe?g$/i) || t.search(/^data:image\/jpeg/) === 0, o.format = f ? 1022 : 1023, o.needsUpdate = !0, e !== void 0 && e(o);
        },
        i,
        n
      ), o;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ee.prototype, {
    getPoint: function() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    },
    getPointAt: function(t, e) {
      return t = this.getUtoTmapping(t), this.getPoint(t, e);
    },
    getPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return e;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPointAt(i / t));
      return e;
    },
    getLength: function() {
      var t = this.getLengths();
      return t[t.length - 1];
    },
    getLengths: function(t) {
      if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      var e = [], i = this.getPoint(0), n, o = 0;
      for (e.push(0), n = 1; n <= t; n++) {
        var l = this.getPoint(n / t);
        o += l.distanceTo(i), e.push(o), i = l;
      }
      return this.cacheArcLengths = e;
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.getLengths();
    },
    getUtoTmapping: function(t, e) {
      var i = this.getLengths(), n = i.length;
      e = e || t * i[n - 1];
      for (var o = 0, l = n - 1, f; o <= l; )
        if (t = Math.floor(o + (l - o) / 2), f = i[t] - e, 0 > f)
          o = t + 1;
        else if (0 < f)
          l = t - 1;
        else {
          l = t;
          break;
        }
      return t = l, i[t] === e ? t / (n - 1) : (o = i[t], (t + (e - o) / (i[t + 1] - o)) / (n - 1));
    },
    getTangent: function(t) {
      var e = t - 1e-4;
      return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize();
    },
    getTangentAt: function(t) {
      return t = this.getUtoTmapping(t), this.getTangent(t);
    },
    computeFrenetFrames: function(t, e) {
      var i = new u(), n = [], o = [], l = [], f = new u(), p = new c(), y;
      for (y = 0; y <= t; y++) {
        var w = y / t;
        n[y] = this.getTangentAt(w), n[y].normalize();
      }
      o[0] = new u(), l[0] = new u(), y = Number.MAX_VALUE, w = Math.abs(n[0].x);
      var A = Math.abs(n[0].y), P = Math.abs(n[0].z);
      for (w <= y && (y = w, i.set(1, 0, 0)), A <= y && (y = A, i.set(0, 1, 0)), P <= y && i.set(0, 0, 1), f.crossVectors(n[0], i).normalize(), o[0].crossVectors(n[0], f), l[0].crossVectors(n[0], o[0]), y = 1; y <= t; y++)
        o[y] = o[y - 1].clone(), l[y] = l[y - 1].clone(), f.crossVectors(n[y - 1], n[y]), f.length() > Number.EPSILON && (f.normalize(), i = Math.acos(fi.clamp(n[y - 1].dot(n[y]), -1, 1)), o[y].applyMatrix4(p.makeRotationAxis(f, i))), l[y].crossVectors(n[y], o[y]);
      if (e === !0)
        for (i = Math.acos(fi.clamp(o[0].dot(o[t]), -1, 1)), i /= t, 0 < n[0].dot(f.crossVectors(o[0], o[t])) && (i = -i), y = 1; y <= t; y++)
          o[y].applyMatrix4(p.makeRotationAxis(n[y], i * y)), l[y].crossVectors(n[y], o[y]);
      return { tangents: n, normals: o, binormals: l };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    },
    toJSON: function() {
      var t = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" }
      };
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    },
    fromJSON: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  }), Jn.prototype = Object.create(Ee.prototype), Jn.prototype.constructor = Jn, Jn.prototype.isEllipseCurve = !0, Jn.prototype.getPoint = function(t, e) {
    e = e || new s();
    for (var i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, o = Math.abs(n) < Number.EPSILON; 0 > n; )
      n += i;
    for (; n > i; )
      n -= i;
    n < Number.EPSILON && (n = o ? 0 : i), this.aClockwise !== !0 || o || (n = n === i ? -i : n - i), i = this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(i);
    var l = this.aY + this.yRadius * Math.sin(i);
    return this.aRotation !== 0 && (i = Math.cos(this.aRotation), n = Math.sin(this.aRotation), o = t - this.aX, l -= this.aY, t = o * i - l * n + this.aX, l = o * n + l * i + this.aY), e.set(t, l);
  }, Jn.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, Jn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }, Jn.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, ca.prototype = Object.create(Jn.prototype), ca.prototype.constructor = ca, ca.prototype.isArcCurve = !0;
  var Mn = new u(), cl = new nr(), Yl = new nr(), Rr = new nr();
  Pn.prototype = Object.create(Ee.prototype), Pn.prototype.constructor = Pn, Pn.prototype.isCatmullRomCurve3 = !0, Pn.prototype.getPoint = function(t, e) {
    e = e || new u();
    var i = this.points, n = i.length;
    t *= n - (this.closed ? 0 : 1);
    var o = Math.floor(t);
    if (t -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : t === 0 && o === n - 1 && (o = n - 2, t = 1), this.closed || 0 < o)
      var l = i[(o - 1) % n];
    else
      Mn.subVectors(i[0], i[1]).add(i[0]), l = Mn;
    var f = i[o % n], p = i[(o + 1) % n];
    if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (Mn.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Mn), this.curveType === "centripetal" || this.curveType === "chordal") {
      var y = this.curveType === "chordal" ? 0.5 : 0.25;
      n = Math.pow(l.distanceToSquared(f), y), o = Math.pow(f.distanceToSquared(p), y), y = Math.pow(p.distanceToSquared(i), y), 1e-4 > o && (o = 1), 1e-4 > n && (n = o), 1e-4 > y && (y = o), cl.initNonuniformCatmullRom(l.x, f.x, p.x, i.x, n, o, y), Yl.initNonuniformCatmullRom(l.y, f.y, p.y, i.y, n, o, y), Rr.initNonuniformCatmullRom(l.z, f.z, p.z, i.z, n, o, y);
    } else
      this.curveType === "catmullrom" && (cl.initCatmullRom(l.x, f.x, p.x, i.x, this.tension), Yl.initCatmullRom(l.y, f.y, p.y, i.y, this.tension), Rr.initCatmullRom(l.z, f.z, p.z, i.z, this.tension));
    return e.set(cl.calc(t), Yl.calc(t), Rr.calc(t)), e;
  }, Pn.prototype.copy = function(t) {
    Ee.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, Pn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }, Pn.prototype.fromJSON = function(t) {
    Ee.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new u().fromArray(n));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, rr.prototype = Object.create(Ee.prototype), rr.prototype.constructor = rr, rr.prototype.isCubicBezierCurve = !0, rr.prototype.getPoint = function(t, e) {
    e = e || new s();
    var i = this.v0, n = this.v1, o = this.v2, l = this.v3;
    return e.set(Jo(t, i.x, n.x, o.x, l.x), Jo(t, i.y, n.y, o.y, l.y)), e;
  }, rr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, rr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, rr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, wi.prototype = Object.create(Ee.prototype), wi.prototype.constructor = wi, wi.prototype.isCubicBezierCurve3 = !0, wi.prototype.getPoint = function(t, e) {
    e = e || new u();
    var i = this.v0, n = this.v1, o = this.v2, l = this.v3;
    return e.set(
      Jo(t, i.x, n.x, o.x, l.x),
      Jo(t, i.y, n.y, o.y, l.y),
      Jo(t, i.z, n.z, o.z, l.z)
    ), e;
  }, wi.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, wi.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, wi.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, or.prototype = Object.create(Ee.prototype), or.prototype.constructor = or, or.prototype.isLineCurve = !0, or.prototype.getPoint = function(t, e) {
    return e = e || new s(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, or.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, or.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
  }, or.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, or.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, or.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Ar.prototype = Object.create(Ee.prototype), Ar.prototype.constructor = Ar, Ar.prototype.isLineCurve3 = !0, Ar.prototype.getPoint = function(t, e) {
    return e = e || new u(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, Ar.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, Ar.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Ar.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Ar.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, sr.prototype = Object.create(Ee.prototype), sr.prototype.constructor = sr, sr.prototype.isQuadraticBezierCurve = !0, sr.prototype.getPoint = function(t, e) {
    e = e || new s();
    var i = this.v0, n = this.v1, o = this.v2;
    return e.set(co(t, i.x, n.x, o.x), co(t, i.y, n.y, o.y)), e;
  }, sr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, sr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, sr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, fo.prototype = Object.create(Ee.prototype), fo.prototype.constructor = fo, fo.prototype.isQuadraticBezierCurve3 = !0, fo.prototype.getPoint = function(t, e) {
    e = e || new u();
    var i = this.v0, n = this.v1, o = this.v2;
    return e.set(co(t, i.x, n.x, o.x), co(t, i.y, n.y, o.y), co(t, i.z, n.z, o.z)), e;
  }, fo.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, fo.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, fo.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Xr.prototype = Object.create(Ee.prototype), Xr.prototype.constructor = Xr, Xr.prototype.isSplineCurve = !0, Xr.prototype.getPoint = function(t, e) {
    e = e || new s();
    var i = this.points, n = (i.length - 1) * t;
    t = Math.floor(n), n -= t;
    var o = i[t === 0 ? t : t - 1], l = i[t], f = i[t > i.length - 2 ? i.length - 1 : t + 1];
    return i = i[t > i.length - 3 ? i.length - 1 : t + 2], e.set(hu(n, o.x, l.x, f.x, i.x), hu(n, o.y, l.y, f.y, i.y)), e;
  }, Xr.prototype.copy = function(t) {
    Ee.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this;
  }, Xr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t;
  }, Xr.prototype.fromJSON = function(t) {
    Ee.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new s().fromArray(n));
    }
    return this;
  };
  var Zl = Object.freeze({
    ArcCurve: ca,
    CatmullRomCurve3: Pn,
    CubicBezierCurve: rr,
    CubicBezierCurve3: wi,
    EllipseCurve: Jn,
    LineCurve: or,
    LineCurve3: Ar,
    QuadraticBezierCurve: sr,
    QuadraticBezierCurve3: fo,
    SplineCurve: Xr
  });
  Oo.prototype = Object.assign(Object.create(Ee.prototype), {
    constructor: Oo,
    add: function(t) {
      this.curves.push(t);
    },
    closePath: function() {
      var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new or(e, t));
    },
    getPoint: function(t) {
      var e = t * this.getLength(), i = this.getCurveLengths();
      for (t = 0; t < i.length; ) {
        if (i[t] >= e)
          return e = i[t] - e, t = this.curves[t], i = t.getLength(), t.getPointAt(i === 0 ? 0 : 1 - e / i);
        t++;
      }
      return null;
    },
    getLength: function() {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
        e += this.curves[i].getLength(), t.push(e);
      return this.cacheLengths = t;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 40);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]), e;
    },
    getPoints: function(t) {
      t = t || 12;
      for (var e = [], i, n = 0, o = this.curves; n < o.length; n++) {
        var l = o[n];
        l = l.getPoints(
          l && l.isEllipseCurve ? 2 * t : l && (l.isLineCurve || l.isLineCurve3) ? 1 : l && l.isSplineCurve ? t * l.points.length : t
        );
        for (var f = 0; f < l.length; f++) {
          var p = l[f];
          i && i.equals(p) || (e.push(p), i = p);
        }
      }
      return this.autoClose && 1 < e.length && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
    },
    copy: function(t) {
      Ee.prototype.copy.call(this, t), this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++)
        this.curves.push(t.curves[e].clone());
      return this.autoClose = t.autoClose, this;
    },
    toJSON: function() {
      var t = Ee.prototype.toJSON.call(this);
      t.autoClose = this.autoClose, t.curves = [];
      for (var e = 0, i = this.curves.length; e < i; e++)
        t.curves.push(this.curves[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      Ee.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var n = t.curves[e];
        this.curves.push(new Zl[n.type]().fromJSON(n));
      }
      return this;
    }
  }), ar.prototype = Object.assign(Object.create(Oo.prototype), {
    constructor: ar,
    setFromPoints: function(t) {
      this.moveTo(t[0].x, t[0].y);
      for (var e = 1, i = t.length; e < i; e++)
        this.lineTo(t[e].x, t[e].y);
    },
    moveTo: function(t, e) {
      this.currentPoint.set(t, e);
    },
    lineTo: function(t, e) {
      var i = new or(this.currentPoint.clone(), new s(t, e));
      this.curves.push(i), this.currentPoint.set(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      t = new sr(this.currentPoint.clone(), new s(t, e), new s(i, n)), this.curves.push(t), this.currentPoint.set(i, n);
    },
    bezierCurveTo: function(t, e, i, n, o, l) {
      t = new rr(
        this.currentPoint.clone(),
        new s(t, e),
        new s(i, n),
        new s(o, l)
      ), this.curves.push(t), this.currentPoint.set(o, l);
    },
    splineThru: function(t) {
      var e = [this.currentPoint.clone()].concat(t);
      e = new Xr(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
    },
    arc: function(t, e, i, n, o, l) {
      this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, o, l);
    },
    absarc: function(t, e, i, n, o, l) {
      this.absellipse(t, e, i, i, n, o, l);
    },
    ellipse: function(t, e, i, n, o, l, f, p) {
      this.absellipse(
        t + this.currentPoint.x,
        e + this.currentPoint.y,
        i,
        n,
        o,
        l,
        f,
        p
      );
    },
    absellipse: function(t, e, i, n, o, l, f, p) {
      t = new Jn(t, e, i, n, o, l, f, p), 0 < this.curves.length && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t);
    },
    copy: function(t) {
      return Oo.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
    },
    toJSON: function() {
      var t = Oo.prototype.toJSON.call(this);
      return t.currentPoint = this.currentPoint.toArray(), t;
    },
    fromJSON: function(t) {
      return Oo.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
    }
  }), $n.prototype = Object.assign(Object.create(ar.prototype), {
    constructor: $n,
    getPointsHoles: function(t) {
      for (var e = [], i = 0, n = this.holes.length; i < n; i++)
        e[i] = this.holes[i].getPoints(t);
      return e;
    },
    extractPoints: function(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    },
    copy: function(t) {
      ar.prototype.copy.call(this, t), this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++)
        this.holes.push(t.holes[e].clone());
      return this;
    },
    toJSON: function() {
      var t = ar.prototype.toJSON.call(this);
      t.uuid = this.uuid, t.holes = [];
      for (var e = 0, i = this.holes.length; e < i; e++)
        t.holes.push(this.holes[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      ar.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++) {
        var n = t.holes[e];
        this.holes.push(new ar().fromJSON(n));
      }
      return this;
    }
  }), $i.prototype = Object.assign(Object.create(N.prototype), {
    constructor: $i,
    isLight: !0,
    copy: function(t) {
      return N.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
    },
    toJSON: function(t) {
      return t = N.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
  }), Za.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Za,
    isHemisphereLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    }
  }), Object.assign(po.prototype, {
    copy: function(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var t = {};
      return this.bias !== 0 && (t.bias = this.bias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
  }), Ja.prototype = Object.assign(Object.create(po.prototype), {
    constructor: Ja,
    isSpotLightShadow: !0,
    update: function(t) {
      var e = this.camera, i = 2 * fi.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height;
      t = t.distance || e.far, (i !== e.fov || n !== e.aspect || t !== e.far) && (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix());
    }
  }), $a.prototype = Object.assign(Object.create($i.prototype), {
    constructor: $a,
    isSpotLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), Cs.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Cs,
    isPointLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }), fa.prototype = Object.assign(Object.create(Be.prototype), {
    constructor: fa,
    isOrthographicCamera: !0,
    copy: function(t, e) {
      return Be.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
    },
    setViewOffset: function(t, e, i, n, o, l) {
      this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, o = i - t;
      if (i += t, t = n + e, e = n - e, this.view !== null && this.view.enabled) {
        i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight);
        var l = (this.right - this.left) / this.view.width;
        n = (this.top - this.bottom) / this.view.height, o += this.view.offsetX / i * l, i = o + this.view.width / i * l, t -= this.view.offsetY / e * n, e = t - this.view.height / e * n;
      }
      this.projectionMatrix.makeOrthographic(o, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = N.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }), $o.prototype = Object.assign(Object.create(po.prototype), {
    constructor: $o
  }), mo.prototype = Object.assign(Object.create($i.prototype), {
    constructor: mo,
    isDirectionalLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), As.prototype = Object.assign(Object.create($i.prototype), {
    constructor: As,
    isAmbientLight: !0
  }), Gl.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Gl,
    isRectAreaLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
    },
    toJSON: function(t) {
      return t = $i.prototype.toJSON.call(this, t), t.object.width = this.width, t.object.height = this.height, t;
    }
  }), Object.assign(Hl.prototype, {
    load: function(t, e, i, n) {
      var o = this, l = new Lt(o.manager);
      l.setPath(o.path), l.load(
        t,
        function(f) {
          e(o.parse(JSON.parse(f)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      function e(f) {
        return i[f] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", f), i[f];
      }
      var i = this.textures, n = new _u[t.type]();
      if (t.uuid !== void 0 && (n.uuid = t.uuid), t.name !== void 0 && (n.name = t.name), t.color !== void 0 && n.color.setHex(t.color), t.roughness !== void 0 && (n.roughness = t.roughness), t.metalness !== void 0 && (n.metalness = t.metalness), t.emissive !== void 0 && n.emissive.setHex(t.emissive), t.specular !== void 0 && n.specular.setHex(t.specular), t.shininess !== void 0 && (n.shininess = t.shininess), t.clearCoat !== void 0 && (n.clearCoat = t.clearCoat), t.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = t.clearCoatRoughness), t.vertexColors !== void 0 && (n.vertexColors = t.vertexColors), t.fog !== void 0 && (n.fog = t.fog), t.flatShading !== void 0 && (n.flatShading = t.flatShading), t.blending !== void 0 && (n.blending = t.blending), t.combine !== void 0 && (n.combine = t.combine), t.side !== void 0 && (n.side = t.side), t.opacity !== void 0 && (n.opacity = t.opacity), t.transparent !== void 0 && (n.transparent = t.transparent), t.alphaTest !== void 0 && (n.alphaTest = t.alphaTest), t.depthTest !== void 0 && (n.depthTest = t.depthTest), t.depthWrite !== void 0 && (n.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (n.colorWrite = t.colorWrite), t.wireframe !== void 0 && (n.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (n.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (n.rotation = t.rotation), t.linewidth !== 1 && (n.linewidth = t.linewidth), t.dashSize !== void 0 && (n.dashSize = t.dashSize), t.gapSize !== void 0 && (n.gapSize = t.gapSize), t.scale !== void 0 && (n.scale = t.scale), t.polygonOffset !== void 0 && (n.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (n.skinning = t.skinning), t.morphTargets !== void 0 && (n.morphTargets = t.morphTargets), t.dithering !== void 0 && (n.dithering = t.dithering), t.visible !== void 0 && (n.visible = t.visible), t.userData !== void 0 && (n.userData = t.userData), t.uniforms !== void 0)
        for (var o in t.uniforms) {
          var l = t.uniforms[o];
          switch (n.uniforms[o] = {}, l.type) {
            case "t":
              n.uniforms[o].value = e(l.value);
              break;
            case "c":
              n.uniforms[o].value = new L().setHex(l.value);
              break;
            case "v2":
              n.uniforms[o].value = new s().fromArray(l.value);
              break;
            case "v3":
              n.uniforms[o].value = new u().fromArray(l.value);
              break;
            case "v4":
              n.uniforms[o].value = new _().fromArray(l.value);
              break;
            case "m4":
              n.uniforms[o].value = new c().fromArray(l.value);
              break;
            default:
              n.uniforms[o].value = l.value;
          }
        }
      return t.defines !== void 0 && (n.defines = t.defines), t.vertexShader !== void 0 && (n.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (n.fragmentShader = t.fragmentShader), t.shading !== void 0 && (n.flatShading = t.shading === 1), t.size !== void 0 && (n.size = t.size), t.sizeAttenuation !== void 0 && (n.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (n.map = e(t.map)), t.alphaMap !== void 0 && (n.alphaMap = e(t.alphaMap), n.transparent = !0), t.bumpMap !== void 0 && (n.bumpMap = e(t.bumpMap)), t.bumpScale !== void 0 && (n.bumpScale = t.bumpScale), t.normalMap !== void 0 && (n.normalMap = e(t.normalMap)), t.normalMapType !== void 0 && (n.normalMapType = t.normalMapType), t.normalScale !== void 0 && (o = t.normalScale, Array.isArray(o) === !1 && (o = [o, o]), n.normalScale = new s().fromArray(o)), t.displacementMap !== void 0 && (n.displacementMap = e(t.displacementMap)), t.displacementScale !== void 0 && (n.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (n.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (n.roughnessMap = e(t.roughnessMap)), t.metalnessMap !== void 0 && (n.metalnessMap = e(t.metalnessMap)), t.emissiveMap !== void 0 && (n.emissiveMap = e(t.emissiveMap)), t.emissiveIntensity !== void 0 && (n.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (n.specularMap = e(t.specularMap)), t.envMap !== void 0 && (n.envMap = e(t.envMap)), t.envMapIntensity !== void 0 && (n.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (n.reflectivity = t.reflectivity), t.lightMap !== void 0 && (n.lightMap = e(t.lightMap)), t.lightMapIntensity !== void 0 && (n.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (n.aoMap = e(t.aoMap)), t.aoMapIntensity !== void 0 && (n.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (n.gradientMap = e(t.gradientMap)), n;
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setTextures: function(t) {
      return this.textures = t, this;
    }
  });
  var Ds = {
    decodeText: function(t) {
      if (typeof TextDecoder < "u")
        return new TextDecoder().decode(t);
      for (var e = "", i = 0, n = t.length; i < n; i++)
        e += String.fromCharCode(t[i]);
      return decodeURIComponent(escape(e));
    },
    extractUrlBase: function(t) {
      var e = t.lastIndexOf("/");
      return e === -1 ? "./" : t.substr(0, e + 1);
    }
  };
  Object.assign(wh.prototype, {
    load: function(t, e, i, n) {
      var o = this, l = new Lt(o.manager);
      l.setPath(o.path), l.load(
        t,
        function(f) {
          e(o.parse(JSON.parse(f)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      var e = new Ft(), i = t.data.index;
      i !== void 0 && (i = new is[i.type](i.array), e.setIndex(new J(i, 1)));
      var n = t.data.attributes;
      for (l in n) {
        var o = n[l];
        i = new is[o.type](o.array), e.addAttribute(l, new J(i, o.itemSize, o.normalized));
      }
      var l = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (l !== void 0)
        for (i = 0, n = l.length; i !== n; ++i)
          o = l[i], e.addGroup(o.start, o.count, o.materialIndex);
      return t = t.data.boundingSphere, t !== void 0 && (l = new u(), t.center !== void 0 && l.fromArray(t.center), e.boundingSphere = new D(l, t.radius)), e;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var is = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  Io.Handlers = {
    handlers: [],
    add: function(t, e) {
      this.handlers.push(t, e);
    },
    get: function(t) {
      for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
        var o = e[i + 1];
        if (e[i].test(t))
          return o;
      }
      return null;
    }
  }, Object.assign(Io.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {
    },
    onLoadProgress: function() {
    },
    onLoadComplete: function() {
    },
    initMaterials: function(t, e, i) {
      for (var n = [], o = 0; o < t.length; ++o)
        n[o] = this.createMaterial(t[o], e, i);
      return n;
    },
    createMaterial: function() {
      var t = {
        NoBlending: 0,
        NormalBlending: 1,
        AdditiveBlending: 2,
        SubtractiveBlending: 3,
        MultiplyBlending: 4,
        CustomBlending: 5
      }, e = new L(), i = new ln(), n = new Hl();
      return function(o, l, f) {
        function p(B, H, q, $, rt) {
          B = l + B;
          var xt = Io.Handlers.get(B);
          return xt !== null ? B = xt.load(B) : (i.setCrossOrigin(f), B = i.load(B)), H !== void 0 && (B.repeat.fromArray(H), H[0] !== 1 && (B.wrapS = 1e3), H[1] !== 1 && (B.wrapT = 1e3)), q !== void 0 && B.offset.fromArray(q), $ !== void 0 && ($[0] === "repeat" && (B.wrapS = 1e3), $[0] === "mirror" && (B.wrapS = 1002), $[1] === "repeat" && (B.wrapT = 1e3), $[1] === "mirror" && (B.wrapT = 1002)), rt !== void 0 && (B.anisotropy = rt), H = fi.generateUUID(), y[H] = B, H;
        }
        var y = {}, w = { uuid: fi.generateUUID(), type: "MeshLambertMaterial" }, A;
        for (A in o) {
          var P = o[A];
          switch (A) {
            case "DbgColor":
            case "DbgIndex":
            case "opticalDensity":
            case "illumination":
              break;
            case "DbgName":
              w.name = P;
              break;
            case "blending":
              w.blending = t[P];
              break;
            case "colorAmbient":
            case "mapAmbient":
              console.warn(
                "THREE.Loader.createMaterial:",
                A,
                "is no longer supported."
              );
              break;
            case "colorDiffuse":
              w.color = e.fromArray(P).getHex();
              break;
            case "colorSpecular":
              w.specular = e.fromArray(P).getHex();
              break;
            case "colorEmissive":
              w.emissive = e.fromArray(P).getHex();
              break;
            case "specularCoef":
              w.shininess = P;
              break;
            case "shading":
              P.toLowerCase() === "basic" && (w.type = "MeshBasicMaterial"), P.toLowerCase() === "phong" && (w.type = "MeshPhongMaterial"), P.toLowerCase() === "standard" && (w.type = "MeshStandardMaterial");
              break;
            case "mapDiffuse":
              w.map = p(
                P,
                o.mapDiffuseRepeat,
                o.mapDiffuseOffset,
                o.mapDiffuseWrap,
                o.mapDiffuseAnisotropy
              );
              break;
            case "mapDiffuseRepeat":
            case "mapDiffuseOffset":
            case "mapDiffuseWrap":
            case "mapDiffuseAnisotropy":
              break;
            case "mapEmissive":
              w.emissiveMap = p(
                P,
                o.mapEmissiveRepeat,
                o.mapEmissiveOffset,
                o.mapEmissiveWrap,
                o.mapEmissiveAnisotropy
              );
              break;
            case "mapEmissiveRepeat":
            case "mapEmissiveOffset":
            case "mapEmissiveWrap":
            case "mapEmissiveAnisotropy":
              break;
            case "mapLight":
              w.lightMap = p(
                P,
                o.mapLightRepeat,
                o.mapLightOffset,
                o.mapLightWrap,
                o.mapLightAnisotropy
              );
              break;
            case "mapLightRepeat":
            case "mapLightOffset":
            case "mapLightWrap":
            case "mapLightAnisotropy":
              break;
            case "mapAO":
              w.aoMap = p(
                P,
                o.mapAORepeat,
                o.mapAOOffset,
                o.mapAOWrap,
                o.mapAOAnisotropy
              );
              break;
            case "mapAORepeat":
            case "mapAOOffset":
            case "mapAOWrap":
            case "mapAOAnisotropy":
              break;
            case "mapBump":
              w.bumpMap = p(
                P,
                o.mapBumpRepeat,
                o.mapBumpOffset,
                o.mapBumpWrap,
                o.mapBumpAnisotropy
              );
              break;
            case "mapBumpScale":
              w.bumpScale = P;
              break;
            case "mapBumpRepeat":
            case "mapBumpOffset":
            case "mapBumpWrap":
            case "mapBumpAnisotropy":
              break;
            case "mapNormal":
              w.normalMap = p(
                P,
                o.mapNormalRepeat,
                o.mapNormalOffset,
                o.mapNormalWrap,
                o.mapNormalAnisotropy
              );
              break;
            case "mapNormalFactor":
              w.normalScale = P;
              break;
            case "mapNormalRepeat":
            case "mapNormalOffset":
            case "mapNormalWrap":
            case "mapNormalAnisotropy":
              break;
            case "mapSpecular":
              w.specularMap = p(
                P,
                o.mapSpecularRepeat,
                o.mapSpecularOffset,
                o.mapSpecularWrap,
                o.mapSpecularAnisotropy
              );
              break;
            case "mapSpecularRepeat":
            case "mapSpecularOffset":
            case "mapSpecularWrap":
            case "mapSpecularAnisotropy":
              break;
            case "mapMetalness":
              w.metalnessMap = p(
                P,
                o.mapMetalnessRepeat,
                o.mapMetalnessOffset,
                o.mapMetalnessWrap,
                o.mapMetalnessAnisotropy
              );
              break;
            case "mapMetalnessRepeat":
            case "mapMetalnessOffset":
            case "mapMetalnessWrap":
            case "mapMetalnessAnisotropy":
              break;
            case "mapRoughness":
              w.roughnessMap = p(
                P,
                o.mapRoughnessRepeat,
                o.mapRoughnessOffset,
                o.mapRoughnessWrap,
                o.mapRoughnessAnisotropy
              );
              break;
            case "mapRoughnessRepeat":
            case "mapRoughnessOffset":
            case "mapRoughnessWrap":
            case "mapRoughnessAnisotropy":
              break;
            case "mapAlpha":
              w.alphaMap = p(
                P,
                o.mapAlphaRepeat,
                o.mapAlphaOffset,
                o.mapAlphaWrap,
                o.mapAlphaAnisotropy
              );
              break;
            case "mapAlphaRepeat":
            case "mapAlphaOffset":
            case "mapAlphaWrap":
            case "mapAlphaAnisotropy":
              break;
            case "flipSided":
              w.side = 1;
              break;
            case "doubleSided":
              w.side = 2;
              break;
            case "transparency":
              console.warn(
                "THREE.Loader.createMaterial: transparency has been renamed to opacity"
              ), w.opacity = P;
              break;
            case "depthTest":
            case "depthWrite":
            case "colorWrite":
            case "opacity":
            case "reflectivity":
            case "transparent":
            case "visible":
            case "wireframe":
              w[A] = P;
              break;
            case "vertexColors":
              P === !0 && (w.vertexColors = 2), P === "face" && (w.vertexColors = 1);
              break;
            default:
              console.error("THREE.Loader.createMaterial: Unsupported", A, P);
          }
        }
        return w.type === "MeshBasicMaterial" && delete w.emissive, w.type !== "MeshPhongMaterial" && delete w.specular, 1 > w.opacity && (w.transparent = !0), n.setTextures(y), n.parse(w);
      };
    }()
  }), Object.assign(Ps.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = this, l = this.path === void 0 ? Ds.extractUrlBase(t) : this.path, f = new Lt(this.manager);
      f.setPath(this.path), f.setWithCredentials(this.withCredentials), f.load(
        t,
        function(p) {
          p = JSON.parse(p);
          var y = p.metadata;
          if (y !== void 0 && (y = y.type, y !== void 0 && y.toLowerCase() === "object")) {
            console.error(
              "THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead."
            );
            return;
          }
          p = o.parse(p, l), e(p.geometry, p.materials);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function() {
      return function(t, e) {
        t.data !== void 0 && (t = t.data), t.scale = t.scale !== void 0 ? 1 / t.scale : 1;
        var i = new j(), n = t, o, l, f, p = n.faces, y = n.vertices, w = n.normals, A = n.colors, P = n.scale, B = 0;
        if (n.uvs !== void 0) {
          for (o = 0; o < n.uvs.length; o++)
            n.uvs[o].length && B++;
          for (o = 0; o < B; o++)
            i.faceVertexUvs[o] = [];
        }
        var H = 0;
        for (f = y.length; H < f; )
          o = new u(), o.x = y[H++] * P, o.y = y[H++] * P, o.z = y[H++] * P, i.vertices.push(o);
        for (H = 0, f = p.length; H < f; ) {
          y = p[H++];
          var q = y & 1, $ = y & 2;
          o = y & 8;
          var rt = y & 16, xt = y & 32;
          if (P = y & 64, y &= 128, q) {
            q = new R(), q.a = p[H], q.b = p[H + 1], q.c = p[H + 3];
            var gt = new R();
            if (gt.a = p[H + 1], gt.b = p[H + 2], gt.c = p[H + 3], H += 4, $ && ($ = p[H++], q.materialIndex = $, gt.materialIndex = $), $ = i.faces.length, o)
              for (o = 0; o < B; o++) {
                var Ct = n.uvs[o];
                for (i.faceVertexUvs[o][$] = [], i.faceVertexUvs[o][$ + 1] = [], l = 0; 4 > l; l++) {
                  var wt = p[H++], Vt = Ct[2 * wt];
                  wt = Ct[2 * wt + 1], Vt = new s(Vt, wt), l !== 2 && i.faceVertexUvs[o][$].push(Vt), l !== 0 && i.faceVertexUvs[o][$ + 1].push(Vt);
                }
              }
            if (rt && (rt = 3 * p[H++], q.normal.set(w[rt++], w[rt++], w[rt]), gt.normal.copy(q.normal)), xt)
              for (o = 0; 4 > o; o++)
                rt = 3 * p[H++], xt = new u(w[rt++], w[rt++], w[rt]), o !== 2 && q.vertexNormals.push(xt), o !== 0 && gt.vertexNormals.push(xt);
            if (P && (P = p[H++], P = A[P], q.color.setHex(P), gt.color.setHex(P)), y)
              for (o = 0; 4 > o; o++)
                P = p[H++], P = A[P], o !== 2 && q.vertexColors.push(new L(P)), o !== 0 && gt.vertexColors.push(new L(P));
            i.faces.push(q), i.faces.push(gt);
          } else {
            if (q = new R(), q.a = p[H++], q.b = p[H++], q.c = p[H++], $ && ($ = p[H++], q.materialIndex = $), $ = i.faces.length, o)
              for (o = 0; o < B; o++)
                for (Ct = n.uvs[o], i.faceVertexUvs[o][$] = [], l = 0; 3 > l; l++)
                  wt = p[H++], Vt = Ct[2 * wt], wt = Ct[2 * wt + 1], Vt = new s(Vt, wt), i.faceVertexUvs[o][$].push(Vt);
            if (rt && (rt = 3 * p[H++], q.normal.set(w[rt++], w[rt++], w[rt])), xt)
              for (o = 0; 3 > o; o++)
                rt = 3 * p[H++], xt = new u(w[rt++], w[rt++], w[rt]), q.vertexNormals.push(xt);
            if (P && (P = p[H++], q.color.setHex(A[P])), y)
              for (o = 0; 3 > o; o++)
                P = p[H++], q.vertexColors.push(new L(A[P]));
            i.faces.push(q);
          }
        }
        if (n = t, H = n.influencesPerVertex !== void 0 ? n.influencesPerVertex : 2, n.skinWeights)
          for (f = 0, p = n.skinWeights.length; f < p; f += H)
            i.skinWeights.push(
              new _(
                n.skinWeights[f],
                1 < H ? n.skinWeights[f + 1] : 0,
                2 < H ? n.skinWeights[f + 2] : 0,
                3 < H ? n.skinWeights[f + 3] : 0
              )
            );
        if (n.skinIndices)
          for (f = 0, p = n.skinIndices.length; f < p; f += H)
            i.skinIndices.push(
              new _(
                n.skinIndices[f],
                1 < H ? n.skinIndices[f + 1] : 0,
                2 < H ? n.skinIndices[f + 2] : 0,
                3 < H ? n.skinIndices[f + 3] : 0
              )
            );
        if (i.bones = n.bones, i.bones && 0 < i.bones.length && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && console.warn(
          "When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match."
        ), f = t, p = f.scale, f.morphTargets !== void 0)
          for (n = 0, H = f.morphTargets.length; n < H; n++)
            for (i.morphTargets[n] = {}, i.morphTargets[n].name = f.morphTargets[n].name, i.morphTargets[n].vertices = [], w = i.morphTargets[n].vertices, A = f.morphTargets[n].vertices, B = 0, y = A.length; B < y; B += 3)
              P = new u(), P.x = A[B] * p, P.y = A[B + 1] * p, P.z = A[B + 2] * p, w.push(P);
        if (f.morphColors !== void 0 && 0 < f.morphColors.length)
          for (console.warn(
            'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
          ), p = i.faces, f = f.morphColors[0].colors, n = 0, H = p.length; n < H; n++)
            p[n].color.fromArray(f, 3 * n);
        for (f = t, n = [], H = [], f.animation !== void 0 && H.push(f.animation), f.animations !== void 0 && (f.animations.length ? H = H.concat(f.animations) : H.push(f.animations)), f = 0; f < H.length; f++)
          (p = gr.parseAnimation(H[f], i.bones)) && n.push(p);
        return i.morphTargets && (H = gr.CreateClipsFromMorphTargetSequences(i.morphTargets, 10), n = n.concat(H)), 0 < n.length && (i.animations = n), i.computeFaceNormals(), i.computeBoundingSphere(), t.materials === void 0 || t.materials.length === 0 ? { geometry: i } : (t = Io.prototype.initMaterials(
          t.materials,
          this.resourcePath || e,
          this.crossOrigin
        ), { geometry: i, materials: t });
      };
    }()
  }), Object.assign(Ka.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = this, l = this.path === void 0 ? Ds.extractUrlBase(t) : this.path;
      this.resourcePath = this.resourcePath || l, l = new Lt(o.manager), l.setPath(this.path), l.load(
        t,
        function(f) {
          var p = null;
          try {
            p = JSON.parse(f);
          } catch (y) {
            n !== void 0 && n(y), console.error(
              "THREE:ObjectLoader: Can't parse " + t + ".",
              y.message
            );
            return;
          }
          f = p.metadata, f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry" ? console.error(
            "THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead."
          ) : o.parse(p, e);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function(t, e) {
      var i = this.parseShape(t.shapes);
      i = this.parseGeometries(t.geometries, i);
      var n = this.parseImages(t.images, function() {
        e !== void 0 && e(o);
      });
      n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n);
      var o = this.parseObject(t.object, i, n);
      return t.animations && (o.animations = this.parseAnimations(t.animations)), t.images !== void 0 && t.images.length !== 0 || e === void 0 || e(o), o;
    },
    parseShape: function(t) {
      var e = {};
      if (t !== void 0)
        for (var i = 0, n = t.length; i < n; i++) {
          var o = new $n().fromJSON(t[i]);
          e[o.uuid] = o;
        }
      return e;
    },
    parseGeometries: function(t, e) {
      var i = {};
      if (t !== void 0)
        for (var n = new Ps(), o = new wh(), l = 0, f = t.length; l < f; l++) {
          var p = t[l];
          switch (p.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              var y = new dn[p.type](
                p.width,
                p.height,
                p.widthSegments,
                p.heightSegments
              );
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
              y = new dn[p.type](
                p.width,
                p.height,
                p.depth,
                p.widthSegments,
                p.heightSegments,
                p.depthSegments
              );
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              y = new dn[p.type](
                p.radius,
                p.segments,
                p.thetaStart,
                p.thetaLength
              );
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              y = new dn[p.type](
                p.radiusTop,
                p.radiusBottom,
                p.height,
                p.radialSegments,
                p.heightSegments,
                p.openEnded,
                p.thetaStart,
                p.thetaLength
              );
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              y = new dn[p.type](
                p.radius,
                p.height,
                p.radialSegments,
                p.heightSegments,
                p.openEnded,
                p.thetaStart,
                p.thetaLength
              );
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              y = new dn[p.type](
                p.radius,
                p.widthSegments,
                p.heightSegments,
                p.phiStart,
                p.phiLength,
                p.thetaStart,
                p.thetaLength
              );
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              y = new dn[p.type](p.radius, p.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              y = new dn[p.type](
                p.innerRadius,
                p.outerRadius,
                p.thetaSegments,
                p.phiSegments,
                p.thetaStart,
                p.thetaLength
              );
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              y = new dn[p.type](
                p.radius,
                p.tube,
                p.radialSegments,
                p.tubularSegments,
                p.arc
              );
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              y = new dn[p.type](
                p.radius,
                p.tube,
                p.tubularSegments,
                p.radialSegments,
                p.p,
                p.q
              );
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              y = new dn[p.type](p.points, p.segments, p.phiStart, p.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              y = new dn[p.type](p.vertices, p.indices, p.radius, p.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              y = [];
              for (var w = 0, A = p.shapes.length; w < A; w++) {
                var P = e[p.shapes[w]];
                y.push(P);
              }
              y = new dn[p.type](y, p.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              for (y = [], w = 0, A = p.shapes.length; w < A; w++)
                P = e[p.shapes[w]], y.push(P);
              w = p.options.extrudePath, w !== void 0 && (p.options.extrudePath = new Zl[w.type]().fromJSON(w)), y = new dn[p.type](y, p.options);
              break;
            case "BufferGeometry":
              y = o.parse(p);
              break;
            case "Geometry":
              y = n.parse(p, this.resourcePath).geometry;
              break;
            default:
              console.warn(
                'THREE.ObjectLoader: Unsupported geometry type "' + p.type + '"'
              );
              continue;
          }
          y.uuid = p.uuid, p.name !== void 0 && (y.name = p.name), y.isBufferGeometry === !0 && p.userData !== void 0 && (y.userData = p.userData), i[p.uuid] = y;
        }
      return i;
    },
    parseMaterials: function(t, e) {
      var i = {}, n = {};
      if (t !== void 0) {
        var o = new Hl();
        o.setTextures(e), e = 0;
        for (var l = t.length; e < l; e++) {
          var f = t[e];
          if (f.type === "MultiMaterial") {
            for (var p = [], y = 0; y < f.materials.length; y++) {
              var w = f.materials[y];
              i[w.uuid] === void 0 && (i[w.uuid] = o.parse(w)), p.push(i[w.uuid]);
            }
            n[f.uuid] = p;
          } else
            n[f.uuid] = o.parse(f), i[f.uuid] = n[f.uuid];
        }
      }
      return n;
    },
    parseAnimations: function(t) {
      for (var e = [], i = 0; i < t.length; i++) {
        var n = t[i], o = gr.parse(n);
        n.uuid !== void 0 && (o.uuid = n.uuid), e.push(o);
      }
      return e;
    },
    parseImages: function(t, e) {
      function i(B) {
        return n.manager.itemStart(B), l.load(
          B,
          function() {
            n.manager.itemEnd(B);
          },
          void 0,
          function() {
            n.manager.itemError(B), n.manager.itemEnd(B);
          }
        );
      }
      var n = this, o = {};
      if (t !== void 0 && 0 < t.length) {
        e = new Zo(e);
        var l = new si(e);
        l.setCrossOrigin(this.crossOrigin), e = 0;
        for (var f = t.length; e < f; e++) {
          var p = t[e], y = p.url;
          if (Array.isArray(y)) {
            o[p.uuid] = [];
            for (var w = 0, A = y.length; w < A; w++) {
              var P = y[w];
              P = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(P) ? P : n.resourcePath + P, o[p.uuid].push(i(P));
            }
          } else
            P = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p.url) ? p.url : n.resourcePath + p.url, o[p.uuid] = i(P);
        }
      }
      return o;
    },
    parseTextures: function(t, e) {
      function i(y, w) {
        return typeof y == "number" ? y : (console.warn(
          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
          y
        ), w[y]);
      }
      var n = {};
      if (t !== void 0)
        for (var o = 0, l = t.length; o < l; o++) {
          var f = t[o];
          f.image === void 0 && console.warn(
            'THREE.ObjectLoader: No "image" specified for',
            f.uuid
          ), e[f.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", f.image);
          var p = Array.isArray(e[f.image]) ? new z(e[f.image]) : new g(e[f.image]);
          p.needsUpdate = !0, p.uuid = f.uuid, f.name !== void 0 && (p.name = f.name), f.mapping !== void 0 && (p.mapping = i(f.mapping, xu)), f.offset !== void 0 && p.offset.fromArray(f.offset), f.repeat !== void 0 && p.repeat.fromArray(f.repeat), f.center !== void 0 && p.center.fromArray(f.center), f.rotation !== void 0 && (p.rotation = f.rotation), f.wrap !== void 0 && (p.wrapS = i(f.wrap[0], jn), p.wrapT = i(f.wrap[1], jn)), f.format !== void 0 && (p.format = f.format), f.minFilter !== void 0 && (p.minFilter = i(f.minFilter, Jl)), f.magFilter !== void 0 && (p.magFilter = i(f.magFilter, Jl)), f.anisotropy !== void 0 && (p.anisotropy = f.anisotropy), f.flipY !== void 0 && (p.flipY = f.flipY), n[f.uuid] = p;
        }
      return n;
    },
    parseObject: function(t, e, i) {
      function n(w) {
        return e[w] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", w), e[w];
      }
      function o(w) {
        if (w !== void 0) {
          if (Array.isArray(w)) {
            for (var A = [], P = 0, B = w.length; P < B; P++) {
              var H = w[P];
              i[H] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", H), A.push(i[H]);
            }
            return A;
          }
          return i[w] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", w), i[w];
        }
      }
      switch (t.type) {
        case "Scene":
          var l = new Hn();
          t.background !== void 0 && Number.isInteger(t.background) && (l.background = new L(t.background)), t.fog !== void 0 && (t.fog.type === "Fog" ? l.fog = new wn(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (l.fog = new Le(t.fog.color, t.fog.density)));
          break;
        case "PerspectiveCamera":
          l = new _e(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (l.focus = t.focus), t.zoom !== void 0 && (l.zoom = t.zoom), t.filmGauge !== void 0 && (l.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (l.filmOffset = t.filmOffset), t.view !== void 0 && (l.view = Object.assign({}, t.view));
          break;
        case "OrthographicCamera":
          l = new fa(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (l.zoom = t.zoom), t.view !== void 0 && (l.view = Object.assign({}, t.view));
          break;
        case "AmbientLight":
          l = new As(t.color, t.intensity);
          break;
        case "DirectionalLight":
          l = new mo(t.color, t.intensity);
          break;
        case "PointLight":
          l = new Cs(t.color, t.intensity, t.distance, t.decay);
          break;
        case "RectAreaLight":
          l = new Gl(t.color, t.intensity, t.width, t.height);
          break;
        case "SpotLight":
          l = new $a(
            t.color,
            t.intensity,
            t.distance,
            t.angle,
            t.penumbra,
            t.decay
          );
          break;
        case "HemisphereLight":
          l = new Za(t.color, t.groundColor, t.intensity);
          break;
        case "SkinnedMesh":
          console.warn(
            "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
          );
        case "Mesh":
          l = n(t.geometry);
          var f = o(t.material);
          l = l.bones && 0 < l.bones.length ? new Fi(l, f) : new pi(l, f);
          break;
        case "LOD":
          l = new tn();
          break;
        case "Line":
          l = new Vi(n(t.geometry), o(t.material), t.mode);
          break;
        case "LineLoop":
          l = new so(n(t.geometry), o(t.material));
          break;
        case "LineSegments":
          l = new mi(n(t.geometry), o(t.material));
          break;
        case "PointCloud":
        case "Points":
          l = new Ks(n(t.geometry), o(t.material));
          break;
        case "Sprite":
          l = new Qi(o(t.material));
          break;
        case "Group":
          l = new ui();
          break;
        default:
          l = new N();
      }
      if (l.uuid = t.uuid, t.name !== void 0 && (l.name = t.name), t.matrix !== void 0 ? (l.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = t.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (t.position !== void 0 && l.position.fromArray(t.position), t.rotation !== void 0 && l.rotation.fromArray(t.rotation), t.quaternion !== void 0 && l.quaternion.fromArray(t.quaternion), t.scale !== void 0 && l.scale.fromArray(t.scale)), t.castShadow !== void 0 && (l.castShadow = t.castShadow), t.receiveShadow !== void 0 && (l.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (l.shadow.bias = t.shadow.bias), t.shadow.radius !== void 0 && (l.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (l.visible = t.visible), t.frustumCulled !== void 0 && (l.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (l.renderOrder = t.renderOrder), t.userData !== void 0 && (l.userData = t.userData), t.layers !== void 0 && (l.layers.mask = t.layers), t.children !== void 0) {
        f = t.children;
        for (var p = 0; p < f.length; p++)
          l.add(this.parseObject(f[p], e, i));
      }
      if (t.type === "LOD")
        for (t = t.levels, f = 0; f < t.length; f++) {
          p = t[f];
          var y = l.getObjectByProperty("uuid", p.object);
          y !== void 0 && l.addLevel(y, p.distance);
        }
      return l;
    }
  });
  var xu = {
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307
  }, jn = {
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002
  }, Jl = {
    NearestFilter: 1003,
    NearestMipMapNearestFilter: 1004,
    NearestMipMapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipMapNearestFilter: 1007,
    LinearMipMapLinearFilter: 1008
  };
  Th.prototype = {
    constructor: Th,
    setOptions: function(t) {
      return this.options = t, this;
    },
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var o = this, l = yo.get(t);
      if (l !== void 0)
        return o.manager.itemStart(t), setTimeout(function() {
          e && e(l), o.manager.itemEnd(t);
        }, 0), l;
      fetch(t).then(function(f) {
        return f.blob();
      }).then(function(f) {
        return createImageBitmap(f, o.options);
      }).then(function(f) {
        yo.add(t, f), e && e(f), o.manager.itemEnd(t);
      }).catch(function(f) {
        n && n(f), o.manager.itemError(t), o.manager.itemEnd(t);
      });
    },
    setCrossOrigin: function() {
      return this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }, Object.assign(Vl.prototype, {
    moveTo: function(t, e) {
      this.currentPath = new ar(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e);
    },
    lineTo: function(t, e) {
      this.currentPath.lineTo(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      this.currentPath.quadraticCurveTo(t, e, i, n);
    },
    bezierCurveTo: function(t, e, i, n, o, l) {
      this.currentPath.bezierCurveTo(t, e, i, n, o, l);
    },
    splineThru: function(t) {
      this.currentPath.splineThru(t);
    },
    toShapes: function(t, e) {
      function i(rt) {
        for (var xt = [], gt = 0, Ct = rt.length; gt < Ct; gt++) {
          var wt = rt[gt], Vt = new $n();
          Vt.curves = wt.curves, xt.push(Vt);
        }
        return xt;
      }
      function n(rt, xt) {
        for (var gt = xt.length, Ct = !1, wt = gt - 1, Vt = 0; Vt < gt; wt = Vt++) {
          var Z = xt[wt], ot = xt[Vt], zt = ot.x - Z.x, ee = ot.y - Z.y;
          if (Math.abs(ee) > Number.EPSILON) {
            if (0 > ee && (Z = xt[Vt], zt = -zt, ot = xt[wt], ee = -ee), !(rt.y < Z.y || rt.y > ot.y))
              if (rt.y === Z.y) {
                if (rt.x === Z.x)
                  return !0;
              } else {
                if (wt = ee * (rt.x - Z.x) - zt * (rt.y - Z.y), wt === 0)
                  return !0;
                0 > wt || (Ct = !Ct);
              }
          } else if (rt.y === Z.y && (ot.x <= rt.x && rt.x <= Z.x || Z.x <= rt.x && rt.x <= ot.x))
            return !0;
        }
        return Ct;
      }
      var o = vo.isClockWise, l = this.subPaths;
      if (l.length === 0)
        return [];
      if (e === !0)
        return i(l);
      if (e = [], l.length === 1) {
        var f = l[0], p = new $n();
        return p.curves = f.curves, e.push(p), e;
      }
      var y = !o(l[0].getPoints());
      y = t ? !y : y, p = [];
      var w = [], A = [], P = 0;
      w[P] = void 0, A[P] = [];
      for (var B = 0, H = l.length; B < H; B++) {
        f = l[B];
        var q = f.getPoints(), $ = o(q);
        ($ = t ? !$ : $) ? (!y && w[P] && P++, w[P] = { s: new $n(), p: q }, w[P].s.curves = f.curves, y && P++, A[P] = []) : A[P].push({ h: f, p: q[0] });
      }
      if (!w[0])
        return i(l);
      if (1 < w.length) {
        for (B = !1, t = [], o = 0, l = w.length; o < l; o++)
          p[o] = [];
        for (o = 0, l = w.length; o < l; o++)
          for (f = A[o], $ = 0; $ < f.length; $++) {
            for (y = f[$], P = !0, q = 0; q < w.length; q++)
              n(y.p, w[q].p) && (o !== q && t.push({ froms: o, tos: q, hole: $ }), P ? (P = !1, p[q].push(y)) : B = !0);
            P && p[o].push(y);
          }
        0 < t.length && (B || (A = p));
      }
      for (B = 0, o = w.length; B < o; B++)
        for (p = w[B].s, e.push(p), t = A[B], l = 0, f = t.length; l < f; l++)
          p.holes.push(t[l].h);
      return e;
    }
  }), Object.assign(Mh.prototype, {
    isFont: !0,
    generateShapes: function(t, e) {
      e === void 0 && (e = 100);
      var i = [], n = e;
      e = this.data;
      var o = Array.from ? Array.from(t) : String(t).split("");
      n /= e.resolution;
      var l = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
      t = [];
      for (var f = 0, p = 0, y = 0; y < o.length; y++) {
        var w = o[y];
        if (w === `
`)
          f = 0, p -= l;
        else {
          var A = n, P = f, B = p;
          if (w = e.glyphs[w] || e.glyphs["?"]) {
            var H = new Vl();
            if (w.o)
              for (var q = w._cachedOutline || (w._cachedOutline = w.o.split(" ")), $ = 0, rt = q.length; $ < rt; )
                switch (q[$++]) {
                  case "m":
                    var xt = q[$++] * A + P, gt = q[$++] * A + B;
                    H.moveTo(xt, gt);
                    break;
                  case "l":
                    xt = q[$++] * A + P, gt = q[$++] * A + B, H.lineTo(xt, gt);
                    break;
                  case "q":
                    var Ct = q[$++] * A + P, wt = q[$++] * A + B, Vt = q[$++] * A + P, Z = q[$++] * A + B;
                    H.quadraticCurveTo(Vt, Z, Ct, wt);
                    break;
                  case "b":
                    Ct = q[$++] * A + P, wt = q[$++] * A + B, Vt = q[$++] * A + P, Z = q[$++] * A + B, xt = q[$++] * A + P, gt = q[$++] * A + B, H.bezierCurveTo(Vt, Z, xt, gt, Ct, wt);
                }
            A = { offsetX: w.ha * A, path: H };
          } else
            A = void 0;
          f += A.offsetX, t.push(A.path);
        }
      }
      for (e = 0, o = t.length; e < o; e++)
        Array.prototype.push.apply(i, t[e].toShapes());
      return i;
    }
  }), Object.assign(uu.prototype, {
    load: function(t, e, i, n) {
      var o = this, l = new Lt(this.manager);
      l.setPath(this.path), l.load(
        t,
        function(f) {
          try {
            var p = JSON.parse(f);
          } catch {
            console.warn(
              "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
            ), p = JSON.parse(f.substring(65, f.length - 2));
          }
          f = o.parse(p), e && e(f);
        },
        i,
        n
      );
    },
    parse: function(t) {
      return new Mh(t);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var $l, Dh = {
    getContext: function() {
      return $l === void 0 && ($l = new (window.AudioContext || window.webkitAudioContext)()), $l;
    },
    setContext: function(t) {
      $l = t;
    }
  };
  Object.assign(pn.prototype, {
    load: function(t, e, i, n) {
      var o = new Lt(this.manager);
      o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(
        t,
        function(l) {
          l = l.slice(0), Dh.getContext().decodeAudioData(l, function(f) {
            e(f);
          });
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Gn.prototype, {
    update: function() {
      var t, e, i, n, o, l, f, p, y = new c(), w = new c();
      return function(A) {
        if (t !== this || e !== A.focus || i !== A.fov || n !== A.aspect * this.aspect || o !== A.near || l !== A.far || f !== A.zoom || p !== this.eyeSep) {
          t = this, e = A.focus, i = A.fov, n = A.aspect * this.aspect, o = A.near, l = A.far, f = A.zoom;
          var P = A.projectionMatrix.clone();
          p = this.eyeSep / 2;
          var B = p * o / e, H = o * Math.tan(fi.DEG2RAD * i * 0.5) / f;
          w.elements[12] = -p, y.elements[12] = p;
          var q = -H * n + B, $ = H * n + B;
          P.elements[0] = 2 * o / ($ - q), P.elements[8] = ($ + q) / ($ - q), this.cameraL.projectionMatrix.copy(P), q = -H * n - B, $ = H * n - B, P.elements[0] = 2 * o / ($ - q), P.elements[8] = ($ + q) / ($ - q), this.cameraR.projectionMatrix.copy(P);
        }
        this.cameraL.matrixWorld.copy(A.matrixWorld).multiply(w), this.cameraR.matrixWorld.copy(A.matrixWorld).multiply(y);
      };
    }()
  }), Qa.prototype = Object.create(N.prototype), Qa.prototype.constructor = Qa, Object.assign(Sh.prototype, {
    start: function() {
      this.oldTime = this.startTime = (typeof performance > "u" ? Date : performance).now(), this.elapsedTime = 0, this.running = !0;
    },
    stop: function() {
      this.getElapsedTime(), this.autoStart = this.running = !1;
    },
    getElapsedTime: function() {
      return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
      var t = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        var e = (typeof performance > "u" ? Date : performance).now();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }
      return t;
    }
  }), Wl.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Wl,
    getInput: function() {
      return this.gain;
    },
    removeFilter: function() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    },
    getFilter: function() {
      return this.filter;
    },
    setFilter: function(t) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    },
    getMasterVolume: function() {
      return this.gain.gain.value;
    },
    setMasterVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    },
    updateMatrixWorld: function() {
      var t = new u(), e = new d(), i = new u(), n = new u(), o = new Sh();
      return function(l) {
        N.prototype.updateMatrixWorld.call(this, l), l = this.context.listener;
        var f = this.up;
        if (this.timeDelta = o.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), l.positionX) {
          var p = this.context.currentTime + this.timeDelta;
          l.positionX.linearRampToValueAtTime(t.x, p), l.positionY.linearRampToValueAtTime(t.y, p), l.positionZ.linearRampToValueAtTime(t.z, p), l.forwardX.linearRampToValueAtTime(n.x, p), l.forwardY.linearRampToValueAtTime(n.y, p), l.forwardZ.linearRampToValueAtTime(n.z, p), l.upX.linearRampToValueAtTime(f.x, p), l.upY.linearRampToValueAtTime(f.y, p), l.upZ.linearRampToValueAtTime(f.z, p);
        } else
          l.setPosition(t.x, t.y, t.z), l.setOrientation(n.x, n.y, n.z, f.x, f.y, f.z);
      };
    }()
  }), pa.prototype = Object.assign(Object.create(N.prototype), {
    constructor: pa,
    getOutput: function() {
      return this.gain;
    },
    setNodeSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    },
    setMediaElementSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    },
    setBuffer: function(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    },
    play: function() {
      if (this.isPlaying === !0)
        console.warn("THREE.Audio: Audio is already playing.");
      else if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else {
        var t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect();
      }
    },
    pause: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.isPlaying === !0 && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
    },
    stop: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
    },
    connect: function() {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this;
    },
    disconnect: function() {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this;
    },
    getFilters: function() {
      return this.filters;
    },
    setFilters: function(t) {
      return t || (t = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this;
    },
    getFilter: function() {
      return this.getFilters()[0];
    },
    setFilter: function(t) {
      return this.setFilters(t ? [t] : []);
    },
    setPlaybackRate: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(
          this.playbackRate,
          this.context.currentTime
        ), this;
    },
    getPlaybackRate: function() {
      return this.playbackRate;
    },
    onEnded: function() {
      this.isPlaying = !1;
    },
    getLoop: function() {
      return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    },
    setLoop: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    },
    getVolume: function() {
      return this.gain.gain.value;
    },
    setVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    }
  }), tl.prototype = Object.assign(Object.create(pa.prototype), {
    constructor: tl,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(t) {
      return this.panner.refDistance = t, this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(t) {
      return this.panner.rolloffFactor = t, this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(t) {
      return this.panner.distanceModel = t, this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(t) {
      return this.panner.maxDistance = t, this;
    },
    setDirectionalCone: function(t, e, i) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this;
    },
    updateMatrixWorld: function() {
      var t = new u(), e = new d(), i = new u(), n = new u();
      return function(o) {
        if (N.prototype.updateMatrixWorld.call(this, o), o = this.panner, this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), o.positionX) {
          var l = this.context.currentTime + this.listener.timeDelta;
          o.positionX.linearRampToValueAtTime(t.x, l), o.positionY.linearRampToValueAtTime(t.y, l), o.positionZ.linearRampToValueAtTime(t.z, l), o.orientationX.linearRampToValueAtTime(n.x, l), o.orientationY.linearRampToValueAtTime(n.y, l), o.orientationZ.linearRampToValueAtTime(n.z, l);
        } else
          o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z);
      };
    }()
  }), Object.assign(Ls.prototype, {
    getFrequencyData: function() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    },
    getAverageFrequency: function() {
      for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)
        t += e[i];
      return t / e.length;
    }
  }), Object.assign(el.prototype, {
    accumulate: function(t, e) {
      var i = this.buffer, n = this.valueSize;
      t = t * n + n;
      var o = this.cumulativeWeight;
      if (o === 0) {
        for (o = 0; o !== n; ++o)
          i[t + o] = i[o];
        o = e;
      } else
        o += e, this._mixBufferRegion(i, t, 0, e / o, n);
      this.cumulativeWeight = o;
    },
    apply: function(t) {
      var e = this.valueSize, i = this.buffer;
      t = t * e + e;
      var n = this.cumulativeWeight, o = this.binding;
      this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e;
      for (var l = e + e; n !== l; ++n)
        if (i[n] !== i[n + e]) {
          o.setValue(i, t);
          break;
        }
    },
    saveOriginalState: function() {
      var t = this.buffer, e = this.valueSize, i = 3 * e;
      this.binding.getValue(t, i);
      for (var n = e; n !== i; ++n)
        t[n] = t[i + n % e];
      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
      this.binding.setValue(this.buffer, 3 * this.valueSize);
    },
    _select: function(t, e, i, n, o) {
      if (0.5 <= n)
        for (n = 0; n !== o; ++n)
          t[e + n] = t[i + n];
    },
    _slerp: function(t, e, i, n) {
      d.slerpFlat(t, e, t, e, t, i, n);
    },
    _lerp: function(t, e, i, n, o) {
      for (var l = 1 - n, f = 0; f !== o; ++f) {
        var p = e + f;
        t[p] = t[p] * l + t[i + f] * n;
      }
    }
  }), Object.assign(Rs.prototype, {
    getValue: function(t, e) {
      this.bind();
      var i = this._bindings[this._targetGroup.nCachedObjects_];
      i !== void 0 && i.getValue(t, e);
    },
    setValue: function(t, e) {
      for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, o = i.length; n !== o; ++n)
        i[n].setValue(t, e);
    },
    bind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].bind();
    },
    unbind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].unbind();
    }
  }), Object.assign(Tn, {
    Composite: Rs,
    create: function(t, e, i) {
      return t && t.isAnimationObjectGroup ? new Tn.Composite(t, e, i) : new Tn(t, e, i);
    },
    sanitizeNodeName: function() {
      var t = /[\[\]\.:\/]/g;
      return function(e) {
        return e.replace(/\s/g, "_").replace(t, "");
      };
    }(),
    parseTrackName: function() {
      var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
      t = /(WCOD+)?/.source.replace("WCOD", t);
      var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
        "WC",
        "[^\\[\\]\\.:\\/]"
      ), n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), o = new RegExp("^" + e + t + i + n + "$"), l = ["material", "materials", "bones"];
      return function(f) {
        var p = o.exec(f);
        if (!p)
          throw Error("PropertyBinding: Cannot parse trackName: " + f);
        p = {
          nodeName: p[2],
          objectName: p[3],
          objectIndex: p[4],
          propertyName: p[5],
          propertyIndex: p[6]
        };
        var y = p.nodeName && p.nodeName.lastIndexOf(".");
        if (y !== void 0 && y !== -1) {
          var w = p.nodeName.substring(y + 1);
          l.indexOf(w) !== -1 && (p.nodeName = p.nodeName.substring(0, y), p.objectName = w);
        }
        if (p.propertyName === null || p.propertyName.length === 0)
          throw Error(
            "PropertyBinding: can not parse propertyName from trackName: " + f
          );
        return p;
      };
    }(),
    findNode: function(t, e) {
      if (!e || e === "" || e === "root" || e === "." || e === -1 || e === t.name || e === t.uuid)
        return t;
      if (t.skeleton) {
        var i = t.skeleton.getBoneByName(e);
        if (i !== void 0)
          return i;
      }
      if (t.children) {
        var n = function(o) {
          for (var l = 0; l < o.length; l++) {
            var f = o[l];
            if (f.name === e || f.uuid === e || (f = n(f.children)))
              return f;
          }
          return null;
        };
        if (t = n(t.children))
          return t;
      }
      return null;
    }
  }), Object.assign(Tn.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
    GetterByBindingType: [
      function(t, e) {
        t[e] = this.node[this.propertyName];
      },
      function(t, e) {
        for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
          t[e++] = i[n];
      },
      function(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      },
      function(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function(t, e) {
          this.targetObject[this.propertyName] = t[e];
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
          this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty.fromArray(t, e);
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ]
    ],
    getValue: function(t, e) {
      this.bind(), this.getValue(t, e);
    },
    setValue: function(t, e) {
      this.bind(), this.setValue(t, e);
    },
    bind: function() {
      var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, o = e.propertyIndex;
      if (t || (this.node = t = Tn.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
        if (i) {
          var l = e.objectIndex;
          switch (i) {
            case "materials":
              if (!t.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!t.material.materials) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
                return;
              }
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
                return;
              }
              for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                if (t[i].name === l) {
                  l = i;
                  break;
                }
              break;
            default:
              if (t[i] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
                return;
              }
              t = t[i];
          }
          if (l !== void 0) {
            if (t[l] === void 0) {
              console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                t
              );
              return;
            }
            t = t[l];
          }
        }
        if (l = t[n], l === void 0)
          console.error(
            "THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.",
            t
          );
        else {
          if (e = this.Versioning.None, this.targetObject = t, t.needsUpdate !== void 0 ? e = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, o !== void 0) {
            if (n === "morphTargetInfluences") {
              if (!t.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (t.geometry.isBufferGeometry) {
                if (!t.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                  if (t.geometry.morphAttributes.position[i].name === o) {
                    o = i;
                    break;
                  }
              } else {
                if (!t.geometry.morphTargets) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                  if (t.geometry.morphTargets[i].name === o) {
                    o = i;
                    break;
                  }
              }
            }
            i = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o;
          } else
            l.fromArray !== void 0 && l.toArray !== void 0 ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (i = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e];
        }
      } else
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."
        );
    },
    unbind: function() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }), Object.assign(Tn.prototype, {
    _getValue_unbound: Tn.prototype.getValue,
    _setValue_unbound: Tn.prototype.setValue
  }), Object.assign(da.prototype, {
    isAnimationObjectGroup: !0,
    add: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._paths, l = this._parsedPaths, f = this._bindings, p = f.length, y = void 0, w = 0, A = arguments.length; w !== A; ++w) {
        var P = arguments[w], B = P.uuid, H = n[B];
        if (H === void 0) {
          H = e++, n[B] = H, t.push(P), B = 0;
          for (var q = p; B !== q; ++B)
            f[B].push(new Tn(P, o[B], l[B]));
        } else if (H < i) {
          y = t[H];
          var $ = --i;
          for (q = t[$], n[q.uuid] = H, t[H] = q, n[B] = $, t[$] = P, B = 0, q = p; B !== q; ++B) {
            var rt = f[B], xt = rt[H];
            rt[H] = rt[$], xt === void 0 && (xt = new Tn(P, o[B], l[B])), rt[$] = xt;
          }
        } else
          t[H] !== y && console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
      }
      this.nCachedObjects_ = i;
    },
    remove: function() {
      for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, o = n.length, l = 0, f = arguments.length; l !== f; ++l) {
        var p = arguments[l], y = p.uuid, w = i[y];
        if (w !== void 0 && w >= e) {
          var A = e++, P = t[A];
          for (i[P.uuid] = w, t[w] = P, i[y] = A, t[A] = p, p = 0, y = o; p !== y; ++p) {
            P = n[p];
            var B = P[w];
            P[w] = P[A], P[A] = B;
          }
        }
      }
      this.nCachedObjects_ = e;
    },
    uncache: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._bindings, l = o.length, f = 0, p = arguments.length; f !== p; ++f) {
        var y = arguments[f].uuid, w = n[y];
        if (w !== void 0)
          if (delete n[y], w < i) {
            y = --i;
            var A = t[y], P = --e, B = t[P];
            for (n[A.uuid] = w, t[w] = A, n[B.uuid] = y, t[y] = B, t.pop(), A = 0, B = l; A !== B; ++A) {
              var H = o[A], q = H[P];
              H[w] = H[y], H[y] = q, H.pop();
            }
          } else
            for (P = --e, B = t[P], n[B.uuid] = w, t[w] = B, t.pop(), A = 0, B = l; A !== B; ++A)
              H = o[A], H[w] = H[P], H.pop();
      }
      this.nCachedObjects_ = i;
    },
    subscribe_: function(t, e) {
      var i = this._bindingsIndicesByPath, n = i[t], o = this._bindings;
      if (n !== void 0)
        return o[n];
      var l = this._paths, f = this._parsedPaths, p = this._objects, y = this.nCachedObjects_, w = Array(p.length);
      for (n = o.length, i[t] = n, l.push(t), f.push(e), o.push(w), i = y, n = p.length; i !== n; ++i)
        w[i] = new Tn(p[i], t, e);
      return w;
    },
    unsubscribe_: function(t) {
      var e = this._bindingsIndicesByPath, i = e[t];
      if (i !== void 0) {
        var n = this._paths, o = this._parsedPaths, l = this._bindings, f = l.length - 1, p = l[f];
        e[t[f]] = i, l[i] = p, l.pop(), o[i] = o[f], o.pop(), n[i] = n[f], n.pop();
      }
    }
  }), Object.assign(il.prototype, {
    play: function() {
      return this._mixer._activateAction(this), this;
    },
    stop: function() {
      return this._mixer._deactivateAction(this), this.reset();
    },
    reset: function() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    },
    isRunning: function() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(t) {
      return this._startTime = t, this;
    },
    setLoop: function(t, e) {
      return this.loop = t, this.repetitions = e, this;
    },
    setEffectiveWeight: function(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(t) {
      return this._scheduleFading(t, 0, 1);
    },
    fadeOut: function(t) {
      return this._scheduleFading(t, 1, 0);
    },
    crossFadeFrom: function(t, e, i) {
      if (t.fadeOut(e), this.fadeIn(e), i) {
        i = this._clip.duration;
        var n = t._clip.duration, o = i / n;
        t.warp(1, n / i, e), this.warp(o, 1, e);
      }
      return this;
    },
    crossFadeTo: function(t, e, i) {
      return t.crossFadeFrom(this, e, i);
    },
    stopFading: function() {
      var t = this._weightInterpolant;
      return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    setEffectiveTimeScale: function(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    },
    syncWith: function(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    },
    halt: function(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    },
    warp: function(t, e, i) {
      var n = this._mixer, o = n.time, l = this._timeScaleInterpolant, f = this.timeScale;
      return l === null && (this._timeScaleInterpolant = l = n._lendControlInterpolant()), n = l.parameterPositions, l = l.sampleValues, n[0] = o, n[1] = o + i, l[0] = t / f, l[1] = e / f, this;
    },
    stopWarping: function() {
      var t = this._timeScaleInterpolant;
      return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(t, e, i, n) {
      if (this.enabled) {
        var o = this._startTime;
        if (o !== null) {
          if (e = (t - o) * i, 0 > e || i === 0)
            return;
          this._startTime = null, e *= i;
        }
        if (e *= this._updateTimeScale(t), i = this._updateTime(e), t = this._updateWeight(t), 0 < t) {
          e = this._interpolants, o = this._propertyBindings;
          for (var l = 0, f = e.length; l !== f; ++l)
            e[l].evaluate(i), o[l].accumulate(n, t);
        }
      } else
        this._updateWeight(t);
    },
    _updateWeight: function(t) {
      var e = 0;
      if (this.enabled) {
        e = this.weight;
        var i = this._weightInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
        }
      }
      return this._effectiveWeight = e;
    },
    _updateTimeScale: function(t) {
      var e = 0;
      if (!this.paused) {
        e = this.timeScale;
        var i = this._timeScaleInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
        }
      }
      return this._effectiveTimeScale = e;
    },
    _updateTime: function(t) {
      var e = this.time + t, i = this._clip.duration, n = this.loop, o = this._loopCount, l = n === 2202;
      if (t === 0)
        return o === -1 ? e : l && (o & 1) === 1 ? i - e : e;
      if (n === 2200)
        t: {
          if (o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i)
            e = i;
          else if (0 > e)
            e = 0;
          else
            break t;
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 > t ? -1 : 1
          });
        }
      else {
        if (o === -1 && (0 <= t ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), e >= i || 0 > e) {
          n = Math.floor(e / i), e -= i * n, o += Math.abs(n);
          var f = this.repetitions - o;
          0 >= f ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 < t ? 1 : -1
          })) : (f === 1 ? (t = 0 > t, this._setEndings(t, !t, l)) : this._setEndings(!1, !1, l), this._loopCount = o, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: n
          }));
        }
        if (l && (o & 1) === 1)
          return this.time = e, i - e;
      }
      return this.time = e;
    },
    _setEndings: function(t, e, i) {
      var n = this._interpolantSettings;
      i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    },
    _scheduleFading: function(t, e, i) {
      var n = this._mixer, o = n.time, l = this._weightInterpolant;
      return l === null && (this._weightInterpolant = l = n._lendControlInterpolant()), n = l.parameterPositions, l = l.sampleValues, n[0] = o, l[0] = e, n[1] = o + t, l[1] = i, this;
    }
  }), Ko.prototype = Object.assign(Object.create(a.prototype), {
    constructor: Ko,
    _bindAction: function(t, e) {
      var i = t._localRoot || this._root, n = t._clip.tracks, o = n.length, l = t._propertyBindings;
      t = t._interpolants;
      var f = i.uuid, p = this._bindingsByRootAndName, y = p[f];
      for (y === void 0 && (y = {}, p[f] = y), p = 0; p !== o; ++p) {
        var w = n[p], A = w.name, P = y[A];
        if (P === void 0) {
          if (P = l[p], P !== void 0) {
            P._cacheIndex === null && (++P.referenceCount, this._addInactiveBinding(P, f, A));
            continue;
          }
          P = new el(
            Tn.create(i, A, e && e._propertyBindings[p].binding.parsedPath),
            w.ValueTypeName,
            w.getValueSize()
          ), ++P.referenceCount, this._addInactiveBinding(P, f, A);
        }
        l[p] = P, t[p].resultBuffer = P.buffer;
      }
    },
    _activateAction: function(t) {
      if (!this._isActiveAction(t)) {
        if (t._cacheIndex === null) {
          var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
          this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
        }
        for (e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var o = e[i];
          o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
        }
        this._lendAction(t);
      }
    },
    _deactivateAction: function(t) {
      if (this._isActiveAction(t)) {
        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var o = e[i];
          --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
        }
        this._takeBackAction(t);
      }
    },
    _initMemoryManager: function() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },
          get inUse() {
            return t._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return t._bindings.length;
          },
          get inUse() {
            return t._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },
          get inUse() {
            return t._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(t) {
      return t = t._cacheIndex, t !== null && t < this._nActiveActions;
    },
    _addInactiveAction: function(t, e, i) {
      var n = this._actions, o = this._actionsByClip, l = o[e];
      l === void 0 ? (l = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, o[e] = l) : (e = l.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), l.actionByRoot[i] = t;
    },
    _removeInactiveAction: function(t) {
      var e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
      i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid, i = this._actionsByClip, n = i[e];
      var o = n.knownActions, l = o[o.length - 1], f = t._byClipCacheIndex;
      l._byClipCacheIndex = f, o[f] = l, o.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], o.length === 0 && delete i[e], this._removeInactiveBindingsForAction(t);
    },
    _removeInactiveBindingsForAction: function(t) {
      t = t._propertyBindings;
      for (var e = 0, i = t.length; e !== i; ++e) {
        var n = t[e];
        --n.referenceCount === 0 && this._removeInactiveBinding(n);
      }
    },
    _lendAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _takeBackAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _addInactiveBinding: function(t, e, i) {
      var n = this._bindingsByRootAndName, o = n[e], l = this._bindings;
      o === void 0 && (o = {}, n[e] = o), o[i] = t, t._cacheIndex = l.length, l.push(t);
    },
    _removeInactiveBinding: function(t) {
      var e = this._bindings, i = t.binding, n = i.rootNode.uuid;
      i = i.path;
      var o = this._bindingsByRootAndName, l = o[n], f = e[e.length - 1];
      t = t._cacheIndex, f._cacheIndex = t, e[t] = f, e.pop(), delete l[i];
      t: {
        for (var p in l)
          break t;
        delete o[n];
      }
    },
    _lendBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _takeBackBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _lendControlInterpolant: function() {
      var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
      return i === void 0 && (i = new Cr(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      ), i.__cacheIndex = e, t[e] = i), i;
    },
    _takeBackControlInterpolant: function(t) {
      var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, o = e[n];
      t.__cacheIndex = n, e[n] = t, o.__cacheIndex = i, e[i] = o;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(t, e) {
      var i = e || this._root, n = i.uuid;
      i = typeof t == "string" ? gr.findByName(i, t) : t, t = i !== null ? i.uuid : t;
      var o = this._actionsByClip[t], l = null;
      if (o !== void 0) {
        if (l = o.actionByRoot[n], l !== void 0)
          return l;
        l = o.knownActions[0], i === null && (i = l._clip);
      }
      return i === null ? null : (e = new il(this, i, e), this._bindAction(e, l), this._addInactiveAction(e, t, n), e);
    },
    existingAction: function(t, e) {
      var i = e || this._root;
      return e = i.uuid, i = typeof t == "string" ? gr.findByName(i, t) : t, t = this._actionsByClip[i ? i.uuid : t], t !== void 0 && t.actionByRoot[e] || null;
    },
    stopAllAction: function() {
      for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, o = this._nActiveBindings = this._nActiveActions = 0; o !== e; ++o)
        t[o].reset();
      for (o = 0; o !== n; ++o)
        i[o].useCount = 0;
      return this;
    },
    update: function(t) {
      t *= this.timeScale;
      for (var e = this._actions, i = this._nActiveActions, n = this.time += t, o = Math.sign(t), l = this._accuIndex ^= 1, f = 0; f !== i; ++f)
        e[f]._update(n, t, o, l);
      for (t = this._bindings, e = this._nActiveBindings, f = 0; f !== e; ++f)
        t[f].apply(l);
      return this;
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(t) {
      var e = this._actions;
      t = t.uuid;
      var i = this._actionsByClip, n = i[t];
      if (n !== void 0) {
        n = n.knownActions;
        for (var o = 0, l = n.length; o !== l; ++o) {
          var f = n[o];
          this._deactivateAction(f);
          var p = f._cacheIndex, y = e[e.length - 1];
          f._cacheIndex = null, f._byClipCacheIndex = null, y._cacheIndex = p, e[p] = y, e.pop(), this._removeInactiveBindingsForAction(f);
        }
        delete i[t];
      }
    },
    uncacheRoot: function(t) {
      t = t.uuid;
      var e = this._actionsByClip;
      for (n in e) {
        var i = e[n].actionByRoot[t];
        i !== void 0 && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
      var n = this._bindingsByRootAndName[t];
      if (n !== void 0)
        for (var o in n)
          t = n[o], t.restoreOriginalState(), this._removeInactiveBinding(t);
    },
    uncacheAction: function(t, e) {
      t = this.existingAction(t, e), t !== null && (this._deactivateAction(t), this._removeInactiveAction(t));
    }
  }), jl.prototype.clone = function() {
    return new jl(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }, Eh.prototype = Object.assign(Object.create(Ft.prototype), {
    constructor: Eh,
    isInstancedBufferGeometry: !0,
    copy: function(t) {
      return Ft.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), bh.prototype = Object.assign(Object.create(Ii.prototype), {
    constructor: bh,
    isInstancedInterleavedBuffer: !0,
    copy: function(t) {
      return Ii.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), Ch.prototype = Object.assign(Object.create(J.prototype), {
    constructor: Ch,
    isInstancedBufferAttribute: !0,
    copy: function(t) {
      return J.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), Object.assign(cu.prototype, {
    linePrecision: 1,
    set: function(t, e) {
      this.ray.set(t, e);
    },
    setFromCamera: function(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
    },
    intersectObject: function(t, e, i) {
      return i = i || [], Os(t, this, i, e), i.sort(nl), i;
    },
    intersectObjects: function(t, e, i) {
      if (i = i || [], Array.isArray(t) === !1)
        return console.warn(
          "THREE.Raycaster.intersectObjects: objects is not an Array."
        ), i;
      for (var n = 0, o = t.length; n < o; n++)
        Os(t[n], this, i, e);
      return i.sort(nl), i;
    }
  }), Object.assign(Ah.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.phi = e, this.theta = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    },
    makeSafe: function() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + e * e + i * i), this.radius === 0 ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(fi.clamp(e / this.radius, -1, 1))), this;
    }
  }), Object.assign(it.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.theta = e, this.y = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this;
    }
  }), Object.assign(Qo.prototype, {
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new s();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new s()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), t = new s()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new s()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    },
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new s()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new s();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(ma.prototype, {
    set: function(t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new u()), t.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), t = new u()), t.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Line3: .at() target is now required"), e = new u()), this.delta(e).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
      var t = new u(), e = new u();
      return function(i, n) {
        return t.subVectors(i, this.start), e.subVectors(this.end, this.start), i = e.dot(e), i = e.dot(t) / i, n && (i = fi.clamp(i, 0, 1)), i;
      };
    }(),
    closestPointToPoint: function(t, e, i) {
      return t = this.closestPointToPointParameter(t, e), i === void 0 && (console.warn(
        "THREE.Line3: .closestPointToPoint() target is now required"
      ), i = new u()), this.delta(i).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    },
    equals: function(t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }
  }), Vn.prototype = Object.create(N.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isImmediateRenderObject = !0, yi.prototype = Object.create(mi.prototype), yi.prototype.constructor = yi, yi.prototype.update = function() {
    var t = new u(), e = new u(), i = new m();
    return function() {
      var n = ["a", "b", "c"];
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var o = this.object.matrixWorld, l = this.geometry.attributes.position, f = this.object.geometry;
      if (f && f.isGeometry)
        for (var p = f.vertices, y = f.faces, w = f = 0, A = y.length; w < A; w++)
          for (var P = y[w], B = 0, H = P.vertexNormals.length; B < H; B++) {
            var q = P.vertexNormals[B];
            t.copy(p[P[n[B]]]).applyMatrix4(o), e.copy(q).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), l.setXYZ(f, t.x, t.y, t.z), f += 1, l.setXYZ(f, e.x, e.y, e.z), f += 1;
          }
      else if (f && f.isBufferGeometry)
        for (n = f.attributes.position, p = f.attributes.normal, B = f = 0, H = n.count; B < H; B++)
          t.set(n.getX(B), n.getY(B), n.getZ(B)).applyMatrix4(o), e.set(p.getX(B), p.getY(B), p.getZ(B)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), l.setXYZ(f, t.x, t.y, t.z), f += 1, l.setXYZ(f, e.x, e.y, e.z), f += 1;
      l.needsUpdate = !0;
    };
  }(), ga.prototype = Object.create(N.prototype), ga.prototype.constructor = ga, ga.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }, ga.prototype.update = function() {
    var t = new u(), e = new u();
    return function() {
      this.light.updateMatrixWorld();
      var i = this.light.distance ? this.light.distance : 1e3, n = i * Math.tan(this.light.angle);
      this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    };
  }(), va.prototype = Object.create(mi.prototype), va.prototype.constructor = va, va.prototype.updateMatrixWorld = function() {
    var t = new u(), e = new c(), i = new c();
    return function(n) {
      var o = this.bones, l = this.geometry, f = l.getAttribute("position");
      i.getInverse(this.root.matrixWorld);
      for (var p = 0, y = 0; p < o.length; p++) {
        var w = o[p];
        w.parent && w.parent.isBone && (e.multiplyMatrices(i, w.matrixWorld), t.setFromMatrixPosition(e), f.setXYZ(y, t.x, t.y, t.z), e.multiplyMatrices(i, w.parent.matrixWorld), t.setFromMatrixPosition(e), f.setXYZ(y + 1, t.x, t.y, t.z), y += 2);
      }
      l.getAttribute("position").needsUpdate = !0, N.prototype.updateMatrixWorld.call(this, n);
    };
  }(), Pr.prototype = Object.create(pi.prototype), Pr.prototype.constructor = Pr, Pr.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
  }, Pr.prototype.update = function() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }, ya.prototype = Object.create(N.prototype), ya.prototype.constructor = ya, ya.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, ya.prototype.update = function() {
    var t = 0.5 * this.light.width, e = 0.5 * this.light.height, i = this.line.geometry.attributes.position, n = i.array;
    n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, this.color !== void 0 ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
  }, _a.prototype = Object.create(N.prototype), _a.prototype.constructor = _a, _a.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, _a.prototype.update = function() {
    var t = new u(), e = new L(), i = new L();
    return function() {
      var n = this.children[0];
      if (this.color !== void 0)
        this.material.color.set(this.color);
      else {
        var o = n.geometry.getAttribute("color");
        e.copy(this.light.color), i.copy(this.light.groundColor);
        for (var l = 0, f = o.count; l < f; l++) {
          var p = l < f / 2 ? e : i;
          o.setXYZ(l, p.r, p.g, p.b);
        }
        o.needsUpdate = !0;
      }
      n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }(), rl.prototype = Object.create(mi.prototype), rl.prototype.constructor = rl, Xl.prototype = Object.create(mi.prototype), Xl.prototype.constructor = Xl, ol.prototype = Object.create(mi.prototype), ol.prototype.constructor = ol, ol.prototype.update = function() {
    var t = new u(), e = new u(), i = new m();
    return function() {
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var n = this.object.matrixWorld, o = this.geometry.attributes.position, l = this.object.geometry, f = l.vertices;
      l = l.faces;
      for (var p = 0, y = 0, w = l.length; y < w; y++) {
        var A = l[y], P = A.normal;
        t.copy(f[A.a]).add(f[A.b]).add(f[A.c]).divideScalar(3).applyMatrix4(n), e.copy(P).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(p, t.x, t.y, t.z), p += 1, o.setXYZ(p, e.x, e.y, e.z), p += 1;
      }
      o.needsUpdate = !0;
    };
  }(), lr.prototype = Object.create(N.prototype), lr.prototype.constructor = lr, lr.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }, lr.prototype.update = function() {
    var t = new u(), e = new u(), i = new u();
    return function() {
      t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length();
    };
  }(), sl.prototype = Object.create(mi.prototype), sl.prototype.constructor = sl, sl.prototype.update = function() {
    function t(l, f, p, y) {
      if (n.set(f, p, y).unproject(o), l = i[l], l !== void 0)
        for (f = e.getAttribute("position"), p = 0, y = l.length; p < y; p++)
          f.setXYZ(l[p], n.x, n.y, n.z);
    }
    var e, i, n = new u(), o = new Be();
    return function() {
      e = this.geometry, i = this.pointMap, o.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", 0.7, 1.1, -1), t("u2", -0.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
    };
  }(), Do.prototype = Object.create(mi.prototype), Do.prototype.constructor = Do, Do.prototype.update = function() {
    var t = new k();
    return function(e) {
      if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && t.setFromObject(this.object), !t.isEmpty()) {
        e = t.min;
        var i = t.max, n = this.geometry.attributes.position, o = n.array;
        o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = e.x, o[4] = i.y, o[5] = i.z, o[6] = e.x, o[7] = e.y, o[8] = i.z, o[9] = i.x, o[10] = e.y, o[11] = i.z, o[12] = i.x, o[13] = i.y, o[14] = e.z, o[15] = e.x, o[16] = i.y, o[17] = e.z, o[18] = e.x, o[19] = e.y, o[20] = e.z, o[21] = i.x, o[22] = e.y, o[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
      }
    };
  }(), Do.prototype.setFromObject = function(t) {
    return this.object = t, this.update(), this;
  }, Do.prototype.copy = function(t) {
    return mi.prototype.copy.call(this, t), this.object = t.object, this;
  }, Do.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, al.prototype = Object.create(mi.prototype), al.prototype.constructor = al, al.prototype.updateMatrixWorld = function(t) {
    var e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), N.prototype.updateMatrixWorld.call(this, t));
  }, ll.prototype = Object.create(Vi.prototype), ll.prototype.constructor = ll, ll.prototype.updateMatrixWorld = function(t) {
    var e = -this.plane.constant;
    1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), N.prototype.updateMatrixWorld.call(this, t);
  };
  var Kl, fl;
  zo.prototype = Object.create(N.prototype), zo.prototype.constructor = zo, zo.prototype.setDirection = function() {
    var t = new u(), e;
    return function(i) {
      0.99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e));
    };
  }(), zo.prototype.setLength = function(t, e, i) {
    e === void 0 && (e = 0.2 * t), i === void 0 && (i = 0.2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix();
  }, zo.prototype.setColor = function(t) {
    this.line.material.color.copy(t), this.cone.material.color.copy(t);
  }, zo.prototype.copy = function(t) {
    return N.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
  }, zo.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, vr.prototype = Object.create(mi.prototype), vr.prototype.constructor = vr, Ee.create = function(t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ee.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
  }, Object.assign(Oo.prototype, {
    createPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getPoints(t), this.createGeometry(t);
    },
    createSpacedPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getSpacedPoints(t), this.createGeometry(t);
    },
    createGeometry: function(t) {
      console.warn(
        "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      for (var e = new j(), i = 0, n = t.length; i < n; i++) {
        var o = t[i];
        e.vertices.push(new u(o.x, o.y, o.z || 0));
      }
      return e;
    }
  }), Object.assign(ar.prototype, {
    fromPoints: function(t) {
      console.warn(
        "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
      ), this.setFromPoints(t);
    }
  }), pu.prototype = Object.create(Pn.prototype), du.prototype = Object.create(Pn.prototype), Ph.prototype = Object.create(Pn.prototype), Object.assign(Ph.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error(
        "THREE.Spline: .reparametrizeByArcLength() has been removed."
      );
    }
  }), rl.prototype.setColors = function() {
    console.error(
      "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
  }, va.prototype.update = function() {
    console.error(
      "THREE.SkeletonHelper: update() no longer needs to be called."
    );
  }, Object.assign(Io.prototype, {
    extractUrlBase: function(t) {
      return console.warn(
        "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
      ), Ds.extractUrlBase(t);
    }
  }), Object.assign(Ps.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(Ka.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(Qo.prototype, {
    center: function(t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    size: function(t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), Object.assign(k.prototype, {
    center: function(t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    },
    size: function(t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), ma.prototype.center = function(t) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  }, Object.assign(fi, {
    random16: function() {
      return console.warn(
        "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
      ), Math.random();
    },
    nearestPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
      ), fi.floorPowerOfTwo(t);
    },
    nextPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
      ), fi.ceilPowerOfTwo(t);
    }
  }), Object.assign(m.prototype, {
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
      ), t.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  }), Object.assign(c.prototype, {
    extractPosition: function(t) {
      return console.warn(
        "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
      ), this.copyPosition(t);
    },
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    getPosition: function() {
      var t;
      return function() {
        return t === void 0 && (t = new u()), console.warn(
          "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
        ), t.setFromMatrixColumn(this, 3);
      };
    }(),
    setRotationFromQuaternion: function(t) {
      return console.warn(
        "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
      ), this.makeRotationFromQuaternion(t);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector4: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(t) {
      console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
      ), t.transformDirection(this);
    },
    crossVector: function(t) {
      return console.warn(
        "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(t, e, i, n, o, l) {
      return console.warn(
        "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
      ), this.makePerspective(t, e, n, i, o, l);
    }
  }), F.prototype.isIntersectionLine = function(t) {
    return console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ), this.intersectsLine(t);
  }, d.prototype.multiplyVector3 = function(t) {
    return console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ), t.applyQuaternion(this);
  }, Object.assign(Li.prototype, {
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionPlane: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
      ), this.intersectsPlane(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    }
  }), Object.assign(Oe.prototype, {
    area: function() {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    },
    barycoordFromPoint: function(t, e) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), this.getBarycoord(t, e);
    },
    midpoint: function(t) {
      return console.warn(
        "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
      ), this.getMidpoint(t);
    },
    normal: function(t) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), this.getNormal(t);
    },
    plane: function(t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    }
  }), Object.assign(Oe, {
    barycoordFromPoint: function(t, e, i, n, o) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), Oe.getBarycoord(t, e, i, n, o);
    },
    normal: function(t, e, i, n) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), Oe.getNormal(t, e, i, n);
    }
  }), Object.assign($n.prototype, {
    extractAllPoints: function(t) {
      return console.warn(
        "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
      ), this.extractPoints(t);
    },
    extrude: function(t) {
      return console.warn(
        "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
      ), new Ao(this, t);
    },
    makeGeometry: function(t) {
      return console.warn(
        "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
      ), new Po(this, t);
    }
  }), Object.assign(s.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(u.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
      );
    },
    setEulerFromQuaternion: function() {
      console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
      );
    },
    getPositionFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
      ), this.setFromMatrixPosition(t);
    },
    getScaleFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
      ), this.setFromMatrixScale(t);
    },
    getColumnFromMatrix: function(t, e) {
      return console.warn(
        "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
      ), this.setFromMatrixColumn(e, t);
    },
    applyProjection: function(t) {
      return console.warn(
        "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
      ), this.applyMatrix4(t);
    },
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(_.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(j.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
  }), Object.assign(N.prototype, {
    getChildByName: function(t) {
      return console.warn(
        "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
      ), this.getObjectByName(t);
    },
    renderDepth: function() {
      console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
      );
    },
    translate: function(t, e) {
      return console.warn(
        "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
      ), this.translateOnAxis(e, t);
    },
    getWorldRotation: function() {
      console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
      );
    }
  }), Object.defineProperties(N.prototype, {
    eulerOrder: {
      get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      },
      set: function(t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
      set: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      }
    }
  }), Object.defineProperties(tn.prototype, {
    objects: {
      get: function() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      }
    }
  }), Object.defineProperty(sn.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  }), Object.defineProperty(Ee.prototype, "__arcLengthDivisions", {
    get: function() {
      return console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions;
    },
    set: function(t) {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions = t;
    }
  }), _e.prototype.setLens = function(t, e) {
    console.warn(
      "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    ), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
  }, Object.defineProperties($i.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
        ), this.shadow.camera.fov = t;
      }
    },
    shadowCameraLeft: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
        ), this.shadow.camera.left = t;
      }
    },
    shadowCameraRight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
        ), this.shadow.camera.right = t;
      }
    },
    shadowCameraTop: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
        ), this.shadow.camera.top = t;
      }
    },
    shadowCameraBottom: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
        ), this.shadow.camera.bottom = t;
      }
    },
    shadowCameraNear: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
        ), this.shadow.camera.near = t;
      }
    },
    shadowCameraFar: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
        ), this.shadow.camera.far = t;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn(
          "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
        );
      }
    },
    shadowBias: {
      set: function(t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
        ), this.shadow.mapSize.width = t;
      }
    },
    shadowMapHeight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
        ), this.shadow.mapSize.height = t;
      }
    }
  }), Object.defineProperties(J.prototype, {
    length: {
      get: function() {
        return console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ), this.array.length;
      }
    },
    copyIndicesArray: function() {
      console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
      );
    }
  }), Object.assign(Ft.prototype, {
    addIndex: function(t) {
      console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
      ), this.setIndex(t);
    },
    addDrawCall: function(t, e, i) {
      i !== void 0 && console.warn(
        "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
      ), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    },
    clearDrawCalls: function() {
      console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
      ), this.clearGroups();
    },
    computeTangents: function() {
      console.warn(
        "THREE.BufferGeometry: .computeTangents() has been removed."
      );
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
  }), Object.defineProperties(Ft.prototype, {
    drawcalls: {
      get: function() {
        return console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ), this.groups;
      }
    },
    offsets: {
      get: function() {
        return console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ), this.groups;
      }
    }
  }), Object.assign(lo.prototype, {
    getArrays: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
      );
    },
    addShapeList: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
      );
    },
    addShape: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
      );
    }
  }), Object.defineProperties(jl.prototype, {
    dynamic: {
      set: function() {
        console.warn(
          "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
        );
      }
    },
    onUpdate: {
      value: function() {
        return console.warn(
          "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
        ), this;
      }
    }
  }), Object.defineProperties(Yt.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new L();
      }
    },
    shading: {
      get: function() {
        console.error(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        );
      },
      set: function(t) {
        console.warn(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        ), this.flatShading = t === 1;
      }
    }
  }), Object.defineProperties(Wr.prototype, {
    metal: {
      get: function() {
        return console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
        ), !1;
      },
      set: function() {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
        );
      }
    }
  }), Object.defineProperties($e.prototype, {
    derivatives: {
      get: function() {
        return console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives;
      },
      set: function(t) {
        console.warn(
          "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives = t;
      }
    }
  }), Object.assign(xe.prototype, {
    clearTarget: function(t, e, i, n) {
      console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
      ), this.setRenderTarget(t), this.clear(e, i, n);
    },
    animate: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
      ), this.setAnimationLoop(t);
    },
    getCurrentRenderTarget: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
      ), this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
      ), this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
      ), this.capabilities.precision;
    },
    resetGLState: function() {
      return console.warn(
        "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
      ), this.state.reset();
    },
    supportsFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      ), this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      ), this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      ), this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      ), this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      ), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      ), this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
      ), this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      ), this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
      ), this.setScissorTest(t);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }
  }), Object.defineProperties(xe.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
        ), this.shadowMap.enabled = t;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
        ), this.shadowMap.type = t;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(ye.prototype, {
    cullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(S.prototype, {
    wrapS: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
      }
    },
    wrapT: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
      }
    },
    magFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter = t;
      }
    },
    minFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter = t;
      }
    },
    anisotropy: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy = t;
      }
    },
    offset: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset = t;
      }
    },
    repeat: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat = t;
      }
    },
    format: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format = t;
      }
    },
    type: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
      }
    },
    generateMipmaps: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps = t;
      }
    }
  }), Object.defineProperties(di.prototype, {
    standing: {
      set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      }
    },
    userHeight: {
      set: function() {
        console.warn("THREE.WebVRManager: .userHeight has been removed.");
      }
    }
  }), pa.prototype.load = function(t) {
    console.warn(
      "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
    );
    var e = this;
    return new pn().load(t, function(i) {
      e.setBuffer(i);
    }), this;
  }, Ls.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  }, Qa.prototype.updateCubeMap = function(t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
  }, ts.crossOrigin = void 0, ts.loadTexture = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    var o = new ln();
    return o.setCrossOrigin(this.crossOrigin), t = o.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, ts.loadTextureCube = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    var o = new ki();
    return o.setCrossOrigin(this.crossOrigin), t = o.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, ts.loadCompressedTexture = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
  }, ts.loadCompressedTextureCube = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
  }, x.WebGLRenderTargetCube = C, x.WebGLRenderTarget = S, x.WebGLRenderer = xe, x.ShaderLib = go, x.UniformsLib = qe, x.UniformsUtils = Dn, x.ShaderChunk = Ei, x.FogExp2 = Le, x.Fog = wn, x.Scene = Hn, x.Sprite = Qi, x.LOD = tn, x.SkinnedMesh = Fi, x.Skeleton = sn, x.Bone = an, x.Mesh = pi, x.LineSegments = mi, x.LineLoop = so, x.Line = Vi, x.Points = Ks, x.Group = ui, x.VideoTexture = yh, x.DataTexture = O, x.DataTexture3D = Q, x.CompressedTexture = Ho, x.CubeTexture = z, x.CanvasTexture = Fa, x.DepthTexture = Ua, x.Texture = g, x.AnimationLoader = Qt, x.CompressedTextureLoader = Zt, x.DataTextureLoader = Ue, x.CubeTextureLoader = ki, x.TextureLoader = ln, x.ObjectLoader = Ka, x.MaterialLoader = Hl, x.BufferGeometryLoader = wh, x.DefaultLoadingManager = Kn, x.LoadingManager = Zo, x.JSONLoader = Ps, x.ImageLoader = si, x.ImageBitmapLoader = Th, x.FontLoader = uu, x.FileLoader = Lt, x.Loader = Io, x.LoaderUtils = Ds, x.Cache = yo, x.AudioLoader = pn, x.SpotLightShadow = Ja, x.SpotLight = $a, x.PointLight = Cs, x.RectAreaLight = Gl, x.HemisphereLight = Za, x.DirectionalLightShadow = $o, x.DirectionalLight = mo, x.AmbientLight = As, x.LightShadow = po, x.Light = $i, x.StereoCamera = Gn, x.PerspectiveCamera = _e, x.OrthographicCamera = fa, x.CubeCamera = Qa, x.ArrayCamera = Fe, x.Camera = Be, x.AudioListener = Wl, x.PositionalAudio = tl, x.AudioContext = Dh, x.AudioAnalyser = Ls, x.Audio = pa, x.VectorKeyframeTrack = ua, x.StringKeyframeTrack = Ul, x.QuaternionKeyframeTrack = ha, x.NumberKeyframeTrack = jr, x.ColorKeyframeTrack = Fl, x.BooleanKeyframeTrack = Nl, x.PropertyMixer = el, x.PropertyBinding = Tn, x.KeyframeTrack = Un, x.AnimationUtils = Wn, x.AnimationObjectGroup = da, x.AnimationMixer = Ko, x.AnimationClip = gr, x.Uniform = jl, x.InstancedBufferGeometry = Eh, x.BufferGeometry = Ft, x.Geometry = j, x.InterleavedBufferAttribute = Di, x.InstancedInterleavedBuffer = bh, x.InterleavedBuffer = Ii, x.InstancedBufferAttribute = Ch, x.Face3 = R, x.Object3D = N, x.Raycaster = cu, x.Layers = U, x.EventDispatcher = a, x.Clock = Sh, x.QuaternionLinearInterpolant = ir, x.LinearInterpolant = Cr, x.DiscreteInterpolant = bs, x.CubicInterpolant = Ya, x.Interpolant = Zn, x.Triangle = Oe, x.Math = fi, x.Spherical = Ah, x.Cylindrical = it, x.Plane = F, x.Frustum = E, x.Sphere = D, x.Ray = Li, x.Matrix4 = c, x.Matrix3 = m, x.Box3 = k, x.Box2 = Qo, x.Line3 = ma, x.Euler = b, x.Vector4 = _, x.Vector3 = u, x.Vector2 = s, x.Quaternion = d, x.Color = L, x.ImmediateRenderObject = Vn, x.VertexNormalsHelper = yi, x.SpotLightHelper = ga, x.SkeletonHelper = va, x.PointLightHelper = Pr, x.RectAreaLightHelper = ya, x.HemisphereLightHelper = _a, x.GridHelper = rl, x.PolarGridHelper = Xl, x.FaceNormalsHelper = ol, x.DirectionalLightHelper = lr, x.CameraHelper = sl, x.BoxHelper = Do, x.Box3Helper = al, x.PlaneHelper = ll, x.ArrowHelper = zo, x.AxesHelper = vr, x.Shape = $n, x.Path = ar, x.ShapePath = Vl, x.Font = Mh, x.CurvePath = Oo, x.Curve = Ee, x.ImageUtils = ts, x.ShapeUtils = vo, x.WebGLUtils = He, x.WireframeGeometry = Qs, x.ParametricGeometry = Ga, x.ParametricBufferGeometry = ta, x.TetrahedronGeometry = Ha, x.TetrahedronBufferGeometry = ea, x.OctahedronGeometry = Va, x.OctahedronBufferGeometry = ps, x.IcosahedronGeometry = Wa, x.IcosahedronBufferGeometry = ia, x.DodecahedronGeometry = na, x.DodecahedronBufferGeometry = ra, x.PolyhedronGeometry = Wi, x.PolyhedronBufferGeometry = _i, x.TubeGeometry = fn, x.TubeBufferGeometry = Vo, x.TorusKnotGeometry = Vr, x.TorusKnotBufferGeometry = ds, x.TorusGeometry = ms, x.TorusBufferGeometry = Nn, x.TextGeometry = Xa, x.TextBufferGeometry = vs, x.SphereGeometry = Wo, x.SphereBufferGeometry = Er, x.RingGeometry = qa, x.RingBufferGeometry = ys, x.PlaneGeometry = ke, x.PlaneBufferGeometry = ce, x.LatheGeometry = aa, x.LatheBufferGeometry = jo, x.ShapeGeometry = Po, x.ShapeBufferGeometry = Xo, x.ExtrudeGeometry = Ao, x.ExtrudeBufferGeometry = lo, x.EdgesGeometry = qo, x.ConeGeometry = la, x.ConeBufferGeometry = Fn, x.CylinderGeometry = Lo, x.CylinderBufferGeometry = Ro, x.CircleGeometry = _s, x.CircleBufferGeometry = ho, x.BoxGeometry = Ot, x.BoxBufferGeometry = Bt, x.ShadowMaterial = Yo, x.SpriteMaterial = Ui, x.RawShaderMaterial = xs, x.ShaderMaterial = $e, x.PointsMaterial = Bn, x.MeshPhysicalMaterial = ws, x.MeshStandardMaterial = uo, x.MeshPhongMaterial = Wr, x.MeshToonMaterial = Ts, x.MeshNormalMaterial = Ms, x.MeshLambertMaterial = br, x.MeshDepthMaterial = se, x.MeshDistanceMaterial = te, x.MeshBasicMaterial = Ge, x.MeshMatcapMaterial = Ss, x.LineDashedMaterial = Es, x.LineBasicMaterial = zi, x.Material = Yt, x.Float64BufferAttribute = At, x.Float32BufferAttribute = Et, x.Uint32BufferAttribute = Pt, x.Int32BufferAttribute = G, x.Uint16BufferAttribute = _t, x.Int16BufferAttribute = et, x.Uint8ClampedBufferAttribute = It, x.Uint8BufferAttribute = ct, x.Int8BufferAttribute = K, x.BufferAttribute = J, x.ArcCurve = ca, x.CatmullRomCurve3 = Pn, x.CubicBezierCurve = rr, x.CubicBezierCurve3 = wi, x.EllipseCurve = Jn, x.LineCurve = or, x.LineCurve3 = Ar, x.QuadraticBezierCurve = sr, x.QuadraticBezierCurve3 = fo, x.SplineCurve = Xr, x.REVISION = "98", x.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, x.CullFaceNone = 0, x.CullFaceBack = 1, x.CullFaceFront = 2, x.CullFaceFrontBack = 3, x.FrontFaceDirectionCW = 0, x.FrontFaceDirectionCCW = 1, x.BasicShadowMap = 0, x.PCFShadowMap = 1, x.PCFSoftShadowMap = 2, x.FrontSide = 0, x.BackSide = 1, x.DoubleSide = 2, x.FlatShading = 1, x.SmoothShading = 2, x.NoColors = 0, x.FaceColors = 1, x.VertexColors = 2, x.NoBlending = 0, x.NormalBlending = 1, x.AdditiveBlending = 2, x.SubtractiveBlending = 3, x.MultiplyBlending = 4, x.CustomBlending = 5, x.AddEquation = 100, x.SubtractEquation = 101, x.ReverseSubtractEquation = 102, x.MinEquation = 103, x.MaxEquation = 104, x.ZeroFactor = 200, x.OneFactor = 201, x.SrcColorFactor = 202, x.OneMinusSrcColorFactor = 203, x.SrcAlphaFactor = 204, x.OneMinusSrcAlphaFactor = 205, x.DstAlphaFactor = 206, x.OneMinusDstAlphaFactor = 207, x.DstColorFactor = 208, x.OneMinusDstColorFactor = 209, x.SrcAlphaSaturateFactor = 210, x.NeverDepth = 0, x.AlwaysDepth = 1, x.LessDepth = 2, x.LessEqualDepth = 3, x.EqualDepth = 4, x.GreaterEqualDepth = 5, x.GreaterDepth = 6, x.NotEqualDepth = 7, x.MultiplyOperation = 0, x.MixOperation = 1, x.AddOperation = 2, x.NoToneMapping = 0, x.LinearToneMapping = 1, x.ReinhardToneMapping = 2, x.Uncharted2ToneMapping = 3, x.CineonToneMapping = 4, x.UVMapping = 300, x.CubeReflectionMapping = 301, x.CubeRefractionMapping = 302, x.EquirectangularReflectionMapping = 303, x.EquirectangularRefractionMapping = 304, x.SphericalReflectionMapping = 305, x.CubeUVReflectionMapping = 306, x.CubeUVRefractionMapping = 307, x.RepeatWrapping = 1e3, x.ClampToEdgeWrapping = 1001, x.MirroredRepeatWrapping = 1002, x.NearestFilter = 1003, x.NearestMipMapNearestFilter = 1004, x.NearestMipMapLinearFilter = 1005, x.LinearFilter = 1006, x.LinearMipMapNearestFilter = 1007, x.LinearMipMapLinearFilter = 1008, x.UnsignedByteType = 1009, x.ByteType = 1010, x.ShortType = 1011, x.UnsignedShortType = 1012, x.IntType = 1013, x.UnsignedIntType = 1014, x.FloatType = 1015, x.HalfFloatType = 1016, x.UnsignedShort4444Type = 1017, x.UnsignedShort5551Type = 1018, x.UnsignedShort565Type = 1019, x.UnsignedInt248Type = 1020, x.AlphaFormat = 1021, x.RGBFormat = 1022, x.RGBAFormat = 1023, x.LuminanceFormat = 1024, x.LuminanceAlphaFormat = 1025, x.RGBEFormat = 1023, x.DepthFormat = 1026, x.DepthStencilFormat = 1027, x.RedFormat = 1028, x.RGB_S3TC_DXT1_Format = 33776, x.RGBA_S3TC_DXT1_Format = 33777, x.RGBA_S3TC_DXT3_Format = 33778, x.RGBA_S3TC_DXT5_Format = 33779, x.RGB_PVRTC_4BPPV1_Format = 35840, x.RGB_PVRTC_2BPPV1_Format = 35841, x.RGBA_PVRTC_4BPPV1_Format = 35842, x.RGBA_PVRTC_2BPPV1_Format = 35843, x.RGB_ETC1_Format = 36196, x.RGBA_ASTC_4x4_Format = 37808, x.RGBA_ASTC_5x4_Format = 37809, x.RGBA_ASTC_5x5_Format = 37810, x.RGBA_ASTC_6x5_Format = 37811, x.RGBA_ASTC_6x6_Format = 37812, x.RGBA_ASTC_8x5_Format = 37813, x.RGBA_ASTC_8x6_Format = 37814, x.RGBA_ASTC_8x8_Format = 37815, x.RGBA_ASTC_10x5_Format = 37816, x.RGBA_ASTC_10x6_Format = 37817, x.RGBA_ASTC_10x8_Format = 37818, x.RGBA_ASTC_10x10_Format = 37819, x.RGBA_ASTC_12x10_Format = 37820, x.RGBA_ASTC_12x12_Format = 37821, x.LoopOnce = 2200, x.LoopRepeat = 2201, x.LoopPingPong = 2202, x.InterpolateDiscrete = 2300, x.InterpolateLinear = 2301, x.InterpolateSmooth = 2302, x.ZeroCurvatureEnding = 2400, x.ZeroSlopeEnding = 2401, x.WrapAroundEnding = 2402, x.TrianglesDrawMode = 0, x.TriangleStripDrawMode = 1, x.TriangleFanDrawMode = 2, x.LinearEncoding = 3e3, x.sRGBEncoding = 3001, x.GammaEncoding = 3007, x.RGBEEncoding = 3002, x.LogLuvEncoding = 3003, x.RGBM7Encoding = 3004, x.RGBM16Encoding = 3005, x.RGBDEncoding = 3006, x.BasicDepthPacking = 3200, x.RGBADepthPacking = 3201, x.TangentSpaceNormalMap = 0, x.ObjectSpaceNormalMap = 1, x.CubeGeometry = Ot, x.Face4 = function(t, e, i, n, o, l, f) {
    return console.warn(
      "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
    ), new R(t, e, i, o, l, f);
  }, x.LineStrip = 0, x.LinePieces = 1, x.MeshFaceMaterial = function(t) {
    return console.warn(
      "THREE.MeshFaceMaterial has been removed. Use an Array instead."
    ), t;
  }, x.MultiMaterial = function(t) {
    return t === void 0 && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
      return t.slice();
    }, t;
  }, x.PointCloud = function(t, e) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ks(t, e);
  }, x.Particle = function(t) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Qi(t);
  }, x.ParticleSystem = function(t, e) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ks(t, e);
  }, x.PointCloudMaterial = function(t) {
    return console.warn(
      "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
    ), new Bn(t);
  }, x.ParticleBasicMaterial = function(t) {
    return console.warn(
      "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
    ), new Bn(t);
  }, x.ParticleSystemMaterial = function(t) {
    return console.warn(
      "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
    ), new Bn(t);
  }, x.Vertex = function(t, e, i) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new u(t, e, i);
  }, x.DynamicBufferAttribute = function(t, e) {
    return console.warn(
      "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
    ), new J(t, e).setDynamic(!0);
  }, x.Int8Attribute = function(t, e) {
    return console.warn(
      "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
    ), new K(t, e);
  }, x.Uint8Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
    ), new ct(t, e);
  }, x.Uint8ClampedAttribute = function(t, e) {
    return console.warn(
      "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
    ), new It(t, e);
  }, x.Int16Attribute = function(t, e) {
    return console.warn(
      "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
    ), new et(t, e);
  }, x.Uint16Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
    ), new _t(t, e);
  }, x.Int32Attribute = function(t, e) {
    return console.warn(
      "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
    ), new G(t, e);
  }, x.Uint32Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
    ), new Pt(t, e);
  }, x.Float32Attribute = function(t, e) {
    return console.warn(
      "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
    ), new Et(t, e);
  }, x.Float64Attribute = function(t, e) {
    return console.warn(
      "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
    ), new At(t, e);
  }, x.ClosedSplineCurve3 = pu, x.SplineCurve3 = du, x.Spline = Ph, x.AxisHelper = function(t) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new vr(t);
  }, x.BoundingBoxHelper = function(t, e) {
    return console.warn(
      "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
    ), new Do(t, e);
  }, x.EdgesHelper = function(t, e) {
    return console.warn(
      "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
    ), new mi(
      new qo(t.geometry),
      new zi({ color: e !== void 0 ? e : 16777215 })
    );
  }, x.WireframeHelper = function(t, e) {
    return console.warn(
      "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
    ), new mi(
      new Qs(t.geometry),
      new zi({ color: e !== void 0 ? e : 16777215 })
    );
  }, x.XHRLoader = function(t) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Lt(t);
  }, x.BinaryTextureLoader = function(t) {
    return console.warn(
      "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
    ), new Ue(t);
  }, x.GeometryUtils = {
    merge: function(t, e, i) {
      if (console.warn(
        "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
      ), e.isMesh) {
        e.matrixAutoUpdate && e.updateMatrix();
        var n = e.matrix;
        e = e.geometry;
      }
      t.merge(e, n, i);
    },
    center: function(t) {
      return console.warn(
        "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
      ), t.center();
    }
  }, x.Projector = function() {
    console.error(
      "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
    ), this.projectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .projectVector() is now vector.project()."
      ), t.project(e);
    }, this.unprojectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .unprojectVector() is now vector.unproject()."
      ), t.unproject(e);
    }, this.pickingRay = function() {
      console.error(
        "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
      );
    };
  }, x.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  }, x.SceneUtils = {
    createMultiMaterialObject: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    detach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    attach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    }
  }, x.LensFlare = function() {
    console.error(
      "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
    );
  }, Object.defineProperty(x, "__esModule", { value: !0 });
});
THREE.Sky = function() {
  var x = THREE.Sky.SkyShader, a = new THREE.ShaderMaterial({
    fragmentShader: x.fragmentShader,
    vertexShader: x.vertexShader,
    uniforms: THREE.UniformsUtils.clone(x.uniforms),
    side: THREE.BackSide
  });
  THREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), a);
};
THREE.Sky.prototype = Object.create(THREE.Mesh.prototype);
THREE.Sky.SkyShader = {
  uniforms: {
    luminance: { value: 1 },
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new THREE.Vector3() }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    // wavelength of used primaries, according to preetham
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
    // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    // mie stuff
    // K coefficient for the primaries
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    // earth shadow hack
    // cutoffAngle = pi / 1.95;
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    // set z to camera.far
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    // extinction (absorbtion + out scattering)
    // rayleigh coefficients
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    // mie coefficients
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join(`
`),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float luminance;",
    "uniform float mieDirectionalG;",
    "const vec3 cameraPos = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    // refractive index of air
    "const float N = 2.545E25;",
    // number of molecules per unit volume for air at
    // 288.15K and 1013mb (sea level -45 celsius)
    // optical length at zenith for molecules
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // 66 arc seconds -> degrees, and the cosine of that
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    // 3.0 / ( 16.0 * pi )
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    // 1.0 / ( 4.0 * pi )
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    // Filmic ToneMapping http://filmicgames.com/archives/75
    "const float A = 0.15;",
    "const float B = 0.50;",
    "const float C = 0.10;",
    "const float D = 0.20;",
    "const float E = 0.02;",
    "const float F = 0.30;",
    "const float whiteScale = 1.0748724675633854;",
    // 1.0 / Uncharted2Tonemap(1000.0)
    "vec3 Uncharted2Tonemap( vec3 x ) {",
    "	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
    "}",
    "void main() {",
    // optical length
    // cutoff angle at 90 to avoid singularity in next formula.
    "	float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    // combined extinction factor
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    // in scattering
    "	float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    // nightsky
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    // composition + solar disc
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );",
    "	vec3 color = curr * whiteScale;",
    "	vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "}"
  ].join(`
`)
};
(function(x) {
  typeof module > "u" ? window.charming = x : module.exports = x;
})(function(x, a) {
  a = a || {};
  var s = a.tagName || "span", c = a.classPrefix != null ? a.classPrefix : "char", d = 1, u = function(m) {
    for (var g = m.parentNode, _ = m.nodeValue, S = _.length, C = -1; ++C < S; ) {
      var O = document.createElement(s);
      c && (O.className = c + d, d++), O.appendChild(document.createTextNode(_[C])), g.insertBefore(O, m);
    }
    g.removeChild(m);
  };
  return function m(g) {
    for (var _ = [].slice.call(g.childNodes), S = _.length, C = -1; ++C < S; )
      m(_[C]);
    g.nodeType === Node.TEXT_NODE && u(g);
  }(x), x;
});
class v1 {
  constructor(a = []) {
    mars3d ? (this.tilesetLayer, this.modelArr = a, this.bimObliquePhotographyId = [], this.editDate = {
      id: null
    }) : console.error("未引入指定插件");
  }
  /**
   * 给 modelArr 添加数据
   * @param  { Object } mode 模型数据
   */
  pushModel(a) {
    this.modelArr.push(a);
  }
  /**
   * add 模型方法
   * @param  { Object || String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   * @param  { Object } customAttributes 自定义属性
   */
  add(a, s, c) {
    let d = c == null ? void 0 : c.isClone;
    const u = /* @__PURE__ */ new Map([
      ["click", mars3d.EventType.click],
      ["initialTilesLoaded", mars3d.EventType.initialTilesLoaded]
    ]);
    return new Promise((m, g) => {
      let _, S, C, O, k, D, F, E, L, T = {
        enabled: !0,
        precise: !1,
        czm: !1
        // maxCanvasSize: 7000,
      }, M = { enabled: !0, precise: !1, czm: !1 };
      if (typeof a != "object") {
        let b = this.query(a);
        b || g("缺少树结构");
        let { id: U, bimModelExcavationDetails: N, bimModel: j } = b;
        _ = U, S = j.modelType, C = j.tender, O = j.releasedDistance, k = j.modelName, D = j.isDynamicReleased, F = {
          bimModelExcavationDetails: N
        }, E = b.url, L = j.modelColor, T.maxCanvasSize = j.gridResolution || 4080;
      } else
        _ = a.modelId, S = a.modelType, C = a.tender, O = a.releasedDistance, k = a.modelTitle, D = a.permission, F = a.customize, E = a.url, L = a.color, T.maxCanvasSize = a.maxCanvasSize || 4080;
      c && (c.color && (L = c.color), c.clip && (T.area = c.clip.handleDataList), c.flat && (M.area = c.flat.handleDataList), c.maxCanvasSize && (T.maxCanvasSize = c.maxCanvasSize || 4080));
      let R;
      if (d ? window.mapClone && (R = window.mapClone.mapEx.getLayer(a, "modelId")) : R = window.map.getLayer(a, "modelId"), R)
        return m(R), c.color && this.editColor(
          a,
          c.color,
          c
        ), !1;
      if (E.indexOf("tileset.json") < 0)
        return console.error("链接不完整", k), m({
          tite: "【模型】「" + k + "」链接地址有误",
          type: "error",
          id: _,
          url: E
        }), !1;
      new Cesium.Resource({
        url: E
      }).fetchJson().then((U) => {
        let N = null;
        L && (N = {
          color: { conditions: [["true", L]] }
        }), this.tilesetLayer = new mars3d.layer.TilesetLayer({
          modelId: _,
          modelType: S,
          tender: C,
          releasedDistance: O,
          modelTitle: k,
          permission: D,
          customize: F,
          url: encodeURI(E),
          skipLevelOfDetail: !1,
          loadSiblings: !0,
          cullRequestsWhileMoving: !0,
          cullRequestsWhileMovingMultiplier: 10,
          preferLeaves: !0,
          progressiveResolutionHeightFraction: 0.5,
          dynamicScreenSpaceError: !0,
          preloadWhenHidden: !1,
          style: N,
          clip: T,
          flat: M,
          maximumScreenSpaceError: 16
          // customShader: new Cesium.CustomShader({
          //   lightingModel: Cesium.LightingModel.UNLIT,
          // }),
        }), this.tilesetLayer.bindPopup((j) => {
          if (j.graphic) {
            const J = j.graphic.attr;
            let K = null, ct = null;
            return JSON.stringify(J) !== "{}" ? (J.name && (K = J.name.lastIndexOf("@")), K && K > -1 && (ct = J.name.slice(0, K)), J.name ? `&nbsp;&nbsp;<span>${ct || J.name}</span>&nbsp;&nbsp;` : `&nbsp;&nbsp;<span>${k}</span>&nbsp;&nbsp;`) : `&nbsp;&nbsp;<span>${k}</span>&nbsp;&nbsp;`;
          } else
            return `&nbsp;&nbsp;<span>${k}</span>&nbsp;&nbsp;`;
        }), this.tilesetLayer.readyPromise.then((j) => {
          m(j);
        }).catch((j) => {
          console.log("加载失败", j), m();
        }), this.tilesetLayer.on("click", (j) => {
          j.layer.style == null && map.bimMapEdit == "0" && j.layer.openHighlight(
            {
              color: "rgba(255,0,0,1)"
            },
            !0
          );
        }), s && Object.keys(s).forEach((j) => {
          this.tilesetLayer.on(u.get(j), (J) => {
            s[j](J);
          });
        }), S == 0 && this.bimObliquePhotographyId.push(_), d ? window.mapClone && window.mapClone.mapEx.addLayer(this.tilesetLayer) : window.map.addLayer(this.tilesetLayer);
      }).catch((U) => {
        console.error("数据加载失败", k), m({
          tite: "【模型】「" + k + "」无法加载",
          type: "error",
          id: _,
          url: E
        });
      });
    });
  }
  /**
   * 移除模型方法
   * @param  { String } id 模型id
   *
   */
  remove(a, s) {
    let c = s == null ? void 0 : s.isClone;
    window.map.getLayer(a, "modelId") && (c ? (window.mapClone.mapEx.getLayer(a, "modelId").closeHighlight(), window.mapClone.mapEx.removeLayer(
      window.mapClone.mapEx.getLayer(a, "modelId")
    )) : (window.map.getLayer(a, "modelId").closeHighlight(), window.map.removeLayer(window.map.getLayer(a, "modelId"))));
  }
  /**
   * 选中模型
   * @param  { String } id 模型id
   * @param  { Object } fn 自定义注册事件
   *
   */
  selected(a, s, c, d = !0) {
    return new Promise((u, m) => {
      let g = window.map.getLayer(a, "modelId");
      g ? (g.style == null && map.bimMapEdit == "0" && g.openHighlight(
        {
          color: "rgba(255,0,0,1)"
        },
        !0
      ), d ? g.flyTo({
        complete: () => {
          u(g);
        }
      }) : u(g)) : this.add(a, s, c).then((_) => {
        _ && (_.style == null && map.bimMapEdit == "0" && _.openHighlight(
          {
            color: "rgba(255,0,0,1)"
          },
          !0
        ), d ? _.flyTo({
          complete: () => {
            u(_);
          }
        }) : u(_));
      });
    });
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArr = [], this.bimObliquePhotographyId = [], this.tilesetLayer = null;
  }
  /**
   * 查询动态释放模型方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(a) {
    return this.modelArr.length == 0 ? !1 : this.modelArr.find((s) => s.id == a);
  }
  /**
   * 查询矢量数据的实体
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 返回标绘实体
   */
  queryModel(a) {
    return window.map.getLayer(a, "modelId");
  }
  /**
   * 用户操作的模型
   * @param  { String } id 模型属性
   */
  postEditDate(a) {
    this.editDate = {
      id: a
    };
  }
  /**
   * 更新模型颜色
   * @param  { String | Object} id 模型属性 或者 模型对象
   * @param  { String | Number } newColor 需要着色的颜色
   * @param  { String } selectcontent 判断逻辑 默认是全部染色
   */
  editColor(a, s, c, d = "true") {
    let u, m = c == null ? void 0 : c.isClone;
    if (typeof a != "object" && (m ? u = window.mapClone.mapEx.getLayer(a, "modelId") : u = window.map.getLayer(a, "modelId")), u)
      if (s)
        u.style = {
          color: {
            conditions: [[d, s]]
          }
        };
      else {
        let g = this.query(a).bimModel.modelColor;
        g ? u.style = {
          color: { conditions: [[d, g]] }
        } : u.style = null;
      }
  }
  /**
   * 更新模型透明度
   * @param  { String } id 模型属性
   * @param  { String | Number } opacity 透明度值
   */
  editOpacity(a, s) {
    window.map.getLayer(a, "modelId").opacity = s;
  }
  /**
   * 模型挖洞
   */
  addClip(a) {
    return new Promise((s, c) => {
      window.bimClip ? s(bimClip.clipModelAdd(a)) : c("挖洞工具未初始化");
    });
  }
  /**
   * 模型挖洞 移除
   */
  removeClip(a) {
    window.bimClip ? window.bimClip.clipModelremoveClip(a) : console.log("挖洞工具未初始化");
  }
}
const Du = (x) => Object.prototype.toString.call(x) === "[object Object]";
function Uu() {
  const x = Array.from(arguments);
  if (x.length < 2)
    return x[0];
  let a = x[0];
  return x.shift(), x.forEach((s) => {
    if (Du(s)) {
      Du(a) || (a = {});
      for (let c in s)
        a[c] && Du(s[c]) ? a[c] = Uu(a[c], s[c]) : a[c] = s[c];
    } else
      s instanceof Array && (a instanceof Array || (a = []), s.forEach((c, d) => {
        Du(c) ? a[d] = Uu(a[d]) : a[d] = c;
      }));
  }), a;
}
let Vh = {};
const Up = (x, a, s) => {
  Vh = {};
  let { vectorStyle: c, difference: d } = x;
  if (c) {
    let { divType: u } = c, m = "";
    if (u) {
      let {
        theme_color: g,
        title: _,
        font_color: S,
        content: C,
        scaleByDistance: O,
        scaleByDistance_far: k,
        scaleByDistance_farValue: D,
        scaleByDistance_near: F,
        scaleByDistance_nearValue: E,
        distanceDisplayCondition: L,
        distanceDisplayCondition_far: T,
        distanceDisplayCondition_near: M,
        clampToGround: R,
        divStyle: b
        // theme_color2,
        // theme_color3,
      } = c, { theme_color2: U, theme_color3: N } = b;
      switch (u) {
        case "1":
          m = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${g};--theme-font-color1:${S};">
            <div class="title">${_}</div>
          </div >`;
          break;
        case "2":
          m = `<div class="entity-div-style entity-div-style2" style="--theme-color1:${g};--theme-font-color1:${S};">
            <div class="title">${_}</div>
             <div class="mars3d-divUpLabel-line"></div>
          </div >`;
          break;
        case "3":
          m = `<div class="entity-div-style entity-div-style3" style="--theme-color1:${g};--theme-font-color1:${S};--theme-color2:${U};--theme-color3:${N}">
            <div class="image"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="infotop"><div class="title">${_}</div><div class="content overflow-auto scrollbar h-full">${C}</div></div>
          </div >`;
          break;
        case "4":
          m = `<div class="entity-div-style entity-div-style4" style="--theme-color1:${g};--theme-font-color1:${S};">
            <div class="title">${_}</div>
          </div >`;
          break;
        case "5":
          m = `<div class="entity-div-style entity-div-style5 marsTiltPanel marsTiltPanel-theme-green" style="--theme-color1:${g};--theme-font-color1:${S};--theme-color2:${U};">
            <div class="marsTiltPanel-wrap">
              <div class="area">
                <div class="arrow-lt"></div>
                <div class="b-t"></div>
                <div class="b-r"></div>
                <div class="b-b"></div>
                <div class="b-l"></div>
                <div class="arrow-rb"></div>
                <div class="label-wrap">
                  <div class="title">${_}</div>
                  <div class="content">${C}</div>
                </div>
              </div>
              <div class="b-t-l"></div>
              <div class="b-b-r"></div>
            </div>
            <div class="arrow"></div>
          </div >`;
          break;
        case "6":
          m = `<div class="entity-div-style entity-div-style6" style="--theme-color1:${g};--theme-font-color1:${S};--theme-color2:${U};">
            <div class="title">${_}</div>
          </div >`;
          break;
        case "7":
          m = `<div class="entity-div-style entity-div-style7" style="--theme-color1:${g};--theme-font-color1:${S};">
            <div class="title">${_}</div>
            <div class="pile-number">
              <div class="circular"></div>
              <div class="pole"></div>
            </div>
          </div >`;
          break;
      }
      Vh = {
        html: m,
        scaleByDistance: O,
        scaleByDistance_far: k,
        scaleByDistance_farValue: D,
        scaleByDistance_near: F,
        scaleByDistance_nearValue: E,
        distanceDisplayCondition: L,
        distanceDisplayCondition_far: T,
        distanceDisplayCondition_near: M,
        clampToGround: R
      };
    } else
      x.difference && x.difference.length > 0 && x.difference.forEach((g) => {
        Uu(Vh, {
          [g]: c[g]
        });
      }), a && a.difference && a.difference.length > 0 && a.difference.forEach((g) => {
        Uu(Vh, {
          label: {
            [g]: a.labelStyle[g]
          }
        });
      });
  }
  return Vh;
};
var zr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function af(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var Gu = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Gu.exports;
(function(x, a) {
  (function() {
    var s, c = "4.17.21", d = 200, u = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", m = "Expected a function", g = "Invalid `variable` option passed into `_.template`", _ = "__lodash_hash_undefined__", S = 500, C = "__lodash_placeholder__", O = 1, k = 2, D = 4, F = 1, E = 2, L = 1, T = 2, M = 4, R = 8, b = 16, U = 32, N = 64, j = 128, J = 256, K = 512, ct = 30, It = "...", et = 800, _t = 16, G = 1, Pt = 2, Et = 3, At = 1 / 0, fe = 9007199254740991, re = 17976931348623157e292, Ft = 0 / 0, Ot = 4294967295, Bt = Ot - 1, ke = Ot >>> 1, ce = [
      ["ary", j],
      ["bind", L],
      ["bindKey", T],
      ["curry", R],
      ["curryRight", b],
      ["flip", K],
      ["partial", U],
      ["partialRight", N],
      ["rearg", J]
    ], Yt = "[object Arguments]", $e = "[object Array]", Li = "[object AsyncFunction]", Oe = "[object Boolean]", Ge = "[object Date]", pi = "[object DOMException]", Ri = "[object Error]", cn = "[object Function]", Ji = "[object GeneratorFunction]", W = "[object Map]", Jt = "[object Number]", Wt = "[object Null]", pt = "[object Object]", dt = "[object Promise]", Dt = "[object Proxy]", ie = "[object RegExp]", Kt = "[object Set]", z = "[object String]", Q = "[object Symbol]", st = "[object Undefined]", nt = "[object WeakMap]", vt = "[object WeakSet]", Gt = "[object ArrayBuffer]", Xt = "[object DataView]", jt = "[object Float32Array]", Ne = "[object Float64Array]", Re = "[object Int8Array]", ge = "[object Int16Array]", we = "[object Int32Array]", vi = "[object Uint8Array]", Mi = "[object Uint8ClampedArray]", ni = "[object Uint16Array]", Si = "[object Uint32Array]", Gr = /\b__p \+= '';/g, er = /\b(__p \+=) '' \+/g, rn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Co = /&(?:amp|lt|gt|quot|#39);/g, Oi = /[&<>"']/g, Go = RegExp(Co.source), io = RegExp(Oi.source), Pl = /<%-([\s\S]+?)%>/g, xn = /<%([\s\S]+?)%>/g, qs = /<%=([\s\S]+?)%>/g, us = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, dr = /^\w*$/, Ys = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ka = /[\\^$.*+?()[\]{}|]/g, Ll = RegExp(ka.source), no = /^\s+/, mh = /\s/, Zs = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Ba = /\{\n\/\* \[wrapped with (.+)\] \*/, ro = /,? & /, Na = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Js = /[()=,{}\[\]\/\s]/, $s = /\\(\\)?/g, oo = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Rl = /\w*$/, gh = /^[-+]0x[0-9a-f]+$/i, vh = /^0b[01]+$/i, cs = /^\[object .+?Constructor\]$/, fs = /^0o[0-7]+$/i, Ol = /^(?:0|[1-9]\d*)$/, Il = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Hr = /($^)/, V = /['\n\r\u2028\u2029\\]/g, tt = "\\ud800-\\udfff", lt = "\\u0300-\\u036f", at = "\\ufe20-\\ufe2f", X = "\\u20d0-\\u20ff", St = lt + at + X, ht = "\\u2700-\\u27bf", Rt = "a-z\\xdf-\\xf6\\xf8-\\xff", Ht = "\\xac\\xb1\\xd7\\xf7", kt = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Mt = "\\u2000-\\u206f", he = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", se = "A-Z\\xc0-\\xd6\\xd8-\\xde", te = "\\ufe0e\\ufe0f", ye = Ht + kt + Mt + he, ue = "['’]", je = "[" + tt + "]", He = "[" + ye + "]", ui = "[" + St + "]", Be = "\\d+", _e = "[" + ht + "]", Fe = "[" + Rt + "]", pe = "[^" + tt + ye + Be + ht + Rt + se + "]", di = "\\ud83c[\\udffb-\\udfff]", Pe = "(?:" + ui + "|" + di + ")", xe = "[^" + tt + "]", Le = "(?:\\ud83c[\\udde6-\\uddff]){2}", wn = "[\\ud800-\\udbff][\\udc00-\\udfff]", Hn = "[" + se + "]", Ii = "\\u200d", Di = "(?:" + Fe + "|" + pe + ")", Ui = "(?:" + Hn + "|" + pe + ")", Qi = "(?:" + ue + "(?:d|ll|m|re|s|t|ve))?", tn = "(?:" + ue + "(?:D|LL|M|RE|S|T|VE))?", sn = Pe + "?", an = "[" + te + "]?", Fi = "(?:" + Ii + "(?:" + [xe, Le, wn].join("|") + ")" + an + sn + ")*", zi = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Vi = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", mi = an + sn + Fi, so = "(?:" + [_e, Le, wn].join("|") + ")" + mi, Bn = "(?:" + [xe + ui + "?", ui, Le, wn, je].join("|") + ")", Ks = RegExp(ue, "g"), yh = RegExp(ui, "g"), Ho = RegExp(di + "(?=" + di + ")|" + Bn + mi, "g"), Fa = RegExp([
      Hn + "?" + Fe + "+" + Qi + "(?=" + [He, Hn, "$"].join("|") + ")",
      Ui + "+" + tn + "(?=" + [He, Hn + Di, "$"].join("|") + ")",
      Hn + "?" + Di + "+" + Qi,
      Hn + "+" + tn,
      Vi,
      zi,
      Be,
      so
    ].join("|"), "g"), Ua = RegExp("[" + Ii + tt + St + te + "]"), Qs = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ga = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], ta = -1, Wi = {};
    Wi[jt] = Wi[Ne] = Wi[Re] = Wi[ge] = Wi[we] = Wi[vi] = Wi[Mi] = Wi[ni] = Wi[Si] = !0, Wi[Yt] = Wi[$e] = Wi[Gt] = Wi[Oe] = Wi[Xt] = Wi[Ge] = Wi[Ri] = Wi[cn] = Wi[W] = Wi[Jt] = Wi[pt] = Wi[ie] = Wi[Kt] = Wi[z] = Wi[nt] = !1;
    var _i = {};
    _i[Yt] = _i[$e] = _i[Gt] = _i[Xt] = _i[Oe] = _i[Ge] = _i[jt] = _i[Ne] = _i[Re] = _i[ge] = _i[we] = _i[W] = _i[Jt] = _i[pt] = _i[ie] = _i[Kt] = _i[z] = _i[Q] = _i[vi] = _i[Mi] = _i[ni] = _i[Si] = !0, _i[Ri] = _i[cn] = _i[nt] = !1;
    var Ha = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, ea = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Va = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, ps = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Wa = parseFloat, ia = parseInt, na = typeof zr == "object" && zr && zr.Object === Object && zr, ra = typeof self == "object" && self && self.Object === Object && self, fn = na || ra || Function("return this")(), Vo = a && !a.nodeType && a, Vr = Vo && !0 && x && !x.nodeType && x, ds = Vr && Vr.exports === Vo, ms = ds && na.process, Nn = function() {
      try {
        var Lt = Vr && Vr.require && Vr.require("util").types;
        return Lt || ms && ms.binding && ms.binding("util");
      } catch {
      }
    }(), _h = Nn && Nn.isArrayBuffer, oa = Nn && Nn.isDate, sa = Nn && Nn.isMap, ru = Nn && Nn.isRegExp, ou = Nn && Nn.isSet, Dl = Nn && Nn.isTypedArray;
    function mr(Lt, Qt, Zt) {
      switch (Zt.length) {
        case 0:
          return Lt.call(Qt);
        case 1:
          return Lt.call(Qt, Zt[0]);
        case 2:
          return Lt.call(Qt, Zt[0], Zt[1]);
        case 3:
          return Lt.call(Qt, Zt[0], Zt[1], Zt[2]);
      }
      return Lt.apply(Qt, Zt);
    }
    function zl(Lt, Qt, Zt, Ue) {
      for (var si = -1, ki = Lt == null ? 0 : Lt.length; ++si < ki; ) {
        var ln = Lt[si];
        Qt(Ue, ln, Zt(ln), Lt);
      }
      return Ue;
    }
    function Yi(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length; ++Zt < Ue && Qt(Lt[Zt], Zt, Lt) !== !1; )
        ;
      return Lt;
    }
    function gs(Lt, Qt) {
      for (var Zt = Lt == null ? 0 : Lt.length; Zt-- && Qt(Lt[Zt], Zt, Lt) !== !1; )
        ;
      return Lt;
    }
    function xh(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length; ++Zt < Ue; )
        if (!Qt(Lt[Zt], Zt, Lt))
          return !1;
      return !0;
    }
    function Sr(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length, si = 0, ki = []; ++Zt < Ue; ) {
        var ln = Lt[Zt];
        Qt(ln, Zt, Lt) && (ki[si++] = ln);
      }
      return ki;
    }
    function ja(Lt, Qt) {
      var Zt = Lt == null ? 0 : Lt.length;
      return !!Zt && Er(Lt, Qt, 0) > -1;
    }
    function kl(Lt, Qt, Zt) {
      for (var Ue = -1, si = Lt == null ? 0 : Lt.length; ++Ue < si; )
        if (Zt(Qt, Lt[Ue]))
          return !0;
      return !1;
    }
    function Xi(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length, si = Array(Ue); ++Zt < Ue; )
        si[Zt] = Qt(Lt[Zt], Zt, Lt);
      return si;
    }
    function ao(Lt, Qt) {
      for (var Zt = -1, Ue = Qt.length, si = Lt.length; ++Zt < Ue; )
        Lt[si + Zt] = Qt[Zt];
      return Lt;
    }
    function Bl(Lt, Qt, Zt, Ue) {
      var si = -1, ki = Lt == null ? 0 : Lt.length;
      for (Ue && ki && (Zt = Lt[++si]); ++si < ki; )
        Zt = Qt(Zt, Lt[si], si, Lt);
      return Zt;
    }
    function su(Lt, Qt, Zt, Ue) {
      var si = Lt == null ? 0 : Lt.length;
      for (Ue && si && (Zt = Lt[--si]); si--; )
        Zt = Qt(Zt, Lt[si], si, Lt);
      return Zt;
    }
    function Ao(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length; ++Zt < Ue; )
        if (Qt(Lt[Zt], Zt, Lt))
          return !0;
      return !1;
    }
    var lo = jo("length");
    function au(Lt) {
      return Lt.split("");
    }
    function Xa(Lt) {
      return Lt.match(Na) || [];
    }
    function vs(Lt, Qt, Zt) {
      var Ue;
      return Zt(Lt, function(si, ki, ln) {
        if (Qt(si, ki, ln))
          return Ue = ki, !1;
      }), Ue;
    }
    function Wo(Lt, Qt, Zt, Ue) {
      for (var si = Lt.length, ki = Zt + (Ue ? 1 : -1); Ue ? ki-- : ++ki < si; )
        if (Qt(Lt[ki], ki, Lt))
          return ki;
      return -1;
    }
    function Er(Lt, Qt, Zt) {
      return Qt === Qt ? Nl(Lt, Qt, Zt) : Wo(Lt, ys, Zt);
    }
    function qa(Lt, Qt, Zt, Ue) {
      for (var si = Zt - 1, ki = Lt.length; ++si < ki; )
        if (Ue(Lt[si], Qt))
          return si;
      return -1;
    }
    function ys(Lt) {
      return Lt !== Lt;
    }
    function aa(Lt, Qt) {
      var Zt = Lt == null ? 0 : Lt.length;
      return Zt ? qo(Lt, Qt) / Zt : Ft;
    }
    function jo(Lt) {
      return function(Qt) {
        return Qt == null ? s : Qt[Lt];
      };
    }
    function Po(Lt) {
      return function(Qt) {
        return Lt == null ? s : Lt[Qt];
      };
    }
    function Xo(Lt, Qt, Zt, Ue, si) {
      return si(Lt, function(ki, ln, Ee) {
        Zt = Ue ? (Ue = !1, ki) : Qt(Zt, ki, ln, Ee);
      }), Zt;
    }
    function lu(Lt, Qt) {
      var Zt = Lt.length;
      for (Lt.sort(Qt); Zt--; )
        Lt[Zt] = Lt[Zt].value;
      return Lt;
    }
    function qo(Lt, Qt) {
      for (var Zt, Ue = -1, si = Lt.length; ++Ue < si; ) {
        var ki = Qt(Lt[Ue]);
        ki !== s && (Zt = Zt === s ? ki : Zt + ki);
      }
      return Zt;
    }
    function Lo(Lt, Qt) {
      for (var Zt = -1, Ue = Array(Lt); ++Zt < Lt; )
        Ue[Zt] = Qt(Zt);
      return Ue;
    }
    function Ro(Lt, Qt) {
      return Xi(Qt, function(Zt) {
        return [Zt, Lt[Zt]];
      });
    }
    function la(Lt) {
      return Lt && Lt.slice(0, ha(Lt) + 1).replace(no, "");
    }
    function Fn(Lt) {
      return function(Qt) {
        return Lt(Qt);
      };
    }
    function _s(Lt, Qt) {
      return Xi(Qt, function(Zt) {
        return Lt[Zt];
      });
    }
    function ho(Lt, Qt) {
      return Lt.has(Qt);
    }
    function Yo(Lt, Qt) {
      for (var Zt = -1, Ue = Lt.length; ++Zt < Ue && Er(Qt, Lt[Zt], 0) > -1; )
        ;
      return Zt;
    }
    function xs(Lt, Qt) {
      for (var Zt = Lt.length; Zt-- && Er(Qt, Lt[Zt], 0) > -1; )
        ;
      return Zt;
    }
    function uo(Lt, Qt) {
      for (var Zt = Lt.length, Ue = 0; Zt--; )
        Lt[Zt] === Qt && ++Ue;
      return Ue;
    }
    var ws = Po(Ha), Wr = Po(ea);
    function Ts(Lt) {
      return "\\" + ps[Lt];
    }
    function Ms(Lt, Qt) {
      return Lt == null ? s : Lt[Qt];
    }
    function br(Lt) {
      return Ua.test(Lt);
    }
    function Ss(Lt) {
      return Qs.test(Lt);
    }
    function Es(Lt) {
      for (var Qt, Zt = []; !(Qt = Lt.next()).done; )
        Zt.push(Qt.value);
      return Zt;
    }
    function Zn(Lt) {
      var Qt = -1, Zt = Array(Lt.size);
      return Lt.forEach(function(Ue, si) {
        Zt[++Qt] = [si, Ue];
      }), Zt;
    }
    function Ya(Lt, Qt) {
      return function(Zt) {
        return Lt(Qt(Zt));
      };
    }
    function Cr(Lt, Qt) {
      for (var Zt = -1, Ue = Lt.length, si = 0, ki = []; ++Zt < Ue; ) {
        var ln = Lt[Zt];
        (ln === Qt || ln === C) && (Lt[Zt] = C, ki[si++] = Zt);
      }
      return ki;
    }
    function bs(Lt) {
      var Qt = -1, Zt = Array(Lt.size);
      return Lt.forEach(function(Ue) {
        Zt[++Qt] = Ue;
      }), Zt;
    }
    function Un(Lt) {
      var Qt = -1, Zt = Array(Lt.size);
      return Lt.forEach(function(Ue) {
        Zt[++Qt] = [Ue, Ue];
      }), Zt;
    }
    function Nl(Lt, Qt, Zt) {
      for (var Ue = Zt - 1, si = Lt.length; ++Ue < si; )
        if (Lt[Ue] === Qt)
          return Ue;
      return -1;
    }
    function Fl(Lt, Qt, Zt) {
      for (var Ue = Zt + 1; Ue--; )
        if (Lt[Ue] === Qt)
          return Ue;
      return Ue;
    }
    function jr(Lt) {
      return br(Lt) ? ua(Lt) : lo(Lt);
    }
    function ir(Lt) {
      return br(Lt) ? gr(Lt) : au(Lt);
    }
    function ha(Lt) {
      for (var Qt = Lt.length; Qt-- && mh.test(Lt.charAt(Qt)); )
        ;
      return Qt;
    }
    var Ul = Po(Va);
    function ua(Lt) {
      for (var Qt = Ho.lastIndex = 0; Ho.test(Lt); )
        ++Qt;
      return Qt;
    }
    function gr(Lt) {
      return Lt.match(Ho) || [];
    }
    function tc(Lt) {
      return Lt.match(Fa) || [];
    }
    var ec = function Lt(Qt) {
      Qt = Qt == null ? fn : Zo.defaults(fn.Object(), Qt, Zo.pick(fn, Ga));
      var Zt = Qt.Array, Ue = Qt.Date, si = Qt.Error, ki = Qt.Function, ln = Qt.Math, Ee = Qt.Object, Jn = Qt.RegExp, ca = Qt.String, nr = Qt.TypeError, Pn = Zt.prototype, hu = ki.prototype, co = Ee.prototype, Jo = Qt["__core-js_shared__"], rr = hu.toString, wi = co.hasOwnProperty, or = 0, Ar = function() {
        var r = /[^.]+$/.exec(Jo && Jo.keys && Jo.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : "";
      }(), sr = co.toString, fo = rr.call(Ee), Xr = fn._, Oo = Jn(
        "^" + rr.call(wi).replace(ka, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), ar = ds ? Qt.Buffer : s, $n = Qt.Symbol, $i = Qt.Uint8Array, Za = ar ? ar.allocUnsafe : s, po = Ya(Ee.getPrototypeOf, Ee), Ja = Ee.create, $a = co.propertyIsEnumerable, Cs = Pn.splice, fa = $n ? $n.isConcatSpreadable : s, $o = $n ? $n.iterator : s, mo = $n ? $n.toStringTag : s, As = function() {
        try {
          var r = dl(Ee, "defineProperty");
          return r({}, "", {}), r;
        } catch {
        }
      }(), Gl = Qt.clearTimeout !== fn.clearTimeout && Qt.clearTimeout, Hl = Ue && Ue.now !== fn.Date.now && Ue.now, wh = Qt.setTimeout !== fn.setTimeout && Qt.setTimeout, Io = ln.ceil, Ps = ln.floor, Ka = Ee.getOwnPropertySymbols, Th = ar ? ar.isBuffer : s, Vl = Qt.isFinite, Mh = Pn.join, uu = Ya(Ee.keys, Ee), pn = ln.max, Gn = ln.min, Qa = Ue.now, Sh = Qt.parseInt, Wl = ln.random, pa = Pn.reverse, tl = dl(Qt, "DataView"), Ls = dl(Qt, "Map"), el = dl(Qt, "Promise"), Rs = dl(Qt, "Set"), Tn = dl(Qt, "WeakMap"), da = dl(Ee, "create"), il = Tn && new Tn(), Ko = {}, jl = ml(tl), Eh = ml(Ls), bh = ml(el), Ch = ml(Rs), cu = ml(Tn), nl = $n ? $n.prototype : s, Os = nl ? nl.valueOf : s, Ah = nl ? nl.toString : s;
      function it(r) {
        if (Cn(r) && !gi(r) && !(r instanceof yi)) {
          if (r instanceof Vn)
            return r;
          if (wi.call(r, "__wrapped__"))
            return Ff(r);
        }
        return new Vn(r);
      }
      var Qo = function() {
        function r() {
        }
        return function(h) {
          if (!vn(h))
            return {};
          if (Ja)
            return Ja(h);
          r.prototype = h;
          var v = new r();
          return r.prototype = s, v;
        };
      }();
      function ma() {
      }
      function Vn(r, h) {
        this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = s;
      }
      it.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Pl,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: xn,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: qs,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: it
        }
      }, it.prototype = ma.prototype, it.prototype.constructor = it, Vn.prototype = Qo(ma.prototype), Vn.prototype.constructor = Vn;
      function yi(r) {
        this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Ot, this.__views__ = [];
      }
      function ga() {
        var r = new yi(this.__wrapped__);
        return r.__actions__ = Qn(this.__actions__), r.__dir__ = this.__dir__, r.__filtered__ = this.__filtered__, r.__iteratees__ = Qn(this.__iteratees__), r.__takeCount__ = this.__takeCount__, r.__views__ = Qn(this.__views__), r;
      }
      function fu() {
        if (this.__filtered__) {
          var r = new yi(this);
          r.__dir__ = -1, r.__filtered__ = !0;
        } else
          r = this.clone(), r.__dir__ *= -1;
        return r;
      }
      function va() {
        var r = this.__wrapped__.value(), h = this.__dir__, v = gi(r), I = h < 0, Y = v ? r.length : 0, ut = qd(0, Y, this.__views__), yt = ut.start, bt = ut.end, Nt = bt - yt, oe = I ? bt : yt - 1, le = this.__iteratees__, de = le.length, ze = 0, Je = Gn(Nt, this.__takeCount__);
        if (!v || !I && Y == Nt && Je == Nt)
          return ri(r, this.__actions__);
        var li = [];
        t:
          for (; Nt-- && ze < Je; ) {
            oe += h;
            for (var Ti = -1, hi = r[oe]; ++Ti < de; ) {
              var Ai = le[Ti], Bi = Ai.iteratee, Zr = Ai.type, wr = Bi(hi);
              if (Zr == Pt)
                hi = wr;
              else if (!wr) {
                if (Zr == G)
                  continue t;
                break t;
              }
            }
            li[ze++] = hi;
          }
        return li;
      }
      yi.prototype = Qo(ma.prototype), yi.prototype.constructor = yi;
      function Pr(r) {
        var h = -1, v = r == null ? 0 : r.length;
        for (this.clear(); ++h < v; ) {
          var I = r[h];
          this.set(I[0], I[1]);
        }
      }
      function ya() {
        this.__data__ = da ? da(null) : {}, this.size = 0;
      }
      function _a(r) {
        var h = this.has(r) && delete this.__data__[r];
        return this.size -= h ? 1 : 0, h;
      }
      function rl(r) {
        var h = this.__data__;
        if (da) {
          var v = h[r];
          return v === _ ? s : v;
        }
        return wi.call(h, r) ? h[r] : s;
      }
      function Xl(r) {
        var h = this.__data__;
        return da ? h[r] !== s : wi.call(h, r);
      }
      function ol(r, h) {
        var v = this.__data__;
        return this.size += this.has(r) ? 0 : 1, v[r] = da && h === s ? _ : h, this;
      }
      Pr.prototype.clear = ya, Pr.prototype.delete = _a, Pr.prototype.get = rl, Pr.prototype.has = Xl, Pr.prototype.set = ol;
      function lr(r) {
        var h = -1, v = r == null ? 0 : r.length;
        for (this.clear(); ++h < v; ) {
          var I = r[h];
          this.set(I[0], I[1]);
        }
      }
      function sl() {
        this.__data__ = [], this.size = 0;
      }
      function Do(r) {
        var h = this.__data__, v = hl(h, r);
        if (v < 0)
          return !1;
        var I = h.length - 1;
        return v == I ? h.pop() : Cs.call(h, v, 1), --this.size, !0;
      }
      function al(r) {
        var h = this.__data__, v = hl(h, r);
        return v < 0 ? s : h[v][1];
      }
      function ll(r) {
        return hl(this.__data__, r) > -1;
      }
      function zo(r, h) {
        var v = this.__data__, I = hl(v, r);
        return I < 0 ? (++this.size, v.push([r, h])) : v[I][1] = h, this;
      }
      lr.prototype.clear = sl, lr.prototype.delete = Do, lr.prototype.get = al, lr.prototype.has = ll, lr.prototype.set = zo;
      function vr(r) {
        var h = -1, v = r == null ? 0 : r.length;
        for (this.clear(); ++h < v; ) {
          var I = r[h];
          this.set(I[0], I[1]);
        }
      }
      function pu() {
        this.size = 0, this.__data__ = {
          hash: new Pr(),
          map: new (Ls || lr)(),
          string: new Pr()
        };
      }
      function du(r) {
        var h = Su(this, r).delete(r);
        return this.size -= h ? 1 : 0, h;
      }
      function Ph(r) {
        return Su(this, r).get(r);
      }
      function fi(r) {
        return Su(this, r).has(r);
      }
      function ts(r, h) {
        var v = Su(this, r), I = v.size;
        return v.set(r, h), this.size += v.size == I ? 0 : 1, this;
      }
      vr.prototype.clear = pu, vr.prototype.delete = du, vr.prototype.get = Ph, vr.prototype.has = fi, vr.prototype.set = ts;
      function Is(r) {
        var h = -1, v = r == null ? 0 : r.length;
        for (this.__data__ = new vr(); ++h < v; )
          this.add(r[h]);
      }
      function Ei(r) {
        return this.__data__.set(r, _), this;
      }
      function Dn(r) {
        return this.__data__.has(r);
      }
      Is.prototype.add = Is.prototype.push = Ei, Is.prototype.has = Dn;
      function qr(r) {
        var h = this.__data__ = new lr(r);
        this.size = h.size;
      }
      function qe() {
        this.__data__ = new lr(), this.size = 0;
      }
      function go(r) {
        var h = this.__data__, v = h.delete(r);
        return this.size = h.size, v;
      }
      function ic(r) {
        return this.__data__.get(r);
      }
      function nc(r) {
        return this.__data__.has(r);
      }
      function rc(r, h) {
        var v = this.__data__;
        if (v instanceof lr) {
          var I = v.__data__;
          if (!Ls || I.length < d - 1)
            return I.push([r, h]), this.size = ++v.size, this;
          v = this.__data__ = new vr(I);
        }
        return v.set(r, h), this.size = v.size, this;
      }
      qr.prototype.clear = qe, qr.prototype.delete = go, qr.prototype.get = ic, qr.prototype.has = nc, qr.prototype.set = rc;
      function mu(r, h) {
        var v = gi(r), I = !v && gl(r), Y = !v && !I && ba(r), ut = !v && !I && !Y && eh(r), yt = v || I || Y || ut, bt = yt ? Lo(r.length, ca) : [], Nt = bt.length;
        for (var oe in r)
          (h || wi.call(r, oe)) && !(yt && // Safari 9 has enumerable `arguments.length` in strict mode.
          (oe == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          Y && (oe == "offset" || oe == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ut && (oe == "buffer" || oe == "byteLength" || oe == "byteOffset") || // Skip index properties.
          Ns(oe, Nt))) && bt.push(oe);
        return bt;
      }
      function Lh(r) {
        var h = r.length;
        return h ? r[me(0, h - 1)] : s;
      }
      function oc(r, h) {
        return Eu(Qn(r), es(h, 0, r.length));
      }
      function gu(r) {
        return Eu(Qn(r));
      }
      function ql(r, h, v) {
        (v !== s && !Fo(r[h], v) || v === s && !(h in r)) && ko(r, h, v);
      }
      function xa(r, h, v) {
        var I = r[h];
        (!(wi.call(r, h) && Fo(I, v)) || v === s && !(h in r)) && ko(r, h, v);
      }
      function hl(r, h) {
        for (var v = r.length; v--; )
          if (Fo(r[v][0], h))
            return v;
        return -1;
      }
      function vu(r, h, v, I) {
        return dn(r, function(Y, ut, yt) {
          h(I, Y, v(Y), yt);
        }), I;
      }
      function Rh(r, h) {
        return r && Ln(h, Xn(h), r);
      }
      function Oh(r, h) {
        return r && Ln(h, Ir(h), r);
      }
      function ko(r, h, v) {
        h == "__proto__" && As ? As(r, h, {
          configurable: !0,
          enumerable: !0,
          value: v,
          writable: !0
        }) : r[h] = v;
      }
      function Ih(r, h) {
        for (var v = -1, I = h.length, Y = Zt(I), ut = r == null; ++v < I; )
          Y[v] = ut ? s : wc(r, h[v]);
        return Y;
      }
      function es(r, h, v) {
        return r === r && (v !== s && (r = r <= v ? r : v), h !== s && (r = r >= h ? r : h)), r;
      }
      function yr(r, h, v, I, Y, ut) {
        var yt, bt = h & O, Nt = h & k, oe = h & D;
        if (v && (yt = Y ? v(r, I, Y, ut) : v(r)), yt !== s)
          return yt;
        if (!vn(r))
          return r;
        var le = gi(r);
        if (le) {
          if (yt = Zd(r), !bt)
            return Qn(r, yt);
        } else {
          var de = ur(r), ze = de == cn || de == Ji;
          if (ba(r))
            return Bo(r, bt);
          if (de == pt || de == Yt || ze && !Y) {
            if (yt = Nt || ze ? {} : Lf(r), !bt)
              return Nt ? wu(r, Oh(yt, r)) : _o(r, Rh(yt, r));
          } else {
            if (!_i[de])
              return Y ? r : {};
            yt = Jd(r, de, bt);
          }
        }
        ut || (ut = new qr());
        var Je = ut.get(r);
        if (Je)
          return Je;
        ut.set(r, yt), op(r) ? r.forEach(function(hi) {
          yt.add(yr(hi, h, v, hi, r, ut));
        }) : np(r) && r.forEach(function(hi, Ai) {
          yt.set(Ai, yr(hi, h, v, Ai, r, ut));
        });
        var li = oe ? Nt ? ac : sc : Nt ? Ir : Xn, Ti = le ? s : li(r);
        return Yi(Ti || r, function(hi, Ai) {
          Ti && (Ai = hi, hi = r[Ai]), xa(yt, Ai, yr(hi, h, v, Ai, r, ut));
        }), yt;
      }
      function wa(r) {
        var h = Xn(r);
        return function(v) {
          return yu(v, r, h);
        };
      }
      function yu(r, h, v) {
        var I = v.length;
        if (r == null)
          return !I;
        for (r = Ee(r); I--; ) {
          var Y = v[I], ut = h[Y], yt = r[Y];
          if (yt === s && !(Y in r) || !ut(yt))
            return !1;
        }
        return !0;
      }
      function vo(r, h, v) {
        if (typeof r != "function")
          throw new nr(m);
        return Gh(function() {
          r.apply(s, v);
        }, h);
      }
      function ul(r, h, v, I) {
        var Y = -1, ut = ja, yt = !0, bt = r.length, Nt = [], oe = h.length;
        if (!bt)
          return Nt;
        v && (h = Xi(h, Fn(v))), I ? (ut = kl, yt = !1) : h.length >= d && (ut = ho, yt = !1, h = new Is(h));
        t:
          for (; ++Y < bt; ) {
            var le = r[Y], de = v == null ? le : v(le);
            if (le = I || le !== 0 ? le : 0, yt && de === de) {
              for (var ze = oe; ze--; )
                if (h[ze] === de)
                  continue t;
              Nt.push(le);
            } else
              ut(h, de, I) || Nt.push(le);
          }
        return Nt;
      }
      var dn = ft(Rr), _u = ft(Zl, !0);
      function Wn(r, h) {
        var v = !0;
        return dn(r, function(I, Y, ut) {
          return v = !!h(I, Y, ut), v;
        }), v;
      }
      function yo(r, h, v) {
        for (var I = -1, Y = r.length; ++I < Y; ) {
          var ut = r[I], yt = h(ut);
          if (yt != null && (bt === s ? yt === yt && !Yr(yt) : v(yt, bt)))
            var bt = yt, Nt = ut;
        }
        return Nt;
      }
      function Kn(r, h, v, I) {
        var Y = r.length;
        for (v = xi(v), v < 0 && (v = -v > Y ? 0 : Y + v), I = I === s || I > Y ? Y : xi(I), I < 0 && (I += Y), I = v > I ? 0 : ap(I); v < I; )
          r[v++] = h;
        return r;
      }
      function Lr(r, h) {
        var v = [];
        return dn(r, function(I, Y, ut) {
          h(I, Y, ut) && v.push(I);
        }), v;
      }
      function Mn(r, h, v, I, Y) {
        var ut = -1, yt = r.length;
        for (v || (v = Kd), Y || (Y = []); ++ut < yt; ) {
          var bt = r[ut];
          h > 0 && v(bt) ? h > 1 ? Mn(bt, h - 1, v, I, Y) : ao(Y, bt) : I || (Y[Y.length] = bt);
        }
        return Y;
      }
      var cl = Tt(), Yl = Tt(!0);
      function Rr(r, h) {
        return r && cl(r, h, Xn);
      }
      function Zl(r, h) {
        return r && Yl(r, h, Xn);
      }
      function Ds(r, h) {
        return Sr(h, function(v) {
          return Fs(r[v]);
        });
      }
      function is(r, h) {
        h = Ze(h, r);
        for (var v = 0, I = h.length; r != null && v < I; )
          r = r[rs(h[v++])];
        return v && v == I ? r : s;
      }
      function xu(r, h, v) {
        var I = h(r);
        return gi(r) ? I : ao(I, v(r));
      }
      function jn(r) {
        return r == null ? r === s ? st : Wt : mo && mo in Ee(r) ? Xd(r) : om(r);
      }
      function Jl(r, h) {
        return r > h;
      }
      function $l(r, h) {
        return r != null && wi.call(r, h);
      }
      function Dh(r, h) {
        return r != null && h in Ee(r);
      }
      function Kl(r, h, v) {
        return r >= Gn(h, v) && r < pn(h, v);
      }
      function fl(r, h, v) {
        for (var I = v ? kl : ja, Y = r[0].length, ut = r.length, yt = ut, bt = Zt(ut), Nt = 1 / 0, oe = []; yt--; ) {
          var le = r[yt];
          yt && h && (le = Xi(le, Fn(h))), Nt = Gn(le.length, Nt), bt[yt] = !v && (h || Y >= 120 && le.length >= 120) ? new Is(yt && le) : s;
        }
        le = r[0];
        var de = -1, ze = bt[0];
        t:
          for (; ++de < Y && oe.length < Nt; ) {
            var Je = le[de], li = h ? h(Je) : Je;
            if (Je = v || Je !== 0 ? Je : 0, !(ze ? ho(ze, li) : I(oe, li, v))) {
              for (yt = ut; --yt; ) {
                var Ti = bt[yt];
                if (!(Ti ? ho(Ti, li) : I(r[yt], li, v)))
                  continue t;
              }
              ze && ze.push(li), oe.push(Je);
            }
          }
        return oe;
      }
      function t(r, h, v, I) {
        return Rr(r, function(Y, ut, yt) {
          h(I, v(Y), ut, yt);
        }), I;
      }
      function e(r, h, v) {
        h = Ze(h, r), r = Df(r, h);
        var I = r == null ? r : r[rs(wo(h))];
        return I == null ? s : mr(I, r, v);
      }
      function i(r) {
        return Cn(r) && jn(r) == Yt;
      }
      function n(r) {
        return Cn(r) && jn(r) == Gt;
      }
      function o(r) {
        return Cn(r) && jn(r) == Ge;
      }
      function l(r, h, v, I, Y) {
        return r === h ? !0 : r == null || h == null || !Cn(r) && !Cn(h) ? r !== r && h !== h : f(r, h, v, I, l, Y);
      }
      function f(r, h, v, I, Y, ut) {
        var yt = gi(r), bt = gi(h), Nt = yt ? $e : ur(r), oe = bt ? $e : ur(h);
        Nt = Nt == Yt ? pt : Nt, oe = oe == Yt ? pt : oe;
        var le = Nt == pt, de = oe == pt, ze = Nt == oe;
        if (ze && ba(r)) {
          if (!ba(h))
            return !1;
          yt = !0, le = !1;
        }
        if (ze && !le)
          return ut || (ut = new qr()), yt || eh(r) ? Cf(r, h, v, I, Y, ut) : Wd(r, h, Nt, v, I, Y, ut);
        if (!(v & F)) {
          var Je = le && wi.call(r, "__wrapped__"), li = de && wi.call(h, "__wrapped__");
          if (Je || li) {
            var Ti = Je ? r.value() : r, hi = li ? h.value() : h;
            return ut || (ut = new qr()), Y(Ti, hi, v, I, ut);
          }
        }
        return ze ? (ut || (ut = new qr()), jd(r, h, v, I, Y, ut)) : !1;
      }
      function p(r) {
        return Cn(r) && ur(r) == W;
      }
      function y(r, h, v, I) {
        var Y = v.length, ut = Y, yt = !I;
        if (r == null)
          return !ut;
        for (r = Ee(r); Y--; ) {
          var bt = v[Y];
          if (yt && bt[2] ? bt[1] !== r[bt[0]] : !(bt[0] in r))
            return !1;
        }
        for (; ++Y < ut; ) {
          bt = v[Y];
          var Nt = bt[0], oe = r[Nt], le = bt[1];
          if (yt && bt[2]) {
            if (oe === s && !(Nt in r))
              return !1;
          } else {
            var de = new qr();
            if (I)
              var ze = I(oe, le, Nt, r, h, de);
            if (!(ze === s ? l(le, oe, F | E, I, de) : ze))
              return !1;
          }
        }
        return !0;
      }
      function w(r) {
        if (!vn(r) || tm(r))
          return !1;
        var h = Fs(r) ? Oo : cs;
        return h.test(ml(r));
      }
      function A(r) {
        return Cn(r) && jn(r) == ie;
      }
      function P(r) {
        return Cn(r) && ur(r) == Kt;
      }
      function B(r) {
        return Cn(r) && Ru(r.length) && !!Wi[jn(r)];
      }
      function H(r) {
        return typeof r == "function" ? r : r == null ? Dr : typeof r == "object" ? gi(r) ? Ct(r[0], r[1]) : gt(r) : yp(r);
      }
      function q(r) {
        if (!Uh(r))
          return uu(r);
        var h = [];
        for (var v in Ee(r))
          wi.call(r, v) && v != "constructor" && h.push(v);
        return h;
      }
      function $(r) {
        if (!vn(r))
          return rm(r);
        var h = Uh(r), v = [];
        for (var I in r)
          I == "constructor" && (h || !wi.call(r, I)) || v.push(I);
        return v;
      }
      function rt(r, h) {
        return r < h;
      }
      function xt(r, h) {
        var v = -1, I = Or(r) ? Zt(r.length) : [];
        return dn(r, function(Y, ut, yt) {
          I[++v] = h(Y, ut, yt);
        }), I;
      }
      function gt(r) {
        var h = hc(r);
        return h.length == 1 && h[0][2] ? Of(h[0][0], h[0][1]) : function(v) {
          return v === r || y(v, r, h);
        };
      }
      function Ct(r, h) {
        return cc(r) && Rf(h) ? Of(rs(r), h) : function(v) {
          var I = wc(v, r);
          return I === s && I === h ? Tc(v, r) : l(h, I, F | E);
        };
      }
      function wt(r, h, v, I, Y) {
        r !== h && cl(h, function(ut, yt) {
          if (Y || (Y = new qr()), vn(ut))
            Vt(r, h, yt, v, wt, I, Y);
          else {
            var bt = I ? I(pc(r, yt), ut, yt + "", r, h, Y) : s;
            bt === s && (bt = ut), ql(r, yt, bt);
          }
        }, Ir);
      }
      function Vt(r, h, v, I, Y, ut, yt) {
        var bt = pc(r, v), Nt = pc(h, v), oe = yt.get(Nt);
        if (oe) {
          ql(r, v, oe);
          return;
        }
        var le = ut ? ut(bt, Nt, v + "", r, h, yt) : s, de = le === s;
        if (de) {
          var ze = gi(Nt), Je = !ze && ba(Nt), li = !ze && !Je && eh(Nt);
          le = Nt, ze || Je || li ? gi(bt) ? le = bt : Rn(bt) ? le = Qn(bt) : Je ? (de = !1, le = Bo(Nt, !0)) : li ? (de = !1, le = pl(Nt, !0)) : le = [] : Hh(Nt) || gl(Nt) ? (le = bt, gl(bt) ? le = lp(bt) : (!vn(bt) || Fs(bt)) && (le = Lf(Nt))) : de = !1;
        }
        de && (yt.set(Nt, le), Y(le, Nt, I, ut, yt), yt.delete(Nt)), ql(r, v, le);
      }
      function Z(r, h) {
        var v = r.length;
        if (v)
          return h += h < 0 ? v : 0, Ns(h, v) ? r[h] : s;
      }
      function ot(r, h, v) {
        h.length ? h = Xi(h, function(ut) {
          return gi(ut) ? function(yt) {
            return is(yt, ut.length === 1 ? ut[0] : ut);
          } : ut;
        }) : h = [Dr];
        var I = -1;
        h = Xi(h, Fn(oi()));
        var Y = xt(r, function(ut, yt, bt) {
          var Nt = Xi(h, function(oe) {
            return oe(ut);
          });
          return { criteria: Nt, index: ++I, value: ut };
        });
        return lu(Y, function(ut, yt) {
          return ns(ut, yt, v);
        });
      }
      function zt(r, h) {
        return ee(r, h, function(v, I) {
          return Tc(r, I);
        });
      }
      function ee(r, h, v) {
        for (var I = -1, Y = h.length, ut = {}; ++I < Y; ) {
          var yt = h[I], bt = is(r, yt);
          v(bt, yt) && ci(ut, Ze(yt, r), bt);
        }
        return ut;
      }
      function $t(r) {
        return function(h) {
          return is(h, r);
        };
      }
      function qt(r, h, v, I) {
        var Y = I ? qa : Er, ut = -1, yt = h.length, bt = r;
        for (r === h && (h = Qn(h)), v && (bt = Xi(r, Fn(v))); ++ut < yt; )
          for (var Nt = 0, oe = h[ut], le = v ? v(oe) : oe; (Nt = Y(bt, le, Nt, I)) > -1; )
            bt !== r && Cs.call(bt, Nt, 1), Cs.call(r, Nt, 1);
        return r;
      }
      function Te(r, h) {
        for (var v = r ? h.length : 0, I = v - 1; v--; ) {
          var Y = h[v];
          if (v == I || Y !== ut) {
            var ut = Y;
            Ns(Y) ? Cs.call(r, Y, 1) : Hi(r, Y);
          }
        }
        return r;
      }
      function me(r, h) {
        return r + Ps(Wl() * (h - r + 1));
      }
      function Ie(r, h, v, I) {
        for (var Y = -1, ut = pn(Io((h - r) / (v || 1)), 0), yt = Zt(ut); ut--; )
          yt[I ? ut : ++Y] = r, r += v;
        return yt;
      }
      function be(r, h) {
        var v = "";
        if (!r || h < 1 || h > fe)
          return v;
        do
          h % 2 && (v += r), h = Ps(h / 2), h && (r += r);
        while (h);
        return v;
      }
      function ae(r, h) {
        return dc(If(r, h, Dr), r + "");
      }
      function We(r) {
        return Lh(ih(r));
      }
      function Qe(r, h) {
        var v = ih(r);
        return Eu(v, es(h, 0, v.length));
      }
      function ci(r, h, v, I) {
        if (!vn(r))
          return r;
        h = Ze(h, r);
        for (var Y = -1, ut = h.length, yt = ut - 1, bt = r; bt != null && ++Y < ut; ) {
          var Nt = rs(h[Y]), oe = v;
          if (Nt === "__proto__" || Nt === "constructor" || Nt === "prototype")
            return r;
          if (Y != yt) {
            var le = bt[Nt];
            oe = I ? I(le, Nt, bt) : s, oe === s && (oe = vn(le) ? le : Ns(h[Y + 1]) ? [] : {});
          }
          xa(bt, Nt, oe), bt = bt[Nt];
        }
        return r;
      }
      var Sn = il ? function(r, h) {
        return il.set(r, h), r;
      } : Dr, mn = As ? function(r, h) {
        return As(r, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Sc(h),
          writable: !0
        });
      } : Dr;
      function ji(r) {
        return Eu(ih(r));
      }
      function Gi(r, h, v) {
        var I = -1, Y = r.length;
        h < 0 && (h = -h > Y ? 0 : Y + h), v = v > Y ? Y : v, v < 0 && (v += Y), Y = h > v ? 0 : v - h >>> 0, h >>>= 0;
        for (var ut = Zt(Y); ++I < Y; )
          ut[I] = r[I + h];
        return ut;
      }
      function en(r, h) {
        var v;
        return dn(r, function(I, Y, ut) {
          return v = h(I, Y, ut), !v;
        }), !!v;
      }
      function En(r, h, v) {
        var I = 0, Y = r == null ? I : r.length;
        if (typeof h == "number" && h === h && Y <= ke) {
          for (; I < Y; ) {
            var ut = I + Y >>> 1, yt = r[ut];
            yt !== null && !Yr(yt) && (v ? yt <= h : yt < h) ? I = ut + 1 : Y = ut;
          }
          return Y;
        }
        return Ce(r, h, Dr, v);
      }
      function Ce(r, h, v, I) {
        var Y = 0, ut = r == null ? 0 : r.length;
        if (ut === 0)
          return 0;
        h = v(h);
        for (var yt = h !== h, bt = h === null, Nt = Yr(h), oe = h === s; Y < ut; ) {
          var le = Ps((Y + ut) / 2), de = v(r[le]), ze = de !== s, Je = de === null, li = de === de, Ti = Yr(de);
          if (yt)
            var hi = I || li;
          else
            oe ? hi = li && (I || ze) : bt ? hi = li && ze && (I || !Je) : Nt ? hi = li && ze && !Je && (I || !Ti) : Je || Ti ? hi = !1 : hi = I ? de <= h : de < h;
          hi ? Y = le + 1 : ut = le;
        }
        return Gn(ut, Bt);
      }
      function ti(r, h) {
        for (var v = -1, I = r.length, Y = 0, ut = []; ++v < I; ) {
          var yt = r[v], bt = h ? h(yt) : yt;
          if (!v || !Fo(bt, Nt)) {
            var Nt = bt;
            ut[Y++] = yt === 0 ? 0 : yt;
          }
        }
        return ut;
      }
      function Ut(r) {
        return typeof r == "number" ? r : Yr(r) ? Ft : +r;
      }
      function Ye(r) {
        if (typeof r == "string")
          return r;
        if (gi(r))
          return Xi(r, Ye) + "";
        if (Yr(r))
          return Ah ? Ah.call(r) : "";
        var h = r + "";
        return h == "0" && 1 / r == -At ? "-0" : h;
      }
      function ei(r, h, v) {
        var I = -1, Y = ja, ut = r.length, yt = !0, bt = [], Nt = bt;
        if (v)
          yt = !1, Y = kl;
        else if (ut >= d) {
          var oe = h ? null : Ea(r);
          if (oe)
            return bs(oe);
          yt = !1, Y = ho, Nt = new Is();
        } else
          Nt = h ? [] : bt;
        t:
          for (; ++I < ut; ) {
            var le = r[I], de = h ? h(le) : le;
            if (le = v || le !== 0 ? le : 0, yt && de === de) {
              for (var ze = Nt.length; ze--; )
                if (Nt[ze] === de)
                  continue t;
              h && Nt.push(de), bt.push(le);
            } else
              Y(Nt, de, v) || (Nt !== bt && Nt.push(de), bt.push(le));
          }
        return bt;
      }
      function Hi(r, h) {
        return h = Ze(h, r), r = Df(r, h), r == null || delete r[rs(wo(h))];
      }
      function Ae(r, h, v, I) {
        return ci(r, h, v(is(r, h)), I);
      }
      function Xe(r, h, v, I) {
        for (var Y = r.length, ut = I ? Y : -1; (I ? ut-- : ++ut < Y) && h(r[ut], ut, r); )
          ;
        return v ? Gi(r, I ? 0 : ut, I ? ut + 1 : Y) : Gi(r, I ? ut + 1 : 0, I ? Y : ut);
      }
      function ri(r, h) {
        var v = r;
        return v instanceof yi && (v = v.value()), Bl(h, function(I, Y) {
          return Y.func.apply(Y.thisArg, ao([I], Y.args));
        }, v);
      }
      function Ci(r, h, v) {
        var I = r.length;
        if (I < 2)
          return I ? ei(r[0]) : [];
        for (var Y = -1, ut = Zt(I); ++Y < I; )
          for (var yt = r[Y], bt = -1; ++bt < I; )
            bt != Y && (ut[Y] = ul(ut[Y] || yt, r[bt], h, v));
        return ei(Mn(ut, 1), h, v);
      }
      function bi(r, h, v) {
        for (var I = -1, Y = r.length, ut = h.length, yt = {}; ++I < Y; ) {
          var bt = I < ut ? h[I] : s;
          v(yt, r[I], bt);
        }
        return yt;
      }
      function ne(r) {
        return Rn(r) ? r : [];
      }
      function ii(r) {
        return typeof r == "function" ? r : Dr;
      }
      function Ze(r, h) {
        return gi(r) ? r : cc(r, h) ? [r] : Nf(qi(r));
      }
      var ai = ae;
      function gn(r, h, v) {
        var I = r.length;
        return v = v === s ? I : v, !h && v >= I ? r : Gi(r, h, v);
      }
      var bn = Gl || function(r) {
        return fn.clearTimeout(r);
      };
      function Bo(r, h) {
        if (h)
          return r.slice();
        var v = r.length, I = Za ? Za(v) : new r.constructor(v);
        return r.copy(I), I;
      }
      function Ta(r) {
        var h = new r.constructor(r.byteLength);
        return new $i(h).set(new $i(r)), h;
      }
      function zh(r, h) {
        var v = h ? Ta(r.buffer) : r.buffer;
        return new r.constructor(v, r.byteOffset, r.byteLength);
      }
      function Ma(r) {
        var h = new r.constructor(r.source, Rl.exec(r));
        return h.lastIndex = r.lastIndex, h;
      }
      function zs(r) {
        return Os ? Ee(Os.call(r)) : {};
      }
      function pl(r, h) {
        var v = h ? Ta(r.buffer) : r.buffer;
        return new r.constructor(v, r.byteOffset, r.length);
      }
      function ks(r, h) {
        if (r !== h) {
          var v = r !== s, I = r === null, Y = r === r, ut = Yr(r), yt = h !== s, bt = h === null, Nt = h === h, oe = Yr(h);
          if (!bt && !oe && !ut && r > h || ut && yt && Nt && !bt && !oe || I && yt && Nt || !v && Nt || !Y)
            return 1;
          if (!I && !ut && !oe && r < h || oe && v && Y && !I && !ut || bt && v && Y || !yt && Y || !Nt)
            return -1;
        }
        return 0;
      }
      function ns(r, h, v) {
        for (var I = -1, Y = r.criteria, ut = h.criteria, yt = Y.length, bt = v.length; ++I < yt; ) {
          var Nt = ks(Y[I], ut[I]);
          if (Nt) {
            if (I >= bt)
              return Nt;
            var oe = v[I];
            return Nt * (oe == "desc" ? -1 : 1);
          }
        }
        return r.index - h.index;
      }
      function kh(r, h, v, I) {
        for (var Y = -1, ut = r.length, yt = v.length, bt = -1, Nt = h.length, oe = pn(ut - yt, 0), le = Zt(Nt + oe), de = !I; ++bt < Nt; )
          le[bt] = h[bt];
        for (; ++Y < yt; )
          (de || Y < ut) && (le[v[Y]] = r[Y]);
        for (; oe--; )
          le[bt++] = r[Y++];
        return le;
      }
      function Bh(r, h, v, I) {
        for (var Y = -1, ut = r.length, yt = -1, bt = v.length, Nt = -1, oe = h.length, le = pn(ut - bt, 0), de = Zt(le + oe), ze = !I; ++Y < le; )
          de[Y] = r[Y];
        for (var Je = Y; ++Nt < oe; )
          de[Je + Nt] = h[Nt];
        for (; ++yt < bt; )
          (ze || Y < ut) && (de[Je + v[yt]] = r[Y++]);
        return de;
      }
      function Qn(r, h) {
        var v = -1, I = r.length;
        for (h || (h = Zt(I)); ++v < I; )
          h[v] = r[v];
        return h;
      }
      function Ln(r, h, v, I) {
        var Y = !v;
        v || (v = {});
        for (var ut = -1, yt = h.length; ++ut < yt; ) {
          var bt = h[ut], Nt = I ? I(v[bt], r[bt], bt, v, r) : s;
          Nt === s && (Nt = r[bt]), Y ? ko(v, bt, Nt) : xa(v, bt, Nt);
        }
        return v;
      }
      function _o(r, h) {
        return Ln(r, uc(r), h);
      }
      function wu(r, h) {
        return Ln(r, Af(r), h);
      }
      function Sa(r, h) {
        return function(v, I) {
          var Y = gi(v) ? zl : vu, ut = h ? h() : {};
          return Y(v, r, oi(I, 2), ut);
        };
      }
      function No(r) {
        return ae(function(h, v) {
          var I = -1, Y = v.length, ut = Y > 1 ? v[Y - 1] : s, yt = Y > 2 ? v[2] : s;
          for (ut = r.length > 3 && typeof ut == "function" ? (Y--, ut) : s, yt && xr(v[0], v[1], yt) && (ut = Y < 3 ? s : ut, Y = 1), h = Ee(h); ++I < Y; ) {
            var bt = v[I];
            bt && r(h, bt, I, ut);
          }
          return h;
        });
      }
      function ft(r, h) {
        return function(v, I) {
          if (v == null)
            return v;
          if (!Or(v))
            return r(v, I);
          for (var Y = v.length, ut = h ? Y : -1, yt = Ee(v); (h ? ut-- : ++ut < Y) && I(yt[ut], ut, yt) !== !1; )
            ;
          return v;
        };
      }
      function Tt(r) {
        return function(h, v, I) {
          for (var Y = -1, ut = Ee(h), yt = I(h), bt = yt.length; bt--; ) {
            var Nt = yt[r ? bt : ++Y];
            if (v(ut[Nt], Nt, ut) === !1)
              break;
          }
          return h;
        };
      }
      function mt(r, h, v) {
        var I = h & L, Y = Ve(r);
        function ut() {
          var yt = this && this !== fn && this instanceof ut ? Y : r;
          return yt.apply(I ? v : this, arguments);
        }
        return ut;
      }
      function Me(r) {
        return function(h) {
          h = qi(h);
          var v = br(h) ? ir(h) : s, I = v ? v[0] : h.charAt(0), Y = v ? gn(v, 1).join("") : h.slice(1);
          return I[r]() + Y;
        };
      }
      function De(r) {
        return function(h) {
          return Bl(gp(mp(h).replace(Ks, "")), r, "");
        };
      }
      function Ve(r) {
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return new r();
            case 1:
              return new r(h[0]);
            case 2:
              return new r(h[0], h[1]);
            case 3:
              return new r(h[0], h[1], h[2]);
            case 4:
              return new r(h[0], h[1], h[2], h[3]);
            case 5:
              return new r(h[0], h[1], h[2], h[3], h[4]);
            case 6:
              return new r(h[0], h[1], h[2], h[3], h[4], h[5]);
            case 7:
              return new r(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
          }
          var v = Qo(r.prototype), I = r.apply(v, h);
          return vn(I) ? I : v;
        };
      }
      function Se(r, h, v) {
        var I = Ve(r);
        function Y() {
          for (var ut = arguments.length, yt = Zt(ut), bt = ut, Nt = th(Y); bt--; )
            yt[bt] = arguments[bt];
          var oe = ut < 3 && yt[0] !== Nt && yt[ut - 1] !== Nt ? [] : Cr(yt, Nt);
          if (ut -= oe.length, ut < v)
            return Fh(
              r,
              h,
              Zi,
              Y.placeholder,
              s,
              yt,
              oe,
              s,
              s,
              v - ut
            );
          var le = this && this !== fn && this instanceof Y ? I : r;
          return mr(le, this, yt);
        }
        return Y;
      }
      function Ke(r) {
        return function(h, v, I) {
          var Y = Ee(h);
          if (!Or(h)) {
            var ut = oi(v, 3);
            h = Xn(h), v = function(bt) {
              return ut(Y[bt], bt, Y);
            };
          }
          var yt = r(h, v, I);
          return yt > -1 ? Y[ut ? h[yt] : yt] : s;
        };
      }
      function Pi(r) {
        return Bs(function(h) {
          var v = h.length, I = v, Y = Vn.prototype.thru;
          for (r && h.reverse(); I--; ) {
            var ut = h[I];
            if (typeof ut != "function")
              throw new nr(m);
            if (Y && !yt && Mu(ut) == "wrapper")
              var yt = new Vn([], !0);
          }
          for (I = yt ? I : v; ++I < v; ) {
            ut = h[I];
            var bt = Mu(ut), Nt = bt == "wrapper" ? lc(ut) : s;
            Nt && fc(Nt[0]) && Nt[1] == (j | R | U | J) && !Nt[4].length && Nt[9] == 1 ? yt = yt[Mu(Nt[0])].apply(yt, Nt[3]) : yt = ut.length == 1 && fc(ut) ? yt[bt]() : yt.thru(ut);
          }
          return function() {
            var oe = arguments, le = oe[0];
            if (yt && oe.length == 1 && gi(le))
              return yt.plant(le).value();
            for (var de = 0, ze = v ? h[de].apply(this, oe) : le; ++de < v; )
              ze = h[de].call(this, ze);
            return ze;
          };
        });
      }
      function Zi(r, h, v, I, Y, ut, yt, bt, Nt, oe) {
        var le = h & j, de = h & L, ze = h & T, Je = h & (R | b), li = h & K, Ti = ze ? s : Ve(r);
        function hi() {
          for (var Ai = arguments.length, Bi = Zt(Ai), Zr = Ai; Zr--; )
            Bi[Zr] = arguments[Zr];
          if (Je)
            var wr = th(hi), Jr = uo(Bi, wr);
          if (I && (Bi = kh(Bi, I, Y, Je)), ut && (Bi = Bh(Bi, ut, yt, Je)), Ai -= Jr, Je && Ai < oe) {
            var On = Cr(Bi, wr);
            return Fh(
              r,
              h,
              Zi,
              hi.placeholder,
              v,
              Bi,
              On,
              bt,
              Nt,
              oe - Ai
            );
          }
          var Uo = de ? v : this, Gs = ze ? Uo[r] : r;
          return Ai = Bi.length, bt ? Bi = sm(Bi, bt) : li && Ai > 1 && Bi.reverse(), le && Nt < Ai && (Bi.length = Nt), this && this !== fn && this instanceof hi && (Gs = Ti || Ve(Gs)), Gs.apply(Uo, Bi);
        }
        return hi;
      }
      function ve(r, h) {
        return function(v, I) {
          return t(v, r, h(I), {});
        };
      }
      function _r(r, h) {
        return function(v, I) {
          var Y;
          if (v === s && I === s)
            return h;
          if (v !== s && (Y = v), I !== s) {
            if (Y === s)
              return I;
            typeof v == "string" || typeof I == "string" ? (v = Ye(v), I = Ye(I)) : (v = Ut(v), I = Ut(I)), Y = r(v, I);
          }
          return Y;
        };
      }
      function zn(r) {
        return Bs(function(h) {
          return h = Xi(h, Fn(oi())), ae(function(v) {
            var I = this;
            return r(h, function(Y) {
              return mr(Y, I, v);
            });
          });
        });
      }
      function on(r, h) {
        h = h === s ? " " : Ye(h);
        var v = h.length;
        if (v < 2)
          return v ? be(h, r) : h;
        var I = be(h, Io(r / jr(h)));
        return br(h) ? gn(ir(I), 0, r).join("") : I.slice(0, r);
      }
      function hr(r, h, v, I) {
        var Y = h & L, ut = Ve(r);
        function yt() {
          for (var bt = -1, Nt = arguments.length, oe = -1, le = I.length, de = Zt(le + Nt), ze = this && this !== fn && this instanceof yt ? ut : r; ++oe < le; )
            de[oe] = I[oe];
          for (; Nt--; )
            de[oe++] = arguments[++bt];
          return mr(ze, Y ? v : this, de);
        }
        return yt;
      }
      function Nh(r) {
        return function(h, v, I) {
          return I && typeof I != "number" && xr(h, v, I) && (v = I = s), h = Us(h), v === s ? (v = h, h = 0) : v = Us(v), I = I === s ? h < v ? 1 : -1 : Us(I), Ie(h, v, I, r);
        };
      }
      function xo(r) {
        return function(h, v) {
          return typeof h == "string" && typeof v == "string" || (h = To(h), v = To(v)), r(h, v);
        };
      }
      function Fh(r, h, v, I, Y, ut, yt, bt, Nt, oe) {
        var le = h & R, de = le ? yt : s, ze = le ? s : yt, Je = le ? ut : s, li = le ? s : ut;
        h |= le ? U : N, h &= ~(le ? N : U), h & M || (h &= ~(L | T));
        var Ti = [
          r,
          h,
          Y,
          Je,
          de,
          li,
          ze,
          bt,
          Nt,
          oe
        ], hi = v.apply(s, Ti);
        return fc(r) && zf(hi, Ti), hi.placeholder = I, kf(hi, r, h);
      }
      function Ql(r) {
        var h = ln[r];
        return function(v, I) {
          if (v = To(v), I = I == null ? 0 : Gn(xi(I), 292), I && Vl(v)) {
            var Y = (qi(v) + "e").split("e"), ut = h(Y[0] + "e" + (+Y[1] + I));
            return Y = (qi(ut) + "e").split("e"), +(Y[0] + "e" + (+Y[1] - I));
          }
          return h(v);
        };
      }
      var Ea = Rs && 1 / bs(new Rs([, -0]))[1] == At ? function(r) {
        return new Rs(r);
      } : Cc;
      function Tu(r) {
        return function(h) {
          var v = ur(h);
          return v == W ? Zn(h) : v == Kt ? Un(h) : Ro(h, r(h));
        };
      }
      function tr(r, h, v, I, Y, ut, yt, bt) {
        var Nt = h & T;
        if (!Nt && typeof r != "function")
          throw new nr(m);
        var oe = I ? I.length : 0;
        if (oe || (h &= ~(U | N), I = Y = s), yt = yt === s ? yt : pn(xi(yt), 0), bt = bt === s ? bt : xi(bt), oe -= Y ? Y.length : 0, h & N) {
          var le = I, de = Y;
          I = Y = s;
        }
        var ze = Nt ? s : lc(r), Je = [
          r,
          h,
          v,
          I,
          Y,
          le,
          de,
          ut,
          yt,
          bt
        ];
        if (ze && nm(Je, ze), r = Je[0], h = Je[1], v = Je[2], I = Je[3], Y = Je[4], bt = Je[9] = Je[9] === s ? Nt ? 0 : r.length : pn(Je[9] - oe, 0), !bt && h & (R | b) && (h &= ~(R | b)), !h || h == L)
          var li = mt(r, h, v);
        else
          h == R || h == b ? li = Se(r, h, bt) : (h == U || h == (L | U)) && !Y.length ? li = hr(r, h, v, I) : li = Zi.apply(s, Je);
        var Ti = ze ? Sn : zf;
        return kf(Ti(li, Je), r, h);
      }
      function Ef(r, h, v, I) {
        return r === s || Fo(r, co[v]) && !wi.call(I, v) ? h : r;
      }
      function bf(r, h, v, I, Y, ut) {
        return vn(r) && vn(h) && (ut.set(h, r), wt(r, h, s, bf, ut), ut.delete(h)), r;
      }
      function Vd(r) {
        return Hh(r) ? s : r;
      }
      function Cf(r, h, v, I, Y, ut) {
        var yt = v & F, bt = r.length, Nt = h.length;
        if (bt != Nt && !(yt && Nt > bt))
          return !1;
        var oe = ut.get(r), le = ut.get(h);
        if (oe && le)
          return oe == h && le == r;
        var de = -1, ze = !0, Je = v & E ? new Is() : s;
        for (ut.set(r, h), ut.set(h, r); ++de < bt; ) {
          var li = r[de], Ti = h[de];
          if (I)
            var hi = yt ? I(Ti, li, de, h, r, ut) : I(li, Ti, de, r, h, ut);
          if (hi !== s) {
            if (hi)
              continue;
            ze = !1;
            break;
          }
          if (Je) {
            if (!Ao(h, function(Ai, Bi) {
              if (!ho(Je, Bi) && (li === Ai || Y(li, Ai, v, I, ut)))
                return Je.push(Bi);
            })) {
              ze = !1;
              break;
            }
          } else if (!(li === Ti || Y(li, Ti, v, I, ut))) {
            ze = !1;
            break;
          }
        }
        return ut.delete(r), ut.delete(h), ze;
      }
      function Wd(r, h, v, I, Y, ut, yt) {
        switch (v) {
          case Xt:
            if (r.byteLength != h.byteLength || r.byteOffset != h.byteOffset)
              return !1;
            r = r.buffer, h = h.buffer;
          case Gt:
            return !(r.byteLength != h.byteLength || !ut(new $i(r), new $i(h)));
          case Oe:
          case Ge:
          case Jt:
            return Fo(+r, +h);
          case Ri:
            return r.name == h.name && r.message == h.message;
          case ie:
          case z:
            return r == h + "";
          case W:
            var bt = Zn;
          case Kt:
            var Nt = I & F;
            if (bt || (bt = bs), r.size != h.size && !Nt)
              return !1;
            var oe = yt.get(r);
            if (oe)
              return oe == h;
            I |= E, yt.set(r, h);
            var le = Cf(bt(r), bt(h), I, Y, ut, yt);
            return yt.delete(r), le;
          case Q:
            if (Os)
              return Os.call(r) == Os.call(h);
        }
        return !1;
      }
      function jd(r, h, v, I, Y, ut) {
        var yt = v & F, bt = sc(r), Nt = bt.length, oe = sc(h), le = oe.length;
        if (Nt != le && !yt)
          return !1;
        for (var de = Nt; de--; ) {
          var ze = bt[de];
          if (!(yt ? ze in h : wi.call(h, ze)))
            return !1;
        }
        var Je = ut.get(r), li = ut.get(h);
        if (Je && li)
          return Je == h && li == r;
        var Ti = !0;
        ut.set(r, h), ut.set(h, r);
        for (var hi = yt; ++de < Nt; ) {
          ze = bt[de];
          var Ai = r[ze], Bi = h[ze];
          if (I)
            var Zr = yt ? I(Bi, Ai, ze, h, r, ut) : I(Ai, Bi, ze, r, h, ut);
          if (!(Zr === s ? Ai === Bi || Y(Ai, Bi, v, I, ut) : Zr)) {
            Ti = !1;
            break;
          }
          hi || (hi = ze == "constructor");
        }
        if (Ti && !hi) {
          var wr = r.constructor, Jr = h.constructor;
          wr != Jr && "constructor" in r && "constructor" in h && !(typeof wr == "function" && wr instanceof wr && typeof Jr == "function" && Jr instanceof Jr) && (Ti = !1);
        }
        return ut.delete(r), ut.delete(h), Ti;
      }
      function Bs(r) {
        return dc(If(r, s, Hf), r + "");
      }
      function sc(r) {
        return xu(r, Xn, uc);
      }
      function ac(r) {
        return xu(r, Ir, Af);
      }
      var lc = il ? function(r) {
        return il.get(r);
      } : Cc;
      function Mu(r) {
        for (var h = r.name + "", v = Ko[h], I = wi.call(Ko, h) ? v.length : 0; I--; ) {
          var Y = v[I], ut = Y.func;
          if (ut == null || ut == r)
            return Y.name;
        }
        return h;
      }
      function th(r) {
        var h = wi.call(it, "placeholder") ? it : r;
        return h.placeholder;
      }
      function oi() {
        var r = it.iteratee || Ec;
        return r = r === Ec ? H : r, arguments.length ? r(arguments[0], arguments[1]) : r;
      }
      function Su(r, h) {
        var v = r.__data__;
        return Qd(h) ? v[typeof h == "string" ? "string" : "hash"] : v.map;
      }
      function hc(r) {
        for (var h = Xn(r), v = h.length; v--; ) {
          var I = h[v], Y = r[I];
          h[v] = [I, Y, Rf(Y)];
        }
        return h;
      }
      function dl(r, h) {
        var v = Ms(r, h);
        return w(v) ? v : s;
      }
      function Xd(r) {
        var h = wi.call(r, mo), v = r[mo];
        try {
          r[mo] = s;
          var I = !0;
        } catch {
        }
        var Y = sr.call(r);
        return I && (h ? r[mo] = v : delete r[mo]), Y;
      }
      var uc = Ka ? function(r) {
        return r == null ? [] : (r = Ee(r), Sr(Ka(r), function(h) {
          return $a.call(r, h);
        }));
      } : Ac, Af = Ka ? function(r) {
        for (var h = []; r; )
          ao(h, uc(r)), r = po(r);
        return h;
      } : Ac, ur = jn;
      (tl && ur(new tl(new ArrayBuffer(1))) != Xt || Ls && ur(new Ls()) != W || el && ur(el.resolve()) != dt || Rs && ur(new Rs()) != Kt || Tn && ur(new Tn()) != nt) && (ur = function(r) {
        var h = jn(r), v = h == pt ? r.constructor : s, I = v ? ml(v) : "";
        if (I)
          switch (I) {
            case jl:
              return Xt;
            case Eh:
              return W;
            case bh:
              return dt;
            case Ch:
              return Kt;
            case cu:
              return nt;
          }
        return h;
      });
      function qd(r, h, v) {
        for (var I = -1, Y = v.length; ++I < Y; ) {
          var ut = v[I], yt = ut.size;
          switch (ut.type) {
            case "drop":
              r += yt;
              break;
            case "dropRight":
              h -= yt;
              break;
            case "take":
              h = Gn(h, r + yt);
              break;
            case "takeRight":
              r = pn(r, h - yt);
              break;
          }
        }
        return { start: r, end: h };
      }
      function Yd(r) {
        var h = r.match(Ba);
        return h ? h[1].split(ro) : [];
      }
      function Pf(r, h, v) {
        h = Ze(h, r);
        for (var I = -1, Y = h.length, ut = !1; ++I < Y; ) {
          var yt = rs(h[I]);
          if (!(ut = r != null && v(r, yt)))
            break;
          r = r[yt];
        }
        return ut || ++I != Y ? ut : (Y = r == null ? 0 : r.length, !!Y && Ru(Y) && Ns(yt, Y) && (gi(r) || gl(r)));
      }
      function Zd(r) {
        var h = r.length, v = new r.constructor(h);
        return h && typeof r[0] == "string" && wi.call(r, "index") && (v.index = r.index, v.input = r.input), v;
      }
      function Lf(r) {
        return typeof r.constructor == "function" && !Uh(r) ? Qo(po(r)) : {};
      }
      function Jd(r, h, v) {
        var I = r.constructor;
        switch (h) {
          case Gt:
            return Ta(r);
          case Oe:
          case Ge:
            return new I(+r);
          case Xt:
            return zh(r, v);
          case jt:
          case Ne:
          case Re:
          case ge:
          case we:
          case vi:
          case Mi:
          case ni:
          case Si:
            return pl(r, v);
          case W:
            return new I();
          case Jt:
          case z:
            return new I(r);
          case ie:
            return Ma(r);
          case Kt:
            return new I();
          case Q:
            return zs(r);
        }
      }
      function $d(r, h) {
        var v = h.length;
        if (!v)
          return r;
        var I = v - 1;
        return h[I] = (v > 1 ? "& " : "") + h[I], h = h.join(v > 2 ? ", " : " "), r.replace(Zs, `{
/* [wrapped with ` + h + `] */
`);
      }
      function Kd(r) {
        return gi(r) || gl(r) || !!(fa && r && r[fa]);
      }
      function Ns(r, h) {
        var v = typeof r;
        return h = h ?? fe, !!h && (v == "number" || v != "symbol" && Ol.test(r)) && r > -1 && r % 1 == 0 && r < h;
      }
      function xr(r, h, v) {
        if (!vn(v))
          return !1;
        var I = typeof h;
        return (I == "number" ? Or(v) && Ns(h, v.length) : I == "string" && h in v) ? Fo(v[h], r) : !1;
      }
      function cc(r, h) {
        if (gi(r))
          return !1;
        var v = typeof r;
        return v == "number" || v == "symbol" || v == "boolean" || r == null || Yr(r) ? !0 : dr.test(r) || !us.test(r) || h != null && r in Ee(h);
      }
      function Qd(r) {
        var h = typeof r;
        return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? r !== "__proto__" : r === null;
      }
      function fc(r) {
        var h = Mu(r), v = it[h];
        if (typeof v != "function" || !(h in yi.prototype))
          return !1;
        if (r === v)
          return !0;
        var I = lc(v);
        return !!I && r === I[0];
      }
      function tm(r) {
        return !!Ar && Ar in r;
      }
      var em = Jo ? Fs : Pc;
      function Uh(r) {
        var h = r && r.constructor, v = typeof h == "function" && h.prototype || co;
        return r === v;
      }
      function Rf(r) {
        return r === r && !vn(r);
      }
      function Of(r, h) {
        return function(v) {
          return v == null ? !1 : v[r] === h && (h !== s || r in Ee(v));
        };
      }
      function im(r) {
        var h = Pu(r, function(I) {
          return v.size === S && v.clear(), I;
        }), v = h.cache;
        return h;
      }
      function nm(r, h) {
        var v = r[1], I = h[1], Y = v | I, ut = Y < (L | T | j), yt = I == j && v == R || I == j && v == J && r[7].length <= h[8] || I == (j | J) && h[7].length <= h[8] && v == R;
        if (!(ut || yt))
          return r;
        I & L && (r[2] = h[2], Y |= v & L ? 0 : M);
        var bt = h[3];
        if (bt) {
          var Nt = r[3];
          r[3] = Nt ? kh(Nt, bt, h[4]) : bt, r[4] = Nt ? Cr(r[3], C) : h[4];
        }
        return bt = h[5], bt && (Nt = r[5], r[5] = Nt ? Bh(Nt, bt, h[6]) : bt, r[6] = Nt ? Cr(r[5], C) : h[6]), bt = h[7], bt && (r[7] = bt), I & j && (r[8] = r[8] == null ? h[8] : Gn(r[8], h[8])), r[9] == null && (r[9] = h[9]), r[0] = h[0], r[1] = Y, r;
      }
      function rm(r) {
        var h = [];
        if (r != null)
          for (var v in Ee(r))
            h.push(v);
        return h;
      }
      function om(r) {
        return sr.call(r);
      }
      function If(r, h, v) {
        return h = pn(h === s ? r.length - 1 : h, 0), function() {
          for (var I = arguments, Y = -1, ut = pn(I.length - h, 0), yt = Zt(ut); ++Y < ut; )
            yt[Y] = I[h + Y];
          Y = -1;
          for (var bt = Zt(h + 1); ++Y < h; )
            bt[Y] = I[Y];
          return bt[h] = v(yt), mr(r, this, bt);
        };
      }
      function Df(r, h) {
        return h.length < 2 ? r : is(r, Gi(h, 0, -1));
      }
      function sm(r, h) {
        for (var v = r.length, I = Gn(h.length, v), Y = Qn(r); I--; ) {
          var ut = h[I];
          r[I] = Ns(ut, v) ? Y[ut] : s;
        }
        return r;
      }
      function pc(r, h) {
        if (!(h === "constructor" && typeof r[h] == "function") && h != "__proto__")
          return r[h];
      }
      var zf = Bf(Sn), Gh = wh || function(r, h) {
        return fn.setTimeout(r, h);
      }, dc = Bf(mn);
      function kf(r, h, v) {
        var I = h + "";
        return dc(r, $d(I, am(Yd(I), v)));
      }
      function Bf(r) {
        var h = 0, v = 0;
        return function() {
          var I = Qa(), Y = _t - (I - v);
          if (v = I, Y > 0) {
            if (++h >= et)
              return arguments[0];
          } else
            h = 0;
          return r.apply(s, arguments);
        };
      }
      function Eu(r, h) {
        var v = -1, I = r.length, Y = I - 1;
        for (h = h === s ? I : h; ++v < h; ) {
          var ut = me(v, Y), yt = r[ut];
          r[ut] = r[v], r[v] = yt;
        }
        return r.length = h, r;
      }
      var Nf = im(function(r) {
        var h = [];
        return r.charCodeAt(0) === 46 && h.push(""), r.replace(Ys, function(v, I, Y, ut) {
          h.push(Y ? ut.replace($s, "$1") : I || v);
        }), h;
      });
      function rs(r) {
        if (typeof r == "string" || Yr(r))
          return r;
        var h = r + "";
        return h == "0" && 1 / r == -At ? "-0" : h;
      }
      function ml(r) {
        if (r != null) {
          try {
            return rr.call(r);
          } catch {
          }
          try {
            return r + "";
          } catch {
          }
        }
        return "";
      }
      function am(r, h) {
        return Yi(ce, function(v) {
          var I = "_." + v[0];
          h & v[1] && !ja(r, I) && r.push(I);
        }), r.sort();
      }
      function Ff(r) {
        if (r instanceof yi)
          return r.clone();
        var h = new Vn(r.__wrapped__, r.__chain__);
        return h.__actions__ = Qn(r.__actions__), h.__index__ = r.__index__, h.__values__ = r.__values__, h;
      }
      function lm(r, h, v) {
        (v ? xr(r, h, v) : h === s) ? h = 1 : h = pn(xi(h), 0);
        var I = r == null ? 0 : r.length;
        if (!I || h < 1)
          return [];
        for (var Y = 0, ut = 0, yt = Zt(Io(I / h)); Y < I; )
          yt[ut++] = Gi(r, Y, Y += h);
        return yt;
      }
      function hm(r) {
        for (var h = -1, v = r == null ? 0 : r.length, I = 0, Y = []; ++h < v; ) {
          var ut = r[h];
          ut && (Y[I++] = ut);
        }
        return Y;
      }
      function um() {
        var r = arguments.length;
        if (!r)
          return [];
        for (var h = Zt(r - 1), v = arguments[0], I = r; I--; )
          h[I - 1] = arguments[I];
        return ao(gi(v) ? Qn(v) : [v], Mn(h, 1));
      }
      var cm = ae(function(r, h) {
        return Rn(r) ? ul(r, Mn(h, 1, Rn, !0)) : [];
      }), fm = ae(function(r, h) {
        var v = wo(h);
        return Rn(v) && (v = s), Rn(r) ? ul(r, Mn(h, 1, Rn, !0), oi(v, 2)) : [];
      }), pm = ae(function(r, h) {
        var v = wo(h);
        return Rn(v) && (v = s), Rn(r) ? ul(r, Mn(h, 1, Rn, !0), s, v) : [];
      });
      function dm(r, h, v) {
        var I = r == null ? 0 : r.length;
        return I ? (h = v || h === s ? 1 : xi(h), Gi(r, h < 0 ? 0 : h, I)) : [];
      }
      function mm(r, h, v) {
        var I = r == null ? 0 : r.length;
        return I ? (h = v || h === s ? 1 : xi(h), h = I - h, Gi(r, 0, h < 0 ? 0 : h)) : [];
      }
      function gm(r, h) {
        return r && r.length ? Xe(r, oi(h, 3), !0, !0) : [];
      }
      function vm(r, h) {
        return r && r.length ? Xe(r, oi(h, 3), !0) : [];
      }
      function ym(r, h, v, I) {
        var Y = r == null ? 0 : r.length;
        return Y ? (v && typeof v != "number" && xr(r, h, v) && (v = 0, I = Y), Kn(r, h, v, I)) : [];
      }
      function Uf(r, h, v) {
        var I = r == null ? 0 : r.length;
        if (!I)
          return -1;
        var Y = v == null ? 0 : xi(v);
        return Y < 0 && (Y = pn(I + Y, 0)), Wo(r, oi(h, 3), Y);
      }
      function Gf(r, h, v) {
        var I = r == null ? 0 : r.length;
        if (!I)
          return -1;
        var Y = I - 1;
        return v !== s && (Y = xi(v), Y = v < 0 ? pn(I + Y, 0) : Gn(Y, I - 1)), Wo(r, oi(h, 3), Y, !0);
      }
      function Hf(r) {
        var h = r == null ? 0 : r.length;
        return h ? Mn(r, 1) : [];
      }
      function _m(r) {
        var h = r == null ? 0 : r.length;
        return h ? Mn(r, At) : [];
      }
      function xm(r, h) {
        var v = r == null ? 0 : r.length;
        return v ? (h = h === s ? 1 : xi(h), Mn(r, h)) : [];
      }
      function wm(r) {
        for (var h = -1, v = r == null ? 0 : r.length, I = {}; ++h < v; ) {
          var Y = r[h];
          I[Y[0]] = Y[1];
        }
        return I;
      }
      function Vf(r) {
        return r && r.length ? r[0] : s;
      }
      function Tm(r, h, v) {
        var I = r == null ? 0 : r.length;
        if (!I)
          return -1;
        var Y = v == null ? 0 : xi(v);
        return Y < 0 && (Y = pn(I + Y, 0)), Er(r, h, Y);
      }
      function Mm(r) {
        var h = r == null ? 0 : r.length;
        return h ? Gi(r, 0, -1) : [];
      }
      var Sm = ae(function(r) {
        var h = Xi(r, ne);
        return h.length && h[0] === r[0] ? fl(h) : [];
      }), Em = ae(function(r) {
        var h = wo(r), v = Xi(r, ne);
        return h === wo(v) ? h = s : v.pop(), v.length && v[0] === r[0] ? fl(v, oi(h, 2)) : [];
      }), bm = ae(function(r) {
        var h = wo(r), v = Xi(r, ne);
        return h = typeof h == "function" ? h : s, h && v.pop(), v.length && v[0] === r[0] ? fl(v, s, h) : [];
      });
      function Cm(r, h) {
        return r == null ? "" : Mh.call(r, h);
      }
      function wo(r) {
        var h = r == null ? 0 : r.length;
        return h ? r[h - 1] : s;
      }
      function Am(r, h, v) {
        var I = r == null ? 0 : r.length;
        if (!I)
          return -1;
        var Y = I;
        return v !== s && (Y = xi(v), Y = Y < 0 ? pn(I + Y, 0) : Gn(Y, I - 1)), h === h ? Fl(r, h, Y) : Wo(r, ys, Y, !0);
      }
      function Pm(r, h) {
        return r && r.length ? Z(r, xi(h)) : s;
      }
      var Lm = ae(Wf);
      function Wf(r, h) {
        return r && r.length && h && h.length ? qt(r, h) : r;
      }
      function Rm(r, h, v) {
        return r && r.length && h && h.length ? qt(r, h, oi(v, 2)) : r;
      }
      function Om(r, h, v) {
        return r && r.length && h && h.length ? qt(r, h, s, v) : r;
      }
      var Im = Bs(function(r, h) {
        var v = r == null ? 0 : r.length, I = Ih(r, h);
        return Te(r, Xi(h, function(Y) {
          return Ns(Y, v) ? +Y : Y;
        }).sort(ks)), I;
      });
      function Dm(r, h) {
        var v = [];
        if (!(r && r.length))
          return v;
        var I = -1, Y = [], ut = r.length;
        for (h = oi(h, 3); ++I < ut; ) {
          var yt = r[I];
          h(yt, I, r) && (v.push(yt), Y.push(I));
        }
        return Te(r, Y), v;
      }
      function mc(r) {
        return r == null ? r : pa.call(r);
      }
      function zm(r, h, v) {
        var I = r == null ? 0 : r.length;
        return I ? (v && typeof v != "number" && xr(r, h, v) ? (h = 0, v = I) : (h = h == null ? 0 : xi(h), v = v === s ? I : xi(v)), Gi(r, h, v)) : [];
      }
      function km(r, h) {
        return En(r, h);
      }
      function Bm(r, h, v) {
        return Ce(r, h, oi(v, 2));
      }
      function Nm(r, h) {
        var v = r == null ? 0 : r.length;
        if (v) {
          var I = En(r, h);
          if (I < v && Fo(r[I], h))
            return I;
        }
        return -1;
      }
      function Fm(r, h) {
        return En(r, h, !0);
      }
      function Um(r, h, v) {
        return Ce(r, h, oi(v, 2), !0);
      }
      function Gm(r, h) {
        var v = r == null ? 0 : r.length;
        if (v) {
          var I = En(r, h, !0) - 1;
          if (Fo(r[I], h))
            return I;
        }
        return -1;
      }
      function Hm(r) {
        return r && r.length ? ti(r) : [];
      }
      function Vm(r, h) {
        return r && r.length ? ti(r, oi(h, 2)) : [];
      }
      function Wm(r) {
        var h = r == null ? 0 : r.length;
        return h ? Gi(r, 1, h) : [];
      }
      function jm(r, h, v) {
        return r && r.length ? (h = v || h === s ? 1 : xi(h), Gi(r, 0, h < 0 ? 0 : h)) : [];
      }
      function Xm(r, h, v) {
        var I = r == null ? 0 : r.length;
        return I ? (h = v || h === s ? 1 : xi(h), h = I - h, Gi(r, h < 0 ? 0 : h, I)) : [];
      }
      function qm(r, h) {
        return r && r.length ? Xe(r, oi(h, 3), !1, !0) : [];
      }
      function Ym(r, h) {
        return r && r.length ? Xe(r, oi(h, 3)) : [];
      }
      var Zm = ae(function(r) {
        return ei(Mn(r, 1, Rn, !0));
      }), Jm = ae(function(r) {
        var h = wo(r);
        return Rn(h) && (h = s), ei(Mn(r, 1, Rn, !0), oi(h, 2));
      }), $m = ae(function(r) {
        var h = wo(r);
        return h = typeof h == "function" ? h : s, ei(Mn(r, 1, Rn, !0), s, h);
      });
      function Km(r) {
        return r && r.length ? ei(r) : [];
      }
      function Qm(r, h) {
        return r && r.length ? ei(r, oi(h, 2)) : [];
      }
      function tg(r, h) {
        return h = typeof h == "function" ? h : s, r && r.length ? ei(r, s, h) : [];
      }
      function gc(r) {
        if (!(r && r.length))
          return [];
        var h = 0;
        return r = Sr(r, function(v) {
          if (Rn(v))
            return h = pn(v.length, h), !0;
        }), Lo(h, function(v) {
          return Xi(r, jo(v));
        });
      }
      function jf(r, h) {
        if (!(r && r.length))
          return [];
        var v = gc(r);
        return h == null ? v : Xi(v, function(I) {
          return mr(h, s, I);
        });
      }
      var eg = ae(function(r, h) {
        return Rn(r) ? ul(r, h) : [];
      }), ig = ae(function(r) {
        return Ci(Sr(r, Rn));
      }), ng = ae(function(r) {
        var h = wo(r);
        return Rn(h) && (h = s), Ci(Sr(r, Rn), oi(h, 2));
      }), rg = ae(function(r) {
        var h = wo(r);
        return h = typeof h == "function" ? h : s, Ci(Sr(r, Rn), s, h);
      }), og = ae(gc);
      function sg(r, h) {
        return bi(r || [], h || [], xa);
      }
      function ag(r, h) {
        return bi(r || [], h || [], ci);
      }
      var lg = ae(function(r) {
        var h = r.length, v = h > 1 ? r[h - 1] : s;
        return v = typeof v == "function" ? (r.pop(), v) : s, jf(r, v);
      });
      function Xf(r) {
        var h = it(r);
        return h.__chain__ = !0, h;
      }
      function hg(r, h) {
        return h(r), r;
      }
      function bu(r, h) {
        return h(r);
      }
      var ug = Bs(function(r) {
        var h = r.length, v = h ? r[0] : 0, I = this.__wrapped__, Y = function(ut) {
          return Ih(ut, r);
        };
        return h > 1 || this.__actions__.length || !(I instanceof yi) || !Ns(v) ? this.thru(Y) : (I = I.slice(v, +v + (h ? 1 : 0)), I.__actions__.push({
          func: bu,
          args: [Y],
          thisArg: s
        }), new Vn(I, this.__chain__).thru(function(ut) {
          return h && !ut.length && ut.push(s), ut;
        }));
      });
      function cg() {
        return Xf(this);
      }
      function fg() {
        return new Vn(this.value(), this.__chain__);
      }
      function pg() {
        this.__values__ === s && (this.__values__ = sp(this.value()));
        var r = this.__index__ >= this.__values__.length, h = r ? s : this.__values__[this.__index__++];
        return { done: r, value: h };
      }
      function dg() {
        return this;
      }
      function mg(r) {
        for (var h, v = this; v instanceof ma; ) {
          var I = Ff(v);
          I.__index__ = 0, I.__values__ = s, h ? Y.__wrapped__ = I : h = I;
          var Y = I;
          v = v.__wrapped__;
        }
        return Y.__wrapped__ = r, h;
      }
      function gg() {
        var r = this.__wrapped__;
        if (r instanceof yi) {
          var h = r;
          return this.__actions__.length && (h = new yi(this)), h = h.reverse(), h.__actions__.push({
            func: bu,
            args: [mc],
            thisArg: s
          }), new Vn(h, this.__chain__);
        }
        return this.thru(mc);
      }
      function vg() {
        return ri(this.__wrapped__, this.__actions__);
      }
      var yg = Sa(function(r, h, v) {
        wi.call(r, v) ? ++r[v] : ko(r, v, 1);
      });
      function _g(r, h, v) {
        var I = gi(r) ? xh : Wn;
        return v && xr(r, h, v) && (h = s), I(r, oi(h, 3));
      }
      function xg(r, h) {
        var v = gi(r) ? Sr : Lr;
        return v(r, oi(h, 3));
      }
      var wg = Ke(Uf), Tg = Ke(Gf);
      function Mg(r, h) {
        return Mn(Cu(r, h), 1);
      }
      function Sg(r, h) {
        return Mn(Cu(r, h), At);
      }
      function Eg(r, h, v) {
        return v = v === s ? 1 : xi(v), Mn(Cu(r, h), v);
      }
      function qf(r, h) {
        var v = gi(r) ? Yi : dn;
        return v(r, oi(h, 3));
      }
      function Yf(r, h) {
        var v = gi(r) ? gs : _u;
        return v(r, oi(h, 3));
      }
      var bg = Sa(function(r, h, v) {
        wi.call(r, v) ? r[v].push(h) : ko(r, v, [h]);
      });
      function Cg(r, h, v, I) {
        r = Or(r) ? r : ih(r), v = v && !I ? xi(v) : 0;
        var Y = r.length;
        return v < 0 && (v = pn(Y + v, 0)), Ou(r) ? v <= Y && r.indexOf(h, v) > -1 : !!Y && Er(r, h, v) > -1;
      }
      var Ag = ae(function(r, h, v) {
        var I = -1, Y = typeof h == "function", ut = Or(r) ? Zt(r.length) : [];
        return dn(r, function(yt) {
          ut[++I] = Y ? mr(h, yt, v) : e(yt, h, v);
        }), ut;
      }), Pg = Sa(function(r, h, v) {
        ko(r, v, h);
      });
      function Cu(r, h) {
        var v = gi(r) ? Xi : xt;
        return v(r, oi(h, 3));
      }
      function Lg(r, h, v, I) {
        return r == null ? [] : (gi(h) || (h = h == null ? [] : [h]), v = I ? s : v, gi(v) || (v = v == null ? [] : [v]), ot(r, h, v));
      }
      var Rg = Sa(function(r, h, v) {
        r[v ? 0 : 1].push(h);
      }, function() {
        return [[], []];
      });
      function Og(r, h, v) {
        var I = gi(r) ? Bl : Xo, Y = arguments.length < 3;
        return I(r, oi(h, 4), v, Y, dn);
      }
      function Ig(r, h, v) {
        var I = gi(r) ? su : Xo, Y = arguments.length < 3;
        return I(r, oi(h, 4), v, Y, _u);
      }
      function Dg(r, h) {
        var v = gi(r) ? Sr : Lr;
        return v(r, Lu(oi(h, 3)));
      }
      function zg(r) {
        var h = gi(r) ? Lh : We;
        return h(r);
      }
      function kg(r, h, v) {
        (v ? xr(r, h, v) : h === s) ? h = 1 : h = xi(h);
        var I = gi(r) ? oc : Qe;
        return I(r, h);
      }
      function Bg(r) {
        var h = gi(r) ? gu : ji;
        return h(r);
      }
      function Ng(r) {
        if (r == null)
          return 0;
        if (Or(r))
          return Ou(r) ? jr(r) : r.length;
        var h = ur(r);
        return h == W || h == Kt ? r.size : q(r).length;
      }
      function Fg(r, h, v) {
        var I = gi(r) ? Ao : en;
        return v && xr(r, h, v) && (h = s), I(r, oi(h, 3));
      }
      var Ug = ae(function(r, h) {
        if (r == null)
          return [];
        var v = h.length;
        return v > 1 && xr(r, h[0], h[1]) ? h = [] : v > 2 && xr(h[0], h[1], h[2]) && (h = [h[0]]), ot(r, Mn(h, 1), []);
      }), Au = Hl || function() {
        return fn.Date.now();
      };
      function Gg(r, h) {
        if (typeof h != "function")
          throw new nr(m);
        return r = xi(r), function() {
          if (--r < 1)
            return h.apply(this, arguments);
        };
      }
      function Zf(r, h, v) {
        return h = v ? s : h, h = r && h == null ? r.length : h, tr(r, j, s, s, s, s, h);
      }
      function Jf(r, h) {
        var v;
        if (typeof h != "function")
          throw new nr(m);
        return r = xi(r), function() {
          return --r > 0 && (v = h.apply(this, arguments)), r <= 1 && (h = s), v;
        };
      }
      var vc = ae(function(r, h, v) {
        var I = L;
        if (v.length) {
          var Y = Cr(v, th(vc));
          I |= U;
        }
        return tr(r, I, h, v, Y);
      }), $f = ae(function(r, h, v) {
        var I = L | T;
        if (v.length) {
          var Y = Cr(v, th($f));
          I |= U;
        }
        return tr(h, I, r, v, Y);
      });
      function Kf(r, h, v) {
        h = v ? s : h;
        var I = tr(r, R, s, s, s, s, s, h);
        return I.placeholder = Kf.placeholder, I;
      }
      function Qf(r, h, v) {
        h = v ? s : h;
        var I = tr(r, b, s, s, s, s, s, h);
        return I.placeholder = Qf.placeholder, I;
      }
      function tp(r, h, v) {
        var I, Y, ut, yt, bt, Nt, oe = 0, le = !1, de = !1, ze = !0;
        if (typeof r != "function")
          throw new nr(m);
        h = To(h) || 0, vn(v) && (le = !!v.leading, de = "maxWait" in v, ut = de ? pn(To(v.maxWait) || 0, h) : ut, ze = "trailing" in v ? !!v.trailing : ze);
        function Je(On) {
          var Uo = I, Gs = Y;
          return I = Y = s, oe = On, yt = r.apply(Gs, Uo), yt;
        }
        function li(On) {
          return oe = On, bt = Gh(Ai, h), le ? Je(On) : yt;
        }
        function Ti(On) {
          var Uo = On - Nt, Gs = On - oe, _p = h - Uo;
          return de ? Gn(_p, ut - Gs) : _p;
        }
        function hi(On) {
          var Uo = On - Nt, Gs = On - oe;
          return Nt === s || Uo >= h || Uo < 0 || de && Gs >= ut;
        }
        function Ai() {
          var On = Au();
          if (hi(On))
            return Bi(On);
          bt = Gh(Ai, Ti(On));
        }
        function Bi(On) {
          return bt = s, ze && I ? Je(On) : (I = Y = s, yt);
        }
        function Zr() {
          bt !== s && bn(bt), oe = 0, I = Nt = Y = bt = s;
        }
        function wr() {
          return bt === s ? yt : Bi(Au());
        }
        function Jr() {
          var On = Au(), Uo = hi(On);
          if (I = arguments, Y = this, Nt = On, Uo) {
            if (bt === s)
              return li(Nt);
            if (de)
              return bn(bt), bt = Gh(Ai, h), Je(Nt);
          }
          return bt === s && (bt = Gh(Ai, h)), yt;
        }
        return Jr.cancel = Zr, Jr.flush = wr, Jr;
      }
      var Hg = ae(function(r, h) {
        return vo(r, 1, h);
      }), Vg = ae(function(r, h, v) {
        return vo(r, To(h) || 0, v);
      });
      function Wg(r) {
        return tr(r, K);
      }
      function Pu(r, h) {
        if (typeof r != "function" || h != null && typeof h != "function")
          throw new nr(m);
        var v = function() {
          var I = arguments, Y = h ? h.apply(this, I) : I[0], ut = v.cache;
          if (ut.has(Y))
            return ut.get(Y);
          var yt = r.apply(this, I);
          return v.cache = ut.set(Y, yt) || ut, yt;
        };
        return v.cache = new (Pu.Cache || vr)(), v;
      }
      Pu.Cache = vr;
      function Lu(r) {
        if (typeof r != "function")
          throw new nr(m);
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return !r.call(this);
            case 1:
              return !r.call(this, h[0]);
            case 2:
              return !r.call(this, h[0], h[1]);
            case 3:
              return !r.call(this, h[0], h[1], h[2]);
          }
          return !r.apply(this, h);
        };
      }
      function jg(r) {
        return Jf(2, r);
      }
      var Xg = ai(function(r, h) {
        h = h.length == 1 && gi(h[0]) ? Xi(h[0], Fn(oi())) : Xi(Mn(h, 1), Fn(oi()));
        var v = h.length;
        return ae(function(I) {
          for (var Y = -1, ut = Gn(I.length, v); ++Y < ut; )
            I[Y] = h[Y].call(this, I[Y]);
          return mr(r, this, I);
        });
      }), yc = ae(function(r, h) {
        var v = Cr(h, th(yc));
        return tr(r, U, s, h, v);
      }), ep = ae(function(r, h) {
        var v = Cr(h, th(ep));
        return tr(r, N, s, h, v);
      }), qg = Bs(function(r, h) {
        return tr(r, J, s, s, s, h);
      });
      function Yg(r, h) {
        if (typeof r != "function")
          throw new nr(m);
        return h = h === s ? h : xi(h), ae(r, h);
      }
      function Zg(r, h) {
        if (typeof r != "function")
          throw new nr(m);
        return h = h == null ? 0 : pn(xi(h), 0), ae(function(v) {
          var I = v[h], Y = gn(v, 0, h);
          return I && ao(Y, I), mr(r, this, Y);
        });
      }
      function Jg(r, h, v) {
        var I = !0, Y = !0;
        if (typeof r != "function")
          throw new nr(m);
        return vn(v) && (I = "leading" in v ? !!v.leading : I, Y = "trailing" in v ? !!v.trailing : Y), tp(r, h, {
          leading: I,
          maxWait: h,
          trailing: Y
        });
      }
      function $g(r) {
        return Zf(r, 1);
      }
      function Kg(r, h) {
        return yc(ii(h), r);
      }
      function Qg() {
        if (!arguments.length)
          return [];
        var r = arguments[0];
        return gi(r) ? r : [r];
      }
      function t0(r) {
        return yr(r, D);
      }
      function e0(r, h) {
        return h = typeof h == "function" ? h : s, yr(r, D, h);
      }
      function i0(r) {
        return yr(r, O | D);
      }
      function n0(r, h) {
        return h = typeof h == "function" ? h : s, yr(r, O | D, h);
      }
      function r0(r, h) {
        return h == null || yu(r, h, Xn(h));
      }
      function Fo(r, h) {
        return r === h || r !== r && h !== h;
      }
      var o0 = xo(Jl), s0 = xo(function(r, h) {
        return r >= h;
      }), gl = i(function() {
        return arguments;
      }()) ? i : function(r) {
        return Cn(r) && wi.call(r, "callee") && !$a.call(r, "callee");
      }, gi = Zt.isArray, a0 = _h ? Fn(_h) : n;
      function Or(r) {
        return r != null && Ru(r.length) && !Fs(r);
      }
      function Rn(r) {
        return Cn(r) && Or(r);
      }
      function l0(r) {
        return r === !0 || r === !1 || Cn(r) && jn(r) == Oe;
      }
      var ba = Th || Pc, h0 = oa ? Fn(oa) : o;
      function u0(r) {
        return Cn(r) && r.nodeType === 1 && !Hh(r);
      }
      function c0(r) {
        if (r == null)
          return !0;
        if (Or(r) && (gi(r) || typeof r == "string" || typeof r.splice == "function" || ba(r) || eh(r) || gl(r)))
          return !r.length;
        var h = ur(r);
        if (h == W || h == Kt)
          return !r.size;
        if (Uh(r))
          return !q(r).length;
        for (var v in r)
          if (wi.call(r, v))
            return !1;
        return !0;
      }
      function f0(r, h) {
        return l(r, h);
      }
      function p0(r, h, v) {
        v = typeof v == "function" ? v : s;
        var I = v ? v(r, h) : s;
        return I === s ? l(r, h, s, v) : !!I;
      }
      function _c(r) {
        if (!Cn(r))
          return !1;
        var h = jn(r);
        return h == Ri || h == pi || typeof r.message == "string" && typeof r.name == "string" && !Hh(r);
      }
      function d0(r) {
        return typeof r == "number" && Vl(r);
      }
      function Fs(r) {
        if (!vn(r))
          return !1;
        var h = jn(r);
        return h == cn || h == Ji || h == Li || h == Dt;
      }
      function ip(r) {
        return typeof r == "number" && r == xi(r);
      }
      function Ru(r) {
        return typeof r == "number" && r > -1 && r % 1 == 0 && r <= fe;
      }
      function vn(r) {
        var h = typeof r;
        return r != null && (h == "object" || h == "function");
      }
      function Cn(r) {
        return r != null && typeof r == "object";
      }
      var np = sa ? Fn(sa) : p;
      function m0(r, h) {
        return r === h || y(r, h, hc(h));
      }
      function g0(r, h, v) {
        return v = typeof v == "function" ? v : s, y(r, h, hc(h), v);
      }
      function v0(r) {
        return rp(r) && r != +r;
      }
      function y0(r) {
        if (em(r))
          throw new si(u);
        return w(r);
      }
      function _0(r) {
        return r === null;
      }
      function x0(r) {
        return r == null;
      }
      function rp(r) {
        return typeof r == "number" || Cn(r) && jn(r) == Jt;
      }
      function Hh(r) {
        if (!Cn(r) || jn(r) != pt)
          return !1;
        var h = po(r);
        if (h === null)
          return !0;
        var v = wi.call(h, "constructor") && h.constructor;
        return typeof v == "function" && v instanceof v && rr.call(v) == fo;
      }
      var xc = ru ? Fn(ru) : A;
      function w0(r) {
        return ip(r) && r >= -fe && r <= fe;
      }
      var op = ou ? Fn(ou) : P;
      function Ou(r) {
        return typeof r == "string" || !gi(r) && Cn(r) && jn(r) == z;
      }
      function Yr(r) {
        return typeof r == "symbol" || Cn(r) && jn(r) == Q;
      }
      var eh = Dl ? Fn(Dl) : B;
      function T0(r) {
        return r === s;
      }
      function M0(r) {
        return Cn(r) && ur(r) == nt;
      }
      function S0(r) {
        return Cn(r) && jn(r) == vt;
      }
      var E0 = xo(rt), b0 = xo(function(r, h) {
        return r <= h;
      });
      function sp(r) {
        if (!r)
          return [];
        if (Or(r))
          return Ou(r) ? ir(r) : Qn(r);
        if ($o && r[$o])
          return Es(r[$o]());
        var h = ur(r), v = h == W ? Zn : h == Kt ? bs : ih;
        return v(r);
      }
      function Us(r) {
        if (!r)
          return r === 0 ? r : 0;
        if (r = To(r), r === At || r === -At) {
          var h = r < 0 ? -1 : 1;
          return h * re;
        }
        return r === r ? r : 0;
      }
      function xi(r) {
        var h = Us(r), v = h % 1;
        return h === h ? v ? h - v : h : 0;
      }
      function ap(r) {
        return r ? es(xi(r), 0, Ot) : 0;
      }
      function To(r) {
        if (typeof r == "number")
          return r;
        if (Yr(r))
          return Ft;
        if (vn(r)) {
          var h = typeof r.valueOf == "function" ? r.valueOf() : r;
          r = vn(h) ? h + "" : h;
        }
        if (typeof r != "string")
          return r === 0 ? r : +r;
        r = la(r);
        var v = vh.test(r);
        return v || fs.test(r) ? ia(r.slice(2), v ? 2 : 8) : gh.test(r) ? Ft : +r;
      }
      function lp(r) {
        return Ln(r, Ir(r));
      }
      function C0(r) {
        return r ? es(xi(r), -fe, fe) : r === 0 ? r : 0;
      }
      function qi(r) {
        return r == null ? "" : Ye(r);
      }
      var A0 = No(function(r, h) {
        if (Uh(h) || Or(h)) {
          Ln(h, Xn(h), r);
          return;
        }
        for (var v in h)
          wi.call(h, v) && xa(r, v, h[v]);
      }), hp = No(function(r, h) {
        Ln(h, Ir(h), r);
      }), Iu = No(function(r, h, v, I) {
        Ln(h, Ir(h), r, I);
      }), P0 = No(function(r, h, v, I) {
        Ln(h, Xn(h), r, I);
      }), L0 = Bs(Ih);
      function R0(r, h) {
        var v = Qo(r);
        return h == null ? v : Rh(v, h);
      }
      var O0 = ae(function(r, h) {
        r = Ee(r);
        var v = -1, I = h.length, Y = I > 2 ? h[2] : s;
        for (Y && xr(h[0], h[1], Y) && (I = 1); ++v < I; )
          for (var ut = h[v], yt = Ir(ut), bt = -1, Nt = yt.length; ++bt < Nt; ) {
            var oe = yt[bt], le = r[oe];
            (le === s || Fo(le, co[oe]) && !wi.call(r, oe)) && (r[oe] = ut[oe]);
          }
        return r;
      }), I0 = ae(function(r) {
        return r.push(s, bf), mr(up, s, r);
      });
      function D0(r, h) {
        return vs(r, oi(h, 3), Rr);
      }
      function z0(r, h) {
        return vs(r, oi(h, 3), Zl);
      }
      function k0(r, h) {
        return r == null ? r : cl(r, oi(h, 3), Ir);
      }
      function B0(r, h) {
        return r == null ? r : Yl(r, oi(h, 3), Ir);
      }
      function N0(r, h) {
        return r && Rr(r, oi(h, 3));
      }
      function F0(r, h) {
        return r && Zl(r, oi(h, 3));
      }
      function U0(r) {
        return r == null ? [] : Ds(r, Xn(r));
      }
      function G0(r) {
        return r == null ? [] : Ds(r, Ir(r));
      }
      function wc(r, h, v) {
        var I = r == null ? s : is(r, h);
        return I === s ? v : I;
      }
      function H0(r, h) {
        return r != null && Pf(r, h, $l);
      }
      function Tc(r, h) {
        return r != null && Pf(r, h, Dh);
      }
      var V0 = ve(function(r, h, v) {
        h != null && typeof h.toString != "function" && (h = sr.call(h)), r[h] = v;
      }, Sc(Dr)), W0 = ve(function(r, h, v) {
        h != null && typeof h.toString != "function" && (h = sr.call(h)), wi.call(r, h) ? r[h].push(v) : r[h] = [v];
      }, oi), j0 = ae(e);
      function Xn(r) {
        return Or(r) ? mu(r) : q(r);
      }
      function Ir(r) {
        return Or(r) ? mu(r, !0) : $(r);
      }
      function X0(r, h) {
        var v = {};
        return h = oi(h, 3), Rr(r, function(I, Y, ut) {
          ko(v, h(I, Y, ut), I);
        }), v;
      }
      function q0(r, h) {
        var v = {};
        return h = oi(h, 3), Rr(r, function(I, Y, ut) {
          ko(v, Y, h(I, Y, ut));
        }), v;
      }
      var Y0 = No(function(r, h, v) {
        wt(r, h, v);
      }), up = No(function(r, h, v, I) {
        wt(r, h, v, I);
      }), Z0 = Bs(function(r, h) {
        var v = {};
        if (r == null)
          return v;
        var I = !1;
        h = Xi(h, function(ut) {
          return ut = Ze(ut, r), I || (I = ut.length > 1), ut;
        }), Ln(r, ac(r), v), I && (v = yr(v, O | k | D, Vd));
        for (var Y = h.length; Y--; )
          Hi(v, h[Y]);
        return v;
      });
      function J0(r, h) {
        return cp(r, Lu(oi(h)));
      }
      var $0 = Bs(function(r, h) {
        return r == null ? {} : zt(r, h);
      });
      function cp(r, h) {
        if (r == null)
          return {};
        var v = Xi(ac(r), function(I) {
          return [I];
        });
        return h = oi(h), ee(r, v, function(I, Y) {
          return h(I, Y[0]);
        });
      }
      function K0(r, h, v) {
        h = Ze(h, r);
        var I = -1, Y = h.length;
        for (Y || (Y = 1, r = s); ++I < Y; ) {
          var ut = r == null ? s : r[rs(h[I])];
          ut === s && (I = Y, ut = v), r = Fs(ut) ? ut.call(r) : ut;
        }
        return r;
      }
      function Q0(r, h, v) {
        return r == null ? r : ci(r, h, v);
      }
      function tv(r, h, v, I) {
        return I = typeof I == "function" ? I : s, r == null ? r : ci(r, h, v, I);
      }
      var fp = Tu(Xn), pp = Tu(Ir);
      function ev(r, h, v) {
        var I = gi(r), Y = I || ba(r) || eh(r);
        if (h = oi(h, 4), v == null) {
          var ut = r && r.constructor;
          Y ? v = I ? new ut() : [] : vn(r) ? v = Fs(ut) ? Qo(po(r)) : {} : v = {};
        }
        return (Y ? Yi : Rr)(r, function(yt, bt, Nt) {
          return h(v, yt, bt, Nt);
        }), v;
      }
      function iv(r, h) {
        return r == null ? !0 : Hi(r, h);
      }
      function nv(r, h, v) {
        return r == null ? r : Ae(r, h, ii(v));
      }
      function rv(r, h, v, I) {
        return I = typeof I == "function" ? I : s, r == null ? r : Ae(r, h, ii(v), I);
      }
      function ih(r) {
        return r == null ? [] : _s(r, Xn(r));
      }
      function ov(r) {
        return r == null ? [] : _s(r, Ir(r));
      }
      function sv(r, h, v) {
        return v === s && (v = h, h = s), v !== s && (v = To(v), v = v === v ? v : 0), h !== s && (h = To(h), h = h === h ? h : 0), es(To(r), h, v);
      }
      function av(r, h, v) {
        return h = Us(h), v === s ? (v = h, h = 0) : v = Us(v), r = To(r), Kl(r, h, v);
      }
      function lv(r, h, v) {
        if (v && typeof v != "boolean" && xr(r, h, v) && (h = v = s), v === s && (typeof h == "boolean" ? (v = h, h = s) : typeof r == "boolean" && (v = r, r = s)), r === s && h === s ? (r = 0, h = 1) : (r = Us(r), h === s ? (h = r, r = 0) : h = Us(h)), r > h) {
          var I = r;
          r = h, h = I;
        }
        if (v || r % 1 || h % 1) {
          var Y = Wl();
          return Gn(r + Y * (h - r + Wa("1e-" + ((Y + "").length - 1))), h);
        }
        return me(r, h);
      }
      var hv = De(function(r, h, v) {
        return h = h.toLowerCase(), r + (v ? dp(h) : h);
      });
      function dp(r) {
        return Mc(qi(r).toLowerCase());
      }
      function mp(r) {
        return r = qi(r), r && r.replace(Il, ws).replace(yh, "");
      }
      function uv(r, h, v) {
        r = qi(r), h = Ye(h);
        var I = r.length;
        v = v === s ? I : es(xi(v), 0, I);
        var Y = v;
        return v -= h.length, v >= 0 && r.slice(v, Y) == h;
      }
      function cv(r) {
        return r = qi(r), r && io.test(r) ? r.replace(Oi, Wr) : r;
      }
      function fv(r) {
        return r = qi(r), r && Ll.test(r) ? r.replace(ka, "\\$&") : r;
      }
      var pv = De(function(r, h, v) {
        return r + (v ? "-" : "") + h.toLowerCase();
      }), dv = De(function(r, h, v) {
        return r + (v ? " " : "") + h.toLowerCase();
      }), mv = Me("toLowerCase");
      function gv(r, h, v) {
        r = qi(r), h = xi(h);
        var I = h ? jr(r) : 0;
        if (!h || I >= h)
          return r;
        var Y = (h - I) / 2;
        return on(Ps(Y), v) + r + on(Io(Y), v);
      }
      function vv(r, h, v) {
        r = qi(r), h = xi(h);
        var I = h ? jr(r) : 0;
        return h && I < h ? r + on(h - I, v) : r;
      }
      function yv(r, h, v) {
        r = qi(r), h = xi(h);
        var I = h ? jr(r) : 0;
        return h && I < h ? on(h - I, v) + r : r;
      }
      function _v(r, h, v) {
        return v || h == null ? h = 0 : h && (h = +h), Sh(qi(r).replace(no, ""), h || 0);
      }
      function xv(r, h, v) {
        return (v ? xr(r, h, v) : h === s) ? h = 1 : h = xi(h), be(qi(r), h);
      }
      function wv() {
        var r = arguments, h = qi(r[0]);
        return r.length < 3 ? h : h.replace(r[1], r[2]);
      }
      var Tv = De(function(r, h, v) {
        return r + (v ? "_" : "") + h.toLowerCase();
      });
      function Mv(r, h, v) {
        return v && typeof v != "number" && xr(r, h, v) && (h = v = s), v = v === s ? Ot : v >>> 0, v ? (r = qi(r), r && (typeof h == "string" || h != null && !xc(h)) && (h = Ye(h), !h && br(r)) ? gn(ir(r), 0, v) : r.split(h, v)) : [];
      }
      var Sv = De(function(r, h, v) {
        return r + (v ? " " : "") + Mc(h);
      });
      function Ev(r, h, v) {
        return r = qi(r), v = v == null ? 0 : es(xi(v), 0, r.length), h = Ye(h), r.slice(v, v + h.length) == h;
      }
      function bv(r, h, v) {
        var I = it.templateSettings;
        v && xr(r, h, v) && (h = s), r = qi(r), h = Iu({}, h, I, Ef);
        var Y = Iu({}, h.imports, I.imports, Ef), ut = Xn(Y), yt = _s(Y, ut), bt, Nt, oe = 0, le = h.interpolate || Hr, de = "__p += '", ze = Jn(
          (h.escape || Hr).source + "|" + le.source + "|" + (le === qs ? oo : Hr).source + "|" + (h.evaluate || Hr).source + "|$",
          "g"
        ), Je = "//# sourceURL=" + (wi.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ta + "]") + `
`;
        r.replace(ze, function(hi, Ai, Bi, Zr, wr, Jr) {
          return Bi || (Bi = Zr), de += r.slice(oe, Jr).replace(V, Ts), Ai && (bt = !0, de += `' +
__e(` + Ai + `) +
'`), wr && (Nt = !0, de += `';
` + wr + `;
__p += '`), Bi && (de += `' +
((__t = (` + Bi + `)) == null ? '' : __t) +
'`), oe = Jr + hi.length, hi;
        }), de += `';
`;
        var li = wi.call(h, "variable") && h.variable;
        if (!li)
          de = `with (obj) {
` + de + `
}
`;
        else if (Js.test(li))
          throw new si(g);
        de = (Nt ? de.replace(Gr, "") : de).replace(er, "$1").replace(rn, "$1;"), de = "function(" + (li || "obj") + `) {
` + (li ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (bt ? ", __e = _.escape" : "") + (Nt ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + de + `return __p
}`;
        var Ti = vp(function() {
          return ki(ut, Je + "return " + de).apply(s, yt);
        });
        if (Ti.source = de, _c(Ti))
          throw Ti;
        return Ti;
      }
      function Cv(r) {
        return qi(r).toLowerCase();
      }
      function Av(r) {
        return qi(r).toUpperCase();
      }
      function Pv(r, h, v) {
        if (r = qi(r), r && (v || h === s))
          return la(r);
        if (!r || !(h = Ye(h)))
          return r;
        var I = ir(r), Y = ir(h), ut = Yo(I, Y), yt = xs(I, Y) + 1;
        return gn(I, ut, yt).join("");
      }
      function Lv(r, h, v) {
        if (r = qi(r), r && (v || h === s))
          return r.slice(0, ha(r) + 1);
        if (!r || !(h = Ye(h)))
          return r;
        var I = ir(r), Y = xs(I, ir(h)) + 1;
        return gn(I, 0, Y).join("");
      }
      function Rv(r, h, v) {
        if (r = qi(r), r && (v || h === s))
          return r.replace(no, "");
        if (!r || !(h = Ye(h)))
          return r;
        var I = ir(r), Y = Yo(I, ir(h));
        return gn(I, Y).join("");
      }
      function Ov(r, h) {
        var v = ct, I = It;
        if (vn(h)) {
          var Y = "separator" in h ? h.separator : Y;
          v = "length" in h ? xi(h.length) : v, I = "omission" in h ? Ye(h.omission) : I;
        }
        r = qi(r);
        var ut = r.length;
        if (br(r)) {
          var yt = ir(r);
          ut = yt.length;
        }
        if (v >= ut)
          return r;
        var bt = v - jr(I);
        if (bt < 1)
          return I;
        var Nt = yt ? gn(yt, 0, bt).join("") : r.slice(0, bt);
        if (Y === s)
          return Nt + I;
        if (yt && (bt += Nt.length - bt), xc(Y)) {
          if (r.slice(bt).search(Y)) {
            var oe, le = Nt;
            for (Y.global || (Y = Jn(Y.source, qi(Rl.exec(Y)) + "g")), Y.lastIndex = 0; oe = Y.exec(le); )
              var de = oe.index;
            Nt = Nt.slice(0, de === s ? bt : de);
          }
        } else if (r.indexOf(Ye(Y), bt) != bt) {
          var ze = Nt.lastIndexOf(Y);
          ze > -1 && (Nt = Nt.slice(0, ze));
        }
        return Nt + I;
      }
      function Iv(r) {
        return r = qi(r), r && Go.test(r) ? r.replace(Co, Ul) : r;
      }
      var Dv = De(function(r, h, v) {
        return r + (v ? " " : "") + h.toUpperCase();
      }), Mc = Me("toUpperCase");
      function gp(r, h, v) {
        return r = qi(r), h = v ? s : h, h === s ? Ss(r) ? tc(r) : Xa(r) : r.match(h) || [];
      }
      var vp = ae(function(r, h) {
        try {
          return mr(r, s, h);
        } catch (v) {
          return _c(v) ? v : new si(v);
        }
      }), zv = Bs(function(r, h) {
        return Yi(h, function(v) {
          v = rs(v), ko(r, v, vc(r[v], r));
        }), r;
      });
      function kv(r) {
        var h = r == null ? 0 : r.length, v = oi();
        return r = h ? Xi(r, function(I) {
          if (typeof I[1] != "function")
            throw new nr(m);
          return [v(I[0]), I[1]];
        }) : [], ae(function(I) {
          for (var Y = -1; ++Y < h; ) {
            var ut = r[Y];
            if (mr(ut[0], this, I))
              return mr(ut[1], this, I);
          }
        });
      }
      function Bv(r) {
        return wa(yr(r, O));
      }
      function Sc(r) {
        return function() {
          return r;
        };
      }
      function Nv(r, h) {
        return r == null || r !== r ? h : r;
      }
      var Fv = Pi(), Uv = Pi(!0);
      function Dr(r) {
        return r;
      }
      function Ec(r) {
        return H(typeof r == "function" ? r : yr(r, O));
      }
      function Gv(r) {
        return gt(yr(r, O));
      }
      function Hv(r, h) {
        return Ct(r, yr(h, O));
      }
      var Vv = ae(function(r, h) {
        return function(v) {
          return e(v, r, h);
        };
      }), Wv = ae(function(r, h) {
        return function(v) {
          return e(r, v, h);
        };
      });
      function bc(r, h, v) {
        var I = Xn(h), Y = Ds(h, I);
        v == null && !(vn(h) && (Y.length || !I.length)) && (v = h, h = r, r = this, Y = Ds(h, Xn(h)));
        var ut = !(vn(v) && "chain" in v) || !!v.chain, yt = Fs(r);
        return Yi(Y, function(bt) {
          var Nt = h[bt];
          r[bt] = Nt, yt && (r.prototype[bt] = function() {
            var oe = this.__chain__;
            if (ut || oe) {
              var le = r(this.__wrapped__), de = le.__actions__ = Qn(this.__actions__);
              return de.push({ func: Nt, args: arguments, thisArg: r }), le.__chain__ = oe, le;
            }
            return Nt.apply(r, ao([this.value()], arguments));
          });
        }), r;
      }
      function jv() {
        return fn._ === this && (fn._ = Xr), this;
      }
      function Cc() {
      }
      function Xv(r) {
        return r = xi(r), ae(function(h) {
          return Z(h, r);
        });
      }
      var qv = zn(Xi), Yv = zn(xh), Zv = zn(Ao);
      function yp(r) {
        return cc(r) ? jo(rs(r)) : $t(r);
      }
      function Jv(r) {
        return function(h) {
          return r == null ? s : is(r, h);
        };
      }
      var $v = Nh(), Kv = Nh(!0);
      function Ac() {
        return [];
      }
      function Pc() {
        return !1;
      }
      function Qv() {
        return {};
      }
      function ty() {
        return "";
      }
      function ey() {
        return !0;
      }
      function iy(r, h) {
        if (r = xi(r), r < 1 || r > fe)
          return [];
        var v = Ot, I = Gn(r, Ot);
        h = oi(h), r -= Ot;
        for (var Y = Lo(I, h); ++v < r; )
          h(v);
        return Y;
      }
      function ny(r) {
        return gi(r) ? Xi(r, rs) : Yr(r) ? [r] : Qn(Nf(qi(r)));
      }
      function ry(r) {
        var h = ++or;
        return qi(r) + h;
      }
      var oy = _r(function(r, h) {
        return r + h;
      }, 0), sy = Ql("ceil"), ay = _r(function(r, h) {
        return r / h;
      }, 1), ly = Ql("floor");
      function hy(r) {
        return r && r.length ? yo(r, Dr, Jl) : s;
      }
      function uy(r, h) {
        return r && r.length ? yo(r, oi(h, 2), Jl) : s;
      }
      function cy(r) {
        return aa(r, Dr);
      }
      function fy(r, h) {
        return aa(r, oi(h, 2));
      }
      function py(r) {
        return r && r.length ? yo(r, Dr, rt) : s;
      }
      function dy(r, h) {
        return r && r.length ? yo(r, oi(h, 2), rt) : s;
      }
      var my = _r(function(r, h) {
        return r * h;
      }, 1), gy = Ql("round"), vy = _r(function(r, h) {
        return r - h;
      }, 0);
      function yy(r) {
        return r && r.length ? qo(r, Dr) : 0;
      }
      function _y(r, h) {
        return r && r.length ? qo(r, oi(h, 2)) : 0;
      }
      return it.after = Gg, it.ary = Zf, it.assign = A0, it.assignIn = hp, it.assignInWith = Iu, it.assignWith = P0, it.at = L0, it.before = Jf, it.bind = vc, it.bindAll = zv, it.bindKey = $f, it.castArray = Qg, it.chain = Xf, it.chunk = lm, it.compact = hm, it.concat = um, it.cond = kv, it.conforms = Bv, it.constant = Sc, it.countBy = yg, it.create = R0, it.curry = Kf, it.curryRight = Qf, it.debounce = tp, it.defaults = O0, it.defaultsDeep = I0, it.defer = Hg, it.delay = Vg, it.difference = cm, it.differenceBy = fm, it.differenceWith = pm, it.drop = dm, it.dropRight = mm, it.dropRightWhile = gm, it.dropWhile = vm, it.fill = ym, it.filter = xg, it.flatMap = Mg, it.flatMapDeep = Sg, it.flatMapDepth = Eg, it.flatten = Hf, it.flattenDeep = _m, it.flattenDepth = xm, it.flip = Wg, it.flow = Fv, it.flowRight = Uv, it.fromPairs = wm, it.functions = U0, it.functionsIn = G0, it.groupBy = bg, it.initial = Mm, it.intersection = Sm, it.intersectionBy = Em, it.intersectionWith = bm, it.invert = V0, it.invertBy = W0, it.invokeMap = Ag, it.iteratee = Ec, it.keyBy = Pg, it.keys = Xn, it.keysIn = Ir, it.map = Cu, it.mapKeys = X0, it.mapValues = q0, it.matches = Gv, it.matchesProperty = Hv, it.memoize = Pu, it.merge = Y0, it.mergeWith = up, it.method = Vv, it.methodOf = Wv, it.mixin = bc, it.negate = Lu, it.nthArg = Xv, it.omit = Z0, it.omitBy = J0, it.once = jg, it.orderBy = Lg, it.over = qv, it.overArgs = Xg, it.overEvery = Yv, it.overSome = Zv, it.partial = yc, it.partialRight = ep, it.partition = Rg, it.pick = $0, it.pickBy = cp, it.property = yp, it.propertyOf = Jv, it.pull = Lm, it.pullAll = Wf, it.pullAllBy = Rm, it.pullAllWith = Om, it.pullAt = Im, it.range = $v, it.rangeRight = Kv, it.rearg = qg, it.reject = Dg, it.remove = Dm, it.rest = Yg, it.reverse = mc, it.sampleSize = kg, it.set = Q0, it.setWith = tv, it.shuffle = Bg, it.slice = zm, it.sortBy = Ug, it.sortedUniq = Hm, it.sortedUniqBy = Vm, it.split = Mv, it.spread = Zg, it.tail = Wm, it.take = jm, it.takeRight = Xm, it.takeRightWhile = qm, it.takeWhile = Ym, it.tap = hg, it.throttle = Jg, it.thru = bu, it.toArray = sp, it.toPairs = fp, it.toPairsIn = pp, it.toPath = ny, it.toPlainObject = lp, it.transform = ev, it.unary = $g, it.union = Zm, it.unionBy = Jm, it.unionWith = $m, it.uniq = Km, it.uniqBy = Qm, it.uniqWith = tg, it.unset = iv, it.unzip = gc, it.unzipWith = jf, it.update = nv, it.updateWith = rv, it.values = ih, it.valuesIn = ov, it.without = eg, it.words = gp, it.wrap = Kg, it.xor = ig, it.xorBy = ng, it.xorWith = rg, it.zip = og, it.zipObject = sg, it.zipObjectDeep = ag, it.zipWith = lg, it.entries = fp, it.entriesIn = pp, it.extend = hp, it.extendWith = Iu, bc(it, it), it.add = oy, it.attempt = vp, it.camelCase = hv, it.capitalize = dp, it.ceil = sy, it.clamp = sv, it.clone = t0, it.cloneDeep = i0, it.cloneDeepWith = n0, it.cloneWith = e0, it.conformsTo = r0, it.deburr = mp, it.defaultTo = Nv, it.divide = ay, it.endsWith = uv, it.eq = Fo, it.escape = cv, it.escapeRegExp = fv, it.every = _g, it.find = wg, it.findIndex = Uf, it.findKey = D0, it.findLast = Tg, it.findLastIndex = Gf, it.findLastKey = z0, it.floor = ly, it.forEach = qf, it.forEachRight = Yf, it.forIn = k0, it.forInRight = B0, it.forOwn = N0, it.forOwnRight = F0, it.get = wc, it.gt = o0, it.gte = s0, it.has = H0, it.hasIn = Tc, it.head = Vf, it.identity = Dr, it.includes = Cg, it.indexOf = Tm, it.inRange = av, it.invoke = j0, it.isArguments = gl, it.isArray = gi, it.isArrayBuffer = a0, it.isArrayLike = Or, it.isArrayLikeObject = Rn, it.isBoolean = l0, it.isBuffer = ba, it.isDate = h0, it.isElement = u0, it.isEmpty = c0, it.isEqual = f0, it.isEqualWith = p0, it.isError = _c, it.isFinite = d0, it.isFunction = Fs, it.isInteger = ip, it.isLength = Ru, it.isMap = np, it.isMatch = m0, it.isMatchWith = g0, it.isNaN = v0, it.isNative = y0, it.isNil = x0, it.isNull = _0, it.isNumber = rp, it.isObject = vn, it.isObjectLike = Cn, it.isPlainObject = Hh, it.isRegExp = xc, it.isSafeInteger = w0, it.isSet = op, it.isString = Ou, it.isSymbol = Yr, it.isTypedArray = eh, it.isUndefined = T0, it.isWeakMap = M0, it.isWeakSet = S0, it.join = Cm, it.kebabCase = pv, it.last = wo, it.lastIndexOf = Am, it.lowerCase = dv, it.lowerFirst = mv, it.lt = E0, it.lte = b0, it.max = hy, it.maxBy = uy, it.mean = cy, it.meanBy = fy, it.min = py, it.minBy = dy, it.stubArray = Ac, it.stubFalse = Pc, it.stubObject = Qv, it.stubString = ty, it.stubTrue = ey, it.multiply = my, it.nth = Pm, it.noConflict = jv, it.noop = Cc, it.now = Au, it.pad = gv, it.padEnd = vv, it.padStart = yv, it.parseInt = _v, it.random = lv, it.reduce = Og, it.reduceRight = Ig, it.repeat = xv, it.replace = wv, it.result = K0, it.round = gy, it.runInContext = Lt, it.sample = zg, it.size = Ng, it.snakeCase = Tv, it.some = Fg, it.sortedIndex = km, it.sortedIndexBy = Bm, it.sortedIndexOf = Nm, it.sortedLastIndex = Fm, it.sortedLastIndexBy = Um, it.sortedLastIndexOf = Gm, it.startCase = Sv, it.startsWith = Ev, it.subtract = vy, it.sum = yy, it.sumBy = _y, it.template = bv, it.times = iy, it.toFinite = Us, it.toInteger = xi, it.toLength = ap, it.toLower = Cv, it.toNumber = To, it.toSafeInteger = C0, it.toString = qi, it.toUpper = Av, it.trim = Pv, it.trimEnd = Lv, it.trimStart = Rv, it.truncate = Ov, it.unescape = Iv, it.uniqueId = ry, it.upperCase = Dv, it.upperFirst = Mc, it.each = qf, it.eachRight = Yf, it.first = Vf, bc(it, function() {
        var r = {};
        return Rr(it, function(h, v) {
          wi.call(it.prototype, v) || (r[v] = h);
        }), r;
      }(), { chain: !1 }), it.VERSION = c, Yi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(r) {
        it[r].placeholder = it;
      }), Yi(["drop", "take"], function(r, h) {
        yi.prototype[r] = function(v) {
          v = v === s ? 1 : pn(xi(v), 0);
          var I = this.__filtered__ && !h ? new yi(this) : this.clone();
          return I.__filtered__ ? I.__takeCount__ = Gn(v, I.__takeCount__) : I.__views__.push({
            size: Gn(v, Ot),
            type: r + (I.__dir__ < 0 ? "Right" : "")
          }), I;
        }, yi.prototype[r + "Right"] = function(v) {
          return this.reverse()[r](v).reverse();
        };
      }), Yi(["filter", "map", "takeWhile"], function(r, h) {
        var v = h + 1, I = v == G || v == Et;
        yi.prototype[r] = function(Y) {
          var ut = this.clone();
          return ut.__iteratees__.push({
            iteratee: oi(Y, 3),
            type: v
          }), ut.__filtered__ = ut.__filtered__ || I, ut;
        };
      }), Yi(["head", "last"], function(r, h) {
        var v = "take" + (h ? "Right" : "");
        yi.prototype[r] = function() {
          return this[v](1).value()[0];
        };
      }), Yi(["initial", "tail"], function(r, h) {
        var v = "drop" + (h ? "" : "Right");
        yi.prototype[r] = function() {
          return this.__filtered__ ? new yi(this) : this[v](1);
        };
      }), yi.prototype.compact = function() {
        return this.filter(Dr);
      }, yi.prototype.find = function(r) {
        return this.filter(r).head();
      }, yi.prototype.findLast = function(r) {
        return this.reverse().find(r);
      }, yi.prototype.invokeMap = ae(function(r, h) {
        return typeof r == "function" ? new yi(this) : this.map(function(v) {
          return e(v, r, h);
        });
      }), yi.prototype.reject = function(r) {
        return this.filter(Lu(oi(r)));
      }, yi.prototype.slice = function(r, h) {
        r = xi(r);
        var v = this;
        return v.__filtered__ && (r > 0 || h < 0) ? new yi(v) : (r < 0 ? v = v.takeRight(-r) : r && (v = v.drop(r)), h !== s && (h = xi(h), v = h < 0 ? v.dropRight(-h) : v.take(h - r)), v);
      }, yi.prototype.takeRightWhile = function(r) {
        return this.reverse().takeWhile(r).reverse();
      }, yi.prototype.toArray = function() {
        return this.take(Ot);
      }, Rr(yi.prototype, function(r, h) {
        var v = /^(?:filter|find|map|reject)|While$/.test(h), I = /^(?:head|last)$/.test(h), Y = it[I ? "take" + (h == "last" ? "Right" : "") : h], ut = I || /^find/.test(h);
        Y && (it.prototype[h] = function() {
          var yt = this.__wrapped__, bt = I ? [1] : arguments, Nt = yt instanceof yi, oe = bt[0], le = Nt || gi(yt), de = function(Ai) {
            var Bi = Y.apply(it, ao([Ai], bt));
            return I && ze ? Bi[0] : Bi;
          };
          le && v && typeof oe == "function" && oe.length != 1 && (Nt = le = !1);
          var ze = this.__chain__, Je = !!this.__actions__.length, li = ut && !ze, Ti = Nt && !Je;
          if (!ut && le) {
            yt = Ti ? yt : new yi(this);
            var hi = r.apply(yt, bt);
            return hi.__actions__.push({ func: bu, args: [de], thisArg: s }), new Vn(hi, ze);
          }
          return li && Ti ? r.apply(this, bt) : (hi = this.thru(de), li ? I ? hi.value()[0] : hi.value() : hi);
        });
      }), Yi(["pop", "push", "shift", "sort", "splice", "unshift"], function(r) {
        var h = Pn[r], v = /^(?:push|sort|unshift)$/.test(r) ? "tap" : "thru", I = /^(?:pop|shift)$/.test(r);
        it.prototype[r] = function() {
          var Y = arguments;
          if (I && !this.__chain__) {
            var ut = this.value();
            return h.apply(gi(ut) ? ut : [], Y);
          }
          return this[v](function(yt) {
            return h.apply(gi(yt) ? yt : [], Y);
          });
        };
      }), Rr(yi.prototype, function(r, h) {
        var v = it[h];
        if (v) {
          var I = v.name + "";
          wi.call(Ko, I) || (Ko[I] = []), Ko[I].push({ name: h, func: v });
        }
      }), Ko[Zi(s, T).name] = [{
        name: "wrapper",
        func: s
      }], yi.prototype.clone = ga, yi.prototype.reverse = fu, yi.prototype.value = va, it.prototype.at = ug, it.prototype.chain = cg, it.prototype.commit = fg, it.prototype.next = pg, it.prototype.plant = mg, it.prototype.reverse = gg, it.prototype.toJSON = it.prototype.valueOf = it.prototype.value = vg, it.prototype.first = it.prototype.head, $o && (it.prototype[$o] = dg), it;
    }, Zo = ec();
    Vr ? ((Vr.exports = Zo)._ = Zo, Vo._ = Zo) : fn._ = Zo;
  }).call(zr);
})(Gu, Gu.exports);
var Zy = Gu.exports;
const Uc = /* @__PURE__ */ af(Zy);
class y1 {
  constructor(a = [], s = !1) {
    /**
     * 矢量数据简化
     * @param {*} geojson  geojson数据
     * @returns  { Object }
     */
    vl(this, "simplifyFunc", (a) => {
      try {
        a = turf.simplify(a, {
          tolerance: 5e-4,
          highQuality: !1,
          mutate: !0
        });
      } catch {
      }
      return a;
    });
    mars3d ? (this.vectorArr = a, this.geoJsonType = /* @__PURE__ */ new Map([
      ["Point"],
      ["LineString"],
      ["Polygon"],
      ["MultiPoint"],
      ["MultiLineString"],
      ["MultiPolygon"]
    ]), this.avoidanceArr = [], this.editDate = {
      id: ""
    }, this.isDynamicMasking = s) : console.error("未引入指定插件");
  }
  /**
   * 移除矢量数据
   * @param  { String } id 矢量数据id
   *
   */
  remove(a, s = null) {
    s && s.isClone == "true" ? window.mapClone.mapEx.removeLayer(
      window.mapClone.mapEx.getLayer(a, "vectorId")
    ) : (window.map.removeLayer(window.map.getLayer(a, "vectorId")), window.dynamicMasking && window.dynamicMasking.remove(a));
  }
  /**
   * add 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } customAttributes 自定义属性
   */
  add(a, s) {
    return new Promise((c, d) => {
      let u, m = s == null ? void 0 : s.isClone;
      if (typeof a != "object") {
        let g = window.map.getLayer(a, "vectorId");
        if (g)
          return c(g);
        u = this.query(a);
      } else {
        let g = window.map.getLayer(a.id, "vectorId");
        if (g)
          return c(g);
        u = a;
      }
      if (u) {
        let { value: g, url: _, id: S, title: C } = u;
        new Cesium.Resource({
          url: _
        }).fetchJson().then((k) => {
          let { id: D, title: F, shpInfo: E } = u, { attributes: L, geometryType: T, geometryCount: M, pointCount: R } = E;
          if (L) {
            let {
              width: b,
              materialType: U,
              materialOptions: N,
              clampToGround: j,
              distanceDisplayCondition: J,
              distanceDisplayCondition_near: K,
              distanceDisplayCondition_far: ct,
              zIndex: It,
              label: et,
              fill: _t,
              diffHeight: G,
              outline: Pt,
              outlineStyle: Et,
              color: At,
              pixelSize: fe,
              outlineColor: re,
              outlineWidth: Ft,
              classificationType: Ot
            } = JSON.parse(L), Bt;
            switch (this.isDynamicMasking ? (et.color = Cesium.Color.fromCssColorString(
              et.color
            ).withAlpha(0), et.outlineColor = Cesium.Color.fromCssColorString(
              et.outlineColor
            ).withAlpha(1e-3), et.backgroundColor = Cesium.Color.fromCssColorString(
              et.backgroundColor
            ).withAlpha(1e-3), et.background = !1, et.outline = !1, et.show = !1) : (et.color = Cesium.Color.fromCssColorString(et.color), et.outlineColor = Cesium.Color.fromCssColorString(
              et.outlineColor
            ), et.backgroundColor = Cesium.Color.fromCssColorString(
              et.backgroundColor
            )), T) {
              case "LineString":
              case "MultiLineString":
                et.backgroundPadding = 5, Bt = new mars3d.layer.GeoJsonLayer({
                  data: k,
                  vectorId: D,
                  // format: pointCount > 10000 ? this.simplifyFunc : null,
                  symbol: {
                    type: "polylineC",
                    styleOptions: {
                      width: b,
                      clampToGround: j,
                      distanceDisplayCondition: J,
                      distanceDisplayCondition_far: ct,
                      distanceDisplayCondition_near: K,
                      materialType: U,
                      materialOptions: N,
                      classificationType: Ot,
                      label: et
                    }
                  },
                  // popup: `&nbsp;&nbsp; ${title} &nbsp;&nbsp;`,
                  hasZIndex: !0,
                  zIndex: It
                });
                break;
              case "Polygon":
              case "MultiPolygon":
                U == "PolyGrass" && (N = {
                  evenColor: new Cesium.Color(0.25, 0.4, 0.1, 1),
                  oddColor: new Cesium.Color(0.1, 0.1, 0.1, 1),
                  frequency: 1.5
                  // 斑驳
                }), Bt = new mars3d.layer.GeoJsonLayer({
                  data: k,
                  vectorId: D,
                  // format: pointCount > 10000 ? this.simplifyFunc : null,
                  symbol: {
                    type: "polygon",
                    styleOptions: {
                      fill: _t,
                      diffHeight: G,
                      clampToGround: j,
                      materialType: U,
                      materialOptions: N,
                      distanceDisplayCondition: J,
                      distanceDisplayCondition_far: ct,
                      distanceDisplayCondition_near: K,
                      outlineStyle: Et,
                      outline: Pt,
                      classificationType: Ot,
                      label: et
                    }
                  }
                  // popup: `&nbsp;&nbsp; ${title} &nbsp;&nbsp;`,
                });
                break;
              case "Point":
              case "MultiPoint":
                Bt = new mars3d.layer.GeoJsonLayer({
                  data: k,
                  vectorId: D,
                  // format: pointCount > 10000 ? this.simplifyFunc : null,
                  symbol: {
                    type: "pointP",
                    styleOptions: {
                      color: At,
                      pixelSize: fe,
                      outline: Pt,
                      outlineColor: re,
                      outlineWidth: Ft,
                      visibleDepth: !1,
                      label: et
                    }
                  }
                });
                break;
            }
            m ? window.mapClone.mapEx.addLayer(Bt) : window.map.addLayer(Bt), Bt.bindPopup((ce) => {
              let Yt = '<div class="bim-map-popup">';
              return Object.keys(ce.graphic.attr).forEach(($e, Li) => {
                ce.graphic.attr[$e] && (Yt += `<p><b>${$e}</b> : ${ce.graphic.attr[$e]}</p>`);
              }), Yt += "</div>", Yt;
            });
            let ke = Uc.debounce((ce) => {
              window.dynamicMasking.add(ce, JSON.parse(L));
            }, 500);
            Bt.readyPromise.then((ce) => {
              window.dynamicMasking && ke(ce), c(ce);
            }).catch((ce) => {
              console.error("测试shp矢量加载失败", ce), c({
                tite: "【矢量】「" + F + "」无法加载",
                type: "error",
                id: D,
                url: _
              });
            });
          } else
            c({
              tite: "【矢量】「" + F + "」无法加载",
              type: "error",
              id: D,
              url: _
            });
        }).catch((k) => {
          console.error("数据有误", k), c({
            tite: "【矢量】「" + C + "」链接地址有误",
            type: "error",
            id: S,
            url: _
          });
        });
      } else
        c({
          tite: "【矢量】ID:「" + a + "」已删除",
          type: "error",
          id: a
        });
    });
  }
  /**
   * 更新 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData(a) {
    this.vectorArr = a;
  }
  /**
   * 处理kml数据
   * @param  { Object } item 查询出来的对象
   * @returns { Object } 样式对象
   */
  processingKML(a) {
    let s, c = 2e3, d = !0, { kmlInfo: u } = a, {
      fill: m,
      areaColor: g,
      areaSideColor: _,
      transparency: S,
      isAreaSideColor: C,
      minDistinct: O,
      textDistinct: k,
      textSize: D,
      textColor: F,
      fontStyle: E,
      outLine: L,
      sideColor: T,
      backGround: M,
      backGroundColor: R,
      clampToGround: b
    } = u, U = {
      fill: m,
      color: g,
      opacity: S || 0.5,
      outline: C,
      outlineColor: _,
      outlineWidth: 2,
      clampToGround: b,
      // distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1000000),
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: k || 1e6,
      distanceDisplayCondition_near: O || 0,
      classificationType: s,
      opacity: String(S)
    }, N = {
      text: "{name}",
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      pixelOffsetY: -10,
      font_size: 26,
      color: F || "#ffffff",
      font_family: E || "黑体",
      outline: L || !0,
      outlineColor: T || "#000000",
      outlineWidth: 4,
      scaleByDistance: !0,
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: k || 1e6,
      distanceDisplayCondition_near: O || 0,
      background: M || !1,
      backgroundColor: R || "",
      visibleDepth: d,
      clampToGround: b || !1,
      disableDepthTestDistance: c
    };
    return {
      ...U,
      label: N
    };
  }
  /**
   * 选中矢量
   * @param  { String } id 模型id
   *
   */
  selected(a) {
    window.map.getLayer(a, "vectorId") && window.map.getLayer(a, "vectorId").flyTo();
  }
  /**
   * 查询矢量数据的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(a) {
    return this.vectorArr.length == 0 ? !1 : this.vectorArr.find((s) => s.id == a);
  }
  /**
   * 查询矢量实体的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  queryVector(a) {
    return window.map.getLayer(a, "vectorId");
  }
  /**
   * 批量编辑矢量
   * @param  { String } id 对象id
   * @param  { Object } vector 矢量对象
   * @param  { Object } label  注记对象
   * @returns { Object }
   */
  editVector(a, s, c) {
    let d = window.map.getLayer(a, "vectorId"), u = Up(s, c);
    d && (d.eachGraphic((m) => {
      m.label.show === !1 && (delete m.label.outline, delete m.label.background, delete m.label.outlineColor, delete m.label.backgroundColor), m.setStyle({
        ...u
      });
    }), window.dynamicMasking && dynamicMasking.modify(a, u));
  }
  /**
   * 加载国家边界线
   *
   * @returns { any }
   */
  nationalBoundaries(a = "/gis/nationalBoundaries.json") {
    let s = new mars3d.layer.GeoJsonLayer({
      name: "国界",
      url: a,
      vectorId: "border",
      format: (c) => {
        try {
          c = turf.simplify(c, {
            tolerance: 1e-5,
            highQuality: !1,
            mutate: !0
          });
        } catch (d) {
          console.error(d);
        }
        return c;
      },
      symbol: {
        type: "polylineC",
        styleOptions: {
          width: 2,
          materialType: "Color",
          materialOptions: {
            color: "#CD9B1D"
          },
          distanceDisplayCondition: !0,
          distanceDisplayCondition_near: 1e3,
          distanceDisplayCondition_far: 2e7,
          clampToGround: !0,
          classificationType: Cesium.ClassificationType.TERRAIN
        }
      }
    });
    map.addLayer(s);
  }
  /**
   * 切换动态避让
   * @returns { any }
   */
  switchDynamicMasking(a) {
    this.isDynamicMasking = a;
  }
}
class _1 {
  constructor(a = []) {
    mars3d ? (this.terrainProviderArr = a, this.terrainProviderId = "", this.events = {}, window.map.on(mars3d.EventType.terrainLoadError, (s) => {
      console.error("地形服务加载失败", s), this.hide();
    }), window.map.viewer.scene.globe.tileLoadProgressEvent.addEventListener(
      (s) => {
        window.map.viewer.scene.globe.tilesLoaded && this.emit("load", s);
      }
    )) : console.error("未引入指定插件");
  }
  /**
   * add 添加地形
   * @param  { Object || String } terrainProviderParameter 地形属性 或者 地形id
   */
  add(a) {
    let { url: s, id: c } = a;
    if (this.terrainProviderId == c && window.map.terrainProvider._layers)
      return !1;
    window.map.terrainProvider = mars3d.LayerUtil.createTerrainProvider({
      imageXyzId: c,
      type: "xyz",
      url: s,
      //item.gisInfo.gisUrl,
      requestVertexNormals: !0,
      requestMetadata: !0
    }), this.terrainProviderId = c;
  }
  /**
   * 开启地形
   *
   */
  show() {
    window.map.hasTerrain = !0;
  }
  /**
   * 隐藏地形
   *
   */
  hide() {
    window.map.hasTerrain = !1;
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(a, s) {
    a == "load" ? this.events[a] ? this.events[a].push(s) : this.events[a] = [s] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(a, ...s) {
    this.events[a] != null && this.events[a].forEach((c) => c(...s));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(a, s) {
    this.events[a] = this.events[a].filter((c) => c !== s);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(a, s) {
    const c = () => {
      s(), this.off(a, c);
    };
    this.on(a, c);
  }
  /**
   * 地形裁剪
   */
  addClip(a) {
    return new Promise((s, c) => {
      window.bimClip ? s(bimClip.clipGisAdd(a)) : c("挖洞工具未初始化");
    });
  }
}
class x1 {
  constructor(a = [], s) {
    mars3d ? (this.elevationImageArr = a, this.elevationImageLayer, s ? this.gisTkone = {
      Authorization: `Bearer ${s}`
    } : this.gisTkone = {}, this.form = {
      brightnessVal: 1.3,
      //环境亮度配置
      msaaSamples: 4,
      //反锯齿配置
      surfaceOpacity: 1,
      //地表不透明度
      layerOpacity: 1,
      //瓦片透明度
      layerBrightness: 2,
      //瓦片亮度
      layerContrast: 1,
      //瓦片对比度
      layerHue: 0,
      //瓦片色彩
      layerSaturation: 1,
      //瓦片饱和度
      layerGamma: 1
      //瓦片伽马值
    }, this.tdtLayer = null) : console.error("未引入指定插件");
  }
  /**
   * 给影像数组添加数据
   * @param  { Object } data 集合数据
   */
  pushVector(a) {
    this.elevationImageArr.push(a);
  }
  /**
   * 添加影像
   * @param  { Object || String } xyzParameter 影像属性 或者 影像id
   * @param  { Object || String } isGisTkone
   * @param  { Object } fn 监听函数
   *
   */
  add(a, s = !0, c) {
    let d;
    if (typeof a != "object" ? d = a : d = a.imageXyzId, window.map.getLayer(d, "imageXyzId"))
      return !1;
    const {
      layerOpacity: u,
      layerBrightness: m,
      layerContrast: g,
      layerHue: _,
      layerSaturation: S,
      layerGamma: C,
      surfaceOpacity: O
    } = this.exposureEnvironmentSettings();
    return new Promise((k, D) => {
      let F, E, L, T, M, R;
      if (typeof a != "object") {
        let b = this.query(a);
        b || D("缺少树结构");
        let { gisInfo: U } = b;
        F = U.id, L = U.order, E = b.url, T = U.minLevel, M = U.maxLevel;
      } else
        F = a.imageXyzId, E = a.url, L = a.zIndex, T = a.minimumLevel, M = a.maximumLevel, R = a.chinaCRS;
      this.elevationImageLayer = new mars3d.layer.XyzLayer({
        imageXyzId: F,
        type: "xyz",
        url: E,
        //item.gisUrl,
        hasZIndex: !0,
        //是否可以调整图层顺序（在同类型图层间）
        zIndex: L.toString(),
        //图层顺序，数字大的在上面。（当hasZIndex为true时）
        brightness: m,
        //亮度0.0-1.0。
        opacity: u,
        saturation: S,
        contrast: g,
        hue: _,
        gamma: C,
        alpha: O,
        show: !0,
        minimumLevel: T || 0,
        maximumLevel: M || 15,
        chinaCRS: R,
        // queryParameters: { token: "zhang" },
        headers: s ? this.gisTkone : null
      }), this.elevationImageLayer.on(mars3d.EventType.load, (b) => {
        k(b);
      }), window.map.addLayer(this.elevationImageLayer), c && Object.keys(c).forEach((b) => {
        this.elevationImageLayer.on(fnType.get(b), (U) => {
          c[b](U);
        });
      });
    });
  }
  // /**
  //  * 三方注记
  //  * @param  { Object || String } xyzParameter 影像属性 或者 影像id
  //  * @param  { Object || String } isGisTkone
  //  * @param  { Object } fn 监听函数
  //  *
  //  */
  // addTdt() {
  //   if (this.tdtLayer == null) {
  //   }
  // }
  /**
   * 移除影像方法
   * @param  { String } id 影像id
   *
   */
  remove(a) {
    console.log(a), window.map.removeLayer(window.map.getLayer(a, "imageXyzId"));
  }
  /**
   * 查询影像方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的对象 或者 false
   */
  query(a) {
    return this.elevationImageArr.length == 0 ? !1 : this.elevationImageArr.find((s) => s.id == a);
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.elevationImageArr = [], this.elevationImageLayer = null;
  }
  /**
   *
   * 是否读取本地化数据 来初始化地球
   * @returns { any }
   */
  exposureEnvironmentSettings() {
    return localStorage.getItem("environmentSettings") ? JSON.parse(localStorage.getItem("environmentSettings")) : (localStorage.setItem("environmentSettings", JSON.stringify(this.form)), JSON.parse(JSON.stringify(this.form)));
  }
}
class w1 {
  constructor(a, ...s) {
    /**
     * 手动释放 1秒防抖
     * @param  { object } data - 模型的树形结构
     * @returns { any }
     */
    vl(this, "manualFreed", Uc.debounce(() => {
      let { lng: a, lat: s, alt: c, pitch: d } = window.map.getCameraView(), u;
      this.modelArray.forEach((m) => {
        u = m.releasedDistance ? m.releasedDistance : 1e4, this.disTance(
          [a, s, c],
          [m.center._lng, m.center._lat, m.center._alt],
          this.calculateDistance(d, u)
        ) ? window.map.getLayer(m.id, "modelId") && this.emit("leave", m) : window.map.getLayer(m.id, "modelId") || this.emit("enter", m);
      });
    }, 200));
    mars3d ? (a && a != null && (this.modelArray = a), this.showModelArray = [], this.Cesium = mars3d.Cesium, this.events = {}) : console.error("未引入指定插件");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(a, s) {
    a == "enter" || a == "leave" ? this.events[a] ? this.events[a].push(s) : this.events[a] = [s] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(a, ...s) {
    this.events[a] != null && this.events[a].forEach((c) => c(...s));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(a, s) {
    this.events[a] = this.events[a].filter((c) => c !== s);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(a, s) {
    const c = () => {
      s(), this.off(a, c);
    };
    this.on(a, c);
  }
  /**
   * modelArray
   * 读取数据
   * @param  { string | number } key - 需要查询对象的key 目前只有 modelArray 和 showModelIdArray
   * @returns { any }
   */
  say(a) {
    return this[a];
  }
  /**
   * modelArray
   * 添加数据
   * @param  { string | number } key - 需要添加对象的key 目前只有 modelArray 和 showModelArray
   * @param  { object | array } item - 添加的数据item
   * @returns { any }
   */
  add(a, s) {
    this[a].push(s);
  }
  /**
   * modelArray
   * 移除数据
   * @param  { string | number } key - 需要添加对象的key 目前只有 showModelArray
   * @param  { object | array } item - 添加的数据item
   * @returns { any }
   */
  remove(a, s) {
    this[a] = this[a].filter(function(c) {
      return c !== s;
    });
  }
  /**
   * modelArray && events
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArray = [], this.events = {};
  }
  /**
   * 工具函数
   * modelArray - excavationDetails
   * 更新 modelArray 自定义属性 excavationDetails
   * @param  { string } parentId - 模型id
   * @param  { string } id - 自己实例的id
   * @param  { string } type - update | delete | add | edit 操作类型
   * @param  { object | array } data - 更新的数据
   * @returns { object }
   */
  updateCustomExcavationDetails(a, s, c, d = [], u = {}) {
    let m, g, _;
    switch (m = this.modelArray.find((S) => S.modelId == a).customize.bimModelExcavationDetails, _ = m.find((S, C) => {
      if (S.id == s)
        return g = C, S;
    }), c) {
      case "delete":
        m.splice(g, 1);
        break;
      case "update":
        _.excavationDetails = d;
        break;
      case "add":
        m.push(u);
        break;
      case "edit":
        _.excavationDetails = u.excavationDetails, _.kId = u.kId;
        break;
    }
    return m;
  }
  /**
   * 工具函数
   * 开启视角监听事件 调用freed来实现动态释放逻辑
   * @param  { object } data - 模型的树形结构 重要数据
   * @returns { any }
   */
  resourceRelease() {
    window.map.viewer.camera.moveEnd.addEventListener(() => {
      this.freed();
    });
  }
  /**
   * 功能函数
   * 动态释放的主要逻辑
   * @param  { object } data - 模型的树形结构
   * @returns { any }
   */
  freed() {
    let { alt: a } = window.map.getCameraView();
    a < 2e4 && (this.freed = Uc.throttle(() => {
      let { lng: s, lat: c, alt: d, pitch: u } = window.map.getCameraView();
      this.modelArray && this.modelArray.forEach((m) => {
        let g = m.bimModel.releasedDistance ? m.bimModel.releasedDistance : 1e4;
        m.center && this.disTance(
          [s, c, d],
          [m.center._lng, m.center._lat, m.center._alt],
          this.calculateDistance(u, g)
        ) ? window.map.getLayer(m.id, "modelId") && this.emit("leave", m) : this.showModelArray.indexOf(m.id) >= 0 && !window.map.getLayer(m.id, "modelId") && this.emit("enter", m);
      });
    }, 2e3), this.freed());
  }
  /**
   * 通过id查询对象
   * @param  { object } data - 模型的树形结构
   * @param  { string } id - 模型id
   * @param  { string } type - 查找类型
   * @returns { boolean }
   */
  findPnodeId(a, s, c = "id") {
    let d;
    if (a) {
      for (var u = 0; u < a.length; u++) {
        let m = a[u];
        if (m[c] == s)
          return d = m, d;
        if (m.children && m.children.length > 0 && (d = this.findPnodeId(m.children, s, c), d))
          return d;
      }
      return d;
    }
  }
  /**
   * modelArray
   * 动态释放的计算方法
   * @param  { array } positionsStart - 起始坐标
   * @param  { array } positionsEnd - 结束坐标
   * @param  { number } limit - 设置的长度
   * @returns { boolean }
   */
  disTance(a, s, c) {
    let d, u, m;
    return d = Cesium.Cartesian3.fromDegrees(...a), u = Cesium.Cartesian3.fromDegrees(...s), m = Cesium.Cartesian3.distance(d, u), m > c;
  }
  /**
   * @function 获取模型的可视范围
   * @param { number } angle 当前角度
   * @param { number } maxDistance 最大可视距离
   * @returns { number } 当前可视距离
   * */
  calculateDistance(a, s) {
    let c = (a + 180) % 360 - 180;
    c = Math.max(-90, Math.min(c, 90));
    let d = (s - s / 5) * (Math.abs(c) / 90) + s / 5;
    return Math.round(d);
  }
}
class T1 {
  constructor(a = [], s) {
    mars3d ? (this.entityArr = a, this.entityLayer = new mars3d.layer.GraphicLayer({
      entityId: "bimEntity"
    }), window.map.addLayer(this.entityLayer), this.entityItem = null, this.events = {}, this.entityCloneLayer) : console.error("未引入指定插件");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持change和collection
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(a, s) {
    a == "change" || a == "collection" || a == "collection" ? this.events[a] ? this.events[a].push(s) : this.events[a] = [s] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(a, ...s) {
    this.events[a] != null && this.events[a].forEach((c) => c(...s));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(a, s) {
    this.events[a] = this.events[a].filter((c) => c !== s);
  }
  /**
   * events
   * 事件移除所有
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  offAll() {
    this.events = {};
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(a, s) {
    const c = () => {
      s(), this.off(a, c);
    };
    this.on(a, c);
  }
  /**
   * 添加标绘实例
   * @param  { String } modelParameter 标绘实例id 或者 标绘参数
   *
   */
  add(a, s = null, c) {
    return new Promise((d, u) => {
      var m;
      if (this.entityLayer) {
        let g, _, S;
        if (c == null ? void 0 : c.isClone)
          this.entityCloneLayer && (_ = this.query(a), _ ? (S = JSON.parse(_.bimPlanPainting.graphic), S.attr = S.attr || {}, S.attr.entityId = a, this.entityCloneLayer.addGraphic(S)) : d({
            tite: "【标绘】 ID:「" + a + "」已删除",
            type: "error",
            id: a
          }));
        else {
          if (typeof a != "object" ? (g = this.entityLayer.getGraphicByAttr(
            a,
            "entityId"
          ), _ = this.query(a), _ ? (S = JSON.parse(_.bimPlanPainting.graphic), S.attr = S.attr || {}, S.attr.entityId = a) : d({
            tite: "【标绘】ID:「" + a + "」已删除",
            type: "error",
            id: a
          })) : (g = this.entityLayer.getGraphicByAttr(
            a.id,
            "entityId"
          ), S = JSON.parse(JSON.stringify(a)), S.attr = S.attr || {}, S.attr.entityId = S.attr.entityId || s, S.attr == null ? S.attr = {
            entityId: a.id
          } : ((m = S.attr) == null ? void 0 : m.entityId) == null && s && (S.attr.entityId = s)), g)
            return d();
          this.entityLayer.addGraphic(S), d(S);
        }
      } else
        d(), console.error("未初始化标绘实例图层");
    });
  }
  /**
   * 查询标绘数据的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(a) {
    return this.entityArr.length == 0 ? !1 : this.entityArr.find((s) => s.id == a);
  }
  /**
   * 查询矢量数据的实体
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 返回标绘实体
   */
  queryEntity(a) {
    if (bimEntity.entityLayer)
      return bimEntity.entityLayer.getGraphicByAttr(a, "entityId");
  }
  /**
   * 选中标绘
   * @param  { String } id 模型id
   *
   */
  selected(a, s = null) {
    let c = this.entityLayer.getGraphicByAttr(a, "entityId");
    s == null || s.isClone, (c.options.type == "div" || c.options.type == "point") && c._point ? c.flyTo({
      radius: c._point._alt + 500 < 500 ? 5e3 : c._point._alt + 500
    }) : c.flyTo();
  }
  /**
   * 移除标绘
   * @param  { String } id 模型id
   *
   */
  remove(a, s = null) {
    (s == null ? void 0 : s.isClone) ? this.entityCloneLayer && this.entityCloneLayer.getGraphicByAttr(a, "entityId").remove() : this.entityLayer.getGraphicByAttr(a, "entityId") && (this.entityLayer.getGraphicByAttr(a, "entityId").remove(), this.entityItem && (this.entityItem._state == "destroy" || this.entityItem.options.attr.entityId == a) && (this.entityItem = null));
  }
  entityCloneLayerInit() {
    (this.entityCloneLayer == null || this.entityCloneLayer.state == "destroy") && (this.entityCloneLayer = window.mapClone._mapEx.getLayer(
      "bimEntity",
      "entityId"
    ));
  }
  /**
   * 移除克隆场景的标绘
   *
   */
  entityCloneLayerRemove() {
    this.entityCloneLayer.remove(), this.entityCloneLayer = null;
  }
  /**
   * 移除当前标绘对象
   * @param  { String } id 模型id
   *
   */
  removeEntityItem() {
    this.entityItem = null;
  }
  /**
   * 更新 矢量数据集合
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData(a) {
    this.entityArr = a;
  }
  /**
   * 开始绘制标绘
   * @param  { Object } data 标绘参数
   *
   */
  startDrawGraphic(a) {
    return new Promise((s, c) => {
      let { type: d, style: u } = a;
      if (a.style.drawShow = !0, d == "div")
        if (u.html)
          this.entityLayer.startDraw(a).then((m) => {
            setTimeout(() => {
              this.entityItem = m, this.entityLayer.startEditing(m);
            }, 500);
          });
        else {
          let {
            title: m,
            divType: g,
            theme_color: _,
            font_color: S,
            scaleByDistance: C,
            scaleByDistance_far: O,
            scaleByDistance_farValue: k,
            scaleByDistance_near: D,
            scaleByDistance_nearValue: F,
            distanceDisplayCondition: E,
            distanceDisplayCondition_far: L,
            distanceDisplayCondition_near: T,
            clampToGround: M
          } = u, R = {
            type: "div",
            style: {
              pointerEvents: !0,
              scaleByDistance: C,
              scaleByDistance_far: O,
              scaleByDistance_farValue: k,
              scaleByDistance_near: D,
              scaleByDistance_nearValue: F,
              distanceDisplayCondition: E,
              distanceDisplayCondition_far: L,
              distanceDisplayCondition_near: T,
              clampToGround: M,
              horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM
            }
          };
          switch (g) {
            case "1":
              R.style.html = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${_};--theme-font-color1:${S};">
            <div class="title">${m}</div>
          </div>`, R.style.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
              break;
          }
          this.entityLayer.startDraw(R).then((b) => {
            setTimeout(() => {
              this.entityItem = b, this.entityLayer.startEditing(b), s(b);
            }, 500);
          });
        }
      else
        this.entityLayer.startDraw(a).then((m) => {
          setTimeout(() => {
            this.entityItem = m, this.entityLayer.startEditing(m), s(m);
          }, 500);
        });
    });
  }
  /**
   * 停止绘制标绘
   *
   */
  stopDraw(a = !0) {
    this.entityLayer && this.entityLayer.stopDraw(), a && this.entityItem && (this.entityItem.stopEditing(), this.entityItem.remove(), this.entityItem = null);
  }
  /**
   * 更新标绘
   * @param  { Object } data 标绘参数
   *
   */
  updateEntityItem(a) {
    let s = this.entityLayer.getGraphicByAttr(a, "entityId");
    s ? this.entityItem = s : this.removeEntityItem();
  }
  /**
   * 编辑标绘
   * @param  { String | Number } id 标绘id或者是edit新建标绘
   * @param  { Object } vector 标绘主体
   * @param  { Object } label 标绘label
   * @param  { String } 自定义类型 目前有div
   */
  edit(a, s, c, d) {
    let u = Up(s, c);
    if (s.vectorStyle && this.entityItem)
      if (s.vectorStyle.divType == 5)
        this.entityItem.setStyle({
          ...u,
          horizontalOrigin: Cesium.HorizontalOrigin.LEFT
        });
      else {
        if (this.entityItem.type == "circleP" && Object.keys(u).length == 1 && Object.keys(u)[0] == "radius" && u.radius == this.entityItem.options.style.radius)
          return !1;
        this.entityItem.setStyle({
          ...u,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER
        });
      }
  }
  /**
   * 开启拖动/关闭拖动
   * @param  { Boolean } isEnableDragging 是否开启
   */
  enableDragging(a = !0) {
    a ? this.entityLayer.startEditing(this.entityItem) : (this.entityLayer.stopDraw(), this.entityItem && this.entityItem.stopEditing());
  }
  /**
   * 添加右键菜单
   *
   */
  addRightMenu() {
    this.entityLayer.bindContextMenu([
      {
        text: "编辑对象",
        callback: (a) => {
          this.emit("change", a);
        }
      },
      {
        text: "收藏对象",
        callback: (a) => {
          this.emit("collection", a);
        }
      }
    ]);
  }
  /**
   * 移除右键菜单
   *
   */
  removeRightMenu() {
    this.entityLayer.hasContextMenu() && this.entityLayer.unbindContextMenu();
  }
  /**
   * 解耦div数据
   * @param  { String } htmlString HTML字符串
   * @returns { Object } 返回的是表单数据
   */
  processDivData(a) {
    let s = {
      "--theme-color1": "theme_color",
      "--theme-font-color1": "font_color",
      "--theme-color2": "theme_color2",
      "--theme-color3": "theme_color3"
    }, c = {
      title: "",
      theme_color: "",
      font_color: "",
      content: "",
      divType: "",
      divStyle: {},
      isMirror: !1
    };
    const d = document.createElement("div");
    d.innerHTML = a;
    const u = d.querySelector(".entity-div-style");
    return console.log("解耦", u), Object.keys(s).forEach((m) => {
      m == "--theme-color2" || m == "--theme-color3" ? c.divStyle[s[m]] = u.style.getPropertyValue(m) || "#fff" : c[s[m]] = u.style.getPropertyValue(m);
    }), c.title = u.querySelector(".title") ? u.querySelector(".title").innerText : "标题", c.content = u.querySelector(".content") ? u.querySelector(".content").innerText : "内容", c.divType = u.classList[1] ? u.classList[1].replace("entity-div-style", "") : "", c.isMirror = u.classList.contains("isMirror"), console.log("解耦", c), c;
  }
  /**
   * 更新html数据
   * @param  { String } divType 类型
   * @param  { Object } list 配合类型的样式参数
   * @returns { Object } html 字符串
   */
  updateHtml(a, s) {
    let { theme_color: c, font_color: d, title: u, content: m, divStyle: g } = s, { theme_color2: _, theme_color3: S } = g, C = "";
    switch (a) {
      case "1":
        C = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${c};--theme-font-color1:${d};">
            <div class="title">${u}</div>
          </div>`;
        break;
      case "2":
        C = `<div class="entity-div-style entity-div-style2" style="--theme-color1:${c};--theme-font-color1:${d};">
            <div class="title">${u}</div>
            <div class="mars3d-divUpLabel-line"></div>
          </div>`;
        break;
      case "3":
        C = `<div class="entity-div-style entity-div-style3" style="--theme-color1:${c};--theme-font-color1:${d};--theme-color2:${_};--theme-color3:${S}">
            <div class="image"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="infotop"><div class="title">${u}</div><div class="content overflow-auto scrollbar h-full">${m}</div></div>
          </div >`;
        break;
      case "4":
        C = `<div class="entity-div-style entity-div-style4" style="--theme-color1:${c};--theme-font-color1:${d};">
            <div class="entity-title"><span class="title">${u}</span></div>
            <div class="circular"></div>
          </div >`;
        break;
      case "5":
        C = `<div class="entity-div-style entity-div-style5 marsTiltPanel marsTiltPanel-theme-green" style="--theme-color1:${c};--theme-font-color1:${d};--theme-color2:${_};">
            <div class="marsTiltPanel-wrap">
              <div class="area">
                <div class="arrow-lt"></div>
                <div class="b-t"></div>
                <div class="b-r"></div>
                <div class="b-b"></div>
                <div class="b-l"></div>
                <div class="arrow-rb"></div>
                <div class="label-wrap">
                  <div class="title">${u}</div>
                  <div class="content">${m}</div>
                </div>
              </div>
              <div class="b-t-l"></div>
              <div class="b-b-r"></div>
            </div>
            <div class="arrow"></div>
          </div >`;
        break;
      case "6":
        C = `<div class="entity-div-style entity-div-style6" style="--theme-color1:${c};--theme-font-color1:${d};--theme-color2:${_};">
            <div class="title">${u}</div>
          </div >`;
        break;
      case "7":
        C = `<div class="entity-div-style entity-div-style7" style="--theme-color1:${c};--theme-font-color1:${d};">
            <div class="title">${u}</div>
            <div class="pile-number">
              <div class="circular"></div>
              <div class="pole"></div>
            </div>
          </div >`;
        break;
    }
    return C;
  }
}
function zu(x) {
  throw new Error('Could not dynamically require "' + x + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Gp = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(x, a) {
  (function(s) {
    x.exports = s();
  })(function() {
    return function s(c, d, u) {
      function m(S, C) {
        if (!d[S]) {
          if (!c[S]) {
            var O = typeof zu == "function" && zu;
            if (!C && O)
              return O(S, !0);
            if (g)
              return g(S, !0);
            var k = new Error("Cannot find module '" + S + "'");
            throw k.code = "MODULE_NOT_FOUND", k;
          }
          var D = d[S] = { exports: {} };
          c[S][0].call(D.exports, function(F) {
            var E = c[S][1][F];
            return m(E || F);
          }, D, D.exports, s, c, d, u);
        }
        return d[S].exports;
      }
      for (var g = typeof zu == "function" && zu, _ = 0; _ < u.length; _++)
        m(u[_]);
      return m;
    }({ 1: [function(s, c, d) {
      var u = s("./utils"), m = s("./support"), g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      d.encode = function(_) {
        for (var S, C, O, k, D, F, E, L = [], T = 0, M = _.length, R = M, b = u.getTypeOf(_) !== "string"; T < _.length; )
          R = M - T, O = b ? (S = _[T++], C = T < M ? _[T++] : 0, T < M ? _[T++] : 0) : (S = _.charCodeAt(T++), C = T < M ? _.charCodeAt(T++) : 0, T < M ? _.charCodeAt(T++) : 0), k = S >> 2, D = (3 & S) << 4 | C >> 4, F = 1 < R ? (15 & C) << 2 | O >> 6 : 64, E = 2 < R ? 63 & O : 64, L.push(g.charAt(k) + g.charAt(D) + g.charAt(F) + g.charAt(E));
        return L.join("");
      }, d.decode = function(_) {
        var S, C, O, k, D, F, E = 0, L = 0, T = "data:";
        if (_.substr(0, T.length) === T)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var M, R = 3 * (_ = _.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (_.charAt(_.length - 1) === g.charAt(64) && R--, _.charAt(_.length - 2) === g.charAt(64) && R--, R % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (M = m.uint8array ? new Uint8Array(0 | R) : new Array(0 | R); E < _.length; )
          S = g.indexOf(_.charAt(E++)) << 2 | (k = g.indexOf(_.charAt(E++))) >> 4, C = (15 & k) << 4 | (D = g.indexOf(_.charAt(E++))) >> 2, O = (3 & D) << 6 | (F = g.indexOf(_.charAt(E++))), M[L++] = S, D !== 64 && (M[L++] = C), F !== 64 && (M[L++] = O);
        return M;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(s, c, d) {
      var u = s("./external"), m = s("./stream/DataWorker"), g = s("./stream/Crc32Probe"), _ = s("./stream/DataLengthProbe");
      function S(C, O, k, D, F) {
        this.compressedSize = C, this.uncompressedSize = O, this.crc32 = k, this.compression = D, this.compressedContent = F;
      }
      S.prototype = { getContentWorker: function() {
        var C = new m(u.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new _("data_length")), O = this;
        return C.on("end", function() {
          if (this.streamInfo.data_length !== O.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), C;
      }, getCompressedWorker: function() {
        return new m(u.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, S.createWorkerFrom = function(C, O, k) {
        return C.pipe(new g()).pipe(new _("uncompressedSize")).pipe(O.compressWorker(k)).pipe(new _("compressedSize")).withStreamInfo("compression", O);
      }, c.exports = S;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(s, c, d) {
      var u = s("./stream/GenericWorker");
      d.STORE = { magic: "\0\0", compressWorker: function() {
        return new u("STORE compression");
      }, uncompressWorker: function() {
        return new u("STORE decompression");
      } }, d.DEFLATE = s("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(s, c, d) {
      var u = s("./utils"), m = function() {
        for (var g, _ = [], S = 0; S < 256; S++) {
          g = S;
          for (var C = 0; C < 8; C++)
            g = 1 & g ? 3988292384 ^ g >>> 1 : g >>> 1;
          _[S] = g;
        }
        return _;
      }();
      c.exports = function(g, _) {
        return g !== void 0 && g.length ? u.getTypeOf(g) !== "string" ? function(S, C, O, k) {
          var D = m, F = k + O;
          S ^= -1;
          for (var E = k; E < F; E++)
            S = S >>> 8 ^ D[255 & (S ^ C[E])];
          return -1 ^ S;
        }(0 | _, g, g.length, 0) : function(S, C, O, k) {
          var D = m, F = k + O;
          S ^= -1;
          for (var E = k; E < F; E++)
            S = S >>> 8 ^ D[255 & (S ^ C.charCodeAt(E))];
          return -1 ^ S;
        }(0 | _, g, g.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(s, c, d) {
      d.base64 = !1, d.binary = !1, d.dir = !1, d.createFolders = !0, d.date = null, d.compression = null, d.compressionOptions = null, d.comment = null, d.unixPermissions = null, d.dosPermissions = null;
    }, {}], 6: [function(s, c, d) {
      var u = null;
      u = typeof Promise < "u" ? Promise : s("lie"), c.exports = { Promise: u };
    }, { lie: 37 }], 7: [function(s, c, d) {
      var u = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", m = s("pako"), g = s("./utils"), _ = s("./stream/GenericWorker"), S = u ? "uint8array" : "array";
      function C(O, k) {
        _.call(this, "FlateWorker/" + O), this._pako = null, this._pakoAction = O, this._pakoOptions = k, this.meta = {};
      }
      d.magic = "\b\0", g.inherits(C, _), C.prototype.processChunk = function(O) {
        this.meta = O.meta, this._pako === null && this._createPako(), this._pako.push(g.transformTo(S, O.data), !1);
      }, C.prototype.flush = function() {
        _.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, C.prototype.cleanUp = function() {
        _.prototype.cleanUp.call(this), this._pako = null;
      }, C.prototype._createPako = function() {
        this._pako = new m[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var O = this;
        this._pako.onData = function(k) {
          O.push({ data: k, meta: O.meta });
        };
      }, d.compressWorker = function(O) {
        return new C("Deflate", O);
      }, d.uncompressWorker = function() {
        return new C("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(s, c, d) {
      function u(D, F) {
        var E, L = "";
        for (E = 0; E < F; E++)
          L += String.fromCharCode(255 & D), D >>>= 8;
        return L;
      }
      function m(D, F, E, L, T, M) {
        var R, b, U = D.file, N = D.compression, j = M !== S.utf8encode, J = g.transformTo("string", M(U.name)), K = g.transformTo("string", S.utf8encode(U.name)), ct = U.comment, It = g.transformTo("string", M(ct)), et = g.transformTo("string", S.utf8encode(ct)), _t = K.length !== U.name.length, G = et.length !== ct.length, Pt = "", Et = "", At = "", fe = U.dir, re = U.date, Ft = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        F && !E || (Ft.crc32 = D.crc32, Ft.compressedSize = D.compressedSize, Ft.uncompressedSize = D.uncompressedSize);
        var Ot = 0;
        F && (Ot |= 8), j || !_t && !G || (Ot |= 2048);
        var Bt = 0, ke = 0;
        fe && (Bt |= 16), T === "UNIX" ? (ke = 798, Bt |= function(Yt, $e) {
          var Li = Yt;
          return Yt || (Li = $e ? 16893 : 33204), (65535 & Li) << 16;
        }(U.unixPermissions, fe)) : (ke = 20, Bt |= function(Yt) {
          return 63 & (Yt || 0);
        }(U.dosPermissions)), R = re.getUTCHours(), R <<= 6, R |= re.getUTCMinutes(), R <<= 5, R |= re.getUTCSeconds() / 2, b = re.getUTCFullYear() - 1980, b <<= 4, b |= re.getUTCMonth() + 1, b <<= 5, b |= re.getUTCDate(), _t && (Et = u(1, 1) + u(C(J), 4) + K, Pt += "up" + u(Et.length, 2) + Et), G && (At = u(1, 1) + u(C(It), 4) + et, Pt += "uc" + u(At.length, 2) + At);
        var ce = "";
        return ce += `
\0`, ce += u(Ot, 2), ce += N.magic, ce += u(R, 2), ce += u(b, 2), ce += u(Ft.crc32, 4), ce += u(Ft.compressedSize, 4), ce += u(Ft.uncompressedSize, 4), ce += u(J.length, 2), ce += u(Pt.length, 2), { fileRecord: O.LOCAL_FILE_HEADER + ce + J + Pt, dirRecord: O.CENTRAL_FILE_HEADER + u(ke, 2) + ce + u(It.length, 2) + "\0\0\0\0" + u(Bt, 4) + u(L, 4) + J + Pt + It };
      }
      var g = s("../utils"), _ = s("../stream/GenericWorker"), S = s("../utf8"), C = s("../crc32"), O = s("../signature");
      function k(D, F, E, L) {
        _.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = F, this.zipPlatform = E, this.encodeFileName = L, this.streamFiles = D, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      g.inherits(k, _), k.prototype.push = function(D) {
        var F = D.meta.percent || 0, E = this.entriesCount, L = this._sources.length;
        this.accumulate ? this.contentBuffer.push(D) : (this.bytesWritten += D.data.length, _.prototype.push.call(this, { data: D.data, meta: { currentFile: this.currentFile, percent: E ? (F + 100 * (E - L - 1)) / E : 100 } }));
      }, k.prototype.openedSource = function(D) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = D.file.name;
        var F = this.streamFiles && !D.file.dir;
        if (F) {
          var E = m(D, F, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: E.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, k.prototype.closedSource = function(D) {
        this.accumulate = !1;
        var F = this.streamFiles && !D.file.dir, E = m(D, F, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(E.dirRecord), F)
          this.push({ data: function(L) {
            return O.DATA_DESCRIPTOR + u(L.crc32, 4) + u(L.compressedSize, 4) + u(L.uncompressedSize, 4);
          }(D), meta: { percent: 100 } });
        else
          for (this.push({ data: E.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, k.prototype.flush = function() {
        for (var D = this.bytesWritten, F = 0; F < this.dirRecords.length; F++)
          this.push({ data: this.dirRecords[F], meta: { percent: 100 } });
        var E = this.bytesWritten - D, L = function(T, M, R, b, U) {
          var N = g.transformTo("string", U(b));
          return O.CENTRAL_DIRECTORY_END + "\0\0\0\0" + u(T, 2) + u(T, 2) + u(M, 4) + u(R, 4) + u(N.length, 2) + N;
        }(this.dirRecords.length, E, D, this.zipComment, this.encodeFileName);
        this.push({ data: L, meta: { percent: 100 } });
      }, k.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, k.prototype.registerPrevious = function(D) {
        this._sources.push(D);
        var F = this;
        return D.on("data", function(E) {
          F.processChunk(E);
        }), D.on("end", function() {
          F.closedSource(F.previous.streamInfo), F._sources.length ? F.prepareNextSource() : F.end();
        }), D.on("error", function(E) {
          F.error(E);
        }), this;
      }, k.prototype.resume = function() {
        return !!_.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, k.prototype.error = function(D) {
        var F = this._sources;
        if (!_.prototype.error.call(this, D))
          return !1;
        for (var E = 0; E < F.length; E++)
          try {
            F[E].error(D);
          } catch {
          }
        return !0;
      }, k.prototype.lock = function() {
        _.prototype.lock.call(this);
        for (var D = this._sources, F = 0; F < D.length; F++)
          D[F].lock();
      }, c.exports = k;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(s, c, d) {
      var u = s("../compressions"), m = s("./ZipFileWorker");
      d.generateWorker = function(g, _, S) {
        var C = new m(_.streamFiles, S, _.platform, _.encodeFileName), O = 0;
        try {
          g.forEach(function(k, D) {
            O++;
            var F = function(M, R) {
              var b = M || R, U = u[b];
              if (!U)
                throw new Error(b + " is not a valid compression method !");
              return U;
            }(D.options.compression, _.compression), E = D.options.compressionOptions || _.compressionOptions || {}, L = D.dir, T = D.date;
            D._compressWorker(F, E).withStreamInfo("file", { name: k, dir: L, date: T, comment: D.comment || "", unixPermissions: D.unixPermissions, dosPermissions: D.dosPermissions }).pipe(C);
          }), C.entriesCount = O;
        } catch (k) {
          C.error(k);
        }
        return C;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(s, c, d) {
      function u() {
        if (!(this instanceof u))
          return new u();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var m = new u();
          for (var g in this)
            typeof this[g] != "function" && (m[g] = this[g]);
          return m;
        };
      }
      (u.prototype = s("./object")).loadAsync = s("./load"), u.support = s("./support"), u.defaults = s("./defaults"), u.version = "3.10.1", u.loadAsync = function(m, g) {
        return new u().loadAsync(m, g);
      }, u.external = s("./external"), c.exports = u;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(s, c, d) {
      var u = s("./utils"), m = s("./external"), g = s("./utf8"), _ = s("./zipEntries"), S = s("./stream/Crc32Probe"), C = s("./nodejsUtils");
      function O(k) {
        return new m.Promise(function(D, F) {
          var E = k.decompressed.getContentWorker().pipe(new S());
          E.on("error", function(L) {
            F(L);
          }).on("end", function() {
            E.streamInfo.crc32 !== k.decompressed.crc32 ? F(new Error("Corrupted zip : CRC32 mismatch")) : D();
          }).resume();
        });
      }
      c.exports = function(k, D) {
        var F = this;
        return D = u.extend(D || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: g.utf8decode }), C.isNode && C.isStream(k) ? m.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", k, !0, D.optimizedBinaryString, D.base64).then(function(E) {
          var L = new _(D);
          return L.load(E), L;
        }).then(function(E) {
          var L = [m.Promise.resolve(E)], T = E.files;
          if (D.checkCRC32)
            for (var M = 0; M < T.length; M++)
              L.push(O(T[M]));
          return m.Promise.all(L);
        }).then(function(E) {
          for (var L = E.shift(), T = L.files, M = 0; M < T.length; M++) {
            var R = T[M], b = R.fileNameStr, U = u.resolve(R.fileNameStr);
            F.file(U, R.decompressed, { binary: !0, optimizedBinaryString: !0, date: R.date, dir: R.dir, comment: R.fileCommentStr.length ? R.fileCommentStr : null, unixPermissions: R.unixPermissions, dosPermissions: R.dosPermissions, createFolders: D.createFolders }), R.dir || (F.file(U).unsafeOriginalName = b);
          }
          return L.zipComment.length && (F.comment = L.zipComment), F;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(s, c, d) {
      var u = s("../utils"), m = s("../stream/GenericWorker");
      function g(_, S) {
        m.call(this, "Nodejs stream input adapter for " + _), this._upstreamEnded = !1, this._bindStream(S);
      }
      u.inherits(g, m), g.prototype._bindStream = function(_) {
        var S = this;
        (this._stream = _).pause(), _.on("data", function(C) {
          S.push({ data: C, meta: { percent: 0 } });
        }).on("error", function(C) {
          S.isPaused ? this.generatedError = C : S.error(C);
        }).on("end", function() {
          S.isPaused ? S._upstreamEnded = !0 : S.end();
        });
      }, g.prototype.pause = function() {
        return !!m.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, g.prototype.resume = function() {
        return !!m.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, c.exports = g;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(s, c, d) {
      var u = s("readable-stream").Readable;
      function m(g, _, S) {
        u.call(this, _), this._helper = g;
        var C = this;
        g.on("data", function(O, k) {
          C.push(O) || C._helper.pause(), S && S(k);
        }).on("error", function(O) {
          C.emit("error", O);
        }).on("end", function() {
          C.push(null);
        });
      }
      s("../utils").inherits(m, u), m.prototype._read = function() {
        this._helper.resume();
      }, c.exports = m;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(s, c, d) {
      c.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(u, m) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(u, m);
        if (typeof u == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(u, m);
      }, allocBuffer: function(u) {
        if (Buffer.alloc)
          return Buffer.alloc(u);
        var m = new Buffer(u);
        return m.fill(0), m;
      }, isBuffer: function(u) {
        return Buffer.isBuffer(u);
      }, isStream: function(u) {
        return u && typeof u.on == "function" && typeof u.pause == "function" && typeof u.resume == "function";
      } };
    }, {}], 15: [function(s, c, d) {
      function u(U, N, j) {
        var J, K = g.getTypeOf(N), ct = g.extend(j || {}, C);
        ct.date = ct.date || /* @__PURE__ */ new Date(), ct.compression !== null && (ct.compression = ct.compression.toUpperCase()), typeof ct.unixPermissions == "string" && (ct.unixPermissions = parseInt(ct.unixPermissions, 8)), ct.unixPermissions && 16384 & ct.unixPermissions && (ct.dir = !0), ct.dosPermissions && 16 & ct.dosPermissions && (ct.dir = !0), ct.dir && (U = T(U)), ct.createFolders && (J = L(U)) && M.call(this, J, !0);
        var It = K === "string" && ct.binary === !1 && ct.base64 === !1;
        j && j.binary !== void 0 || (ct.binary = !It), (N instanceof O && N.uncompressedSize === 0 || ct.dir || !N || N.length === 0) && (ct.base64 = !1, ct.binary = !0, N = "", ct.compression = "STORE", K = "string");
        var et = null;
        et = N instanceof O || N instanceof _ ? N : F.isNode && F.isStream(N) ? new E(U, N) : g.prepareContent(U, N, ct.binary, ct.optimizedBinaryString, ct.base64);
        var _t = new k(U, et, ct);
        this.files[U] = _t;
      }
      var m = s("./utf8"), g = s("./utils"), _ = s("./stream/GenericWorker"), S = s("./stream/StreamHelper"), C = s("./defaults"), O = s("./compressedObject"), k = s("./zipObject"), D = s("./generate"), F = s("./nodejsUtils"), E = s("./nodejs/NodejsStreamInputAdapter"), L = function(U) {
        U.slice(-1) === "/" && (U = U.substring(0, U.length - 1));
        var N = U.lastIndexOf("/");
        return 0 < N ? U.substring(0, N) : "";
      }, T = function(U) {
        return U.slice(-1) !== "/" && (U += "/"), U;
      }, M = function(U, N) {
        return N = N !== void 0 ? N : C.createFolders, U = T(U), this.files[U] || u.call(this, U, null, { dir: !0, createFolders: N }), this.files[U];
      };
      function R(U) {
        return Object.prototype.toString.call(U) === "[object RegExp]";
      }
      var b = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(U) {
        var N, j, J;
        for (N in this.files)
          J = this.files[N], (j = N.slice(this.root.length, N.length)) && N.slice(0, this.root.length) === this.root && U(j, J);
      }, filter: function(U) {
        var N = [];
        return this.forEach(function(j, J) {
          U(j, J) && N.push(J);
        }), N;
      }, file: function(U, N, j) {
        if (arguments.length !== 1)
          return U = this.root + U, u.call(this, U, N, j), this;
        if (R(U)) {
          var J = U;
          return this.filter(function(ct, It) {
            return !It.dir && J.test(ct);
          });
        }
        var K = this.files[this.root + U];
        return K && !K.dir ? K : null;
      }, folder: function(U) {
        if (!U)
          return this;
        if (R(U))
          return this.filter(function(K, ct) {
            return ct.dir && U.test(K);
          });
        var N = this.root + U, j = M.call(this, N), J = this.clone();
        return J.root = j.name, J;
      }, remove: function(U) {
        U = this.root + U;
        var N = this.files[U];
        if (N || (U.slice(-1) !== "/" && (U += "/"), N = this.files[U]), N && !N.dir)
          delete this.files[U];
        else
          for (var j = this.filter(function(K, ct) {
            return ct.name.slice(0, U.length) === U;
          }), J = 0; J < j.length; J++)
            delete this.files[j[J].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(U) {
        var N, j = {};
        try {
          if ((j = g.extend(U || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: m.utf8encode })).type = j.type.toLowerCase(), j.compression = j.compression.toUpperCase(), j.type === "binarystring" && (j.type = "string"), !j.type)
            throw new Error("No output type specified.");
          g.checkSupport(j.type), j.platform !== "darwin" && j.platform !== "freebsd" && j.platform !== "linux" && j.platform !== "sunos" || (j.platform = "UNIX"), j.platform === "win32" && (j.platform = "DOS");
          var J = j.comment || this.comment || "";
          N = D.generateWorker(this, j, J);
        } catch (K) {
          (N = new _("error")).error(K);
        }
        return new S(N, j.type || "string", j.mimeType);
      }, generateAsync: function(U, N) {
        return this.generateInternalStream(U).accumulate(N);
      }, generateNodeStream: function(U, N) {
        return (U = U || {}).type || (U.type = "nodebuffer"), this.generateInternalStream(U).toNodejsStream(N);
      } };
      c.exports = b;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(s, c, d) {
      c.exports = s("stream");
    }, { stream: void 0 }], 17: [function(s, c, d) {
      var u = s("./DataReader");
      function m(g) {
        u.call(this, g);
        for (var _ = 0; _ < this.data.length; _++)
          g[_] = 255 & g[_];
      }
      s("../utils").inherits(m, u), m.prototype.byteAt = function(g) {
        return this.data[this.zero + g];
      }, m.prototype.lastIndexOfSignature = function(g) {
        for (var _ = g.charCodeAt(0), S = g.charCodeAt(1), C = g.charCodeAt(2), O = g.charCodeAt(3), k = this.length - 4; 0 <= k; --k)
          if (this.data[k] === _ && this.data[k + 1] === S && this.data[k + 2] === C && this.data[k + 3] === O)
            return k - this.zero;
        return -1;
      }, m.prototype.readAndCheckSignature = function(g) {
        var _ = g.charCodeAt(0), S = g.charCodeAt(1), C = g.charCodeAt(2), O = g.charCodeAt(3), k = this.readData(4);
        return _ === k[0] && S === k[1] && C === k[2] && O === k[3];
      }, m.prototype.readData = function(g) {
        if (this.checkOffset(g), g === 0)
          return [];
        var _ = this.data.slice(this.zero + this.index, this.zero + this.index + g);
        return this.index += g, _;
      }, c.exports = m;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(s, c, d) {
      var u = s("../utils");
      function m(g) {
        this.data = g, this.length = g.length, this.index = 0, this.zero = 0;
      }
      m.prototype = { checkOffset: function(g) {
        this.checkIndex(this.index + g);
      }, checkIndex: function(g) {
        if (this.length < this.zero + g || g < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + g + "). Corrupted zip ?");
      }, setIndex: function(g) {
        this.checkIndex(g), this.index = g;
      }, skip: function(g) {
        this.setIndex(this.index + g);
      }, byteAt: function() {
      }, readInt: function(g) {
        var _, S = 0;
        for (this.checkOffset(g), _ = this.index + g - 1; _ >= this.index; _--)
          S = (S << 8) + this.byteAt(_);
        return this.index += g, S;
      }, readString: function(g) {
        return u.transformTo("string", this.readData(g));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var g = this.readInt(4);
        return new Date(Date.UTC(1980 + (g >> 25 & 127), (g >> 21 & 15) - 1, g >> 16 & 31, g >> 11 & 31, g >> 5 & 63, (31 & g) << 1));
      } }, c.exports = m;
    }, { "../utils": 32 }], 19: [function(s, c, d) {
      var u = s("./Uint8ArrayReader");
      function m(g) {
        u.call(this, g);
      }
      s("../utils").inherits(m, u), m.prototype.readData = function(g) {
        this.checkOffset(g);
        var _ = this.data.slice(this.zero + this.index, this.zero + this.index + g);
        return this.index += g, _;
      }, c.exports = m;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(s, c, d) {
      var u = s("./DataReader");
      function m(g) {
        u.call(this, g);
      }
      s("../utils").inherits(m, u), m.prototype.byteAt = function(g) {
        return this.data.charCodeAt(this.zero + g);
      }, m.prototype.lastIndexOfSignature = function(g) {
        return this.data.lastIndexOf(g) - this.zero;
      }, m.prototype.readAndCheckSignature = function(g) {
        return g === this.readData(4);
      }, m.prototype.readData = function(g) {
        this.checkOffset(g);
        var _ = this.data.slice(this.zero + this.index, this.zero + this.index + g);
        return this.index += g, _;
      }, c.exports = m;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(s, c, d) {
      var u = s("./ArrayReader");
      function m(g) {
        u.call(this, g);
      }
      s("../utils").inherits(m, u), m.prototype.readData = function(g) {
        if (this.checkOffset(g), g === 0)
          return new Uint8Array(0);
        var _ = this.data.subarray(this.zero + this.index, this.zero + this.index + g);
        return this.index += g, _;
      }, c.exports = m;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(s, c, d) {
      var u = s("../utils"), m = s("../support"), g = s("./ArrayReader"), _ = s("./StringReader"), S = s("./NodeBufferReader"), C = s("./Uint8ArrayReader");
      c.exports = function(O) {
        var k = u.getTypeOf(O);
        return u.checkSupport(k), k !== "string" || m.uint8array ? k === "nodebuffer" ? new S(O) : m.uint8array ? new C(u.transformTo("uint8array", O)) : new g(u.transformTo("array", O)) : new _(O);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(s, c, d) {
      d.LOCAL_FILE_HEADER = "PK", d.CENTRAL_FILE_HEADER = "PK", d.CENTRAL_DIRECTORY_END = "PK", d.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", d.ZIP64_CENTRAL_DIRECTORY_END = "PK", d.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(s, c, d) {
      var u = s("./GenericWorker"), m = s("../utils");
      function g(_) {
        u.call(this, "ConvertWorker to " + _), this.destType = _;
      }
      m.inherits(g, u), g.prototype.processChunk = function(_) {
        this.push({ data: m.transformTo(this.destType, _.data), meta: _.meta });
      }, c.exports = g;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(s, c, d) {
      var u = s("./GenericWorker"), m = s("../crc32");
      function g() {
        u.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      s("../utils").inherits(g, u), g.prototype.processChunk = function(_) {
        this.streamInfo.crc32 = m(_.data, this.streamInfo.crc32 || 0), this.push(_);
      }, c.exports = g;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(s, c, d) {
      var u = s("../utils"), m = s("./GenericWorker");
      function g(_) {
        m.call(this, "DataLengthProbe for " + _), this.propName = _, this.withStreamInfo(_, 0);
      }
      u.inherits(g, m), g.prototype.processChunk = function(_) {
        if (_) {
          var S = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = S + _.data.length;
        }
        m.prototype.processChunk.call(this, _);
      }, c.exports = g;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(s, c, d) {
      var u = s("../utils"), m = s("./GenericWorker");
      function g(_) {
        m.call(this, "DataWorker");
        var S = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, _.then(function(C) {
          S.dataIsReady = !0, S.data = C, S.max = C && C.length || 0, S.type = u.getTypeOf(C), S.isPaused || S._tickAndRepeat();
        }, function(C) {
          S.error(C);
        });
      }
      u.inherits(g, m), g.prototype.cleanUp = function() {
        m.prototype.cleanUp.call(this), this.data = null;
      }, g.prototype.resume = function() {
        return !!m.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, u.delay(this._tickAndRepeat, [], this)), !0);
      }, g.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (u.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, g.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var _ = null, S = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            _ = this.data.substring(this.index, S);
            break;
          case "uint8array":
            _ = this.data.subarray(this.index, S);
            break;
          case "array":
          case "nodebuffer":
            _ = this.data.slice(this.index, S);
        }
        return this.index = S, this.push({ data: _, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, c.exports = g;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(s, c, d) {
      function u(m) {
        this.name = m || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      u.prototype = { push: function(m) {
        this.emit("data", m);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (m) {
          this.emit("error", m);
        }
        return !0;
      }, error: function(m) {
        return !this.isFinished && (this.isPaused ? this.generatedError = m : (this.isFinished = !0, this.emit("error", m), this.previous && this.previous.error(m), this.cleanUp()), !0);
      }, on: function(m, g) {
        return this._listeners[m].push(g), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(m, g) {
        if (this._listeners[m])
          for (var _ = 0; _ < this._listeners[m].length; _++)
            this._listeners[m][_].call(this, g);
      }, pipe: function(m) {
        return m.registerPrevious(this);
      }, registerPrevious: function(m) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = m.streamInfo, this.mergeStreamInfo(), this.previous = m;
        var g = this;
        return m.on("data", function(_) {
          g.processChunk(_);
        }), m.on("end", function() {
          g.end();
        }), m.on("error", function(_) {
          g.error(_);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var m = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), m = !0), this.previous && this.previous.resume(), !m;
      }, flush: function() {
      }, processChunk: function(m) {
        this.push(m);
      }, withStreamInfo: function(m, g) {
        return this.extraStreamInfo[m] = g, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var m in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, m) && (this.streamInfo[m] = this.extraStreamInfo[m]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var m = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + m : m;
      } }, c.exports = u;
    }, {}], 29: [function(s, c, d) {
      var u = s("../utils"), m = s("./ConvertWorker"), g = s("./GenericWorker"), _ = s("../base64"), S = s("../support"), C = s("../external"), O = null;
      if (S.nodestream)
        try {
          O = s("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function k(F, E) {
        return new C.Promise(function(L, T) {
          var M = [], R = F._internalType, b = F._outputType, U = F._mimeType;
          F.on("data", function(N, j) {
            M.push(N), E && E(j);
          }).on("error", function(N) {
            M = [], T(N);
          }).on("end", function() {
            try {
              var N = function(j, J, K) {
                switch (j) {
                  case "blob":
                    return u.newBlob(u.transformTo("arraybuffer", J), K);
                  case "base64":
                    return _.encode(J);
                  default:
                    return u.transformTo(j, J);
                }
              }(b, function(j, J) {
                var K, ct = 0, It = null, et = 0;
                for (K = 0; K < J.length; K++)
                  et += J[K].length;
                switch (j) {
                  case "string":
                    return J.join("");
                  case "array":
                    return Array.prototype.concat.apply([], J);
                  case "uint8array":
                    for (It = new Uint8Array(et), K = 0; K < J.length; K++)
                      It.set(J[K], ct), ct += J[K].length;
                    return It;
                  case "nodebuffer":
                    return Buffer.concat(J);
                  default:
                    throw new Error("concat : unsupported type '" + j + "'");
                }
              }(R, M), U);
              L(N);
            } catch (j) {
              T(j);
            }
            M = [];
          }).resume();
        });
      }
      function D(F, E, L) {
        var T = E;
        switch (E) {
          case "blob":
          case "arraybuffer":
            T = "uint8array";
            break;
          case "base64":
            T = "string";
        }
        try {
          this._internalType = T, this._outputType = E, this._mimeType = L, u.checkSupport(T), this._worker = F.pipe(new m(T)), F.lock();
        } catch (M) {
          this._worker = new g("error"), this._worker.error(M);
        }
      }
      D.prototype = { accumulate: function(F) {
        return k(this, F);
      }, on: function(F, E) {
        var L = this;
        return F === "data" ? this._worker.on(F, function(T) {
          E.call(L, T.data, T.meta);
        }) : this._worker.on(F, function() {
          u.delay(E, arguments, L);
        }), this;
      }, resume: function() {
        return u.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(F) {
        if (u.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new O(this, { objectMode: this._outputType !== "nodebuffer" }, F);
      } }, c.exports = D;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(s, c, d) {
      if (d.base64 = !0, d.array = !0, d.string = !0, d.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", d.nodebuffer = typeof Buffer < "u", d.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        d.blob = !1;
      else {
        var u = new ArrayBuffer(0);
        try {
          d.blob = new Blob([u], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            m.append(u), d.blob = m.getBlob("application/zip").size === 0;
          } catch {
            d.blob = !1;
          }
        }
      }
      try {
        d.nodestream = !!s("readable-stream").Readable;
      } catch {
        d.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(s, c, d) {
      for (var u = s("./utils"), m = s("./support"), g = s("./nodejsUtils"), _ = s("./stream/GenericWorker"), S = new Array(256), C = 0; C < 256; C++)
        S[C] = 252 <= C ? 6 : 248 <= C ? 5 : 240 <= C ? 4 : 224 <= C ? 3 : 192 <= C ? 2 : 1;
      S[254] = S[254] = 1;
      function O() {
        _.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function k() {
        _.call(this, "utf-8 encode");
      }
      d.utf8encode = function(D) {
        return m.nodebuffer ? g.newBufferFrom(D, "utf-8") : function(F) {
          var E, L, T, M, R, b = F.length, U = 0;
          for (M = 0; M < b; M++)
            (64512 & (L = F.charCodeAt(M))) == 55296 && M + 1 < b && (64512 & (T = F.charCodeAt(M + 1))) == 56320 && (L = 65536 + (L - 55296 << 10) + (T - 56320), M++), U += L < 128 ? 1 : L < 2048 ? 2 : L < 65536 ? 3 : 4;
          for (E = m.uint8array ? new Uint8Array(U) : new Array(U), M = R = 0; R < U; M++)
            (64512 & (L = F.charCodeAt(M))) == 55296 && M + 1 < b && (64512 & (T = F.charCodeAt(M + 1))) == 56320 && (L = 65536 + (L - 55296 << 10) + (T - 56320), M++), L < 128 ? E[R++] = L : (L < 2048 ? E[R++] = 192 | L >>> 6 : (L < 65536 ? E[R++] = 224 | L >>> 12 : (E[R++] = 240 | L >>> 18, E[R++] = 128 | L >>> 12 & 63), E[R++] = 128 | L >>> 6 & 63), E[R++] = 128 | 63 & L);
          return E;
        }(D);
      }, d.utf8decode = function(D) {
        return m.nodebuffer ? u.transformTo("nodebuffer", D).toString("utf-8") : function(F) {
          var E, L, T, M, R = F.length, b = new Array(2 * R);
          for (E = L = 0; E < R; )
            if ((T = F[E++]) < 128)
              b[L++] = T;
            else if (4 < (M = S[T]))
              b[L++] = 65533, E += M - 1;
            else {
              for (T &= M === 2 ? 31 : M === 3 ? 15 : 7; 1 < M && E < R; )
                T = T << 6 | 63 & F[E++], M--;
              1 < M ? b[L++] = 65533 : T < 65536 ? b[L++] = T : (T -= 65536, b[L++] = 55296 | T >> 10 & 1023, b[L++] = 56320 | 1023 & T);
            }
          return b.length !== L && (b.subarray ? b = b.subarray(0, L) : b.length = L), u.applyFromCharCode(b);
        }(D = u.transformTo(m.uint8array ? "uint8array" : "array", D));
      }, u.inherits(O, _), O.prototype.processChunk = function(D) {
        var F = u.transformTo(m.uint8array ? "uint8array" : "array", D.data);
        if (this.leftOver && this.leftOver.length) {
          if (m.uint8array) {
            var E = F;
            (F = new Uint8Array(E.length + this.leftOver.length)).set(this.leftOver, 0), F.set(E, this.leftOver.length);
          } else
            F = this.leftOver.concat(F);
          this.leftOver = null;
        }
        var L = function(M, R) {
          var b;
          for ((R = R || M.length) > M.length && (R = M.length), b = R - 1; 0 <= b && (192 & M[b]) == 128; )
            b--;
          return b < 0 || b === 0 ? R : b + S[M[b]] > R ? b : R;
        }(F), T = F;
        L !== F.length && (m.uint8array ? (T = F.subarray(0, L), this.leftOver = F.subarray(L, F.length)) : (T = F.slice(0, L), this.leftOver = F.slice(L, F.length))), this.push({ data: d.utf8decode(T), meta: D.meta });
      }, O.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: d.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, d.Utf8DecodeWorker = O, u.inherits(k, _), k.prototype.processChunk = function(D) {
        this.push({ data: d.utf8encode(D.data), meta: D.meta });
      }, d.Utf8EncodeWorker = k;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(s, c, d) {
      var u = s("./support"), m = s("./base64"), g = s("./nodejsUtils"), _ = s("./external");
      function S(E) {
        return E;
      }
      function C(E, L) {
        for (var T = 0; T < E.length; ++T)
          L[T] = 255 & E.charCodeAt(T);
        return L;
      }
      s("setimmediate"), d.newBlob = function(E, L) {
        d.checkSupport("blob");
        try {
          return new Blob([E], { type: L });
        } catch {
          try {
            var T = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return T.append(E), T.getBlob(L);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var O = { stringifyByChunk: function(E, L, T) {
        var M = [], R = 0, b = E.length;
        if (b <= T)
          return String.fromCharCode.apply(null, E);
        for (; R < b; )
          L === "array" || L === "nodebuffer" ? M.push(String.fromCharCode.apply(null, E.slice(R, Math.min(R + T, b)))) : M.push(String.fromCharCode.apply(null, E.subarray(R, Math.min(R + T, b)))), R += T;
        return M.join("");
      }, stringifyByChar: function(E) {
        for (var L = "", T = 0; T < E.length; T++)
          L += String.fromCharCode(E[T]);
        return L;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return u.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return u.nodebuffer && String.fromCharCode.apply(null, g.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function k(E) {
        var L = 65536, T = d.getTypeOf(E), M = !0;
        if (T === "uint8array" ? M = O.applyCanBeUsed.uint8array : T === "nodebuffer" && (M = O.applyCanBeUsed.nodebuffer), M)
          for (; 1 < L; )
            try {
              return O.stringifyByChunk(E, T, L);
            } catch {
              L = Math.floor(L / 2);
            }
        return O.stringifyByChar(E);
      }
      function D(E, L) {
        for (var T = 0; T < E.length; T++)
          L[T] = E[T];
        return L;
      }
      d.applyFromCharCode = k;
      var F = {};
      F.string = { string: S, array: function(E) {
        return C(E, new Array(E.length));
      }, arraybuffer: function(E) {
        return F.string.uint8array(E).buffer;
      }, uint8array: function(E) {
        return C(E, new Uint8Array(E.length));
      }, nodebuffer: function(E) {
        return C(E, g.allocBuffer(E.length));
      } }, F.array = { string: k, array: S, arraybuffer: function(E) {
        return new Uint8Array(E).buffer;
      }, uint8array: function(E) {
        return new Uint8Array(E);
      }, nodebuffer: function(E) {
        return g.newBufferFrom(E);
      } }, F.arraybuffer = { string: function(E) {
        return k(new Uint8Array(E));
      }, array: function(E) {
        return D(new Uint8Array(E), new Array(E.byteLength));
      }, arraybuffer: S, uint8array: function(E) {
        return new Uint8Array(E);
      }, nodebuffer: function(E) {
        return g.newBufferFrom(new Uint8Array(E));
      } }, F.uint8array = { string: k, array: function(E) {
        return D(E, new Array(E.length));
      }, arraybuffer: function(E) {
        return E.buffer;
      }, uint8array: S, nodebuffer: function(E) {
        return g.newBufferFrom(E);
      } }, F.nodebuffer = { string: k, array: function(E) {
        return D(E, new Array(E.length));
      }, arraybuffer: function(E) {
        return F.nodebuffer.uint8array(E).buffer;
      }, uint8array: function(E) {
        return D(E, new Uint8Array(E.length));
      }, nodebuffer: S }, d.transformTo = function(E, L) {
        if (L = L || "", !E)
          return L;
        d.checkSupport(E);
        var T = d.getTypeOf(L);
        return F[T][E](L);
      }, d.resolve = function(E) {
        for (var L = E.split("/"), T = [], M = 0; M < L.length; M++) {
          var R = L[M];
          R === "." || R === "" && M !== 0 && M !== L.length - 1 || (R === ".." ? T.pop() : T.push(R));
        }
        return T.join("/");
      }, d.getTypeOf = function(E) {
        return typeof E == "string" ? "string" : Object.prototype.toString.call(E) === "[object Array]" ? "array" : u.nodebuffer && g.isBuffer(E) ? "nodebuffer" : u.uint8array && E instanceof Uint8Array ? "uint8array" : u.arraybuffer && E instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, d.checkSupport = function(E) {
        if (!u[E.toLowerCase()])
          throw new Error(E + " is not supported by this platform");
      }, d.MAX_VALUE_16BITS = 65535, d.MAX_VALUE_32BITS = -1, d.pretty = function(E) {
        var L, T, M = "";
        for (T = 0; T < (E || "").length; T++)
          M += "\\x" + ((L = E.charCodeAt(T)) < 16 ? "0" : "") + L.toString(16).toUpperCase();
        return M;
      }, d.delay = function(E, L, T) {
        setImmediate(function() {
          E.apply(T || null, L || []);
        });
      }, d.inherits = function(E, L) {
        function T() {
        }
        T.prototype = L.prototype, E.prototype = new T();
      }, d.extend = function() {
        var E, L, T = {};
        for (E = 0; E < arguments.length; E++)
          for (L in arguments[E])
            Object.prototype.hasOwnProperty.call(arguments[E], L) && T[L] === void 0 && (T[L] = arguments[E][L]);
        return T;
      }, d.prepareContent = function(E, L, T, M, R) {
        return _.Promise.resolve(L).then(function(b) {
          return u.blob && (b instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(b)) !== -1) && typeof FileReader < "u" ? new _.Promise(function(U, N) {
            var j = new FileReader();
            j.onload = function(J) {
              U(J.target.result);
            }, j.onerror = function(J) {
              N(J.target.error);
            }, j.readAsArrayBuffer(b);
          }) : b;
        }).then(function(b) {
          var U = d.getTypeOf(b);
          return U ? (U === "arraybuffer" ? b = d.transformTo("uint8array", b) : U === "string" && (R ? b = m.decode(b) : T && M !== !0 && (b = function(N) {
            return C(N, u.uint8array ? new Uint8Array(N.length) : new Array(N.length));
          }(b))), b) : _.Promise.reject(new Error("Can't read the data of '" + E + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(s, c, d) {
      var u = s("./reader/readerFor"), m = s("./utils"), g = s("./signature"), _ = s("./zipEntry"), S = s("./support");
      function C(O) {
        this.files = [], this.loadOptions = O;
      }
      C.prototype = { checkSignature: function(O) {
        if (!this.reader.readAndCheckSignature(O)) {
          this.reader.index -= 4;
          var k = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + m.pretty(k) + ", expected " + m.pretty(O) + ")");
        }
      }, isSignature: function(O, k) {
        var D = this.reader.index;
        this.reader.setIndex(O);
        var F = this.reader.readString(4) === k;
        return this.reader.setIndex(D), F;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var O = this.reader.readData(this.zipCommentLength), k = S.uint8array ? "uint8array" : "array", D = m.transformTo(k, O);
        this.zipComment = this.loadOptions.decodeFileName(D);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var O, k, D, F = this.zip64EndOfCentralSize - 44; 0 < F; )
          O = this.reader.readInt(2), k = this.reader.readInt(4), D = this.reader.readData(k), this.zip64ExtensibleData[O] = { id: O, length: k, value: D };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var O, k;
        for (O = 0; O < this.files.length; O++)
          k = this.files[O], this.reader.setIndex(k.localHeaderOffset), this.checkSignature(g.LOCAL_FILE_HEADER), k.readLocalPart(this.reader), k.handleUTF8(), k.processAttributes();
      }, readCentralDir: function() {
        var O;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER); )
          (O = new _({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(O);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var O = this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);
        if (O < 0)
          throw this.isSignature(0, g.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(O);
        var k = O;
        if (this.checkSignature(g.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === m.MAX_VALUE_16BITS || this.diskWithCentralDirStart === m.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === m.MAX_VALUE_16BITS || this.centralDirRecords === m.MAX_VALUE_16BITS || this.centralDirSize === m.MAX_VALUE_32BITS || this.centralDirOffset === m.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (O = this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(O), this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, g.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var D = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (D += 20, D += 12 + this.zip64EndOfCentralSize);
        var F = k - D;
        if (0 < F)
          this.isSignature(k, g.CENTRAL_FILE_HEADER) || (this.reader.zero = F);
        else if (F < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(F) + " bytes.");
      }, prepareReader: function(O) {
        this.reader = u(O);
      }, load: function(O) {
        this.prepareReader(O), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, c.exports = C;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(s, c, d) {
      var u = s("./reader/readerFor"), m = s("./utils"), g = s("./compressedObject"), _ = s("./crc32"), S = s("./utf8"), C = s("./compressions"), O = s("./support");
      function k(D, F) {
        this.options = D, this.loadOptions = F;
      }
      k.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(D) {
        var F, E;
        if (D.skip(22), this.fileNameLength = D.readInt(2), E = D.readInt(2), this.fileName = D.readData(this.fileNameLength), D.skip(E), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((F = function(L) {
          for (var T in C)
            if (Object.prototype.hasOwnProperty.call(C, T) && C[T].magic === L)
              return C[T];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + m.pretty(this.compressionMethod) + " unknown (inner file : " + m.transformTo("string", this.fileName) + ")");
        this.decompressed = new g(this.compressedSize, this.uncompressedSize, this.crc32, F, D.readData(this.compressedSize));
      }, readCentralPart: function(D) {
        this.versionMadeBy = D.readInt(2), D.skip(2), this.bitFlag = D.readInt(2), this.compressionMethod = D.readString(2), this.date = D.readDate(), this.crc32 = D.readInt(4), this.compressedSize = D.readInt(4), this.uncompressedSize = D.readInt(4);
        var F = D.readInt(2);
        if (this.extraFieldsLength = D.readInt(2), this.fileCommentLength = D.readInt(2), this.diskNumberStart = D.readInt(2), this.internalFileAttributes = D.readInt(2), this.externalFileAttributes = D.readInt(4), this.localHeaderOffset = D.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        D.skip(F), this.readExtraFields(D), this.parseZIP64ExtraField(D), this.fileComment = D.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var D = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), D == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), D == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var D = u(this.extraFields[1].value);
          this.uncompressedSize === m.MAX_VALUE_32BITS && (this.uncompressedSize = D.readInt(8)), this.compressedSize === m.MAX_VALUE_32BITS && (this.compressedSize = D.readInt(8)), this.localHeaderOffset === m.MAX_VALUE_32BITS && (this.localHeaderOffset = D.readInt(8)), this.diskNumberStart === m.MAX_VALUE_32BITS && (this.diskNumberStart = D.readInt(4));
        }
      }, readExtraFields: function(D) {
        var F, E, L, T = D.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); D.index + 4 < T; )
          F = D.readInt(2), E = D.readInt(2), L = D.readData(E), this.extraFields[F] = { id: F, length: E, value: L };
        D.setIndex(T);
      }, handleUTF8: function() {
        var D = O.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = S.utf8decode(this.fileName), this.fileCommentStr = S.utf8decode(this.fileComment);
        else {
          var F = this.findExtraFieldUnicodePath();
          if (F !== null)
            this.fileNameStr = F;
          else {
            var E = m.transformTo(D, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(E);
          }
          var L = this.findExtraFieldUnicodeComment();
          if (L !== null)
            this.fileCommentStr = L;
          else {
            var T = m.transformTo(D, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(T);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var D = this.extraFields[28789];
        if (D) {
          var F = u(D.value);
          return F.readInt(1) !== 1 || _(this.fileName) !== F.readInt(4) ? null : S.utf8decode(F.readData(D.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var D = this.extraFields[25461];
        if (D) {
          var F = u(D.value);
          return F.readInt(1) !== 1 || _(this.fileComment) !== F.readInt(4) ? null : S.utf8decode(F.readData(D.length - 5));
        }
        return null;
      } }, c.exports = k;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(s, c, d) {
      function u(F, E, L) {
        this.name = F, this.dir = L.dir, this.date = L.date, this.comment = L.comment, this.unixPermissions = L.unixPermissions, this.dosPermissions = L.dosPermissions, this._data = E, this._dataBinary = L.binary, this.options = { compression: L.compression, compressionOptions: L.compressionOptions };
      }
      var m = s("./stream/StreamHelper"), g = s("./stream/DataWorker"), _ = s("./utf8"), S = s("./compressedObject"), C = s("./stream/GenericWorker");
      u.prototype = { internalStream: function(F) {
        var E = null, L = "string";
        try {
          if (!F)
            throw new Error("No output type specified.");
          var T = (L = F.toLowerCase()) === "string" || L === "text";
          L !== "binarystring" && L !== "text" || (L = "string"), E = this._decompressWorker();
          var M = !this._dataBinary;
          M && !T && (E = E.pipe(new _.Utf8EncodeWorker())), !M && T && (E = E.pipe(new _.Utf8DecodeWorker()));
        } catch (R) {
          (E = new C("error")).error(R);
        }
        return new m(E, L, "");
      }, async: function(F, E) {
        return this.internalStream(F).accumulate(E);
      }, nodeStream: function(F, E) {
        return this.internalStream(F || "nodebuffer").toNodejsStream(E);
      }, _compressWorker: function(F, E) {
        if (this._data instanceof S && this._data.compression.magic === F.magic)
          return this._data.getCompressedWorker();
        var L = this._decompressWorker();
        return this._dataBinary || (L = L.pipe(new _.Utf8EncodeWorker())), S.createWorkerFrom(L, F, E);
      }, _decompressWorker: function() {
        return this._data instanceof S ? this._data.getContentWorker() : this._data instanceof C ? this._data : new g(this._data);
      } };
      for (var O = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], k = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, D = 0; D < O.length; D++)
        u.prototype[O[D]] = k;
      c.exports = u;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(s, c, d) {
      (function(u) {
        var m, g, _ = u.MutationObserver || u.WebKitMutationObserver;
        if (_) {
          var S = 0, C = new _(F), O = u.document.createTextNode("");
          C.observe(O, { characterData: !0 }), m = function() {
            O.data = S = ++S % 2;
          };
        } else if (u.setImmediate || u.MessageChannel === void 0)
          m = "document" in u && "onreadystatechange" in u.document.createElement("script") ? function() {
            var E = u.document.createElement("script");
            E.onreadystatechange = function() {
              F(), E.onreadystatechange = null, E.parentNode.removeChild(E), E = null;
            }, u.document.documentElement.appendChild(E);
          } : function() {
            setTimeout(F, 0);
          };
        else {
          var k = new u.MessageChannel();
          k.port1.onmessage = F, m = function() {
            k.port2.postMessage(0);
          };
        }
        var D = [];
        function F() {
          var E, L;
          g = !0;
          for (var T = D.length; T; ) {
            for (L = D, D = [], E = -1; ++E < T; )
              L[E]();
            T = D.length;
          }
          g = !1;
        }
        c.exports = function(E) {
          D.push(E) !== 1 || g || m();
        };
      }).call(this, typeof zr < "u" ? zr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(s, c, d) {
      var u = s("immediate");
      function m() {
      }
      var g = {}, _ = ["REJECTED"], S = ["FULFILLED"], C = ["PENDING"];
      function O(T) {
        if (typeof T != "function")
          throw new TypeError("resolver must be a function");
        this.state = C, this.queue = [], this.outcome = void 0, T !== m && E(this, T);
      }
      function k(T, M, R) {
        this.promise = T, typeof M == "function" && (this.onFulfilled = M, this.callFulfilled = this.otherCallFulfilled), typeof R == "function" && (this.onRejected = R, this.callRejected = this.otherCallRejected);
      }
      function D(T, M, R) {
        u(function() {
          var b;
          try {
            b = M(R);
          } catch (U) {
            return g.reject(T, U);
          }
          b === T ? g.reject(T, new TypeError("Cannot resolve promise with itself")) : g.resolve(T, b);
        });
      }
      function F(T) {
        var M = T && T.then;
        if (T && (typeof T == "object" || typeof T == "function") && typeof M == "function")
          return function() {
            M.apply(T, arguments);
          };
      }
      function E(T, M) {
        var R = !1;
        function b(j) {
          R || (R = !0, g.reject(T, j));
        }
        function U(j) {
          R || (R = !0, g.resolve(T, j));
        }
        var N = L(function() {
          M(U, b);
        });
        N.status === "error" && b(N.value);
      }
      function L(T, M) {
        var R = {};
        try {
          R.value = T(M), R.status = "success";
        } catch (b) {
          R.status = "error", R.value = b;
        }
        return R;
      }
      (c.exports = O).prototype.finally = function(T) {
        if (typeof T != "function")
          return this;
        var M = this.constructor;
        return this.then(function(R) {
          return M.resolve(T()).then(function() {
            return R;
          });
        }, function(R) {
          return M.resolve(T()).then(function() {
            throw R;
          });
        });
      }, O.prototype.catch = function(T) {
        return this.then(null, T);
      }, O.prototype.then = function(T, M) {
        if (typeof T != "function" && this.state === S || typeof M != "function" && this.state === _)
          return this;
        var R = new this.constructor(m);
        return this.state !== C ? D(R, this.state === S ? T : M, this.outcome) : this.queue.push(new k(R, T, M)), R;
      }, k.prototype.callFulfilled = function(T) {
        g.resolve(this.promise, T);
      }, k.prototype.otherCallFulfilled = function(T) {
        D(this.promise, this.onFulfilled, T);
      }, k.prototype.callRejected = function(T) {
        g.reject(this.promise, T);
      }, k.prototype.otherCallRejected = function(T) {
        D(this.promise, this.onRejected, T);
      }, g.resolve = function(T, M) {
        var R = L(F, M);
        if (R.status === "error")
          return g.reject(T, R.value);
        var b = R.value;
        if (b)
          E(T, b);
        else {
          T.state = S, T.outcome = M;
          for (var U = -1, N = T.queue.length; ++U < N; )
            T.queue[U].callFulfilled(M);
        }
        return T;
      }, g.reject = function(T, M) {
        T.state = _, T.outcome = M;
        for (var R = -1, b = T.queue.length; ++R < b; )
          T.queue[R].callRejected(M);
        return T;
      }, O.resolve = function(T) {
        return T instanceof this ? T : g.resolve(new this(m), T);
      }, O.reject = function(T) {
        var M = new this(m);
        return g.reject(M, T);
      }, O.all = function(T) {
        var M = this;
        if (Object.prototype.toString.call(T) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var R = T.length, b = !1;
        if (!R)
          return this.resolve([]);
        for (var U = new Array(R), N = 0, j = -1, J = new this(m); ++j < R; )
          K(T[j], j);
        return J;
        function K(ct, It) {
          M.resolve(ct).then(function(et) {
            U[It] = et, ++N !== R || b || (b = !0, g.resolve(J, U));
          }, function(et) {
            b || (b = !0, g.reject(J, et));
          });
        }
      }, O.race = function(T) {
        var M = this;
        if (Object.prototype.toString.call(T) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var R = T.length, b = !1;
        if (!R)
          return this.resolve([]);
        for (var U = -1, N = new this(m); ++U < R; )
          j = T[U], M.resolve(j).then(function(J) {
            b || (b = !0, g.resolve(N, J));
          }, function(J) {
            b || (b = !0, g.reject(N, J));
          });
        var j;
        return N;
      };
    }, { immediate: 36 }], 38: [function(s, c, d) {
      var u = {};
      (0, s("./lib/utils/common").assign)(u, s("./lib/deflate"), s("./lib/inflate"), s("./lib/zlib/constants")), c.exports = u;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(s, c, d) {
      var u = s("./zlib/deflate"), m = s("./utils/common"), g = s("./utils/strings"), _ = s("./zlib/messages"), S = s("./zlib/zstream"), C = Object.prototype.toString, O = 0, k = -1, D = 0, F = 8;
      function E(T) {
        if (!(this instanceof E))
          return new E(T);
        this.options = m.assign({ level: k, method: F, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: D, to: "" }, T || {});
        var M = this.options;
        M.raw && 0 < M.windowBits ? M.windowBits = -M.windowBits : M.gzip && 0 < M.windowBits && M.windowBits < 16 && (M.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new S(), this.strm.avail_out = 0;
        var R = u.deflateInit2(this.strm, M.level, M.method, M.windowBits, M.memLevel, M.strategy);
        if (R !== O)
          throw new Error(_[R]);
        if (M.header && u.deflateSetHeader(this.strm, M.header), M.dictionary) {
          var b;
          if (b = typeof M.dictionary == "string" ? g.string2buf(M.dictionary) : C.call(M.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(M.dictionary) : M.dictionary, (R = u.deflateSetDictionary(this.strm, b)) !== O)
            throw new Error(_[R]);
          this._dict_set = !0;
        }
      }
      function L(T, M) {
        var R = new E(M);
        if (R.push(T, !0), R.err)
          throw R.msg || _[R.err];
        return R.result;
      }
      E.prototype.push = function(T, M) {
        var R, b, U = this.strm, N = this.options.chunkSize;
        if (this.ended)
          return !1;
        b = M === ~~M ? M : M === !0 ? 4 : 0, typeof T == "string" ? U.input = g.string2buf(T) : C.call(T) === "[object ArrayBuffer]" ? U.input = new Uint8Array(T) : U.input = T, U.next_in = 0, U.avail_in = U.input.length;
        do {
          if (U.avail_out === 0 && (U.output = new m.Buf8(N), U.next_out = 0, U.avail_out = N), (R = u.deflate(U, b)) !== 1 && R !== O)
            return this.onEnd(R), !(this.ended = !0);
          U.avail_out !== 0 && (U.avail_in !== 0 || b !== 4 && b !== 2) || (this.options.to === "string" ? this.onData(g.buf2binstring(m.shrinkBuf(U.output, U.next_out))) : this.onData(m.shrinkBuf(U.output, U.next_out)));
        } while ((0 < U.avail_in || U.avail_out === 0) && R !== 1);
        return b === 4 ? (R = u.deflateEnd(this.strm), this.onEnd(R), this.ended = !0, R === O) : b !== 2 || (this.onEnd(O), !(U.avail_out = 0));
      }, E.prototype.onData = function(T) {
        this.chunks.push(T);
      }, E.prototype.onEnd = function(T) {
        T === O && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = m.flattenChunks(this.chunks)), this.chunks = [], this.err = T, this.msg = this.strm.msg;
      }, d.Deflate = E, d.deflate = L, d.deflateRaw = function(T, M) {
        return (M = M || {}).raw = !0, L(T, M);
      }, d.gzip = function(T, M) {
        return (M = M || {}).gzip = !0, L(T, M);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(s, c, d) {
      var u = s("./zlib/inflate"), m = s("./utils/common"), g = s("./utils/strings"), _ = s("./zlib/constants"), S = s("./zlib/messages"), C = s("./zlib/zstream"), O = s("./zlib/gzheader"), k = Object.prototype.toString;
      function D(E) {
        if (!(this instanceof D))
          return new D(E);
        this.options = m.assign({ chunkSize: 16384, windowBits: 0, to: "" }, E || {});
        var L = this.options;
        L.raw && 0 <= L.windowBits && L.windowBits < 16 && (L.windowBits = -L.windowBits, L.windowBits === 0 && (L.windowBits = -15)), !(0 <= L.windowBits && L.windowBits < 16) || E && E.windowBits || (L.windowBits += 32), 15 < L.windowBits && L.windowBits < 48 && !(15 & L.windowBits) && (L.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new C(), this.strm.avail_out = 0;
        var T = u.inflateInit2(this.strm, L.windowBits);
        if (T !== _.Z_OK)
          throw new Error(S[T]);
        this.header = new O(), u.inflateGetHeader(this.strm, this.header);
      }
      function F(E, L) {
        var T = new D(L);
        if (T.push(E, !0), T.err)
          throw T.msg || S[T.err];
        return T.result;
      }
      D.prototype.push = function(E, L) {
        var T, M, R, b, U, N, j = this.strm, J = this.options.chunkSize, K = this.options.dictionary, ct = !1;
        if (this.ended)
          return !1;
        M = L === ~~L ? L : L === !0 ? _.Z_FINISH : _.Z_NO_FLUSH, typeof E == "string" ? j.input = g.binstring2buf(E) : k.call(E) === "[object ArrayBuffer]" ? j.input = new Uint8Array(E) : j.input = E, j.next_in = 0, j.avail_in = j.input.length;
        do {
          if (j.avail_out === 0 && (j.output = new m.Buf8(J), j.next_out = 0, j.avail_out = J), (T = u.inflate(j, _.Z_NO_FLUSH)) === _.Z_NEED_DICT && K && (N = typeof K == "string" ? g.string2buf(K) : k.call(K) === "[object ArrayBuffer]" ? new Uint8Array(K) : K, T = u.inflateSetDictionary(this.strm, N)), T === _.Z_BUF_ERROR && ct === !0 && (T = _.Z_OK, ct = !1), T !== _.Z_STREAM_END && T !== _.Z_OK)
            return this.onEnd(T), !(this.ended = !0);
          j.next_out && (j.avail_out !== 0 && T !== _.Z_STREAM_END && (j.avail_in !== 0 || M !== _.Z_FINISH && M !== _.Z_SYNC_FLUSH) || (this.options.to === "string" ? (R = g.utf8border(j.output, j.next_out), b = j.next_out - R, U = g.buf2string(j.output, R), j.next_out = b, j.avail_out = J - b, b && m.arraySet(j.output, j.output, R, b, 0), this.onData(U)) : this.onData(m.shrinkBuf(j.output, j.next_out)))), j.avail_in === 0 && j.avail_out === 0 && (ct = !0);
        } while ((0 < j.avail_in || j.avail_out === 0) && T !== _.Z_STREAM_END);
        return T === _.Z_STREAM_END && (M = _.Z_FINISH), M === _.Z_FINISH ? (T = u.inflateEnd(this.strm), this.onEnd(T), this.ended = !0, T === _.Z_OK) : M !== _.Z_SYNC_FLUSH || (this.onEnd(_.Z_OK), !(j.avail_out = 0));
      }, D.prototype.onData = function(E) {
        this.chunks.push(E);
      }, D.prototype.onEnd = function(E) {
        E === _.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = m.flattenChunks(this.chunks)), this.chunks = [], this.err = E, this.msg = this.strm.msg;
      }, d.Inflate = D, d.inflate = F, d.inflateRaw = function(E, L) {
        return (L = L || {}).raw = !0, F(E, L);
      }, d.ungzip = F;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(s, c, d) {
      var u = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      d.assign = function(_) {
        for (var S = Array.prototype.slice.call(arguments, 1); S.length; ) {
          var C = S.shift();
          if (C) {
            if (typeof C != "object")
              throw new TypeError(C + "must be non-object");
            for (var O in C)
              C.hasOwnProperty(O) && (_[O] = C[O]);
          }
        }
        return _;
      }, d.shrinkBuf = function(_, S) {
        return _.length === S ? _ : _.subarray ? _.subarray(0, S) : (_.length = S, _);
      };
      var m = { arraySet: function(_, S, C, O, k) {
        if (S.subarray && _.subarray)
          _.set(S.subarray(C, C + O), k);
        else
          for (var D = 0; D < O; D++)
            _[k + D] = S[C + D];
      }, flattenChunks: function(_) {
        var S, C, O, k, D, F;
        for (S = O = 0, C = _.length; S < C; S++)
          O += _[S].length;
        for (F = new Uint8Array(O), S = k = 0, C = _.length; S < C; S++)
          D = _[S], F.set(D, k), k += D.length;
        return F;
      } }, g = { arraySet: function(_, S, C, O, k) {
        for (var D = 0; D < O; D++)
          _[k + D] = S[C + D];
      }, flattenChunks: function(_) {
        return [].concat.apply([], _);
      } };
      d.setTyped = function(_) {
        _ ? (d.Buf8 = Uint8Array, d.Buf16 = Uint16Array, d.Buf32 = Int32Array, d.assign(d, m)) : (d.Buf8 = Array, d.Buf16 = Array, d.Buf32 = Array, d.assign(d, g));
      }, d.setTyped(u);
    }, {}], 42: [function(s, c, d) {
      var u = s("./common"), m = !0, g = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        m = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        g = !1;
      }
      for (var _ = new u.Buf8(256), S = 0; S < 256; S++)
        _[S] = 252 <= S ? 6 : 248 <= S ? 5 : 240 <= S ? 4 : 224 <= S ? 3 : 192 <= S ? 2 : 1;
      function C(O, k) {
        if (k < 65537 && (O.subarray && g || !O.subarray && m))
          return String.fromCharCode.apply(null, u.shrinkBuf(O, k));
        for (var D = "", F = 0; F < k; F++)
          D += String.fromCharCode(O[F]);
        return D;
      }
      _[254] = _[254] = 1, d.string2buf = function(O) {
        var k, D, F, E, L, T = O.length, M = 0;
        for (E = 0; E < T; E++)
          (64512 & (D = O.charCodeAt(E))) == 55296 && E + 1 < T && (64512 & (F = O.charCodeAt(E + 1))) == 56320 && (D = 65536 + (D - 55296 << 10) + (F - 56320), E++), M += D < 128 ? 1 : D < 2048 ? 2 : D < 65536 ? 3 : 4;
        for (k = new u.Buf8(M), E = L = 0; L < M; E++)
          (64512 & (D = O.charCodeAt(E))) == 55296 && E + 1 < T && (64512 & (F = O.charCodeAt(E + 1))) == 56320 && (D = 65536 + (D - 55296 << 10) + (F - 56320), E++), D < 128 ? k[L++] = D : (D < 2048 ? k[L++] = 192 | D >>> 6 : (D < 65536 ? k[L++] = 224 | D >>> 12 : (k[L++] = 240 | D >>> 18, k[L++] = 128 | D >>> 12 & 63), k[L++] = 128 | D >>> 6 & 63), k[L++] = 128 | 63 & D);
        return k;
      }, d.buf2binstring = function(O) {
        return C(O, O.length);
      }, d.binstring2buf = function(O) {
        for (var k = new u.Buf8(O.length), D = 0, F = k.length; D < F; D++)
          k[D] = O.charCodeAt(D);
        return k;
      }, d.buf2string = function(O, k) {
        var D, F, E, L, T = k || O.length, M = new Array(2 * T);
        for (D = F = 0; D < T; )
          if ((E = O[D++]) < 128)
            M[F++] = E;
          else if (4 < (L = _[E]))
            M[F++] = 65533, D += L - 1;
          else {
            for (E &= L === 2 ? 31 : L === 3 ? 15 : 7; 1 < L && D < T; )
              E = E << 6 | 63 & O[D++], L--;
            1 < L ? M[F++] = 65533 : E < 65536 ? M[F++] = E : (E -= 65536, M[F++] = 55296 | E >> 10 & 1023, M[F++] = 56320 | 1023 & E);
          }
        return C(M, F);
      }, d.utf8border = function(O, k) {
        var D;
        for ((k = k || O.length) > O.length && (k = O.length), D = k - 1; 0 <= D && (192 & O[D]) == 128; )
          D--;
        return D < 0 || D === 0 ? k : D + _[O[D]] > k ? D : k;
      };
    }, { "./common": 41 }], 43: [function(s, c, d) {
      c.exports = function(u, m, g, _) {
        for (var S = 65535 & u | 0, C = u >>> 16 & 65535 | 0, O = 0; g !== 0; ) {
          for (g -= O = 2e3 < g ? 2e3 : g; C = C + (S = S + m[_++] | 0) | 0, --O; )
            ;
          S %= 65521, C %= 65521;
        }
        return S | C << 16 | 0;
      };
    }, {}], 44: [function(s, c, d) {
      c.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(s, c, d) {
      var u = function() {
        for (var m, g = [], _ = 0; _ < 256; _++) {
          m = _;
          for (var S = 0; S < 8; S++)
            m = 1 & m ? 3988292384 ^ m >>> 1 : m >>> 1;
          g[_] = m;
        }
        return g;
      }();
      c.exports = function(m, g, _, S) {
        var C = u, O = S + _;
        m ^= -1;
        for (var k = S; k < O; k++)
          m = m >>> 8 ^ C[255 & (m ^ g[k])];
        return -1 ^ m;
      };
    }, {}], 46: [function(s, c, d) {
      var u, m = s("../utils/common"), g = s("./trees"), _ = s("./adler32"), S = s("./crc32"), C = s("./messages"), O = 0, k = 4, D = 0, F = -2, E = -1, L = 4, T = 2, M = 8, R = 9, b = 286, U = 30, N = 19, j = 2 * b + 1, J = 15, K = 3, ct = 258, It = ct + K + 1, et = 42, _t = 113, G = 1, Pt = 2, Et = 3, At = 4;
      function fe(W, Jt) {
        return W.msg = C[Jt], Jt;
      }
      function re(W) {
        return (W << 1) - (4 < W ? 9 : 0);
      }
      function Ft(W) {
        for (var Jt = W.length; 0 <= --Jt; )
          W[Jt] = 0;
      }
      function Ot(W) {
        var Jt = W.state, Wt = Jt.pending;
        Wt > W.avail_out && (Wt = W.avail_out), Wt !== 0 && (m.arraySet(W.output, Jt.pending_buf, Jt.pending_out, Wt, W.next_out), W.next_out += Wt, Jt.pending_out += Wt, W.total_out += Wt, W.avail_out -= Wt, Jt.pending -= Wt, Jt.pending === 0 && (Jt.pending_out = 0));
      }
      function Bt(W, Jt) {
        g._tr_flush_block(W, 0 <= W.block_start ? W.block_start : -1, W.strstart - W.block_start, Jt), W.block_start = W.strstart, Ot(W.strm);
      }
      function ke(W, Jt) {
        W.pending_buf[W.pending++] = Jt;
      }
      function ce(W, Jt) {
        W.pending_buf[W.pending++] = Jt >>> 8 & 255, W.pending_buf[W.pending++] = 255 & Jt;
      }
      function Yt(W, Jt) {
        var Wt, pt, dt = W.max_chain_length, Dt = W.strstart, ie = W.prev_length, Kt = W.nice_match, z = W.strstart > W.w_size - It ? W.strstart - (W.w_size - It) : 0, Q = W.window, st = W.w_mask, nt = W.prev, vt = W.strstart + ct, Gt = Q[Dt + ie - 1], Xt = Q[Dt + ie];
        W.prev_length >= W.good_match && (dt >>= 2), Kt > W.lookahead && (Kt = W.lookahead);
        do
          if (Q[(Wt = Jt) + ie] === Xt && Q[Wt + ie - 1] === Gt && Q[Wt] === Q[Dt] && Q[++Wt] === Q[Dt + 1]) {
            Dt += 2, Wt++;
            do
              ;
            while (Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Dt < vt);
            if (pt = ct - (vt - Dt), Dt = vt - ct, ie < pt) {
              if (W.match_start = Jt, Kt <= (ie = pt))
                break;
              Gt = Q[Dt + ie - 1], Xt = Q[Dt + ie];
            }
          }
        while ((Jt = nt[Jt & st]) > z && --dt != 0);
        return ie <= W.lookahead ? ie : W.lookahead;
      }
      function $e(W) {
        var Jt, Wt, pt, dt, Dt, ie, Kt, z, Q, st, nt = W.w_size;
        do {
          if (dt = W.window_size - W.lookahead - W.strstart, W.strstart >= nt + (nt - It)) {
            for (m.arraySet(W.window, W.window, nt, nt, 0), W.match_start -= nt, W.strstart -= nt, W.block_start -= nt, Jt = Wt = W.hash_size; pt = W.head[--Jt], W.head[Jt] = nt <= pt ? pt - nt : 0, --Wt; )
              ;
            for (Jt = Wt = nt; pt = W.prev[--Jt], W.prev[Jt] = nt <= pt ? pt - nt : 0, --Wt; )
              ;
            dt += nt;
          }
          if (W.strm.avail_in === 0)
            break;
          if (ie = W.strm, Kt = W.window, z = W.strstart + W.lookahead, Q = dt, st = void 0, st = ie.avail_in, Q < st && (st = Q), Wt = st === 0 ? 0 : (ie.avail_in -= st, m.arraySet(Kt, ie.input, ie.next_in, st, z), ie.state.wrap === 1 ? ie.adler = _(ie.adler, Kt, st, z) : ie.state.wrap === 2 && (ie.adler = S(ie.adler, Kt, st, z)), ie.next_in += st, ie.total_in += st, st), W.lookahead += Wt, W.lookahead + W.insert >= K)
            for (Dt = W.strstart - W.insert, W.ins_h = W.window[Dt], W.ins_h = (W.ins_h << W.hash_shift ^ W.window[Dt + 1]) & W.hash_mask; W.insert && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[Dt + K - 1]) & W.hash_mask, W.prev[Dt & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = Dt, Dt++, W.insert--, !(W.lookahead + W.insert < K)); )
              ;
        } while (W.lookahead < It && W.strm.avail_in !== 0);
      }
      function Li(W, Jt) {
        for (var Wt, pt; ; ) {
          if (W.lookahead < It) {
            if ($e(W), W.lookahead < It && Jt === O)
              return G;
            if (W.lookahead === 0)
              break;
          }
          if (Wt = 0, W.lookahead >= K && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + K - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart), Wt !== 0 && W.strstart - Wt <= W.w_size - It && (W.match_length = Yt(W, Wt)), W.match_length >= K)
            if (pt = g._tr_tally(W, W.strstart - W.match_start, W.match_length - K), W.lookahead -= W.match_length, W.match_length <= W.max_lazy_match && W.lookahead >= K) {
              for (W.match_length--; W.strstart++, W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + K - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart, --W.match_length != 0; )
                ;
              W.strstart++;
            } else
              W.strstart += W.match_length, W.match_length = 0, W.ins_h = W.window[W.strstart], W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + 1]) & W.hash_mask;
          else
            pt = g._tr_tally(W, 0, W.window[W.strstart]), W.lookahead--, W.strstart++;
          if (pt && (Bt(W, !1), W.strm.avail_out === 0))
            return G;
        }
        return W.insert = W.strstart < K - 1 ? W.strstart : K - 1, Jt === k ? (Bt(W, !0), W.strm.avail_out === 0 ? Et : At) : W.last_lit && (Bt(W, !1), W.strm.avail_out === 0) ? G : Pt;
      }
      function Oe(W, Jt) {
        for (var Wt, pt, dt; ; ) {
          if (W.lookahead < It) {
            if ($e(W), W.lookahead < It && Jt === O)
              return G;
            if (W.lookahead === 0)
              break;
          }
          if (Wt = 0, W.lookahead >= K && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + K - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart), W.prev_length = W.match_length, W.prev_match = W.match_start, W.match_length = K - 1, Wt !== 0 && W.prev_length < W.max_lazy_match && W.strstart - Wt <= W.w_size - It && (W.match_length = Yt(W, Wt), W.match_length <= 5 && (W.strategy === 1 || W.match_length === K && 4096 < W.strstart - W.match_start) && (W.match_length = K - 1)), W.prev_length >= K && W.match_length <= W.prev_length) {
            for (dt = W.strstart + W.lookahead - K, pt = g._tr_tally(W, W.strstart - 1 - W.prev_match, W.prev_length - K), W.lookahead -= W.prev_length - 1, W.prev_length -= 2; ++W.strstart <= dt && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + K - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart), --W.prev_length != 0; )
              ;
            if (W.match_available = 0, W.match_length = K - 1, W.strstart++, pt && (Bt(W, !1), W.strm.avail_out === 0))
              return G;
          } else if (W.match_available) {
            if ((pt = g._tr_tally(W, 0, W.window[W.strstart - 1])) && Bt(W, !1), W.strstart++, W.lookahead--, W.strm.avail_out === 0)
              return G;
          } else
            W.match_available = 1, W.strstart++, W.lookahead--;
        }
        return W.match_available && (pt = g._tr_tally(W, 0, W.window[W.strstart - 1]), W.match_available = 0), W.insert = W.strstart < K - 1 ? W.strstart : K - 1, Jt === k ? (Bt(W, !0), W.strm.avail_out === 0 ? Et : At) : W.last_lit && (Bt(W, !1), W.strm.avail_out === 0) ? G : Pt;
      }
      function Ge(W, Jt, Wt, pt, dt) {
        this.good_length = W, this.max_lazy = Jt, this.nice_length = Wt, this.max_chain = pt, this.func = dt;
      }
      function pi() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = M, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new m.Buf16(2 * j), this.dyn_dtree = new m.Buf16(2 * (2 * U + 1)), this.bl_tree = new m.Buf16(2 * (2 * N + 1)), Ft(this.dyn_ltree), Ft(this.dyn_dtree), Ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new m.Buf16(J + 1), this.heap = new m.Buf16(2 * b + 1), Ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new m.Buf16(2 * b + 1), Ft(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Ri(W) {
        var Jt;
        return W && W.state ? (W.total_in = W.total_out = 0, W.data_type = T, (Jt = W.state).pending = 0, Jt.pending_out = 0, Jt.wrap < 0 && (Jt.wrap = -Jt.wrap), Jt.status = Jt.wrap ? et : _t, W.adler = Jt.wrap === 2 ? 0 : 1, Jt.last_flush = O, g._tr_init(Jt), D) : fe(W, F);
      }
      function cn(W) {
        var Jt = Ri(W);
        return Jt === D && function(Wt) {
          Wt.window_size = 2 * Wt.w_size, Ft(Wt.head), Wt.max_lazy_match = u[Wt.level].max_lazy, Wt.good_match = u[Wt.level].good_length, Wt.nice_match = u[Wt.level].nice_length, Wt.max_chain_length = u[Wt.level].max_chain, Wt.strstart = 0, Wt.block_start = 0, Wt.lookahead = 0, Wt.insert = 0, Wt.match_length = Wt.prev_length = K - 1, Wt.match_available = 0, Wt.ins_h = 0;
        }(W.state), Jt;
      }
      function Ji(W, Jt, Wt, pt, dt, Dt) {
        if (!W)
          return F;
        var ie = 1;
        if (Jt === E && (Jt = 6), pt < 0 ? (ie = 0, pt = -pt) : 15 < pt && (ie = 2, pt -= 16), dt < 1 || R < dt || Wt !== M || pt < 8 || 15 < pt || Jt < 0 || 9 < Jt || Dt < 0 || L < Dt)
          return fe(W, F);
        pt === 8 && (pt = 9);
        var Kt = new pi();
        return (W.state = Kt).strm = W, Kt.wrap = ie, Kt.gzhead = null, Kt.w_bits = pt, Kt.w_size = 1 << Kt.w_bits, Kt.w_mask = Kt.w_size - 1, Kt.hash_bits = dt + 7, Kt.hash_size = 1 << Kt.hash_bits, Kt.hash_mask = Kt.hash_size - 1, Kt.hash_shift = ~~((Kt.hash_bits + K - 1) / K), Kt.window = new m.Buf8(2 * Kt.w_size), Kt.head = new m.Buf16(Kt.hash_size), Kt.prev = new m.Buf16(Kt.w_size), Kt.lit_bufsize = 1 << dt + 6, Kt.pending_buf_size = 4 * Kt.lit_bufsize, Kt.pending_buf = new m.Buf8(Kt.pending_buf_size), Kt.d_buf = 1 * Kt.lit_bufsize, Kt.l_buf = 3 * Kt.lit_bufsize, Kt.level = Jt, Kt.strategy = Dt, Kt.method = Wt, cn(W);
      }
      u = [new Ge(0, 0, 0, 0, function(W, Jt) {
        var Wt = 65535;
        for (Wt > W.pending_buf_size - 5 && (Wt = W.pending_buf_size - 5); ; ) {
          if (W.lookahead <= 1) {
            if ($e(W), W.lookahead === 0 && Jt === O)
              return G;
            if (W.lookahead === 0)
              break;
          }
          W.strstart += W.lookahead, W.lookahead = 0;
          var pt = W.block_start + Wt;
          if ((W.strstart === 0 || W.strstart >= pt) && (W.lookahead = W.strstart - pt, W.strstart = pt, Bt(W, !1), W.strm.avail_out === 0) || W.strstart - W.block_start >= W.w_size - It && (Bt(W, !1), W.strm.avail_out === 0))
            return G;
        }
        return W.insert = 0, Jt === k ? (Bt(W, !0), W.strm.avail_out === 0 ? Et : At) : (W.strstart > W.block_start && (Bt(W, !1), W.strm.avail_out), G);
      }), new Ge(4, 4, 8, 4, Li), new Ge(4, 5, 16, 8, Li), new Ge(4, 6, 32, 32, Li), new Ge(4, 4, 16, 16, Oe), new Ge(8, 16, 32, 32, Oe), new Ge(8, 16, 128, 128, Oe), new Ge(8, 32, 128, 256, Oe), new Ge(32, 128, 258, 1024, Oe), new Ge(32, 258, 258, 4096, Oe)], d.deflateInit = function(W, Jt) {
        return Ji(W, Jt, M, 15, 8, 0);
      }, d.deflateInit2 = Ji, d.deflateReset = cn, d.deflateResetKeep = Ri, d.deflateSetHeader = function(W, Jt) {
        return W && W.state ? W.state.wrap !== 2 ? F : (W.state.gzhead = Jt, D) : F;
      }, d.deflate = function(W, Jt) {
        var Wt, pt, dt, Dt;
        if (!W || !W.state || 5 < Jt || Jt < 0)
          return W ? fe(W, F) : F;
        if (pt = W.state, !W.output || !W.input && W.avail_in !== 0 || pt.status === 666 && Jt !== k)
          return fe(W, W.avail_out === 0 ? -5 : F);
        if (pt.strm = W, Wt = pt.last_flush, pt.last_flush = Jt, pt.status === et)
          if (pt.wrap === 2)
            W.adler = 0, ke(pt, 31), ke(pt, 139), ke(pt, 8), pt.gzhead ? (ke(pt, (pt.gzhead.text ? 1 : 0) + (pt.gzhead.hcrc ? 2 : 0) + (pt.gzhead.extra ? 4 : 0) + (pt.gzhead.name ? 8 : 0) + (pt.gzhead.comment ? 16 : 0)), ke(pt, 255 & pt.gzhead.time), ke(pt, pt.gzhead.time >> 8 & 255), ke(pt, pt.gzhead.time >> 16 & 255), ke(pt, pt.gzhead.time >> 24 & 255), ke(pt, pt.level === 9 ? 2 : 2 <= pt.strategy || pt.level < 2 ? 4 : 0), ke(pt, 255 & pt.gzhead.os), pt.gzhead.extra && pt.gzhead.extra.length && (ke(pt, 255 & pt.gzhead.extra.length), ke(pt, pt.gzhead.extra.length >> 8 & 255)), pt.gzhead.hcrc && (W.adler = S(W.adler, pt.pending_buf, pt.pending, 0)), pt.gzindex = 0, pt.status = 69) : (ke(pt, 0), ke(pt, 0), ke(pt, 0), ke(pt, 0), ke(pt, 0), ke(pt, pt.level === 9 ? 2 : 2 <= pt.strategy || pt.level < 2 ? 4 : 0), ke(pt, 3), pt.status = _t);
          else {
            var ie = M + (pt.w_bits - 8 << 4) << 8;
            ie |= (2 <= pt.strategy || pt.level < 2 ? 0 : pt.level < 6 ? 1 : pt.level === 6 ? 2 : 3) << 6, pt.strstart !== 0 && (ie |= 32), ie += 31 - ie % 31, pt.status = _t, ce(pt, ie), pt.strstart !== 0 && (ce(pt, W.adler >>> 16), ce(pt, 65535 & W.adler)), W.adler = 1;
          }
        if (pt.status === 69)
          if (pt.gzhead.extra) {
            for (dt = pt.pending; pt.gzindex < (65535 & pt.gzhead.extra.length) && (pt.pending !== pt.pending_buf_size || (pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Ot(W), dt = pt.pending, pt.pending !== pt.pending_buf_size)); )
              ke(pt, 255 & pt.gzhead.extra[pt.gzindex]), pt.gzindex++;
            pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), pt.gzindex === pt.gzhead.extra.length && (pt.gzindex = 0, pt.status = 73);
          } else
            pt.status = 73;
        if (pt.status === 73)
          if (pt.gzhead.name) {
            dt = pt.pending;
            do {
              if (pt.pending === pt.pending_buf_size && (pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Ot(W), dt = pt.pending, pt.pending === pt.pending_buf_size)) {
                Dt = 1;
                break;
              }
              Dt = pt.gzindex < pt.gzhead.name.length ? 255 & pt.gzhead.name.charCodeAt(pt.gzindex++) : 0, ke(pt, Dt);
            } while (Dt !== 0);
            pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Dt === 0 && (pt.gzindex = 0, pt.status = 91);
          } else
            pt.status = 91;
        if (pt.status === 91)
          if (pt.gzhead.comment) {
            dt = pt.pending;
            do {
              if (pt.pending === pt.pending_buf_size && (pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Ot(W), dt = pt.pending, pt.pending === pt.pending_buf_size)) {
                Dt = 1;
                break;
              }
              Dt = pt.gzindex < pt.gzhead.comment.length ? 255 & pt.gzhead.comment.charCodeAt(pt.gzindex++) : 0, ke(pt, Dt);
            } while (Dt !== 0);
            pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Dt === 0 && (pt.status = 103);
          } else
            pt.status = 103;
        if (pt.status === 103 && (pt.gzhead.hcrc ? (pt.pending + 2 > pt.pending_buf_size && Ot(W), pt.pending + 2 <= pt.pending_buf_size && (ke(pt, 255 & W.adler), ke(pt, W.adler >> 8 & 255), W.adler = 0, pt.status = _t)) : pt.status = _t), pt.pending !== 0) {
          if (Ot(W), W.avail_out === 0)
            return pt.last_flush = -1, D;
        } else if (W.avail_in === 0 && re(Jt) <= re(Wt) && Jt !== k)
          return fe(W, -5);
        if (pt.status === 666 && W.avail_in !== 0)
          return fe(W, -5);
        if (W.avail_in !== 0 || pt.lookahead !== 0 || Jt !== O && pt.status !== 666) {
          var Kt = pt.strategy === 2 ? function(z, Q) {
            for (var st; ; ) {
              if (z.lookahead === 0 && ($e(z), z.lookahead === 0)) {
                if (Q === O)
                  return G;
                break;
              }
              if (z.match_length = 0, st = g._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++, st && (Bt(z, !1), z.strm.avail_out === 0))
                return G;
            }
            return z.insert = 0, Q === k ? (Bt(z, !0), z.strm.avail_out === 0 ? Et : At) : z.last_lit && (Bt(z, !1), z.strm.avail_out === 0) ? G : Pt;
          }(pt, Jt) : pt.strategy === 3 ? function(z, Q) {
            for (var st, nt, vt, Gt, Xt = z.window; ; ) {
              if (z.lookahead <= ct) {
                if ($e(z), z.lookahead <= ct && Q === O)
                  return G;
                if (z.lookahead === 0)
                  break;
              }
              if (z.match_length = 0, z.lookahead >= K && 0 < z.strstart && (nt = Xt[vt = z.strstart - 1]) === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt]) {
                Gt = z.strstart + ct;
                do
                  ;
                while (nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && vt < Gt);
                z.match_length = ct - (Gt - vt), z.match_length > z.lookahead && (z.match_length = z.lookahead);
              }
              if (z.match_length >= K ? (st = g._tr_tally(z, 1, z.match_length - K), z.lookahead -= z.match_length, z.strstart += z.match_length, z.match_length = 0) : (st = g._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++), st && (Bt(z, !1), z.strm.avail_out === 0))
                return G;
            }
            return z.insert = 0, Q === k ? (Bt(z, !0), z.strm.avail_out === 0 ? Et : At) : z.last_lit && (Bt(z, !1), z.strm.avail_out === 0) ? G : Pt;
          }(pt, Jt) : u[pt.level].func(pt, Jt);
          if (Kt !== Et && Kt !== At || (pt.status = 666), Kt === G || Kt === Et)
            return W.avail_out === 0 && (pt.last_flush = -1), D;
          if (Kt === Pt && (Jt === 1 ? g._tr_align(pt) : Jt !== 5 && (g._tr_stored_block(pt, 0, 0, !1), Jt === 3 && (Ft(pt.head), pt.lookahead === 0 && (pt.strstart = 0, pt.block_start = 0, pt.insert = 0))), Ot(W), W.avail_out === 0))
            return pt.last_flush = -1, D;
        }
        return Jt !== k ? D : pt.wrap <= 0 ? 1 : (pt.wrap === 2 ? (ke(pt, 255 & W.adler), ke(pt, W.adler >> 8 & 255), ke(pt, W.adler >> 16 & 255), ke(pt, W.adler >> 24 & 255), ke(pt, 255 & W.total_in), ke(pt, W.total_in >> 8 & 255), ke(pt, W.total_in >> 16 & 255), ke(pt, W.total_in >> 24 & 255)) : (ce(pt, W.adler >>> 16), ce(pt, 65535 & W.adler)), Ot(W), 0 < pt.wrap && (pt.wrap = -pt.wrap), pt.pending !== 0 ? D : 1);
      }, d.deflateEnd = function(W) {
        var Jt;
        return W && W.state ? (Jt = W.state.status) !== et && Jt !== 69 && Jt !== 73 && Jt !== 91 && Jt !== 103 && Jt !== _t && Jt !== 666 ? fe(W, F) : (W.state = null, Jt === _t ? fe(W, -3) : D) : F;
      }, d.deflateSetDictionary = function(W, Jt) {
        var Wt, pt, dt, Dt, ie, Kt, z, Q, st = Jt.length;
        if (!W || !W.state || (Dt = (Wt = W.state).wrap) === 2 || Dt === 1 && Wt.status !== et || Wt.lookahead)
          return F;
        for (Dt === 1 && (W.adler = _(W.adler, Jt, st, 0)), Wt.wrap = 0, st >= Wt.w_size && (Dt === 0 && (Ft(Wt.head), Wt.strstart = 0, Wt.block_start = 0, Wt.insert = 0), Q = new m.Buf8(Wt.w_size), m.arraySet(Q, Jt, st - Wt.w_size, Wt.w_size, 0), Jt = Q, st = Wt.w_size), ie = W.avail_in, Kt = W.next_in, z = W.input, W.avail_in = st, W.next_in = 0, W.input = Jt, $e(Wt); Wt.lookahead >= K; ) {
          for (pt = Wt.strstart, dt = Wt.lookahead - (K - 1); Wt.ins_h = (Wt.ins_h << Wt.hash_shift ^ Wt.window[pt + K - 1]) & Wt.hash_mask, Wt.prev[pt & Wt.w_mask] = Wt.head[Wt.ins_h], Wt.head[Wt.ins_h] = pt, pt++, --dt; )
            ;
          Wt.strstart = pt, Wt.lookahead = K - 1, $e(Wt);
        }
        return Wt.strstart += Wt.lookahead, Wt.block_start = Wt.strstart, Wt.insert = Wt.lookahead, Wt.lookahead = 0, Wt.match_length = Wt.prev_length = K - 1, Wt.match_available = 0, W.next_in = Kt, W.input = z, W.avail_in = ie, Wt.wrap = Dt, D;
      }, d.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(s, c, d) {
      c.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(s, c, d) {
      c.exports = function(u, m) {
        var g, _, S, C, O, k, D, F, E, L, T, M, R, b, U, N, j, J, K, ct, It, et, _t, G, Pt;
        g = u.state, _ = u.next_in, G = u.input, S = _ + (u.avail_in - 5), C = u.next_out, Pt = u.output, O = C - (m - u.avail_out), k = C + (u.avail_out - 257), D = g.dmax, F = g.wsize, E = g.whave, L = g.wnext, T = g.window, M = g.hold, R = g.bits, b = g.lencode, U = g.distcode, N = (1 << g.lenbits) - 1, j = (1 << g.distbits) - 1;
        t:
          do {
            R < 15 && (M += G[_++] << R, R += 8, M += G[_++] << R, R += 8), J = b[M & N];
            e:
              for (; ; ) {
                if (M >>>= K = J >>> 24, R -= K, (K = J >>> 16 & 255) === 0)
                  Pt[C++] = 65535 & J;
                else {
                  if (!(16 & K)) {
                    if (!(64 & K)) {
                      J = b[(65535 & J) + (M & (1 << K) - 1)];
                      continue e;
                    }
                    if (32 & K) {
                      g.mode = 12;
                      break t;
                    }
                    u.msg = "invalid literal/length code", g.mode = 30;
                    break t;
                  }
                  ct = 65535 & J, (K &= 15) && (R < K && (M += G[_++] << R, R += 8), ct += M & (1 << K) - 1, M >>>= K, R -= K), R < 15 && (M += G[_++] << R, R += 8, M += G[_++] << R, R += 8), J = U[M & j];
                  i:
                    for (; ; ) {
                      if (M >>>= K = J >>> 24, R -= K, !(16 & (K = J >>> 16 & 255))) {
                        if (!(64 & K)) {
                          J = U[(65535 & J) + (M & (1 << K) - 1)];
                          continue i;
                        }
                        u.msg = "invalid distance code", g.mode = 30;
                        break t;
                      }
                      if (It = 65535 & J, R < (K &= 15) && (M += G[_++] << R, (R += 8) < K && (M += G[_++] << R, R += 8)), D < (It += M & (1 << K) - 1)) {
                        u.msg = "invalid distance too far back", g.mode = 30;
                        break t;
                      }
                      if (M >>>= K, R -= K, (K = C - O) < It) {
                        if (E < (K = It - K) && g.sane) {
                          u.msg = "invalid distance too far back", g.mode = 30;
                          break t;
                        }
                        if (_t = T, (et = 0) === L) {
                          if (et += F - K, K < ct) {
                            for (ct -= K; Pt[C++] = T[et++], --K; )
                              ;
                            et = C - It, _t = Pt;
                          }
                        } else if (L < K) {
                          if (et += F + L - K, (K -= L) < ct) {
                            for (ct -= K; Pt[C++] = T[et++], --K; )
                              ;
                            if (et = 0, L < ct) {
                              for (ct -= K = L; Pt[C++] = T[et++], --K; )
                                ;
                              et = C - It, _t = Pt;
                            }
                          }
                        } else if (et += L - K, K < ct) {
                          for (ct -= K; Pt[C++] = T[et++], --K; )
                            ;
                          et = C - It, _t = Pt;
                        }
                        for (; 2 < ct; )
                          Pt[C++] = _t[et++], Pt[C++] = _t[et++], Pt[C++] = _t[et++], ct -= 3;
                        ct && (Pt[C++] = _t[et++], 1 < ct && (Pt[C++] = _t[et++]));
                      } else {
                        for (et = C - It; Pt[C++] = Pt[et++], Pt[C++] = Pt[et++], Pt[C++] = Pt[et++], 2 < (ct -= 3); )
                          ;
                        ct && (Pt[C++] = Pt[et++], 1 < ct && (Pt[C++] = Pt[et++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (_ < S && C < k);
        _ -= ct = R >> 3, M &= (1 << (R -= ct << 3)) - 1, u.next_in = _, u.next_out = C, u.avail_in = _ < S ? S - _ + 5 : 5 - (_ - S), u.avail_out = C < k ? k - C + 257 : 257 - (C - k), g.hold = M, g.bits = R;
      };
    }, {}], 49: [function(s, c, d) {
      var u = s("../utils/common"), m = s("./adler32"), g = s("./crc32"), _ = s("./inffast"), S = s("./inftrees"), C = 1, O = 2, k = 0, D = -2, F = 1, E = 852, L = 592;
      function T(et) {
        return (et >>> 24 & 255) + (et >>> 8 & 65280) + ((65280 & et) << 8) + ((255 & et) << 24);
      }
      function M() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new u.Buf16(320), this.work = new u.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function R(et) {
        var _t;
        return et && et.state ? (_t = et.state, et.total_in = et.total_out = _t.total = 0, et.msg = "", _t.wrap && (et.adler = 1 & _t.wrap), _t.mode = F, _t.last = 0, _t.havedict = 0, _t.dmax = 32768, _t.head = null, _t.hold = 0, _t.bits = 0, _t.lencode = _t.lendyn = new u.Buf32(E), _t.distcode = _t.distdyn = new u.Buf32(L), _t.sane = 1, _t.back = -1, k) : D;
      }
      function b(et) {
        var _t;
        return et && et.state ? ((_t = et.state).wsize = 0, _t.whave = 0, _t.wnext = 0, R(et)) : D;
      }
      function U(et, _t) {
        var G, Pt;
        return et && et.state ? (Pt = et.state, _t < 0 ? (G = 0, _t = -_t) : (G = 1 + (_t >> 4), _t < 48 && (_t &= 15)), _t && (_t < 8 || 15 < _t) ? D : (Pt.window !== null && Pt.wbits !== _t && (Pt.window = null), Pt.wrap = G, Pt.wbits = _t, b(et))) : D;
      }
      function N(et, _t) {
        var G, Pt;
        return et ? (Pt = new M(), (et.state = Pt).window = null, (G = U(et, _t)) !== k && (et.state = null), G) : D;
      }
      var j, J, K = !0;
      function ct(et) {
        if (K) {
          var _t;
          for (j = new u.Buf32(512), J = new u.Buf32(32), _t = 0; _t < 144; )
            et.lens[_t++] = 8;
          for (; _t < 256; )
            et.lens[_t++] = 9;
          for (; _t < 280; )
            et.lens[_t++] = 7;
          for (; _t < 288; )
            et.lens[_t++] = 8;
          for (S(C, et.lens, 0, 288, j, 0, et.work, { bits: 9 }), _t = 0; _t < 32; )
            et.lens[_t++] = 5;
          S(O, et.lens, 0, 32, J, 0, et.work, { bits: 5 }), K = !1;
        }
        et.lencode = j, et.lenbits = 9, et.distcode = J, et.distbits = 5;
      }
      function It(et, _t, G, Pt) {
        var Et, At = et.state;
        return At.window === null && (At.wsize = 1 << At.wbits, At.wnext = 0, At.whave = 0, At.window = new u.Buf8(At.wsize)), Pt >= At.wsize ? (u.arraySet(At.window, _t, G - At.wsize, At.wsize, 0), At.wnext = 0, At.whave = At.wsize) : (Pt < (Et = At.wsize - At.wnext) && (Et = Pt), u.arraySet(At.window, _t, G - Pt, Et, At.wnext), (Pt -= Et) ? (u.arraySet(At.window, _t, G - Pt, Pt, 0), At.wnext = Pt, At.whave = At.wsize) : (At.wnext += Et, At.wnext === At.wsize && (At.wnext = 0), At.whave < At.wsize && (At.whave += Et))), 0;
      }
      d.inflateReset = b, d.inflateReset2 = U, d.inflateResetKeep = R, d.inflateInit = function(et) {
        return N(et, 15);
      }, d.inflateInit2 = N, d.inflate = function(et, _t) {
        var G, Pt, Et, At, fe, re, Ft, Ot, Bt, ke, ce, Yt, $e, Li, Oe, Ge, pi, Ri, cn, Ji, W, Jt, Wt, pt, dt = 0, Dt = new u.Buf8(4), ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!et || !et.state || !et.output || !et.input && et.avail_in !== 0)
          return D;
        (G = et.state).mode === 12 && (G.mode = 13), fe = et.next_out, Et = et.output, Ft = et.avail_out, At = et.next_in, Pt = et.input, re = et.avail_in, Ot = G.hold, Bt = G.bits, ke = re, ce = Ft, Jt = k;
        t:
          for (; ; )
            switch (G.mode) {
              case F:
                if (G.wrap === 0) {
                  G.mode = 13;
                  break;
                }
                for (; Bt < 16; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                if (2 & G.wrap && Ot === 35615) {
                  Dt[G.check = 0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = g(G.check, Dt, 2, 0), Bt = Ot = 0, G.mode = 2;
                  break;
                }
                if (G.flags = 0, G.head && (G.head.done = !1), !(1 & G.wrap) || (((255 & Ot) << 8) + (Ot >> 8)) % 31) {
                  et.msg = "incorrect header check", G.mode = 30;
                  break;
                }
                if ((15 & Ot) != 8) {
                  et.msg = "unknown compression method", G.mode = 30;
                  break;
                }
                if (Bt -= 4, W = 8 + (15 & (Ot >>>= 4)), G.wbits === 0)
                  G.wbits = W;
                else if (W > G.wbits) {
                  et.msg = "invalid window size", G.mode = 30;
                  break;
                }
                G.dmax = 1 << W, et.adler = G.check = 1, G.mode = 512 & Ot ? 10 : 12, Bt = Ot = 0;
                break;
              case 2:
                for (; Bt < 16; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                if (G.flags = Ot, (255 & G.flags) != 8) {
                  et.msg = "unknown compression method", G.mode = 30;
                  break;
                }
                if (57344 & G.flags) {
                  et.msg = "unknown header flags set", G.mode = 30;
                  break;
                }
                G.head && (G.head.text = Ot >> 8 & 1), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = g(G.check, Dt, 2, 0)), Bt = Ot = 0, G.mode = 3;
              case 3:
                for (; Bt < 32; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                G.head && (G.head.time = Ot), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, Dt[2] = Ot >>> 16 & 255, Dt[3] = Ot >>> 24 & 255, G.check = g(G.check, Dt, 4, 0)), Bt = Ot = 0, G.mode = 4;
              case 4:
                for (; Bt < 16; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                G.head && (G.head.xflags = 255 & Ot, G.head.os = Ot >> 8), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = g(G.check, Dt, 2, 0)), Bt = Ot = 0, G.mode = 5;
              case 5:
                if (1024 & G.flags) {
                  for (; Bt < 16; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  G.length = Ot, G.head && (G.head.extra_len = Ot), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = g(G.check, Dt, 2, 0)), Bt = Ot = 0;
                } else
                  G.head && (G.head.extra = null);
                G.mode = 6;
              case 6:
                if (1024 & G.flags && (re < (Yt = G.length) && (Yt = re), Yt && (G.head && (W = G.head.extra_len - G.length, G.head.extra || (G.head.extra = new Array(G.head.extra_len)), u.arraySet(G.head.extra, Pt, At, Yt, W)), 512 & G.flags && (G.check = g(G.check, Pt, Yt, At)), re -= Yt, At += Yt, G.length -= Yt), G.length))
                  break t;
                G.length = 0, G.mode = 7;
              case 7:
                if (2048 & G.flags) {
                  if (re === 0)
                    break t;
                  for (Yt = 0; W = Pt[At + Yt++], G.head && W && G.length < 65536 && (G.head.name += String.fromCharCode(W)), W && Yt < re; )
                    ;
                  if (512 & G.flags && (G.check = g(G.check, Pt, Yt, At)), re -= Yt, At += Yt, W)
                    break t;
                } else
                  G.head && (G.head.name = null);
                G.length = 0, G.mode = 8;
              case 8:
                if (4096 & G.flags) {
                  if (re === 0)
                    break t;
                  for (Yt = 0; W = Pt[At + Yt++], G.head && W && G.length < 65536 && (G.head.comment += String.fromCharCode(W)), W && Yt < re; )
                    ;
                  if (512 & G.flags && (G.check = g(G.check, Pt, Yt, At)), re -= Yt, At += Yt, W)
                    break t;
                } else
                  G.head && (G.head.comment = null);
                G.mode = 9;
              case 9:
                if (512 & G.flags) {
                  for (; Bt < 16; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  if (Ot !== (65535 & G.check)) {
                    et.msg = "header crc mismatch", G.mode = 30;
                    break;
                  }
                  Bt = Ot = 0;
                }
                G.head && (G.head.hcrc = G.flags >> 9 & 1, G.head.done = !0), et.adler = G.check = 0, G.mode = 12;
                break;
              case 10:
                for (; Bt < 32; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                et.adler = G.check = T(Ot), Bt = Ot = 0, G.mode = 11;
              case 11:
                if (G.havedict === 0)
                  return et.next_out = fe, et.avail_out = Ft, et.next_in = At, et.avail_in = re, G.hold = Ot, G.bits = Bt, 2;
                et.adler = G.check = 1, G.mode = 12;
              case 12:
                if (_t === 5 || _t === 6)
                  break t;
              case 13:
                if (G.last) {
                  Ot >>>= 7 & Bt, Bt -= 7 & Bt, G.mode = 27;
                  break;
                }
                for (; Bt < 3; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                switch (G.last = 1 & Ot, Bt -= 1, 3 & (Ot >>>= 1)) {
                  case 0:
                    G.mode = 14;
                    break;
                  case 1:
                    if (ct(G), G.mode = 20, _t !== 6)
                      break;
                    Ot >>>= 2, Bt -= 2;
                    break t;
                  case 2:
                    G.mode = 17;
                    break;
                  case 3:
                    et.msg = "invalid block type", G.mode = 30;
                }
                Ot >>>= 2, Bt -= 2;
                break;
              case 14:
                for (Ot >>>= 7 & Bt, Bt -= 7 & Bt; Bt < 32; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                if ((65535 & Ot) != (Ot >>> 16 ^ 65535)) {
                  et.msg = "invalid stored block lengths", G.mode = 30;
                  break;
                }
                if (G.length = 65535 & Ot, Bt = Ot = 0, G.mode = 15, _t === 6)
                  break t;
              case 15:
                G.mode = 16;
              case 16:
                if (Yt = G.length) {
                  if (re < Yt && (Yt = re), Ft < Yt && (Yt = Ft), Yt === 0)
                    break t;
                  u.arraySet(Et, Pt, At, Yt, fe), re -= Yt, At += Yt, Ft -= Yt, fe += Yt, G.length -= Yt;
                  break;
                }
                G.mode = 12;
                break;
              case 17:
                for (; Bt < 14; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                if (G.nlen = 257 + (31 & Ot), Ot >>>= 5, Bt -= 5, G.ndist = 1 + (31 & Ot), Ot >>>= 5, Bt -= 5, G.ncode = 4 + (15 & Ot), Ot >>>= 4, Bt -= 4, 286 < G.nlen || 30 < G.ndist) {
                  et.msg = "too many length or distance symbols", G.mode = 30;
                  break;
                }
                G.have = 0, G.mode = 18;
              case 18:
                for (; G.have < G.ncode; ) {
                  for (; Bt < 3; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  G.lens[ie[G.have++]] = 7 & Ot, Ot >>>= 3, Bt -= 3;
                }
                for (; G.have < 19; )
                  G.lens[ie[G.have++]] = 0;
                if (G.lencode = G.lendyn, G.lenbits = 7, Wt = { bits: G.lenbits }, Jt = S(0, G.lens, 0, 19, G.lencode, 0, G.work, Wt), G.lenbits = Wt.bits, Jt) {
                  et.msg = "invalid code lengths set", G.mode = 30;
                  break;
                }
                G.have = 0, G.mode = 19;
              case 19:
                for (; G.have < G.nlen + G.ndist; ) {
                  for (; Ge = (dt = G.lencode[Ot & (1 << G.lenbits) - 1]) >>> 16 & 255, pi = 65535 & dt, !((Oe = dt >>> 24) <= Bt); ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  if (pi < 16)
                    Ot >>>= Oe, Bt -= Oe, G.lens[G.have++] = pi;
                  else {
                    if (pi === 16) {
                      for (pt = Oe + 2; Bt < pt; ) {
                        if (re === 0)
                          break t;
                        re--, Ot += Pt[At++] << Bt, Bt += 8;
                      }
                      if (Ot >>>= Oe, Bt -= Oe, G.have === 0) {
                        et.msg = "invalid bit length repeat", G.mode = 30;
                        break;
                      }
                      W = G.lens[G.have - 1], Yt = 3 + (3 & Ot), Ot >>>= 2, Bt -= 2;
                    } else if (pi === 17) {
                      for (pt = Oe + 3; Bt < pt; ) {
                        if (re === 0)
                          break t;
                        re--, Ot += Pt[At++] << Bt, Bt += 8;
                      }
                      Bt -= Oe, W = 0, Yt = 3 + (7 & (Ot >>>= Oe)), Ot >>>= 3, Bt -= 3;
                    } else {
                      for (pt = Oe + 7; Bt < pt; ) {
                        if (re === 0)
                          break t;
                        re--, Ot += Pt[At++] << Bt, Bt += 8;
                      }
                      Bt -= Oe, W = 0, Yt = 11 + (127 & (Ot >>>= Oe)), Ot >>>= 7, Bt -= 7;
                    }
                    if (G.have + Yt > G.nlen + G.ndist) {
                      et.msg = "invalid bit length repeat", G.mode = 30;
                      break;
                    }
                    for (; Yt--; )
                      G.lens[G.have++] = W;
                  }
                }
                if (G.mode === 30)
                  break;
                if (G.lens[256] === 0) {
                  et.msg = "invalid code -- missing end-of-block", G.mode = 30;
                  break;
                }
                if (G.lenbits = 9, Wt = { bits: G.lenbits }, Jt = S(C, G.lens, 0, G.nlen, G.lencode, 0, G.work, Wt), G.lenbits = Wt.bits, Jt) {
                  et.msg = "invalid literal/lengths set", G.mode = 30;
                  break;
                }
                if (G.distbits = 6, G.distcode = G.distdyn, Wt = { bits: G.distbits }, Jt = S(O, G.lens, G.nlen, G.ndist, G.distcode, 0, G.work, Wt), G.distbits = Wt.bits, Jt) {
                  et.msg = "invalid distances set", G.mode = 30;
                  break;
                }
                if (G.mode = 20, _t === 6)
                  break t;
              case 20:
                G.mode = 21;
              case 21:
                if (6 <= re && 258 <= Ft) {
                  et.next_out = fe, et.avail_out = Ft, et.next_in = At, et.avail_in = re, G.hold = Ot, G.bits = Bt, _(et, ce), fe = et.next_out, Et = et.output, Ft = et.avail_out, At = et.next_in, Pt = et.input, re = et.avail_in, Ot = G.hold, Bt = G.bits, G.mode === 12 && (G.back = -1);
                  break;
                }
                for (G.back = 0; Ge = (dt = G.lencode[Ot & (1 << G.lenbits) - 1]) >>> 16 & 255, pi = 65535 & dt, !((Oe = dt >>> 24) <= Bt); ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                if (Ge && !(240 & Ge)) {
                  for (Ri = Oe, cn = Ge, Ji = pi; Ge = (dt = G.lencode[Ji + ((Ot & (1 << Ri + cn) - 1) >> Ri)]) >>> 16 & 255, pi = 65535 & dt, !(Ri + (Oe = dt >>> 24) <= Bt); ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  Ot >>>= Ri, Bt -= Ri, G.back += Ri;
                }
                if (Ot >>>= Oe, Bt -= Oe, G.back += Oe, G.length = pi, Ge === 0) {
                  G.mode = 26;
                  break;
                }
                if (32 & Ge) {
                  G.back = -1, G.mode = 12;
                  break;
                }
                if (64 & Ge) {
                  et.msg = "invalid literal/length code", G.mode = 30;
                  break;
                }
                G.extra = 15 & Ge, G.mode = 22;
              case 22:
                if (G.extra) {
                  for (pt = G.extra; Bt < pt; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  G.length += Ot & (1 << G.extra) - 1, Ot >>>= G.extra, Bt -= G.extra, G.back += G.extra;
                }
                G.was = G.length, G.mode = 23;
              case 23:
                for (; Ge = (dt = G.distcode[Ot & (1 << G.distbits) - 1]) >>> 16 & 255, pi = 65535 & dt, !((Oe = dt >>> 24) <= Bt); ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[At++] << Bt, Bt += 8;
                }
                if (!(240 & Ge)) {
                  for (Ri = Oe, cn = Ge, Ji = pi; Ge = (dt = G.distcode[Ji + ((Ot & (1 << Ri + cn) - 1) >> Ri)]) >>> 16 & 255, pi = 65535 & dt, !(Ri + (Oe = dt >>> 24) <= Bt); ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  Ot >>>= Ri, Bt -= Ri, G.back += Ri;
                }
                if (Ot >>>= Oe, Bt -= Oe, G.back += Oe, 64 & Ge) {
                  et.msg = "invalid distance code", G.mode = 30;
                  break;
                }
                G.offset = pi, G.extra = 15 & Ge, G.mode = 24;
              case 24:
                if (G.extra) {
                  for (pt = G.extra; Bt < pt; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  G.offset += Ot & (1 << G.extra) - 1, Ot >>>= G.extra, Bt -= G.extra, G.back += G.extra;
                }
                if (G.offset > G.dmax) {
                  et.msg = "invalid distance too far back", G.mode = 30;
                  break;
                }
                G.mode = 25;
              case 25:
                if (Ft === 0)
                  break t;
                if (Yt = ce - Ft, G.offset > Yt) {
                  if ((Yt = G.offset - Yt) > G.whave && G.sane) {
                    et.msg = "invalid distance too far back", G.mode = 30;
                    break;
                  }
                  $e = Yt > G.wnext ? (Yt -= G.wnext, G.wsize - Yt) : G.wnext - Yt, Yt > G.length && (Yt = G.length), Li = G.window;
                } else
                  Li = Et, $e = fe - G.offset, Yt = G.length;
                for (Ft < Yt && (Yt = Ft), Ft -= Yt, G.length -= Yt; Et[fe++] = Li[$e++], --Yt; )
                  ;
                G.length === 0 && (G.mode = 21);
                break;
              case 26:
                if (Ft === 0)
                  break t;
                Et[fe++] = G.length, Ft--, G.mode = 21;
                break;
              case 27:
                if (G.wrap) {
                  for (; Bt < 32; ) {
                    if (re === 0)
                      break t;
                    re--, Ot |= Pt[At++] << Bt, Bt += 8;
                  }
                  if (ce -= Ft, et.total_out += ce, G.total += ce, ce && (et.adler = G.check = G.flags ? g(G.check, Et, ce, fe - ce) : m(G.check, Et, ce, fe - ce)), ce = Ft, (G.flags ? Ot : T(Ot)) !== G.check) {
                    et.msg = "incorrect data check", G.mode = 30;
                    break;
                  }
                  Bt = Ot = 0;
                }
                G.mode = 28;
              case 28:
                if (G.wrap && G.flags) {
                  for (; Bt < 32; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[At++] << Bt, Bt += 8;
                  }
                  if (Ot !== (4294967295 & G.total)) {
                    et.msg = "incorrect length check", G.mode = 30;
                    break;
                  }
                  Bt = Ot = 0;
                }
                G.mode = 29;
              case 29:
                Jt = 1;
                break t;
              case 30:
                Jt = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return D;
            }
        return et.next_out = fe, et.avail_out = Ft, et.next_in = At, et.avail_in = re, G.hold = Ot, G.bits = Bt, (G.wsize || ce !== et.avail_out && G.mode < 30 && (G.mode < 27 || _t !== 4)) && It(et, et.output, et.next_out, ce - et.avail_out) ? (G.mode = 31, -4) : (ke -= et.avail_in, ce -= et.avail_out, et.total_in += ke, et.total_out += ce, G.total += ce, G.wrap && ce && (et.adler = G.check = G.flags ? g(G.check, Et, ce, et.next_out - ce) : m(G.check, Et, ce, et.next_out - ce)), et.data_type = G.bits + (G.last ? 64 : 0) + (G.mode === 12 ? 128 : 0) + (G.mode === 20 || G.mode === 15 ? 256 : 0), (ke == 0 && ce === 0 || _t === 4) && Jt === k && (Jt = -5), Jt);
      }, d.inflateEnd = function(et) {
        if (!et || !et.state)
          return D;
        var _t = et.state;
        return _t.window && (_t.window = null), et.state = null, k;
      }, d.inflateGetHeader = function(et, _t) {
        var G;
        return et && et.state && 2 & (G = et.state).wrap ? ((G.head = _t).done = !1, k) : D;
      }, d.inflateSetDictionary = function(et, _t) {
        var G, Pt = _t.length;
        return et && et.state ? (G = et.state).wrap !== 0 && G.mode !== 11 ? D : G.mode === 11 && m(1, _t, Pt, 0) !== G.check ? -3 : It(et, _t, Pt, Pt) ? (G.mode = 31, -4) : (G.havedict = 1, k) : D;
      }, d.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(s, c, d) {
      var u = s("../utils/common"), m = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], g = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], _ = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], S = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      c.exports = function(C, O, k, D, F, E, L, T) {
        var M, R, b, U, N, j, J, K, ct, It = T.bits, et = 0, _t = 0, G = 0, Pt = 0, Et = 0, At = 0, fe = 0, re = 0, Ft = 0, Ot = 0, Bt = null, ke = 0, ce = new u.Buf16(16), Yt = new u.Buf16(16), $e = null, Li = 0;
        for (et = 0; et <= 15; et++)
          ce[et] = 0;
        for (_t = 0; _t < D; _t++)
          ce[O[k + _t]]++;
        for (Et = It, Pt = 15; 1 <= Pt && ce[Pt] === 0; Pt--)
          ;
        if (Pt < Et && (Et = Pt), Pt === 0)
          return F[E++] = 20971520, F[E++] = 20971520, T.bits = 1, 0;
        for (G = 1; G < Pt && ce[G] === 0; G++)
          ;
        for (Et < G && (Et = G), et = re = 1; et <= 15; et++)
          if (re <<= 1, (re -= ce[et]) < 0)
            return -1;
        if (0 < re && (C === 0 || Pt !== 1))
          return -1;
        for (Yt[1] = 0, et = 1; et < 15; et++)
          Yt[et + 1] = Yt[et] + ce[et];
        for (_t = 0; _t < D; _t++)
          O[k + _t] !== 0 && (L[Yt[O[k + _t]]++] = _t);
        if (j = C === 0 ? (Bt = $e = L, 19) : C === 1 ? (Bt = m, ke -= 257, $e = g, Li -= 257, 256) : (Bt = _, $e = S, -1), et = G, N = E, fe = _t = Ot = 0, b = -1, U = (Ft = 1 << (At = Et)) - 1, C === 1 && 852 < Ft || C === 2 && 592 < Ft)
          return 1;
        for (; ; ) {
          for (J = et - fe, ct = L[_t] < j ? (K = 0, L[_t]) : L[_t] > j ? (K = $e[Li + L[_t]], Bt[ke + L[_t]]) : (K = 96, 0), M = 1 << et - fe, G = R = 1 << At; F[N + (Ot >> fe) + (R -= M)] = J << 24 | K << 16 | ct | 0, R !== 0; )
            ;
          for (M = 1 << et - 1; Ot & M; )
            M >>= 1;
          if (M !== 0 ? (Ot &= M - 1, Ot += M) : Ot = 0, _t++, --ce[et] == 0) {
            if (et === Pt)
              break;
            et = O[k + L[_t]];
          }
          if (Et < et && (Ot & U) !== b) {
            for (fe === 0 && (fe = Et), N += G, re = 1 << (At = et - fe); At + fe < Pt && !((re -= ce[At + fe]) <= 0); )
              At++, re <<= 1;
            if (Ft += 1 << At, C === 1 && 852 < Ft || C === 2 && 592 < Ft)
              return 1;
            F[b = Ot & U] = Et << 24 | At << 16 | N - E | 0;
          }
        }
        return Ot !== 0 && (F[N + Ot] = et - fe << 24 | 64 << 16 | 0), T.bits = Et, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(s, c, d) {
      c.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(s, c, d) {
      var u = s("../utils/common"), m = 0, g = 1;
      function _(dt) {
        for (var Dt = dt.length; 0 <= --Dt; )
          dt[Dt] = 0;
      }
      var S = 0, C = 29, O = 256, k = O + 1 + C, D = 30, F = 19, E = 2 * k + 1, L = 15, T = 16, M = 7, R = 256, b = 16, U = 17, N = 18, j = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], J = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], K = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ct = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], It = new Array(2 * (k + 2));
      _(It);
      var et = new Array(2 * D);
      _(et);
      var _t = new Array(512);
      _(_t);
      var G = new Array(256);
      _(G);
      var Pt = new Array(C);
      _(Pt);
      var Et, At, fe, re = new Array(D);
      function Ft(dt, Dt, ie, Kt, z) {
        this.static_tree = dt, this.extra_bits = Dt, this.extra_base = ie, this.elems = Kt, this.max_length = z, this.has_stree = dt && dt.length;
      }
      function Ot(dt, Dt) {
        this.dyn_tree = dt, this.max_code = 0, this.stat_desc = Dt;
      }
      function Bt(dt) {
        return dt < 256 ? _t[dt] : _t[256 + (dt >>> 7)];
      }
      function ke(dt, Dt) {
        dt.pending_buf[dt.pending++] = 255 & Dt, dt.pending_buf[dt.pending++] = Dt >>> 8 & 255;
      }
      function ce(dt, Dt, ie) {
        dt.bi_valid > T - ie ? (dt.bi_buf |= Dt << dt.bi_valid & 65535, ke(dt, dt.bi_buf), dt.bi_buf = Dt >> T - dt.bi_valid, dt.bi_valid += ie - T) : (dt.bi_buf |= Dt << dt.bi_valid & 65535, dt.bi_valid += ie);
      }
      function Yt(dt, Dt, ie) {
        ce(dt, ie[2 * Dt], ie[2 * Dt + 1]);
      }
      function $e(dt, Dt) {
        for (var ie = 0; ie |= 1 & dt, dt >>>= 1, ie <<= 1, 0 < --Dt; )
          ;
        return ie >>> 1;
      }
      function Li(dt, Dt, ie) {
        var Kt, z, Q = new Array(L + 1), st = 0;
        for (Kt = 1; Kt <= L; Kt++)
          Q[Kt] = st = st + ie[Kt - 1] << 1;
        for (z = 0; z <= Dt; z++) {
          var nt = dt[2 * z + 1];
          nt !== 0 && (dt[2 * z] = $e(Q[nt]++, nt));
        }
      }
      function Oe(dt) {
        var Dt;
        for (Dt = 0; Dt < k; Dt++)
          dt.dyn_ltree[2 * Dt] = 0;
        for (Dt = 0; Dt < D; Dt++)
          dt.dyn_dtree[2 * Dt] = 0;
        for (Dt = 0; Dt < F; Dt++)
          dt.bl_tree[2 * Dt] = 0;
        dt.dyn_ltree[2 * R] = 1, dt.opt_len = dt.static_len = 0, dt.last_lit = dt.matches = 0;
      }
      function Ge(dt) {
        8 < dt.bi_valid ? ke(dt, dt.bi_buf) : 0 < dt.bi_valid && (dt.pending_buf[dt.pending++] = dt.bi_buf), dt.bi_buf = 0, dt.bi_valid = 0;
      }
      function pi(dt, Dt, ie, Kt) {
        var z = 2 * Dt, Q = 2 * ie;
        return dt[z] < dt[Q] || dt[z] === dt[Q] && Kt[Dt] <= Kt[ie];
      }
      function Ri(dt, Dt, ie) {
        for (var Kt = dt.heap[ie], z = ie << 1; z <= dt.heap_len && (z < dt.heap_len && pi(Dt, dt.heap[z + 1], dt.heap[z], dt.depth) && z++, !pi(Dt, Kt, dt.heap[z], dt.depth)); )
          dt.heap[ie] = dt.heap[z], ie = z, z <<= 1;
        dt.heap[ie] = Kt;
      }
      function cn(dt, Dt, ie) {
        var Kt, z, Q, st, nt = 0;
        if (dt.last_lit !== 0)
          for (; Kt = dt.pending_buf[dt.d_buf + 2 * nt] << 8 | dt.pending_buf[dt.d_buf + 2 * nt + 1], z = dt.pending_buf[dt.l_buf + nt], nt++, Kt === 0 ? Yt(dt, z, Dt) : (Yt(dt, (Q = G[z]) + O + 1, Dt), (st = j[Q]) !== 0 && ce(dt, z -= Pt[Q], st), Yt(dt, Q = Bt(--Kt), ie), (st = J[Q]) !== 0 && ce(dt, Kt -= re[Q], st)), nt < dt.last_lit; )
            ;
        Yt(dt, R, Dt);
      }
      function Ji(dt, Dt) {
        var ie, Kt, z, Q = Dt.dyn_tree, st = Dt.stat_desc.static_tree, nt = Dt.stat_desc.has_stree, vt = Dt.stat_desc.elems, Gt = -1;
        for (dt.heap_len = 0, dt.heap_max = E, ie = 0; ie < vt; ie++)
          Q[2 * ie] !== 0 ? (dt.heap[++dt.heap_len] = Gt = ie, dt.depth[ie] = 0) : Q[2 * ie + 1] = 0;
        for (; dt.heap_len < 2; )
          Q[2 * (z = dt.heap[++dt.heap_len] = Gt < 2 ? ++Gt : 0)] = 1, dt.depth[z] = 0, dt.opt_len--, nt && (dt.static_len -= st[2 * z + 1]);
        for (Dt.max_code = Gt, ie = dt.heap_len >> 1; 1 <= ie; ie--)
          Ri(dt, Q, ie);
        for (z = vt; ie = dt.heap[1], dt.heap[1] = dt.heap[dt.heap_len--], Ri(dt, Q, 1), Kt = dt.heap[1], dt.heap[--dt.heap_max] = ie, dt.heap[--dt.heap_max] = Kt, Q[2 * z] = Q[2 * ie] + Q[2 * Kt], dt.depth[z] = (dt.depth[ie] >= dt.depth[Kt] ? dt.depth[ie] : dt.depth[Kt]) + 1, Q[2 * ie + 1] = Q[2 * Kt + 1] = z, dt.heap[1] = z++, Ri(dt, Q, 1), 2 <= dt.heap_len; )
          ;
        dt.heap[--dt.heap_max] = dt.heap[1], function(Xt, jt) {
          var Ne, Re, ge, we, vi, Mi, ni = jt.dyn_tree, Si = jt.max_code, Gr = jt.stat_desc.static_tree, er = jt.stat_desc.has_stree, rn = jt.stat_desc.extra_bits, Co = jt.stat_desc.extra_base, Oi = jt.stat_desc.max_length, Go = 0;
          for (we = 0; we <= L; we++)
            Xt.bl_count[we] = 0;
          for (ni[2 * Xt.heap[Xt.heap_max] + 1] = 0, Ne = Xt.heap_max + 1; Ne < E; Ne++)
            Oi < (we = ni[2 * ni[2 * (Re = Xt.heap[Ne]) + 1] + 1] + 1) && (we = Oi, Go++), ni[2 * Re + 1] = we, Si < Re || (Xt.bl_count[we]++, vi = 0, Co <= Re && (vi = rn[Re - Co]), Mi = ni[2 * Re], Xt.opt_len += Mi * (we + vi), er && (Xt.static_len += Mi * (Gr[2 * Re + 1] + vi)));
          if (Go !== 0) {
            do {
              for (we = Oi - 1; Xt.bl_count[we] === 0; )
                we--;
              Xt.bl_count[we]--, Xt.bl_count[we + 1] += 2, Xt.bl_count[Oi]--, Go -= 2;
            } while (0 < Go);
            for (we = Oi; we !== 0; we--)
              for (Re = Xt.bl_count[we]; Re !== 0; )
                Si < (ge = Xt.heap[--Ne]) || (ni[2 * ge + 1] !== we && (Xt.opt_len += (we - ni[2 * ge + 1]) * ni[2 * ge], ni[2 * ge + 1] = we), Re--);
          }
        }(dt, Dt), Li(Q, Gt, dt.bl_count);
      }
      function W(dt, Dt, ie) {
        var Kt, z, Q = -1, st = Dt[1], nt = 0, vt = 7, Gt = 4;
        for (st === 0 && (vt = 138, Gt = 3), Dt[2 * (ie + 1) + 1] = 65535, Kt = 0; Kt <= ie; Kt++)
          z = st, st = Dt[2 * (Kt + 1) + 1], ++nt < vt && z === st || (nt < Gt ? dt.bl_tree[2 * z] += nt : z !== 0 ? (z !== Q && dt.bl_tree[2 * z]++, dt.bl_tree[2 * b]++) : nt <= 10 ? dt.bl_tree[2 * U]++ : dt.bl_tree[2 * N]++, Q = z, Gt = (nt = 0) === st ? (vt = 138, 3) : z === st ? (vt = 6, 3) : (vt = 7, 4));
      }
      function Jt(dt, Dt, ie) {
        var Kt, z, Q = -1, st = Dt[1], nt = 0, vt = 7, Gt = 4;
        for (st === 0 && (vt = 138, Gt = 3), Kt = 0; Kt <= ie; Kt++)
          if (z = st, st = Dt[2 * (Kt + 1) + 1], !(++nt < vt && z === st)) {
            if (nt < Gt)
              for (; Yt(dt, z, dt.bl_tree), --nt != 0; )
                ;
            else
              z !== 0 ? (z !== Q && (Yt(dt, z, dt.bl_tree), nt--), Yt(dt, b, dt.bl_tree), ce(dt, nt - 3, 2)) : nt <= 10 ? (Yt(dt, U, dt.bl_tree), ce(dt, nt - 3, 3)) : (Yt(dt, N, dt.bl_tree), ce(dt, nt - 11, 7));
            Q = z, Gt = (nt = 0) === st ? (vt = 138, 3) : z === st ? (vt = 6, 3) : (vt = 7, 4);
          }
      }
      _(re);
      var Wt = !1;
      function pt(dt, Dt, ie, Kt) {
        ce(dt, (S << 1) + (Kt ? 1 : 0), 3), function(z, Q, st, nt) {
          Ge(z), nt && (ke(z, st), ke(z, ~st)), u.arraySet(z.pending_buf, z.window, Q, st, z.pending), z.pending += st;
        }(dt, Dt, ie, !0);
      }
      d._tr_init = function(dt) {
        Wt || (function() {
          var Dt, ie, Kt, z, Q, st = new Array(L + 1);
          for (z = Kt = 0; z < C - 1; z++)
            for (Pt[z] = Kt, Dt = 0; Dt < 1 << j[z]; Dt++)
              G[Kt++] = z;
          for (G[Kt - 1] = z, z = Q = 0; z < 16; z++)
            for (re[z] = Q, Dt = 0; Dt < 1 << J[z]; Dt++)
              _t[Q++] = z;
          for (Q >>= 7; z < D; z++)
            for (re[z] = Q << 7, Dt = 0; Dt < 1 << J[z] - 7; Dt++)
              _t[256 + Q++] = z;
          for (ie = 0; ie <= L; ie++)
            st[ie] = 0;
          for (Dt = 0; Dt <= 143; )
            It[2 * Dt + 1] = 8, Dt++, st[8]++;
          for (; Dt <= 255; )
            It[2 * Dt + 1] = 9, Dt++, st[9]++;
          for (; Dt <= 279; )
            It[2 * Dt + 1] = 7, Dt++, st[7]++;
          for (; Dt <= 287; )
            It[2 * Dt + 1] = 8, Dt++, st[8]++;
          for (Li(It, k + 1, st), Dt = 0; Dt < D; Dt++)
            et[2 * Dt + 1] = 5, et[2 * Dt] = $e(Dt, 5);
          Et = new Ft(It, j, O + 1, k, L), At = new Ft(et, J, 0, D, L), fe = new Ft(new Array(0), K, 0, F, M);
        }(), Wt = !0), dt.l_desc = new Ot(dt.dyn_ltree, Et), dt.d_desc = new Ot(dt.dyn_dtree, At), dt.bl_desc = new Ot(dt.bl_tree, fe), dt.bi_buf = 0, dt.bi_valid = 0, Oe(dt);
      }, d._tr_stored_block = pt, d._tr_flush_block = function(dt, Dt, ie, Kt) {
        var z, Q, st = 0;
        0 < dt.level ? (dt.strm.data_type === 2 && (dt.strm.data_type = function(nt) {
          var vt, Gt = 4093624447;
          for (vt = 0; vt <= 31; vt++, Gt >>>= 1)
            if (1 & Gt && nt.dyn_ltree[2 * vt] !== 0)
              return m;
          if (nt.dyn_ltree[18] !== 0 || nt.dyn_ltree[20] !== 0 || nt.dyn_ltree[26] !== 0)
            return g;
          for (vt = 32; vt < O; vt++)
            if (nt.dyn_ltree[2 * vt] !== 0)
              return g;
          return m;
        }(dt)), Ji(dt, dt.l_desc), Ji(dt, dt.d_desc), st = function(nt) {
          var vt;
          for (W(nt, nt.dyn_ltree, nt.l_desc.max_code), W(nt, nt.dyn_dtree, nt.d_desc.max_code), Ji(nt, nt.bl_desc), vt = F - 1; 3 <= vt && nt.bl_tree[2 * ct[vt] + 1] === 0; vt--)
            ;
          return nt.opt_len += 3 * (vt + 1) + 5 + 5 + 4, vt;
        }(dt), z = dt.opt_len + 3 + 7 >>> 3, (Q = dt.static_len + 3 + 7 >>> 3) <= z && (z = Q)) : z = Q = ie + 5, ie + 4 <= z && Dt !== -1 ? pt(dt, Dt, ie, Kt) : dt.strategy === 4 || Q === z ? (ce(dt, 2 + (Kt ? 1 : 0), 3), cn(dt, It, et)) : (ce(dt, 4 + (Kt ? 1 : 0), 3), function(nt, vt, Gt, Xt) {
          var jt;
          for (ce(nt, vt - 257, 5), ce(nt, Gt - 1, 5), ce(nt, Xt - 4, 4), jt = 0; jt < Xt; jt++)
            ce(nt, nt.bl_tree[2 * ct[jt] + 1], 3);
          Jt(nt, nt.dyn_ltree, vt - 1), Jt(nt, nt.dyn_dtree, Gt - 1);
        }(dt, dt.l_desc.max_code + 1, dt.d_desc.max_code + 1, st + 1), cn(dt, dt.dyn_ltree, dt.dyn_dtree)), Oe(dt), Kt && Ge(dt);
      }, d._tr_tally = function(dt, Dt, ie) {
        return dt.pending_buf[dt.d_buf + 2 * dt.last_lit] = Dt >>> 8 & 255, dt.pending_buf[dt.d_buf + 2 * dt.last_lit + 1] = 255 & Dt, dt.pending_buf[dt.l_buf + dt.last_lit] = 255 & ie, dt.last_lit++, Dt === 0 ? dt.dyn_ltree[2 * ie]++ : (dt.matches++, Dt--, dt.dyn_ltree[2 * (G[ie] + O + 1)]++, dt.dyn_dtree[2 * Bt(Dt)]++), dt.last_lit === dt.lit_bufsize - 1;
      }, d._tr_align = function(dt) {
        ce(dt, 2, 3), Yt(dt, R, It), function(Dt) {
          Dt.bi_valid === 16 ? (ke(Dt, Dt.bi_buf), Dt.bi_buf = 0, Dt.bi_valid = 0) : 8 <= Dt.bi_valid && (Dt.pending_buf[Dt.pending++] = 255 & Dt.bi_buf, Dt.bi_buf >>= 8, Dt.bi_valid -= 8);
        }(dt);
      };
    }, { "../utils/common": 41 }], 53: [function(s, c, d) {
      c.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(s, c, d) {
      (function(u) {
        (function(m, g) {
          if (!m.setImmediate) {
            var _, S, C, O, k = 1, D = {}, F = !1, E = m.document, L = Object.getPrototypeOf && Object.getPrototypeOf(m);
            L = L && L.setTimeout ? L : m, _ = {}.toString.call(m.process) === "[object process]" ? function(b) {
              process.nextTick(function() {
                M(b);
              });
            } : function() {
              if (m.postMessage && !m.importScripts) {
                var b = !0, U = m.onmessage;
                return m.onmessage = function() {
                  b = !1;
                }, m.postMessage("", "*"), m.onmessage = U, b;
              }
            }() ? (O = "setImmediate$" + Math.random() + "$", m.addEventListener ? m.addEventListener("message", R, !1) : m.attachEvent("onmessage", R), function(b) {
              m.postMessage(O + b, "*");
            }) : m.MessageChannel ? ((C = new MessageChannel()).port1.onmessage = function(b) {
              M(b.data);
            }, function(b) {
              C.port2.postMessage(b);
            }) : E && "onreadystatechange" in E.createElement("script") ? (S = E.documentElement, function(b) {
              var U = E.createElement("script");
              U.onreadystatechange = function() {
                M(b), U.onreadystatechange = null, S.removeChild(U), U = null;
              }, S.appendChild(U);
            }) : function(b) {
              setTimeout(M, 0, b);
            }, L.setImmediate = function(b) {
              typeof b != "function" && (b = new Function("" + b));
              for (var U = new Array(arguments.length - 1), N = 0; N < U.length; N++)
                U[N] = arguments[N + 1];
              var j = { callback: b, args: U };
              return D[k] = j, _(k), k++;
            }, L.clearImmediate = T;
          }
          function T(b) {
            delete D[b];
          }
          function M(b) {
            if (F)
              setTimeout(M, 0, b);
            else {
              var U = D[b];
              if (U) {
                F = !0;
                try {
                  (function(N) {
                    var j = N.callback, J = N.args;
                    switch (J.length) {
                      case 0:
                        j();
                        break;
                      case 1:
                        j(J[0]);
                        break;
                      case 2:
                        j(J[0], J[1]);
                        break;
                      case 3:
                        j(J[0], J[1], J[2]);
                        break;
                      default:
                        j.apply(g, J);
                    }
                  })(U);
                } finally {
                  T(b), F = !1;
                }
              }
            }
          }
          function R(b) {
            b.source === m && typeof b.data == "string" && b.data.indexOf(O) === 0 && M(+b.data.slice(O.length));
          }
        })(typeof self > "u" ? u === void 0 ? this : u : self);
      }).call(this, typeof zr < "u" ? zr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Gp);
var Jy = Gp.exports;
const $y = /* @__PURE__ */ af(Jy);
var Hp = { exports: {} };
(function(x, a) {
  (function(s, c) {
    c();
  })(zr, function() {
    function s(S, C) {
      return typeof C > "u" ? C = { autoBom: !1 } : typeof C != "object" && (console.warn("Deprecated: Expected third argument to be a object"), C = { autoBom: !C }), C.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(S.type) ? new Blob(["\uFEFF", S], { type: S.type }) : S;
    }
    function c(S, C, O) {
      var k = new XMLHttpRequest();
      k.open("GET", S), k.responseType = "blob", k.onload = function() {
        _(k.response, C, O);
      }, k.onerror = function() {
        console.error("could not download file");
      }, k.send();
    }
    function d(S) {
      var C = new XMLHttpRequest();
      C.open("HEAD", S, !1);
      try {
        C.send();
      } catch {
      }
      return 200 <= C.status && 299 >= C.status;
    }
    function u(S) {
      try {
        S.dispatchEvent(new MouseEvent("click"));
      } catch {
        var C = document.createEvent("MouseEvents");
        C.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), S.dispatchEvent(C);
      }
    }
    var m = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof zr == "object" && zr.global === zr ? zr : void 0, g = m.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), _ = m.saveAs || (typeof window != "object" || window !== m ? function() {
    } : "download" in HTMLAnchorElement.prototype && !g ? function(S, C, O) {
      var k = m.URL || m.webkitURL, D = document.createElement("a");
      C = C || S.name || "download", D.download = C, D.rel = "noopener", typeof S == "string" ? (D.href = S, D.origin === location.origin ? u(D) : d(D.href) ? c(S, C, O) : u(D, D.target = "_blank")) : (D.href = k.createObjectURL(S), setTimeout(function() {
        k.revokeObjectURL(D.href);
      }, 4e4), setTimeout(function() {
        u(D);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(S, C, O) {
      if (C = C || S.name || "download", typeof S != "string")
        navigator.msSaveOrOpenBlob(s(S, O), C);
      else if (d(S))
        c(S, C, O);
      else {
        var k = document.createElement("a");
        k.href = S, k.target = "_blank", setTimeout(function() {
          u(k);
        });
      }
    } : function(S, C, O, k) {
      if (k = k || open("", "_blank"), k && (k.document.title = k.document.body.innerText = "downloading..."), typeof S == "string")
        return c(S, C, O);
      var D = S.type === "application/octet-stream", F = /constructor/i.test(m.HTMLElement) || m.safari, E = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((E || D && F || g) && typeof FileReader < "u") {
        var L = new FileReader();
        L.onloadend = function() {
          var R = L.result;
          R = E ? R : R.replace(/^data:[^;]*;/, "data:attachment/file;"), k ? k.location.href = R : location = R, k = null;
        }, L.readAsDataURL(S);
      } else {
        var T = m.URL || m.webkitURL, M = T.createObjectURL(S);
        k ? k.location = M : location.href = M, k = null, setTimeout(function() {
          T.revokeObjectURL(M);
        }, 4e4);
      }
    });
    m.saveAs = _.saveAs = _, x.exports = _;
  });
})(Hp);
var Ky = Hp.exports;
const Qy = /* @__PURE__ */ af(Ky);
class M1 {
  constructor(a, s) {
    window.mars3d ? (this.panoramicViewClass = s, this.coordinate = [
      {
        heading: 0,
        pitch: 0,
        stop: 5
      },
      {
        heading: 90,
        pitch: 0,
        stop: 5
      },
      {
        heading: 180,
        pitch: 0,
        stop: 5
      },
      {
        heading: 270,
        pitch: 0,
        stop: 5
      },
      {
        heading: 0,
        pitch: 90,
        stop: 5
      },
      {
        heading: 0,
        pitch: -90,
        stop: 5
      }
    ], this.screenshotArray = [], this.events = {}, this.timestamp = 0, this.lat, this.lng, this.alt) : console.error("未引入指定插件");
  }
  /**
   * 开启全景图下载
   * @returns { any }
   */
  start(a = !0) {
    var s, c;
    if (a) {
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
      const d = document.getElementById("app"), u = window.innerHeight, m = document.getElementById("mars3dContainer");
      m && (m.style.width = u.toString() + "px", m.style.height = u.toString() + "px"), d !== null && d.classList.add(this.panoramicViewClass);
      let { lat: g, lng: _, alt: S } = window.map.getCameraView();
      this.lat = g, this.lng = _, this.alt = S, window.map.viewer.scene.camera.frustum.fov = window.Cesium.Math.PI_OVER_THREE * 1.5;
    }
    this.screenshotArray && this.coordinate ? this.coordinate[(s = this.screenshotArray) == null ? void 0 : s.length] ? window.map.setCameraView(
      {
        lat: this.lat,
        lng: this.lng,
        alt: this.alt,
        ...this.coordinate[(c = this.screenshotArray) == null ? void 0 : c.length]
      },
      {
        complete: () => {
          setTimeout(() => {
            var d;
            this.screenshot((d = this.screenshotArray) == null ? void 0 : d.length);
          }, 100);
        }
      }
    ) : (this.downloadImagesAsZip(), this.screenshotArray = []) : (console.error("初始化失效"), this.emit("state", {
      type: "error"
    }));
  }
  /**
   * 截图
   * @returns { any }
   */
  async screenshot(a) {
    const s = await window.map.expImage({ download: !1 }), c = window.map.container.getElementsByClassName(
      "cesium-viewer-cesiumWidgetContainer"
    ), d = await window.domtoimage.toPng(
      window.map.container,
      {
        filter: (u) => u !== c[0]
      }
    );
    this.mergeImage(s.image, d, s.width, s.height).then(
      (u) => {
        var _;
        let m = Number(a) + 1, g = {
          src: u,
          name: "全景图_" + this.timestamp + "_" + m + ".jpg"
        };
        this.emit("intercept", g), (_ = this.screenshotArray) == null || _.push(g), this.start(!1);
      }
    );
  }
  /**
   * 合成图片
   * @param {any} width
   * @param {any} height
   * @returns {any}
   */
  mergeImage(a, s, c, d) {
    return new Promise((u, m) => {
      const g = document.createElement("canvas");
      g.width = c, g.height = d;
      const _ = g.getContext("2d");
      if (g && _) {
        const S = new Image();
        S.crossOrigin = "Anonymous", S.onload = () => {
          _.drawImage(S, 0, 0, c, d);
          const C = new Image();
          C.crossOrigin = "Anonymous", C.onload = () => {
            _.drawImage(C, 0, 0, c, d);
            const O = g.toDataURL("image/png");
            u(O);
          }, C.src = s;
        }, S.src = a;
      } else
        m();
    });
  }
  /**
   * 下载图片
   * @returns {any}
   */
  download() {
    this.screenshotArray && this.screenshotArray.forEach((a) => {
      window.mars3d.Util.downloadBase64Image(a.name, a.src);
    });
  }
  /**
   * 下载压缩包
   * @returns
   */
  async downloadImagesAsZip() {
    if (this.screenshotArray) {
      const a = new $y();
      this.screenshotArray.forEach((c) => {
        const d = c.src.split(",")[1], u = atob(d), m = [];
        for (let S = 0; S < u.length; S += 1024) {
          const C = u.slice(S, S + 1024), O = new Array(C.length);
          for (let D = 0; D < C.length; D++)
            O[D] = C.charCodeAt(D);
          const k = new Uint8Array(O);
          m.push(k);
        }
        const g = new Blob(m, { type: "image/jpeg" }), _ = `${c.name}`;
        a.file(_, g, { binary: !0 });
      });
      const s = await a.generateAsync({ type: "blob" });
      Qy(s, "CHBIM-Panorama.zip"), this.emit("state", {
        type: "success",
        schedule: 100
      }), this.init();
    }
  }
  /**
   * 初始化
   */
  init() {
    const a = document.getElementById("app");
    a && a.classList.remove(this.panoramicViewClass);
    const s = document.getElementById("mars3dContainer");
    s && (s.style.width = "", s.style.height = "");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { Function } fn - 回调函数
   * @returns { any }
   */
  on(a, s) {
    this.events[a] ? this.events[a].push(s) : this.events[a] = [s];
  }
  /**
   * events
   * 事件触发
   * @param  { string } event - 事件名
   * @returns { any }
   */
  emit(a, ...s) {
    this.events[a] != null && this.events[a].forEach((c) => c(...s));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(a, s) {
    this.events[a] = this.events[a].filter(
      (c) => c !== s
    );
  }
}
function Vs(x) {
  if (x === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return x;
}
function Vp(x, a) {
  x.prototype = Object.create(a.prototype), x.prototype.constructor = x, x.__proto__ = a;
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var to = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, uh = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, lf, fr, un, So = 1e8, nn = 1 / So, Gc = Math.PI * 2, t_ = Gc / 4, e_ = 0, Wp = Math.sqrt, i_ = Math.cos, n_ = Math.sin, Yn = function(a) {
  return typeof a == "string";
}, An = function(a) {
  return typeof a == "function";
}, js = function(a) {
  return typeof a == "number";
}, hf = function(a) {
  return typeof a > "u";
}, hs = function(a) {
  return typeof a == "object";
}, kr = function(a) {
  return a !== !1;
}, uf = function() {
  return typeof window < "u";
}, ku = function(a) {
  return An(a) || Yn(a);
}, jp = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, pr = Array.isArray, Hc = /(?:-?\.?\d|\.)+/gi, Xp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, oh = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Lc = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, qp = /[+-]=-?[.\d]+/, Yp = /[^,'"\[\]\s]+/gi, r_ = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, yn, os, Vc, cf, eo = {}, Hu = {}, Zp, Jp = function(a) {
  return (Hu = bl(a, eo)) && Ur;
}, ff = function(a, s) {
  return console.warn("Invalid property", a, "set to", s, "Missing plugin? gsap.registerPlugin()");
}, Jh = function(a, s) {
  return !s && console.warn(a);
}, $p = function(a, s) {
  return a && (eo[a] = s) && Hu && (Hu[a] = s) || eo;
}, $h = function() {
  return 0;
}, o_ = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, Bu = {
  suppressEvents: !0,
  kill: !1
}, s_ = {
  suppressEvents: !0
}, pf = {}, Ra = [], Wc = {}, Kp, $r = {}, Rc = {}, wp = 30, Nu = [], df = "", mf = function(a) {
  var s = a[0], c, d;
  if (hs(s) || An(s) || (a = [a]), !(c = (s._gsap || {}).harness)) {
    for (d = Nu.length; d-- && !Nu[d].targetTest(s); )
      ;
    c = Nu[d];
  }
  for (d = a.length; d--; )
    a[d] && (a[d]._gsap || (a[d]._gsap = new Td(a[d], c))) || a.splice(d, 1);
  return a;
}, Tl = function(a) {
  return a._gsap || mf(Eo(a))[0]._gsap;
}, Qp = function(a, s, c) {
  return (c = a[s]) && An(c) ? a[s]() : hf(c) && a.getAttribute && a.getAttribute(s) || c;
}, Br = function(a, s) {
  return (a = a.split(",")).forEach(s) || a;
}, In = function(a) {
  return Math.round(a * 1e5) / 1e5 || 0;
}, qn = function(a) {
  return Math.round(a * 1e7) / 1e7 || 0;
}, ah = function(a, s) {
  var c = s.charAt(0), d = parseFloat(s.substr(2));
  return a = parseFloat(a), c === "+" ? a + d : c === "-" ? a - d : c === "*" ? a * d : a / d;
}, a_ = function(a, s) {
  for (var c = s.length, d = 0; a.indexOf(s[d]) < 0 && ++d < c; )
    ;
  return d < c;
}, Vu = function() {
  var a = Ra.length, s = Ra.slice(0), c, d;
  for (Wc = {}, Ra.length = 0, c = 0; c < a; c++)
    d = s[c], d && d._lazy && (d.render(d._lazy[0], d._lazy[1], !0)._lazy = 0);
}, td = function(a, s, c, d) {
  Ra.length && !fr && Vu(), a.render(s, c, d || fr && s < 0 && (a._initted || a._startAt)), Ra.length && !fr && Vu();
}, ed = function(a) {
  var s = parseFloat(a);
  return (s || s === 0) && (a + "").match(Yp).length < 2 ? s : Yn(a) ? a.trim() : a;
}, id = function(a) {
  return a;
}, bo = function(a, s) {
  for (var c in s)
    c in a || (a[c] = s[c]);
  return a;
}, l_ = function(a) {
  return function(s, c) {
    for (var d in c)
      d in s || d === "duration" && a || d === "ease" || (s[d] = c[d]);
  };
}, bl = function(a, s) {
  for (var c in s)
    a[c] = s[c];
  return a;
}, Tp = function x(a, s) {
  for (var c in s)
    c !== "__proto__" && c !== "constructor" && c !== "prototype" && (a[c] = hs(s[c]) ? x(a[c] || (a[c] = {}), s[c]) : s[c]);
  return a;
}, Wu = function(a, s) {
  var c = {}, d;
  for (d in a)
    d in s || (c[d] = a[d]);
  return c;
}, qh = function(a) {
  var s = a.parent || yn, c = a.keyframes ? l_(pr(a.keyframes)) : bo;
  if (kr(a.inherit))
    for (; s; )
      c(a, s.vars.defaults), s = s.parent || s._dp;
  return a;
}, h_ = function(a, s) {
  for (var c = a.length, d = c === s.length; d && c-- && a[c] === s[c]; )
    ;
  return c < 0;
}, nd = function(a, s, c, d, u) {
  c === void 0 && (c = "_first"), d === void 0 && (d = "_last");
  var m = a[d], g;
  if (u)
    for (g = s[u]; m && m[u] > g; )
      m = m._prev;
  return m ? (s._next = m._next, m._next = s) : (s._next = a[c], a[c] = s), s._next ? s._next._prev = s : a[d] = s, s._prev = m, s.parent = s._dp = a, s;
}, $u = function(a, s, c, d) {
  c === void 0 && (c = "_first"), d === void 0 && (d = "_last");
  var u = s._prev, m = s._next;
  u ? u._next = m : a[c] === s && (a[c] = m), m ? m._prev = u : a[d] === s && (a[d] = u), s._next = s._prev = s.parent = null;
}, Ia = function(a, s) {
  a.parent && (!s || a.parent.autoRemoveChildren) && a.parent.remove && a.parent.remove(a), a._act = 0;
}, Ml = function(a, s) {
  if (a && (!s || s._end > a._dur || s._start < 0))
    for (var c = a; c; )
      c._dirty = 1, c = c.parent;
  return a;
}, u_ = function(a) {
  for (var s = a.parent; s && s.parent; )
    s._dirty = 1, s.totalDuration(), s = s.parent;
  return a;
}, jc = function(a, s, c, d) {
  return a._startAt && (fr ? a._startAt.revert(Bu) : a.vars.immediateRender && !a.vars.autoRevert || a._startAt.render(s, !0, d));
}, c_ = function x(a) {
  return !a || a._ts && x(a.parent);
}, Mp = function(a) {
  return a._repeat ? ch(a._tTime, a = a.duration() + a._rDelay) * a : 0;
}, ch = function(a, s) {
  var c = Math.floor(a /= s);
  return a && c === a ? c - 1 : c;
}, ju = function(a, s) {
  return (a - s._start) * s._ts + (s._ts >= 0 ? 0 : s._dirty ? s.totalDuration() : s._tDur);
}, Ku = function(a) {
  return a._end = qn(a._start + (a._tDur / Math.abs(a._ts || a._rts || nn) || 0));
}, Qu = function(a, s) {
  var c = a._dp;
  return c && c.smoothChildTiming && a._ts && (a._start = qn(c._time - (a._ts > 0 ? s / a._ts : ((a._dirty ? a.totalDuration() : a._tDur) - s) / -a._ts)), Ku(a), c._dirty || Ml(c, a)), a;
}, rd = function(a, s) {
  var c;
  if ((s._time || !s._dur && s._initted || s._start < a._time && (s._dur || !s.add)) && (c = ju(a.rawTime(), s), (!s._dur || nu(0, s.totalDuration(), c) - s._tTime > nn) && s.render(c, !0)), Ml(a, s)._dp && a._initted && a._time >= a._dur && a._ts) {
    if (a._dur < a.duration())
      for (c = a; c._dp; )
        c.rawTime() >= 0 && c.totalTime(c._tTime), c = c._dp;
    a._zTime = -nn;
  }
}, ss = function(a, s, c, d) {
  return s.parent && Ia(s), s._start = qn((js(c) ? c : c || a !== yn ? Mo(a, c, s) : a._time) + s._delay), s._end = qn(s._start + (s.totalDuration() / Math.abs(s.timeScale()) || 0)), nd(a, s, "_first", "_last", a._sort ? "_start" : 0), Xc(s) || (a._recent = s), d || rd(a, s), a._ts < 0 && Qu(a, a._tTime), a;
}, od = function(a, s) {
  return (eo.ScrollTrigger || ff("scrollTrigger", s)) && eo.ScrollTrigger.create(s, a);
}, sd = function(a, s, c, d, u) {
  if (vf(a, s, u), !a._initted)
    return 1;
  if (!c && a._pt && !fr && (a._dur && a.vars.lazy !== !1 || !a._dur && a.vars.lazy) && Kp !== Kr.frame)
    return Ra.push(a), a._lazy = [u, d], 1;
}, f_ = function x(a) {
  var s = a.parent;
  return s && s._ts && s._initted && !s._lock && (s.rawTime() < 0 || x(s));
}, Xc = function(a) {
  var s = a.data;
  return s === "isFromStart" || s === "isStart";
}, p_ = function(a, s, c, d) {
  var u = a.ratio, m = s < 0 || !s && (!a._start && f_(a) && !(!a._initted && Xc(a)) || (a._ts < 0 || a._dp._ts < 0) && !Xc(a)) ? 0 : 1, g = a._rDelay, _ = 0, S, C, O;
  if (g && a._repeat && (_ = nu(0, a._tDur, s), C = ch(_, g), a._yoyo && C & 1 && (m = 1 - m), C !== ch(a._tTime, g) && (u = 1 - m, a.vars.repeatRefresh && a._initted && a.invalidate())), m !== u || fr || d || a._zTime === nn || !s && a._zTime) {
    if (!a._initted && sd(a, s, d, c, _))
      return;
    for (O = a._zTime, a._zTime = s || (c ? nn : 0), c || (c = s && !O), a.ratio = m, a._from && (m = 1 - m), a._time = 0, a._tTime = _, S = a._pt; S; )
      S.r(m, S.d), S = S._next;
    s < 0 && jc(a, s, c, !0), a._onUpdate && !c && Qr(a, "onUpdate"), _ && a._repeat && !c && a.parent && Qr(a, "onRepeat"), (s >= a._tDur || s < 0) && a.ratio === m && (m && Ia(a, 1), !c && !fr && (Qr(a, m ? "onComplete" : "onReverseComplete", !0), a._prom && a._prom()));
  } else
    a._zTime || (a._zTime = s);
}, d_ = function(a, s, c) {
  var d;
  if (c > s)
    for (d = a._first; d && d._start <= c; ) {
      if (d.data === "isPause" && d._start > s)
        return d;
      d = d._next;
    }
  else
    for (d = a._last; d && d._start >= c; ) {
      if (d.data === "isPause" && d._start < s)
        return d;
      d = d._prev;
    }
}, fh = function(a, s, c, d) {
  var u = a._repeat, m = qn(s) || 0, g = a._tTime / a._tDur;
  return g && !d && (a._time *= m / a._dur), a._dur = m, a._tDur = u ? u < 0 ? 1e10 : qn(m * (u + 1) + a._rDelay * u) : m, g > 0 && !d && Qu(a, a._tTime = a._tDur * g), a.parent && Ku(a), c || Ml(a.parent, a), a;
}, Sp = function(a) {
  return a instanceof Tr ? Ml(a) : fh(a, a._dur);
}, m_ = {
  _start: 0,
  endTime: $h,
  totalDuration: $h
}, Mo = function x(a, s, c) {
  var d = a.labels, u = a._recent || m_, m = a.duration() >= So ? u.endTime(!1) : a._dur, g, _, S;
  return Yn(s) && (isNaN(s) || s in d) ? (_ = s.charAt(0), S = s.substr(-1) === "%", g = s.indexOf("="), _ === "<" || _ === ">" ? (g >= 0 && (s = s.replace(/=/, "")), (_ === "<" ? u._start : u.endTime(u._repeat >= 0)) + (parseFloat(s.substr(1)) || 0) * (S ? (g < 0 ? u : c).totalDuration() / 100 : 1)) : g < 0 ? (s in d || (d[s] = m), d[s]) : (_ = parseFloat(s.charAt(g - 1) + s.substr(g + 1)), S && c && (_ = _ / 100 * (pr(c) ? c[0] : c).totalDuration()), g > 1 ? x(a, s.substr(0, g - 1), c) + _ : m + _)) : s == null ? m : +s;
}, Yh = function(a, s, c) {
  var d = js(s[1]), u = (d ? 2 : 1) + (a < 2 ? 0 : 1), m = s[u], g, _;
  if (d && (m.duration = s[1]), m.parent = c, a) {
    for (g = m, _ = c; _ && !("immediateRender" in g); )
      g = _.vars.defaults || {}, _ = kr(_.vars.inherit) && _.parent;
    m.immediateRender = kr(g.immediateRender), a < 2 ? m.runBackwards = 1 : m.startAt = s[u - 1];
  }
  return new kn(s[0], m, s[u + 1]);
}, za = function(a, s) {
  return a || a === 0 ? s(a) : s;
}, nu = function(a, s, c) {
  return c < a ? a : c > s ? s : c;
}, cr = function(a, s) {
  return !Yn(a) || !(s = r_.exec(a)) ? "" : s[1];
}, g_ = function(a, s, c) {
  return za(c, function(d) {
    return nu(a, s, d);
  });
}, qc = [].slice, ad = function(a, s) {
  return a && hs(a) && "length" in a && (!s && !a.length || a.length - 1 in a && hs(a[0])) && !a.nodeType && a !== os;
}, v_ = function(a, s, c) {
  return c === void 0 && (c = []), a.forEach(function(d) {
    var u;
    return Yn(d) && !s || ad(d, 1) ? (u = c).push.apply(u, Eo(d)) : c.push(d);
  }) || c;
}, Eo = function(a, s, c) {
  return un && !s && un.selector ? un.selector(a) : Yn(a) && !c && (Vc || !ph()) ? qc.call((s || cf).querySelectorAll(a), 0) : pr(a) ? v_(a, c) : ad(a) ? qc.call(a, 0) : a ? [a] : [];
}, Yc = function(a) {
  return a = Eo(a)[0] || Jh("Invalid scope") || {}, function(s) {
    var c = a.current || a.nativeElement || a;
    return Eo(s, c.querySelectorAll ? c : c === a ? Jh("Invalid scope") || cf.createElement("div") : a);
  };
}, ld = function(a) {
  return a.sort(function() {
    return 0.5 - Math.random();
  });
}, hd = function(a) {
  if (An(a))
    return a;
  var s = hs(a) ? a : {
    each: a
  }, c = Sl(s.ease), d = s.from || 0, u = parseFloat(s.base) || 0, m = {}, g = d > 0 && d < 1, _ = isNaN(d) || g, S = s.axis, C = d, O = d;
  return Yn(d) ? C = O = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[d] || 0 : !g && _ && (C = d[0], O = d[1]), function(k, D, F) {
    var E = (F || s).length, L = m[E], T, M, R, b, U, N, j, J, K;
    if (!L) {
      if (K = s.grid === "auto" ? 0 : (s.grid || [1, So])[1], !K) {
        for (j = -So; j < (j = F[K++].getBoundingClientRect().left) && K < E; )
          ;
        K < E && K--;
      }
      for (L = m[E] = [], T = _ ? Math.min(K, E) * C - 0.5 : d % K, M = K === So ? 0 : _ ? E * O / K - 0.5 : d / K | 0, j = 0, J = So, N = 0; N < E; N++)
        R = N % K - T, b = M - (N / K | 0), L[N] = U = S ? Math.abs(S === "y" ? b : R) : Wp(R * R + b * b), U > j && (j = U), U < J && (J = U);
      d === "random" && ld(L), L.max = j - J, L.min = J, L.v = E = (parseFloat(s.amount) || parseFloat(s.each) * (K > E ? E - 1 : S ? S === "y" ? E / K : K : Math.max(K, E / K)) || 0) * (d === "edges" ? -1 : 1), L.b = E < 0 ? u - E : u, L.u = cr(s.amount || s.each) || 0, c = c && E < 0 ? _d(c) : c;
    }
    return E = (L[k] - L.min) / L.max || 0, qn(L.b + (c ? c(E) : E) * L.v) + L.u;
  };
}, Zc = function(a) {
  var s = Math.pow(10, ((a + "").split(".")[1] || "").length);
  return function(c) {
    var d = qn(Math.round(parseFloat(c) / a) * a * s);
    return (d - d % 1) / s + (js(c) ? 0 : cr(c));
  };
}, ud = function(a, s) {
  var c = pr(a), d, u;
  return !c && hs(a) && (d = c = a.radius || So, a.values ? (a = Eo(a.values), (u = !js(a[0])) && (d *= d)) : a = Zc(a.increment)), za(s, c ? An(a) ? function(m) {
    return u = a(m), Math.abs(u - m) <= d ? u : m;
  } : function(m) {
    for (var g = parseFloat(u ? m.x : m), _ = parseFloat(u ? m.y : 0), S = So, C = 0, O = a.length, k, D; O--; )
      u ? (k = a[O].x - g, D = a[O].y - _, k = k * k + D * D) : k = Math.abs(a[O] - g), k < S && (S = k, C = O);
    return C = !d || S <= d ? a[C] : m, u || C === m || js(m) ? C : C + cr(m);
  } : Zc(a));
}, cd = function(a, s, c, d) {
  return za(pr(a) ? !s : c === !0 ? !!(c = 0) : !d, function() {
    return pr(a) ? a[~~(Math.random() * a.length)] : (c = c || 1e-5) && (d = c < 1 ? Math.pow(10, (c + "").length - 2) : 1) && Math.floor(Math.round((a - c / 2 + Math.random() * (s - a + c * 0.99)) / c) * c * d) / d;
  });
}, y_ = function() {
  for (var a = arguments.length, s = new Array(a), c = 0; c < a; c++)
    s[c] = arguments[c];
  return function(d) {
    return s.reduce(function(u, m) {
      return m(u);
    }, d);
  };
}, __ = function(a, s) {
  return function(c) {
    return a(parseFloat(c)) + (s || cr(c));
  };
}, x_ = function(a, s, c) {
  return pd(a, s, 0, 1, c);
}, fd = function(a, s, c) {
  return za(c, function(d) {
    return a[~~s(d)];
  });
}, w_ = function x(a, s, c) {
  var d = s - a;
  return pr(a) ? fd(a, x(0, a.length), s) : za(c, function(u) {
    return (d + (u - a) % d) % d + a;
  });
}, T_ = function x(a, s, c) {
  var d = s - a, u = d * 2;
  return pr(a) ? fd(a, x(0, a.length - 1), s) : za(c, function(m) {
    return m = (u + (m - a) % u) % u || 0, a + (m > d ? u - m : m);
  });
}, Kh = function(a) {
  for (var s = 0, c = "", d, u, m, g; ~(d = a.indexOf("random(", s)); )
    m = a.indexOf(")", d), g = a.charAt(d + 7) === "[", u = a.substr(d + 7, m - d - 7).match(g ? Yp : Hc), c += a.substr(s, d - s) + cd(g ? u : +u[0], g ? 0 : +u[1], +u[2] || 1e-5), s = m + 1;
  return c + a.substr(s, a.length - s);
}, pd = function(a, s, c, d, u) {
  var m = s - a, g = d - c;
  return za(u, function(_) {
    return c + ((_ - a) / m * g || 0);
  });
}, M_ = function x(a, s, c, d) {
  var u = isNaN(a + s) ? 0 : function(D) {
    return (1 - D) * a + D * s;
  };
  if (!u) {
    var m = Yn(a), g = {}, _, S, C, O, k;
    if (c === !0 && (d = 1) && (c = null), m)
      a = {
        p: a
      }, s = {
        p: s
      };
    else if (pr(a) && !pr(s)) {
      for (C = [], O = a.length, k = O - 2, S = 1; S < O; S++)
        C.push(x(a[S - 1], a[S]));
      O--, u = function(F) {
        F *= O;
        var E = Math.min(k, ~~F);
        return C[E](F - E);
      }, c = s;
    } else
      d || (a = bl(pr(a) ? [] : {}, a));
    if (!C) {
      for (_ in s)
        gf.call(g, a, _, "get", s[_]);
      u = function(F) {
        return xf(F, g) || (m ? a.p : a);
      };
    }
  }
  return za(c, u);
}, Ep = function(a, s, c) {
  var d = a.labels, u = So, m, g, _;
  for (m in d)
    g = d[m] - s, g < 0 == !!c && g && u > (g = Math.abs(g)) && (_ = m, u = g);
  return _;
}, Qr = function(a, s, c) {
  var d = a.vars, u = d[s], m = un, g = a._ctx, _, S, C;
  if (u)
    return _ = d[s + "Params"], S = d.callbackScope || a, c && Ra.length && Vu(), g && (un = g), C = _ ? u.apply(S, _) : u.call(S), un = m, C;
}, jh = function(a) {
  return Ia(a), a.scrollTrigger && a.scrollTrigger.kill(!!fr), a.progress() < 1 && Qr(a, "onInterrupt"), a;
}, sh, dd = [], md = function(a) {
  if (a)
    if (a = !a.name && a.default || a, uf() || a.headless) {
      var s = a.name, c = An(a), d = s && !c && a.init ? function() {
        this._props = [];
      } : a, u = {
        init: $h,
        render: xf,
        add: gf,
        kill: F_,
        modifier: N_,
        rawVars: 0
      }, m = {
        targetTest: 0,
        get: 0,
        getSetter: _f,
        aliases: {},
        register: 0
      };
      if (ph(), a !== d) {
        if ($r[s])
          return;
        bo(d, bo(Wu(a, u), m)), bl(d.prototype, bl(u, Wu(a, m))), $r[d.prop = s] = d, a.targetTest && (Nu.push(d), pf[s] = 1), s = (s === "css" ? "CSS" : s.charAt(0).toUpperCase() + s.substr(1)) + "Plugin";
      }
      $p(s, d), a.register && a.register(Ur, d, Nr);
    } else
      dd.push(a);
}, Ki = 255, Xh = {
  aqua: [0, Ki, Ki],
  lime: [0, Ki, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, Ki],
  navy: [0, 0, 128],
  white: [Ki, Ki, Ki],
  olive: [128, 128, 0],
  yellow: [Ki, Ki, 0],
  orange: [Ki, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [Ki, 0, 0],
  pink: [Ki, 192, 203],
  cyan: [0, Ki, Ki],
  transparent: [Ki, Ki, Ki, 0]
}, Oc = function(a, s, c) {
  return a += a < 0 ? 1 : a > 1 ? -1 : 0, (a * 6 < 1 ? s + (c - s) * a * 6 : a < 0.5 ? c : a * 3 < 2 ? s + (c - s) * (2 / 3 - a) * 6 : s) * Ki + 0.5 | 0;
}, gd = function(a, s, c) {
  var d = a ? js(a) ? [a >> 16, a >> 8 & Ki, a & Ki] : 0 : Xh.black, u, m, g, _, S, C, O, k, D, F;
  if (!d) {
    if (a.substr(-1) === "," && (a = a.substr(0, a.length - 1)), Xh[a])
      d = Xh[a];
    else if (a.charAt(0) === "#") {
      if (a.length < 6 && (u = a.charAt(1), m = a.charAt(2), g = a.charAt(3), a = "#" + u + u + m + m + g + g + (a.length === 5 ? a.charAt(4) + a.charAt(4) : "")), a.length === 9)
        return d = parseInt(a.substr(1, 6), 16), [d >> 16, d >> 8 & Ki, d & Ki, parseInt(a.substr(7), 16) / 255];
      a = parseInt(a.substr(1), 16), d = [a >> 16, a >> 8 & Ki, a & Ki];
    } else if (a.substr(0, 3) === "hsl") {
      if (d = F = a.match(Hc), !s)
        _ = +d[0] % 360 / 360, S = +d[1] / 100, C = +d[2] / 100, m = C <= 0.5 ? C * (S + 1) : C + S - C * S, u = C * 2 - m, d.length > 3 && (d[3] *= 1), d[0] = Oc(_ + 1 / 3, u, m), d[1] = Oc(_, u, m), d[2] = Oc(_ - 1 / 3, u, m);
      else if (~a.indexOf("="))
        return d = a.match(Xp), c && d.length < 4 && (d[3] = 1), d;
    } else
      d = a.match(Hc) || Xh.transparent;
    d = d.map(Number);
  }
  return s && !F && (u = d[0] / Ki, m = d[1] / Ki, g = d[2] / Ki, O = Math.max(u, m, g), k = Math.min(u, m, g), C = (O + k) / 2, O === k ? _ = S = 0 : (D = O - k, S = C > 0.5 ? D / (2 - O - k) : D / (O + k), _ = O === u ? (m - g) / D + (m < g ? 6 : 0) : O === m ? (g - u) / D + 2 : (u - m) / D + 4, _ *= 60), d[0] = ~~(_ + 0.5), d[1] = ~~(S * 100 + 0.5), d[2] = ~~(C * 100 + 0.5)), c && d.length < 4 && (d[3] = 1), d;
}, vd = function(a) {
  var s = [], c = [], d = -1;
  return a.split(Oa).forEach(function(u) {
    var m = u.match(oh) || [];
    s.push.apply(s, m), c.push(d += m.length + 1);
  }), s.c = c, s;
}, bp = function(a, s, c) {
  var d = "", u = (a + d).match(Oa), m = s ? "hsla(" : "rgba(", g = 0, _, S, C, O;
  if (!u)
    return a;
  if (u = u.map(function(k) {
    return (k = gd(k, s, 1)) && m + (s ? k[0] + "," + k[1] + "%," + k[2] + "%," + k[3] : k.join(",")) + ")";
  }), c && (C = vd(a), _ = c.c, _.join(d) !== C.c.join(d)))
    for (S = a.replace(Oa, "1").split(oh), O = S.length - 1; g < O; g++)
      d += S[g] + (~_.indexOf(g) ? u.shift() || m + "0,0,0,0)" : (C.length ? C : u.length ? u : c).shift());
  if (!S)
    for (S = a.split(Oa), O = S.length - 1; g < O; g++)
      d += S[g] + u[g];
  return d + S[O];
}, Oa = function() {
  var x = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", a;
  for (a in Xh)
    x += "|" + a + "\\b";
  return new RegExp(x + ")", "gi");
}(), S_ = /hsl[a]?\(/, yd = function(a) {
  var s = a.join(" "), c;
  if (Oa.lastIndex = 0, Oa.test(s))
    return c = S_.test(s), a[1] = bp(a[1], c), a[0] = bp(a[0], c, vd(a[1])), !0;
}, Qh, Kr = function() {
  var x = Date.now, a = 500, s = 33, c = x(), d = c, u = 1e3 / 240, m = u, g = [], _, S, C, O, k, D, F = function E(L) {
    var T = x() - d, M = L === !0, R, b, U, N;
    if ((T > a || T < 0) && (c += T - s), d += T, U = d - c, R = U - m, (R > 0 || M) && (N = ++O.frame, k = U - O.time * 1e3, O.time = U = U / 1e3, m += R + (R >= u ? 4 : u - R), b = 1), M || (_ = S(E)), b)
      for (D = 0; D < g.length; D++)
        g[D](U, k, N, L);
  };
  return O = {
    time: 0,
    frame: 0,
    tick: function() {
      F(!0);
    },
    deltaRatio: function(L) {
      return k / (1e3 / (L || 60));
    },
    wake: function() {
      Zp && (!Vc && uf() && (os = Vc = window, cf = os.document || {}, eo.gsap = Ur, (os.gsapVersions || (os.gsapVersions = [])).push(Ur.version), Jp(Hu || os.GreenSockGlobals || !os.gsap && os || {}), dd.forEach(md)), C = typeof requestAnimationFrame < "u" && requestAnimationFrame, _ && O.sleep(), S = C || function(L) {
        return setTimeout(L, m - O.time * 1e3 + 1 | 0);
      }, Qh = 1, F(2));
    },
    sleep: function() {
      (C ? cancelAnimationFrame : clearTimeout)(_), Qh = 0, S = $h;
    },
    lagSmoothing: function(L, T) {
      a = L || 1 / 0, s = Math.min(T || 33, a);
    },
    fps: function(L) {
      u = 1e3 / (L || 240), m = O.time * 1e3 + u;
    },
    add: function(L, T, M) {
      var R = T ? function(b, U, N, j) {
        L(b, U, N, j), O.remove(R);
      } : L;
      return O.remove(L), g[M ? "unshift" : "push"](R), ph(), R;
    },
    remove: function(L, T) {
      ~(T = g.indexOf(L)) && g.splice(T, 1) && D >= T && D--;
    },
    _listeners: g
  }, O;
}(), ph = function() {
  return !Qh && Kr.wake();
}, Ni = {}, E_ = /^[\d.\-M][\d.\-,\s]/, b_ = /["']/g, C_ = function(a) {
  for (var s = {}, c = a.substr(1, a.length - 3).split(":"), d = c[0], u = 1, m = c.length, g, _, S; u < m; u++)
    _ = c[u], g = u !== m - 1 ? _.lastIndexOf(",") : _.length, S = _.substr(0, g), s[d] = isNaN(S) ? S.replace(b_, "").trim() : +S, d = _.substr(g + 1).trim();
  return s;
}, A_ = function(a) {
  var s = a.indexOf("(") + 1, c = a.indexOf(")"), d = a.indexOf("(", s);
  return a.substring(s, ~d && d < c ? a.indexOf(")", c + 1) : c);
}, P_ = function(a) {
  var s = (a + "").split("("), c = Ni[s[0]];
  return c && s.length > 1 && c.config ? c.config.apply(null, ~a.indexOf("{") ? [C_(s[1])] : A_(a).split(",").map(ed)) : Ni._CE && E_.test(a) ? Ni._CE("", a) : c;
}, _d = function(a) {
  return function(s) {
    return 1 - a(1 - s);
  };
}, xd = function x(a, s) {
  for (var c = a._first, d; c; )
    c instanceof Tr ? x(c, s) : c.vars.yoyoEase && (!c._yoyo || !c._repeat) && c._yoyo !== s && (c.timeline ? x(c.timeline, s) : (d = c._ease, c._ease = c._yEase, c._yEase = d, c._yoyo = s)), c = c._next;
}, Sl = function(a, s) {
  return a && (An(a) ? a : Ni[a] || P_(a)) || s;
}, Al = function(a, s, c, d) {
  c === void 0 && (c = function(_) {
    return 1 - s(1 - _);
  }), d === void 0 && (d = function(_) {
    return _ < 0.5 ? s(_ * 2) / 2 : 1 - s((1 - _) * 2) / 2;
  });
  var u = {
    easeIn: s,
    easeOut: c,
    easeInOut: d
  }, m;
  return Br(a, function(g) {
    Ni[g] = eo[g] = u, Ni[m = g.toLowerCase()] = c;
    for (var _ in u)
      Ni[m + (_ === "easeIn" ? ".in" : _ === "easeOut" ? ".out" : ".inOut")] = Ni[g + "." + _] = u[_];
  }), u;
}, wd = function(a) {
  return function(s) {
    return s < 0.5 ? (1 - a(1 - s * 2)) / 2 : 0.5 + a((s - 0.5) * 2) / 2;
  };
}, Ic = function x(a, s, c) {
  var d = s >= 1 ? s : 1, u = (c || (a ? 0.3 : 0.45)) / (s < 1 ? s : 1), m = u / Gc * (Math.asin(1 / d) || 0), g = function(C) {
    return C === 1 ? 1 : d * Math.pow(2, -10 * C) * n_((C - m) * u) + 1;
  }, _ = a === "out" ? g : a === "in" ? function(S) {
    return 1 - g(1 - S);
  } : wd(g);
  return u = Gc / u, _.config = function(S, C) {
    return x(a, S, C);
  }, _;
}, Dc = function x(a, s) {
  s === void 0 && (s = 1.70158);
  var c = function(m) {
    return m ? --m * m * ((s + 1) * m + s) + 1 : 0;
  }, d = a === "out" ? c : a === "in" ? function(u) {
    return 1 - c(1 - u);
  } : wd(c);
  return d.config = function(u) {
    return x(a, u);
  }, d;
};
Br("Linear,Quad,Cubic,Quart,Quint,Strong", function(x, a) {
  var s = a < 5 ? a + 1 : a;
  Al(x + ",Power" + (s - 1), a ? function(c) {
    return Math.pow(c, s);
  } : function(c) {
    return c;
  }, function(c) {
    return 1 - Math.pow(1 - c, s);
  }, function(c) {
    return c < 0.5 ? Math.pow(c * 2, s) / 2 : 1 - Math.pow((1 - c) * 2, s) / 2;
  });
});
Ni.Linear.easeNone = Ni.none = Ni.Linear.easeIn;
Al("Elastic", Ic("in"), Ic("out"), Ic());
(function(x, a) {
  var s = 1 / a, c = 2 * s, d = 2.5 * s, u = function(g) {
    return g < s ? x * g * g : g < c ? x * Math.pow(g - 1.5 / a, 2) + 0.75 : g < d ? x * (g -= 2.25 / a) * g + 0.9375 : x * Math.pow(g - 2.625 / a, 2) + 0.984375;
  };
  Al("Bounce", function(m) {
    return 1 - u(1 - m);
  }, u);
})(7.5625, 2.75);
Al("Expo", function(x) {
  return x ? Math.pow(2, 10 * (x - 1)) : 0;
});
Al("Circ", function(x) {
  return -(Wp(1 - x * x) - 1);
});
Al("Sine", function(x) {
  return x === 1 ? 1 : -i_(x * t_) + 1;
});
Al("Back", Dc("in"), Dc("out"), Dc());
Ni.SteppedEase = Ni.steps = eo.SteppedEase = {
  config: function(a, s) {
    a === void 0 && (a = 1);
    var c = 1 / a, d = a + (s ? 0 : 1), u = s ? 1 : 0, m = 1 - nn;
    return function(g) {
      return ((d * nu(0, m, g) | 0) + u) * c;
    };
  }
};
uh.ease = Ni["quad.out"];
Br("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(x) {
  return df += x + "," + x + "Params,";
});
var Td = function(a, s) {
  this.id = e_++, a._gsap = this, this.target = a, this.harness = s, this.get = s ? s.get : Qp, this.set = s ? s.getSetter : _f;
}, tu = /* @__PURE__ */ function() {
  function x(s) {
    this.vars = s, this._delay = +s.delay || 0, (this._repeat = s.repeat === 1 / 0 ? -2 : s.repeat || 0) && (this._rDelay = s.repeatDelay || 0, this._yoyo = !!s.yoyo || !!s.yoyoEase), this._ts = 1, fh(this, +s.duration, 1, 1), this.data = s.data, un && (this._ctx = un, un.data.push(this)), Qh || Kr.wake();
  }
  var a = x.prototype;
  return a.delay = function(c) {
    return c || c === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + c - this._delay), this._delay = c, this) : this._delay;
  }, a.duration = function(c) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? c + (c + this._rDelay) * this._repeat : c) : this.totalDuration() && this._dur;
  }, a.totalDuration = function(c) {
    return arguments.length ? (this._dirty = 0, fh(this, this._repeat < 0 ? c : (c - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, a.totalTime = function(c, d) {
    if (ph(), !arguments.length)
      return this._tTime;
    var u = this._dp;
    if (u && u.smoothChildTiming && this._ts) {
      for (Qu(this, c), !u._dp || u.parent || rd(u, this); u && u.parent; )
        u.parent._time !== u._start + (u._ts >= 0 ? u._tTime / u._ts : (u.totalDuration() - u._tTime) / -u._ts) && u.totalTime(u._tTime, !0), u = u.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && c < this._tDur || this._ts < 0 && c > 0 || !this._tDur && !c) && ss(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== c || !this._dur && !d || this._initted && Math.abs(this._zTime) === nn || !c && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = c), td(this, c, d)), this;
  }, a.time = function(c, d) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), c + Mp(this)) % (this._dur + this._rDelay) || (c ? this._dur : 0), d) : this._time;
  }, a.totalProgress = function(c, d) {
    return arguments.length ? this.totalTime(this.totalDuration() * c, d) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, a.progress = function(c, d) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - c : c) + Mp(this), d) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, a.iteration = function(c, d) {
    var u = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (c - 1) * u, d) : this._repeat ? ch(this._tTime, u) + 1 : 1;
  }, a.timeScale = function(c, d) {
    if (!arguments.length)
      return this._rts === -nn ? 0 : this._rts;
    if (this._rts === c)
      return this;
    var u = this.parent && this._ts ? ju(this.parent._time, this) : this._tTime;
    return this._rts = +c || 0, this._ts = this._ps || c === -nn ? 0 : this._rts, this.totalTime(nu(-Math.abs(this._delay), this._tDur, u), d !== !1), Ku(this), u_(this);
  }, a.paused = function(c) {
    return arguments.length ? (this._ps !== c && (this._ps = c, c ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (ph(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== nn && (this._tTime -= nn)))), this) : this._ps;
  }, a.startTime = function(c) {
    if (arguments.length) {
      this._start = c;
      var d = this.parent || this._dp;
      return d && (d._sort || !this.parent) && ss(d, this, c - this._delay), this;
    }
    return this._start;
  }, a.endTime = function(c) {
    return this._start + (kr(c) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, a.rawTime = function(c) {
    var d = this.parent || this._dp;
    return d ? c && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ju(d.rawTime(c), this) : this._tTime : this._tTime;
  }, a.revert = function(c) {
    c === void 0 && (c = s_);
    var d = fr;
    return fr = c, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(c), this.totalTime(-0.01, c.suppressEvents)), this.data !== "nested" && c.kill !== !1 && this.kill(), fr = d, this;
  }, a.globalTime = function(c) {
    for (var d = this, u = arguments.length ? c : d.rawTime(); d; )
      u = d._start + u / (Math.abs(d._ts) || 1), d = d._dp;
    return !this.parent && this._sat ? this._sat.globalTime(c) : u;
  }, a.repeat = function(c) {
    return arguments.length ? (this._repeat = c === 1 / 0 ? -2 : c, Sp(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, a.repeatDelay = function(c) {
    if (arguments.length) {
      var d = this._time;
      return this._rDelay = c, Sp(this), d ? this.time(d) : this;
    }
    return this._rDelay;
  }, a.yoyo = function(c) {
    return arguments.length ? (this._yoyo = c, this) : this._yoyo;
  }, a.seek = function(c, d) {
    return this.totalTime(Mo(this, c), kr(d));
  }, a.restart = function(c, d) {
    return this.play().totalTime(c ? -this._delay : 0, kr(d));
  }, a.play = function(c, d) {
    return c != null && this.seek(c, d), this.reversed(!1).paused(!1);
  }, a.reverse = function(c, d) {
    return c != null && this.seek(c || this.totalDuration(), d), this.reversed(!0).paused(!1);
  }, a.pause = function(c, d) {
    return c != null && this.seek(c, d), this.paused(!0);
  }, a.resume = function() {
    return this.paused(!1);
  }, a.reversed = function(c) {
    return arguments.length ? (!!c !== this.reversed() && this.timeScale(-this._rts || (c ? -nn : 0)), this) : this._rts < 0;
  }, a.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -nn, this;
  }, a.isActive = function() {
    var c = this.parent || this._dp, d = this._start, u;
    return !!(!c || this._ts && this._initted && c.isActive() && (u = c.rawTime(!0)) >= d && u < this.endTime(!0) - nn);
  }, a.eventCallback = function(c, d, u) {
    var m = this.vars;
    return arguments.length > 1 ? (d ? (m[c] = d, u && (m[c + "Params"] = u), c === "onUpdate" && (this._onUpdate = d)) : delete m[c], this) : m[c];
  }, a.then = function(c) {
    var d = this;
    return new Promise(function(u) {
      var m = An(c) ? c : id, g = function() {
        var S = d.then;
        d.then = null, An(m) && (m = m(d)) && (m.then || m === d) && (d.then = S), u(m), d.then = S;
      };
      d._initted && d.totalProgress() === 1 && d._ts >= 0 || !d._tTime && d._ts < 0 ? g() : d._prom = g;
    });
  }, a.kill = function() {
    jh(this);
  }, x;
}();
bo(tu.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -nn,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Tr = /* @__PURE__ */ function(x) {
  Vp(a, x);
  function a(c, d) {
    var u;
    return c === void 0 && (c = {}), u = x.call(this, c) || this, u.labels = {}, u.smoothChildTiming = !!c.smoothChildTiming, u.autoRemoveChildren = !!c.autoRemoveChildren, u._sort = kr(c.sortChildren), yn && ss(c.parent || yn, Vs(u), d), c.reversed && u.reverse(), c.paused && u.paused(!0), c.scrollTrigger && od(Vs(u), c.scrollTrigger), u;
  }
  var s = a.prototype;
  return s.to = function(d, u, m) {
    return Yh(0, arguments, this), this;
  }, s.from = function(d, u, m) {
    return Yh(1, arguments, this), this;
  }, s.fromTo = function(d, u, m, g) {
    return Yh(2, arguments, this), this;
  }, s.set = function(d, u, m) {
    return u.duration = 0, u.parent = this, qh(u).repeatDelay || (u.repeat = 0), u.immediateRender = !!u.immediateRender, new kn(d, u, Mo(this, m), 1), this;
  }, s.call = function(d, u, m) {
    return ss(this, kn.delayedCall(0, d, u), m);
  }, s.staggerTo = function(d, u, m, g, _, S, C) {
    return m.duration = u, m.stagger = m.stagger || g, m.onComplete = S, m.onCompleteParams = C, m.parent = this, new kn(d, m, Mo(this, _)), this;
  }, s.staggerFrom = function(d, u, m, g, _, S, C) {
    return m.runBackwards = 1, qh(m).immediateRender = kr(m.immediateRender), this.staggerTo(d, u, m, g, _, S, C);
  }, s.staggerFromTo = function(d, u, m, g, _, S, C, O) {
    return g.startAt = m, qh(g).immediateRender = kr(g.immediateRender), this.staggerTo(d, u, g, _, S, C, O);
  }, s.render = function(d, u, m) {
    var g = this._time, _ = this._dirty ? this.totalDuration() : this._tDur, S = this._dur, C = d <= 0 ? 0 : qn(d), O = this._zTime < 0 != d < 0 && (this._initted || !S), k, D, F, E, L, T, M, R, b, U, N, j;
    if (this !== yn && C > _ && d >= 0 && (C = _), C !== this._tTime || m || O) {
      if (g !== this._time && S && (C += this._time - g, d += this._time - g), k = C, b = this._start, R = this._ts, T = !R, O && (S || (g = this._zTime), (d || !u) && (this._zTime = d)), this._repeat) {
        if (N = this._yoyo, L = S + this._rDelay, this._repeat < -1 && d < 0)
          return this.totalTime(L * 100 + d, u, m);
        if (k = qn(C % L), C === _ ? (E = this._repeat, k = S) : (E = ~~(C / L), E && E === C / L && (k = S, E--), k > S && (k = S)), U = ch(this._tTime, L), !g && this._tTime && U !== E && this._tTime - U * L - this._dur <= 0 && (U = E), N && E & 1 && (k = S - k, j = 1), E !== U && !this._lock) {
          var J = N && U & 1, K = J === (N && E & 1);
          if (E < U && (J = !J), g = J ? 0 : C % S ? S : C, this._lock = 1, this.render(g || (j ? 0 : qn(E * L)), u, !S)._lock = 0, this._tTime = C, !u && this.parent && Qr(this, "onRepeat"), this.vars.repeatRefresh && !j && (this.invalidate()._lock = 1), g && g !== this._time || T !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (S = this._dur, _ = this._tDur, K && (this._lock = 2, g = J ? S : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !j && this.invalidate()), this._lock = 0, !this._ts && !T)
            return this;
          xd(this, j);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (M = d_(this, qn(g), qn(k)), M && (C -= k - (k = M._start))), this._tTime = C, this._time = k, this._act = !R, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = d, g = 0), !g && k && !u && !E && (Qr(this, "onStart"), this._tTime !== C))
        return this;
      if (k >= g && d >= 0)
        for (D = this._first; D; ) {
          if (F = D._next, (D._act || k >= D._start) && D._ts && M !== D) {
            if (D.parent !== this)
              return this.render(d, u, m);
            if (D.render(D._ts > 0 ? (k - D._start) * D._ts : (D._dirty ? D.totalDuration() : D._tDur) + (k - D._start) * D._ts, u, m), k !== this._time || !this._ts && !T) {
              M = 0, F && (C += this._zTime = -nn);
              break;
            }
          }
          D = F;
        }
      else {
        D = this._last;
        for (var ct = d < 0 ? d : k; D; ) {
          if (F = D._prev, (D._act || ct <= D._end) && D._ts && M !== D) {
            if (D.parent !== this)
              return this.render(d, u, m);
            if (D.render(D._ts > 0 ? (ct - D._start) * D._ts : (D._dirty ? D.totalDuration() : D._tDur) + (ct - D._start) * D._ts, u, m || fr && (D._initted || D._startAt)), k !== this._time || !this._ts && !T) {
              M = 0, F && (C += this._zTime = ct ? -nn : nn);
              break;
            }
          }
          D = F;
        }
      }
      if (M && !u && (this.pause(), M.render(k >= g ? 0 : -nn)._zTime = k >= g ? 1 : -1, this._ts))
        return this._start = b, Ku(this), this.render(d, u, m);
      this._onUpdate && !u && Qr(this, "onUpdate", !0), (C === _ && this._tTime >= this.totalDuration() || !C && g) && (b === this._start || Math.abs(R) !== Math.abs(this._ts)) && (this._lock || ((d || !S) && (C === _ && this._ts > 0 || !C && this._ts < 0) && Ia(this, 1), !u && !(d < 0 && !g) && (C || g || !_) && (Qr(this, C === _ && d >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(C < _ && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, s.add = function(d, u) {
    var m = this;
    if (js(u) || (u = Mo(this, u, d)), !(d instanceof tu)) {
      if (pr(d))
        return d.forEach(function(g) {
          return m.add(g, u);
        }), this;
      if (Yn(d))
        return this.addLabel(d, u);
      if (An(d))
        d = kn.delayedCall(0, d);
      else
        return this;
    }
    return this !== d ? ss(this, d, u) : this;
  }, s.getChildren = function(d, u, m, g) {
    d === void 0 && (d = !0), u === void 0 && (u = !0), m === void 0 && (m = !0), g === void 0 && (g = -So);
    for (var _ = [], S = this._first; S; )
      S._start >= g && (S instanceof kn ? u && _.push(S) : (m && _.push(S), d && _.push.apply(_, S.getChildren(!0, u, m)))), S = S._next;
    return _;
  }, s.getById = function(d) {
    for (var u = this.getChildren(1, 1, 1), m = u.length; m--; )
      if (u[m].vars.id === d)
        return u[m];
  }, s.remove = function(d) {
    return Yn(d) ? this.removeLabel(d) : An(d) ? this.killTweensOf(d) : ($u(this, d), d === this._recent && (this._recent = this._last), Ml(this));
  }, s.totalTime = function(d, u) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = qn(Kr.time - (this._ts > 0 ? d / this._ts : (this.totalDuration() - d) / -this._ts))), x.prototype.totalTime.call(this, d, u), this._forcing = 0, this) : this._tTime;
  }, s.addLabel = function(d, u) {
    return this.labels[d] = Mo(this, u), this;
  }, s.removeLabel = function(d) {
    return delete this.labels[d], this;
  }, s.addPause = function(d, u, m) {
    var g = kn.delayedCall(0, u || $h, m);
    return g.data = "isPause", this._hasPause = 1, ss(this, g, Mo(this, d));
  }, s.removePause = function(d) {
    var u = this._first;
    for (d = Mo(this, d); u; )
      u._start === d && u.data === "isPause" && Ia(u), u = u._next;
  }, s.killTweensOf = function(d, u, m) {
    for (var g = this.getTweensOf(d, m), _ = g.length; _--; )
      Aa !== g[_] && g[_].kill(d, u);
    return this;
  }, s.getTweensOf = function(d, u) {
    for (var m = [], g = Eo(d), _ = this._first, S = js(u), C; _; )
      _ instanceof kn ? a_(_._targets, g) && (S ? (!Aa || _._initted && _._ts) && _.globalTime(0) <= u && _.globalTime(_.totalDuration()) > u : !u || _.isActive()) && m.push(_) : (C = _.getTweensOf(g, u)).length && m.push.apply(m, C), _ = _._next;
    return m;
  }, s.tweenTo = function(d, u) {
    u = u || {};
    var m = this, g = Mo(m, d), _ = u, S = _.startAt, C = _.onStart, O = _.onStartParams, k = _.immediateRender, D, F = kn.to(m, bo({
      ease: u.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: g,
      overwrite: "auto",
      duration: u.duration || Math.abs((g - (S && "time" in S ? S.time : m._time)) / m.timeScale()) || nn,
      onStart: function() {
        if (m.pause(), !D) {
          var L = u.duration || Math.abs((g - (S && "time" in S ? S.time : m._time)) / m.timeScale());
          F._dur !== L && fh(F, L, 0, 1).render(F._time, !0, !0), D = 1;
        }
        C && C.apply(F, O || []);
      }
    }, u));
    return k ? F.render(0) : F;
  }, s.tweenFromTo = function(d, u, m) {
    return this.tweenTo(u, bo({
      startAt: {
        time: Mo(this, d)
      }
    }, m));
  }, s.recent = function() {
    return this._recent;
  }, s.nextLabel = function(d) {
    return d === void 0 && (d = this._time), Ep(this, Mo(this, d));
  }, s.previousLabel = function(d) {
    return d === void 0 && (d = this._time), Ep(this, Mo(this, d), 1);
  }, s.currentLabel = function(d) {
    return arguments.length ? this.seek(d, !0) : this.previousLabel(this._time + nn);
  }, s.shiftChildren = function(d, u, m) {
    m === void 0 && (m = 0);
    for (var g = this._first, _ = this.labels, S; g; )
      g._start >= m && (g._start += d, g._end += d), g = g._next;
    if (u)
      for (S in _)
        _[S] >= m && (_[S] += d);
    return Ml(this);
  }, s.invalidate = function(d) {
    var u = this._first;
    for (this._lock = 0; u; )
      u.invalidate(d), u = u._next;
    return x.prototype.invalidate.call(this, d);
  }, s.clear = function(d) {
    d === void 0 && (d = !0);
    for (var u = this._first, m; u; )
      m = u._next, this.remove(u), u = m;
    return this._dp && (this._time = this._tTime = this._pTime = 0), d && (this.labels = {}), Ml(this);
  }, s.totalDuration = function(d) {
    var u = 0, m = this, g = m._last, _ = So, S, C, O;
    if (arguments.length)
      return m.timeScale((m._repeat < 0 ? m.duration() : m.totalDuration()) / (m.reversed() ? -d : d));
    if (m._dirty) {
      for (O = m.parent; g; )
        S = g._prev, g._dirty && g.totalDuration(), C = g._start, C > _ && m._sort && g._ts && !m._lock ? (m._lock = 1, ss(m, g, C - g._delay, 1)._lock = 0) : _ = C, C < 0 && g._ts && (u -= C, (!O && !m._dp || O && O.smoothChildTiming) && (m._start += C / m._ts, m._time -= C, m._tTime -= C), m.shiftChildren(-C, !1, -1 / 0), _ = 0), g._end > u && g._ts && (u = g._end), g = S;
      fh(m, m === yn && m._time > u ? m._time : u, 1, 1), m._dirty = 0;
    }
    return m._tDur;
  }, a.updateRoot = function(d) {
    if (yn._ts && (td(yn, ju(d, yn)), Kp = Kr.frame), Kr.frame >= wp) {
      wp += to.autoSleep || 120;
      var u = yn._first;
      if ((!u || !u._ts) && to.autoSleep && Kr._listeners.length < 2) {
        for (; u && !u._ts; )
          u = u._next;
        u || Kr.sleep();
      }
    }
  }, a;
}(tu);
bo(Tr.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var L_ = function(a, s, c, d, u, m, g) {
  var _ = new Nr(this._pt, a, s, 0, 1, Ad, null, u), S = 0, C = 0, O, k, D, F, E, L, T, M;
  for (_.b = c, _.e = d, c += "", d += "", (T = ~d.indexOf("random(")) && (d = Kh(d)), m && (M = [c, d], m(M, a, s), c = M[0], d = M[1]), k = c.match(Lc) || []; O = Lc.exec(d); )
    F = O[0], E = d.substring(S, O.index), D ? D = (D + 1) % 5 : E.substr(-5) === "rgba(" && (D = 1), F !== k[C++] && (L = parseFloat(k[C - 1]) || 0, _._pt = {
      _next: _._pt,
      p: E || C === 1 ? E : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: L,
      c: F.charAt(1) === "=" ? ah(L, F) - L : parseFloat(F) - L,
      m: D && D < 4 ? Math.round : 0
    }, S = Lc.lastIndex);
  return _.c = S < d.length ? d.substring(S, d.length) : "", _.fp = g, (qp.test(d) || T) && (_.e = 0), this._pt = _, _;
}, gf = function(a, s, c, d, u, m, g, _, S, C) {
  An(d) && (d = d(u || 0, a, m));
  var O = a[s], k = c !== "get" ? c : An(O) ? S ? a[s.indexOf("set") || !An(a["get" + s.substr(3)]) ? s : "get" + s.substr(3)](S) : a[s]() : O, D = An(O) ? S ? z_ : bd : yf, F;
  if (Yn(d) && (~d.indexOf("random(") && (d = Kh(d)), d.charAt(1) === "=" && (F = ah(k, d) + (cr(k) || 0), (F || F === 0) && (d = F))), !C || k !== d || Jc)
    return !isNaN(k * d) && d !== "" ? (F = new Nr(this._pt, a, s, +k || 0, d - (k || 0), typeof O == "boolean" ? B_ : Cd, 0, D), S && (F.fp = S), g && F.modifier(g, this, a), this._pt = F) : (!O && !(s in a) && ff(s, d), L_.call(this, a, s, k, d, D, _ || to.stringFilter, S));
}, R_ = function(a, s, c, d, u) {
  if (An(a) && (a = Zh(a, u, s, c, d)), !hs(a) || a.style && a.nodeType || pr(a) || jp(a))
    return Yn(a) ? Zh(a, u, s, c, d) : a;
  var m = {}, g;
  for (g in a)
    m[g] = Zh(a[g], u, s, c, d);
  return m;
}, Md = function(a, s, c, d, u, m) {
  var g, _, S, C;
  if ($r[a] && (g = new $r[a]()).init(u, g.rawVars ? s[a] : R_(s[a], d, u, m, c), c, d, m) !== !1 && (c._pt = _ = new Nr(c._pt, u, a, 0, 1, g.render, g, 0, g.priority), c !== sh))
    for (S = c._ptLookup[c._targets.indexOf(u)], C = g._props.length; C--; )
      S[g._props[C]] = _;
  return g;
}, Aa, Jc, vf = function x(a, s, c) {
  var d = a.vars, u = d.ease, m = d.startAt, g = d.immediateRender, _ = d.lazy, S = d.onUpdate, C = d.runBackwards, O = d.yoyoEase, k = d.keyframes, D = d.autoRevert, F = a._dur, E = a._startAt, L = a._targets, T = a.parent, M = T && T.data === "nested" ? T.vars.targets : L, R = a._overwrite === "auto" && !lf, b = a.timeline, U, N, j, J, K, ct, It, et, _t, G, Pt, Et, At;
  if (b && (!k || !u) && (u = "none"), a._ease = Sl(u, uh.ease), a._yEase = O ? _d(Sl(O === !0 ? u : O, uh.ease)) : 0, O && a._yoyo && !a._repeat && (O = a._yEase, a._yEase = a._ease, a._ease = O), a._from = !b && !!d.runBackwards, !b || k && !d.stagger) {
    if (et = L[0] ? Tl(L[0]).harness : 0, Et = et && d[et.prop], U = Wu(d, pf), E && (E._zTime < 0 && E.progress(1), s < 0 && C && g && !D ? E.render(-1, !0) : E.revert(C && F ? Bu : o_), E._lazy = 0), m) {
      if (Ia(a._startAt = kn.set(L, bo({
        data: "isStart",
        overwrite: !1,
        parent: T,
        immediateRender: !0,
        lazy: !E && kr(_),
        startAt: null,
        delay: 0,
        onUpdate: S && function() {
          return Qr(a, "onUpdate");
        },
        stagger: 0
      }, m))), a._startAt._dp = 0, a._startAt._sat = a, s < 0 && (fr || !g && !D) && a._startAt.revert(Bu), g && F && s <= 0 && c <= 0) {
        s && (a._zTime = s);
        return;
      }
    } else if (C && F && !E) {
      if (s && (g = !1), j = bo({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: g && !E && kr(_),
        immediateRender: g,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: T
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, U), Et && (j[et.prop] = Et), Ia(a._startAt = kn.set(L, j)), a._startAt._dp = 0, a._startAt._sat = a, s < 0 && (fr ? a._startAt.revert(Bu) : a._startAt.render(-1, !0)), a._zTime = s, !g)
        x(a._startAt, nn, nn);
      else if (!s)
        return;
    }
    for (a._pt = a._ptCache = 0, _ = F && kr(_) || _ && !F, N = 0; N < L.length; N++) {
      if (K = L[N], It = K._gsap || mf(L)[N]._gsap, a._ptLookup[N] = G = {}, Wc[It.id] && Ra.length && Vu(), Pt = M === L ? N : M.indexOf(K), et && (_t = new et()).init(K, Et || U, a, Pt, M) !== !1 && (a._pt = J = new Nr(a._pt, K, _t.name, 0, 1, _t.render, _t, 0, _t.priority), _t._props.forEach(function(fe) {
        G[fe] = J;
      }), _t.priority && (ct = 1)), !et || Et)
        for (j in U)
          $r[j] && (_t = Md(j, U, a, Pt, K, M)) ? _t.priority && (ct = 1) : G[j] = J = gf.call(a, K, j, "get", U[j], Pt, M, 0, d.stringFilter);
      a._op && a._op[N] && a.kill(K, a._op[N]), R && a._pt && (Aa = a, yn.killTweensOf(K, G, a.globalTime(s)), At = !a.parent, Aa = 0), a._pt && _ && (Wc[It.id] = 1);
    }
    ct && Pd(a), a._onInit && a._onInit(a);
  }
  a._onUpdate = S, a._initted = (!a._op || a._pt) && !At, k && s <= 0 && b.render(So, !0, !0);
}, O_ = function(a, s, c, d, u, m, g, _) {
  var S = (a._pt && a._ptCache || (a._ptCache = {}))[s], C, O, k, D;
  if (!S)
    for (S = a._ptCache[s] = [], k = a._ptLookup, D = a._targets.length; D--; ) {
      if (C = k[D][s], C && C.d && C.d._pt)
        for (C = C.d._pt; C && C.p !== s && C.fp !== s; )
          C = C._next;
      if (!C)
        return Jc = 1, a.vars[s] = "+=0", vf(a, g), Jc = 0, _ ? Jh(s + " not eligible for reset") : 1;
      S.push(C);
    }
  for (D = S.length; D--; )
    O = S[D], C = O._pt || O, C.s = (d || d === 0) && !u ? d : C.s + (d || 0) + m * C.c, C.c = c - C.s, O.e && (O.e = In(c) + cr(O.e)), O.b && (O.b = C.s + cr(O.b));
}, I_ = function(a, s) {
  var c = a[0] ? Tl(a[0]).harness : 0, d = c && c.aliases, u, m, g, _;
  if (!d)
    return s;
  u = bl({}, s);
  for (m in d)
    if (m in u)
      for (_ = d[m].split(","), g = _.length; g--; )
        u[_[g]] = u[m];
  return u;
}, D_ = function(a, s, c, d) {
  var u = s.ease || d || "power1.inOut", m, g;
  if (pr(s))
    g = c[a] || (c[a] = []), s.forEach(function(_, S) {
      return g.push({
        t: S / (s.length - 1) * 100,
        v: _,
        e: u
      });
    });
  else
    for (m in s)
      g = c[m] || (c[m] = []), m === "ease" || g.push({
        t: parseFloat(a),
        v: s[m],
        e: u
      });
}, Zh = function(a, s, c, d, u) {
  return An(a) ? a.call(s, c, d, u) : Yn(a) && ~a.indexOf("random(") ? Kh(a) : a;
}, Sd = df + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Ed = {};
Br(Sd + ",id,stagger,delay,duration,paused,scrollTrigger", function(x) {
  return Ed[x] = 1;
});
var kn = /* @__PURE__ */ function(x) {
  Vp(a, x);
  function a(c, d, u, m) {
    var g;
    typeof d == "number" && (u.duration = d, d = u, u = null), g = x.call(this, m ? d : qh(d)) || this;
    var _ = g.vars, S = _.duration, C = _.delay, O = _.immediateRender, k = _.stagger, D = _.overwrite, F = _.keyframes, E = _.defaults, L = _.scrollTrigger, T = _.yoyoEase, M = d.parent || yn, R = (pr(c) || jp(c) ? js(c[0]) : "length" in d) ? [c] : Eo(c), b, U, N, j, J, K, ct, It;
    if (g._targets = R.length ? mf(R) : Jh("GSAP target " + c + " not found. https://gsap.com", !to.nullTargetWarn) || [], g._ptLookup = [], g._overwrite = D, F || k || ku(S) || ku(C)) {
      if (d = g.vars, b = g.timeline = new Tr({
        data: "nested",
        defaults: E || {},
        targets: M && M.data === "nested" ? M.vars.targets : R
      }), b.kill(), b.parent = b._dp = Vs(g), b._start = 0, k || ku(S) || ku(C)) {
        if (j = R.length, ct = k && hd(k), hs(k))
          for (J in k)
            ~Sd.indexOf(J) && (It || (It = {}), It[J] = k[J]);
        for (U = 0; U < j; U++)
          N = Wu(d, Ed), N.stagger = 0, T && (N.yoyoEase = T), It && bl(N, It), K = R[U], N.duration = +Zh(S, Vs(g), U, K, R), N.delay = (+Zh(C, Vs(g), U, K, R) || 0) - g._delay, !k && j === 1 && N.delay && (g._delay = C = N.delay, g._start += C, N.delay = 0), b.to(K, N, ct ? ct(U, K, R) : 0), b._ease = Ni.none;
        b.duration() ? S = C = 0 : g.timeline = 0;
      } else if (F) {
        qh(bo(b.vars.defaults, {
          ease: "none"
        })), b._ease = Sl(F.ease || d.ease || "none");
        var et = 0, _t, G, Pt;
        if (pr(F))
          F.forEach(function(Et) {
            return b.to(R, Et, ">");
          }), b.duration();
        else {
          N = {};
          for (J in F)
            J === "ease" || J === "easeEach" || D_(J, F[J], N, F.easeEach);
          for (J in N)
            for (_t = N[J].sort(function(Et, At) {
              return Et.t - At.t;
            }), et = 0, U = 0; U < _t.length; U++)
              G = _t[U], Pt = {
                ease: G.e,
                duration: (G.t - (U ? _t[U - 1].t : 0)) / 100 * S
              }, Pt[J] = G.v, b.to(R, Pt, et), et += Pt.duration;
          b.duration() < S && b.to({}, {
            duration: S - b.duration()
          });
        }
      }
      S || g.duration(S = b.duration());
    } else
      g.timeline = 0;
    return D === !0 && !lf && (Aa = Vs(g), yn.killTweensOf(R), Aa = 0), ss(M, Vs(g), u), d.reversed && g.reverse(), d.paused && g.paused(!0), (O || !S && !F && g._start === qn(M._time) && kr(O) && c_(Vs(g)) && M.data !== "nested") && (g._tTime = -nn, g.render(Math.max(0, -C) || 0)), L && od(Vs(g), L), g;
  }
  var s = a.prototype;
  return s.render = function(d, u, m) {
    var g = this._time, _ = this._tDur, S = this._dur, C = d < 0, O = d > _ - nn && !C ? _ : d < nn ? 0 : d, k, D, F, E, L, T, M, R, b;
    if (!S)
      p_(this, d, u, m);
    else if (O !== this._tTime || !d || m || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== C) {
      if (k = O, R = this.timeline, this._repeat) {
        if (E = S + this._rDelay, this._repeat < -1 && C)
          return this.totalTime(E * 100 + d, u, m);
        if (k = qn(O % E), O === _ ? (F = this._repeat, k = S) : (F = ~~(O / E), F && F === qn(O / E) && (k = S, F--), k > S && (k = S)), T = this._yoyo && F & 1, T && (b = this._yEase, k = S - k), L = ch(this._tTime, E), k === g && !m && this._initted && F === L)
          return this._tTime = O, this;
        F !== L && (R && this._yEase && xd(R, T), this.vars.repeatRefresh && !T && !this._lock && this._time !== E && this._initted && (this._lock = m = 1, this.render(qn(E * F), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (sd(this, C ? d : k, m, u, O))
          return this._tTime = 0, this;
        if (g !== this._time && !(m && this.vars.repeatRefresh && F !== L))
          return this;
        if (S !== this._dur)
          return this.render(d, u, m);
      }
      if (this._tTime = O, this._time = k, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = M = (b || this._ease)(k / S), this._from && (this.ratio = M = 1 - M), k && !g && !u && !F && (Qr(this, "onStart"), this._tTime !== O))
        return this;
      for (D = this._pt; D; )
        D.r(M, D.d), D = D._next;
      R && R.render(d < 0 ? d : R._dur * R._ease(k / this._dur), u, m) || this._startAt && (this._zTime = d), this._onUpdate && !u && (C && jc(this, d, u, m), Qr(this, "onUpdate")), this._repeat && F !== L && this.vars.onRepeat && !u && this.parent && Qr(this, "onRepeat"), (O === this._tDur || !O) && this._tTime === O && (C && !this._onUpdate && jc(this, d, !0, !0), (d || !S) && (O === this._tDur && this._ts > 0 || !O && this._ts < 0) && Ia(this, 1), !u && !(C && !g) && (O || g || T) && (Qr(this, O === _ ? "onComplete" : "onReverseComplete", !0), this._prom && !(O < _ && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, s.targets = function() {
    return this._targets;
  }, s.invalidate = function(d) {
    return (!d || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(d), x.prototype.invalidate.call(this, d);
  }, s.resetTo = function(d, u, m, g, _) {
    Qh || Kr.wake(), this._ts || this.play();
    var S = Math.min(this._dur, (this._dp._time - this._start) * this._ts), C;
    return this._initted || vf(this, S), C = this._ease(S / this._dur), O_(this, d, u, m, g, C, S, _) ? this.resetTo(d, u, m, g, 1) : (Qu(this, 0), this.parent || nd(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, s.kill = function(d, u) {
    if (u === void 0 && (u = "all"), !d && (!u || u === "all"))
      return this._lazy = this._pt = 0, this.parent ? jh(this) : this;
    if (this.timeline) {
      var m = this.timeline.totalDuration();
      return this.timeline.killTweensOf(d, u, Aa && Aa.vars.overwrite !== !0)._first || jh(this), this.parent && m !== this.timeline.totalDuration() && fh(this, this._dur * this.timeline._tDur / m, 0, 1), this;
    }
    var g = this._targets, _ = d ? Eo(d) : g, S = this._ptLookup, C = this._pt, O, k, D, F, E, L, T;
    if ((!u || u === "all") && h_(g, _))
      return u === "all" && (this._pt = 0), jh(this);
    for (O = this._op = this._op || [], u !== "all" && (Yn(u) && (E = {}, Br(u, function(M) {
      return E[M] = 1;
    }), u = E), u = I_(g, u)), T = g.length; T--; )
      if (~_.indexOf(g[T])) {
        k = S[T], u === "all" ? (O[T] = u, F = k, D = {}) : (D = O[T] = O[T] || {}, F = u);
        for (E in F)
          L = k && k[E], L && ((!("kill" in L.d) || L.d.kill(E) === !0) && $u(this, L, "_pt"), delete k[E]), D !== "all" && (D[E] = 1);
      }
    return this._initted && !this._pt && C && jh(this), this;
  }, a.to = function(d, u) {
    return new a(d, u, arguments[2]);
  }, a.from = function(d, u) {
    return Yh(1, arguments);
  }, a.delayedCall = function(d, u, m, g) {
    return new a(u, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: d,
      onComplete: u,
      onReverseComplete: u,
      onCompleteParams: m,
      onReverseCompleteParams: m,
      callbackScope: g
    });
  }, a.fromTo = function(d, u, m) {
    return Yh(2, arguments);
  }, a.set = function(d, u) {
    return u.duration = 0, u.repeatDelay || (u.repeat = 0), new a(d, u);
  }, a.killTweensOf = function(d, u, m) {
    return yn.killTweensOf(d, u, m);
  }, a;
}(tu);
bo(kn.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
Br("staggerTo,staggerFrom,staggerFromTo", function(x) {
  kn[x] = function() {
    var a = new Tr(), s = qc.call(arguments, 0);
    return s.splice(x === "staggerFromTo" ? 5 : 4, 0, 0), a[x].apply(a, s);
  };
});
var yf = function(a, s, c) {
  return a[s] = c;
}, bd = function(a, s, c) {
  return a[s](c);
}, z_ = function(a, s, c, d) {
  return a[s](d.fp, c);
}, k_ = function(a, s, c) {
  return a.setAttribute(s, c);
}, _f = function(a, s) {
  return An(a[s]) ? bd : hf(a[s]) && a.setAttribute ? k_ : yf;
}, Cd = function(a, s) {
  return s.set(s.t, s.p, Math.round((s.s + s.c * a) * 1e6) / 1e6, s);
}, B_ = function(a, s) {
  return s.set(s.t, s.p, !!(s.s + s.c * a), s);
}, Ad = function(a, s) {
  var c = s._pt, d = "";
  if (!a && s.b)
    d = s.b;
  else if (a === 1 && s.e)
    d = s.e;
  else {
    for (; c; )
      d = c.p + (c.m ? c.m(c.s + c.c * a) : Math.round((c.s + c.c * a) * 1e4) / 1e4) + d, c = c._next;
    d += s.c;
  }
  s.set(s.t, s.p, d, s);
}, xf = function(a, s) {
  for (var c = s._pt; c; )
    c.r(a, c.d), c = c._next;
}, N_ = function(a, s, c, d) {
  for (var u = this._pt, m; u; )
    m = u._next, u.p === d && u.modifier(a, s, c), u = m;
}, F_ = function(a) {
  for (var s = this._pt, c, d; s; )
    d = s._next, s.p === a && !s.op || s.op === a ? $u(this, s, "_pt") : s.dep || (c = 1), s = d;
  return !c;
}, U_ = function(a, s, c, d) {
  d.mSet(a, s, d.m.call(d.tween, c, d.mt), d);
}, Pd = function(a) {
  for (var s = a._pt, c, d, u, m; s; ) {
    for (c = s._next, d = u; d && d.pr > s.pr; )
      d = d._next;
    (s._prev = d ? d._prev : m) ? s._prev._next = s : u = s, (s._next = d) ? d._prev = s : m = s, s = c;
  }
  a._pt = u;
}, Nr = /* @__PURE__ */ function() {
  function x(s, c, d, u, m, g, _, S, C) {
    this.t = c, this.s = u, this.c = m, this.p = d, this.r = g || Cd, this.d = _ || this, this.set = S || yf, this.pr = C || 0, this._next = s, s && (s._prev = this);
  }
  var a = x.prototype;
  return a.modifier = function(c, d, u) {
    this.mSet = this.mSet || this.set, this.set = U_, this.m = c, this.mt = u, this.tween = d;
  }, x;
}();
Br(df + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(x) {
  return pf[x] = 1;
});
eo.TweenMax = eo.TweenLite = kn;
eo.TimelineLite = eo.TimelineMax = Tr;
yn = new Tr({
  sortChildren: !1,
  defaults: uh,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
to.stringFilter = yd;
var El = [], Fu = {}, G_ = [], Cp = 0, H_ = 0, zc = function(a) {
  return (Fu[a] || G_).map(function(s) {
    return s();
  });
}, $c = function() {
  var a = Date.now(), s = [];
  a - Cp > 2 && (zc("matchMediaInit"), El.forEach(function(c) {
    var d = c.queries, u = c.conditions, m, g, _, S;
    for (g in d)
      m = os.matchMedia(d[g]).matches, m && (_ = 1), m !== u[g] && (u[g] = m, S = 1);
    S && (c.revert(), _ && s.push(c));
  }), zc("matchMediaRevert"), s.forEach(function(c) {
    return c.onMatch(c, function(d) {
      return c.add(null, d);
    });
  }), Cp = a, zc("matchMedia"));
}, Ld = /* @__PURE__ */ function() {
  function x(s, c) {
    this.selector = c && Yc(c), this.data = [], this._r = [], this.isReverted = !1, this.id = H_++, s && this.add(s);
  }
  var a = x.prototype;
  return a.add = function(c, d, u) {
    An(c) && (u = d, d = c, c = An);
    var m = this, g = function() {
      var S = un, C = m.selector, O;
      return S && S !== m && S.data.push(m), u && (m.selector = Yc(u)), un = m, O = d.apply(m, arguments), An(O) && m._r.push(O), un = S, m.selector = C, m.isReverted = !1, O;
    };
    return m.last = g, c === An ? g(m, function(_) {
      return m.add(null, _);
    }) : c ? m[c] = g : g;
  }, a.ignore = function(c) {
    var d = un;
    un = null, c(this), un = d;
  }, a.getTweens = function() {
    var c = [];
    return this.data.forEach(function(d) {
      return d instanceof x ? c.push.apply(c, d.getTweens()) : d instanceof kn && !(d.parent && d.parent.data === "nested") && c.push(d);
    }), c;
  }, a.clear = function() {
    this._r.length = this.data.length = 0;
  }, a.kill = function(c, d) {
    var u = this;
    if (c ? function() {
      for (var g = u.getTweens(), _ = u.data.length, S; _--; )
        S = u.data[_], S.data === "isFlip" && (S.revert(), S.getChildren(!0, !0, !1).forEach(function(C) {
          return g.splice(g.indexOf(C), 1);
        }));
      for (g.map(function(C) {
        return {
          g: C._dur || C._delay || C._sat && !C._sat.vars.immediateRender ? C.globalTime(0) : -1 / 0,
          t: C
        };
      }).sort(function(C, O) {
        return O.g - C.g || -1 / 0;
      }).forEach(function(C) {
        return C.t.revert(c);
      }), _ = u.data.length; _--; )
        S = u.data[_], S instanceof Tr ? S.data !== "nested" && (S.scrollTrigger && S.scrollTrigger.revert(), S.kill()) : !(S instanceof kn) && S.revert && S.revert(c);
      u._r.forEach(function(C) {
        return C(c, u);
      }), u.isReverted = !0;
    }() : this.data.forEach(function(g) {
      return g.kill && g.kill();
    }), this.clear(), d)
      for (var m = El.length; m--; )
        El[m].id === this.id && El.splice(m, 1);
  }, a.revert = function(c) {
    this.kill(c || {});
  }, x;
}(), V_ = /* @__PURE__ */ function() {
  function x(s) {
    this.contexts = [], this.scope = s, un && un.data.push(this);
  }
  var a = x.prototype;
  return a.add = function(c, d, u) {
    hs(c) || (c = {
      matches: c
    });
    var m = new Ld(0, u || this.scope), g = m.conditions = {}, _, S, C;
    un && !m.selector && (m.selector = un.selector), this.contexts.push(m), d = m.add("onMatch", d), m.queries = c;
    for (S in c)
      S === "all" ? C = 1 : (_ = os.matchMedia(c[S]), _ && (El.indexOf(m) < 0 && El.push(m), (g[S] = _.matches) && (C = 1), _.addListener ? _.addListener($c) : _.addEventListener("change", $c)));
    return C && d(m, function(O) {
      return m.add(null, O);
    }), this;
  }, a.revert = function(c) {
    this.kill(c || {});
  }, a.kill = function(c) {
    this.contexts.forEach(function(d) {
      return d.kill(c, !0);
    });
  }, x;
}(), Xu = {
  registerPlugin: function() {
    for (var a = arguments.length, s = new Array(a), c = 0; c < a; c++)
      s[c] = arguments[c];
    s.forEach(function(d) {
      return md(d);
    });
  },
  timeline: function(a) {
    return new Tr(a);
  },
  getTweensOf: function(a, s) {
    return yn.getTweensOf(a, s);
  },
  getProperty: function(a, s, c, d) {
    Yn(a) && (a = Eo(a)[0]);
    var u = Tl(a || {}).get, m = c ? id : ed;
    return c === "native" && (c = ""), a && (s ? m(($r[s] && $r[s].get || u)(a, s, c, d)) : function(g, _, S) {
      return m(($r[g] && $r[g].get || u)(a, g, _, S));
    });
  },
  quickSetter: function(a, s, c) {
    if (a = Eo(a), a.length > 1) {
      var d = a.map(function(C) {
        return Ur.quickSetter(C, s, c);
      }), u = d.length;
      return function(C) {
        for (var O = u; O--; )
          d[O](C);
      };
    }
    a = a[0] || {};
    var m = $r[s], g = Tl(a), _ = g.harness && (g.harness.aliases || {})[s] || s, S = m ? function(C) {
      var O = new m();
      sh._pt = 0, O.init(a, c ? C + c : C, sh, 0, [a]), O.render(1, O), sh._pt && xf(1, sh);
    } : g.set(a, _);
    return m ? S : function(C) {
      return S(a, _, c ? C + c : C, g, 1);
    };
  },
  quickTo: function(a, s, c) {
    var d, u = Ur.to(a, bl((d = {}, d[s] = "+=0.1", d.paused = !0, d), c || {})), m = function(_, S, C) {
      return u.resetTo(s, _, S, C);
    };
    return m.tween = u, m;
  },
  isTweening: function(a) {
    return yn.getTweensOf(a, !0).length > 0;
  },
  defaults: function(a) {
    return a && a.ease && (a.ease = Sl(a.ease, uh.ease)), Tp(uh, a || {});
  },
  config: function(a) {
    return Tp(to, a || {});
  },
  registerEffect: function(a) {
    var s = a.name, c = a.effect, d = a.plugins, u = a.defaults, m = a.extendTimeline;
    (d || "").split(",").forEach(function(g) {
      return g && !$r[g] && !eo[g] && Jh(s + " effect requires " + g + " plugin.");
    }), Rc[s] = function(g, _, S) {
      return c(Eo(g), bo(_ || {}, u), S);
    }, m && (Tr.prototype[s] = function(g, _, S) {
      return this.add(Rc[s](g, hs(_) ? _ : (S = _) && {}, this), S);
    });
  },
  registerEase: function(a, s) {
    Ni[a] = Sl(s);
  },
  parseEase: function(a, s) {
    return arguments.length ? Sl(a, s) : Ni;
  },
  getById: function(a) {
    return yn.getById(a);
  },
  exportRoot: function(a, s) {
    a === void 0 && (a = {});
    var c = new Tr(a), d, u;
    for (c.smoothChildTiming = kr(a.smoothChildTiming), yn.remove(c), c._dp = 0, c._time = c._tTime = yn._time, d = yn._first; d; )
      u = d._next, (s || !(!d._dur && d instanceof kn && d.vars.onComplete === d._targets[0])) && ss(c, d, d._start - d._delay), d = u;
    return ss(yn, c, 0), c;
  },
  context: function(a, s) {
    return a ? new Ld(a, s) : un;
  },
  matchMedia: function(a) {
    return new V_(a);
  },
  matchMediaRefresh: function() {
    return El.forEach(function(a) {
      var s = a.conditions, c, d;
      for (d in s)
        s[d] && (s[d] = !1, c = 1);
      c && a.revert();
    }) || $c();
  },
  addEventListener: function(a, s) {
    var c = Fu[a] || (Fu[a] = []);
    ~c.indexOf(s) || c.push(s);
  },
  removeEventListener: function(a, s) {
    var c = Fu[a], d = c && c.indexOf(s);
    d >= 0 && c.splice(d, 1);
  },
  utils: {
    wrap: w_,
    wrapYoyo: T_,
    distribute: hd,
    random: cd,
    snap: ud,
    normalize: x_,
    getUnit: cr,
    clamp: g_,
    splitColor: gd,
    toArray: Eo,
    selector: Yc,
    mapRange: pd,
    pipe: y_,
    unitize: __,
    interpolate: M_,
    shuffle: ld
  },
  install: Jp,
  effects: Rc,
  ticker: Kr,
  updateRoot: Tr.updateRoot,
  plugins: $r,
  globalTimeline: yn,
  core: {
    PropTween: Nr,
    globals: $p,
    Tween: kn,
    Timeline: Tr,
    Animation: tu,
    getCache: Tl,
    _removeLinkedListItem: $u,
    reverting: function() {
      return fr;
    },
    context: function(a) {
      return a && un && (un.data.push(a), a._ctx = un), un;
    },
    suppressOverwrites: function(a) {
      return lf = a;
    }
  }
};
Br("to,from,fromTo,delayedCall,set,killTweensOf", function(x) {
  return Xu[x] = kn[x];
});
Kr.add(Tr.updateRoot);
sh = Xu.to({}, {
  duration: 0
});
var W_ = function(a, s) {
  for (var c = a._pt; c && c.p !== s && c.op !== s && c.fp !== s; )
    c = c._next;
  return c;
}, j_ = function(a, s) {
  var c = a._targets, d, u, m;
  for (d in s)
    for (u = c.length; u--; )
      m = a._ptLookup[u][d], m && (m = m.d) && (m._pt && (m = W_(m, d)), m && m.modifier && m.modifier(s[d], a, c[u], d));
}, kc = function(a, s) {
  return {
    name: a,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(d, u, m) {
      m._onInit = function(g) {
        var _, S;
        if (Yn(u) && (_ = {}, Br(u, function(C) {
          return _[C] = 1;
        }), u = _), s) {
          _ = {};
          for (S in u)
            _[S] = s(u[S]);
          u = _;
        }
        j_(g, u);
      };
    }
  };
}, Ur = Xu.registerPlugin({
  name: "attr",
  init: function(a, s, c, d, u) {
    var m, g, _;
    this.tween = c;
    for (m in s)
      _ = a.getAttribute(m) || "", g = this.add(a, "setAttribute", (_ || 0) + "", s[m], d, u, 0, 0, m), g.op = m, g.b = _, this._props.push(m);
  },
  render: function(a, s) {
    for (var c = s._pt; c; )
      fr ? c.set(c.t, c.p, c.b, c) : c.r(a, c.d), c = c._next;
  }
}, {
  name: "endArray",
  init: function(a, s) {
    for (var c = s.length; c--; )
      this.add(a, c, a[c] || 0, s[c], 0, 0, 0, 0, 0, 1);
  }
}, kc("roundProps", Zc), kc("modifiers"), kc("snap", ud)) || Xu;
kn.version = Tr.version = Ur.version = "3.12.5";
Zp = 1;
uf() && ph();
Ni.Power0;
Ni.Power1;
Ni.Power2;
Ni.Power3;
Ni.Power4;
Ni.Linear;
Ni.Quad;
Ni.Cubic;
Ni.Quart;
Ni.Quint;
Ni.Strong;
Ni.Elastic;
Ni.Back;
Ni.SteppedEase;
Ni.Bounce;
Ni.Sine;
Ni.Expo;
Ni.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ap, Pa, lh, wf, wl, Pp, Tf, X_ = function() {
  return typeof window < "u";
}, Xs = {}, xl = 180 / Math.PI, hh = Math.PI / 180, nh = Math.atan2, Lp = 1e8, Mf = /([A-Z])/g, q_ = /(left|right|width|margin|padding|x)/i, Y_ = /[\s,\(]\S/, as = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, Kc = function(a, s) {
  return s.set(s.t, s.p, Math.round((s.s + s.c * a) * 1e4) / 1e4 + s.u, s);
}, Z_ = function(a, s) {
  return s.set(s.t, s.p, a === 1 ? s.e : Math.round((s.s + s.c * a) * 1e4) / 1e4 + s.u, s);
}, J_ = function(a, s) {
  return s.set(s.t, s.p, a ? Math.round((s.s + s.c * a) * 1e4) / 1e4 + s.u : s.b, s);
}, $_ = function(a, s) {
  var c = s.s + s.c * a;
  s.set(s.t, s.p, ~~(c + (c < 0 ? -0.5 : 0.5)) + s.u, s);
}, Rd = function(a, s) {
  return s.set(s.t, s.p, a ? s.e : s.b, s);
}, Od = function(a, s) {
  return s.set(s.t, s.p, a !== 1 ? s.b : s.e, s);
}, K_ = function(a, s, c) {
  return a.style[s] = c;
}, Q_ = function(a, s, c) {
  return a.style.setProperty(s, c);
}, t1 = function(a, s, c) {
  return a._gsap[s] = c;
}, e1 = function(a, s, c) {
  return a._gsap.scaleX = a._gsap.scaleY = c;
}, i1 = function(a, s, c, d, u) {
  var m = a._gsap;
  m.scaleX = m.scaleY = c, m.renderTransform(u, m);
}, n1 = function(a, s, c, d, u) {
  var m = a._gsap;
  m[s] = c, m.renderTransform(u, m);
}, _n = "transform", Fr = _n + "Origin", r1 = function x(a, s) {
  var c = this, d = this.target, u = d.style, m = d._gsap;
  if (a in Xs && u) {
    if (this.tfm = this.tfm || {}, a !== "transform")
      a = as[a] || a, ~a.indexOf(",") ? a.split(",").forEach(function(g) {
        return c.tfm[g] = Ws(d, g);
      }) : this.tfm[a] = m.x ? m[a] : Ws(d, a), a === Fr && (this.tfm.zOrigin = m.zOrigin);
    else
      return as.transform.split(",").forEach(function(g) {
        return x.call(c, g, s);
      });
    if (this.props.indexOf(_n) >= 0)
      return;
    m.svg && (this.svgo = d.getAttribute("data-svg-origin"), this.props.push(Fr, s, "")), a = _n;
  }
  (u || s) && this.props.push(a, s, u[a]);
}, Id = function(a) {
  a.translate && (a.removeProperty("translate"), a.removeProperty("scale"), a.removeProperty("rotate"));
}, o1 = function() {
  var a = this.props, s = this.target, c = s.style, d = s._gsap, u, m;
  for (u = 0; u < a.length; u += 3)
    a[u + 1] ? s[a[u]] = a[u + 2] : a[u + 2] ? c[a[u]] = a[u + 2] : c.removeProperty(a[u].substr(0, 2) === "--" ? a[u] : a[u].replace(Mf, "-$1").toLowerCase());
  if (this.tfm) {
    for (m in this.tfm)
      d[m] = this.tfm[m];
    d.svg && (d.renderTransform(), s.setAttribute("data-svg-origin", this.svgo || "")), u = Tf(), (!u || !u.isStart) && !c[_n] && (Id(c), d.zOrigin && c[Fr] && (c[Fr] += " " + d.zOrigin + "px", d.zOrigin = 0, d.renderTransform()), d.uncache = 1);
  }
}, Dd = function(a, s) {
  var c = {
    target: a,
    props: [],
    revert: o1,
    save: r1
  };
  return a._gsap || Ur.core.getCache(a), s && s.split(",").forEach(function(d) {
    return c.save(d);
  }), c;
}, zd, Qc = function(a, s) {
  var c = Pa.createElementNS ? Pa.createElementNS((s || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), a) : Pa.createElement(a);
  return c && c.style ? c : Pa.createElement(a);
}, ls = function x(a, s, c) {
  var d = getComputedStyle(a);
  return d[s] || d.getPropertyValue(s.replace(Mf, "-$1").toLowerCase()) || d.getPropertyValue(s) || !c && x(a, dh(s) || s, 1) || "";
}, Rp = "O,Moz,ms,Ms,Webkit".split(","), dh = function(a, s, c) {
  var d = s || wl, u = d.style, m = 5;
  if (a in u && !c)
    return a;
  for (a = a.charAt(0).toUpperCase() + a.substr(1); m-- && !(Rp[m] + a in u); )
    ;
  return m < 0 ? null : (m === 3 ? "ms" : m >= 0 ? Rp[m] : "") + a;
}, tf = function() {
  X_() && window.document && (Ap = window, Pa = Ap.document, lh = Pa.documentElement, wl = Qc("div") || {
    style: {}
  }, Qc("div"), _n = dh(_n), Fr = _n + "Origin", wl.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", zd = !!dh("perspective"), Tf = Ur.core.reverting, wf = 1);
}, Bc = function x(a) {
  var s = Qc("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), c = this.parentNode, d = this.nextSibling, u = this.style.cssText, m;
  if (lh.appendChild(s), s.appendChild(this), this.style.display = "block", a)
    try {
      m = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = x;
    } catch {
    }
  else
    this._gsapBBox && (m = this._gsapBBox());
  return c && (d ? c.insertBefore(this, d) : c.appendChild(this)), lh.removeChild(s), this.style.cssText = u, m;
}, Op = function(a, s) {
  for (var c = s.length; c--; )
    if (a.hasAttribute(s[c]))
      return a.getAttribute(s[c]);
}, kd = function(a) {
  var s;
  try {
    s = a.getBBox();
  } catch {
    s = Bc.call(a, !0);
  }
  return s && (s.width || s.height) || a.getBBox === Bc || (s = Bc.call(a, !0)), s && !s.width && !s.x && !s.y ? {
    x: +Op(a, ["x", "cx", "x1"]) || 0,
    y: +Op(a, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : s;
}, Bd = function(a) {
  return !!(a.getCTM && (!a.parentNode || a.ownerSVGElement) && kd(a));
}, Cl = function(a, s) {
  if (s) {
    var c = a.style, d;
    s in Xs && s !== Fr && (s = _n), c.removeProperty ? (d = s.substr(0, 2), (d === "ms" || s.substr(0, 6) === "webkit") && (s = "-" + s), c.removeProperty(d === "--" ? s : s.replace(Mf, "-$1").toLowerCase())) : c.removeAttribute(s);
  }
}, La = function(a, s, c, d, u, m) {
  var g = new Nr(a._pt, s, c, 0, 1, m ? Od : Rd);
  return a._pt = g, g.b = d, g.e = u, a._props.push(c), g;
}, Ip = {
  deg: 1,
  rad: 1,
  turn: 1
}, s1 = {
  grid: 1,
  flex: 1
}, Da = function x(a, s, c, d) {
  var u = parseFloat(c) || 0, m = (c + "").trim().substr((u + "").length) || "px", g = wl.style, _ = q_.test(s), S = a.tagName.toLowerCase() === "svg", C = (S ? "client" : "offset") + (_ ? "Width" : "Height"), O = 100, k = d === "px", D = d === "%", F, E, L, T;
  if (d === m || !u || Ip[d] || Ip[m])
    return u;
  if (m !== "px" && !k && (u = x(a, s, c, "px")), T = a.getCTM && Bd(a), (D || m === "%") && (Xs[s] || ~s.indexOf("adius")))
    return F = T ? a.getBBox()[_ ? "width" : "height"] : a[C], In(D ? u / F * O : u / 100 * F);
  if (g[_ ? "width" : "height"] = O + (k ? m : d), E = ~s.indexOf("adius") || d === "em" && a.appendChild && !S ? a : a.parentNode, T && (E = (a.ownerSVGElement || {}).parentNode), (!E || E === Pa || !E.appendChild) && (E = Pa.body), L = E._gsap, L && D && L.width && _ && L.time === Kr.time && !L.uncache)
    return In(u / L.width * O);
  if (D && (s === "height" || s === "width")) {
    var M = a.style[s];
    a.style[s] = O + d, F = a[C], M ? a.style[s] = M : Cl(a, s);
  } else
    (D || m === "%") && !s1[ls(E, "display")] && (g.position = ls(a, "position")), E === a && (g.position = "static"), E.appendChild(wl), F = wl[C], E.removeChild(wl), g.position = "absolute";
  return _ && D && (L = Tl(E), L.time = Kr.time, L.width = E[C]), In(k ? F * u / O : F && u ? O / F * u : 0);
}, Ws = function(a, s, c, d) {
  var u;
  return wf || tf(), s in as && s !== "transform" && (s = as[s], ~s.indexOf(",") && (s = s.split(",")[0])), Xs[s] && s !== "transform" ? (u = iu(a, d), u = s !== "transformOrigin" ? u[s] : u.svg ? u.origin : Yu(ls(a, Fr)) + " " + u.zOrigin + "px") : (u = a.style[s], (!u || u === "auto" || d || ~(u + "").indexOf("calc(")) && (u = qu[s] && qu[s](a, s, c) || ls(a, s) || Qp(a, s) || (s === "opacity" ? 1 : 0))), c && !~(u + "").trim().indexOf(" ") ? Da(a, s, u, c) + c : u;
}, a1 = function(a, s, c, d) {
  if (!c || c === "none") {
    var u = dh(s, a, 1), m = u && ls(a, u, 1);
    m && m !== c ? (s = u, c = m) : s === "borderColor" && (c = ls(a, "borderTopColor"));
  }
  var g = new Nr(this._pt, a.style, s, 0, 1, Ad), _ = 0, S = 0, C, O, k, D, F, E, L, T, M, R, b, U;
  if (g.b = c, g.e = d, c += "", d += "", d === "auto" && (E = a.style[s], a.style[s] = d, d = ls(a, s) || d, E ? a.style[s] = E : Cl(a, s)), C = [c, d], yd(C), c = C[0], d = C[1], k = c.match(oh) || [], U = d.match(oh) || [], U.length) {
    for (; O = oh.exec(d); )
      L = O[0], M = d.substring(_, O.index), F ? F = (F + 1) % 5 : (M.substr(-5) === "rgba(" || M.substr(-5) === "hsla(") && (F = 1), L !== (E = k[S++] || "") && (D = parseFloat(E) || 0, b = E.substr((D + "").length), L.charAt(1) === "=" && (L = ah(D, L) + b), T = parseFloat(L), R = L.substr((T + "").length), _ = oh.lastIndex - R.length, R || (R = R || to.units[s] || b, _ === d.length && (d += R, g.e += R)), b !== R && (D = Da(a, s, E, R) || 0), g._pt = {
        _next: g._pt,
        p: M || S === 1 ? M : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: D,
        c: T - D,
        m: F && F < 4 || s === "zIndex" ? Math.round : 0
      });
    g.c = _ < d.length ? d.substring(_, d.length) : "";
  } else
    g.r = s === "display" && d === "none" ? Od : Rd;
  return qp.test(d) && (g.e = 0), this._pt = g, g;
}, Dp = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, l1 = function(a) {
  var s = a.split(" "), c = s[0], d = s[1] || "50%";
  return (c === "top" || c === "bottom" || d === "left" || d === "right") && (a = c, c = d, d = a), s[0] = Dp[c] || c, s[1] = Dp[d] || d, s.join(" ");
}, h1 = function(a, s) {
  if (s.tween && s.tween._time === s.tween._dur) {
    var c = s.t, d = c.style, u = s.u, m = c._gsap, g, _, S;
    if (u === "all" || u === !0)
      d.cssText = "", _ = 1;
    else
      for (u = u.split(","), S = u.length; --S > -1; )
        g = u[S], Xs[g] && (_ = 1, g = g === "transformOrigin" ? Fr : _n), Cl(c, g);
    _ && (Cl(c, _n), m && (m.svg && c.removeAttribute("transform"), iu(c, 1), m.uncache = 1, Id(d)));
  }
}, qu = {
  clearProps: function(a, s, c, d, u) {
    if (u.data !== "isFromStart") {
      var m = a._pt = new Nr(a._pt, s, c, 0, 0, h1);
      return m.u = d, m.pr = -10, m.tween = u, a._props.push(c), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, eu = [1, 0, 0, 1, 0, 0], Nd = {}, Fd = function(a) {
  return a === "matrix(1, 0, 0, 1, 0, 0)" || a === "none" || !a;
}, zp = function(a) {
  var s = ls(a, _n);
  return Fd(s) ? eu : s.substr(7).match(Xp).map(In);
}, Sf = function(a, s) {
  var c = a._gsap || Tl(a), d = a.style, u = zp(a), m, g, _, S;
  return c.svg && a.getAttribute("transform") ? (_ = a.transform.baseVal.consolidate().matrix, u = [_.a, _.b, _.c, _.d, _.e, _.f], u.join(",") === "1,0,0,1,0,0" ? eu : u) : (u === eu && !a.offsetParent && a !== lh && !c.svg && (_ = d.display, d.display = "block", m = a.parentNode, (!m || !a.offsetParent) && (S = 1, g = a.nextElementSibling, lh.appendChild(a)), u = zp(a), _ ? d.display = _ : Cl(a, "display"), S && (g ? m.insertBefore(a, g) : m ? m.appendChild(a) : lh.removeChild(a))), s && u.length > 6 ? [u[0], u[1], u[4], u[5], u[12], u[13]] : u);
}, ef = function(a, s, c, d, u, m) {
  var g = a._gsap, _ = u || Sf(a, !0), S = g.xOrigin || 0, C = g.yOrigin || 0, O = g.xOffset || 0, k = g.yOffset || 0, D = _[0], F = _[1], E = _[2], L = _[3], T = _[4], M = _[5], R = s.split(" "), b = parseFloat(R[0]) || 0, U = parseFloat(R[1]) || 0, N, j, J, K;
  c ? _ !== eu && (j = D * L - F * E) && (J = b * (L / j) + U * (-E / j) + (E * M - L * T) / j, K = b * (-F / j) + U * (D / j) - (D * M - F * T) / j, b = J, U = K) : (N = kd(a), b = N.x + (~R[0].indexOf("%") ? b / 100 * N.width : b), U = N.y + (~(R[1] || R[0]).indexOf("%") ? U / 100 * N.height : U)), d || d !== !1 && g.smooth ? (T = b - S, M = U - C, g.xOffset = O + (T * D + M * E) - T, g.yOffset = k + (T * F + M * L) - M) : g.xOffset = g.yOffset = 0, g.xOrigin = b, g.yOrigin = U, g.smooth = !!d, g.origin = s, g.originIsAbsolute = !!c, a.style[Fr] = "0px 0px", m && (La(m, g, "xOrigin", S, b), La(m, g, "yOrigin", C, U), La(m, g, "xOffset", O, g.xOffset), La(m, g, "yOffset", k, g.yOffset)), a.setAttribute("data-svg-origin", b + " " + U);
}, iu = function(a, s) {
  var c = a._gsap || new Td(a);
  if ("x" in c && !s && !c.uncache)
    return c;
  var d = a.style, u = c.scaleX < 0, m = "px", g = "deg", _ = getComputedStyle(a), S = ls(a, Fr) || "0", C, O, k, D, F, E, L, T, M, R, b, U, N, j, J, K, ct, It, et, _t, G, Pt, Et, At, fe, re, Ft, Ot, Bt, ke, ce, Yt;
  return C = O = k = E = L = T = M = R = b = 0, D = F = 1, c.svg = !!(a.getCTM && Bd(a)), _.translate && ((_.translate !== "none" || _.scale !== "none" || _.rotate !== "none") && (d[_n] = (_.translate !== "none" ? "translate3d(" + (_.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (_.rotate !== "none" ? "rotate(" + _.rotate + ") " : "") + (_.scale !== "none" ? "scale(" + _.scale.split(" ").join(",") + ") " : "") + (_[_n] !== "none" ? _[_n] : "")), d.scale = d.rotate = d.translate = "none"), j = Sf(a, c.svg), c.svg && (c.uncache ? (fe = a.getBBox(), S = c.xOrigin - fe.x + "px " + (c.yOrigin - fe.y) + "px", At = "") : At = !s && a.getAttribute("data-svg-origin"), ef(a, At || S, !!At || c.originIsAbsolute, c.smooth !== !1, j)), U = c.xOrigin || 0, N = c.yOrigin || 0, j !== eu && (It = j[0], et = j[1], _t = j[2], G = j[3], C = Pt = j[4], O = Et = j[5], j.length === 6 ? (D = Math.sqrt(It * It + et * et), F = Math.sqrt(G * G + _t * _t), E = It || et ? nh(et, It) * xl : 0, M = _t || G ? nh(_t, G) * xl + E : 0, M && (F *= Math.abs(Math.cos(M * hh))), c.svg && (C -= U - (U * It + N * _t), O -= N - (U * et + N * G))) : (Yt = j[6], ke = j[7], Ft = j[8], Ot = j[9], Bt = j[10], ce = j[11], C = j[12], O = j[13], k = j[14], J = nh(Yt, Bt), L = J * xl, J && (K = Math.cos(-J), ct = Math.sin(-J), At = Pt * K + Ft * ct, fe = Et * K + Ot * ct, re = Yt * K + Bt * ct, Ft = Pt * -ct + Ft * K, Ot = Et * -ct + Ot * K, Bt = Yt * -ct + Bt * K, ce = ke * -ct + ce * K, Pt = At, Et = fe, Yt = re), J = nh(-_t, Bt), T = J * xl, J && (K = Math.cos(-J), ct = Math.sin(-J), At = It * K - Ft * ct, fe = et * K - Ot * ct, re = _t * K - Bt * ct, ce = G * ct + ce * K, It = At, et = fe, _t = re), J = nh(et, It), E = J * xl, J && (K = Math.cos(J), ct = Math.sin(J), At = It * K + et * ct, fe = Pt * K + Et * ct, et = et * K - It * ct, Et = Et * K - Pt * ct, It = At, Pt = fe), L && Math.abs(L) + Math.abs(E) > 359.9 && (L = E = 0, T = 180 - T), D = In(Math.sqrt(It * It + et * et + _t * _t)), F = In(Math.sqrt(Et * Et + Yt * Yt)), J = nh(Pt, Et), M = Math.abs(J) > 2e-4 ? J * xl : 0, b = ce ? 1 / (ce < 0 ? -ce : ce) : 0), c.svg && (At = a.getAttribute("transform"), c.forceCSS = a.setAttribute("transform", "") || !Fd(ls(a, _n)), At && a.setAttribute("transform", At))), Math.abs(M) > 90 && Math.abs(M) < 270 && (u ? (D *= -1, M += E <= 0 ? 180 : -180, E += E <= 0 ? 180 : -180) : (F *= -1, M += M <= 0 ? 180 : -180)), s = s || c.uncache, c.x = C - ((c.xPercent = C && (!s && c.xPercent || (Math.round(a.offsetWidth / 2) === Math.round(-C) ? -50 : 0))) ? a.offsetWidth * c.xPercent / 100 : 0) + m, c.y = O - ((c.yPercent = O && (!s && c.yPercent || (Math.round(a.offsetHeight / 2) === Math.round(-O) ? -50 : 0))) ? a.offsetHeight * c.yPercent / 100 : 0) + m, c.z = k + m, c.scaleX = In(D), c.scaleY = In(F), c.rotation = In(E) + g, c.rotationX = In(L) + g, c.rotationY = In(T) + g, c.skewX = M + g, c.skewY = R + g, c.transformPerspective = b + m, (c.zOrigin = parseFloat(S.split(" ")[2]) || !s && c.zOrigin || 0) && (d[Fr] = Yu(S)), c.xOffset = c.yOffset = 0, c.force3D = to.force3D, c.renderTransform = c.svg ? c1 : zd ? Ud : u1, c.uncache = 0, c;
}, Yu = function(a) {
  return (a = a.split(" "))[0] + " " + a[1];
}, Nc = function(a, s, c) {
  var d = cr(s);
  return In(parseFloat(s) + parseFloat(Da(a, "x", c + "px", d))) + d;
}, u1 = function(a, s) {
  s.z = "0px", s.rotationY = s.rotationX = "0deg", s.force3D = 0, Ud(a, s);
}, yl = "0deg", Wh = "0px", _l = ") ", Ud = function(a, s) {
  var c = s || this, d = c.xPercent, u = c.yPercent, m = c.x, g = c.y, _ = c.z, S = c.rotation, C = c.rotationY, O = c.rotationX, k = c.skewX, D = c.skewY, F = c.scaleX, E = c.scaleY, L = c.transformPerspective, T = c.force3D, M = c.target, R = c.zOrigin, b = "", U = T === "auto" && a && a !== 1 || T === !0;
  if (R && (O !== yl || C !== yl)) {
    var N = parseFloat(C) * hh, j = Math.sin(N), J = Math.cos(N), K;
    N = parseFloat(O) * hh, K = Math.cos(N), m = Nc(M, m, j * K * -R), g = Nc(M, g, -Math.sin(N) * -R), _ = Nc(M, _, J * K * -R + R);
  }
  L !== Wh && (b += "perspective(" + L + _l), (d || u) && (b += "translate(" + d + "%, " + u + "%) "), (U || m !== Wh || g !== Wh || _ !== Wh) && (b += _ !== Wh || U ? "translate3d(" + m + ", " + g + ", " + _ + ") " : "translate(" + m + ", " + g + _l), S !== yl && (b += "rotate(" + S + _l), C !== yl && (b += "rotateY(" + C + _l), O !== yl && (b += "rotateX(" + O + _l), (k !== yl || D !== yl) && (b += "skew(" + k + ", " + D + _l), (F !== 1 || E !== 1) && (b += "scale(" + F + ", " + E + _l), M.style[_n] = b || "translate(0, 0)";
}, c1 = function(a, s) {
  var c = s || this, d = c.xPercent, u = c.yPercent, m = c.x, g = c.y, _ = c.rotation, S = c.skewX, C = c.skewY, O = c.scaleX, k = c.scaleY, D = c.target, F = c.xOrigin, E = c.yOrigin, L = c.xOffset, T = c.yOffset, M = c.forceCSS, R = parseFloat(m), b = parseFloat(g), U, N, j, J, K;
  _ = parseFloat(_), S = parseFloat(S), C = parseFloat(C), C && (C = parseFloat(C), S += C, _ += C), _ || S ? (_ *= hh, S *= hh, U = Math.cos(_) * O, N = Math.sin(_) * O, j = Math.sin(_ - S) * -k, J = Math.cos(_ - S) * k, S && (C *= hh, K = Math.tan(S - C), K = Math.sqrt(1 + K * K), j *= K, J *= K, C && (K = Math.tan(C), K = Math.sqrt(1 + K * K), U *= K, N *= K)), U = In(U), N = In(N), j = In(j), J = In(J)) : (U = O, J = k, N = j = 0), (R && !~(m + "").indexOf("px") || b && !~(g + "").indexOf("px")) && (R = Da(D, "x", m, "px"), b = Da(D, "y", g, "px")), (F || E || L || T) && (R = In(R + F - (F * U + E * j) + L), b = In(b + E - (F * N + E * J) + T)), (d || u) && (K = D.getBBox(), R = In(R + d / 100 * K.width), b = In(b + u / 100 * K.height)), K = "matrix(" + U + "," + N + "," + j + "," + J + "," + R + "," + b + ")", D.setAttribute("transform", K), M && (D.style[_n] = K);
}, f1 = function(a, s, c, d, u) {
  var m = 360, g = Yn(u), _ = parseFloat(u) * (g && ~u.indexOf("rad") ? xl : 1), S = _ - d, C = d + S + "deg", O, k;
  return g && (O = u.split("_")[1], O === "short" && (S %= m, S !== S % (m / 2) && (S += S < 0 ? m : -m)), O === "cw" && S < 0 ? S = (S + m * Lp) % m - ~~(S / m) * m : O === "ccw" && S > 0 && (S = (S - m * Lp) % m - ~~(S / m) * m)), a._pt = k = new Nr(a._pt, s, c, d, S, Z_), k.e = C, k.u = "deg", a._props.push(c), k;
}, kp = function(a, s) {
  for (var c in s)
    a[c] = s[c];
  return a;
}, p1 = function(a, s, c) {
  var d = kp({}, c._gsap), u = "perspective,force3D,transformOrigin,svgOrigin", m = c.style, g, _, S, C, O, k, D, F;
  d.svg ? (S = c.getAttribute("transform"), c.setAttribute("transform", ""), m[_n] = s, g = iu(c, 1), Cl(c, _n), c.setAttribute("transform", S)) : (S = getComputedStyle(c)[_n], m[_n] = s, g = iu(c, 1), m[_n] = S);
  for (_ in Xs)
    S = d[_], C = g[_], S !== C && u.indexOf(_) < 0 && (D = cr(S), F = cr(C), O = D !== F ? Da(c, _, S, F) : parseFloat(S), k = parseFloat(C), a._pt = new Nr(a._pt, g, _, O, k - O, Kc), a._pt.u = F || 0, a._props.push(_));
  kp(g, d);
};
Br("padding,margin,Width,Radius", function(x, a) {
  var s = "Top", c = "Right", d = "Bottom", u = "Left", m = (a < 3 ? [s, c, d, u] : [s + u, s + c, d + c, d + u]).map(function(g) {
    return a < 2 ? x + g : "border" + g + x;
  });
  qu[a > 1 ? "border" + x : x] = function(g, _, S, C, O) {
    var k, D;
    if (arguments.length < 4)
      return k = m.map(function(F) {
        return Ws(g, F, S);
      }), D = k.join(" "), D.split(k[0]).length === 5 ? k[0] : D;
    k = (C + "").split(" "), D = {}, m.forEach(function(F, E) {
      return D[F] = k[E] = k[E] || k[(E - 1) / 2 | 0];
    }), g.init(_, D, O);
  };
});
var Gd = {
  name: "css",
  register: tf,
  targetTest: function(a) {
    return a.style && a.nodeType;
  },
  init: function(a, s, c, d, u) {
    var m = this._props, g = a.style, _ = c.vars.startAt, S, C, O, k, D, F, E, L, T, M, R, b, U, N, j, J;
    wf || tf(), this.styles = this.styles || Dd(a), J = this.styles.props, this.tween = c;
    for (E in s)
      if (E !== "autoRound" && (C = s[E], !($r[E] && Md(E, s, c, d, a, u)))) {
        if (D = typeof C, F = qu[E], D === "function" && (C = C.call(c, d, a, u), D = typeof C), D === "string" && ~C.indexOf("random(") && (C = Kh(C)), F)
          F(this, a, E, C, c) && (j = 1);
        else if (E.substr(0, 2) === "--")
          S = (getComputedStyle(a).getPropertyValue(E) + "").trim(), C += "", Oa.lastIndex = 0, Oa.test(S) || (L = cr(S), T = cr(C)), T ? L !== T && (S = Da(a, E, S, T) + T) : L && (C += L), this.add(g, "setProperty", S, C, d, u, 0, 0, E), m.push(E), J.push(E, 0, g[E]);
        else if (D !== "undefined") {
          if (_ && E in _ ? (S = typeof _[E] == "function" ? _[E].call(c, d, a, u) : _[E], Yn(S) && ~S.indexOf("random(") && (S = Kh(S)), cr(S + "") || S === "auto" || (S += to.units[E] || cr(Ws(a, E)) || ""), (S + "").charAt(1) === "=" && (S = Ws(a, E))) : S = Ws(a, E), k = parseFloat(S), M = D === "string" && C.charAt(1) === "=" && C.substr(0, 2), M && (C = C.substr(2)), O = parseFloat(C), E in as && (E === "autoAlpha" && (k === 1 && Ws(a, "visibility") === "hidden" && O && (k = 0), J.push("visibility", 0, g.visibility), La(this, g, "visibility", k ? "inherit" : "hidden", O ? "inherit" : "hidden", !O)), E !== "scale" && E !== "transform" && (E = as[E], ~E.indexOf(",") && (E = E.split(",")[0]))), R = E in Xs, R) {
            if (this.styles.save(E), b || (U = a._gsap, U.renderTransform && !s.parseTransform || iu(a, s.parseTransform), N = s.smoothOrigin !== !1 && U.smooth, b = this._pt = new Nr(this._pt, g, _n, 0, 1, U.renderTransform, U, 0, -1), b.dep = 1), E === "scale")
              this._pt = new Nr(this._pt, U, "scaleY", U.scaleY, (M ? ah(U.scaleY, M + O) : O) - U.scaleY || 0, Kc), this._pt.u = 0, m.push("scaleY", E), E += "X";
            else if (E === "transformOrigin") {
              J.push(Fr, 0, g[Fr]), C = l1(C), U.svg ? ef(a, C, 0, N, 0, this) : (T = parseFloat(C.split(" ")[2]) || 0, T !== U.zOrigin && La(this, U, "zOrigin", U.zOrigin, T), La(this, g, E, Yu(S), Yu(C)));
              continue;
            } else if (E === "svgOrigin") {
              ef(a, C, 1, N, 0, this);
              continue;
            } else if (E in Nd) {
              f1(this, U, E, k, M ? ah(k, M + C) : C);
              continue;
            } else if (E === "smoothOrigin") {
              La(this, U, "smooth", U.smooth, C);
              continue;
            } else if (E === "force3D") {
              U[E] = C;
              continue;
            } else if (E === "transform") {
              p1(this, C, a);
              continue;
            }
          } else
            E in g || (E = dh(E) || E);
          if (R || (O || O === 0) && (k || k === 0) && !Y_.test(C) && E in g)
            L = (S + "").substr((k + "").length), O || (O = 0), T = cr(C) || (E in to.units ? to.units[E] : L), L !== T && (k = Da(a, E, S, T)), this._pt = new Nr(this._pt, R ? U : g, E, k, (M ? ah(k, M + O) : O) - k, !R && (T === "px" || E === "zIndex") && s.autoRound !== !1 ? $_ : Kc), this._pt.u = T || 0, L !== T && T !== "%" && (this._pt.b = S, this._pt.r = J_);
          else if (E in g)
            a1.call(this, a, E, S, M ? M + C : C);
          else if (E in a)
            this.add(a, E, S || a[E], M ? M + C : C, d, u);
          else if (E !== "parseTransform") {
            ff(E, C);
            continue;
          }
          R || (E in g ? J.push(E, 0, g[E]) : J.push(E, 1, S || a[E])), m.push(E);
        }
      }
    j && Pd(this);
  },
  render: function(a, s) {
    if (s.tween._time || !Tf())
      for (var c = s._pt; c; )
        c.r(a, c.d), c = c._next;
    else
      s.styles.revert();
  },
  get: Ws,
  aliases: as,
  getSetter: function(a, s, c) {
    var d = as[s];
    return d && d.indexOf(",") < 0 && (s = d), s in Xs && s !== Fr && (a._gsap.x || Ws(a, "x")) ? c && Pp === c ? s === "scale" ? e1 : t1 : (Pp = c || {}) && (s === "scale" ? i1 : n1) : a.style && !hf(a.style[s]) ? K_ : ~s.indexOf("-") ? Q_ : _f(a, s);
  },
  core: {
    _removeProperty: Cl,
    _getMatrix: Sf
  }
};
Ur.utils.checkPrefix = dh;
Ur.core.getStyleSaver = Dd;
(function(x, a, s, c) {
  var d = Br(x + "," + a + "," + s, function(u) {
    Xs[u] = 1;
  });
  Br(a, function(u) {
    to.units[u] = "deg", Nd[u] = 1;
  }), as[d[13]] = x + "," + a, Br(c, function(u) {
    var m = u.split(":");
    as[m[1]] = d[m[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Br("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(x) {
  to.units[x] = "px";
});
Ur.registerPlugin(Gd);
var nf = Ur.registerPlugin(Gd) || Ur;
nf.core.Tween;
class S1 {
  constructor(a, s = !1) {
    window.mars3d ? (this.Cesium = window.mars3d.Cesium, this.DynamicMaskingArr = [], this.DynamicMaskingStyle = [], this.canvasClientWidth = a.viewer.canvas.clientWidth, this.canvasClientHeight = a.viewer.canvas.clientHeight, this.oldSet = /* @__PURE__ */ new Set(), this.tweenMap = /* @__PURE__ */ new Map(), this.isDynamicMasking = s) : console.error("未引入指定插件");
  }
  /**
   * 添加动态遮蔽数据
   * item 是地图对象
   * data 是数据 (地图对象隐藏的时候有些数据有问题 辅助作用)
   */
  add(a, s) {
    let c = a.options.symbol.styleOptions.label.font_size, d = a.options.vectorId, u = Number(c) * 1.4, m = Number(c) * 1.8, g = a.options.symbol.styleOptions.label, { color: _, outlineColor: S, backgroundColor: C } = g;
    a.eachGraphic((O) => {
      O.style.label && this.DynamicMaskingArr.push({
        id: d,
        uid: O.id,
        position: O._getLablePosition(),
        label: O.name,
        width: u * O.name.length,
        height: m,
        color: _,
        outline: s.label.outline,
        outlineColor: S,
        background: s.label.background,
        backgroundColor: C,
        dynamicMaskingColor: {
          backgroundColor: this.Cesium.Color.fromCssColorString(
            s.label.backgroundColor
          ),
          color: this.Cesium.Color.fromCssColorString(s.label.color),
          outlineColor: this.Cesium.Color.fromCssColorString(
            s.label.outlineColor
          )
        }
      });
    }), this.DynamicMaskingStyle.push({
      vectorId: a.options.vectorId,
      outline: s.label.outline,
      background: s.label.background,
      color: this.Cesium.Color.fromCssColorString(s.label.color),
      backgroundColor: this.Cesium.Color.fromCssColorString(
        s.label.backgroundColor
      ),
      outlineColor: this.Cesium.Color.fromCssColorString(
        s.label.outlineColor
      )
    }), this.oldSet = /* @__PURE__ */ new Set(), this.tweenMap = /* @__PURE__ */ new Map();
  }
  /**
   * 移除动态遮蔽数据
   */
  remove(a) {
    this.DynamicMaskingArr = this.DynamicMaskingArr.filter(
      (s) => s.id !== a
    ), this.DynamicMaskingStyle = this.DynamicMaskingStyle.filter(
      (s) => s.vectorId !== a
    ), this.oldSet = /* @__PURE__ */ new Set(), this.tweenMap = /* @__PURE__ */ new Map();
  }
  /**
   * 修改数据
   * 主要就是修改
   * outline
   * background
   * color
   * outlineColor
   * backgroundColor
   * 用于渐变
   */
  modify(a, s) {
    let { label: c } = s;
    if (c) {
      let { color: d, outline: u, outlineColor: m, background: g, backgroundColor: _ } = c;
      this.DynamicMaskingArr.forEach((S) => {
        S.id === a && (d != null && (S.color = this.Cesium.Color.fromCssColorString(d), S.dynamicMaskingColor.color = this.Cesium.Color.fromCssColorString(d)), u != null && (S.outline = u), m != null && (S.outlineColor = this.Cesium.Color.fromCssColorString(m), S.dynamicMaskingColor.outlineColor = this.Cesium.Color.fromCssColorString(m)), g != null && (S.background = g), _ != null && (S.backgroundColor = this.Cesium.Color.fromCssColorString(_), S.dynamicMaskingColor.backgroundColor = this.Cesium.Color.fromCssColorString(_)));
      });
    }
  }
  /**
   * 获取边界值 生成包围盒
   */
  getBoundingRectangle(a) {
    var s = this.Cesium.SceneTransforms.wgs84ToWindowCoordinates(
      window.map.viewer.scene,
      a.position
    );
    return s !== void 0 ? new this.Cesium.BoundingRectangle(
      s.x,
      s.y,
      a.width,
      a.height
    ) : new this.Cesium.BoundingRectangle(0, 0, 1, 1);
  }
  getNonIntersectingRectangles() {
    let a = [];
    for (var s = 0; s < this.DynamicMaskingArr.length; s++) {
      let d = !1, u = this.DynamicMaskingArr[s], m, g, _;
      if (g = this.getBoundingRectangle(u), !(g.x < 0 || g.x > this.canvasClientWidth || g.y < 0 || g.y > this.canvasClientHeight))
        if (a.length === 0) {
          a.push(s);
          continue;
        } else {
          for (var c = 0; c < a.length; c++)
            if (m = this.DynamicMaskingArr[a[c]], _ = this.getBoundingRectangle(m), this.Cesium.Intersect.OUTSIDE !== this.Cesium.BoundingRectangle.intersect(g, _)) {
              d = !0;
              break;
            }
          d || a.push(s);
        }
    }
    return new Set(a);
  }
  /**
   * 动态遮蔽主要逻辑
   */
  ifShow() {
    if (this.isDynamicMasking) {
      let s = {
        color: 1e-3,
        outlineColor: 1e-3,
        backgroundColor: 1e-3
      }, c = {
        color: 1,
        outlineColor: 1,
        backgroundColor: 1
      }, d = this.getNonIntersectingRectangles(), u = new Set([...this.oldSet].filter((g) => !d.has(g))), m = new Set([...d].filter((g) => !this.oldSet.has(g)));
      for (let g of u)
        if (this.DynamicMaskingArr[g]) {
          if (this.tweenMap.has(g)) {
            var a = this.tweenMap.get(g);
            a.kill(), this.tweenMap.delete(g);
          }
          var a = nf.to(c, {
            duration: 0.2,
            color: 0,
            outlineColor: 0,
            backgroundColor: 0,
            onUpdate: () => {
              var S, C;
              var _ = this.DynamicMaskingArr[g];
              _.backgroundColor.alpha = c.backgroundColor, _.color.alpha = c.color, _.outlineColor.alpha = c.outlineColor, (C = (S = window.map.getLayer(_.id, "vectorId")) == null ? void 0 : S.getGraphicByAttr(_.uid)) == null || C.setStyle({
                label: {
                  show: !1,
                  outline: !1,
                  background: !1
                }
              });
            }
          });
          this.tweenMap.set(g, a);
        }
      for (let g of m)
        if (this.DynamicMaskingArr[g]) {
          if (this.tweenMap.has(g)) {
            var a = this.tweenMap.get(g);
            a.kill(), this.tweenMap.delete(g);
          }
          let _ = this.DynamicMaskingArr[g], { backgroundColor: S, color: C, outlineColor: O } = _.dynamicMaskingColor;
          var a = nf.to(s, {
            duration: 0.8 + Math.random(),
            color: C.alpha,
            outlineColor: O.alpha,
            backgroundColor: S.alpha,
            onUpdate: () => {
              var D, F;
              _.backgroundColor.alpha = s.backgroundColor, _.color.alpha = s.color, _.outlineColor.alpha = s.outlineColor, (F = (D = window.map.getLayer(_.id, "vectorId")) == null ? void 0 : D.getGraphicByAttr(_.uid)) == null || F.setStyle({
                label: {
                  show: !0,
                  outline: _.outline,
                  background: _.background,
                  color: _.color,
                  outlineColor: _.outlineColor,
                  backgroundColor: _.backgroundColor
                }
              });
            }
          });
          this.tweenMap.set(g, a);
        }
      this.oldSet = d;
    }
  }
  /**
   * 切换动态避让
   * @returns { any }
   */
  switchDynamicMasking(a) {
    if (a)
      window.map.getLayers().forEach((s) => {
        var c;
        if ((c = s.options) != null && c.vectorId) {
          let { color: d, outlineColor: u, backgroundColor: m } = s.options.symbol.styleOptions.label;
          s.eachGraphic((g) => {
            g.setStyle({
              label: {
                color: d.withAlpha(0),
                outlineColor: u.withAlpha(1e-3),
                backgroundColor: m.withAlpha(1e-3),
                show: !1,
                background: !1,
                outline: !1
              }
            });
          });
        }
      });
    else if (this.DynamicMaskingStyle.length > 0) {
      let s;
      this.DynamicMaskingStyle.forEach((c) => {
        let {
          color: d,
          outline: u,
          outlineColor: m,
          background: g,
          backgroundColor: _,
          vectorId: S
        } = c;
        s = window.map.getLayer(S, "vectorId"), s && s.eachGraphic((C) => {
          C.setStyle({
            label: {
              color: d,
              outlineColor: m,
              backgroundColor: _,
              show: !0,
              background: g,
              outline: u
            }
          });
        });
      });
    }
    this.isDynamicMasking = a, window.bimVector.switchDynamicMasking(a);
  }
}
const E1 = () => {
  window.planClip.clearPlanClip(), window.schemeEvnModify.clearAllEvnModify(), window.bimRotatePoint.stop(), window.bimTrafficSimulation.destruction(), window.bimMapPTV && window.bimMapPTV.destruction(), window.romStop(), window.complete(), window.bimMapCompare.hide ? window.bimMapCompare.hide() : window.bimMapCompare.destroyControl(), window.updateEitor({
    eitorinfo: "",
    eitorflag: !1
  });
}, b1 = () => {
  window.planClip.clearPlanClip(), window.bimRotatePoint.stop(), window.bimTrafficSimulation.destruction(), window.bimMapPTV && window.bimMapPTV.destruction(), window.romStop(), window.complete(), window.bimMapCompare.hide ? window.bimMapCompare.hide() : window.bimMapCompare.destroyControl();
}, C1 = (x = 1) => {
  window.planClip.clearPlanClip(), window.bimRotatePoint.stop(), window.bimTrafficSimulation.destruction(), window.bimMapPTV && window.bimMapPTV.destruction(), window.romStop(), window.complete(), window.bimMapCompare.hide ? window.bimMapCompare.hide() : window.bimMapCompare.destroyControl();
}, A1 = (x) => {
  let a = [];
  if (x.forEach((s) => {
    let { id: c } = s, d = {
      id: c,
      mockData: {
        nextPage: [],
        item: [],
        previousPage: []
      }
    };
    s.operate.forEach((u, m) => {
      let g = rf(u, d.mockData.nextPage);
      d.mockData.nextPage = g, d.mockData.item = g, d.mockData.previousPage = [];
    }), a.push(d);
  }), a.length > 1)
    for (let s = 1; s < a.length; s++) {
      let c = a[s].mockData, d = a[s - 1].mockData.item;
      const u = /* @__PURE__ */ new Map();
      d.forEach((m) => {
        m.type != "rotatePoint" && m.type != "viewpoint" && m.type != "roaming" && m.type != "splitScreen" && m.type != "planClip" ? u.set(`${m.screenplayId}-${m.type}`, m) : a[s].mockData.previousPage.push(m);
      }), c.nextPage.forEach((m) => {
        const g = `${m.screenplayId}-${m.type}`;
        let _ = {
          ...u.get(g)
        };
        if (u.has(g)) {
          if (m.type == "flight")
            a[s].mockData.previousPage.unshift(
              u.get(g)
            ), _ = m;
          else {
            let S = {};
            Object.keys(m).forEach((C) => {
              if (C != "screenplayId" && C != "type")
                if (u.get(g)[C])
                  if (Object.keys(S).length == 0 && (S = {
                    screenplayId: m.screenplayId,
                    type: m.type
                  }), C == "clip" || C == "flat") {
                    _[C] = Hd(u.get(g)[C], m[C]);
                    let O = {
                      screenplayId: m.screenplayId,
                      type: m.type
                    };
                    O[C] = {}, Object.keys(m[C]).forEach((k) => {
                      u.get(g)[C][k] ? O[C][k] = u.get(g)[C][k] : m[C][k] == "true" && (O[C][k] = "false");
                    }), S = {
                      ...O,
                      ...S
                    };
                  } else
                    S[C] = u.get(g)[C], _[C] = m[C];
                else
                  a[s].mockData.previousPage.some(
                    (O) => O.screenplayId === m.screenplayId
                  ) || (S = { ...Bp(m, C), ...S }), _[C] = m[C];
            }), Object.keys(S).length > 0 && a[s].mockData.previousPage.push(
              S
            );
          }
          u.set(g, _);
        } else {
          let S = Bp(m);
          S && a[s].mockData.previousPage.push(S), u.set(g, m);
        }
      }), a[s].mockData.item = Array.from(u.values());
    }
  return console.log("-----------最后输出-----------"), console.log(a), console.log("-----------最后输出-----------"), a;
}, rf = (x, a = null) => {
  let { executionProperty: s, screenplayId: c, property: d, type: u, delay: m, delayTime: g } = x;
  if ((d == "add" || d == !0) && (d = "true"), (d == "remove" || d == !1) && (d = "false"), u == "pit") {
    let S = window.schemeEvnModify.getModelModifyDataForInitModelById(c);
    if (S) {
      let C = {};
      C[c] = d, d = C, c = S.modelId, s = S.type;
    }
  }
  let _;
  if (c == "" || c == "map")
    if (c = "map", u == "splitScreen") {
      let { splitScreenMode: S, splitScreenModePercentage: C } = JSON.parse(d);
      a.push({
        screenplayId: c,
        type: u,
        executionProperty: {
          splitScreenMode: S,
          splitScreenModePercentage: C,
          mapClone: []
        }
      });
      let { mainScreen: O, secondaryScreen: k } = JSON.parse(x.property);
      O.forEach((F) => {
        rf(F, a);
      });
      let D = a.find((F) => F.type == "splitScreen");
      k.forEach((F) => {
        rf(F, D.executionProperty.mapClone);
      });
    } else
      _ = {
        screenplayId: c,
        type: u,
        executionProperty: d
      }, (s == "clip" || s == "flat") && (_[s] = d), m && (_.delay = m), g && (_.delayTime = g), a && (u == "flight" ? a.unshift(_) : a.push(_));
  else
    _ = a ? a.find((S) => S.screenplayId == c) : null, _ ? (s == "clip" || s == "flat" ? _[s] ? _[s] = Hd(
      _[s],
      d
    ) : (_[s] = d, _.type = "model") : _[s] = d, m && (_[s].delay = m), g && (_[s].delayTime = g)) : (_ = {
      screenplayId: c,
      type: u
    }, m && (_.delay = m), g && (_.delayTime = g), s == "clip" || s == "flat" ? (_[s] = d, _.type = "model") : _[s] = d, a && (u == "flight" ? a.unshift(_) : a.push(_)));
  return a || _;
}, Hd = (x, a) => {
  const s = { ...x };
  for (const c in a)
    a.hasOwnProperty(c) && (s[c] = a[c]);
  return s;
}, Bp = (x, a = "all") => {
  let { type: s, show: c, screenplayId: d, overallStaining: u, clip: m, flat: g } = x, _ = {};
  if (a == "all")
    switch (s) {
      case "model":
      case "shp":
      case "plot":
        c && c == "true" && (_ = {
          screenplayId: d,
          type: s,
          show: "false"
        }), c && c == "false" && console.error("map上没有添加此对象"), u && (_ = {
          ..._,
          screenplayId: d,
          type: s,
          overallStaining: "false"
        }), m && (_ = {
          ..._,
          screenplayId: d,
          type: s,
          clip: "false"
        }), g && (_ = {
          ..._,
          screenplayId: d,
          type: s,
          flat: "false"
        });
        break;
      case "terrain":
        _ = {
          screenplayId: d,
          type: s,
          executionProperty: "true"
        };
        break;
      case "pit":
        _ = {
          screenplayId: d,
          type: s,
          executionProperty: "false"
        };
        break;
      case "underground":
        _ = {
          screenplayId: d,
          type: s,
          executionProperty: "1"
        };
        break;
      case "editor":
        _ = {
          screenplayId: d,
          type: s,
          executionProperty: JSON.stringify({
            content: "",
            isshow: !1
          })
        };
        break;
      case "editor":
        window.updateEitor({
          eitorinfo: "",
          eitorflag: !1
        });
        break;
    }
  else
    switch (console.log("初始化", a), a) {
      case "clip":
      case "flat":
      case "overallStaining":
        _ = {
          screenplayId: d,
          type: s
        }, _[a] = "false";
        break;
    }
  return Object.keys(_).length > 0 ? _ : null;
}, P1 = (x, a) => {
  const s = {};
  return Object.keys(a).forEach((c) => {
    x.hasOwnProperty(c) && (s[c] = x[c]);
  }), s;
}, L1 = (x) => /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*(0|1|0\.\d+)\s*\)$/i.test(x), R1 = (x) => {
  let a = {};
  (x == null ? void 0 : x.length) > 0 && x[0].operate.forEach((s) => {
    let { executionProperty: c, screenplayId: d, property: u, type: m } = s;
    (c == "show" || c == "overallStaining") && (a[d] || (a[d] = {
      type: m
    }), a[d][u] = c);
  }), window.map.getLayers().forEach((s) => {
    if ((s.type == "3dtiles" || s.type == "geojson") && s.options.name != "国界") {
      let c = s.options.modelId || s.options.vectorId;
      a[c] ? window.bimModel.editColor(c) : s.remove();
    }
  }), window.bimEntity.entityLayer.getGraphicsByAttr().forEach((s) => {
    s.remove();
  }), window.bimMapSetUp.undergroundVal(1), window.bimTerrainProvider.show(), window.bimTrafficSimulation.destruction(), window.bimRotatePoint.stop(), window.bimMapPTV.destruction(), window.romStop(), window.complete(), window.planClip.clearPlanClip();
};
class O1 {
  constructor(a) {
    /**
     * 对地形添加裁剪区域
     * @param {Array} positions 裁剪区域的坐标点数组
     * @param {String} id 裁剪区域的id
     */
    vl(this, "terrainCutById", (a, s, c) => {
      switch (c == null ? void 0 : c.isClone) {
        case !0:
          if (this.createTerrainModifyInstanceClone(), !this.terrainClipClone || this.terrainClipClone.list.find((d) => d.id == s))
            return;
          this.terrainClipClone.addArea(
            a.length > 1 ? a : a[0],
            { id: s }
          );
          break;
        case !1:
          if (!this.terrainClip || this.terrainClip.list.find((d) => d.id == s))
            return;
          this.terrainClip.addArea(
            a.length > 1 ? a : a[0],
            { id: s }
          );
          break;
      }
    });
    /**
     * 清除地形的裁剪区域
     * @param {String} id 裁剪区域的id
     */
    vl(this, "clearTerrainCutById", (a, s) => {
      switch (s == null ? void 0 : s.isClone) {
        case !0:
          if (this.createTerrainModifyInstanceClone(), !this.terrainClipClone)
            return;
          this.terrainClipClone.removeArea(a);
          break;
        case !1:
          if (!this.terrainClip)
            return;
          this.terrainClip.removeArea(a);
          break;
      }
    });
    /**
     * 对地形添加压平区域
     * @param {Array} positions 压平区域的坐标点数组
     * @param {Number} diffHeight 压平区域深度
     * @param {String} id 压平区域的id
     */
    vl(this, "terrainFlattenById", (a, s, c, d) => {
      switch (d == null ? void 0 : d.isClone) {
        case !0:
          if (this.createTerrainModifyInstanceClone(), !this.terrainFlatClone || this.terrainFlatClone.list.find((u) => u.id == c))
            return;
          this.terrainFlatClone.addArea(
            a.length > 1 ? a : a[0],
            { id: c, height: s }
          );
          break;
        case !1:
          if (!this.terrainFlat || this.terrainFlat.list.find((u) => u.id == c))
            return;
          this.terrainFlat.addArea(
            a.length > 1 ? a : a[0],
            { id: c, height: s }
          );
          break;
      }
    });
    /**
     * 清除地形的压平区域
     */
    vl(this, "clearTerrainFlattenById", (a, s) => {
      switch (s == null ? void 0 : s.isClone) {
        case !0:
          if (this.createTerrainModifyInstanceClone(), !this.terrainFlatClone)
            return;
          this.terrainFlatClone.removeArea(a);
          break;
        case !1:
          if (!this.terrainFlat)
            return;
          this.terrainFlat.removeArea(a);
          break;
      }
    });
    this.flattenedEvnModifyData = a, this.modelIdListByModify = [], this.modelIdListByModifyClone = [], this.terrainClip = null, this.terrainFlat = null, this.terrainClipClone = null, this.terrainFlatClone = null, this.createTerrainModifyInstance();
  }
  // ------------------------------------------数据预处理------------------------------------------
  /**
   * 通过id从扁平化的环境修改树数据中获取数据
   * @param {String} id 环境修改树数据的id
   * @return {Object} 环境修改树数据
   */
  getDataFromFlattenedEvnModifyListById(a) {
    const s = this.flattenedEvnModifyData.find((c) => c.id == a);
    return s ? (s.id = s.id.toString(), s) : null;
  }
  /**
   * 通过modelId从map对象中获取对应模型
   * @param {String} modelId 模型id
   * @return {Object} 模型对象没有返回undifine
   */
  getModelFromMapById(a, s) {
    let c;
    switch (s == null ? void 0 : s.isClone) {
      case !0:
        c = window.mapClone ? window.mapClone.mapEx.getLayers() : [];
        break;
      case !1:
        c = window.map.getLayers();
        break;
    }
    return c.find(
      (u) => u.options.modelId == a
    );
  }
  /**
   * 更新flattenedEvnModifyData
   * @param {Array} flattenData 环境修改树数据
   */
  updateFlattenedEvnModifyData(a) {
    this.flattenedEvnModifyData = a;
  }
  // ------------------------------------------模型修改相关方法------------------------------------------
  /**
   * 对指定模型添加裁剪区域
   * @param {String} modelId 模型id
   * @param {Array} positions 裁剪区域的坐标点数组(笛卡尔坐标对象组成的数组)
   * @param {String} id 裁剪区域的id即
   */
  modelCutById(a, s, c, d) {
    const u = this.getModelFromMapById(a, d);
    if (u && !u.clip.list.find((m) => m.id == c))
      switch (u.clip.addArea(s.length > 1 ? s : s[0], {
        id: c
      }), d == null ? void 0 : d.isClone) {
        case !0:
          this.modelIdListByModifyClone.push(a), this.modelIdListByModifyClone = [
            ...new Set(this.modelIdListByModifyClone)
          ];
          break;
        case !1:
          this.modelIdListByModify.push(a), this.modelIdListByModify = [...new Set(this.modelIdListByModify)];
          break;
      }
  }
  /**
   * 对指定模型添加压平区域
   * @param {String} modelId 模型id
   * @param {Array} positions 压平区域的坐标点数组
   * @param {Number} height 压平高度
   * @param {String} id 压平区域的id
   */
  modelFlattenById(a, s, c, d, u) {
    const m = this.getModelFromMapById(a, u);
    if (m && !m.flat.list.find((g) => g.id == d))
      switch (m.flat.addArea(s.length > 1 ? s : s[0], {
        height: c,
        id: d
      }), u == null ? void 0 : u.isClone) {
        case !0:
          this.modelIdListByModifyClone.push(a), this.modelIdListByModifyClone = [
            ...new Set(this.modelIdListByModifyClone)
          ];
          break;
        case !1:
          this.modelIdListByModify.push(a), this.modelIdListByModify = [...new Set(this.modelIdListByModify)];
          break;
      }
  }
  /**
   * 清除指定模型的裁剪区域
   * @param {String} modelId 模型id
   * @param {String} id 裁剪区域的id
   */
  clearModelCutById(a, s, c) {
    const d = this.getModelFromMapById(a, c);
    if (d)
      switch (d.clip.removeArea(s), c.isClone) {
        case !0:
          this.modelIdListByModifyClone = this.modelIdListByModifyClone.filter(
            (u) => u != a
          );
          break;
        case !1:
          this.modelIdListByModify = this.modelIdListByModify.filter(
            (u) => u != a
          );
          break;
      }
  }
  /**
   * 清除指定模型的压平区域
   * @param {String} modelId 模型id
   * @param {String} id 压平区域的id
   */
  clearModelFlattenById(a, s, c) {
    const d = this.getModelFromMapById(a, c);
    if (d)
      switch (d.flat.removeArea(s), c == null ? void 0 : c.isClone) {
        case !0:
          this.modelIdListByModifyClone = this.modelIdListByModifyClone.filter(
            (u) => u != a
          );
          break;
        case !1:
          this.modelIdListByModify = this.modelIdListByModify.filter(
            (u) => u != a
          );
          break;
      }
  }
  // ------------------------------------------地形修改相关方法------------------------------------------
  /**
   * 创建地形修改实例(地形修改不像模型修改，模型修改拿到模型对象后直接调用模型对象的clip和flat方法即可。地形修改需要创
   * 建实例，通过该实例来进行地形裁剪和压平操作)
   */
  createTerrainModifyInstance() {
    if (window.map.thing.terrainClip)
      this.terrainClip = window.map.thing.terrainClip;
    else {
      const a = new mars3d.thing.TerrainClip({
        czm: !1,
        splitNum: 30
        // 井边界插值数
      });
      window.map.addThing(a), this.terrainClip = a;
    }
    if (window.map.thing.terrainFlat)
      this.terrainFlat = window.map.thing.terrainFlat;
    else {
      const a = new mars3d.thing.TerrainFlat({
        splitNum: 80
        // 井边界插值数
      });
      window.map.addThing(a), this.terrainFlat = a;
    }
  }
  /**
   * 创建副地图地形修改实例
   */
  createTerrainModifyInstanceClone() {
    if (window.mapClone) {
      if (window.mapClone.mapEx.thing.terrainClip)
        this.terrainClipClone = window.mapClone.mapEx.thing.terrainClip;
      else {
        const a = new mars3d.thing.TerrainClip({
          splitNum: 80
          // 井边界插值数
        });
        window.mapClone.mapEx.addThing(a), this.terrainClipClone = a;
      }
      if (window.mapClone.mapEx.thing.terrainFlat)
        this.terrainFlatClone = window.mapClone.mapEx.thing.terrainFlat;
      else {
        const a = new mars3d.thing.TerrainFlat({
          splitNum: 80
          // 井边界插值数
        });
        window.mapClone.mapEx.addThing(a), this.terrainFlatClone = a;
      }
    }
  }
  // ------------------------------------------利用以上工具函数实现通过id来进行环境修改功能------------------------------------------
  /**
   * 传入id来进行环境修改
   * @param {String} id 环境修改树数据的id
   * @param {Object} params 额外参数，目前只有isClone，用来标识是否是副地图的环境修改
   */
  evnModifyById(a, s) {
    s = arguments[1] || { isClone: !1 };
    const c = this.getDataFromFlattenedEvnModifyListById(a);
    if (!c)
      return;
    const {
      bimEnvModify: { embsId: d, dataType: u, modifyType: m }
    } = c;
    for (let g = 0; g < c.bimEnvModifyData.length; g++) {
      const _ = JSON.parse(
        c.bimEnvModifyData[g].modifyData
      ).coordinates, S = _[0].length > 1 ? _[0] : _[0][0], C = JSON.parse(c.bimEnvModifyData[g].modifyData).depth, O = c.bimEnvModifyData[g].id.toString();
      u === 0 && m === 0 ? this.modelCutById(d, S, O, s) : u === 0 && m === 1 ? this.modelFlattenById(d, S, C, O, s) : u === 1 && m === 0 ? this.terrainCutById(S, O, s) : u === 1 && m === 1 && this.terrainFlattenById(S, C, O, s);
    }
  }
  /**
   * 传入id来进行环境修改并且向map store中传入针对倾斜摄影模型的环境修改配置项，以便在模型重载的时候能够还原环境修改
   * @param {String} id 环境修改树数据的id
   * @param {Object} params 额外参数，目前只有isClone，用来标识是否是副地图的环境修改
   */
  evnModifyByIdAndAddOptionsToStore(a, s) {
    s = arguments[1] || { isClone: !1 };
    const c = this.getDataFromFlattenedEvnModifyListById(a);
    if (!c)
      return;
    const {
      bimEnvModify: { embsId: d, dataType: u, modifyType: m }
    } = c;
    for (let g = 0; g < c.bimEnvModifyData.length; g++) {
      const _ = JSON.parse(
        c.bimEnvModifyData[g].modifyData
      ).coordinates, S = _[0].length > 1 ? _[0] : _[0][0], C = JSON.parse(c.bimEnvModifyData[g].modifyData).depth, O = c.bimEnvModifyData[g].id.toString();
      u === 0 && m === 0 ? this.modelCutById(d, S, O, s) : u === 0 && m === 1 ? this.modelFlattenById(d, S, C, O, s) : u === 1 && m === 0 ? this.terrainCutById(S, O, s) : u === 1 && m === 1 && this.terrainFlattenById(S, C, O, s);
    }
  }
  /**
   * 传入id来清除环境修改
   * @param {String} id 环境修改树数据的id
   * @param {Object} params 额外参数，目前只有isClone，用来标识是否是副地图的环境修改
   */
  clearEvnModifyById(a, s) {
    s = arguments[1] || { isClone: !1 };
    const c = this.getDataFromFlattenedEvnModifyListById(a);
    if (!c)
      return;
    const {
      bimEnvModify: { embsId: d, dataType: u, modifyType: m }
    } = c;
    for (let g = 0; g < c.bimEnvModifyData.length; g++) {
      const _ = c.bimEnvModifyData[g].id.toString();
      u === 0 && m === 0 ? this.clearModelCutById(d, _, s) : u === 0 && m === 1 ? this.clearModelFlattenById(d, _, s) : u === 1 && m === 0 ? this.clearTerrainCutById(_, s) : u === 1 && m === 1 && this.clearTerrainFlattenById(_, s);
    }
  }
  /**
   * 根据params参数来清除指定地图上所有模型的裁剪和压平区域
   * @param {Array} modelIdListByModify 要清除裁剪和压平区域的模型id数组(一般不传即可)
   */
  clearAllModelModify(a) {
    switch (a || (a = { isClone: !1 }), a.isClone) {
      case !0:
        this.modelIdListByModifyClone.forEach((s) => {
          const c = this.getModelFromMapById(s, a);
          c && (c.clip.clear(), c.flat.clear());
        }), this.modelIdListByModifyClone = [];
        break;
      case !1:
        this.modelIdListByModify.forEach((s) => {
          const c = this.getModelFromMapById(s, a);
          c && (c.clip.clear(), c.flat.clear());
        }), this.modelIdListByModify = [];
        break;
    }
  }
  /**
   * 根据params参数来清除指定地形修改区域
   */
  clearAllTerrainModify(a) {
    switch (a || (a = { isClone: !1 }), a.isClone) {
      case !0:
        this.terrainClip && this.terrainClip.clear(), this.terrainFlat && this.terrainFlat.clear();
        break;
      case !1:
        window.mapClone || (this.terrainClipClone = null, this.terrainFlatClone = null), this.terrainClipClone && this.terrainClipClone.clear(), this.terrainFlatClone && this.terrainFlatClone.clear();
        break;
    }
  }
  /**
   * 传入id来获取模型修改所用到的数据，以便在模型加载的时候直接进行模型修改
   *  !!!!!!!!!!!!!!!!!!!!!
   * !!!!!!!!!!!!!!!!!!!!!
   * !!!!!!!!!!!!!!!!!!!!!
   * 从coordinates拿到的position数组，在multpolygon和polygon格式的geojson中，需要的坐标分别嵌套在第三层和第四层因此需要判断后拿到真实的数据
   * !!!!!!!!!!!!!!!!!!!!!
   * !!!!!!!!!!!!!!!!!!!!!
   * !!!!!!!!!!!!!!!!!!!!!
   * @param {String} id 环境修改树数据的id
   * @return {Array} 可以直接放到area中的数组
   */
  getModelModifyDataForInitModelById(a) {
    const s = this.getDataFromFlattenedEvnModifyListById(a);
    if (!s)
      return;
    const {
      bimEnvModify: { embsId: c, dataType: d, modifyType: u }
    } = s;
    if (d === 0 && u === 0) {
      const m = {
        modelId: c,
        type: "clip",
        area: []
      };
      for (let g = 0; g < s.bimEnvModifyData.length; g++) {
        let _ = JSON.parse(s.bimEnvModifyData[g].modifyData).coordinates[0];
        _ = _.length > 1 ? _ : _[0];
        const S = {
          positions: _,
          id: s.bimEnvModifyData[g].id.toString()
        };
        m.area.push(S);
      }
      return m;
    } else if (d === 0 && u === 1) {
      const m = {
        modelId: c,
        type: "flat",
        area: []
      };
      for (let g = 0; g < s.bimEnvModifyData.length; g++) {
        let _ = JSON.parse(s.bimEnvModifyData[g].modifyData).coordinates[0];
        _ = _.length > 1 ? _ : _[0];
        const S = {
          id: s.bimEnvModifyData[g].id.toString(),
          positions: JSON.parse(s.bimEnvModifyData[g].modifyData).coordinates[0],
          height: JSON.parse(s.bimEnvModifyData[g].modifyData).depth
        };
        return m.area.push(S), m;
      }
    }
  }
  /**
   * 清空地图上所有的环境修改
   */
  clearAllEvnModify() {
    this.clearAllModelModify({ isClone: !0 }), this.clearAllModelModify({ isClone: !1 }), this.clearAllTerrainModify({ isClone: !0 }), this.clearAllTerrainModify({ isClone: !1 });
  }
  /**
   * 销毁地形修改实例
   */
  destroyTerrainModifyInstance() {
    this.clearAllTerrainModify({ isClone: !0 }), this.clearAllTerrainModify({ isClone: !1 }), this.terrainClip && window.map.removeThing(this.terrainClip, !0), this.terrainFlat && window.map.removeThing(this.terrainFlat, !0), this.terrainClipClone && window.mapClone.mapEx.removeThing(this.terrainClipClone, !0), this.terrainFlatClone && window.mapClone.mapEx.removeThing(this.terrainFlatClone, !0), this.terrainClip = null, this.terrainFlat = null, this.terrainClipClone = null, this.terrainFlatClone = null;
  }
}
let rh = null, Hs = null, Ca = null;
class I1 {
  constructor() {
    mars3d && (this.projectId = parseInt(window.sessionStorage.getItem("nowProjectId")), this.viewPoints = new Array(), this.roaming = null);
  }
  init(a, s, c) {
    Hs = new mars3d.layer.GraphicLayer({
      isContinued: !0
      // drawEndEventType: true,
    });
    var d = this;
    window.map.addLayer(Hs), Hs.on(mars3d.EventType.drawCreated, function(u) {
      var m = u.graphic.point;
      console.log(m), s(m), setTimeout(() => {
        d.startDrawGraphic();
      }, 500);
    }), Hs.on(mars3d.EventType.editStop, function(u) {
      console.log("停止编辑", u);
    }), Ca = c, rh = new mars3d.layer.GraphicLayer(), window.map.addLayer(rh), a && (this.viewPoints = a.filter((u, m) => {
      if (m % (Ca.smooth * 1) == 0)
        return u;
    })), this.addGraphicLayer(this.viewPoints);
  }
  addDemoGraphic1(a) {
    console.log(
      a.map((c) => [c.lng, c.lat, c.alt])
    );
    const s = new mars3d.graphic.PolylinePrimitive({
      positions: a.map((c) => [c.lng, c.lat, c.alt + 1e3]),
      style: {
        width: 10,
        materialType: mars3d.MaterialType.LineFlow,
        materialOptions: {
          color: "red",
          image: "http://mars3d.cn/img/textures/line-arrow-blue.png",
          speed: 10,
          repeat: new Cesium.Cartesian2(5, 1),
          mixt: !0
        }
      }
    });
    rh.addGraphic(s);
  }
  addGraphicLayer(a) {
    var s = {};
    Ca.Viewovalue == 1 ? s = {
      camera: {
        type: "dy",
        followedX: Ca.followedX,
        followedZ: Ca.followedZ
      },
      interpolation: !0,
      interpolationDegree: 6,
      autoMiddleDynamicPosition: !0,
      interpolationAlgorithm: Cesium.HermitePolynomialApproximation
    } : Ca.Viewovalue == 2 ? s = {
      camera: {
        type: "gs",
        pitch: -30,
        radius: 500
      },
      interpolation: !0,
      interpolationDegree: 2,
      clockLoop: !0,
      path: {
        width: 3,
        color: Cesium.Color.fromCssColorString("#ff0000").withAlpha(0.5)
      }
    } : s = {
      camera: {
        type: "sd",
        followedZ: Ca.followedZ
      },
      polyline: {
        width: 3,
        color: Cesium.Color.fromCssColorString("#ff0000").withAlpha(0.5)
      }
    }, a = a.map((c) => [c.lng, c.lat, c.alt]), a.length, this.fixedRoute = new mars3d.graphic.FixedRoute({
      name: "贴地表表面漫游",
      speed: Ca.speed,
      autoStop: !0,
      positions: a,
      offsetHeight: 1.6,
      clockLoop: !0,
      // 是否循环播放
      ...s
      // polyline: {
      //   color: "#ffff00",
      //   width: 3,
      // },
    }), rh.addGraphic(this.fixedRoute);
  }
  addDemoGraphic(a, s) {
    const c = new mars3d.graphic.BillboardEntity({
      position: new mars3d.LngLatPoint(a.lng, a.lat, a.alt),
      style: {
        width: 30,
        height: 32,
        image: "/img/marker/markffd700.png",
        scale: 1,
        scaleByDistance: !1,
        scaleByDistance_far: 1e6,
        scaleByDistance_farValue: 0.1,
        scaleByDistance_near: 1e3,
        scaleByDistance_nearValue: 1,
        distanceDisplayCondition: !1,
        distanceDisplayCondition_far: 2e6,
        distanceDisplayCondition_near: 0,
        clampToGround: !1,
        visibleDepth: !1,
        drawShow: !0
        // label: {
        //   // 不需要文字时，去掉label配置即可
        //   text: name,
        //   font_size: 30,
        //   color: "#ffffff",
        //   outline: true,
        //   outlineColor: "#000000",
        //   pixelOffsetY: -50,
        // },
      }
    });
    Hs.addGraphic(c);
  }
  startDrawGraphic(a) {
    Hs.startDraw({
      type: "billboard",
      style: {
        width: 30,
        height: 32,
        image: "/img/marker/markffd700.png",
        scale: 1,
        scaleByDistance: !1,
        scaleByDistance_far: 1e6,
        scaleByDistance_farValue: 0.1,
        scaleByDistance_near: 1e3,
        scaleByDistance_nearValue: 1,
        distanceDisplayCondition: !1,
        distanceDisplayCondition_far: 2e6,
        distanceDisplayCondition_near: 0,
        clampToGround: !1,
        visibleDepth: !1,
        drawShow: !0,
        classificationType: Cesium.ClassificationType.TERRAIN
        // label: {
        //   text: name,
        //   font_size: 30,
        //   color: "#ffffff",
        //   outline: true,
        //   outlineColor: "#000000",
        //   pixelOffsetY: -50,
        // },
      }
    }).then((s) => {
      console.log(123);
    });
  }
  start() {
    console.log(this.fixedRoute), this.fixedRoute && this.fixedRoute.start();
  }
  pause() {
    this.fixedRoute && this.fixedRoute.pause();
  }
  resume() {
    this.fixedRoute && this.fixedRoute.proceed();
  }
  stop() {
    this.fixedRoute && this.fixedRoute.stop();
  }
  remove() {
    this.fixedRoute && this.fixedRoute.stop(), window.map.removeThing(this.roaming, !0), window.map.removeLayer(rh, !0), window.map.removeLayer(Hs, !0), this.viewPoints = [];
  }
  removeCameraRoute() {
    rh.clear(), Hs.clear();
  }
  removegraphicLayerpoint() {
    Hs.clear();
  }
}
const d1 = [by, Yy], D1 = {
  continuation: null,
  mapModali: null,
  install(x) {
    if (d1.forEach((m, g) => {
      x.component(m.name, m);
    }), this.continuation) {
      x.config.globalProperties.$continuation = this.continuation;
      return;
    }
    let a = xp(By), s = document.createElement("div"), c = document.body;
    if (c.appendChild(s), this.loading = a.mount(s), x.config.globalProperties.$loading = this.loading, window.$continuation = this.loading, this.mapModali) {
      x.config.globalProperties.$mapModali = this.mapModali;
      return;
    }
    let d = xp(Gy), u = document.createElement("div");
    c.appendChild(u), this.mapModali = d.mount(u), x.config.globalProperties.$mapModali = this.mapModali, window.$mapModali = this.mapModali;
  }
};
export {
  Yy as BimBackgroundPlate,
  By as BimCutscenes,
  x1 as BimElevationImage,
  T1 as BimEntity,
  v1 as BimModel,
  O1 as BimModify,
  _1 as BimTerrainProvider,
  y1 as BimVector,
  I1 as Bimroaming,
  by as Button,
  D1 as ChbimPlugins,
  S1 as DynamicMasking,
  Gy as MapModali,
  M1 as PanoramicView,
  w1 as ViewShed,
  P1 as getSameKeyData,
  E1 as init,
  R1 as initMap,
  L1 as isValidRGBA,
  C1 as nextPage,
  A1 as operateMapData,
  b1 as previousPage
};
