var d_ = Object.defineProperty;
var m_ = (w, l, o) => l in w ? d_(w, l, { enumerable: !0, configurable: !0, writable: !0, value: o }) : w[l] = o;
var bc = (w, l, o) => (m_(w, typeof l != "symbol" ? l + "" : l, o), o);
import { openBlock as ju, createElementBlock as Xu, normalizeClass as Ip, renderSlot as Dp, defineComponent as tf, ref as kc, onMounted as ef, createElementVNode as Mr, toDisplayString as g_, createApp as gp } from "vue";
const v_ = (w, l) => {
  const o = w.__vccOpts || w;
  for (const [p, d] of l)
    o[p] = d;
  return o;
}, __ = {
  name: "MukButton"
}, y_ = /* @__PURE__ */ Object.assign(__, {
  props: {
    size: {
      type: String,
      default: "middle"
    },
    type: {
      type: String,
      default: "default"
    }
  },
  setup(w) {
    return (l, o) => (ju(), Xu("button", {
      class: Ip(["muk-btn", [w.size, w.type]])
    }, [
      Dp(l.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), x_ = /* @__PURE__ */ v_(y_, [["__scopeId", "data-v-0e6d93cd"]]);
class w_ {
  constructor() {
    this.dom = {
      mask: document.querySelector(".js-mask"),
      slices: [...document.querySelectorAll(".js-mask__slice")],
      lines: [...document.querySelectorAll(".js-mask-line")],
      logo: document.querySelector(".js-logo"),
      titles: [...document.querySelectorAll(".js-transition-title")]
    }, this.tl = null, this.state = !1, this.init();
  }
  resetScroll() {
    window.scrollTo(0, 0);
  }
  createTimeline() {
    this.tl = new TimelineMax({
      paused: !0,
      onComplete: () => {
        this.state = !1;
      }
    }), this.tl.set(this.dom.titles, {
      yPercent: 0
    }).set(this.dom.mask, {
      autoAlpha: 1
    }).staggerFromTo(
      this.dom.slices,
      1.5,
      {
        xPercent: 100
      },
      {
        xPercent: 0,
        ease: Expo.easeInOut
      },
      -0.075
    ).addCallback(this.resetScroll.bind(this)).addLabel("loaderStart").set(this.dom.titles, {
      yPercent: -100
    }).set([this.dom.lines[0], this.dom.logo], {
      autoAlpha: 1
    }).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: -100,
        rotation: 10
      },
      {
        yPercent: 0,
        rotation: 0,
        ease: Expo.easeOut
      }
    ).addLabel("intermediateFrame").staggerFromTo(
      this.dom.lines,
      0.5,
      {
        scaleX: 0
      },
      {
        scaleX: 1,
        ease: Expo.easeInOut
      },
      0.75,
      "-=1"
    ).set(this.dom.lines, {
      transformOrigin: "right"
    }).fromTo(
      this.dom.lines[0],
      1,
      {
        scaleX: 1
      },
      {
        scaleX: 0,
        ease: Expo.easeInOut
      }
    ).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: 0
      },
      {
        yPercent: 105,
        ease: Expo.easeOut
      },
      "-=1"
    ).staggerFromTo(
      this.dom.slices,
      0.5,
      {
        xPercent: 0
      },
      {
        xPercent: 100,
        ease: Expo.easeInOut
      },
      0.075
    ).set(this.dom.mask, {
      autoAlpha: 0
    }).addLabel("imagesStart", "-=0.85").staggerFromTo(
      this.dom.titles,
      1.5,
      {
        yPercent: 100
      },
      {
        yPercent: 0,
        ease: Expo.easeInOut
      },
      0.05,
      "imagesStart"
    ).addLabel("loaderEnd");
  }
  continuation() {
    this.init(), this.resetScroll(), this.tl.tweenFromTo("loaderStart", "loaderEnd");
  }
  show() {
    this.init(), this.tl.tweenFromTo("loaderStart", "intermediateFrame");
  }
  hide() {
    this.resetScroll(), this.tl.tweenFromTo("intermediateFrame", "loaderEnd");
  }
  init() {
    document.querySelector(".mask-line.js-mask-line") && document.querySelector(".mask-line.js-mask-line").removeAttribute("style"), document.querySelector(".mask-line__inner.js-mask-line") && document.querySelector(".mask-line__inner.js-mask-line").removeAttribute("style"), this.createTimeline();
  }
}
const T_ = { class: "mask js-mask" }, M_ = /* @__PURE__ */ Mr("div", { class: "mask__slice js-mask__slice" }, null, -1), S_ = /* @__PURE__ */ Mr("div", { class: "mask__slice js-mask__slice" }, null, -1), E_ = /* @__PURE__ */ Mr("div", { class: "mask__slice js-mask__slice" }, null, -1), b_ = { class: "mask__inner" }, A_ = { class: "logo logo--mask" }, C_ = {
  class: "js-logo",
  style: { color: "#fff" }
}, P_ = /* @__PURE__ */ Mr("div", { class: "mask-line js-mask-line" }, [
  /* @__PURE__ */ Mr("div", { class: "mask-line__inner js-mask-line" })
], -1), L_ = {
  name: "BimCutscenes"
}, R_ = /* @__PURE__ */ tf({
  ...L_,
  props: {
    text: {
      type: String,
      default: "CHBIM云平台"
    }
  },
  setup(w, { expose: l }) {
    const o = kc(null), p = () => {
      o.value === null && (o.value = new w_());
    }, d = () => {
      p(), o.value.continuation();
    };
    return ef(() => {
      p();
    }), l({
      continuation: d
    }), (u, m) => (ju(), Xu("div", T_, [
      M_,
      S_,
      E_,
      Mr("div", b_, [
        Mr("figure", A_, [
          Mr("p", C_, g_(w.text), 1)
        ]),
        P_
      ])
    ]));
  }
});
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
var hn = typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window;
(hn._gsQueue || (hn._gsQueue = [])).push(function() {
  hn._gsDefine(
    "TweenMax",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(w, l, o) {
      var p = function(E) {
        var L, x = [], M = E.length;
        for (L = 0; L !== M; x.push(E[L++]))
          ;
        return x;
      }, d = function(E, L, x) {
        var M, R, b = E.cycle;
        for (M in b)
          R = b[M], E[M] = typeof R == "function" ? R(x, L[x]) : R[x % R.length];
        delete E.cycle;
      }, u = function(E, L, x) {
        o.call(this, E, L, x), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = u.prototype.render;
      }, m = 1e-10, _ = o._internals, T = _.isSelector, S = _.isArray, C = u.prototype = o.to({}, 0.1, {}), z = [];
      u.version = "2.0.2", C.constructor = u, C.kill()._gc = !1, u.killTweensOf = u.killDelayedCallsTo = o.killTweensOf, u.getTweensOf = o.getTweensOf, u.lagSmoothing = o.lagSmoothing, u.ticker = o.ticker, u.render = o.render, C.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), o.prototype.invalidate.call(this);
      }, C.updateTo = function(E, L) {
        var x, M = this.ratio, R = this.vars.immediateRender || E.immediateRender;
        L && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
        for (x in E)
          this.vars[x] = E[x];
        if (this._initted || R) {
          if (L)
            this._initted = !1, R && this.render(0, !0, !0);
          else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && o._onPluginEvent("_onDisable", this), this._time / this._duration > 0.998) {
            var b = this._totalTime;
            this.render(0, !0, !1), this._initted = !1, this.render(b, !0, !1);
          } else if (this._initted = !1, this._init(), this._time > 0 || R)
            for (var U, N = 1 / (1 - M), j = this._firstPT; j; )
              U = j.s + j.c, j.c *= N, j.s = U - j.c, j = j._next;
        }
        return this;
      }, C.render = function(E, L, x) {
        this._initted || this._duration === 0 && this.vars.repeat && this.invalidate();
        var M, R, b, U, N, j, J, $, ct, It = this._dirty ? this.totalDuration() : this._totalDuration, et = this._time, yt = this._totalTime, G = this._cycle, Pt = this._duration, Et = this._rawPrevTime;
        if (E >= It - 1e-7 && E >= 0 ? (this._totalTime = It, this._cycle = this._repeat, this._yoyo && 1 & this._cycle ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = Pt, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (M = !0, R = "onComplete", x = x || this._timeline.autoRemoveChildren), Pt === 0 && (this._initted || !this.vars.lazy || x) && (this._startTime === this._timeline._duration && (E = 0), (0 > Et || 0 >= E && E >= -1e-7 || Et === m && this.data !== "isPause") && Et !== E && (x = !0, Et > m && (R = "onReverseComplete")), this._rawPrevTime = $ = !L || E || Et === E ? E : m)) : 1e-7 > E ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (yt !== 0 || Pt === 0 && Et > 0) && (R = "onReverseComplete", M = this._reversed), 0 > E && (this._active = !1, Pt === 0 && (this._initted || !this.vars.lazy || x) && (Et >= 0 && (x = !0), this._rawPrevTime = $ = !L || E || Et === E ? E : m)), this._initted || (x = !0)) : (this._totalTime = this._time = E, this._repeat !== 0 && (U = Pt + this._repeatDelay, this._cycle = this._totalTime / U >> 0, this._cycle !== 0 && this._cycle === this._totalTime / U && E >= yt && this._cycle--, this._time = this._totalTime - this._cycle * U, this._yoyo && 1 & this._cycle && (this._time = Pt - this._time, ct = this._yoyoEase || this.vars.yoyoEase, ct && (this._yoyoEase || (ct !== !0 || this._initted ? this._yoyoEase = ct = ct === !0 ? this._ease : ct instanceof Ease ? ct : Ease.map[ct] : (ct = this.vars.ease, this._yoyoEase = ct = ct ? ct instanceof Ease ? ct : typeof ct == "function" ? new Ease(ct, this.vars.easeParams) : Ease.map[ct] || o.defaultEase : o.defaultEase)), this.ratio = ct ? 1 - ct.getRatio((Pt - this._time) / Pt) : 0)), this._time > Pt ? this._time = Pt : this._time < 0 && (this._time = 0)), this._easeType && !ct ? (N = this._time / Pt, j = this._easeType, J = this._easePower, (j === 1 || j === 3 && N >= 0.5) && (N = 1 - N), j === 3 && (N *= 2), J === 1 ? N *= N : J === 2 ? N *= N * N : J === 3 ? N *= N * N * N : J === 4 && (N *= N * N * N * N), j === 1 ? this.ratio = 1 - N : j === 2 ? this.ratio = N : this._time / Pt < 0.5 ? this.ratio = N / 2 : this.ratio = 1 - N / 2) : ct || (this.ratio = this._ease.getRatio(this._time / Pt))), et === this._time && !x && G === this._cycle)
          return void (yt !== this._totalTime && this._onUpdate && (L || this._callback("onUpdate")));
        if (!this._initted) {
          if (this._init(), !this._initted || this._gc)
            return;
          if (!x && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
            return this._time = et, this._totalTime = yt, this._rawPrevTime = Et, this._cycle = G, _.lazyTweens.push(this), void (this._lazy = [E, L]);
          !this._time || M || ct ? M && this._ease._calcEnd && !ct && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / Pt);
        }
        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== et && E >= 0 && (this._active = !0), yt === 0 && (this._initted === 2 && E > 0 && this._init(), this._startAt && (E >= 0 ? this._startAt.render(E, !0, x) : R || (R = "_dummyGS")), this.vars.onStart && (this._totalTime !== 0 || Pt === 0) && (L || this._callback("onStart"))), b = this._firstPT; b; )
          b.f ? b.t[b.p](b.c * this.ratio + b.s) : b.t[b.p] = b.c * this.ratio + b.s, b = b._next;
        this._onUpdate && (0 > E && this._startAt && this._startTime && this._startAt.render(E, !0, x), L || (this._totalTime !== yt || R) && this._callback("onUpdate")), this._cycle !== G && (L || this._gc || this.vars.onRepeat && this._callback("onRepeat")), R && (!this._gc || x) && (0 > E && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(E, !0, x), M && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !L && this.vars[R] && this._callback(R), Pt === 0 && this._rawPrevTime === m && $ !== m && (this._rawPrevTime = 0));
      }, u.to = function(E, L, x) {
        return new u(E, L, x);
      }, u.from = function(E, L, x) {
        return x.runBackwards = !0, x.immediateRender = x.immediateRender != 0, new u(E, L, x);
      }, u.fromTo = function(E, L, x, M) {
        return M.startAt = x, M.immediateRender = M.immediateRender != 0 && x.immediateRender != 0, new u(E, L, M);
      }, u.staggerTo = u.allTo = function(E, L, x, M, R, b, U) {
        M = M || 0;
        var N, j, J, $, ct = 0, It = [], et = function() {
          x.onComplete && x.onComplete.apply(x.onCompleteScope || this, arguments), R.apply(U || x.callbackScope || this, b || z);
        }, yt = x.cycle, G = x.startAt && x.startAt.cycle;
        for (S(E) || (typeof E == "string" && (E = o.selector(E) || E), T(E) && (E = p(E))), E = E || [], 0 > M && (E = p(E), E.reverse(), M *= -1), N = E.length - 1, J = 0; N >= J; J++) {
          j = {};
          for ($ in x)
            j[$] = x[$];
          if (yt && (d(j, E, J), j.duration != null && (L = j.duration, delete j.duration)), G) {
            G = j.startAt = {};
            for ($ in x.startAt)
              G[$] = x.startAt[$];
            d(j.startAt, E, J);
          }
          j.delay = ct + (j.delay || 0), J === N && R && (j.onComplete = et), It[J] = new u(E[J], L, j), ct += M;
        }
        return It;
      }, u.staggerFrom = u.allFrom = function(E, L, x, M, R, b, U) {
        return x.runBackwards = !0, x.immediateRender = x.immediateRender != 0, u.staggerTo(E, L, x, M, R, b, U);
      }, u.staggerFromTo = u.allFromTo = function(E, L, x, M, R, b, U, N) {
        return M.startAt = x, M.immediateRender = M.immediateRender != 0 && x.immediateRender != 0, u.staggerTo(E, L, M, R, b, U, N);
      }, u.delayedCall = function(E, L, x, M, R) {
        return new u(L, 0, {
          delay: E,
          onComplete: L,
          onCompleteParams: x,
          callbackScope: M,
          onReverseComplete: L,
          onReverseCompleteParams: x,
          immediateRender: !1,
          useFrames: R,
          overwrite: 0
        });
      }, u.set = function(E, L) {
        return new u(E, 0, L);
      }, u.isTweening = function(E) {
        return o.getTweensOf(E, !0).length > 0;
      };
      var B = function(E, L) {
        for (var x = [], M = 0, R = E._first; R; )
          R instanceof o ? x[M++] = R : (L && (x[M++] = R), x = x.concat(B(R, L)), M = x.length), R = R._next;
        return x;
      }, I = u.getAllTweens = function(E) {
        return B(w._rootTimeline, E).concat(B(w._rootFramesTimeline, E));
      };
      u.killAll = function(E, L, x, M) {
        L == null && (L = !0), x == null && (x = !0);
        var R, b, U, N = I(M != 0), j = N.length, J = L && x && M;
        for (U = 0; j > U; U++)
          b = N[U], (J || b instanceof l || (R = b.target === b.vars.onComplete) && x || L && !R) && (E ? b.totalTime(b._reversed ? 0 : b.totalDuration()) : b._enabled(!1, !1));
      }, u.killChildTweensOf = function(E, L) {
        if (E != null) {
          var x, M, R, b, U, N = _.tweenLookup;
          if (typeof E == "string" && (E = o.selector(E) || E), T(E) && (E = p(E)), S(E))
            for (b = E.length; --b > -1; )
              u.killChildTweensOf(E[b], L);
          else {
            x = [];
            for (R in N)
              for (M = N[R].target.parentNode; M; )
                M === E && (x = x.concat(N[R].tweens)), M = M.parentNode;
            for (U = x.length, b = 0; U > b; b++)
              L && x[b].totalTime(x[b].totalDuration()), x[b]._enabled(!1, !1);
          }
        }
      };
      var F = function(E, L, x, M) {
        L = L !== !1, x = x !== !1, M = M !== !1;
        for (var R, b, U = I(M), N = L && x && M, j = U.length; --j > -1; )
          b = U[j], (N || b instanceof l || (R = b.target === b.vars.onComplete) && x || L && !R) && b.paused(E);
      };
      return u.pauseAll = function(E, L, x) {
        F(!0, E, L, x);
      }, u.resumeAll = function(E, L, x) {
        F(!1, E, L, x);
      }, u.globalTimeScale = function(E) {
        var L = w._rootTimeline, x = o.ticker.time;
        return arguments.length ? (E = E || m, L._startTime = x - (x - L._startTime) * L._timeScale / E, L = w._rootFramesTimeline, x = o.ticker.frame, L._startTime = x - (x - L._startTime) * L._timeScale / E, L._timeScale = w._rootTimeline._timeScale = E, E) : L._timeScale;
      }, C.progress = function(E, L) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - E : E) + this._cycle * (this._duration + this._repeatDelay),
          L
        ) : this._time / this.duration();
      }, C.totalProgress = function(E, L) {
        return arguments.length ? this.totalTime(this.totalDuration() * E, L) : this._totalTime / this.totalDuration();
      }, C.time = function(E, L) {
        return arguments.length ? (this._dirty && this.totalDuration(), E > this._duration && (E = this._duration), this._yoyo && 1 & this._cycle ? E = this._duration - E + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (E += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(E, L)) : this._time;
      }, C.duration = function(E) {
        return arguments.length ? w.prototype.duration.call(this, E) : this._duration;
      }, C.totalDuration = function(E) {
        return arguments.length ? this._repeat === -1 ? this : this.duration(
          (E - this._repeat * this._repeatDelay) / (this._repeat + 1)
        ) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration);
      }, C.repeat = function(E) {
        return arguments.length ? (this._repeat = E, this._uncache(!0)) : this._repeat;
      }, C.repeatDelay = function(E) {
        return arguments.length ? (this._repeatDelay = E, this._uncache(!0)) : this._repeatDelay;
      }, C.yoyo = function(E) {
        return arguments.length ? (this._yoyo = E, this) : this._yoyo;
      }, u;
    },
    !0
  ), hn._gsDefine(
    "TimelineLite",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(w, l, o) {
      var p = function(x) {
        l.call(this, x), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
        var M, R, b = this.vars;
        for (R in b)
          M = b[R], T(M) && M.join("").indexOf("{self}") !== -1 && (b[R] = this._swapSelfInParams(M));
        T(b.tweens) && this.add(b.tweens, 0, b.align, b.stagger);
      }, d = 1e-10, u = o._internals, m = p._internals = {}, _ = u.isSelector, T = u.isArray, S = u.lazyTweens, C = u.lazyRender, z = hn._gsDefine.globals, B = function(x) {
        var M, R = {};
        for (M in x)
          R[M] = x[M];
        return R;
      }, I = function(x, M, R) {
        var b, U, N = x.cycle;
        for (b in N)
          U = N[b], x[b] = typeof U == "function" ? U(R, M[R]) : U[R % U.length];
        delete x.cycle;
      }, F = m.pauseCallback = function() {
      }, E = function(x) {
        var M, R = [], b = x.length;
        for (M = 0; M !== b; R.push(x[M++]))
          ;
        return R;
      }, L = p.prototype = new l();
      return p.version = "2.0.2", L.constructor = p, L.kill()._gc = L._forcingPlayhead = L._hasPause = !1, L.to = function(x, M, R, b) {
        var U = R.repeat && z.TweenMax || o;
        return M ? this.add(new U(x, M, R), b) : this.set(x, R, b);
      }, L.from = function(x, M, R, b) {
        return this.add((R.repeat && z.TweenMax || o).from(x, M, R), b);
      }, L.fromTo = function(x, M, R, b, U) {
        var N = b.repeat && z.TweenMax || o;
        return M ? this.add(N.fromTo(x, M, R, b), U) : this.set(x, b, U);
      }, L.staggerTo = function(x, M, R, b, U, N, j, J) {
        var $, ct, It = new p({
          onComplete: N,
          onCompleteParams: j,
          callbackScope: J,
          smoothChildTiming: this.smoothChildTiming
        }), et = R.cycle;
        for (typeof x == "string" && (x = o.selector(x) || x), x = x || [], _(x) && (x = E(x)), b = b || 0, 0 > b && (x = E(x), x.reverse(), b *= -1), ct = 0; ct < x.length; ct++)
          $ = B(R), $.startAt && ($.startAt = B($.startAt), $.startAt.cycle && I($.startAt, x, ct)), et && (I($, x, ct), $.duration != null && (M = $.duration, delete $.duration)), It.to(x[ct], M, $, ct * b);
        return this.add(It, U);
      }, L.staggerFrom = function(x, M, R, b, U, N, j, J) {
        return R.immediateRender = R.immediateRender != 0, R.runBackwards = !0, this.staggerTo(x, M, R, b, U, N, j, J);
      }, L.staggerFromTo = function(x, M, R, b, U, N, j, J, $) {
        return b.startAt = R, b.immediateRender = b.immediateRender != 0 && R.immediateRender != 0, this.staggerTo(x, M, b, U, N, j, J, $);
      }, L.call = function(x, M, R, b) {
        return this.add(o.delayedCall(0, x, M, R), b);
      }, L.set = function(x, M, R) {
        return R = this._parseTimeOrLabel(R, 0, !0), M.immediateRender == null && (M.immediateRender = R === this._time && !this._paused), this.add(new o(x, 0, M), R);
      }, p.exportRoot = function(x, M) {
        x = x || {}, x.smoothChildTiming == null && (x.smoothChildTiming = !0);
        var R, b, U, N, j = new p(x), J = j._timeline;
        for (M == null && (M = !0), J._remove(j, !0), j._startTime = 0, j._rawPrevTime = j._time = j._totalTime = J._time, U = J._first; U; )
          N = U._next, M && U instanceof o && U.target === U.vars.onComplete || (b = U._startTime - U._delay, 0 > b && (R = 1), j.add(U, b)), U = N;
        return J.add(j, 0), R && j.totalDuration(), j;
      }, L.add = function(x, M, R, b) {
        var U, N, j, J, $, ct;
        if (typeof M != "number" && (M = this._parseTimeOrLabel(M, 0, !0, x)), !(x instanceof w)) {
          if (x instanceof Array || x && x.push && T(x)) {
            for (R = R || "normal", b = b || 0, U = M, N = x.length, j = 0; N > j; j++)
              T(J = x[j]) && (J = new p({ tweens: J })), this.add(J, U), typeof J != "string" && typeof J != "function" && (R === "sequence" ? U = J._startTime + J.totalDuration() / J._timeScale : R === "start" && (J._startTime -= J.delay())), U += b;
            return this._uncache(!0);
          }
          if (typeof x == "string")
            return this.addLabel(x, M);
          if (typeof x != "function")
            throw "Cannot add " + x + " into the timeline; it is not a tween, timeline, function, or string.";
          x = o.delayedCall(0, x);
        }
        if (l.prototype.add.call(this, x, M), x._time && (U = Math.max(
          0,
          Math.min(
            x.totalDuration(),
            (this.rawTime() - x._startTime) * x._timeScale
          )
        ), Math.abs(U - x._totalTime) > 1e-5 && x.render(U, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
          for ($ = this, ct = $.rawTime() > x._startTime; $._timeline; )
            ct && $._timeline.smoothChildTiming ? $.totalTime($._totalTime, !0) : $._gc && $._enabled(!0, !1), $ = $._timeline;
        return this;
      }, L.remove = function(x) {
        if (x instanceof w) {
          this._remove(x, !1);
          var M = x._timeline = x.vars.useFrames ? w._rootFramesTimeline : w._rootTimeline;
          return x._startTime = (x._paused ? x._pauseTime : M._time) - (x._reversed ? x.totalDuration() - x._totalTime : x._totalTime) / x._timeScale, this;
        }
        if (x instanceof Array || x && x.push && T(x)) {
          for (var R = x.length; --R > -1; )
            this.remove(x[R]);
          return this;
        }
        return typeof x == "string" ? this.removeLabel(x) : this.kill(null, x);
      }, L._remove = function(x, M) {
        l.prototype._remove.call(this, x, M);
        var R = this._last;
        return R ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this;
      }, L.append = function(x, M) {
        return this.add(x, this._parseTimeOrLabel(null, M, !0, x));
      }, L.insert = L.insertMultiple = function(x, M, R, b) {
        return this.add(x, M || 0, R, b);
      }, L.appendMultiple = function(x, M, R, b) {
        return this.add(x, this._parseTimeOrLabel(null, M, !0, x), R, b);
      }, L.addLabel = function(x, M) {
        return this._labels[x] = this._parseTimeOrLabel(M), this;
      }, L.addPause = function(x, M, R, b) {
        var U = o.delayedCall(0, F, R, b || this);
        return U.vars.onComplete = U.vars.onReverseComplete = M, U.data = "isPause", this._hasPause = !0, this.add(U, x);
      }, L.removeLabel = function(x) {
        return delete this._labels[x], this;
      }, L.getLabelTime = function(x) {
        return this._labels[x] != null ? this._labels[x] : -1;
      }, L._parseTimeOrLabel = function(x, M, R, b) {
        var U, N;
        if (b instanceof w && b.timeline === this)
          this.remove(b);
        else if (b && (b instanceof Array || b.push && T(b)))
          for (N = b.length; --N > -1; )
            b[N] instanceof w && b[N].timeline === this && this.remove(b[N]);
        if (U = typeof x != "number" || M ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, typeof M == "string")
          return this._parseTimeOrLabel(
            M,
            R && typeof x == "number" && this._labels[M] == null ? x - U : 0,
            R
          );
        if (M = M || 0, typeof x != "string" || !isNaN(x) && this._labels[x] == null)
          x == null && (x = U);
        else {
          if (N = x.indexOf("="), N === -1)
            return this._labels[x] == null ? R ? this._labels[x] = U + M : M : this._labels[x] + M;
          M = parseInt(x.charAt(N - 1) + "1", 10) * Number(x.substr(N + 1)), x = N > 1 ? this._parseTimeOrLabel(x.substr(0, N - 1), 0, R) : U;
        }
        return Number(x) + M;
      }, L.seek = function(x, M) {
        return this.totalTime(
          typeof x == "number" ? x : this._parseTimeOrLabel(x),
          M !== !1
        );
      }, L.stop = function() {
        return this.paused(!0);
      }, L.gotoAndPlay = function(x, M) {
        return this.play(x, M);
      }, L.gotoAndStop = function(x, M) {
        return this.pause(x, M);
      }, L.render = function(x, M, R) {
        this._gc && this._enabled(!0, !1);
        var b, U, N, j, J, $, ct, It = this._time, et = this._dirty ? this.totalDuration() : this._totalDuration, yt = this._startTime, G = this._timeScale, Pt = this._paused;
        if (It !== this._time && (x += this._time - It), x >= et - 1e-7 && x >= 0)
          this._totalTime = this._time = et, this._reversed || this._hasPausedChild() || (U = !0, j = "onComplete", J = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= x && x >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === d) && this._rawPrevTime !== x && this._first && (J = !0, this._rawPrevTime > d && (j = "onReverseComplete"))), this._rawPrevTime = this._duration || !M || x || this._rawPrevTime === x ? x : d, x = et + 1e-4;
        else if (1e-7 > x)
          if (this._totalTime = this._time = 0, (It !== 0 || this._duration === 0 && this._rawPrevTime !== d && (this._rawPrevTime > 0 || 0 > x && this._rawPrevTime >= 0)) && (j = "onReverseComplete", U = this._reversed), 0 > x)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (J = U = !0, j = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (J = !0), this._rawPrevTime = x;
          else {
            if (this._rawPrevTime = this._duration || !M || x || this._rawPrevTime === x ? x : d, x === 0 && U)
              for (b = this._first; b && b._startTime === 0; )
                b._duration || (U = !1), b = b._next;
            x = 0, this._initted || (J = !0);
          }
        else {
          if (this._hasPause && !this._forcingPlayhead && !M) {
            if (x >= It)
              for (b = this._first; b && b._startTime <= x && !$; )
                b._duration || b.data !== "isPause" || b.ratio || b._startTime === 0 && this._rawPrevTime === 0 || ($ = b), b = b._next;
            else
              for (b = this._last; b && b._startTime >= x && !$; )
                b._duration || b.data === "isPause" && b._rawPrevTime > 0 && ($ = b), b = b._prev;
            $ && (this._time = x = $._startTime, this._totalTime = x + this._cycle * (this._totalDuration + this._repeatDelay));
          }
          this._totalTime = this._time = this._rawPrevTime = x;
        }
        if (this._time !== It && this._first || R || J || $) {
          if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== It && x > 0 && (this._active = !0), It === 0 && this.vars.onStart && (this._time === 0 && this._duration || M || this._callback("onStart")), ct = this._time, ct >= It)
            for (b = this._first; b && (N = b._next, ct === this._time && (!this._paused || Pt)); )
              (b._active || b._startTime <= ct && !b._paused && !b._gc) && ($ === b && this.pause(), b._reversed ? b.render(
                (b._dirty ? b.totalDuration() : b._totalDuration) - (x - b._startTime) * b._timeScale,
                M,
                R
              ) : b.render((x - b._startTime) * b._timeScale, M, R)), b = N;
          else
            for (b = this._last; b && (N = b._prev, ct === this._time && (!this._paused || Pt)); ) {
              if (b._active || b._startTime <= It && !b._paused && !b._gc) {
                if ($ === b) {
                  for ($ = b._prev; $ && $.endTime() > this._time; )
                    $.render(
                      $._reversed ? $.totalDuration() - (x - $._startTime) * $._timeScale : (x - $._startTime) * $._timeScale,
                      M,
                      R
                    ), $ = $._prev;
                  $ = null, this.pause();
                }
                b._reversed ? b.render(
                  (b._dirty ? b.totalDuration() : b._totalDuration) - (x - b._startTime) * b._timeScale,
                  M,
                  R
                ) : b.render((x - b._startTime) * b._timeScale, M, R);
              }
              b = N;
            }
          this._onUpdate && (M || (S.length && C(), this._callback("onUpdate"))), j && (this._gc || (yt === this._startTime || G !== this._timeScale) && (this._time === 0 || et >= this.totalDuration()) && (U && (S.length && C(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !M && this.vars[j] && this._callback(j)));
        }
      }, L._hasPausedChild = function() {
        for (var x = this._first; x; ) {
          if (x._paused || x instanceof p && x._hasPausedChild())
            return !0;
          x = x._next;
        }
        return !1;
      }, L.getChildren = function(x, M, R, b) {
        b = b || -9999999999;
        for (var U = [], N = this._first, j = 0; N; )
          N._startTime < b || (N instanceof o ? M !== !1 && (U[j++] = N) : (R !== !1 && (U[j++] = N), x !== !1 && (U = U.concat(N.getChildren(!0, M, R)), j = U.length))), N = N._next;
        return U;
      }, L.getTweensOf = function(x, M) {
        var R, b, U = this._gc, N = [], j = 0;
        for (U && this._enabled(!0, !0), R = o.getTweensOf(x), b = R.length; --b > -1; )
          (R[b].timeline === this || M && this._contains(R[b])) && (N[j++] = R[b]);
        return U && this._enabled(!1, !0), N;
      }, L.recent = function() {
        return this._recent;
      }, L._contains = function(x) {
        for (var M = x.timeline; M; ) {
          if (M === this)
            return !0;
          M = M.timeline;
        }
        return !1;
      }, L.shiftChildren = function(x, M, R) {
        R = R || 0;
        for (var b, U = this._first, N = this._labels; U; )
          U._startTime >= R && (U._startTime += x), U = U._next;
        if (M)
          for (b in N)
            N[b] >= R && (N[b] += x);
        return this._uncache(!0);
      }, L._kill = function(x, M) {
        if (!x && !M)
          return this._enabled(!1, !1);
        for (var R = M ? this.getTweensOf(M) : this.getChildren(!0, !0, !1), b = R.length, U = !1; --b > -1; )
          R[b]._kill(x, M) && (U = !0);
        return U;
      }, L.clear = function(x) {
        var M = this.getChildren(!1, !0, !0), R = M.length;
        for (this._time = this._totalTime = 0; --R > -1; )
          M[R]._enabled(!1, !1);
        return x !== !1 && (this._labels = {}), this._uncache(!0);
      }, L.invalidate = function() {
        for (var x = this._first; x; )
          x.invalidate(), x = x._next;
        return w.prototype.invalidate.call(this);
      }, L._enabled = function(x, M) {
        if (x === this._gc)
          for (var R = this._first; R; )
            R._enabled(x, !0), R = R._next;
        return l.prototype._enabled.call(this, x, M);
      }, L.totalTime = function(x, M, R) {
        this._forcingPlayhead = !0;
        var b = w.prototype.totalTime.apply(this, arguments);
        return this._forcingPlayhead = !1, b;
      }, L.duration = function(x) {
        return arguments.length ? (this.duration() !== 0 && x !== 0 && this.timeScale(this._duration / x), this) : (this._dirty && this.totalDuration(), this._duration);
      }, L.totalDuration = function(x) {
        if (!arguments.length) {
          if (this._dirty) {
            for (var M, R, b = 0, U = this._last, N = 999999999999; U; )
              M = U._prev, U._dirty && U.totalDuration(), U._startTime > N && this._sortChildren && !U._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(U, U._startTime - U._delay), this._calculatingDuration = 0) : N = U._startTime, U._startTime < 0 && !U._paused && (b -= U._startTime, this._timeline.smoothChildTiming && (this._startTime += U._startTime / this._timeScale, this._time -= U._startTime, this._totalTime -= U._startTime, this._rawPrevTime -= U._startTime), this.shiftChildren(-U._startTime, !1, -9999999999), N = 0), R = U._startTime + U._totalDuration / U._timeScale, R > b && (b = R), U = M;
            this._duration = this._totalDuration = b, this._dirty = !1;
          }
          return this._totalDuration;
        }
        return x && this.totalDuration() ? this.timeScale(this._totalDuration / x) : this;
      }, L.paused = function(x) {
        if (!x)
          for (var M = this._first, R = this._time; M; )
            M._startTime === R && M.data === "isPause" && (M._rawPrevTime = 0), M = M._next;
        return w.prototype.paused.apply(this, arguments);
      }, L.usesFrames = function() {
        for (var x = this._timeline; x._timeline; )
          x = x._timeline;
        return x === w._rootFramesTimeline;
      }, L.rawTime = function(x) {
        return x && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(x) - this._startTime) * this._timeScale;
      }, p;
    },
    !0
  ), hn._gsDefine(
    "TimelineMax",
    ["TimelineLite", "TweenLite", "easing.Ease"],
    function(w, l, o) {
      var p = function(z) {
        w.call(this, z), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0;
      }, d = 1e-10, u = l._internals, m = u.lazyTweens, _ = u.lazyRender, T = hn._gsDefine.globals, S = new o(null, null, 1, 0), C = p.prototype = new w();
      return C.constructor = p, C.kill()._gc = !1, p.version = "2.0.2", C.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), w.prototype.invalidate.call(this);
      }, C.addCallback = function(z, B, I, F) {
        return this.add(l.delayedCall(0, z, I, F), B);
      }, C.removeCallback = function(z, B) {
        if (z)
          if (B == null)
            this._kill(null, z);
          else
            for (var I = this.getTweensOf(z, !1), F = I.length, E = this._parseTimeOrLabel(B); --F > -1; )
              I[F]._startTime === E && I[F]._enabled(!1, !1);
        return this;
      }, C.removePause = function(z) {
        return this.removeCallback(w._internals.pauseCallback, z);
      }, C.tweenTo = function(z, B) {
        B = B || {};
        var I, F, E, L = {
          ease: S,
          useFrames: this.usesFrames(),
          immediateRender: !1,
          lazy: !1
        }, x = B.repeat && T.TweenMax || l;
        for (F in B)
          L[F] = B[F];
        return L.time = this._parseTimeOrLabel(z), I = Math.abs(Number(L.time) - this._time) / this._timeScale || 1e-3, E = new x(this, I, L), L.onStart = function() {
          E.target.paused(!0), E.vars.time === E.target.time() || I !== E.duration() || E.isFromTo || E.duration(
            Math.abs(E.vars.time - E.target.time()) / E.target._timeScale
          ).render(E.time(), !0, !0), B.onStart && B.onStart.apply(
            B.onStartScope || B.callbackScope || E,
            B.onStartParams || []
          );
        }, E;
      }, C.tweenFromTo = function(z, B, I) {
        I = I || {}, z = this._parseTimeOrLabel(z), I.startAt = {
          onComplete: this.seek,
          onCompleteParams: [z],
          callbackScope: this
        }, I.immediateRender = I.immediateRender !== !1;
        var F = this.tweenTo(B, I);
        return F.isFromTo = 1, F.duration(Math.abs(F.vars.time - z) / this._timeScale || 1e-3);
      }, C.render = function(z, B, I) {
        this._gc && this._enabled(!0, !1);
        var F, E, L, x, M, R, b, U, N = this._time, j = this._dirty ? this.totalDuration() : this._totalDuration, J = this._duration, $ = this._totalTime, ct = this._startTime, It = this._timeScale, et = this._rawPrevTime, yt = this._paused, G = this._cycle;
        if (N !== this._time && (z += this._time - N), z >= j - 1e-7 && z >= 0)
          this._locked || (this._totalTime = j, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (E = !0, x = "onComplete", M = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= z && z >= -1e-7 || 0 > et || et === d) && et !== z && this._first && (M = !0, et > d && (x = "onReverseComplete"))), this._rawPrevTime = this._duration || !B || z || this._rawPrevTime === z ? z : d, this._yoyo && 1 & this._cycle ? this._time = z = 0 : (this._time = J, z = J + 1e-4);
        else if (1e-7 > z)
          if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (N !== 0 || J === 0 && et !== d && (et > 0 || 0 > z && et >= 0) && !this._locked) && (x = "onReverseComplete", E = this._reversed), 0 > z)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (M = E = !0, x = "onReverseComplete") : et >= 0 && this._first && (M = !0), this._rawPrevTime = z;
          else {
            if (this._rawPrevTime = J || !B || z || this._rawPrevTime === z ? z : d, z === 0 && E)
              for (F = this._first; F && F._startTime === 0; )
                F._duration || (E = !1), F = F._next;
            z = 0, this._initted || (M = !0);
          }
        else if (J === 0 && 0 > et && (M = !0), this._time = this._rawPrevTime = z, this._locked || (this._totalTime = z, this._repeat !== 0 && (R = J + this._repeatDelay, this._cycle = this._totalTime / R >> 0, this._cycle !== 0 && this._cycle === this._totalTime / R && z >= $ && this._cycle--, this._time = this._totalTime - this._cycle * R, this._yoyo && 1 & this._cycle && (this._time = J - this._time), this._time > J ? (this._time = J, z = J + 1e-4) : this._time < 0 ? this._time = z = 0 : z = this._time)), this._hasPause && !this._forcingPlayhead && !B) {
          if (z = this._time, z >= N || this._repeat && G !== this._cycle)
            for (F = this._first; F && F._startTime <= z && !b; )
              F._duration || F.data !== "isPause" || F.ratio || F._startTime === 0 && this._rawPrevTime === 0 || (b = F), F = F._next;
          else
            for (F = this._last; F && F._startTime >= z && !b; )
              F._duration || F.data === "isPause" && F._rawPrevTime > 0 && (b = F), F = F._prev;
          b && b._startTime < J && (this._time = z = b._startTime, this._totalTime = z + this._cycle * (this._totalDuration + this._repeatDelay));
        }
        if (this._cycle !== G && !this._locked) {
          var Pt = this._yoyo && (1 & G) !== 0, Et = Pt === (this._yoyo && (1 & this._cycle) !== 0), Ct = this._totalTime, ce = this._cycle, re = this._rawPrevTime, Ft = this._time;
          if (this._totalTime = G * J, this._cycle < G ? Pt = !Pt : this._totalTime += J, this._time = N, this._rawPrevTime = J === 0 ? et - 1e-4 : et, this._cycle = G, this._locked = !0, N = Pt ? 0 : J, this.render(N, B, J === 0), B || this._gc || this.vars.onRepeat && (this._cycle = ce, this._locked = !1, this._callback("onRepeat")), N !== this._time || (Et && (this._cycle = G, this._locked = !0, N = Pt ? J + 1e-4 : -1e-4, this.render(N, !0, !1)), this._locked = !1, this._paused && !yt))
            return;
          this._time = Ft, this._totalTime = Ct, this._cycle = ce, this._rawPrevTime = re;
        }
        if (!(this._time !== N && this._first || I || M || b))
          return void ($ !== this._totalTime && this._onUpdate && (B || this._callback("onUpdate")));
        if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== $ && z > 0 && (this._active = !0), $ === 0 && this.vars.onStart && (this._totalTime === 0 && this._totalDuration || B || this._callback("onStart")), U = this._time, U >= N)
          for (F = this._first; F && (L = F._next, U === this._time && (!this._paused || yt)); )
            (F._active || F._startTime <= this._time && !F._paused && !F._gc) && (b === F && this.pause(), F._reversed ? F.render(
              (F._dirty ? F.totalDuration() : F._totalDuration) - (z - F._startTime) * F._timeScale,
              B,
              I
            ) : F.render((z - F._startTime) * F._timeScale, B, I)), F = L;
        else
          for (F = this._last; F && (L = F._prev, U === this._time && (!this._paused || yt)); ) {
            if (F._active || F._startTime <= N && !F._paused && !F._gc) {
              if (b === F) {
                for (b = F._prev; b && b.endTime() > this._time; )
                  b.render(
                    b._reversed ? b.totalDuration() - (z - b._startTime) * b._timeScale : (z - b._startTime) * b._timeScale,
                    B,
                    I
                  ), b = b._prev;
                b = null, this.pause();
              }
              F._reversed ? F.render(
                (F._dirty ? F.totalDuration() : F._totalDuration) - (z - F._startTime) * F._timeScale,
                B,
                I
              ) : F.render((z - F._startTime) * F._timeScale, B, I);
            }
            F = L;
          }
        this._onUpdate && (B || (m.length && _(), this._callback("onUpdate"))), x && (this._locked || this._gc || (ct === this._startTime || It !== this._timeScale) && (this._time === 0 || j >= this.totalDuration()) && (E && (m.length && _(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !B && this.vars[x] && this._callback(x)));
      }, C.getActive = function(z, B, I) {
        z == null && (z = !0), B == null && (B = !0), I == null && (I = !1);
        var F, E, L = [], x = this.getChildren(z, B, I), M = 0, R = x.length;
        for (F = 0; R > F; F++)
          E = x[F], E.isActive() && (L[M++] = E);
        return L;
      }, C.getLabelAfter = function(z) {
        z || z !== 0 && (z = this._time);
        var B, I = this.getLabelsArray(), F = I.length;
        for (B = 0; F > B; B++)
          if (I[B].time > z)
            return I[B].name;
        return null;
      }, C.getLabelBefore = function(z) {
        z == null && (z = this._time);
        for (var B = this.getLabelsArray(), I = B.length; --I > -1; )
          if (B[I].time < z)
            return B[I].name;
        return null;
      }, C.getLabelsArray = function() {
        var z, B = [], I = 0;
        for (z in this._labels)
          B[I++] = { time: this._labels[z], name: z };
        return B.sort(function(F, E) {
          return F.time - E.time;
        }), B;
      }, C.invalidate = function() {
        return this._locked = !1, w.prototype.invalidate.call(this);
      }, C.progress = function(z, B) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - z : z) + this._cycle * (this._duration + this._repeatDelay),
          B
        ) : this._time / this.duration() || 0;
      }, C.totalProgress = function(z, B) {
        return arguments.length ? this.totalTime(this.totalDuration() * z, B) : this._totalTime / this.totalDuration() || 0;
      }, C.totalDuration = function(z) {
        return arguments.length ? this._repeat !== -1 && z ? this.timeScale(this.totalDuration() / z) : this : (this._dirty && (w.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration);
      }, C.time = function(z, B) {
        return arguments.length ? (this._dirty && this.totalDuration(), z > this._duration && (z = this._duration), this._yoyo && 1 & this._cycle ? z = this._duration - z + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (z += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(z, B)) : this._time;
      }, C.repeat = function(z) {
        return arguments.length ? (this._repeat = z, this._uncache(!0)) : this._repeat;
      }, C.repeatDelay = function(z) {
        return arguments.length ? (this._repeatDelay = z, this._uncache(!0)) : this._repeatDelay;
      }, C.yoyo = function(z) {
        return arguments.length ? (this._yoyo = z, this) : this._yoyo;
      }, C.currentLabel = function(z) {
        return arguments.length ? this.seek(z, !0) : this.getLabelBefore(this._time + 1e-8);
      }, p;
    },
    !0
  ), function() {
    var w = 180 / Math.PI, l = [], o = [], p = [], d = {}, u = hn._gsDefine.globals, m = function(x, M, R, b) {
      R === b && (R = b - (b - M) / 1e6), x === M && (M = x + (R - x) / 1e6), this.a = x, this.b = M, this.c = R, this.d = b, this.da = b - x, this.ca = R - x, this.ba = M - x;
    }, _ = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", T = function(x, M, R, b) {
      var U = { a: x }, N = {}, j = {}, J = { c: b }, $ = (x + M) / 2, ct = (M + R) / 2, It = (R + b) / 2, et = ($ + ct) / 2, yt = (ct + It) / 2, G = (yt - et) / 8;
      return U.b = $ + (x - $) / 4, N.b = et + G, U.c = N.a = (U.b + N.b) / 2, N.c = j.a = (et + yt) / 2, j.b = yt - G, J.b = It + (b - It) / 4, j.c = J.a = (j.b + J.b) / 2, [U, N, j, J];
    }, S = function(x, M, R, b, U) {
      var N, j, J, $, ct, It, et, yt, G, Pt, Et, Ct, ce, re = x.length - 1, Ft = 0, Ot = x[0].a;
      for (N = 0; re > N; N++)
        ct = x[Ft], j = ct.a, J = ct.d, $ = x[Ft + 1].d, U ? (Et = l[N], Ct = o[N], ce = (Ct + Et) * M * 0.25 / (b ? 0.5 : p[N] || 0.5), It = J - (J - j) * (b ? 0.5 * M : Et !== 0 ? ce / Et : 0), et = J + ($ - J) * (b ? 0.5 * M : Ct !== 0 ? ce / Ct : 0), yt = J - (It + ((et - It) * (3 * Et / (Et + Ct) + 0.5) / 4 || 0))) : (It = J - (J - j) * M * 0.5, et = J + ($ - J) * M * 0.5, yt = J - (It + et) / 2), It += yt, et += yt, ct.c = G = It, N !== 0 ? ct.b = Ot : ct.b = Ot = ct.a + 0.6 * (ct.c - ct.a), ct.da = J - j, ct.ca = G - j, ct.ba = Ot - j, R ? (Pt = T(j, Ot, G, J), x.splice(Ft, 1, Pt[0], Pt[1], Pt[2], Pt[3]), Ft += 4) : Ft++, Ot = et;
      ct = x[Ft], ct.b = Ot, ct.c = Ot + 0.4 * (ct.d - Ot), ct.da = ct.d - ct.a, ct.ca = ct.c - ct.a, ct.ba = Ot - ct.a, R && (Pt = T(ct.a, Ot, ct.c, ct.d), x.splice(Ft, 1, Pt[0], Pt[1], Pt[2], Pt[3]));
    }, C = function(x, M, R, b) {
      var U, N, j, J, $, ct, It = [];
      if (b)
        for (x = [b].concat(x), N = x.length; --N > -1; )
          typeof (ct = x[N][M]) == "string" && ct.charAt(1) === "=" && (x[N][M] = b[M] + Number(ct.charAt(0) + ct.substr(2)));
      if (U = x.length - 2, 0 > U)
        return It[0] = new m(x[0][M], 0, 0, x[0][M]), It;
      for (N = 0; U > N; N++)
        j = x[N][M], J = x[N + 1][M], It[N] = new m(j, 0, 0, J), R && ($ = x[N + 2][M], l[N] = (l[N] || 0) + (J - j) * (J - j), o[N] = (o[N] || 0) + ($ - J) * ($ - J));
      return It[N] = new m(x[N][M], 0, 0, x[N + 1][M]), It;
    }, z = function(x, M, R, b, U, N) {
      var j, J, $, ct, It, et, yt, G, Pt = {}, Et = [], Ct = N || x[0];
      U = typeof U == "string" ? "," + U + "," : _, M == null && (M = 1);
      for (J in x[0])
        Et.push(J);
      if (x.length > 1) {
        for (G = x[x.length - 1], yt = !0, j = Et.length; --j > -1; )
          if (J = Et[j], Math.abs(Ct[J] - G[J]) > 0.05) {
            yt = !1;
            break;
          }
        yt && (x = x.concat(), N && x.unshift(N), x.push(x[1]), N = x[x.length - 3]);
      }
      for (l.length = o.length = p.length = 0, j = Et.length; --j > -1; )
        J = Et[j], d[J] = U.indexOf("," + J + ",") !== -1, Pt[J] = C(x, J, d[J], N);
      for (j = l.length; --j > -1; )
        l[j] = Math.sqrt(l[j]), o[j] = Math.sqrt(o[j]);
      if (!b) {
        for (j = Et.length; --j > -1; )
          if (d[J])
            for ($ = Pt[Et[j]], et = $.length - 1, ct = 0; et > ct; ct++)
              It = $[ct + 1].da / o[ct] + $[ct].da / l[ct] || 0, p[ct] = (p[ct] || 0) + It * It;
        for (j = p.length; --j > -1; )
          p[j] = Math.sqrt(p[j]);
      }
      for (j = Et.length, ct = R ? 4 : 1; --j > -1; )
        J = Et[j], $ = Pt[J], S($, M, R, b, d[J]), yt && ($.splice(0, ct), $.splice($.length - ct, ct));
      return Pt;
    }, B = function(x, M, R) {
      M = M || "soft";
      var b, U, N, j, J, $, ct, It, et, yt, G, Pt = {}, Et = M === "cubic" ? 3 : 2, Ct = M === "soft", ce = [];
      if (Ct && R && (x = [R].concat(x)), x == null || x.length < Et + 1)
        throw "invalid Bezier data";
      for (et in x[0])
        ce.push(et);
      for ($ = ce.length; --$ > -1; ) {
        for (et = ce[$], Pt[et] = J = [], yt = 0, It = x.length, ct = 0; It > ct; ct++)
          b = R == null ? x[ct][et] : typeof (G = x[ct][et]) == "string" && G.charAt(1) === "=" ? R[et] + Number(G.charAt(0) + G.substr(2)) : Number(G), Ct && ct > 1 && It - 1 > ct && (J[yt++] = (b + J[yt - 2]) / 2), J[yt++] = b;
        for (It = yt - Et + 1, yt = 0, ct = 0; It > ct; ct += Et)
          b = J[ct], U = J[ct + 1], N = J[ct + 2], j = Et === 2 ? 0 : J[ct + 3], J[yt++] = G = Et === 3 ? new m(b, U, N, j) : new m(b, (2 * U + b) / 3, (2 * U + N) / 3, N);
        J.length = yt;
      }
      return Pt;
    }, I = function(x, M, R) {
      for (var b, U, N, j, J, $, ct, It, et, yt, G, Pt = 1 / R, Et = x.length; --Et > -1; )
        for (yt = x[Et], N = yt.a, j = yt.d - N, J = yt.c - N, $ = yt.b - N, b = U = 0, It = 1; R >= It; It++)
          ct = Pt * It, et = 1 - ct, b = U - (U = (ct * ct * j + 3 * et * (ct * J + et * $)) * ct), G = Et * R + It - 1, M[G] = (M[G] || 0) + b * b;
    }, F = function(x, M) {
      M = M >> 0 || 6;
      var R, b, U, N, j = [], J = [], $ = 0, ct = 0, It = M - 1, et = [], yt = [];
      for (R in x)
        I(x[R], j, M);
      for (U = j.length, b = 0; U > b; b++)
        $ += Math.sqrt(j[b]), N = b % M, yt[N] = $, N === It && (ct += $, N = b / M >> 0, et[N] = yt, J[N] = ct, $ = 0, yt = []);
      return { length: ct, lengths: J, segments: et };
    }, E = hn._gsDefine.plugin({
      propName: "bezier",
      priority: -1,
      version: "1.3.8",
      API: 2,
      global: !0,
      init: function(x, M, R) {
        this._target = x, M instanceof Array && (M = { values: M }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = M.timeResolution == null ? 6 : parseInt(M.timeResolution, 10);
        var b, U, N, j, J, $ = M.values || [], ct = {}, It = $[0], et = M.autoRotate || R.vars.orientToBezier;
        this._autoRotate = et ? et instanceof Array ? et : [["x", "y", "rotation", et === !0 ? 0 : Number(et) || 0]] : null;
        for (b in It)
          this._props.push(b);
        for (N = this._props.length; --N > -1; )
          b = this._props[N], this._overwriteProps.push(b), U = this._func[b] = typeof x[b] == "function", ct[b] = U ? x[b.indexOf("set") || typeof x["get" + b.substr(3)] != "function" ? b : "get" + b.substr(3)]() : parseFloat(x[b]), J || ct[b] !== $[0][b] && (J = ct);
        if (this._beziers = M.type !== "cubic" && M.type !== "quadratic" && M.type !== "soft" ? z(
          $,
          isNaN(M.curviness) ? 1 : M.curviness,
          !1,
          M.type === "thruBasic",
          M.correlate,
          J
        ) : B($, M.type, ct), this._segCount = this._beziers[b].length, this._timeRes) {
          var yt = F(this._beziers, this._timeRes);
          this._length = yt.length, this._lengths = yt.lengths, this._segments = yt.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length;
        }
        if (et = this._autoRotate)
          for (this._initialRotations = [], et[0] instanceof Array || (this._autoRotate = et = [et]), N = et.length; --N > -1; ) {
            for (j = 0; 3 > j; j++)
              b = et[N][j], this._func[b] = typeof x[b] == "function" ? x[b.indexOf("set") || typeof x["get" + b.substr(3)] != "function" ? b : "get" + b.substr(3)] : !1;
            b = et[N][2], this._initialRotations[N] = (this._func[b] ? this._func[b].call(this._target) : this._target[b]) || 0, this._overwriteProps.push(b);
          }
        return this._startRatio = R.vars.runBackwards ? 1 : 0, !0;
      },
      set: function(x) {
        var M, R, b, U, N, j, J, $, ct, It, et = this._segCount, yt = this._func, G = this._target, Pt = x !== this._startRatio;
        if (this._timeRes) {
          if (ct = this._lengths, It = this._curSeg, x *= this._length, b = this._li, x > this._l2 && et - 1 > b) {
            for ($ = et - 1; $ > b && (this._l2 = ct[++b]) <= x; )
              ;
            this._l1 = ct[b - 1], this._li = b, this._curSeg = It = this._segments[b], this._s2 = It[this._s1 = this._si = 0];
          } else if (x < this._l1 && b > 0) {
            for (; b > 0 && (this._l1 = ct[--b]) >= x; )
              ;
            b === 0 && x < this._l1 ? this._l1 = 0 : b++, this._l2 = ct[b], this._li = b, this._curSeg = It = this._segments[b], this._s1 = It[(this._si = It.length - 1) - 1] || 0, this._s2 = It[this._si];
          }
          if (M = b, x -= this._l1, b = this._si, x > this._s2 && b < It.length - 1) {
            for ($ = It.length - 1; $ > b && (this._s2 = It[++b]) <= x; )
              ;
            this._s1 = It[b - 1], this._si = b;
          } else if (x < this._s1 && b > 0) {
            for (; b > 0 && (this._s1 = It[--b]) >= x; )
              ;
            b === 0 && x < this._s1 ? this._s1 = 0 : b++, this._s2 = It[b], this._si = b;
          }
          j = (b + (x - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
        } else
          M = 0 > x ? 0 : x >= 1 ? et - 1 : et * x >> 0, j = (x - M * (1 / et)) * et;
        for (R = 1 - j, b = this._props.length; --b > -1; )
          U = this._props[b], N = this._beziers[U][M], J = (j * j * N.da + 3 * R * (j * N.ca + R * N.ba)) * j + N.a, this._mod[U] && (J = this._mod[U](J, G)), yt[U] ? G[U](J) : G[U] = J;
        if (this._autoRotate) {
          var Et, Ct, ce, re, Ft, Ot, Bt, ke = this._autoRotate;
          for (b = ke.length; --b > -1; )
            U = ke[b][2], Ot = ke[b][3] || 0, Bt = ke[b][4] === !0 ? 1 : w, N = this._beziers[ke[b][0]], Et = this._beziers[ke[b][1]], N && Et && (N = N[M], Et = Et[M], Ct = N.a + (N.b - N.a) * j, re = N.b + (N.c - N.b) * j, Ct += (re - Ct) * j, re += (N.c + (N.d - N.c) * j - re) * j, ce = Et.a + (Et.b - Et.a) * j, Ft = Et.b + (Et.c - Et.b) * j, ce += (Ft - ce) * j, Ft += (Et.c + (Et.d - Et.c) * j - Ft) * j, J = Pt ? Math.atan2(Ft - ce, re - Ct) * Bt + Ot : this._initialRotations[b], this._mod[U] && (J = this._mod[U](J, G)), yt[U] ? G[U](J) : G[U] = J);
        }
      }
    }), L = E.prototype;
    E.bezierThrough = z, E.cubicToQuadratic = T, E._autoCSS = !0, E.quadraticToCubic = function(x, M, R) {
      return new m(x, (2 * M + x) / 3, (2 * M + R) / 3, R);
    }, E._cssRegister = function() {
      var x = u.CSSPlugin;
      if (x) {
        var M = x._internals, R = M._parseToProxy, b = M._setPluginRatio, U = M.CSSPropTween;
        M._registerComplexSpecialProp("bezier", {
          parser: function(N, j, J, $, ct, It) {
            j instanceof Array && (j = { values: j }), It = new E();
            var et, yt, G, Pt = j.values, Et = Pt.length - 1, Ct = [], ce = {};
            if (0 > Et)
              return ct;
            for (et = 0; Et >= et; et++)
              G = R(N, Pt[et], $, ct, It, Et !== et), Ct[et] = G.end;
            for (yt in j)
              ce[yt] = j[yt];
            return ce.values = Ct, ct = new U(N, "bezier", 0, 0, G.pt, 2), ct.data = G, ct.plugin = It, ct.setRatio = b, ce.autoRotate === 0 && (ce.autoRotate = !0), !ce.autoRotate || ce.autoRotate instanceof Array || (et = ce.autoRotate === !0 ? 0 : Number(ce.autoRotate), ce.autoRotate = G.end.left != null ? [["left", "top", "rotation", et, !1]] : G.end.x != null ? [["x", "y", "rotation", et, !1]] : !1), ce.autoRotate && ($._transform || $._enableTransforms(!1), G.autoRotate = $._target._gsTransform, G.proxy.rotation = G.autoRotate.rotation || 0, $._overwriteProps.push("rotation")), It._onInitTween(G.proxy, ce, $._tween), ct;
          }
        });
      }
    }, L._mod = function(x) {
      for (var M, R = this._overwriteProps, b = R.length; --b > -1; )
        M = x[R[b]], M && typeof M == "function" && (this._mod[R[b]] = M);
    }, L._kill = function(x) {
      var M, R, b = this._props;
      for (M in this._beziers)
        if (M in x)
          for (delete this._beziers[M], delete this._func[M], R = b.length; --R > -1; )
            b[R] === M && b.splice(R, 1);
      if (b = this._autoRotate)
        for (R = b.length; --R > -1; )
          x[b[R][2]] && b.splice(R, 1);
      return this._super._kill.call(this, x);
    };
  }(), hn._gsDefine(
    "plugins.CSSPlugin",
    ["plugins.TweenPlugin", "TweenLite"],
    function(w, l) {
      var o, p, d, u, m = function() {
        w.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = m.prototype.setRatio;
      }, _ = hn._gsDefine.globals, T = {}, S = m.prototype = new w("css");
      S.constructor = m, m.version = "2.0.2", m.API = 2, m.defaultTransformPerspective = 0, m.defaultSkewType = "compensated", m.defaultSmoothOrigin = !0, S = "px", m.suffixMap = {
        top: S,
        right: S,
        bottom: S,
        left: S,
        width: S,
        height: S,
        fontSize: S,
        padding: S,
        margin: S,
        perspective: S,
        lineHeight: ""
      };
      var C, z, B, I, F, E, L, x, M = /(?:\-|\.|\b)(\d|\.|e\-)+/g, R = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, U = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, N = /(?:\d|\-|\+|=|#|\.)*/g, j = /opacity *= *([^)]*)/i, J = /opacity:([^;]*)/i, $ = /alpha\(opacity *=.+?\)/i, ct = /^(rgb|hsl)/, It = /([A-Z])/g, et = /-([a-z])/gi, yt = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, G = function(V, tt) {
        return tt.toUpperCase();
      }, Pt = /(?:Left|Right|Width)/i, Et = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, Ct = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, ce = /,(?=[^\)]*(?:\(|$))/gi, re = /[\s,\(]/i, Ft = Math.PI / 180, Ot = 180 / Math.PI, Bt = {}, ke = { style: {} }, fe = hn.document || {
        createElement: function() {
          return ke;
        }
      }, Yt = function(V, tt) {
        return fe.createElementNS ? fe.createElementNS(tt || "http://www.w3.org/1999/xhtml", V) : fe.createElement(V);
      }, ti = Yt("div"), Ni = Yt("img"), Oe = m._internals = { _specialProps: T }, Ge = (hn.navigator || {}).userAgent || "", pi = function() {
        var V = Ge.indexOf("Android"), tt = Yt("a");
        return B = Ge.indexOf("Safari") !== -1 && Ge.indexOf("Chrome") === -1 && (V === -1 || parseFloat(Ge.substr(V + 8, 2)) > 3), F = B && parseFloat(Ge.substr(Ge.indexOf("Version/") + 8, 2)) < 6, I = Ge.indexOf("Firefox") !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Ge) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Ge)) && (E = parseFloat(RegExp.$1)), tt ? (tt.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(tt.style.opacity)) : !1;
      }(), Li = function(V) {
        return j.test(
          typeof V == "string" ? V : (V.currentStyle ? V.currentStyle.filter : V.style.filter) || ""
        ) ? parseFloat(RegExp.$1) / 100 : 1;
      }, cn = function(V) {
        hn.console && console.log(V);
      }, Ji = "", W = "", Jt = function(V, tt) {
        tt = tt || ti;
        var lt, at, X = tt.style;
        if (X[V] !== void 0)
          return V;
        for (V = V.charAt(0).toUpperCase() + V.substr(1), lt = ["O", "Moz", "ms", "Ms", "Webkit"], at = 5; --at > -1 && X[lt[at] + V] === void 0; )
          ;
        return at >= 0 ? (W = at === 3 ? "ms" : lt[at], Ji = "-" + W.toLowerCase() + "-", W + V) : null;
      }, Wt = (typeof window < "u" ? window : fe.defaultView || { getComputedStyle: function() {
      } }).getComputedStyle, pt = m.getStyle = function(V, tt, lt, at, X) {
        var St;
        return pi || tt !== "opacity" ? (!at && V.style[tt] ? St = V.style[tt] : (lt = lt || Wt(V)) ? St = lt[tt] || lt.getPropertyValue(tt) || lt.getPropertyValue(tt.replace(It, "-$1").toLowerCase()) : V.currentStyle && (St = V.currentStyle[tt]), X == null || St && St !== "none" && St !== "auto" && St !== "auto auto" ? St : X) : Li(V);
      }, dt = Oe.convertToPixels = function(V, tt, lt, at, X) {
        if (at === "px" || !at && tt !== "lineHeight")
          return lt;
        if (at === "auto" || !lt)
          return 0;
        var St, ht, Rt, Ht = Pt.test(tt), kt = V, Mt = ti.style, he = 0 > lt, oe = lt === 1;
        if (he && (lt = -lt), oe && (lt *= 100), tt !== "lineHeight" || at)
          if (at === "%" && tt.indexOf("border") !== -1)
            St = lt / 100 * (Ht ? V.clientWidth : V.clientHeight);
          else {
            if (Mt.cssText = "border:0 solid red;position:" + pt(V, "position") + ";line-height:0;", at !== "%" && kt.appendChild && at.charAt(0) !== "v" && at !== "rem")
              Mt[Ht ? "borderLeftWidth" : "borderTopWidth"] = lt + at;
            else {
              if (kt = V.parentNode || fe.body, pt(kt, "display").indexOf("flex") !== -1 && (Mt.position = "absolute"), ht = kt._gsCache, Rt = l.ticker.frame, ht && Ht && ht.time === Rt)
                return ht.width * lt / 100;
              Mt[Ht ? "width" : "height"] = lt + at;
            }
            kt.appendChild(ti), St = parseFloat(ti[Ht ? "offsetWidth" : "offsetHeight"]), kt.removeChild(ti), Ht && at === "%" && m.cacheWidths !== !1 && (ht = kt._gsCache = kt._gsCache || {}, ht.time = Rt, ht.width = St / lt * 100), St !== 0 || X || (St = dt(V, tt, lt, at, !0));
          }
        else
          ht = Wt(V).lineHeight, V.style.lineHeight = lt, St = parseFloat(Wt(V).lineHeight), V.style.lineHeight = ht;
        return oe && (St /= 100), he ? -St : St;
      }, Dt = Oe.calculateOffset = function(V, tt, lt) {
        if (pt(V, "position", lt) !== "absolute")
          return 0;
        var at = tt === "left" ? "Left" : "Top", X = pt(V, "margin" + at, lt);
        return V["offset" + at] - (dt(V, tt, parseFloat(X), X.replace(N, "")) || 0);
      }, ie = function(V, tt) {
        var lt, at, X, St = {};
        if (tt = tt || Wt(V, null))
          if (lt = tt.length)
            for (; --lt > -1; )
              X = tt[lt], (X.indexOf("-transform") === -1 || Xo === X) && (St[X.replace(et, G)] = tt.getPropertyValue(X));
          else
            for (lt in tt)
              (lt.indexOf("Transform") === -1 || xn === lt) && (St[lt] = tt[lt]);
        else if (tt = V.currentStyle || V.style)
          for (lt in tt)
            typeof lt == "string" && St[lt] === void 0 && (St[lt.replace(et, G)] = tt[lt]);
        return pi || (St.opacity = Li(V)), at = ss(V, tt, !1), St.rotation = at.rotation, St.skewX = at.skewX, St.scaleX = at.scaleX, St.scaleY = at.scaleY, St.x = at.x, St.y = at.y, dr && (St.z = at.z, St.rotationX = at.rotationX, St.rotationY = at.rotationY, St.scaleZ = at.scaleZ), St.filters && delete St.filters, St;
      }, Kt = function(V, tt, lt, at, X) {
        var St, ht, Rt, Ht = {}, kt = V.style;
        for (ht in lt)
          ht !== "cssText" && ht !== "length" && isNaN(ht) && (tt[ht] !== (St = lt[ht]) || X && X[ht]) && ht.indexOf("Origin") === -1 && (typeof St == "number" || typeof St == "string") && (Ht[ht] = St !== "auto" || ht !== "left" && ht !== "top" ? St !== "" && St !== "auto" && St !== "none" || typeof tt[ht] != "string" || tt[ht].replace(U, "") === "" ? St : 0 : Dt(V, ht), kt[ht] !== void 0 && (Rt = new ni(kt, ht, kt[ht], Rt)));
        if (at)
          for (ht in at)
            ht !== "className" && (Ht[ht] = at[ht]);
        return { difs: Ht, firstMPT: Rt };
      }, D = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, Q = ["marginLeft", "marginRight", "marginTop", "marginBottom"], ot = function(V, tt, lt) {
        if ((V.nodeName + "").toLowerCase() === "svg")
          return (lt || Wt(V))[tt] || 0;
        if (V.getCTM && ka(V))
          return V.getBBox()[tt] || 0;
        var at = parseFloat(tt === "width" ? V.offsetWidth : V.offsetHeight), X = D[tt], St = X.length;
        for (lt = lt || Wt(V, null); --St > -1; )
          at -= parseFloat(pt(V, "padding" + X[St], lt, !0)) || 0, at -= parseFloat(pt(V, "border" + X[St] + "Width", lt, !0)) || 0;
        return at;
      }, nt = function(V, tt) {
        if (V === "contain" || V === "auto" || V === "auto auto")
          return V + " ";
        (V == null || V === "") && (V = "0 0");
        var lt, at = V.split(" "), X = V.indexOf("left") !== -1 ? "0%" : V.indexOf("right") !== -1 ? "100%" : at[0], St = V.indexOf("top") !== -1 ? "0%" : V.indexOf("bottom") !== -1 ? "100%" : at[1];
        if (at.length > 3 && !tt) {
          for (at = V.split(", ").join(",").split(","), V = [], lt = 0; lt < at.length; lt++)
            V.push(nt(at[lt]));
          return V.join(",");
        }
        return St == null ? St = X === "center" ? "50%" : "0" : St === "center" && (St = "50%"), (X === "center" || isNaN(parseFloat(X)) && (X + "").indexOf("=") === -1) && (X = "50%"), V = X + " " + St + (at.length > 2 ? " " + at[2] : ""), tt && (tt.oxp = X.indexOf("%") !== -1, tt.oyp = St.indexOf("%") !== -1, tt.oxr = X.charAt(1) === "=", tt.oyr = St.charAt(1) === "=", tt.ox = parseFloat(X.replace(U, "")), tt.oy = parseFloat(St.replace(U, "")), tt.v = V), tt || V;
      }, vt = function(V, tt) {
        return typeof V == "function" && (V = V(x, L)), typeof V == "string" && V.charAt(1) === "=" ? parseInt(V.charAt(0) + "1", 10) * parseFloat(V.substr(2)) : parseFloat(V) - parseFloat(tt) || 0;
      }, Gt = function(V, tt) {
        typeof V == "function" && (V = V(x, L));
        var lt = typeof V == "string" && V.charAt(1) === "=";
        return typeof V == "string" && V.charAt(V.length - 2) === "v" && (V = (lt ? V.substr(0, 2) : 0) + window["inner" + (V.substr(-2) === "vh" ? "Height" : "Width")] * (parseFloat(lt ? V.substr(2) : V) / 100)), V == null ? tt : lt ? parseInt(V.charAt(0) + "1", 10) * parseFloat(V.substr(2)) + tt : parseFloat(V) || 0;
      }, Xt = function(V, tt, lt, at) {
        var X, St, ht, Rt, Ht, kt = 1e-6;
        return typeof V == "function" && (V = V(x, L)), V == null ? Rt = tt : typeof V == "number" ? Rt = V : (X = 360, St = V.split("_"), Ht = V.charAt(1) === "=", ht = (Ht ? parseInt(V.charAt(0) + "1", 10) * parseFloat(St[0].substr(2)) : parseFloat(St[0])) * (V.indexOf("rad") === -1 ? 1 : Ot) - (Ht ? 0 : tt), St.length && (at && (at[lt] = tt + ht), V.indexOf("short") !== -1 && (ht %= X, ht !== ht % (X / 2) && (ht = 0 > ht ? ht + X : ht - X)), V.indexOf("_cw") !== -1 && 0 > ht ? ht = (ht + 9999999999 * X) % X - (ht / X | 0) * X : V.indexOf("ccw") !== -1 && ht > 0 && (ht = (ht - 9999999999 * X) % X - (ht / X | 0) * X)), Rt = tt + ht), kt > Rt && Rt > -kt && (Rt = 0), Rt;
      }, jt = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      }, Ne = function(V, tt, lt) {
        return V = 0 > V ? V + 1 : V > 1 ? V - 1 : V, 255 * (1 > 6 * V ? tt + (lt - tt) * V * 6 : 0.5 > V ? lt : 2 > 3 * V ? tt + (lt - tt) * (2 / 3 - V) * 6 : tt) + 0.5 | 0;
      }, Re = m.parseColor = function(V, tt) {
        var lt, at, X, St, ht, Rt, Ht, kt, Mt, he, oe;
        if (V)
          if (typeof V == "number")
            lt = [V >> 16, V >> 8 & 255, 255 & V];
          else {
            if (V.charAt(V.length - 1) === "," && (V = V.substr(0, V.length - 1)), jt[V])
              lt = jt[V];
            else if (V.charAt(0) === "#")
              V.length === 4 && (at = V.charAt(1), X = V.charAt(2), St = V.charAt(3), V = "#" + at + at + X + X + St + St), V = parseInt(V.substr(1), 16), lt = [V >> 16, V >> 8 & 255, 255 & V];
            else if (V.substr(0, 3) === "hsl")
              if (lt = oe = V.match(M), tt) {
                if (V.indexOf("=") !== -1)
                  return V.match(R);
              } else
                ht = Number(lt[0]) % 360 / 360, Rt = Number(lt[1]) / 100, Ht = Number(lt[2]) / 100, X = 0.5 >= Ht ? Ht * (Rt + 1) : Ht + Rt - Ht * Rt, at = 2 * Ht - X, lt.length > 3 && (lt[3] = Number(lt[3])), lt[0] = Ne(ht + 1 / 3, at, X), lt[1] = Ne(ht, at, X), lt[2] = Ne(ht - 1 / 3, at, X);
            else
              lt = V.match(M) || jt.transparent;
            lt[0] = Number(lt[0]), lt[1] = Number(lt[1]), lt[2] = Number(lt[2]), lt.length > 3 && (lt[3] = Number(lt[3]));
          }
        else
          lt = jt.black;
        return tt && !oe && (at = lt[0] / 255, X = lt[1] / 255, St = lt[2] / 255, kt = Math.max(at, X, St), Mt = Math.min(at, X, St), Ht = (kt + Mt) / 2, kt === Mt ? ht = Rt = 0 : (he = kt - Mt, Rt = Ht > 0.5 ? he / (2 - kt - Mt) : he / (kt + Mt), ht = kt === at ? (X - St) / he + (St > X ? 6 : 0) : kt === X ? (St - at) / he + 2 : (at - X) / he + 4, ht *= 60), lt[0] = ht + 0.5 | 0, lt[1] = 100 * Rt + 0.5 | 0, lt[2] = 100 * Ht + 0.5 | 0), lt;
      }, ge = function(V, tt) {
        var lt, at, X, St = V.match(we) || [], ht = 0, Rt = "";
        if (!St.length)
          return V;
        for (lt = 0; lt < St.length; lt++)
          at = St[lt], X = V.substr(ht, V.indexOf(at, ht) - ht), ht += X.length + at.length, at = Re(at, tt), at.length === 3 && at.push(1), Rt += X + (tt ? "hsla(" + at[0] + "," + at[1] + "%," + at[2] + "%," + at[3] : "rgba(" + at.join(",")) + ")";
        return Rt + V.substr(ht);
      }, we = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
      for (S in jt)
        we += "|" + S + "\\b";
      we = new RegExp(we + ")", "gi"), m.colorStringFilter = function(V) {
        var tt, lt = V[0] + " " + V[1];
        we.test(lt) && (tt = lt.indexOf("hsl(") !== -1 || lt.indexOf("hsla(") !== -1, V[0] = ge(V[0], tt), V[1] = ge(V[1], tt)), we.lastIndex = 0;
      }, l.defaultStringFilter || (l.defaultStringFilter = m.colorStringFilter);
      var vi = function(V, tt, lt, at) {
        if (V == null)
          return function(oe) {
            return oe;
          };
        var X, St = tt ? (V.match(we) || [""])[0] : "", ht = V.split(St).join("").match(b) || [], Rt = V.substr(0, V.indexOf(ht[0])), Ht = V.charAt(V.length - 1) === ")" ? ")" : "", kt = V.indexOf(" ") !== -1 ? " " : ",", Mt = ht.length, he = Mt > 0 ? ht[0].replace(M, "") : "";
        return Mt ? X = tt ? function(oe) {
          var te, _e, ue, je;
          if (typeof oe == "number")
            oe += he;
          else if (at && ce.test(oe)) {
            for (je = oe.replace(ce, "|").split("|"), ue = 0; ue < je.length; ue++)
              je[ue] = X(je[ue]);
            return je.join(",");
          }
          if (te = (oe.match(we) || [St])[0], _e = oe.split(te).join("").match(b) || [], ue = _e.length, Mt > ue--)
            for (; ++ue < Mt; )
              _e[ue] = lt ? _e[(ue - 1) / 2 | 0] : ht[ue];
          return Rt + _e.join(kt) + kt + te + Ht + (oe.indexOf("inset") !== -1 ? " inset" : "");
        } : function(oe) {
          var te, _e, ue;
          if (typeof oe == "number")
            oe += he;
          else if (at && ce.test(oe)) {
            for (_e = oe.replace(ce, "|").split("|"), ue = 0; ue < _e.length; ue++)
              _e[ue] = X(_e[ue]);
            return _e.join(",");
          }
          if (te = oe.match(b) || [], ue = te.length, Mt > ue--)
            for (; ++ue < Mt; )
              te[ue] = lt ? te[(ue - 1) / 2 | 0] : ht[ue];
          return Rt + te.join(kt) + Ht;
        } : function(oe) {
          return oe;
        };
      }, Mi = function(V) {
        return V = V.split(","), function(tt, lt, at, X, St, ht, Rt) {
          var Ht, kt = (lt + "").split(" ");
          for (Rt = {}, Ht = 0; 4 > Ht; Ht++)
            Rt[V[Ht]] = kt[Ht] = kt[Ht] || kt[(Ht - 1) / 2 >> 0];
          return X.parse(tt, Rt, St, ht);
        };
      }, ni = (Oe._setPluginRatio = function(V) {
        this.plugin.setRatio(V);
        for (var tt, lt, at, X, St, ht = this.data, Rt = ht.proxy, Ht = ht.firstMPT, kt = 1e-6; Ht; )
          tt = Rt[Ht.v], Ht.r ? tt = Ht.r(tt) : kt > tt && tt > -kt && (tt = 0), Ht.t[Ht.p] = tt, Ht = Ht._next;
        if (ht.autoRotate && (ht.autoRotate.rotation = ht.mod ? ht.mod.call(this._tween, Rt.rotation, this.t, this._tween) : Rt.rotation), V === 1 || V === 0)
          for (Ht = ht.firstMPT, St = V === 1 ? "e" : "b"; Ht; ) {
            if (lt = Ht.t, lt.type) {
              if (lt.type === 1) {
                for (X = lt.xs0 + lt.s + lt.xs1, at = 1; at < lt.l; at++)
                  X += lt["xn" + at] + lt["xs" + (at + 1)];
                lt[St] = X;
              }
            } else
              lt[St] = lt.s + lt.xs0;
            Ht = Ht._next;
          }
      }, function(V, tt, lt, at, X) {
        this.t = V, this.p = tt, this.v = lt, this.r = X, at && (at._prev = this, this._next = at);
      }), Si = (Oe._parseToProxy = function(V, tt, lt, at, X, St) {
        var ht, Rt, Ht, kt, Mt, he = at, oe = {}, te = {}, _e = lt._transform, ue = Bt;
        for (lt._transform = null, Bt = tt, at = Mt = lt.parse(V, tt, at, X), Bt = ue, St && (lt._transform = _e, he && (he._prev = null, he._prev && (he._prev._next = null))); at && at !== he; ) {
          if (at.type <= 1 && (Rt = at.p, te[Rt] = at.s + at.c, oe[Rt] = at.s, St || (kt = new ni(at, "s", Rt, kt, at.r), at.c = 0), at.type === 1))
            for (ht = at.l; --ht > 0; )
              Ht = "xn" + ht, Rt = at.p + "_" + Ht, te[Rt] = at.data[Ht], oe[Rt] = at[Ht], St || (kt = new ni(at, Ht, Rt, kt, at.rxp[Ht]));
          at = at._next;
        }
        return { proxy: oe, end: te, firstMPT: kt, pt: Mt };
      }, Oe.CSSPropTween = function(V, tt, lt, at, X, St, ht, Rt, Ht, kt, Mt) {
        this.t = V, this.p = tt, this.s = lt, this.c = at, this.n = ht || tt, V instanceof Si || u.push(this.n), this.r = Rt && (typeof Rt == "function" ? Rt : Math.round), this.type = St || 0, Ht && (this.pr = Ht, o = !0), this.b = kt === void 0 ? lt : kt, this.e = Mt === void 0 ? lt + at : Mt, X && (this._next = X, X._prev = this);
      }), Gr = function(V, tt, lt, at, X, St) {
        var ht = new Si(V, tt, lt, at - lt, X, -1, St);
        return ht.b = lt, ht.e = ht.xs0 = at, ht;
      }, er = m.parseComplex = function(V, tt, lt, at, X, St, ht, Rt, Ht, kt) {
        lt = lt || St || "", typeof at == "function" && (at = at(x, L)), ht = new Si(V, tt, 0, 0, ht, kt ? 2 : 1, null, !1, Rt, lt, at), at += "", X && we.test(at + lt) && (at = [lt, at], m.colorStringFilter(at), lt = at[0], at = at[1]);
        var Mt, he, oe, te, _e, ue, je, He, ui, Be, ye, Fe, pe, di = lt.split(", ").join(",").split(" "), Pe = at.split(", ").join(",").split(" "), xe = di.length, Le = C !== !1;
        for ((at.indexOf(",") !== -1 || lt.indexOf(",") !== -1) && ((at + lt).indexOf("rgb") !== -1 || (at + lt).indexOf("hsl") !== -1 ? (di = di.join(" ").replace(ce, ", ").split(" "), Pe = Pe.join(" ").replace(ce, ", ").split(" ")) : (di = di.join(" ").split(",").join(", ").split(" "), Pe = Pe.join(" ").split(",").join(", ").split(" ")), xe = di.length), xe !== Pe.length && (di = (St || "").split(" "), xe = di.length), ht.plugin = Ht, ht.setRatio = kt, we.lastIndex = 0, Mt = 0; xe > Mt; Mt++)
          if (te = di[Mt], _e = Pe[Mt] + "", He = parseFloat(te), He || He === 0)
            ht.appendXtra(
              "",
              He,
              vt(_e, He),
              _e.replace(R, ""),
              Le && _e.indexOf("px") !== -1 ? Math.round : !1,
              !0
            );
          else if (X && we.test(te))
            Fe = _e.indexOf(")") + 1, Fe = ")" + (Fe ? _e.substr(Fe) : ""), pe = _e.indexOf("hsl") !== -1 && pi, Be = _e, te = Re(te, pe), _e = Re(_e, pe), ui = te.length + _e.length > 6, ui && !pi && _e[3] === 0 ? (ht["xs" + ht.l] += ht.l ? " transparent" : "transparent", ht.e = ht.e.split(Pe[Mt]).join("transparent")) : (pi || (ui = !1), pe ? ht.appendXtra(
              Be.substr(0, Be.indexOf("hsl")) + (ui ? "hsla(" : "hsl("),
              te[0],
              vt(_e[0], te[0]),
              ",",
              !1,
              !0
            ).appendXtra("", te[1], vt(_e[1], te[1]), "%,", !1).appendXtra(
              "",
              te[2],
              vt(_e[2], te[2]),
              ui ? "%," : "%" + Fe,
              !1
            ) : ht.appendXtra(
              Be.substr(0, Be.indexOf("rgb")) + (ui ? "rgba(" : "rgb("),
              te[0],
              _e[0] - te[0],
              ",",
              Math.round,
              !0
            ).appendXtra("", te[1], _e[1] - te[1], ",", Math.round).appendXtra(
              "",
              te[2],
              _e[2] - te[2],
              ui ? "," : Fe,
              Math.round
            ), ui && (te = te.length < 4 ? 1 : te[3], ht.appendXtra(
              "",
              te,
              (_e.length < 4 ? 1 : _e[3]) - te,
              Fe,
              !1
            ))), we.lastIndex = 0;
          else if (ue = te.match(M)) {
            if (je = _e.match(R), !je || je.length !== ue.length)
              return ht;
            for (oe = 0, he = 0; he < ue.length; he++)
              ye = ue[he], Be = te.indexOf(ye, oe), ht.appendXtra(
                te.substr(oe, Be - oe),
                Number(ye),
                vt(je[he], ye),
                "",
                Le && te.substr(Be + ye.length, 2) === "px" ? Math.round : !1,
                he === 0
              ), oe = Be + ye.length;
            ht["xs" + ht.l] += te.substr(oe);
          } else
            ht["xs" + ht.l] += ht.l || ht["xs" + ht.l] ? " " + _e : _e;
        if (at.indexOf("=") !== -1 && ht.data) {
          for (Fe = ht.xs0 + ht.data.s, Mt = 1; Mt < ht.l; Mt++)
            Fe += ht["xs" + Mt] + ht.data["xn" + Mt];
          ht.e = Fe + ht["xs" + Mt];
        }
        return ht.l || (ht.type = -1, ht.xs0 = ht.e), ht.xfirst || ht;
      }, rn = 9;
      for (S = Si.prototype, S.l = S.pr = 0; --rn > 0; )
        S["xn" + rn] = 0, S["xs" + rn] = "";
      S.xs0 = "", S._next = S._prev = S.xfirst = S.data = S.plugin = S.setRatio = S.rxp = null, S.appendXtra = function(V, tt, lt, at, X, St) {
        var ht = this, Rt = ht.l;
        return ht["xs" + Rt] += St && (Rt || ht["xs" + Rt]) ? " " + V : V || "", lt || Rt === 0 || ht.plugin ? (ht.l++, ht.type = ht.setRatio ? 2 : 1, ht["xs" + ht.l] = at || "", Rt > 0 ? (ht.data["xn" + Rt] = tt + lt, ht.rxp["xn" + Rt] = X, ht["xn" + Rt] = tt, ht.plugin || (ht.xfirst = new Si(
          ht,
          "xn" + Rt,
          tt,
          lt,
          ht.xfirst || ht,
          0,
          ht.n,
          X,
          ht.pr
        ), ht.xfirst.xs0 = 0), ht) : (ht.data = { s: tt + lt }, ht.rxp = {}, ht.s = tt, ht.c = lt, ht.r = X, ht)) : (ht["xs" + Rt] += tt + (at || ""), ht);
      };
      var bs = function(V, tt) {
        tt = tt || {}, this.p = tt.prefix && Jt(V) || V, T[V] = T[this.p] = this, this.format = tt.formatter || vi(tt.defaultValue, tt.color, tt.collapsible, tt.multi), tt.parser && (this.parse = tt.parser), this.clrs = tt.color, this.multi = tt.multi, this.keyword = tt.keyword, this.dflt = tt.defaultValue, this.pr = tt.priority || 0;
      }, Ri = Oe._registerComplexSpecialProp = function(V, tt, lt) {
        typeof tt != "object" && (tt = { parser: lt });
        var at, X = V.split(","), St = tt.defaultValue;
        for (lt = lt || [St], at = 0; at < X.length; at++)
          tt.prefix = at === 0 && tt.prefix, tt.defaultValue = lt[at] || St, new bs(X[at], tt);
      }, Us = Oe._registerPluginProp = function(V) {
        if (!T[V]) {
          var tt = V.charAt(0).toUpperCase() + V.substr(1) + "Plugin";
          Ri(V, {
            parser: function(lt, at, X, St, ht, Rt, Ht) {
              var kt = _.com.greensock.plugins[tt];
              return kt ? (kt._cssRegister(), T[X].parse(lt, at, X, St, ht, Rt, Ht)) : (cn("Error: " + tt + " js file not loaded."), ht);
            }
          });
        }
      };
      S = bs.prototype, S.parseComplex = function(V, tt, lt, at, X, St) {
        var ht, Rt, Ht, kt, Mt, he, oe = this.keyword;
        if (this.multi && (ce.test(lt) || ce.test(tt) ? (Rt = tt.replace(ce, "|").split("|"), Ht = lt.replace(ce, "|").split("|")) : oe && (Rt = [tt], Ht = [lt])), Ht) {
          for (kt = Ht.length > Rt.length ? Ht.length : Rt.length, ht = 0; kt > ht; ht++)
            tt = Rt[ht] = Rt[ht] || this.dflt, lt = Ht[ht] = Ht[ht] || this.dflt, oe && (Mt = tt.indexOf(oe), he = lt.indexOf(oe), Mt !== he && (he === -1 ? Rt[ht] = Rt[ht].split(oe).join("") : Mt === -1 && (Rt[ht] += " " + oe)));
          tt = Rt.join(", "), lt = Ht.join(", ");
        }
        return er(V, this.p, tt, lt, this.clrs, this.dflt, at, this.pr, X, St);
      }, S.parse = function(V, tt, lt, at, X, St, ht) {
        return this.parseComplex(
          V.style,
          this.format(pt(V, this.p, d, !1, this.dflt)),
          this.format(tt),
          X,
          St
        );
      }, m.registerSpecialProp = function(V, tt, lt) {
        Ri(V, {
          parser: function(at, X, St, ht, Rt, Ht, kt) {
            var Mt = new Si(at, St, 0, 0, Rt, 2, St, !1, lt);
            return Mt.plugin = Ht, Mt.setRatio = tt(at, X, ht._tween, St), Mt;
          },
          priority: lt
        });
      }, m.useSVGTransformAttr = !0;
      var is, bl = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(
        ","
      ), xn = Jt("transform"), Xo = Ji + "transform", ho = Jt("transformOrigin"), dr = Jt("perspective") !== null, qo = Oe.Transform = function() {
        this.perspective = parseFloat(m.defaultTransformPerspective) || 0, this.force3D = m.defaultForce3D !== !1 && dr ? m.defaultForce3D || "auto" : !1;
      }, Da = hn.SVGElement, Al = function(V, tt, lt) {
        var at, X = fe.createElementNS("http://www.w3.org/2000/svg", V), St = /([a-z])([A-Z])/g;
        for (at in lt)
          X.setAttributeNS(null, at.replace(St, "$1-$2").toLowerCase(), lt[at]);
        return tt.appendChild(X), X;
      }, ns = fe.documentElement || {}, ch = function() {
        var V, tt, lt, at = E || /Android/i.test(Ge) && !hn.chrome;
        return fe.createElementNS && !at && (V = Al("svg", ns), tt = Al("rect", V, { width: 100, height: 50, x: 100 }), lt = tt.getBoundingClientRect().width, tt.style[ho] = "50% 50%", tt.style[xn] = "scaleX(0.5)", at = lt === tt.getBoundingClientRect().width && !(I && dr), ns.removeChild(V)), at;
      }(), Yo = function(V, tt, lt, at, X, St) {
        var ht, Rt, Ht, kt, Mt, he, oe, te, _e, ue, je, He, ui, Be, ye = V._gsTransform, Fe = Jo(V, !0);
        ye && (ui = ye.xOrigin, Be = ye.yOrigin), (!at || (ht = at.split(" ")).length < 2) && (oe = V.getBBox(), oe.x === 0 && oe.y === 0 && oe.width + oe.height === 0 && (oe = {
          x: parseFloat(
            V.hasAttribute("x") ? V.getAttribute("x") : V.hasAttribute("cx") ? V.getAttribute("cx") : 0
          ) || 0,
          y: parseFloat(
            V.hasAttribute("y") ? V.getAttribute("y") : V.hasAttribute("cy") ? V.getAttribute("cy") : 0
          ) || 0,
          width: 0,
          height: 0
        }), tt = nt(tt).split(" "), ht = [
          (tt[0].indexOf("%") !== -1 ? parseFloat(tt[0]) / 100 * oe.width : parseFloat(tt[0])) + oe.x,
          (tt[1].indexOf("%") !== -1 ? parseFloat(tt[1]) / 100 * oe.height : parseFloat(tt[1])) + oe.y
        ]), lt.xOrigin = kt = parseFloat(ht[0]), lt.yOrigin = Mt = parseFloat(ht[1]), at && Fe !== Zo && (he = Fe[0], oe = Fe[1], te = Fe[2], _e = Fe[3], ue = Fe[4], je = Fe[5], He = he * _e - oe * te, He && (Rt = kt * (_e / He) + Mt * (-te / He) + (te * je - _e * ue) / He, Ht = kt * (-oe / He) + Mt * (he / He) - (he * je - oe * ue) / He, kt = lt.xOrigin = ht[0] = Rt, Mt = lt.yOrigin = ht[1] = Ht)), ye && (St && (lt.xOffset = ye.xOffset, lt.yOffset = ye.yOffset, ye = lt), X || X !== !1 && m.defaultSmoothOrigin !== !1 ? (Rt = kt - ui, Ht = Mt - Be, ye.xOffset += Rt * Fe[0] + Ht * Fe[2] - Rt, ye.yOffset += Rt * Fe[1] + Ht * Fe[3] - Ht) : ye.xOffset = ye.yOffset = 0), St || V.setAttribute("data-svg-origin", ht.join(" "));
      }, za = function(V) {
        var tt, lt = Yt(
          "svg",
          this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"
        ), at = this.parentNode, X = this.nextSibling, St = this.style.cssText;
        if (ns.appendChild(lt), lt.appendChild(this), this.style.display = "block", V)
          try {
            tt = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = za;
          } catch {
          }
        else
          this._originalGetBBox && (tt = this._originalGetBBox());
        return X ? at.insertBefore(this, X) : at.appendChild(this), ns.removeChild(lt), this.style.cssText = St, tt;
      }, rs = function(V) {
        try {
          return V.getBBox();
        } catch {
          return za.call(V, !0);
        }
      }, ka = function(V) {
        return !(!Da || !V.getCTM || V.parentNode && !V.ownerSVGElement || !rs(V));
      }, Zo = [1, 0, 0, 1, 0, 0], Jo = function(V, tt) {
        var lt, at, X, St, ht, Rt, Ht = V._gsTransform || new qo(), kt = 1e5, Mt = V.style;
        if (xn ? at = pt(V, Xo, null, !0) : V.currentStyle && (at = V.currentStyle.filter.match(Et), at = at && at.length === 4 ? [
          at[0].substr(4),
          Number(at[2].substr(4)),
          Number(at[1].substr(4)),
          at[3].substr(4),
          Ht.x || 0,
          Ht.y || 0
        ].join(",") : ""), lt = !at || at === "none" || at === "matrix(1, 0, 0, 1, 0, 0)", !xn || !(Rt = !Wt(V) || Wt(V).display === "none") && V.parentNode || (Rt && (St = Mt.display, Mt.display = "block"), V.parentNode || (ht = 1, ns.appendChild(V)), at = pt(V, Xo, null, !0), lt = !at || at === "none" || at === "matrix(1, 0, 0, 1, 0, 0)", St ? Mt.display = St : Rt && uo(Mt, "display"), ht && ns.removeChild(V)), (Ht.svg || V.getCTM && ka(V)) && (lt && (Mt[xn] + "").indexOf("matrix") !== -1 && (at = Mt[xn], lt = 0), X = V.getAttribute("transform"), lt && X && (X = V.transform.baseVal.consolidate().matrix, at = "matrix(" + X.a + "," + X.b + "," + X.c + "," + X.d + "," + X.e + "," + X.f + ")", lt = 0)), lt)
          return Zo;
        for (X = (at || "").match(M) || [], rn = X.length; --rn > -1; )
          St = Number(X[rn]), X[rn] = (ht = St - (St |= 0)) ? (ht * kt + (0 > ht ? -0.5 : 0.5) | 0) / kt + St : St;
        return tt && X.length > 6 ? [X[0], X[1], X[4], X[5], X[12], X[13]] : X;
      }, ss = Oe.getTransform = function(V, tt, lt, at) {
        if (V._gsTransform && lt && !at)
          return V._gsTransform;
        var X, St, ht, Rt, Ht, kt, Mt = lt ? V._gsTransform || new qo() : new qo(), he = Mt.scaleX < 0, oe = 2e-5, te = 1e5, _e = dr && (parseFloat(pt(V, ho, tt, !1, "0 0 0").split(" ")[2]) || Mt.zOrigin) || 0, ue = parseFloat(m.defaultTransformPerspective) || 0;
        if (Mt.svg = !(!V.getCTM || !ka(V)), Mt.svg && (Yo(
          V,
          pt(V, ho, tt, !1, "50% 50%") + "",
          Mt,
          V.getAttribute("data-svg-origin")
        ), is = m.useSVGTransformAttr || ch), X = Jo(V), X !== Zo) {
          if (X.length === 16) {
            var je, He, ui, Be, ye, Fe = X[0], pe = X[1], di = X[2], Pe = X[3], xe = X[4], Le = X[5], wn = X[6], Hn = X[7], Oi = X[8], Ii = X[9], Ui = X[10], Qi = X[12], tn = X[13], on = X[14], an = X[11], Fi = Math.atan2(wn, Ui);
            Mt.zOrigin && (on = -Mt.zOrigin, Qi = Oi * on - X[12], tn = Ii * on - X[13], on = Ui * on + Mt.zOrigin - X[14]), Mt.rotationX = Fi * Ot, Fi && (Be = Math.cos(-Fi), ye = Math.sin(-Fi), je = xe * Be + Oi * ye, He = Le * Be + Ii * ye, ui = wn * Be + Ui * ye, Oi = xe * -ye + Oi * Be, Ii = Le * -ye + Ii * Be, Ui = wn * -ye + Ui * Be, an = Hn * -ye + an * Be, xe = je, Le = He, wn = ui), Fi = Math.atan2(-di, Ui), Mt.rotationY = Fi * Ot, Fi && (Be = Math.cos(-Fi), ye = Math.sin(-Fi), je = Fe * Be - Oi * ye, He = pe * Be - Ii * ye, ui = di * Be - Ui * ye, Ii = pe * ye + Ii * Be, Ui = di * ye + Ui * Be, an = Pe * ye + an * Be, Fe = je, pe = He, di = ui), Fi = Math.atan2(pe, Fe), Mt.rotation = Fi * Ot, Fi && (Be = Math.cos(Fi), ye = Math.sin(Fi), je = Fe * Be + pe * ye, He = xe * Be + Le * ye, ui = Oi * Be + Ii * ye, pe = pe * Be - Fe * ye, Le = Le * Be - xe * ye, Ii = Ii * Be - Oi * ye, Fe = je, xe = He, Oi = ui), Mt.rotationX && Math.abs(Mt.rotationX) + Math.abs(Mt.rotation) > 359.9 && (Mt.rotationX = Mt.rotation = 0, Mt.rotationY = 180 - Mt.rotationY), Fi = Math.atan2(xe, Le), Mt.scaleX = (Math.sqrt(Fe * Fe + pe * pe + di * di) * te + 0.5 | 0) / te, Mt.scaleY = (Math.sqrt(Le * Le + wn * wn) * te + 0.5 | 0) / te, Mt.scaleZ = (Math.sqrt(Oi * Oi + Ii * Ii + Ui * Ui) * te + 0.5 | 0) / te, Fe /= Mt.scaleX, xe /= Mt.scaleY, pe /= Mt.scaleX, Le /= Mt.scaleY, Math.abs(Fi) > oe ? (Mt.skewX = Fi * Ot, xe = 0, Mt.skewType !== "simple" && (Mt.scaleY *= 1 / Math.cos(Fi))) : Mt.skewX = 0, Mt.perspective = an ? 1 / (0 > an ? -an : an) : 0, Mt.x = Qi, Mt.y = tn, Mt.z = on, Mt.svg && (Mt.x -= Mt.xOrigin - (Mt.xOrigin * Fe - Mt.yOrigin * xe), Mt.y -= Mt.yOrigin - (Mt.yOrigin * pe - Mt.xOrigin * Le));
          } else if (!dr || at || !X.length || Mt.x !== X[4] || Mt.y !== X[5] || !Mt.rotationX && !Mt.rotationY) {
            var Di = X.length >= 6, Vi = Di ? X[0] : 1, mi = X[1] || 0, os = X[2] || 0, Bn = Di ? X[3] : 1;
            Mt.x = X[4] || 0, Mt.y = X[5] || 0, ht = Math.sqrt(Vi * Vi + mi * mi), Rt = Math.sqrt(Bn * Bn + os * os), Ht = Vi || mi ? Math.atan2(mi, Vi) * Ot : Mt.rotation || 0, kt = os || Bn ? Math.atan2(os, Bn) * Ot + Ht : Mt.skewX || 0, Mt.scaleX = ht, Mt.scaleY = Rt, Mt.rotation = Ht, Mt.skewX = kt, dr && (Mt.rotationX = Mt.rotationY = Mt.z = 0, Mt.perspective = ue, Mt.scaleZ = 1), Mt.svg && (Mt.x -= Mt.xOrigin - (Mt.xOrigin * Vi + Mt.yOrigin * os), Mt.y -= Mt.yOrigin - (Mt.xOrigin * mi + Mt.yOrigin * Bn));
          }
          Math.abs(Mt.skewX) > 90 && Math.abs(Mt.skewX) < 270 && (he ? (Mt.scaleX *= -1, Mt.skewX += Mt.rotation <= 0 ? 180 : -180, Mt.rotation += Mt.rotation <= 0 ? 180 : -180) : (Mt.scaleY *= -1, Mt.skewX += Mt.skewX <= 0 ? 180 : -180)), Mt.zOrigin = _e;
          for (St in Mt)
            Mt[St] < oe && Mt[St] > -oe && (Mt[St] = 0);
        }
        return lt && (V._gsTransform = Mt, Mt.svg && (is && V.style[xn] ? l.delayedCall(1e-3, function() {
          uo(V.style, xn);
        }) : !is && V.getAttribute("transform") && l.delayedCall(1e-3, function() {
          V.removeAttribute("transform");
        }))), Mt;
      }, Cl = function(V) {
        var tt, lt, at = this.data, X = -at.rotation * Ft, St = X + at.skewX * Ft, ht = 1e5, Rt = (Math.cos(X) * at.scaleX * ht | 0) / ht, Ht = (Math.sin(X) * at.scaleX * ht | 0) / ht, kt = (Math.sin(St) * -at.scaleY * ht | 0) / ht, Mt = (Math.cos(St) * at.scaleY * ht | 0) / ht, he = this.t.style, oe = this.t.currentStyle;
        if (oe) {
          lt = Ht, Ht = -kt, kt = -lt, tt = oe.filter, he.filter = "";
          var te, _e, ue = this.t.offsetWidth, je = this.t.offsetHeight, He = oe.position !== "absolute", ui = "progid:DXImageTransform.Microsoft.Matrix(M11=" + Rt + ", M12=" + Ht + ", M21=" + kt + ", M22=" + Mt, Be = at.x + ue * at.xPercent / 100, ye = at.y + je * at.yPercent / 100;
          if (at.ox != null && (te = (at.oxp ? ue * at.ox * 0.01 : at.ox) - ue / 2, _e = (at.oyp ? je * at.oy * 0.01 : at.oy) - je / 2, Be += te - (te * Rt + _e * Ht), ye += _e - (te * kt + _e * Mt)), He ? (te = ue / 2, _e = je / 2, ui += ", Dx=" + (te - (te * Rt + _e * Ht) + Be) + ", Dy=" + (_e - (te * kt + _e * Mt) + ye) + ")") : ui += ", sizingMethod='auto expand')", tt.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? he.filter = tt.replace(Ct, ui) : he.filter = ui + " " + tt, (V === 0 || V === 1) && Rt === 1 && Ht === 0 && kt === 0 && Mt === 1 && (He && ui.indexOf("Dx=0, Dy=0") === -1 || j.test(tt) && parseFloat(RegExp.$1) !== 100 || tt.indexOf(tt.indexOf("Alpha")) === -1 && he.removeAttribute("filter")), !He) {
            var Fe, pe, di, Pe = 8 > E ? 1 : -1;
            for (te = at.ieOffsetX || 0, _e = at.ieOffsetY || 0, at.ieOffsetX = Math.round(
              (ue - ((0 > Rt ? -Rt : Rt) * ue + (0 > Ht ? -Ht : Ht) * je)) / 2 + Be
            ), at.ieOffsetY = Math.round(
              (je - ((0 > Mt ? -Mt : Mt) * je + (0 > kt ? -kt : kt) * ue)) / 2 + ye
            ), rn = 0; 4 > rn; rn++)
              pe = Q[rn], Fe = oe[pe], lt = Fe.indexOf("px") !== -1 ? parseFloat(Fe) : dt(this.t, pe, parseFloat(Fe), Fe.replace(N, "")) || 0, di = lt !== at[pe] ? 2 > rn ? -at.ieOffsetX : -at.ieOffsetY : 2 > rn ? te - at.ieOffsetX : _e - at.ieOffsetY, he[pe] = (at[pe] = Math.round(
                lt - di * (rn === 0 || rn === 2 ? 1 : Pe)
              )) + "px";
          }
        }
      }, fh = Oe.set3DTransformRatio = Oe.setTransformRatio = function(V) {
        var tt, lt, at, X, St, ht, Rt, Ht, kt, Mt, he, oe, te, _e, ue, je, He, ui, Be, ye, Fe, pe, di, Pe = this.data, xe = this.t.style, Le = Pe.rotation, wn = Pe.rotationX, Hn = Pe.rotationY, Oi = Pe.scaleX, Ii = Pe.scaleY, Ui = Pe.scaleZ, Qi = Pe.x, tn = Pe.y, on = Pe.z, an = Pe.svg, Fi = Pe.perspective, Di = Pe.force3D, Vi = Pe.skewY, mi = Pe.skewX;
        if (Vi && (mi += Vi, Le += Vi), ((V === 1 || V === 0) && Di === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !Di) && !on && !Fi && !Hn && !wn && Ui === 1 || is && an || !dr)
          return void (Le || mi || an ? (Le *= Ft, pe = mi * Ft, di = 1e5, lt = Math.cos(Le) * Oi, St = Math.sin(Le) * Oi, at = Math.sin(Le - pe) * -Ii, ht = Math.cos(Le - pe) * Ii, pe && Pe.skewType === "simple" && (tt = Math.tan(pe - Vi * Ft), tt = Math.sqrt(1 + tt * tt), at *= tt, ht *= tt, Vi && (tt = Math.tan(Vi * Ft), tt = Math.sqrt(1 + tt * tt), lt *= tt, St *= tt)), an && (Qi += Pe.xOrigin - (Pe.xOrigin * lt + Pe.yOrigin * at) + Pe.xOffset, tn += Pe.yOrigin - (Pe.xOrigin * St + Pe.yOrigin * ht) + Pe.yOffset, is && (Pe.xPercent || Pe.yPercent) && (ue = this.t.getBBox(), Qi += 0.01 * Pe.xPercent * ue.width, tn += 0.01 * Pe.yPercent * ue.height), ue = 1e-6, ue > Qi && Qi > -ue && (Qi = 0), ue > tn && tn > -ue && (tn = 0)), Be = (lt * di | 0) / di + "," + (St * di | 0) / di + "," + (at * di | 0) / di + "," + (ht * di | 0) / di + "," + Qi + "," + tn + ")", an && is ? this.t.setAttribute("transform", "matrix(" + Be) : xe[xn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix(" : "matrix(") + Be) : xe[xn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix(" : "matrix(") + Oi + ",0,0," + Ii + "," + Qi + "," + tn + ")");
        if (I && (ue = 1e-4, ue > Oi && Oi > -ue && (Oi = Ui = 2e-5), ue > Ii && Ii > -ue && (Ii = Ui = 2e-5), !Fi || Pe.z || Pe.rotationX || Pe.rotationY || (Fi = 0)), Le || mi)
          Le *= Ft, je = lt = Math.cos(Le), He = St = Math.sin(Le), mi && (Le -= mi * Ft, je = Math.cos(Le), He = Math.sin(Le), Pe.skewType === "simple" && (tt = Math.tan((mi - Vi) * Ft), tt = Math.sqrt(1 + tt * tt), je *= tt, He *= tt, Pe.skewY && (tt = Math.tan(Vi * Ft), tt = Math.sqrt(1 + tt * tt), lt *= tt, St *= tt))), at = -He, ht = je;
        else {
          if (!(Hn || wn || Ui !== 1 || Fi || an))
            return void (xe[xn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) translate3d(" : "translate3d(") + Qi + "px," + tn + "px," + on + "px)" + (Oi !== 1 || Ii !== 1 ? " scale(" + Oi + "," + Ii + ")" : ""));
          lt = ht = 1, at = St = 0;
        }
        Mt = 1, X = Rt = Ht = kt = he = oe = 0, te = Fi ? -1 / Fi : 0, _e = Pe.zOrigin, ue = 1e-6, ye = ",", Fe = "0", Le = Hn * Ft, Le && (je = Math.cos(Le), He = Math.sin(Le), Ht = -He, he = te * -He, X = lt * He, Rt = St * He, Mt = je, te *= je, lt *= je, St *= je), Le = wn * Ft, Le && (je = Math.cos(Le), He = Math.sin(Le), tt = at * je + X * He, ui = ht * je + Rt * He, kt = Mt * He, oe = te * He, X = at * -He + X * je, Rt = ht * -He + Rt * je, Mt *= je, te *= je, at = tt, ht = ui), Ui !== 1 && (X *= Ui, Rt *= Ui, Mt *= Ui, te *= Ui), Ii !== 1 && (at *= Ii, ht *= Ii, kt *= Ii, oe *= Ii), Oi !== 1 && (lt *= Oi, St *= Oi, Ht *= Oi, he *= Oi), (_e || an) && (_e && (Qi += X * -_e, tn += Rt * -_e, on += Mt * -_e + _e), an && (Qi += Pe.xOrigin - (Pe.xOrigin * lt + Pe.yOrigin * at) + Pe.xOffset, tn += Pe.yOrigin - (Pe.xOrigin * St + Pe.yOrigin * ht) + Pe.yOffset), ue > Qi && Qi > -ue && (Qi = Fe), ue > tn && tn > -ue && (tn = Fe), ue > on && on > -ue && (on = 0)), Be = Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix3d(" : "matrix3d(", Be += (ue > lt && lt > -ue ? Fe : lt) + ye + (ue > St && St > -ue ? Fe : St) + ye + (ue > Ht && Ht > -ue ? Fe : Ht), Be += ye + (ue > he && he > -ue ? Fe : he) + ye + (ue > at && at > -ue ? Fe : at) + ye + (ue > ht && ht > -ue ? Fe : ht), wn || Hn || Ui !== 1 ? (Be += ye + (ue > kt && kt > -ue ? Fe : kt) + ye + (ue > oe && oe > -ue ? Fe : oe) + ye + (ue > X && X > -ue ? Fe : X), Be += ye + (ue > Rt && Rt > -ue ? Fe : Rt) + ye + (ue > Mt && Mt > -ue ? Fe : Mt) + ye + (ue > te && te > -ue ? Fe : te) + ye) : Be += ",0,0,0,0,1,0,", Be += Qi + ye + tn + ye + on + ye + (Fi ? 1 + -on / Fi : 1) + ")", xe[xn] = Be;
      };
      S = qo.prototype, S.x = S.y = S.z = S.skewX = S.skewY = S.rotation = S.rotationX = S.rotationY = S.zOrigin = S.xPercent = S.yPercent = S.xOffset = S.yOffset = 0, S.scaleX = S.scaleY = S.scaleZ = 1, Ri(
        "transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",
        {
          parser: function(V, tt, lt, at, X, St, ht) {
            if (at._lastParsedTransform === ht)
              return X;
            at._lastParsedTransform = ht;
            var Rt, Ht = ht.scale && typeof ht.scale == "function" ? ht.scale : 0;
            typeof ht[lt] == "function" && (Rt = ht[lt], ht[lt] = tt), Ht && (ht.scale = Ht(x, V));
            var kt, Mt, he, oe, te, _e, ue, je, He, ui = V._gsTransform, Be = V.style, ye = 1e-6, Fe = bl.length, pe = ht, di = {}, Pe = "transformOrigin", xe = ss(V, d, !0, pe.parseTransform), Le = pe.transform && (typeof pe.transform == "function" ? pe.transform(x, L) : pe.transform);
            if (xe.skewType = pe.skewType || xe.skewType || m.defaultSkewType, at._transform = xe, "rotationZ" in pe && (pe.rotation = pe.rotationZ), Le && typeof Le == "string" && xn)
              Mt = ti.style, Mt[xn] = Le, Mt.display = "block", Mt.position = "absolute", Le.indexOf("%") !== -1 && (Mt.width = pt(V, "width"), Mt.height = pt(V, "height")), fe.body.appendChild(ti), kt = ss(ti, null, !1), xe.skewType === "simple" && (kt.scaleY *= Math.cos(kt.skewX * Ft)), xe.svg && (_e = xe.xOrigin, ue = xe.yOrigin, kt.x -= xe.xOffset, kt.y -= xe.yOffset, (pe.transformOrigin || pe.svgOrigin) && (Le = {}, Yo(
                V,
                nt(pe.transformOrigin),
                Le,
                pe.svgOrigin,
                pe.smoothOrigin,
                !0
              ), _e = Le.xOrigin, ue = Le.yOrigin, kt.x -= Le.xOffset - xe.xOffset, kt.y -= Le.yOffset - xe.yOffset), (_e || ue) && (je = Jo(ti, !0), kt.x -= _e - (_e * je[0] + ue * je[2]), kt.y -= ue - (_e * je[1] + ue * je[3]))), fe.body.removeChild(ti), kt.perspective || (kt.perspective = xe.perspective), pe.xPercent != null && (kt.xPercent = Gt(pe.xPercent, xe.xPercent)), pe.yPercent != null && (kt.yPercent = Gt(pe.yPercent, xe.yPercent));
            else if (typeof pe == "object") {
              if (kt = {
                scaleX: Gt(
                  pe.scaleX != null ? pe.scaleX : pe.scale,
                  xe.scaleX
                ),
                scaleY: Gt(
                  pe.scaleY != null ? pe.scaleY : pe.scale,
                  xe.scaleY
                ),
                scaleZ: Gt(pe.scaleZ, xe.scaleZ),
                x: Gt(pe.x, xe.x),
                y: Gt(pe.y, xe.y),
                z: Gt(pe.z, xe.z),
                xPercent: Gt(pe.xPercent, xe.xPercent),
                yPercent: Gt(pe.yPercent, xe.yPercent),
                perspective: Gt(pe.transformPerspective, xe.perspective)
              }, te = pe.directionalRotation, te != null)
                if (typeof te == "object")
                  for (Mt in te)
                    pe[Mt] = te[Mt];
                else
                  pe.rotation = te;
              typeof pe.x == "string" && pe.x.indexOf("%") !== -1 && (kt.x = 0, kt.xPercent = Gt(pe.x, xe.xPercent)), typeof pe.y == "string" && pe.y.indexOf("%") !== -1 && (kt.y = 0, kt.yPercent = Gt(pe.y, xe.yPercent)), kt.rotation = Xt(
                "rotation" in pe ? pe.rotation : "shortRotation" in pe ? pe.shortRotation + "_short" : xe.rotation,
                xe.rotation,
                "rotation",
                di
              ), dr && (kt.rotationX = Xt(
                "rotationX" in pe ? pe.rotationX : "shortRotationX" in pe ? pe.shortRotationX + "_short" : xe.rotationX || 0,
                xe.rotationX,
                "rotationX",
                di
              ), kt.rotationY = Xt(
                "rotationY" in pe ? pe.rotationY : "shortRotationY" in pe ? pe.shortRotationY + "_short" : xe.rotationY || 0,
                xe.rotationY,
                "rotationY",
                di
              )), kt.skewX = Xt(pe.skewX, xe.skewX), kt.skewY = Xt(pe.skewY, xe.skewY);
            }
            for (dr && pe.force3D != null && (xe.force3D = pe.force3D, oe = !0), he = xe.force3D || xe.z || xe.rotationX || xe.rotationY || kt.z || kt.rotationX || kt.rotationY || kt.perspective, he || pe.scale == null || (kt.scaleZ = 1); --Fe > -1; )
              He = bl[Fe], Le = kt[He] - xe[He], (Le > ye || -ye > Le || pe[He] != null || Bt[He] != null) && (oe = !0, X = new Si(xe, He, xe[He], Le, X), He in di && (X.e = di[He]), X.xs0 = 0, X.plugin = St, at._overwriteProps.push(X.n));
            return Le = pe.transformOrigin, xe.svg && (Le || pe.svgOrigin) && (_e = xe.xOffset, ue = xe.yOffset, Yo(V, nt(Le), kt, pe.svgOrigin, pe.smoothOrigin), X = Gr(
              xe,
              "xOrigin",
              (ui ? xe : kt).xOrigin,
              kt.xOrigin,
              X,
              Pe
            ), X = Gr(
              xe,
              "yOrigin",
              (ui ? xe : kt).yOrigin,
              kt.yOrigin,
              X,
              Pe
            ), (_e !== xe.xOffset || ue !== xe.yOffset) && (X = Gr(
              xe,
              "xOffset",
              ui ? _e : xe.xOffset,
              xe.xOffset,
              X,
              Pe
            ), X = Gr(
              xe,
              "yOffset",
              ui ? ue : xe.yOffset,
              xe.yOffset,
              X,
              Pe
            )), Le = "0px 0px"), (Le || dr && he && xe.zOrigin) && (xn ? (oe = !0, He = ho, Le = (Le || pt(V, He, d, !1, "50% 50%")) + "", X = new Si(Be, He, 0, 0, X, -1, Pe), X.b = Be[He], X.plugin = St, dr ? (Mt = xe.zOrigin, Le = Le.split(" "), xe.zOrigin = (Le.length > 2 && (Mt === 0 || Le[2] !== "0px") ? parseFloat(Le[2]) : Mt) || 0, X.xs0 = X.e = Le[0] + " " + (Le[1] || "50%") + " 0px", X = new Si(xe, "zOrigin", 0, 0, X, -1, X.n), X.b = Mt, X.xs0 = X.e = xe.zOrigin) : X.xs0 = X.e = Le) : nt(Le + "", xe)), oe && (at._transformType = xe.svg && is || !he && this._transformType !== 3 ? 2 : 3), Rt && (ht[lt] = Rt), Ht && (ht.scale = Ht), X;
          },
          prefix: !0
        }
      ), Ri("boxShadow", {
        defaultValue: "0px 0px 0px 0px #999",
        prefix: !0,
        color: !0,
        multi: !0,
        keyword: "inset"
      }), Ri("borderRadius", {
        defaultValue: "0px",
        parser: function(V, tt, lt, at, X, St) {
          tt = this.format(tt);
          var ht, Rt, Ht, kt, Mt, he, oe, te, _e, ue, je, He, ui, Be, ye, Fe, pe = [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomRightRadius",
            "borderBottomLeftRadius"
          ], di = V.style;
          for (_e = parseFloat(V.offsetWidth), ue = parseFloat(V.offsetHeight), ht = tt.split(" "), Rt = 0; Rt < pe.length; Rt++)
            this.p.indexOf("border") && (pe[Rt] = Jt(pe[Rt])), Mt = kt = pt(V, pe[Rt], d, !1, "0px"), Mt.indexOf(" ") !== -1 && (kt = Mt.split(" "), Mt = kt[0], kt = kt[1]), he = Ht = ht[Rt], oe = parseFloat(Mt), He = Mt.substr((oe + "").length), ui = he.charAt(1) === "=", ui ? (te = parseInt(he.charAt(0) + "1", 10), he = he.substr(2), te *= parseFloat(he), je = he.substr((te + "").length - (0 > te ? 1 : 0)) || "") : (te = parseFloat(he), je = he.substr((te + "").length)), je === "" && (je = p[lt] || He), je !== He && (Be = dt(V, "borderLeft", oe, He), ye = dt(V, "borderTop", oe, He), je === "%" ? (Mt = Be / _e * 100 + "%", kt = ye / ue * 100 + "%") : je === "em" ? (Fe = dt(V, "borderLeft", 1, "em"), Mt = Be / Fe + "em", kt = ye / Fe + "em") : (Mt = Be + "px", kt = ye + "px"), ui && (he = parseFloat(Mt) + te + je, Ht = parseFloat(kt) + te + je)), X = er(di, pe[Rt], Mt + " " + kt, he + " " + Ht, !1, "0px", X);
          return X;
        },
        prefix: !0,
        formatter: vi("0px 0px 0px 0px", !1, !0)
      }), Ri(
        "borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius",
        {
          defaultValue: "0px",
          parser: function(V, tt, lt, at, X, St) {
            return er(
              V.style,
              lt,
              this.format(pt(V, lt, d, !1, "0px 0px")),
              this.format(tt),
              !1,
              "0px",
              X
            );
          },
          prefix: !0,
          formatter: vi("0px 0px", !1, !0)
        }
      ), Ri("backgroundPosition", {
        defaultValue: "0 0",
        parser: function(V, tt, lt, at, X, St) {
          var ht, Rt, Ht, kt, Mt, he, oe = "background-position", te = d || Wt(V, null), _e = this.format(
            (te ? E ? te.getPropertyValue(oe + "-x") + " " + te.getPropertyValue(oe + "-y") : te.getPropertyValue(oe) : V.currentStyle.backgroundPositionX + " " + V.currentStyle.backgroundPositionY) || "0 0"
          ), ue = this.format(tt);
          if (_e.indexOf("%") !== -1 != (ue.indexOf("%") !== -1) && ue.split(",").length < 2 && (he = pt(V, "backgroundImage").replace(yt, ""), he && he !== "none")) {
            for (ht = _e.split(" "), Rt = ue.split(" "), Ni.setAttribute("src", he), Ht = 2; --Ht > -1; )
              _e = ht[Ht], kt = _e.indexOf("%") !== -1, kt !== (Rt[Ht].indexOf("%") !== -1) && (Mt = Ht === 0 ? V.offsetWidth - Ni.width : V.offsetHeight - Ni.height, ht[Ht] = kt ? parseFloat(_e) / 100 * Mt + "px" : parseFloat(_e) / Mt * 100 + "%");
            _e = ht.join(" ");
          }
          return this.parseComplex(V.style, _e, ue, X, St);
        },
        formatter: nt
      }), Ri("backgroundSize", {
        defaultValue: "0 0",
        formatter: function(V) {
          return V += "", V.substr(0, 2) === "co" ? V : nt(V.indexOf(" ") === -1 ? V + " " + V : V);
        }
      }), Ri("perspective", { defaultValue: "0px", prefix: !0 }), Ri("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), Ri("transformStyle", { prefix: !0 }), Ri("backfaceVisibility", { prefix: !0 }), Ri("userSelect", { prefix: !0 }), Ri("margin", {
        parser: Mi("marginTop,marginRight,marginBottom,marginLeft")
      }), Ri("padding", {
        parser: Mi("paddingTop,paddingRight,paddingBottom,paddingLeft")
      }), Ri("clip", {
        defaultValue: "rect(0px,0px,0px,0px)",
        parser: function(V, tt, lt, at, X, St) {
          var ht, Rt, Ht;
          return 9 > E ? (Rt = V.currentStyle, Ht = 8 > E ? " " : ",", ht = "rect(" + Rt.clipTop + Ht + Rt.clipRight + Ht + Rt.clipBottom + Ht + Rt.clipLeft + ")", tt = this.format(tt).split(",").join(Ht)) : (ht = this.format(pt(V, this.p, d, !1, this.dflt)), tt = this.format(tt)), this.parseComplex(V.style, ht, tt, X, St);
        }
      }), Ri("textShadow", {
        defaultValue: "0px 0px 0px #999",
        color: !0,
        multi: !0
      }), Ri("autoRound,strictUnits", {
        parser: function(V, tt, lt, at, X) {
          return X;
        }
      }), Ri("border", {
        defaultValue: "0px solid #000",
        parser: function(V, tt, lt, at, X, St) {
          var ht = pt(V, "borderTopWidth", d, !1, "0px"), Rt = this.format(tt).split(" "), Ht = Rt[0].replace(N, "");
          return Ht !== "px" && (ht = parseFloat(ht) / dt(V, "borderTopWidth", 1, Ht) + Ht), this.parseComplex(
            V.style,
            this.format(
              ht + " " + pt(V, "borderTopStyle", d, !1, "solid") + " " + pt(V, "borderTopColor", d, !1, "#000")
            ),
            Rt.join(" "),
            X,
            St
          );
        },
        color: !0,
        formatter: function(V) {
          var tt = V.split(" ");
          return tt[0] + " " + (tt[1] || "solid") + " " + (V.match(we) || ["#000"])[0];
        }
      }), Ri("borderWidth", {
        parser: Mi(
          "borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth"
        )
      }), Ri("float,cssFloat,styleFloat", {
        parser: function(V, tt, lt, at, X, St) {
          var ht = V.style, Rt = "cssFloat" in ht ? "cssFloat" : "styleFloat";
          return new Si(ht, Rt, 0, 0, X, -1, lt, !1, 0, ht[Rt], tt);
        }
      });
      var ph = function(V) {
        var tt, lt = this.t, at = lt.filter || pt(this.data, "filter") || "", X = this.s + this.c * V | 0;
        X === 100 && (at.indexOf("atrix(") === -1 && at.indexOf("radient(") === -1 && at.indexOf("oader(") === -1 ? (lt.removeAttribute("filter"), tt = !pt(this.data, "filter")) : (lt.filter = at.replace($, ""), tt = !0)), tt || (this.xn1 && (lt.filter = at = at || "alpha(opacity=" + X + ")"), at.indexOf("pacity") === -1 ? X === 0 && this.xn1 || (lt.filter = at + " alpha(opacity=" + X + ")") : lt.filter = at.replace(j, "opacity=" + X));
      };
      Ri("opacity,alpha,autoAlpha", {
        defaultValue: "1",
        parser: function(V, tt, lt, at, X, St) {
          var ht = parseFloat(pt(V, "opacity", d, !1, "1")), Rt = V.style, Ht = lt === "autoAlpha";
          return typeof tt == "string" && tt.charAt(1) === "=" && (tt = (tt.charAt(0) === "-" ? -1 : 1) * parseFloat(tt.substr(2)) + ht), Ht && ht === 1 && pt(V, "visibility", d) === "hidden" && tt !== 0 && (ht = 0), pi ? X = new Si(Rt, "opacity", ht, tt - ht, X) : (X = new Si(Rt, "opacity", 100 * ht, 100 * (tt - ht), X), X.xn1 = Ht ? 1 : 0, Rt.zoom = 1, X.type = 2, X.b = "alpha(opacity=" + X.s + ")", X.e = "alpha(opacity=" + (X.s + X.c) + ")", X.data = V, X.plugin = St, X.setRatio = ph), Ht && (X = new Si(
            Rt,
            "visibility",
            0,
            0,
            X,
            -1,
            null,
            !1,
            0,
            ht !== 0 ? "inherit" : "hidden",
            tt === 0 ? "hidden" : "inherit"
          ), X.xs0 = "inherit", at._overwriteProps.push(X.n), at._overwriteProps.push(lt)), X;
        }
      });
      var uo = function(V, tt) {
        tt && (V.removeProperty ? ((tt.substr(0, 2) === "ms" || tt.substr(0, 6) === "webkit") && (tt = "-" + tt), V.removeProperty(tt.replace(It, "-$1").toLowerCase())) : V.removeAttribute(tt));
      }, co = function(V) {
        if (this.t._gsClassPT = this, V === 1 || V === 0) {
          this.t.setAttribute("class", V === 0 ? this.b : this.e);
          for (var tt = this.data, lt = this.t.style; tt; )
            tt.v ? lt[tt.p] = tt.v : uo(lt, tt.p), tt = tt._next;
          V === 1 && this.t._gsClassPT === this && (this.t._gsClassPT = null);
        } else
          this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
      };
      Ri("className", {
        parser: function(V, tt, lt, at, X, St, ht) {
          var Rt, Ht, kt, Mt, he, oe = V.getAttribute("class") || "", te = V.style.cssText;
          if (X = at._classNamePT = new Si(V, lt, 0, 0, X, 2), X.setRatio = co, X.pr = -11, o = !0, X.b = oe, Ht = ie(V, d), kt = V._gsClassPT) {
            for (Mt = {}, he = kt.data; he; )
              Mt[he.p] = 1, he = he._next;
            kt.setRatio(1);
          }
          return V._gsClassPT = X, X.e = tt.charAt(1) !== "=" ? tt : oe.replace(
            new RegExp("(?:\\s|^)" + tt.substr(2) + "(?![\\w-])"),
            ""
          ) + (tt.charAt(0) === "+" ? " " + tt.substr(2) : ""), V.setAttribute("class", X.e), Rt = Kt(V, Ht, ie(V), ht, Mt), V.setAttribute("class", oe), X.data = Rt.firstMPT, V.style.cssText = te, X = X.xfirst = at.parse(V, Rt.difs, X, St);
        }
      });
      var Pl = function(V) {
        if ((V === 1 || V === 0) && this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
          var tt, lt, at, X, St, ht = this.t.style, Rt = T.transform.parse;
          if (this.e === "all")
            ht.cssText = "", X = !0;
          else
            for (tt = this.e.split(" ").join("").split(","), at = tt.length; --at > -1; )
              lt = tt[at], T[lt] && (T[lt].parse === Rt ? X = !0 : lt = lt === "transformOrigin" ? ho : T[lt].p), uo(ht, lt);
          X && (uo(ht, xn), St = this.t._gsTransform, St && (St.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform));
        }
      };
      for (Ri("clearProps", {
        parser: function(V, tt, lt, at, X) {
          return X = new Si(V, lt, 0, 0, X, 2), X.setRatio = Pl, X.e = tt, X.pr = -10, X.data = at._tween, o = !0, X;
        }
      }), S = "bezier,throwProps,physicsProps,physics2D".split(","), rn = S.length; rn--; )
        Us(S[rn]);
      S = m.prototype, S._firstPT = S._lastParsedTransform = S._transform = null, S._onInitTween = function(V, tt, lt, at) {
        if (!V.nodeType)
          return !1;
        this._target = L = V, this._tween = lt, this._vars = tt, x = at, C = tt.autoRound, o = !1, p = tt.suffixMap || m.suffixMap, d = Wt(V, ""), u = this._overwriteProps;
        var X, St, ht, Rt, Ht, kt, Mt, he, oe, te = V.style;
        if (z && te.zIndex === "" && (X = pt(V, "zIndex", d), (X === "auto" || X === "") && this._addLazySet(te, "zIndex", 0)), typeof tt == "string" && (Rt = te.cssText, X = ie(V, d), te.cssText = Rt + ";" + tt, X = Kt(V, X, ie(V)).difs, !pi && J.test(tt) && (X.opacity = parseFloat(RegExp.$1)), tt = X, te.cssText = Rt), tt.className ? this._firstPT = St = T.className.parse(
          V,
          tt.className,
          "className",
          this,
          null,
          null,
          tt
        ) : this._firstPT = St = this.parse(V, tt, null), this._transformType) {
          for (oe = this._transformType === 3, xn ? B && (z = !0, te.zIndex === "" && (Mt = pt(V, "zIndex", d), (Mt === "auto" || Mt === "") && this._addLazySet(te, "zIndex", 0)), F && this._addLazySet(
            te,
            "WebkitBackfaceVisibility",
            this._vars.WebkitBackfaceVisibility || (oe ? "visible" : "hidden")
          )) : te.zoom = 1, ht = St; ht && ht._next; )
            ht = ht._next;
          he = new Si(V, "transform", 0, 0, null, 2), this._linkCSSP(he, null, ht), he.setRatio = xn ? fh : Cl, he.data = this._transform || ss(V, d, !0), he.tween = lt, he.pr = -1, u.pop();
        }
        if (o) {
          for (; St; ) {
            for (kt = St._next, ht = Rt; ht && ht.pr > St.pr; )
              ht = ht._next;
            (St._prev = ht ? ht._prev : Ht) ? St._prev._next = St : Rt = St, (St._next = ht) ? ht._prev = St : Ht = St, St = kt;
          }
          this._firstPT = Rt;
        }
        return !0;
      }, S.parse = function(V, tt, lt, at) {
        var X, St, ht, Rt, Ht, kt, Mt, he, oe, te, _e = V.style;
        for (X in tt) {
          if (kt = tt[X], typeof kt == "function" && (kt = kt(x, L)), St = T[X])
            lt = St.parse(V, kt, X, this, lt, at, tt);
          else {
            if (X.substr(0, 2) === "--") {
              this._tween._propLookup[X] = this._addTween.call(
                this._tween,
                V.style,
                "setProperty",
                Wt(V).getPropertyValue(X) + "",
                kt + "",
                X,
                !1,
                X
              );
              continue;
            }
            Ht = pt(V, X, d) + "", oe = typeof kt == "string", X === "color" || X === "fill" || X === "stroke" || X.indexOf("Color") !== -1 || oe && ct.test(kt) ? (oe || (kt = Re(kt), kt = (kt.length > 3 ? "rgba(" : "rgb(") + kt.join(",") + ")"), lt = er(_e, X, Ht, kt, !0, "transparent", lt, 0, at)) : oe && re.test(kt) ? lt = er(_e, X, Ht, kt, !0, null, lt, 0, at) : (ht = parseFloat(Ht), Mt = ht || ht === 0 ? Ht.substr((ht + "").length) : "", (Ht === "" || Ht === "auto") && (X === "width" || X === "height" ? (ht = ot(V, X, d), Mt = "px") : X === "left" || X === "top" ? (ht = Dt(V, X, d), Mt = "px") : (ht = X !== "opacity" ? 0 : 1, Mt = "")), te = oe && kt.charAt(1) === "=", te ? (Rt = parseInt(kt.charAt(0) + "1", 10), kt = kt.substr(2), Rt *= parseFloat(kt), he = kt.replace(N, "")) : (Rt = parseFloat(kt), he = oe ? kt.replace(N, "") : ""), he === "" && (he = X in p ? p[X] : Mt), kt = Rt || Rt === 0 ? (te ? Rt + ht : Rt) + he : tt[X], Mt !== he && (he !== "" || X === "lineHeight") && (Rt || Rt === 0) && ht && (ht = dt(V, X, ht, Mt), he === "%" ? (ht /= dt(V, X, 100, "%") / 100, tt.strictUnits !== !0 && (Ht = ht + "%")) : he === "em" || he === "rem" || he === "vw" || he === "vh" ? ht /= dt(V, X, 1, he) : he !== "px" && (Rt = dt(V, X, Rt, he), he = "px"), te && (Rt || Rt === 0) && (kt = Rt + ht + he)), te && (Rt += ht), !ht && ht !== 0 || !Rt && Rt !== 0 ? _e[X] !== void 0 && (kt || kt + "" != "NaN" && kt != null) ? (lt = new Si(
              _e,
              X,
              Rt || ht || 0,
              0,
              lt,
              -1,
              X,
              !1,
              0,
              Ht,
              kt
            ), lt.xs0 = kt !== "none" || X !== "display" && X.indexOf("Style") === -1 ? kt : Ht) : cn("invalid " + X + " tween value: " + tt[X]) : (lt = new Si(
              _e,
              X,
              ht,
              Rt - ht,
              lt,
              0,
              X,
              C !== !1 && (he === "px" || X === "zIndex"),
              0,
              Ht,
              kt
            ), lt.xs0 = he));
          }
          at && lt && !lt.plugin && (lt.plugin = at);
        }
        return lt;
      }, S.setRatio = function(V) {
        var tt, lt, at, X = this._firstPT, St = 1e-6;
        if (V !== 1 || this._tween._time !== this._tween._duration && this._tween._time !== 0)
          if (V || this._tween._time !== this._tween._duration && this._tween._time !== 0 || this._tween._rawPrevTime === -1e-6)
            for (; X; ) {
              if (tt = X.c * V + X.s, X.r ? tt = X.r(tt) : St > tt && tt > -St && (tt = 0), X.type)
                if (X.type === 1)
                  if (at = X.l, at === 2)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2;
                  else if (at === 3)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2 + X.xn2 + X.xs3;
                  else if (at === 4)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2 + X.xn2 + X.xs3 + X.xn3 + X.xs4;
                  else if (at === 5)
                    X.t[X.p] = X.xs0 + tt + X.xs1 + X.xn1 + X.xs2 + X.xn2 + X.xs3 + X.xn3 + X.xs4 + X.xn4 + X.xs5;
                  else {
                    for (lt = X.xs0 + tt + X.xs1, at = 1; at < X.l; at++)
                      lt += X["xn" + at] + X["xs" + (at + 1)];
                    X.t[X.p] = lt;
                  }
                else
                  X.type === -1 ? X.t[X.p] = X.xs0 : X.setRatio && X.setRatio(V);
              else
                X.t[X.p] = tt + X.xs0;
              X = X._next;
            }
          else
            for (; X; )
              X.type !== 2 ? X.t[X.p] = X.b : X.setRatio(V), X = X._next;
        else
          for (; X; ) {
            if (X.type !== 2)
              if (X.r && X.type !== -1)
                if (tt = X.r(X.s + X.c), X.type) {
                  if (X.type === 1) {
                    for (at = X.l, lt = X.xs0 + tt + X.xs1, at = 1; at < X.l; at++)
                      lt += X["xn" + at] + X["xs" + (at + 1)];
                    X.t[X.p] = lt;
                  }
                } else
                  X.t[X.p] = tt + X.xs0;
              else
                X.t[X.p] = X.e;
            else
              X.setRatio(V);
            X = X._next;
          }
      }, S._enableTransforms = function(V) {
        this._transform = this._transform || ss(this._target, d, !0), this._transformType = this._transform.svg && is || !V && this._transformType !== 3 ? 2 : 3;
      };
      var Ll = function(V) {
        this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
      };
      S._addLazySet = function(V, tt, lt) {
        var at = this._firstPT = new Si(V, tt, 0, 0, this._firstPT, 2);
        at.e = lt, at.setRatio = Ll, at.data = this;
      }, S._linkCSSP = function(V, tt, lt, at) {
        return V && (tt && (tt._prev = V), V._next && (V._next._prev = V._prev), V._prev ? V._prev._next = V._next : this._firstPT === V && (this._firstPT = V._next, at = !0), lt ? lt._next = V : at || this._firstPT !== null || (this._firstPT = V), V._next = tt, V._prev = lt), V;
      }, S._mod = function(V) {
        for (var tt = this._firstPT; tt; )
          typeof V[tt.p] == "function" && (tt.r = V[tt.p]), tt = tt._next;
      }, S._kill = function(V) {
        var tt, lt, at, X = V;
        if (V.autoAlpha || V.alpha) {
          X = {};
          for (lt in V)
            X[lt] = V[lt];
          X.opacity = 1, X.autoAlpha && (X.visibility = 1);
        }
        for (V.className && (tt = this._classNamePT) && (at = tt.xfirst, at && at._prev ? this._linkCSSP(at._prev, tt._next, at._prev._prev) : at === this._firstPT && (this._firstPT = tt._next), tt._next && this._linkCSSP(tt._next, tt._next._next, at._prev), this._classNamePT = null), tt = this._firstPT; tt; )
          tt.plugin && tt.plugin !== lt && tt.plugin._kill && (tt.plugin._kill(V), lt = tt.plugin), tt = tt._next;
        return w.prototype._kill.call(this, X);
      };
      var Hr = function(V, tt, lt) {
        var at, X, St, ht;
        if (V.slice)
          for (X = V.length; --X > -1; )
            Hr(V[X], tt, lt);
        else
          for (at = V.childNodes, X = at.length; --X > -1; )
            St = at[X], ht = St.type, St.style && (tt.push(ie(St)), lt && lt.push(St)), ht !== 1 && ht !== 9 && ht !== 11 || !St.childNodes.length || Hr(St, tt, lt);
      };
      return m.cascadeTo = function(V, tt, lt) {
        var at, X, St, ht, Rt = l.to(V, tt, lt), Ht = [Rt], kt = [], Mt = [], he = [], oe = l._internals.reservedProps;
        for (V = Rt._targets || Rt.target, Hr(V, kt, he), Rt.render(tt, !0, !0), Hr(V, Mt), Rt.render(0, !0, !0), Rt._enabled(!0), at = he.length; --at > -1; )
          if (X = Kt(he[at], kt[at], Mt[at]), X.firstMPT) {
            X = X.difs;
            for (St in lt)
              oe[St] && (X[St] = lt[St]);
            ht = {};
            for (St in X)
              ht[St] = kt[at][St];
            Ht.push(l.fromTo(he[at], tt, ht, X));
          }
        return Ht;
      }, w.activate([m]), m;
    },
    !0
  ), function() {
    var w = hn._gsDefine.plugin({
      propName: "roundProps",
      version: "1.7.0",
      priority: -1,
      API: 2,
      init: function(d, u, m) {
        return this._tween = m, !0;
      }
    }), l = function(d) {
      var u = 1 > d ? Math.pow(10, (d + "").length - 2) : 1;
      return function(m) {
        return (Math.round(m / d) * d * u | 0) / u;
      };
    }, o = function(d, u) {
      for (; d; )
        d.f || d.blob || (d.m = u || Math.round), d = d._next;
    }, p = w.prototype;
    p._onInitAllProps = function() {
      var d, u, m, _, T = this._tween, S = T.vars.roundProps, C = {}, z = T._propLookup.roundProps;
      if (typeof S != "object" || S.push)
        for (typeof S == "string" && (S = S.split(",")), m = S.length; --m > -1; )
          C[S[m]] = Math.round;
      else
        for (_ in S)
          C[_] = l(S[_]);
      for (_ in C)
        for (d = T._firstPT; d; )
          u = d._next, d.pg ? d.t._mod(C) : d.n === _ && (d.f === 2 && d.t ? o(d.t._firstPT, C[_]) : (this._add(d.t, _, d.s, d.c, C[_]), u && (u._prev = d._prev), d._prev ? d._prev._next = u : T._firstPT === d && (T._firstPT = u), d._next = d._prev = null, T._propLookup[_] = z)), d = u;
      return !1;
    }, p._add = function(d, u, m, _, T) {
      this._addTween(d, u, m, m + _, u, T || Math.round), this._overwriteProps.push(u);
    };
  }(), function() {
    hn._gsDefine.plugin({
      propName: "attr",
      API: 2,
      version: "0.6.1",
      init: function(w, l, o, p) {
        var d, u;
        if (typeof w.setAttribute != "function")
          return !1;
        for (d in l)
          u = l[d], typeof u == "function" && (u = u(p, w)), this._addTween(
            w,
            "setAttribute",
            w.getAttribute(d) + "",
            u + "",
            d,
            !1,
            d
          ), this._overwriteProps.push(d);
        return !0;
      }
    });
  }(), hn._gsDefine.plugin({
    propName: "directionalRotation",
    version: "0.3.1",
    API: 2,
    init: function(w, l, o, p) {
      typeof l != "object" && (l = { rotation: l }), this.finals = {};
      var d, u, m, _, T, S, C = l.useRadians === !0 ? 2 * Math.PI : 360, z = 1e-6;
      for (d in l)
        d !== "useRadians" && (_ = l[d], typeof _ == "function" && (_ = _(p, w)), S = (_ + "").split("_"), u = S[0], m = parseFloat(
          typeof w[d] != "function" ? w[d] : w[d.indexOf("set") || typeof w["get" + d.substr(3)] != "function" ? d : "get" + d.substr(3)]()
        ), _ = this.finals[d] = typeof u == "string" && u.charAt(1) === "=" ? m + parseInt(u.charAt(0) + "1", 10) * Number(u.substr(2)) : Number(u) || 0, T = _ - m, S.length && (u = S.join("_"), u.indexOf("short") !== -1 && (T %= C, T !== T % (C / 2) && (T = 0 > T ? T + C : T - C)), u.indexOf("_cw") !== -1 && 0 > T ? T = (T + 9999999999 * C) % C - (T / C | 0) * C : u.indexOf("ccw") !== -1 && T > 0 && (T = (T - 9999999999 * C) % C - (T / C | 0) * C)), (T > z || -z > T) && (this._addTween(w, d, m, m + T, d), this._overwriteProps.push(d)));
      return !0;
    },
    set: function(w) {
      var l;
      if (w !== 1)
        this._super.setRatio.call(this, w);
      else
        for (l = this._firstPT; l; )
          l.f ? l.t[l.p](this.finals[l.p]) : l.t[l.p] = this.finals[l.p], l = l._next;
    }
  })._autoCSS = !0, hn._gsDefine(
    "easing.Back",
    ["easing.Ease"],
    function(w) {
      var l, o, p, d, u = hn.GreenSockGlobals || hn, m = u.com.greensock, _ = 2 * Math.PI, T = Math.PI / 2, S = m._class, C = function(M, R) {
        var b = S("easing." + M, function() {
        }, !0), U = b.prototype = new w();
        return U.constructor = b, U.getRatio = R, b;
      }, z = w.register || function() {
      }, B = function(M, R, b, U, N) {
        var j = S(
          "easing." + M,
          { easeOut: new R(), easeIn: new b(), easeInOut: new U() },
          !0
        );
        return z(j, M), j;
      }, I = function(M, R, b) {
        this.t = M, this.v = R, b && (this.next = b, b.prev = this, this.c = b.v - R, this.gap = b.t - M);
      }, F = function(M, R) {
        var b = S(
          "easing." + M,
          function(N) {
            this._p1 = N || N === 0 ? N : 1.70158, this._p2 = 1.525 * this._p1;
          },
          !0
        ), U = b.prototype = new w();
        return U.constructor = b, U.getRatio = R, U.config = function(N) {
          return new b(N);
        }, b;
      }, E = B(
        "Back",
        F("BackOut", function(M) {
          return (M -= 1) * M * ((this._p1 + 1) * M + this._p1) + 1;
        }),
        F("BackIn", function(M) {
          return M * M * ((this._p1 + 1) * M - this._p1);
        }),
        F("BackInOut", function(M) {
          return (M *= 2) < 1 ? 0.5 * M * M * ((this._p2 + 1) * M - this._p2) : 0.5 * ((M -= 2) * M * ((this._p2 + 1) * M + this._p2) + 2);
        })
      ), L = S(
        "easing.SlowMo",
        function(M, R, b) {
          R = R || R === 0 ? R : 0.7, M == null ? M = 0.7 : M > 1 && (M = 1), this._p = M !== 1 ? R : 0, this._p1 = (1 - M) / 2, this._p2 = M, this._p3 = this._p1 + this._p2, this._calcEnd = b === !0;
        },
        !0
      ), x = L.prototype = new w();
      return x.constructor = L, x.getRatio = function(M) {
        var R = M + (0.5 - M) * this._p;
        return M < this._p1 ? this._calcEnd ? 1 - (M = 1 - M / this._p1) * M : R - (M = 1 - M / this._p1) * M * M * M * R : M > this._p3 ? this._calcEnd ? M === 1 ? 0 : 1 - (M = (M - this._p3) / this._p1) * M : R + (M - R) * (M = (M - this._p3) / this._p1) * M * M * M : this._calcEnd ? 1 : R;
      }, L.ease = new L(0.7, 0.7), x.config = L.config = function(M, R, b) {
        return new L(M, R, b);
      }, l = S(
        "easing.SteppedEase",
        function(M, R) {
          M = M || 1, this._p1 = 1 / M, this._p2 = M + (R ? 0 : 1), this._p3 = R ? 1 : 0;
        },
        !0
      ), x = l.prototype = new w(), x.constructor = l, x.getRatio = function(M) {
        return 0 > M ? M = 0 : M >= 1 && (M = 0.999999999), ((this._p2 * M | 0) + this._p3) * this._p1;
      }, x.config = l.config = function(M, R) {
        return new l(M, R);
      }, o = S(
        "easing.ExpoScaleEase",
        function(M, R, b) {
          this._p1 = Math.log(R / M), this._p2 = R - M, this._p3 = M, this._ease = b;
        },
        !0
      ), x = o.prototype = new w(), x.constructor = o, x.getRatio = function(M) {
        return this._ease && (M = this._ease.getRatio(M)), (this._p3 * Math.exp(this._p1 * M) - this._p3) / this._p2;
      }, x.config = o.config = function(M, R, b) {
        return new o(M, R, b);
      }, p = S(
        "easing.RoughEase",
        function(M) {
          M = M || {};
          for (var R, b, U, N, j, J, $ = M.taper || "none", ct = [], It = 0, et = 0 | (M.points || 20), yt = et, G = M.randomize !== !1, Pt = M.clamp === !0, Et = M.template instanceof w ? M.template : null, Ct = typeof M.strength == "number" ? 0.4 * M.strength : 0.4; --yt > -1; )
            R = G ? Math.random() : 1 / et * yt, b = Et ? Et.getRatio(R) : R, $ === "none" ? U = Ct : $ === "out" ? (N = 1 - R, U = N * N * Ct) : $ === "in" ? U = R * R * Ct : 0.5 > R ? (N = 2 * R, U = N * N * 0.5 * Ct) : (N = 2 * (1 - R), U = N * N * 0.5 * Ct), G ? b += Math.random() * U - 0.5 * U : yt % 2 ? b += 0.5 * U : b -= 0.5 * U, Pt && (b > 1 ? b = 1 : 0 > b && (b = 0)), ct[It++] = { x: R, y: b };
          for (ct.sort(function(ce, re) {
            return ce.x - re.x;
          }), J = new I(1, 1, null), yt = et; --yt > -1; )
            j = ct[yt], J = new I(j.x, j.y, J);
          this._prev = new I(0, 0, J.t !== 0 ? J : J.next);
        },
        !0
      ), x = p.prototype = new w(), x.constructor = p, x.getRatio = function(M) {
        var R = this._prev;
        if (M > R.t) {
          for (; R.next && M >= R.t; )
            R = R.next;
          R = R.prev;
        } else
          for (; R.prev && M <= R.t; )
            R = R.prev;
        return this._prev = R, R.v + (M - R.t) / R.gap * R.c;
      }, x.config = function(M) {
        return new p(M);
      }, p.ease = new p(), B(
        "Bounce",
        C("BounceOut", function(M) {
          return 1 / 2.75 > M ? 7.5625 * M * M : 2 / 2.75 > M ? 7.5625 * (M -= 1.5 / 2.75) * M + 0.75 : 2.5 / 2.75 > M ? 7.5625 * (M -= 2.25 / 2.75) * M + 0.9375 : 7.5625 * (M -= 2.625 / 2.75) * M + 0.984375;
        }),
        C("BounceIn", function(M) {
          return (M = 1 - M) < 1 / 2.75 ? 1 - 7.5625 * M * M : 2 / 2.75 > M ? 1 - (7.5625 * (M -= 1.5 / 2.75) * M + 0.75) : 2.5 / 2.75 > M ? 1 - (7.5625 * (M -= 2.25 / 2.75) * M + 0.9375) : 1 - (7.5625 * (M -= 2.625 / 2.75) * M + 0.984375);
        }),
        C("BounceInOut", function(M) {
          var R = 0.5 > M;
          return M = R ? 1 - 2 * M : 2 * M - 1, M = 1 / 2.75 > M ? 7.5625 * M * M : 2 / 2.75 > M ? 7.5625 * (M -= 1.5 / 2.75) * M + 0.75 : 2.5 / 2.75 > M ? 7.5625 * (M -= 2.25 / 2.75) * M + 0.9375 : 7.5625 * (M -= 2.625 / 2.75) * M + 0.984375, R ? 0.5 * (1 - M) : 0.5 * M + 0.5;
        })
      ), B(
        "Circ",
        C("CircOut", function(M) {
          return Math.sqrt(1 - (M -= 1) * M);
        }),
        C("CircIn", function(M) {
          return -(Math.sqrt(1 - M * M) - 1);
        }),
        C("CircInOut", function(M) {
          return (M *= 2) < 1 ? -0.5 * (Math.sqrt(1 - M * M) - 1) : 0.5 * (Math.sqrt(1 - (M -= 2) * M) + 1);
        })
      ), d = function(M, R, b) {
        var U = S(
          "easing." + M,
          function(j, J) {
            this._p1 = j >= 1 ? j : 1, this._p2 = (J || b) / (1 > j ? j : 1), this._p3 = this._p2 / _ * (Math.asin(1 / this._p1) || 0), this._p2 = _ / this._p2;
          },
          !0
        ), N = U.prototype = new w();
        return N.constructor = U, N.getRatio = R, N.config = function(j, J) {
          return new U(j, J);
        }, U;
      }, B(
        "Elastic",
        d(
          "ElasticOut",
          function(M) {
            return this._p1 * Math.pow(2, -10 * M) * Math.sin((M - this._p3) * this._p2) + 1;
          },
          0.3
        ),
        d(
          "ElasticIn",
          function(M) {
            return -(this._p1 * Math.pow(2, 10 * (M -= 1)) * Math.sin((M - this._p3) * this._p2));
          },
          0.3
        ),
        d(
          "ElasticInOut",
          function(M) {
            return (M *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (M -= 1)) * Math.sin((M - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (M -= 1)) * Math.sin((M - this._p3) * this._p2) * 0.5 + 1;
          },
          0.45
        )
      ), B(
        "Expo",
        C("ExpoOut", function(M) {
          return 1 - Math.pow(2, -10 * M);
        }),
        C("ExpoIn", function(M) {
          return Math.pow(2, 10 * (M - 1)) - 1e-3;
        }),
        C("ExpoInOut", function(M) {
          return (M *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (M - 1)) : 0.5 * (2 - Math.pow(2, -10 * (M - 1)));
        })
      ), B(
        "Sine",
        C("SineOut", function(M) {
          return Math.sin(M * T);
        }),
        C("SineIn", function(M) {
          return -Math.cos(M * T) + 1;
        }),
        C("SineInOut", function(M) {
          return -0.5 * (Math.cos(Math.PI * M) - 1);
        })
      ), S(
        "easing.EaseLookup",
        {
          find: function(M) {
            return w.map[M];
          }
        },
        !0
      ), z(u.SlowMo, "SlowMo", "ease,"), z(p, "RoughEase", "ease,"), z(l, "SteppedEase", "ease,"), E;
    },
    !0
  );
}), hn._gsDefine && hn._gsQueue.pop()(), function(w, l) {
  var o = {}, p = w.document, d = w.GreenSockGlobals = w.GreenSockGlobals || w, u = d[l];
  if (u)
    return typeof module < "u" && module.exports && (module.exports = u), u;
  var m, _, T, S, C, z = function(D) {
    var Q, ot = D.split("."), nt = d;
    for (Q = 0; Q < ot.length; Q++)
      nt[ot[Q]] = nt = nt[ot[Q]] || {};
    return nt;
  }, B = z("com.greensock"), I = 1e-10, F = function(D) {
    var Q, ot = [], nt = D.length;
    for (Q = 0; Q !== nt; ot.push(D[Q++]))
      ;
    return ot;
  }, E = function() {
  }, L = function() {
    var D = Object.prototype.toString, Q = D.call([]);
    return function(ot) {
      return ot != null && (ot instanceof Array || typeof ot == "object" && !!ot.push && D.call(ot) === Q);
    };
  }(), x = {}, M = function(D, Q, ot, nt) {
    this.sc = x[D] ? x[D].sc : [], x[D] = this, this.gsClass = null, this.func = ot;
    var vt = [];
    this.check = function(Gt) {
      for (var Xt, jt, Ne, Re, ge = Q.length, we = ge; --ge > -1; )
        (Xt = x[Q[ge]] || new M(Q[ge], [])).gsClass ? (vt[ge] = Xt.gsClass, we--) : Gt && Xt.sc.push(this);
      if (we === 0 && ot) {
        if (jt = ("com.greensock." + D).split("."), Ne = jt.pop(), Re = z(jt.join("."))[Ne] = this.gsClass = ot.apply(ot, vt), nt)
          if (d[Ne] = o[Ne] = Re, typeof module < "u" && module.exports)
            if (D === l) {
              module.exports = o[l] = Re;
              for (ge in o)
                Re[ge] = o[ge];
            } else
              o[l] && (o[l][Ne] = Re);
          else
            typeof define == "function" && define.amd && define(
              (w.GreenSockAMDPath ? w.GreenSockAMDPath + "/" : "") + D.split(".").pop(),
              [],
              function() {
                return Re;
              }
            );
        for (ge = 0; ge < this.sc.length; ge++)
          this.sc[ge].check();
      }
    }, this.check(!0);
  }, R = w._gsDefine = function(D, Q, ot, nt) {
    return new M(D, Q, ot, nt);
  }, b = B._class = function(D, Q, ot) {
    return Q = Q || function() {
    }, R(
      D,
      [],
      function() {
        return Q;
      },
      ot
    ), Q;
  };
  R.globals = d;
  var U = [0, 0, 1, 1], N = b(
    "easing.Ease",
    function(D, Q, ot, nt) {
      this._func = D, this._type = ot || 0, this._power = nt || 0, this._params = Q ? U.concat(Q) : U;
    },
    !0
  ), j = N.map = {}, J = N.register = function(D, Q, ot, nt) {
    for (var vt, Gt, Xt, jt, Ne = Q.split(","), Re = Ne.length, ge = (ot || "easeIn,easeOut,easeInOut").split(","); --Re > -1; )
      for (Gt = Ne[Re], vt = nt ? b("easing." + Gt, null, !0) : B.easing[Gt] || {}, Xt = ge.length; --Xt > -1; )
        jt = ge[Xt], j[Gt + "." + jt] = j[jt + Gt] = vt[jt] = D.getRatio ? D : D[jt] || new D();
  };
  for (T = N.prototype, T._calcEnd = !1, T.getRatio = function(D) {
    if (this._func)
      return this._params[0] = D, this._func.apply(null, this._params);
    var Q = this._type, ot = this._power, nt = Q === 1 ? 1 - D : Q === 2 ? D : 0.5 > D ? 2 * D : 2 * (1 - D);
    return ot === 1 ? nt *= nt : ot === 2 ? nt *= nt * nt : ot === 3 ? nt *= nt * nt * nt : ot === 4 && (nt *= nt * nt * nt * nt), Q === 1 ? 1 - nt : Q === 2 ? nt : 0.5 > D ? nt / 2 : 1 - nt / 2;
  }, m = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], _ = m.length; --_ > -1; )
    T = m[_] + ",Power" + _, J(new N(null, null, 1, _), T, "easeOut", !0), J(new N(null, null, 2, _), T, "easeIn" + (_ === 0 ? ",easeNone" : "")), J(new N(null, null, 3, _), T, "easeInOut");
  j.linear = B.easing.Linear.easeIn, j.swing = B.easing.Quad.easeInOut;
  var $ = b("events.EventDispatcher", function(D) {
    this._listeners = {}, this._eventTarget = D || this;
  });
  T = $.prototype, T.addEventListener = function(D, Q, ot, nt, vt) {
    vt = vt || 0;
    var Gt, Xt, jt = this._listeners[D], Ne = 0;
    for (this !== S || C || S.wake(), jt == null && (this._listeners[D] = jt = []), Xt = jt.length; --Xt > -1; )
      Gt = jt[Xt], Gt.c === Q && Gt.s === ot ? jt.splice(Xt, 1) : Ne === 0 && Gt.pr < vt && (Ne = Xt + 1);
    jt.splice(Ne, 0, { c: Q, s: ot, up: nt, pr: vt });
  }, T.removeEventListener = function(D, Q) {
    var ot, nt = this._listeners[D];
    if (nt) {
      for (ot = nt.length; --ot > -1; )
        if (nt[ot].c === Q)
          return void nt.splice(ot, 1);
    }
  }, T.dispatchEvent = function(D) {
    var Q, ot, nt, vt = this._listeners[D];
    if (vt)
      for (Q = vt.length, Q > 1 && (vt = vt.slice(0)), ot = this._eventTarget; --Q > -1; )
        nt = vt[Q], nt && (nt.up ? nt.c.call(nt.s || ot, { type: D, target: ot }) : nt.c.call(nt.s || ot));
  };
  var ct = w.requestAnimationFrame, It = w.cancelAnimationFrame, et = Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  }, yt = et();
  for (m = ["ms", "moz", "webkit", "o"], _ = m.length; --_ > -1 && !ct; )
    ct = w[m[_] + "RequestAnimationFrame"], It = w[m[_] + "CancelAnimationFrame"] || w[m[_] + "CancelRequestAnimationFrame"];
  b("Ticker", function(D, Q) {
    var ot, nt, vt, Gt, Xt, jt = this, Ne = et(), Re = Q !== !1 && ct ? "auto" : !1, ge = 500, we = 33, vi = "tick", Mi = function(ni) {
      var Si, Gr, er = et() - yt;
      er > ge && (Ne += er - we), yt += er, jt.time = (yt - Ne) / 1e3, Si = jt.time - Xt, (!ot || Si > 0 || ni === !0) && (jt.frame++, Xt += Si + (Si >= Gt ? 4e-3 : Gt - Si), Gr = !0), ni !== !0 && (vt = nt(Mi)), Gr && jt.dispatchEvent(vi);
    };
    $.call(jt), jt.time = jt.frame = 0, jt.tick = function() {
      Mi(!0);
    }, jt.lagSmoothing = function(ni, Si) {
      return arguments.length ? (ge = ni || 1 / I, void (we = Math.min(Si, ge, 0))) : 1 / I > ge;
    }, jt.sleep = function() {
      vt != null && (Re && It ? It(vt) : clearTimeout(vt), nt = E, vt = null, jt === S && (C = !1));
    }, jt.wake = function(ni) {
      vt !== null ? jt.sleep() : ni ? Ne += -yt + (yt = et()) : jt.frame > 10 && (yt = et() - ge + 5), nt = ot === 0 ? E : Re && ct ? ct : function(Si) {
        return setTimeout(Si, 1e3 * (Xt - jt.time) + 1 | 0);
      }, jt === S && (C = !0), Mi(2);
    }, jt.fps = function(ni) {
      return arguments.length ? (ot = ni, Gt = 1 / (ot || 60), Xt = this.time + Gt, void jt.wake()) : ot;
    }, jt.useRAF = function(ni) {
      return arguments.length ? (jt.sleep(), Re = ni, void jt.fps(ot)) : Re;
    }, jt.fps(D), setTimeout(function() {
      Re === "auto" && jt.frame < 5 && (p || {}).visibilityState !== "hidden" && jt.useRAF(!1);
    }, 1500);
  }), T = B.Ticker.prototype = new B.events.EventDispatcher(), T.constructor = B.Ticker;
  var G = b("core.Animation", function(D, Q) {
    if (this.vars = Q = Q || {}, this._duration = this._totalDuration = D || 0, this._delay = Number(Q.delay) || 0, this._timeScale = 1, this._active = Q.immediateRender === !0, this.data = Q.data, this._reversed = Q.reversed === !0, W) {
      C || S.wake();
      var ot = this.vars.useFrames ? Ji : W;
      ot.add(this, ot._time), this.vars.paused && this.paused(!0);
    }
  });
  S = G.ticker = new B.Ticker(), T = G.prototype, T._dirty = T._gc = T._initted = T._paused = !1, T._totalTime = T._time = 0, T._rawPrevTime = -1, T._next = T._last = T._onUpdate = T._timeline = T.timeline = null, T._paused = !1;
  var Pt = function() {
    C && et() - yt > 2e3 && ((p || {}).visibilityState !== "hidden" || !S.lagSmoothing()) && S.wake();
    var D = setTimeout(Pt, 2e3);
    D.unref && D.unref();
  };
  Pt(), T.play = function(D, Q) {
    return D != null && this.seek(D, Q), this.reversed(!1).paused(!1);
  }, T.pause = function(D, Q) {
    return D != null && this.seek(D, Q), this.paused(!0);
  }, T.resume = function(D, Q) {
    return D != null && this.seek(D, Q), this.paused(!1);
  }, T.seek = function(D, Q) {
    return this.totalTime(Number(D), Q !== !1);
  }, T.restart = function(D, Q) {
    return this.reversed(!1).paused(!1).totalTime(D ? -this._delay : 0, Q !== !1, !0);
  }, T.reverse = function(D, Q) {
    return D != null && this.seek(D || this.totalDuration(), Q), this.reversed(!0).paused(!1);
  }, T.render = function(D, Q, ot) {
  }, T.invalidate = function() {
    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this;
  }, T.isActive = function() {
    var D, Q = this._timeline, ot = this._startTime;
    return !Q || !this._gc && !this._paused && Q.isActive() && (D = Q.rawTime(!0)) >= ot && D < ot + this.totalDuration() / this._timeScale - 1e-7;
  }, T._enabled = function(D, Q) {
    return C || S.wake(), this._gc = !D, this._active = this.isActive(), Q !== !0 && (D && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !D && this.timeline && this._timeline._remove(this, !0)), !1;
  }, T._kill = function(D, Q) {
    return this._enabled(!1, !1);
  }, T.kill = function(D, Q) {
    return this._kill(D, Q), this;
  }, T._uncache = function(D) {
    for (var Q = D ? this : this.timeline; Q; )
      Q._dirty = !0, Q = Q.timeline;
    return this;
  }, T._swapSelfInParams = function(D) {
    for (var Q = D.length, ot = D.concat(); --Q > -1; )
      D[Q] === "{self}" && (ot[Q] = this);
    return ot;
  }, T._callback = function(D) {
    var Q = this.vars, ot = Q[D], nt = Q[D + "Params"], vt = Q[D + "Scope"] || Q.callbackScope || this, Gt = nt ? nt.length : 0;
    switch (Gt) {
      case 0:
        ot.call(vt);
        break;
      case 1:
        ot.call(vt, nt[0]);
        break;
      case 2:
        ot.call(vt, nt[0], nt[1]);
        break;
      default:
        ot.apply(vt, nt);
    }
  }, T.eventCallback = function(D, Q, ot, nt) {
    if ((D || "").substr(0, 2) === "on") {
      var vt = this.vars;
      if (arguments.length === 1)
        return vt[D];
      Q == null ? delete vt[D] : (vt[D] = Q, vt[D + "Params"] = L(ot) && ot.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(ot) : ot, vt[D + "Scope"] = nt), D === "onUpdate" && (this._onUpdate = Q);
    }
    return this;
  }, T.delay = function(D) {
    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + D - this._delay), this._delay = D, this) : this._delay;
  }, T.duration = function(D) {
    return arguments.length ? (this._duration = this._totalDuration = D, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && D !== 0 && this.totalTime(this._totalTime * (D / this._duration), !0), this) : (this._dirty = !1, this._duration);
  }, T.totalDuration = function(D) {
    return this._dirty = !1, arguments.length ? this.duration(D) : this._totalDuration;
  }, T.time = function(D, Q) {
    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(D > this._duration ? this._duration : D, Q)) : this._time;
  }, T.totalTime = function(D, Q, ot) {
    if (C || S.wake(), !arguments.length)
      return this._totalTime;
    if (this._timeline) {
      if (0 > D && !ot && (D += this.totalDuration()), this._timeline.smoothChildTiming) {
        this._dirty && this.totalDuration();
        var nt = this._totalDuration, vt = this._timeline;
        if (D > nt && !ot && (D = nt), this._startTime = (this._paused ? this._pauseTime : vt._time) - (this._reversed ? nt - D : D) / this._timeScale, vt._dirty || this._uncache(!1), vt._timeline)
          for (; vt._timeline; )
            vt._timeline._time !== (vt._startTime + vt._totalTime) / vt._timeScale && vt.totalTime(vt._totalTime, !0), vt = vt._timeline;
      }
      this._gc && this._enabled(!0, !1), (this._totalTime !== D || this._duration === 0) && (Ft.length && Wt(), this.render(D, Q, !1), Ft.length && Wt());
    }
    return this;
  }, T.progress = T.totalProgress = function(D, Q) {
    var ot = this.duration();
    return arguments.length ? this.totalTime(ot * D, Q) : ot ? this._time / ot : this.ratio;
  }, T.startTime = function(D) {
    return arguments.length ? (D !== this._startTime && (this._startTime = D, this.timeline && this.timeline._sortChildren && this.timeline.add(this, D - this._delay)), this) : this._startTime;
  }, T.endTime = function(D) {
    return this._startTime + (D != 0 ? this.totalDuration() : this.duration()) / this._timeScale;
  }, T.timeScale = function(D) {
    if (!arguments.length)
      return this._timeScale;
    var Q, ot;
    for (D = D || I, this._timeline && this._timeline.smoothChildTiming && (Q = this._pauseTime, ot = Q || Q === 0 ? Q : this._timeline.totalTime(), this._startTime = ot - (ot - this._startTime) * this._timeScale / D), this._timeScale = D, ot = this.timeline; ot && ot.timeline; )
      ot._dirty = !0, ot.totalDuration(), ot = ot.timeline;
    return this;
  }, T.reversed = function(D) {
    return arguments.length ? (D != this._reversed && (this._reversed = D, this.totalTime(
      this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime,
      !0
    )), this) : this._reversed;
  }, T.paused = function(D) {
    if (!arguments.length)
      return this._paused;
    var Q, ot, nt = this._timeline;
    return D != this._paused && nt && (C || D || S.wake(), Q = nt.rawTime(), ot = Q - this._pauseTime, !D && nt.smoothChildTiming && (this._startTime += ot, this._uncache(!1)), this._pauseTime = D ? Q : null, this._paused = D, this._active = this.isActive(), !D && ot !== 0 && this._initted && this.duration() && (Q = nt.smoothChildTiming ? this._totalTime : (Q - this._startTime) / this._timeScale, this.render(Q, Q === this._totalTime, !0))), this._gc && !D && this._enabled(!0, !1), this;
  };
  var Et = b("core.SimpleTimeline", function(D) {
    G.call(this, 0, D), this.autoRemoveChildren = this.smoothChildTiming = !0;
  });
  T = Et.prototype = new G(), T.constructor = Et, T.kill()._gc = !1, T._first = T._last = T._recent = null, T._sortChildren = !1, T.add = T.insert = function(D, Q, ot, nt) {
    var vt, Gt;
    if (D._startTime = Number(Q || 0) + D._delay, D._paused && this !== D._timeline && (D._pauseTime = this.rawTime() - (D._timeline.rawTime() - D._pauseTime)), D.timeline && D.timeline._remove(D, !0), D.timeline = D._timeline = this, D._gc && D._enabled(!0, !0), vt = this._last, this._sortChildren)
      for (Gt = D._startTime; vt && vt._startTime > Gt; )
        vt = vt._prev;
    return vt ? (D._next = vt._next, vt._next = D) : (D._next = this._first, this._first = D), D._next ? D._next._prev = D : this._last = D, D._prev = vt, this._recent = D, this._timeline && this._uncache(!0), this;
  }, T._remove = function(D, Q) {
    return D.timeline === this && (Q || D._enabled(!1, !0), D._prev ? D._prev._next = D._next : this._first === D && (this._first = D._next), D._next ? D._next._prev = D._prev : this._last === D && (this._last = D._prev), D._next = D._prev = D.timeline = null, D === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this;
  }, T.render = function(D, Q, ot) {
    var nt, vt = this._first;
    for (this._totalTime = this._time = this._rawPrevTime = D; vt; )
      nt = vt._next, (vt._active || D >= vt._startTime && !vt._paused && !vt._gc) && (vt._reversed ? vt.render(
        (vt._dirty ? vt.totalDuration() : vt._totalDuration) - (D - vt._startTime) * vt._timeScale,
        Q,
        ot
      ) : vt.render((D - vt._startTime) * vt._timeScale, Q, ot)), vt = nt;
  }, T.rawTime = function() {
    return C || S.wake(), this._totalTime;
  };
  var Ct = b(
    "TweenLite",
    function(D, Q, ot) {
      if (G.call(this, Q, ot), this.render = Ct.prototype.render, D == null)
        throw "Cannot tween a null target.";
      this.target = D = typeof D != "string" ? D : Ct.selector(D) || D;
      var nt, vt, Gt, Xt = D.jquery || D.length && D !== w && D[0] && (D[0] === w || D[0].nodeType && D[0].style && !D.nodeType), jt = this.vars.overwrite;
      if (this._overwrite = jt = jt == null ? cn[Ct.defaultOverwrite] : typeof jt == "number" ? jt >> 0 : cn[jt], (Xt || D instanceof Array || D.push && L(D)) && typeof D[0] != "number")
        for (this._targets = Gt = F(D), this._propLookup = [], this._siblings = [], nt = 0; nt < Gt.length; nt++)
          vt = Gt[nt], vt ? typeof vt != "string" ? vt.length && vt !== w && vt[0] && (vt[0] === w || vt[0].nodeType && vt[0].style && !vt.nodeType) ? (Gt.splice(nt--, 1), this._targets = Gt = Gt.concat(F(vt))) : (this._siblings[nt] = pt(vt, this, !1), jt === 1 && this._siblings[nt].length > 1 && Dt(vt, this, null, 1, this._siblings[nt])) : (vt = Gt[nt--] = Ct.selector(vt), typeof vt == "string" && Gt.splice(nt + 1, 1)) : Gt.splice(nt--, 1);
      else
        this._propLookup = {}, this._siblings = pt(D, this, !1), jt === 1 && this._siblings.length > 1 && Dt(D, this, null, 1, this._siblings);
      (this.vars.immediateRender || Q === 0 && this._delay === 0 && this.vars.immediateRender !== !1) && (this._time = -I, this.render(Math.min(0, -this._delay)));
    },
    !0
  ), ce = function(D) {
    return D && D.length && D !== w && D[0] && (D[0] === w || D[0].nodeType && D[0].style && !D.nodeType);
  }, re = function(D, Q) {
    var ot, nt = {};
    for (ot in D)
      Li[ot] || ot in Q && ot !== "transform" && ot !== "x" && ot !== "y" && ot !== "width" && ot !== "height" && ot !== "className" && ot !== "border" || !(!Oe[ot] || Oe[ot] && Oe[ot]._autoCSS) || (nt[ot] = D[ot], delete D[ot]);
    D.css = nt;
  };
  T = Ct.prototype = new G(), T.constructor = Ct, T.kill()._gc = !1, T.ratio = 0, T._firstPT = T._targets = T._overwrittenProps = T._startAt = null, T._notifyPluginsOfEnabled = T._lazy = !1, Ct.version = "2.0.2", Ct.defaultEase = T._ease = new N(null, null, 1, 1), Ct.defaultOverwrite = "auto", Ct.ticker = S, Ct.autoSleep = 120, Ct.lagSmoothing = function(D, Q) {
    S.lagSmoothing(D, Q);
  }, Ct.selector = w.$ || w.jQuery || function(D) {
    var Q = w.$ || w.jQuery;
    return Q ? (Ct.selector = Q, Q(D)) : (p || (p = w.document), p ? p.querySelectorAll ? p.querySelectorAll(D) : p.getElementById(D.charAt(0) === "#" ? D.substr(1) : D) : D);
  };
  var Ft = [], Ot = {}, Bt = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, ke = /[\+-]=-?[\.\d]/, fe = function(D) {
    for (var Q, ot = this._firstPT, nt = 1e-6; ot; )
      Q = ot.blob ? D === 1 && this.end != null ? this.end : D ? this.join("") : this.start : ot.c * D + ot.s, ot.m ? Q = ot.m.call(this._tween, Q, this._target || ot.t, this._tween) : nt > Q && Q > -nt && !ot.blob && (Q = 0), ot.f ? ot.fp ? ot.t[ot.p](ot.fp, Q) : ot.t[ot.p](Q) : ot.t[ot.p] = Q, ot = ot._next;
  }, Yt = function(D, Q, ot, nt) {
    var vt, Gt, Xt, jt, Ne, Re, ge, we = [], vi = 0, Mi = "", ni = 0;
    for (we.start = D, we.end = Q, D = we[0] = D + "", Q = we[1] = Q + "", ot && (ot(we), D = we[0], Q = we[1]), we.length = 0, vt = D.match(Bt) || [], Gt = Q.match(Bt) || [], nt && (nt._next = null, nt.blob = 1, we._firstPT = we._applyPT = nt), Ne = Gt.length, jt = 0; Ne > jt; jt++)
      ge = Gt[jt], Re = Q.substr(vi, Q.indexOf(ge, vi) - vi), Mi += Re || !jt ? Re : ",", vi += Re.length, ni ? ni = (ni + 1) % 5 : Re.substr(-5) === "rgba(" && (ni = 1), ge === vt[jt] || vt.length <= jt ? Mi += ge : (Mi && (we.push(Mi), Mi = ""), Xt = parseFloat(vt[jt]), we.push(Xt), we._firstPT = {
        _next: we._firstPT,
        t: we,
        p: we.length - 1,
        s: Xt,
        c: (ge.charAt(1) === "=" ? parseInt(ge.charAt(0) + "1", 10) * parseFloat(ge.substr(2)) : parseFloat(ge) - Xt) || 0,
        f: 0,
        m: ni && 4 > ni ? Math.round : 0
      }), vi += ge.length;
    return Mi += Q.substr(vi), Mi && we.push(Mi), we.setRatio = fe, ke.test(Q) && (we.end = null), we;
  }, ti = function(D, Q, ot, nt, vt, Gt, Xt, jt, Ne) {
    typeof nt == "function" && (nt = nt(Ne || 0, D));
    var Re, ge = typeof D[Q], we = ge !== "function" ? "" : Q.indexOf("set") || typeof D["get" + Q.substr(3)] != "function" ? Q : "get" + Q.substr(3), vi = ot !== "get" ? ot : we ? Xt ? D[we](Xt) : D[we]() : D[Q], Mi = typeof nt == "string" && nt.charAt(1) === "=", ni = {
      t: D,
      p: Q,
      s: vi,
      f: ge === "function",
      pg: 0,
      n: vt || Q,
      m: Gt ? typeof Gt == "function" ? Gt : Math.round : 0,
      pr: 0,
      c: Mi ? parseInt(nt.charAt(0) + "1", 10) * parseFloat(nt.substr(2)) : parseFloat(nt) - vi || 0
    };
    return (typeof vi != "number" || typeof nt != "number" && !Mi) && (Xt || isNaN(vi) || !Mi && isNaN(nt) || typeof vi == "boolean" || typeof nt == "boolean" ? (ni.fp = Xt, Re = Yt(
      vi,
      Mi ? parseFloat(ni.s) + ni.c + (ni.s + "").replace(/[0-9\-\.]/g, "") : nt,
      jt || Ct.defaultStringFilter,
      ni
    ), ni = {
      t: Re,
      p: "setRatio",
      s: 0,
      c: 1,
      f: 2,
      pg: 0,
      n: vt || Q,
      pr: 0,
      m: 0
    }) : (ni.s = parseFloat(vi), Mi || (ni.c = parseFloat(nt) - ni.s || 0))), ni.c ? ((ni._next = this._firstPT) && (ni._next._prev = ni), this._firstPT = ni, ni) : void 0;
  }, Ni = Ct._internals = {
    isArray: L,
    isSelector: ce,
    lazyTweens: Ft,
    blobDif: Yt
  }, Oe = Ct._plugins = {}, Ge = Ni.tweenLookup = {}, pi = 0, Li = Ni.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1
  }, cn = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    true: 1,
    false: 0
  }, Ji = G._rootFramesTimeline = new Et(), W = G._rootTimeline = new Et(), Jt = 30, Wt = Ni.lazyRender = function() {
    var D, Q = Ft.length;
    for (Ot = {}; --Q > -1; )
      D = Ft[Q], D && D._lazy !== !1 && (D.render(D._lazy[0], D._lazy[1], !0), D._lazy = !1);
    Ft.length = 0;
  };
  W._startTime = S.time, Ji._startTime = S.frame, W._active = Ji._active = !0, setTimeout(Wt, 1), G._updateRoot = Ct.render = function() {
    var D, Q, ot;
    if (Ft.length && Wt(), W.render((S.time - W._startTime) * W._timeScale, !1, !1), Ji.render((S.frame - Ji._startTime) * Ji._timeScale, !1, !1), Ft.length && Wt(), S.frame >= Jt) {
      Jt = S.frame + (parseInt(Ct.autoSleep, 10) || 120);
      for (ot in Ge) {
        for (Q = Ge[ot].tweens, D = Q.length; --D > -1; )
          Q[D]._gc && Q.splice(D, 1);
        Q.length === 0 && delete Ge[ot];
      }
      if (ot = W._first, (!ot || ot._paused) && Ct.autoSleep && !Ji._first && S._listeners.tick.length === 1) {
        for (; ot && ot._paused; )
          ot = ot._next;
        ot || S.sleep();
      }
    }
  }, S.addEventListener("tick", G._updateRoot);
  var pt = function(D, Q, ot) {
    var nt, vt, Gt = D._gsTweenID;
    if (Ge[Gt || (D._gsTweenID = Gt = "t" + pi++)] || (Ge[Gt] = { target: D, tweens: [] }), Q && (nt = Ge[Gt].tweens, nt[vt = nt.length] = Q, ot))
      for (; --vt > -1; )
        nt[vt] === Q && nt.splice(vt, 1);
    return Ge[Gt].tweens;
  }, dt = function(D, Q, ot, nt) {
    var vt, Gt, Xt = D.vars.onOverwrite;
    return Xt && (vt = Xt(D, Q, ot, nt)), Xt = Ct.onOverwrite, Xt && (Gt = Xt(D, Q, ot, nt)), vt !== !1 && Gt !== !1;
  }, Dt = function(D, Q, ot, nt, vt) {
    var Gt, Xt, jt, Ne;
    if (nt === 1 || nt >= 4) {
      for (Ne = vt.length, Gt = 0; Ne > Gt; Gt++)
        if ((jt = vt[Gt]) !== Q)
          jt._gc || jt._kill(null, D, Q) && (Xt = !0);
        else if (nt === 5)
          break;
      return Xt;
    }
    var Re, ge = Q._startTime + I, we = [], vi = 0, Mi = Q._duration === 0;
    for (Gt = vt.length; --Gt > -1; )
      (jt = vt[Gt]) === Q || jt._gc || jt._paused || (jt._timeline !== Q._timeline ? (Re = Re || ie(Q, 0, Mi), ie(jt, Re, Mi) === 0 && (we[vi++] = jt)) : jt._startTime <= ge && jt._startTime + jt.totalDuration() / jt._timeScale > ge && ((Mi || !jt._initted) && ge - jt._startTime <= 2e-10 || (we[vi++] = jt)));
    for (Gt = vi; --Gt > -1; )
      if (jt = we[Gt], Ne = jt._firstPT, nt === 2 && jt._kill(ot, D, Q) && (Xt = !0), nt !== 2 || !jt._firstPT && jt._initted && Ne) {
        if (nt !== 2 && !dt(jt, Q))
          continue;
        jt._enabled(!1, !1) && (Xt = !0);
      }
    return Xt;
  }, ie = function(D, Q, ot) {
    for (var nt = D._timeline, vt = nt._timeScale, Gt = D._startTime; nt._timeline; ) {
      if (Gt += nt._startTime, vt *= nt._timeScale, nt._paused)
        return -100;
      nt = nt._timeline;
    }
    return Gt /= vt, Gt > Q ? Gt - Q : ot && Gt === Q || !D._initted && 2 * I > Gt - Q ? I : (Gt += D.totalDuration() / D._timeScale / vt) > Q + I ? 0 : Gt - Q - I;
  };
  T._init = function() {
    var D, Q, ot, nt, vt, Gt, Xt = this.vars, jt = this._overwrittenProps, Ne = this._duration, Re = !!Xt.immediateRender, ge = Xt.ease;
    if (Xt.startAt) {
      this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), vt = {};
      for (nt in Xt.startAt)
        vt[nt] = Xt.startAt[nt];
      if (vt.data = "isStart", vt.overwrite = !1, vt.immediateRender = !0, vt.lazy = Re && Xt.lazy !== !1, vt.startAt = vt.delay = null, vt.onUpdate = Xt.onUpdate, vt.onUpdateParams = Xt.onUpdateParams, vt.onUpdateScope = Xt.onUpdateScope || Xt.callbackScope || this, this._startAt = Ct.to(this.target || {}, 0, vt), Re) {
        if (this._time > 0)
          this._startAt = null;
        else if (Ne !== 0)
          return;
      }
    } else if (Xt.runBackwards && Ne !== 0)
      if (this._startAt)
        this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
      else {
        this._time !== 0 && (Re = !1), ot = {};
        for (nt in Xt)
          Li[nt] && nt !== "autoCSS" || (ot[nt] = Xt[nt]);
        if (ot.overwrite = 0, ot.data = "isFromStart", ot.lazy = Re && Xt.lazy !== !1, ot.immediateRender = Re, this._startAt = Ct.to(this.target, 0, ot), Re) {
          if (this._time === 0)
            return;
        } else
          this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null);
      }
    if (this._ease = ge = ge ? ge instanceof N ? ge : typeof ge == "function" ? new N(ge, Xt.easeParams) : j[ge] || Ct.defaultEase : Ct.defaultEase, Xt.easeParams instanceof Array && ge.config && (this._ease = ge.config.apply(ge, Xt.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
      for (Gt = this._targets.length, D = 0; Gt > D; D++)
        this._initProps(
          this._targets[D],
          this._propLookup[D] = {},
          this._siblings[D],
          jt ? jt[D] : null,
          D
        ) && (Q = !0);
    else
      Q = this._initProps(
        this.target,
        this._propLookup,
        this._siblings,
        jt,
        0
      );
    if (Q && Ct._onPluginEvent("_onInitAllProps", this), jt && (this._firstPT || typeof this.target != "function" && this._enabled(!1, !1)), Xt.runBackwards)
      for (ot = this._firstPT; ot; )
        ot.s += ot.c, ot.c = -ot.c, ot = ot._next;
    this._onUpdate = Xt.onUpdate, this._initted = !0;
  }, T._initProps = function(D, Q, ot, nt, vt) {
    var Gt, Xt, jt, Ne, Re, ge;
    if (D == null)
      return !1;
    Ot[D._gsTweenID] && Wt(), this.vars.css || D.style && D !== w && D.nodeType && Oe.css && this.vars.autoCSS !== !1 && re(this.vars, D);
    for (Gt in this.vars)
      if (ge = this.vars[Gt], Li[Gt])
        ge && (ge instanceof Array || ge.push && L(ge)) && ge.join("").indexOf("{self}") !== -1 && (this.vars[Gt] = ge = this._swapSelfInParams(ge, this));
      else if (Oe[Gt] && (Ne = new Oe[Gt]())._onInitTween(D, this.vars[Gt], this, vt)) {
        for (this._firstPT = Re = {
          _next: this._firstPT,
          t: Ne,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: Gt,
          pg: 1,
          pr: Ne._priority,
          m: 0
        }, Xt = Ne._overwriteProps.length; --Xt > -1; )
          Q[Ne._overwriteProps[Xt]] = this._firstPT;
        (Ne._priority || Ne._onInitAllProps) && (jt = !0), (Ne._onDisable || Ne._onEnable) && (this._notifyPluginsOfEnabled = !0), Re._next && (Re._next._prev = Re);
      } else
        Q[Gt] = ti.call(
          this,
          D,
          Gt,
          "get",
          ge,
          Gt,
          0,
          null,
          this.vars.stringFilter,
          vt
        );
    return nt && this._kill(nt, D) ? this._initProps(D, Q, ot, nt, vt) : this._overwrite > 1 && this._firstPT && ot.length > 1 && Dt(D, this, Q, this._overwrite, ot) ? (this._kill(Q, D), this._initProps(D, Q, ot, nt, vt)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (Ot[D._gsTweenID] = !0), jt);
  }, T.render = function(D, Q, ot) {
    var nt, vt, Gt, Xt, jt = this._time, Ne = this._duration, Re = this._rawPrevTime;
    if (D >= Ne - 1e-7 && D >= 0)
      this._totalTime = this._time = Ne, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (nt = !0, vt = "onComplete", ot = ot || this._timeline.autoRemoveChildren), Ne === 0 && (this._initted || !this.vars.lazy || ot) && (this._startTime === this._timeline._duration && (D = 0), (0 > Re || 0 >= D && D >= -1e-7 || Re === I && this.data !== "isPause") && Re !== D && (ot = !0, Re > I && (vt = "onReverseComplete")), this._rawPrevTime = Xt = !Q || D || Re === D ? D : I);
    else if (1e-7 > D)
      this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (jt !== 0 || Ne === 0 && Re > 0) && (vt = "onReverseComplete", nt = this._reversed), 0 > D && (this._active = !1, Ne === 0 && (this._initted || !this.vars.lazy || ot) && (Re >= 0 && (Re !== I || this.data !== "isPause") && (ot = !0), this._rawPrevTime = Xt = !Q || D || Re === D ? D : I)), (!this._initted || this._startAt && this._startAt.progress()) && (ot = !0);
    else if (this._totalTime = this._time = D, this._easeType) {
      var ge = D / Ne, we = this._easeType, vi = this._easePower;
      (we === 1 || we === 3 && ge >= 0.5) && (ge = 1 - ge), we === 3 && (ge *= 2), vi === 1 ? ge *= ge : vi === 2 ? ge *= ge * ge : vi === 3 ? ge *= ge * ge * ge : vi === 4 && (ge *= ge * ge * ge * ge), we === 1 ? this.ratio = 1 - ge : we === 2 ? this.ratio = ge : 0.5 > D / Ne ? this.ratio = ge / 2 : this.ratio = 1 - ge / 2;
    } else
      this.ratio = this._ease.getRatio(D / Ne);
    if (this._time !== jt || ot) {
      if (!this._initted) {
        if (this._init(), !this._initted || this._gc)
          return;
        if (!ot && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
          return this._time = this._totalTime = jt, this._rawPrevTime = Re, Ft.push(this), void (this._lazy = [D, Q]);
        this._time && !nt ? this.ratio = this._ease.getRatio(this._time / Ne) : nt && this._ease._calcEnd && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1));
      }
      for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== jt && D >= 0 && (this._active = !0), jt === 0 && (this._startAt && (D >= 0 ? this._startAt.render(D, !0, ot) : vt || (vt = "_dummyGS")), this.vars.onStart && (this._time !== 0 || Ne === 0) && (Q || this._callback("onStart"))), Gt = this._firstPT; Gt; )
        Gt.f ? Gt.t[Gt.p](Gt.c * this.ratio + Gt.s) : Gt.t[Gt.p] = Gt.c * this.ratio + Gt.s, Gt = Gt._next;
      this._onUpdate && (0 > D && this._startAt && D !== -1e-4 && this._startAt.render(D, !0, ot), Q || (this._time !== jt || nt || ot) && this._callback("onUpdate")), vt && (!this._gc || ot) && (0 > D && this._startAt && !this._onUpdate && D !== -1e-4 && this._startAt.render(D, !0, ot), nt && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !Q && this.vars[vt] && this._callback(vt), Ne === 0 && this._rawPrevTime === I && Xt !== I && (this._rawPrevTime = 0));
    }
  }, T._kill = function(D, Q, ot) {
    if (D === "all" && (D = null), D == null && (Q == null || Q === this.target))
      return this._lazy = !1, this._enabled(!1, !1);
    Q = typeof Q != "string" ? Q || this._targets || this.target : Ct.selector(Q) || Q;
    var nt, vt, Gt, Xt, jt, Ne, Re, ge, we, vi = ot && this._time && ot._startTime === this._startTime && this._timeline === ot._timeline, Mi = this._firstPT;
    if ((L(Q) || ce(Q)) && typeof Q[0] != "number")
      for (nt = Q.length; --nt > -1; )
        this._kill(D, Q[nt], ot) && (Ne = !0);
    else {
      if (this._targets) {
        for (nt = this._targets.length; --nt > -1; )
          if (Q === this._targets[nt]) {
            jt = this._propLookup[nt] || {}, this._overwrittenProps = this._overwrittenProps || [], vt = this._overwrittenProps[nt] = D ? this._overwrittenProps[nt] || {} : "all";
            break;
          }
      } else {
        if (Q !== this.target)
          return !1;
        jt = this._propLookup, vt = this._overwrittenProps = D ? this._overwrittenProps || {} : "all";
      }
      if (jt) {
        if (Re = D || jt, ge = D !== vt && vt !== "all" && D !== jt && (typeof D != "object" || !D._tempKill), ot && (Ct.onOverwrite || this.vars.onOverwrite)) {
          for (Gt in Re)
            jt[Gt] && (we || (we = []), we.push(Gt));
          if ((we || !D) && !dt(this, ot, Q, we))
            return !1;
        }
        for (Gt in Re)
          (Xt = jt[Gt]) && (vi && (Xt.f ? Xt.t[Xt.p](Xt.s) : Xt.t[Xt.p] = Xt.s, Ne = !0), Xt.pg && Xt.t._kill(Re) && (Ne = !0), Xt.pg && Xt.t._overwriteProps.length !== 0 || (Xt._prev ? Xt._prev._next = Xt._next : Xt === this._firstPT && (this._firstPT = Xt._next), Xt._next && (Xt._next._prev = Xt._prev), Xt._next = Xt._prev = null), delete jt[Gt]), ge && (vt[Gt] = 1);
        !this._firstPT && this._initted && Mi && this._enabled(!1, !1);
      }
    }
    return Ne;
  }, T.invalidate = function() {
    return this._notifyPluginsOfEnabled && Ct._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], G.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -I, this.render(Math.min(0, -this._delay))), this;
  }, T._enabled = function(D, Q) {
    if (C || S.wake(), D && this._gc) {
      var ot, nt = this._targets;
      if (nt)
        for (ot = nt.length; --ot > -1; )
          this._siblings[ot] = pt(nt[ot], this, !0);
      else
        this._siblings = pt(this.target, this, !0);
    }
    return G.prototype._enabled.call(this, D, Q), this._notifyPluginsOfEnabled && this._firstPT ? Ct._onPluginEvent(D ? "_onEnable" : "_onDisable", this) : !1;
  }, Ct.to = function(D, Q, ot) {
    return new Ct(D, Q, ot);
  }, Ct.from = function(D, Q, ot) {
    return ot.runBackwards = !0, ot.immediateRender = ot.immediateRender != 0, new Ct(D, Q, ot);
  }, Ct.fromTo = function(D, Q, ot, nt) {
    return nt.startAt = ot, nt.immediateRender = nt.immediateRender != 0 && ot.immediateRender != 0, new Ct(D, Q, nt);
  }, Ct.delayedCall = function(D, Q, ot, nt, vt) {
    return new Ct(Q, 0, {
      delay: D,
      onComplete: Q,
      onCompleteParams: ot,
      callbackScope: nt,
      onReverseComplete: Q,
      onReverseCompleteParams: ot,
      immediateRender: !1,
      lazy: !1,
      useFrames: vt,
      overwrite: 0
    });
  }, Ct.set = function(D, Q) {
    return new Ct(D, 0, Q);
  }, Ct.getTweensOf = function(D, Q) {
    if (D == null)
      return [];
    D = typeof D != "string" ? D : Ct.selector(D) || D;
    var ot, nt, vt, Gt;
    if ((L(D) || ce(D)) && typeof D[0] != "number") {
      for (ot = D.length, nt = []; --ot > -1; )
        nt = nt.concat(Ct.getTweensOf(D[ot], Q));
      for (ot = nt.length; --ot > -1; )
        for (Gt = nt[ot], vt = ot; --vt > -1; )
          Gt === nt[vt] && nt.splice(ot, 1);
    } else if (D._gsTweenID)
      for (nt = pt(D).concat(), ot = nt.length; --ot > -1; )
        (nt[ot]._gc || Q && !nt[ot].isActive()) && nt.splice(ot, 1);
    return nt || [];
  }, Ct.killTweensOf = Ct.killDelayedCallsTo = function(D, Q, ot) {
    typeof Q == "object" && (ot = Q, Q = !1);
    for (var nt = Ct.getTweensOf(D, Q), vt = nt.length; --vt > -1; )
      nt[vt]._kill(ot, D);
  };
  var Kt = b(
    "plugins.TweenPlugin",
    function(D, Q) {
      this._overwriteProps = (D || "").split(","), this._propName = this._overwriteProps[0], this._priority = Q || 0, this._super = Kt.prototype;
    },
    !0
  );
  if (T = Kt.prototype, Kt.version = "1.19.0", Kt.API = 2, T._firstPT = null, T._addTween = ti, T.setRatio = fe, T._kill = function(D) {
    var Q, ot = this._overwriteProps, nt = this._firstPT;
    if (D[this._propName] != null)
      this._overwriteProps = [];
    else
      for (Q = ot.length; --Q > -1; )
        D[ot[Q]] != null && ot.splice(Q, 1);
    for (; nt; )
      D[nt.n] != null && (nt._next && (nt._next._prev = nt._prev), nt._prev ? (nt._prev._next = nt._next, nt._prev = null) : this._firstPT === nt && (this._firstPT = nt._next)), nt = nt._next;
    return !1;
  }, T._mod = T._roundProps = function(D) {
    for (var Q, ot = this._firstPT; ot; )
      Q = D[this._propName] || ot.n != null && D[ot.n.split(this._propName + "_").join("")], Q && typeof Q == "function" && (ot.f === 2 ? ot.t._applyPT.m = Q : ot.m = Q), ot = ot._next;
  }, Ct._onPluginEvent = function(D, Q) {
    var ot, nt, vt, Gt, Xt, jt = Q._firstPT;
    if (D === "_onInitAllProps") {
      for (; jt; ) {
        for (Xt = jt._next, nt = vt; nt && nt.pr > jt.pr; )
          nt = nt._next;
        (jt._prev = nt ? nt._prev : Gt) ? jt._prev._next = jt : vt = jt, (jt._next = nt) ? nt._prev = jt : Gt = jt, jt = Xt;
      }
      jt = Q._firstPT = vt;
    }
    for (; jt; )
      jt.pg && typeof jt.t[D] == "function" && jt.t[D]() && (ot = !0), jt = jt._next;
    return ot;
  }, Kt.activate = function(D) {
    for (var Q = D.length; --Q > -1; )
      D[Q].API === Kt.API && (Oe[new D[Q]()._propName] = D[Q]);
    return !0;
  }, R.plugin = function(D) {
    if (!(D && D.propName && D.init && D.API))
      throw "illegal plugin definition.";
    var Q, ot = D.propName, nt = D.priority || 0, vt = D.overwriteProps, Gt = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    }, Xt = b(
      "plugins." + ot.charAt(0).toUpperCase() + ot.substr(1) + "Plugin",
      function() {
        Kt.call(this, ot, nt), this._overwriteProps = vt || [];
      },
      D.global === !0
    ), jt = Xt.prototype = new Kt(ot);
    jt.constructor = Xt, Xt.API = D.API;
    for (Q in Gt)
      typeof D[Q] == "function" && (jt[Gt[Q]] = D[Q]);
    return Xt.version = D.version, Kt.activate([Xt]), Xt;
  }, m = w._gsQueue) {
    for (_ = 0; _ < m.length; _++)
      m[_]();
    for (T in x)
      x[T].func || w.console.log("GSAP encountered missing dependency: " + T);
  }
  C = !1;
}(
  typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window,
  "TweenMax"
);
const O_ = { class: "modal-background" }, I_ = ["innerHTML"], D_ = {
  name: "MapModali"
}, z_ = /* @__PURE__ */ tf({
  ...D_,
  props: {
    // text: {
    //   type: String,
    //   default: "CHBIM云平台",
    // },
  },
  setup(w, { expose: l }) {
    const o = kc(""), p = kc(""), d = (m) => {
      p.value = m, o.value = "five";
    }, u = () => {
      o.value = o.value + " out";
    };
    return ef(() => {
    }), l({
      text: p,
      show: d,
      hide: u
    }), (m, _) => (ju(), Xu("div", {
      id: "modal-container",
      class: Ip(o.value),
      onClick: u
    }, [
      Mr("div", O_, [
        Mr("div", {
          class: "modal",
          onClick: _[0] || (_[0] = (T) => {
            T.stopPropagation();
          })
        }, [
          Mr("p", {
            style: { "white-space": "pre-line", "line-height": "1", margin: "0", color: "#fff" },
            innerHTML: p.value
          }, null, 8, I_)
        ])
      ])
    ], 2));
  }
});
const k_ = { class: "bim_background_plate" }, B_ = { class: "content" }, N_ = /* @__PURE__ */ Mr("canvas", { class: "landscape" }, null, -1), F_ = { class: "content__title" }, U_ = /* @__PURE__ */ Mr("div", { class: "overlay" }, null, -1), G_ = {
  name: "BimBackgroundPlate"
}, H_ = /* @__PURE__ */ tf({
  ...G_,
  setup(w) {
    const l = () => {
      let d = `
          vec3 mod289(vec3 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 mod289(vec4 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 permute(vec4 x)
          {
          	return mod289(((x*34.0)+1.0)*x);
          }

          vec4 taylorInvSqrt(vec4 r)
          {
          	return 1.79284291400159 - 0.85373472095314 * r;
          }

          vec3 fade(vec3 t) {
          	return t*t*t*(t*(t*6.0-15.0)+10.0);
          }

          // Classic Perlin noise
          float cnoise(vec3 P)
          {
          	vec3 Pi0 = floor(P); // Integer part for indexing
          	vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          // Classic Perlin noise, periodic variant
          float pnoise(vec3 P, vec3 rep)
          {
          	vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
          	vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          #define PI 3.1415926535897932384626433832795

          uniform float time;
          uniform float scroll;
          uniform float maxHeight;
          uniform float speed;
          uniform float distortCenter;
          uniform float roadWidth;
          varying float vDisplace;

          varying float fogDepth;

          void main(){

          	float t = time * speed;
          	float wRoad = distortCenter;
          	float wRoad2 = wRoad * 0.5;

          	float angleCenter = uv.y * PI*4.0;
          	angleCenter += t * 0.9;

          	float centerOff = (
          		sin(angleCenter) +
          		sin(angleCenter*0.5)
          	) * wRoad;


          	vec3 noiseIn = vec3(uv, 1.0)*10.0;
          	float noise = cnoise(vec3(noiseIn.x, noiseIn.y + scroll, noiseIn.z));
          	noise += 1.0;
          	float h = noise;
          	float angle = (uv.x - centerOff) * PI;
          	float f = abs(cos(angle));
          	h *= pow(f, 1.5 + roadWidth);


          	vDisplace = h;


          	h*=maxHeight;

          	vec3 transformed = vec3( position.x, position.y, position.z + h );


          	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
          	gl_Position = projectionMatrix * mvPosition;

          	fogDepth = -mvPosition.z;

          }
`, u = `
   uniform float time;
          uniform vec3 color;
          uniform sampler2D pallete;
          varying float vDisplace;

          uniform vec3 fogColor;
          uniform float fogNear;
          uniform float fogFar;
          varying float fogDepth;

          void main(){

          	vec2 stripPos = vec2( 0.0, vDisplace * (sin(time)*0.5+0.7) );
          	vec4 stripColor = texture2D( pallete, stripPos );
          	stripColor *= pow(1.0-vDisplace, 1.0);

          	gl_FragColor = stripColor;

          	#ifdef USE_FOG
          		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
          		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
          	#endif
          }`;
      var m = document.querySelector(".landscape"), _ = window.innerWidth, T = window.innerHeight, S, C, z, B, I = { x: 0, y: 0, xDamped: 0, yDamped: 0 }, F = typeof window.orientation < "u";
      E();
      function E() {
        L(), x(), M(), N(), F ? window.addEventListener("touchmove", U, { passive: !1 }) : window.addEventListener("mousemove", U), window.addEventListener("resize", b), b();
      }
      function L() {
        S = new THREE.Scene();
        var $ = new THREE.Color(3355443);
        S.background = $, S.fog = new THREE.Fog($, 0, 400), R(), z = new THREE.PerspectiveCamera(60, _ / T, 0.1, 1e4), z.position.y = 8, z.position.z = 4;
        let ct = new THREE.AmbientLight(16777215, 1);
        S.add(ct), C = new THREE.WebGLRenderer({
          canvas: m,
          antialias: !0
        }), C.setPixelRatio = devicePixelRatio, C.setSize(_, T);
      }
      function x() {
        var $ = new THREE.PlaneBufferGeometry(100, 400, 400, 400), ct = {
          time: { type: "f", value: 0 },
          scroll: { type: "f", value: 0 },
          distortCenter: { type: "f", value: 0.1 },
          roadWidth: { type: "f", value: 0.5 },
          pallete: { type: "t", value: null },
          speed: { type: "f", value: 3 },
          maxHeight: { type: "f", value: 10 },
          color: new THREE.Color(1, 1, 1)
        }, It = new THREE.ShaderMaterial({
          uniforms: THREE.UniformsUtils.merge([
            THREE.ShaderLib.basic.uniforms,
            ct
          ]),
          vertexShader: d,
          fragmentShader: u,
          wireframe: !1,
          fog: !0
        });
        B = new THREE.Mesh($, It), B.position.z = -180, B.rotation.x = -Math.PI / 2, S.add(B);
      }
      function M() {
        new THREE.TextureLoader().load("", function($) {
          B.material.uniforms.pallete.value = $, B.material.needsUpdate = !0;
        });
      }
      function R() {
        R = new THREE.Sky(), R.scale.setScalar(45e4), R.material.uniforms.turbidity.value = 13, R.material.uniforms.rayleigh.value = 1.2, R.material.uniforms.luminance.value = 1, R.material.uniforms.mieCoefficient.value = 0.1, R.material.uniforms.mieDirectionalG.value = 0.58, S.add(R);
        let $ = new THREE.Mesh(
          new THREE.SphereBufferGeometry(2e4, 16, 8),
          new THREE.MeshBasicMaterial({ color: 16777215 })
        );
        $.visible = !1, S.add($);
        var ct = Math.PI * -2e-3, It = 2 * Math.PI * -0.25;
        $.position.x = 4e5 * Math.cos(It), $.position.y = 4e5 * Math.sin(It) * Math.sin(ct), $.position.z = 4e5 * Math.sin(It) * Math.cos(ct), R.material.uniforms.sunPosition.value.copy($.position);
      }
      function b() {
        _ = window.innerWidth, T = window.innerHeight, z.aspect = _ / T, z.updateProjectionMatrix(), C.setSize(_, T);
      }
      function U($) {
        $.preventDefault();
        var ct, It;
        $.type == "mousemove" ? (ct = $.clientX, It = $.clientY) : (ct = $.changedTouches[0].clientX, It = $.changedTouches[0].clientY), I.x = ct, I.y = It;
      }
      function N() {
        requestAnimationFrame(N), I.xDamped = J(I.xDamped, I.x, 0.1), I.yDamped = J(I.yDamped, I.y, 0.1);
        var $ = performance.now() * 1e-3;
        B.material.uniforms.time.value = $, B.material.uniforms.scroll.value = $ + j(I.yDamped, 0, T, 0, 4), B.material.uniforms.distortCenter.value = Math.sin($) * 0.1, B.material.uniforms.roadWidth.value = j(
          I.xDamped,
          0,
          _,
          1,
          4.5
        ), z.position.y = j(I.yDamped, 0, T, 4, 11), C.render(S, z);
      }
      function j($, ct, It, et, yt) {
        return et + (yt - et) * (($ - ct) / (It - ct));
      }
      function J($, ct, It) {
        return (1 - It) * $ + It * ct;
      }
    }, o = () => {
      const d = document.querySelector(".overlay"), u = document.querySelector(".content__title");
      charming(u);
      const m = Array.from(u.querySelectorAll("span"));
      TweenMax.to(d, 2, {
        ease: Quad.easeOut,
        opacity: 0
      }), TweenMax.set(m, { opacity: 0 }), TweenMax.staggerTo(
        m,
        1.5,
        {
          ease: Expo.easeOut,
          startAt: { rotationX: -100, z: -1e3 },
          opacity: 1,
          rotationX: 0,
          z: 0
        },
        0.1
      );
    }, p = () => {
      l(), o();
    };
    return ef(() => {
      p();
    }), (d, u) => (ju(), Xu("div", k_, [
      Mr("div", B_, [
        N_,
        Mr("h2", F_, [
          Dp(d.$slots, "default")
        ])
      ]),
      U_
    ]));
  }
});
(function(w, l) {
  typeof exports == "object" && typeof module < "u" ? l(exports) : typeof define == "function" && define.amd ? define(["exports"], l) : l(w.THREE = {});
})(window, function(w) {
  function l() {
  }
  function o(t, e) {
    this.x = t || 0, this.y = e || 0;
  }
  function p() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function d(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = n !== void 0 ? n : 1;
  }
  function u(t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0;
  }
  function m() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function _(t, e, i, n, s, a, c, f, v, y) {
    Object.defineProperty(this, "id", { value: Io++ }), this.uuid = fi.generateUUID(), this.name = "", this.image = t !== void 0 ? t : _.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = e !== void 0 ? e : _.DEFAULT_MAPPING, this.wrapS = i !== void 0 ? i : 1001, this.wrapT = n !== void 0 ? n : 1001, this.magFilter = s !== void 0 ? s : 1006, this.minFilter = a !== void 0 ? a : 1008, this.anisotropy = v !== void 0 ? v : 1, this.format = c !== void 0 ? c : 1023, this.type = f !== void 0 ? f : 1009, this.offset = new o(0, 0), this.repeat = new o(1, 1), this.center = new o(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new m(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = y !== void 0 ? y : 3e3, this.version = 0, this.onUpdate = null;
  }
  function T(t, e, i, n) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n !== void 0 ? n : 1;
  }
  function S(t, e, i) {
    this.width = t, this.height = e, this.scissor = new T(0, 0, t, e), this.scissorTest = !1, this.viewport = new T(0, 0, t, e), i = i || {}, i.minFilter === void 0 && (i.minFilter = 1006), this.texture = new _(
      void 0,
      void 0,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    ), this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !0, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !0, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null;
  }
  function C(t, e, i) {
    S.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0;
  }
  function z(t, e, i, n, s, a, c, f, v, y, A, P) {
    _.call(this, null, a, c, f, v, y, n, s, A, P), this.image = { data: t, width: e, height: i }, this.magFilter = v !== void 0 ? v : 1003, this.minFilter = y !== void 0 ? y : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1;
  }
  function B(t, e) {
    this.min = t !== void 0 ? t : new u(1 / 0, 1 / 0, 1 / 0), this.max = e !== void 0 ? e : new u(-1 / 0, -1 / 0, -1 / 0);
  }
  function I(t, e) {
    this.center = t !== void 0 ? t : new u(), this.radius = e !== void 0 ? e : 0;
  }
  function F(t, e) {
    this.normal = t !== void 0 ? t : new u(1, 0, 0), this.constant = e !== void 0 ? e : 0;
  }
  function E(t, e, i, n, s, a) {
    this.planes = [
      t !== void 0 ? t : new F(),
      e !== void 0 ? e : new F(),
      i !== void 0 ? i : new F(),
      n !== void 0 ? n : new F(),
      s !== void 0 ? s : new F(),
      a !== void 0 ? a : new F()
    ];
  }
  function L(t, e, i) {
    return e === void 0 && i === void 0 ? this.set(t) : this.setRGB(t, e, i);
  }
  function x() {
    function t(s, a) {
      i !== !1 && (n(s, a), e.requestAnimationFrame(t));
    }
    var e = null, i = !1, n = null;
    return {
      start: function() {
        i !== !0 && n !== null && (e.requestAnimationFrame(t), i = !0);
      },
      stop: function() {
        i = !1;
      },
      setAnimationLoop: function(s) {
        n = s;
      },
      setContext: function(s) {
        e = s;
      }
    };
  }
  function M(t) {
    function e(n, s) {
      var a = n.array, c = n.dynamic ? 35048 : 35044, f = t.createBuffer();
      return t.bindBuffer(s, f), t.bufferData(s, a, c), n.onUploadCallback(), s = 5126, a instanceof Float32Array ? s = 5126 : a instanceof Float64Array ? console.warn(
        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
      ) : a instanceof Uint16Array ? s = 5123 : a instanceof Int16Array ? s = 5122 : a instanceof Uint32Array ? s = 5125 : a instanceof Int32Array ? s = 5124 : a instanceof Int8Array ? s = 5120 : a instanceof Uint8Array && (s = 5121), {
        buffer: f,
        type: s,
        bytesPerElement: a.BYTES_PER_ELEMENT,
        version: n.version
      };
    }
    var i = /* @__PURE__ */ new WeakMap();
    return {
      get: function(n) {
        return n.isInterleavedBufferAttribute && (n = n.data), i.get(n);
      },
      remove: function(n) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var s = i.get(n);
        s && (t.deleteBuffer(s.buffer), i.delete(n));
      },
      update: function(n, s) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var a = i.get(n);
        if (a === void 0)
          i.set(n, e(n, s));
        else if (a.version < n.version) {
          var c = n, f = c.array, v = c.updateRange;
          t.bindBuffer(s, a.buffer), c.dynamic === !1 ? t.bufferData(s, f, 35044) : v.count === -1 ? t.bufferSubData(s, 0, f) : v.count === 0 ? console.error(
            "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
          ) : (t.bufferSubData(
            s,
            v.offset * f.BYTES_PER_ELEMENT,
            f.subarray(v.offset, v.offset + v.count)
          ), v.count = -1), a.version = n.version;
        }
      }
    };
  }
  function R(t, e, i, n, s, a) {
    this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new u(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = s && s.isColor ? s : new L(), this.vertexColors = Array.isArray(s) ? s : [], this.materialIndex = a !== void 0 ? a : 0;
  }
  function b(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || b.DefaultOrder;
  }
  function U() {
    this.mask = 1;
  }
  function N() {
    Object.defineProperty(this, "id", { value: Ku++ }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = N.DefaultUp.clone();
    var t = new u(), e = new b(), i = new d(), n = new u(1, 1, 1);
    e.onChange(function() {
      i.setFromEuler(e, !1);
    }), i.onChange(function() {
      e.setFromQuaternion(i, void 0, !1);
    }), Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: t },
      rotation: { configurable: !0, enumerable: !0, value: e },
      quaternion: { configurable: !0, enumerable: !0, value: i },
      scale: { configurable: !0, enumerable: !0, value: n },
      modelViewMatrix: { value: new p() },
      normalMatrix: { value: new m() }
    }), this.matrix = new p(), this.matrixWorld = new p(), this.matrixAutoUpdate = N.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new U(), this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
  }
  function j() {
    Object.defineProperty(this, "id", { value: Qu += 2 }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function J(t, e, i) {
    if (Array.isArray(t))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i === !0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function $(t, e, i) {
    J.call(this, new Int8Array(t), e, i);
  }
  function ct(t, e, i) {
    J.call(this, new Uint8Array(t), e, i);
  }
  function It(t, e, i) {
    J.call(this, new Uint8ClampedArray(t), e, i);
  }
  function et(t, e, i) {
    J.call(this, new Int16Array(t), e, i);
  }
  function yt(t, e, i) {
    J.call(this, new Uint16Array(t), e, i);
  }
  function G(t, e, i) {
    J.call(this, new Int32Array(t), e, i);
  }
  function Pt(t, e, i) {
    J.call(this, new Uint32Array(t), e, i);
  }
  function Et(t, e, i) {
    J.call(this, new Float32Array(t), e, i);
  }
  function Ct(t, e, i) {
    J.call(this, new Float64Array(t), e, i);
  }
  function ce() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function re(t) {
    if (t.length === 0)
      return -1 / 0;
    for (var e = t[0], i = 1, n = t.length; i < n; ++i)
      t[i] > e && (e = t[i]);
    return e;
  }
  function Ft() {
    Object.defineProperty(this, "id", { value: tc += 2 }), this.uuid = fi.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  function Ot(t, e, i, n, s, a) {
    j.call(this), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: s,
      depthSegments: a
    }, this.fromBufferGeometry(new Bt(t, e, i, n, s, a)), this.mergeVertices();
  }
  function Bt(t, e, i, n, s, a) {
    function c(q, K, rt, xt, gt, At, wt, Vt, Z, st, zt) {
      var ee = At / Z, $t = wt / st, qt = At / 2, Te = wt / 2, me = Vt / 2;
      wt = Z + 1;
      var Ie = st + 1, be = At = 0, ae, We, Ke = new u();
      for (We = 0; We < Ie; We++) {
        var ci = We * $t - Te;
        for (ae = 0; ae < wt; ae++)
          Ke[q] = (ae * ee - qt) * xt, Ke[K] = ci * gt, Ke[rt] = me, y.push(Ke.x, Ke.y, Ke.z), Ke[q] = 0, Ke[K] = 0, Ke[rt] = 0 < Vt ? 1 : -1, A.push(Ke.x, Ke.y, Ke.z), P.push(ae / Z), P.push(1 - We / st), At += 1;
      }
      for (We = 0; We < st; We++)
        for (ae = 0; ae < Z; ae++)
          q = k + ae + wt * (We + 1), K = k + (ae + 1) + wt * (We + 1), rt = k + (ae + 1) + wt * We, v.push(k + ae + wt * We, q, rt), v.push(q, K, rt), be += 6;
      f.addGroup(H, be, zt), H += be, k += At;
    }
    Ft.call(this), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: s,
      depthSegments: a
    };
    var f = this;
    t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, s = Math.floor(s) || 1, a = Math.floor(a) || 1;
    var v = [], y = [], A = [], P = [], k = 0, H = 0;
    c("z", "y", "x", -1, -1, i, e, t, a, s, 0), c("z", "y", "x", 1, -1, i, e, -t, a, s, 1), c("x", "z", "y", 1, 1, t, i, e, n, a, 2), c("x", "z", "y", 1, -1, t, i, -e, n, a, 3), c("x", "y", "z", 1, -1, t, e, i, n, s, 4), c("x", "y", "z", -1, -1, t, e, -i, n, s, 5), this.setIndex(v), this.addAttribute("position", new Et(y, 3)), this.addAttribute("normal", new Et(A, 3)), this.addAttribute("uv", new Et(P, 2));
  }
  function ke(t, e, i, n) {
    j.call(this), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, this.fromBufferGeometry(new fe(t, e, i, n)), this.mergeVertices();
  }
  function fe(t, e, i, n) {
    Ft.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, t = t || 1, e = e || 1;
    var s = t / 2, a = e / 2;
    i = Math.floor(i) || 1, n = Math.floor(n) || 1;
    var c = i + 1, f = n + 1, v = t / i, y = e / n, A = [], P = [], k = [], H = [];
    for (t = 0; t < f; t++) {
      var q = t * y - a;
      for (e = 0; e < c; e++)
        P.push(e * v - s, -q, 0), k.push(0, 0, 1), H.push(e / i), H.push(1 - t / n);
    }
    for (t = 0; t < n; t++)
      for (e = 0; e < i; e++)
        s = e + c * (t + 1), a = e + 1 + c * (t + 1), f = e + 1 + c * t, A.push(e + c * t, s, f), A.push(s, a, f);
    this.setIndex(A), this.addAttribute("position", new Et(P, 3)), this.addAttribute("normal", new Et(k, 3)), this.addAttribute("uv", new Et(H, 2));
  }
  function Yt() {
    Object.defineProperty(this, "id", { value: cu++ }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0;
  }
  function ti(t) {
    Yt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, t !== void 0 && (t.attributes !== void 0 && console.error(
      "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
    ), this.setValues(t));
  }
  function Ni(t, e) {
    this.origin = t !== void 0 ? t : new u(), this.direction = e !== void 0 ? e : new u();
  }
  function Oe(t, e, i) {
    this.a = t !== void 0 ? t : new u(), this.b = e !== void 0 ? e : new u(), this.c = i !== void 0 ? i : new u();
  }
  function Ge(t) {
    Yt.call(this), this.type = "MeshBasicMaterial", this.color = new L(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function pi(t, e) {
    N.call(this), this.type = "Mesh", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Ge({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets();
  }
  function Li(t, e, i, n) {
    function s(y, A) {
      e.buffers.color.setClear(y.r, y.g, y.b, A, n);
    }
    var a = new L(0), c = 0, f, v;
    return {
      getClearColor: function() {
        return a;
      },
      setClearColor: function(y, A) {
        a.set(y), c = A !== void 0 ? A : 1, s(a, c);
      },
      getClearAlpha: function() {
        return c;
      },
      setClearAlpha: function(y) {
        c = y, s(a, c);
      },
      render: function(y, A, P, k) {
        A = A.background, A === null ? s(a, c) : A && A.isColor && (s(A, 1), k = !0), (t.autoClear || k) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), A && (A.isCubeTexture || A.isWebGLRenderTargetCube) ? (v === void 0 && (v = new pi(
          new Bt(1, 1, 1),
          new ti({
            type: "BackgroundCubeMaterial",
            uniforms: Dn.clone(ms.cube.uniforms),
            vertexShader: ms.cube.vertexShader,
            fragmentShader: ms.cube.fragmentShader,
            side: 1,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), v.geometry.removeAttribute("normal"), v.geometry.removeAttribute("uv"), v.onBeforeRender = function(H, q, K) {
          this.matrixWorld.copyPosition(K.matrixWorld);
        }, i.update(v)), v.material.uniforms.tCube.value = A.isWebGLRenderTargetCube ? A.texture : A, v.material.uniforms.tFlip.value = A.isWebGLRenderTargetCube ? 1 : -1, y.push(v, v.geometry, v.material, 0, null)) : A && A.isTexture && (f === void 0 && (f = new pi(
          new fe(2, 2),
          new ti({
            type: "BackgroundMaterial",
            uniforms: Dn.clone(ms.background.uniforms),
            vertexShader: ms.background.vertexShader,
            fragmentShader: ms.background.fragmentShader,
            side: 0,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), f.geometry.removeAttribute("normal"), i.update(f)), f.material.uniforms.t2D.value = A, A.matrixAutoUpdate === !0 && A.updateMatrix(), f.material.uniforms.uvTransform.value.copy(A.matrix), y.push(f, f.geometry, f.material, 0, null));
      }
    };
  }
  function cn(t, e, i, n) {
    var s;
    this.setMode = function(a) {
      s = a;
    }, this.render = function(a, c) {
      t.drawArrays(s, a, c), i.update(c, s);
    }, this.renderInstances = function(a, c, f) {
      if (n.isWebGL2)
        var v = t;
      else if (v = e.get("ANGLE_instanced_arrays"), v === null) {
        console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      v[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](
        s,
        c,
        f,
        a.maxInstancedCount
      ), i.update(f, s, a.maxInstancedCount);
    };
  }
  function Ji(t, e, i) {
    function n(xt) {
      if (xt === "highp") {
        if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision)
          return "highp";
        xt = "mediump";
      }
      return xt === "mediump" && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var s, a = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext, c = i.precision !== void 0 ? i.precision : "highp", f = n(c);
    f !== c && (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      f,
      "instead."
    ), c = f), i = i.logarithmicDepthBuffer === !0, f = t.getParameter(34930);
    var v = t.getParameter(35660), y = t.getParameter(3379), A = t.getParameter(34076), P = t.getParameter(34921), k = t.getParameter(36347), H = t.getParameter(36348), q = t.getParameter(36349), K = 0 < v, rt = a || !!e.get("OES_texture_float");
    return {
      isWebGL2: a,
      getMaxAnisotropy: function() {
        if (s !== void 0)
          return s;
        var xt = e.get("EXT_texture_filter_anisotropic");
        return s = xt !== null ? t.getParameter(xt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      },
      getMaxPrecision: n,
      precision: c,
      logarithmicDepthBuffer: i,
      maxTextures: f,
      maxVertexTextures: v,
      maxTextureSize: y,
      maxCubemapSize: A,
      maxAttributes: P,
      maxVertexUniforms: k,
      maxVaryings: H,
      maxFragmentUniforms: q,
      vertexTextures: K,
      floatFragmentTextures: rt,
      floatVertexTextures: K && rt
    };
  }
  function W() {
    function t() {
      y.value !== n && (y.value = n, y.needsUpdate = 0 < s), i.numPlanes = s, i.numIntersection = 0;
    }
    function e(A, P, k, H) {
      var q = A !== null ? A.length : 0, K = null;
      if (q !== 0) {
        if (K = y.value, H !== !0 || K === null)
          for (H = k + 4 * q, P = P.matrixWorldInverse, v.getNormalMatrix(P), (K === null || K.length < H) && (K = new Float32Array(H)), H = 0; H !== q; ++H, k += 4)
            f.copy(A[H]).applyMatrix4(P, v), f.normal.toArray(K, k), K[k + 3] = f.constant;
        y.value = K, y.needsUpdate = !0;
      }
      return i.numPlanes = q, K;
    }
    var i = this, n = null, s = 0, a = !1, c = !1, f = new F(), v = new m(), y = { value: null, needsUpdate: !1 };
    this.uniform = y, this.numIntersection = this.numPlanes = 0, this.init = function(A, P, k) {
      var H = A.length !== 0 || P || s !== 0 || a;
      return a = P, n = e(A, k, 0), s = A.length, H;
    }, this.beginShadows = function() {
      c = !0, e(null);
    }, this.endShadows = function() {
      c = !1, t();
    }, this.setState = function(A, P, k, H, q, K) {
      if (!a || A === null || A.length === 0 || c && !k)
        c ? e(null) : t();
      else {
        k = c ? 0 : s;
        var rt = 4 * k, xt = q.clippingState || null;
        for (y.value = xt, xt = e(A, H, rt, K), A = 0; A !== rt; ++A)
          xt[A] = n[A];
        q.clippingState = xt, this.numIntersection = P ? this.numPlanes : 0, this.numPlanes += k;
      }
    };
  }
  function Jt(t) {
    var e = {};
    return {
      get: function(i) {
        if (e[i] !== void 0)
          return e[i];
        switch (i) {
          case "WEBGL_depth_texture":
            var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = t.getExtension(i);
        }
        return n === null && console.warn(
          "THREE.WebGLRenderer: " + i + " extension not supported."
        ), e[i] = n;
      }
    };
  }
  function Wt(t, e, i) {
    function n(c) {
      var f = c.target;
      c = s[f.id], c.index !== null && e.remove(c.index);
      for (var v in c.attributes)
        e.remove(c.attributes[v]);
      f.removeEventListener("dispose", n), delete s[f.id], (v = a[c.id]) && (e.remove(v), delete a[c.id]), i.memory.geometries--;
    }
    var s = {}, a = {};
    return {
      get: function(c, f) {
        var v = s[f.id];
        return v || (f.addEventListener("dispose", n), f.isBufferGeometry ? v = f : f.isGeometry && (f._bufferGeometry === void 0 && (f._bufferGeometry = new Ft().setFromObject(c)), v = f._bufferGeometry), s[f.id] = v, i.memory.geometries++, v);
      },
      update: function(c) {
        var f = c.index, v = c.attributes;
        f !== null && e.update(f, 34963);
        for (var y in v)
          e.update(v[y], 34962);
        c = c.morphAttributes;
        for (y in c) {
          f = c[y], v = 0;
          for (var A = f.length; v < A; v++)
            e.update(f[v], 34962);
        }
      },
      getWireframeAttribute: function(c) {
        var f = a[c.id];
        if (f)
          return f;
        f = [];
        var v = c.index, y = c.attributes;
        if (v !== null) {
          v = v.array, y = 0;
          for (var A = v.length; y < A; y += 3) {
            var P = v[y + 0], k = v[y + 1], H = v[y + 2];
            f.push(P, k, k, H, H, P);
          }
        } else
          for (v = y.position.array, y = 0, A = v.length / 3 - 1; y < A; y += 3)
            P = y + 0, k = y + 1, H = y + 2, f.push(P, k, k, H, H, P);
        return f = new (65535 < re(f) ? Pt : yt)(f, 1), e.update(f, 34963), a[c.id] = f;
      }
    };
  }
  function pt(t, e, i, n) {
    var s, a, c;
    this.setMode = function(f) {
      s = f;
    }, this.setIndex = function(f) {
      a = f.type, c = f.bytesPerElement;
    }, this.render = function(f, v) {
      t.drawElements(s, v, a, f * c), i.update(v, s);
    }, this.renderInstances = function(f, v, y) {
      if (n.isWebGL2)
        var A = t;
      else if (A = e.get("ANGLE_instanced_arrays"), A === null) {
        console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      A[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](
        s,
        y,
        a,
        v * c,
        f.maxInstancedCount
      ), i.update(y, s, f.maxInstancedCount);
    };
  }
  function dt(t) {
    var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function() {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      },
      update: function(i, n, s) {
        switch (s = s || 1, e.calls++, n) {
          case 4:
            e.triangles += i / 3 * s;
            break;
          case 5:
          case 6:
            e.triangles += s * (i - 2);
            break;
          case 1:
            e.lines += i / 2 * s;
            break;
          case 3:
            e.lines += s * (i - 1);
            break;
          case 2:
            e.lines += s * i;
            break;
          case 0:
            e.points += s * i;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      }
    };
  }
  function Dt(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function ie(t) {
    var e = {}, i = new Float32Array(8);
    return {
      update: function(n, s, a, c) {
        var f = n.morphTargetInfluences, v = f.length;
        if (n = e[s.id], n === void 0) {
          n = [];
          for (var y = 0; y < v; y++)
            n[y] = [y, 0];
          e[s.id] = n;
        }
        var A = a.morphTargets && s.morphAttributes.position;
        for (a = a.morphNormals && s.morphAttributes.normal, y = 0; y < v; y++) {
          var P = n[y];
          P[1] !== 0 && (A && s.removeAttribute("morphTarget" + y), a && s.removeAttribute("morphNormal" + y));
        }
        for (y = 0; y < v; y++)
          P = n[y], P[0] = y, P[1] = f[y];
        for (n.sort(Dt), y = 0; 8 > y; y++) {
          if ((P = n[y]) && (f = P[0], v = P[1])) {
            A && s.addAttribute("morphTarget" + y, A[f]), a && s.addAttribute("morphNormal" + y, a[f]), i[y] = v;
            continue;
          }
          i[y] = 0;
        }
        c.getUniforms().setValue(t, "morphTargetInfluences", i);
      }
    };
  }
  function Kt(t, e) {
    var i = {};
    return {
      update: function(n) {
        var s = e.render.frame, a = n.geometry, c = t.get(n, a);
        return i[c.id] !== s && (a.isGeometry && c.updateFromObject(n), t.update(c), i[c.id] = s), c;
      },
      dispose: function() {
        i = {};
      }
    };
  }
  function D(t, e, i, n, s, a, c, f, v, y) {
    t = t !== void 0 ? t : [], _.call(this, t, e !== void 0 ? e : 301, i, n, s, a, c, f, v, y), this.flipY = !1;
  }
  function Q(t, e, i, n) {
    _.call(this, null), this.image = { data: t, width: e, height: i, depth: n }, this.minFilter = this.magFilter = 1003, this.flipY = this.generateMipmaps = !1;
  }
  function ot(t, e, i) {
    var n = t[0];
    if (0 >= n || 0 < n)
      return t;
    var s = e * i, a = Wl[s];
    if (a === void 0 && (a = new Float32Array(s), Wl[s] = a), e !== 0)
      for (n.toArray(a, 0), n = 1, s = 0; n !== e; ++n)
        s += i, t[n].toArray(a, s);
    return a;
  }
  function nt(t, e) {
    if (t.length !== e.length)
      return !1;
    for (var i = 0, n = t.length; i < n; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  function vt(t, e) {
    for (var i = 0, n = e.length; i < n; i++)
      t[i] = e[i];
  }
  function Gt(t, e) {
    var i = ya[e];
    i === void 0 && (i = new Int32Array(e), ya[e] = i);
    for (var n = 0; n !== e; ++n)
      i[n] = t.allocTextureUnit();
    return i;
  }
  function Xt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e);
  }
  function jt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e);
  }
  function Ne(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : nt(i, e) || (t.uniform2fv(this.addr, e), vt(i, e));
  }
  function Re(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : e.r !== void 0 ? (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : nt(i, e) || (t.uniform3fv(this.addr, e), vt(i, e));
  }
  function ge(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : nt(i, e) || (t.uniform4fv(this.addr, e), vt(i, e));
  }
  function we(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? nt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), vt(i, e)) : nt(i, n) || (Ah.set(n), t.uniformMatrix2fv(this.addr, !1, Ah), vt(i, n));
  }
  function vi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? nt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), vt(i, e)) : nt(i, n) || (pu.set(n), t.uniformMatrix3fv(this.addr, !1, pu), vt(i, n));
  }
  function Mi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? nt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), vt(i, e)) : nt(i, n) || (al.set(n), t.uniformMatrix4fv(this.addr, !1, al), vt(i, n));
  }
  function ni(t, e, i) {
    var n = this.cache, s = i.allocTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.setTexture2D(e || bh, s);
  }
  function Si(t, e, i) {
    var n = this.cache, s = i.allocTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.setTexture3D(e || ec, s);
  }
  function Gr(t, e, i) {
    var n = this.cache, s = i.allocTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.setTextureCube(e || fu, s);
  }
  function er(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform2iv(this.addr, e), vt(i, e));
  }
  function rn(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform3iv(this.addr, e), vt(i, e));
  }
  function bs(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform4iv(this.addr, e), vt(i, e));
  }
  function Ri(t) {
    switch (t) {
      case 5126:
        return Xt;
      case 35664:
        return Ne;
      case 35665:
        return Re;
      case 35666:
        return ge;
      case 35674:
        return we;
      case 35675:
        return vi;
      case 35676:
        return Mi;
      case 35678:
      case 36198:
        return ni;
      case 35679:
        return Si;
      case 35680:
        return Gr;
      case 5124:
      case 35670:
        return jt;
      case 35667:
      case 35671:
        return er;
      case 35668:
      case 35672:
        return rn;
      case 35669:
      case 35673:
        return bs;
    }
  }
  function Us(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform1fv(this.addr, e), vt(i, e));
  }
  function is(t, e) {
    var i = this.cache;
    nt(i, e) || (t.uniform1iv(this.addr, e), vt(i, e));
  }
  function bl(t, e) {
    var i = this.cache;
    e = ot(e, this.size, 2), nt(i, e) || (t.uniform2fv(this.addr, e), this.updateCache(e));
  }
  function xn(t, e) {
    var i = this.cache;
    e = ot(e, this.size, 3), nt(i, e) || (t.uniform3fv(this.addr, e), this.updateCache(e));
  }
  function Xo(t, e) {
    var i = this.cache;
    e = ot(e, this.size, 4), nt(i, e) || (t.uniform4fv(this.addr, e), this.updateCache(e));
  }
  function ho(t, e) {
    var i = this.cache;
    e = ot(e, this.size, 4), nt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), this.updateCache(e));
  }
  function dr(t, e) {
    var i = this.cache;
    e = ot(e, this.size, 9), nt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), this.updateCache(e));
  }
  function qo(t, e) {
    var i = this.cache;
    e = ot(e, this.size, 16), nt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), this.updateCache(e));
  }
  function Da(t, e, i) {
    var n = this.cache, s = e.length, a = Gt(i, s);
    for (nt(n, a) === !1 && (t.uniform1iv(this.addr, a), vt(n, a)), t = 0; t !== s; ++t)
      i.setTexture2D(e[t] || bh, a[t]);
  }
  function Al(t, e, i) {
    var n = this.cache, s = e.length, a = Gt(i, s);
    for (nt(n, a) === !1 && (t.uniform1iv(this.addr, a), vt(n, a)), t = 0; t !== s; ++t)
      i.setTextureCube(e[t] || fu, a[t]);
  }
  function ns(t) {
    switch (t) {
      case 5126:
        return Us;
      case 35664:
        return bl;
      case 35665:
        return xn;
      case 35666:
        return Xo;
      case 35674:
        return ho;
      case 35675:
        return dr;
      case 35676:
        return qo;
      case 35678:
        return Da;
      case 35680:
        return Al;
      case 5124:
      case 35670:
        return is;
      case 35667:
      case 35671:
        return er;
      case 35668:
      case 35672:
        return rn;
      case 35669:
      case 35673:
        return bs;
    }
  }
  function ch(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.setValue = Ri(e.type);
  }
  function Yo(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = ns(e.type);
  }
  function za(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  function rs(t, e, i) {
    this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, 35718);
    for (var n = 0; n < i; ++n) {
      var s = t.getActiveUniform(e, n), a = t.getUniformLocation(e, s.name), c = this, f = s.name, v = f.length;
      for (Ch.lastIndex = 0; ; ) {
        var y = Ch.exec(f), A = Ch.lastIndex, P = y[1], k = y[3];
        if (y[2] === "]" && (P |= 0), k === void 0 || k === "[" && A + 2 === v) {
          f = c, s = k === void 0 ? new ch(P, s, a) : new Yo(P, s, a), f.seq.push(s), f.map[s.id] = s;
          break;
        } else
          k = c.map[P], k === void 0 && (k = new za(P), P = c, c = k, P.seq.push(c), P.map[c.id] = c), c = k;
      }
    }
  }
  function ka(t) {
    t = t.split(`
`);
    for (var e = 0; e < t.length; e++)
      t[e] = e + 1 + ": " + t[e];
    return t.join(`
`);
  }
  function Zo(t, e, i) {
    var n = t.createShader(e);
    return t.shaderSource(n, i), t.compileShader(n), t.getShaderParameter(n, 35713) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), t.getShaderInfoLog(n) !== "" && console.warn(
      "THREE.WebGLShader: gl.getShaderInfoLog()",
      e === 35633 ? "vertex" : "fragment",
      t.getShaderInfoLog(n),
      ka(i)
    ), n;
  }
  function Jo(t) {
    switch (t) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw Error("unsupported encoding: " + t);
    }
  }
  function ss(t, e) {
    return e = Jo(e), "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }";
  }
  function Cl(t, e) {
    return e = Jo(e), "vec4 " + t + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
  }
  function fh(t, e) {
    switch (e) {
      case 1:
        e = "Linear";
        break;
      case 2:
        e = "Reinhard";
        break;
      case 3:
        e = "Uncharted2";
        break;
      case 4:
        e = "OptimizedCineon";
        break;
      default:
        throw Error("unsupported toneMapping: " + e);
    }
    return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
  }
  function ph(t, e, i) {
    return t = t || {}, [
      t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
      (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
      t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
      (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ].filter(co).join(`
`);
  }
  function uo(t) {
    var e = [], i;
    for (i in t) {
      var n = t[i];
      n !== !1 && e.push("#define " + i + " " + n);
    }
    return e.join(`
`);
  }
  function co(t) {
    return t !== "";
  }
  function Pl(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
  }
  function Ll(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
  }
  function Hr(t) {
    return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, i) {
      if (e = Ei[i], e === void 0)
        throw Error("Can not resolve #include <" + i + ">");
      return Hr(e);
    });
  }
  function V(t) {
    return t.replace(
      /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      function(e, i, n, s) {
        for (e = "", i = parseInt(i); i < parseInt(n); i++)
          e += s.replace(/\[ i \]/g, "[ " + i + " ]");
        return e;
      }
    );
  }
  function tt(t, e, i, n, s, a, c) {
    var f = t.context, v = n.defines, y = s.vertexShader, A = s.fragmentShader, P = "SHADOWMAP_TYPE_BASIC";
    a.shadowMapType === 1 ? P = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === 2 && (P = "SHADOWMAP_TYPE_PCF_SOFT");
    var k = "ENVMAP_TYPE_CUBE", H = "ENVMAP_MODE_REFLECTION", q = "ENVMAP_BLENDING_MULTIPLY";
    if (a.envMap) {
      switch (n.envMap.mapping) {
        case 301:
        case 302:
          k = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          k = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          k = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          k = "ENVMAP_TYPE_SPHERE";
      }
      switch (n.envMap.mapping) {
        case 302:
        case 304:
          H = "ENVMAP_MODE_REFRACTION";
      }
      switch (n.combine) {
        case 0:
          q = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          q = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          q = "ENVMAP_BLENDING_ADD";
      }
    }
    var K = 0 < t.gammaFactor ? t.gammaFactor : 1, rt = c.isWebGL2 ? "" : ph(n.extensions, a, e), xt = uo(v), gt = f.createProgram();
    n.isRawShaderMaterial ? (v = [xt].filter(co).join(`
`), 0 < v.length && (v += `
`), e = [rt, xt].filter(co).join(`
`), 0 < e.length && (e += `
`)) : (v = [
      "precision " + a.precision + " float;",
      "precision " + a.precision + " int;",
      "#define SHADER_NAME " + s.name,
      xt,
      a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + K,
      "#define MAX_BONES " + a.maxBones,
      a.useFog && a.fog ? "#define USE_FOG" : "",
      a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
      a.map ? "#define USE_MAP" : "",
      a.envMap ? "#define USE_ENVMAP" : "",
      a.envMap ? "#define " + H : "",
      a.lightMap ? "#define USE_LIGHTMAP" : "",
      a.aoMap ? "#define USE_AOMAP" : "",
      a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      a.bumpMap ? "#define USE_BUMPMAP" : "",
      a.normalMap ? "#define USE_NORMALMAP" : "",
      a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      a.specularMap ? "#define USE_SPECULARMAP" : "",
      a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      a.metalnessMap ? "#define USE_METALNESSMAP" : "",
      a.alphaMap ? "#define USE_ALPHAMAP" : "",
      a.vertexColors ? "#define USE_COLOR" : "",
      a.flatShading ? "#define FLAT_SHADED" : "",
      a.skinning ? "#define USE_SKINNING" : "",
      a.useVertexTexture ? "#define BONE_TEXTURE" : "",
      a.morphTargets ? "#define USE_MORPHTARGETS" : "",
      a.morphNormals && a.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
      a.doubleSided ? "#define DOUBLE_SIDED" : "",
      a.flipSided ? "#define FLIP_SIDED" : "",
      a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      a.shadowMapEnabled ? "#define " + P : "",
      a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      a.logarithmicDepthBuffer && (c.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(co).join(`
`), e = [
      rt,
      "precision " + a.precision + " float;",
      "precision " + a.precision + " int;",
      "#define SHADER_NAME " + s.name,
      xt,
      a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + K,
      a.useFog && a.fog ? "#define USE_FOG" : "",
      a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
      a.map ? "#define USE_MAP" : "",
      a.envMap ? "#define USE_ENVMAP" : "",
      a.envMap ? "#define " + k : "",
      a.envMap ? "#define " + H : "",
      a.envMap ? "#define " + q : "",
      a.lightMap ? "#define USE_LIGHTMAP" : "",
      a.aoMap ? "#define USE_AOMAP" : "",
      a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      a.bumpMap ? "#define USE_BUMPMAP" : "",
      a.normalMap ? "#define USE_NORMALMAP" : "",
      a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      a.specularMap ? "#define USE_SPECULARMAP" : "",
      a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      a.metalnessMap ? "#define USE_METALNESSMAP" : "",
      a.alphaMap ? "#define USE_ALPHAMAP" : "",
      a.vertexColors ? "#define USE_COLOR" : "",
      a.gradientMap ? "#define USE_GRADIENTMAP" : "",
      a.flatShading ? "#define FLAT_SHADED" : "",
      a.doubleSided ? "#define DOUBLE_SIDED" : "",
      a.flipSided ? "#define FLIP_SIDED" : "",
      a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      a.shadowMapEnabled ? "#define " + P : "",
      a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      a.logarithmicDepthBuffer && (c.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      a.envMap && (c.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      a.toneMapping !== 0 ? "#define TONE_MAPPING" : "",
      a.toneMapping !== 0 ? Ei.tonemapping_pars_fragment : "",
      a.toneMapping !== 0 ? fh("toneMapping", a.toneMapping) : "",
      a.dithering ? "#define DITHERING" : "",
      a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Ei.encodings_pars_fragment : "",
      a.mapEncoding ? ss("mapTexelToLinear", a.mapEncoding) : "",
      a.matcapEncoding ? ss("matcapTexelToLinear", a.matcapEncoding) : "",
      a.envMapEncoding ? ss("envMapTexelToLinear", a.envMapEncoding) : "",
      a.emissiveMapEncoding ? ss("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "",
      a.outputEncoding ? Cl("linearToOutputTexel", a.outputEncoding) : "",
      a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
      `
`
    ].filter(co).join(`
`)), y = Hr(y), y = Pl(y, a), y = Ll(y, a), A = Hr(A), A = Pl(A, a), A = Ll(A, a), y = V(y), A = V(A), c.isWebGL2 && !n.isRawShaderMaterial && (c = !1, P = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && y.match(P) !== null && A.match(P) !== null && (c = !0, y = y.replace(P, ""), A = A.replace(P, "")), v = `#version 300 es

#define attribute in
#define varying out
#define texture2D texture
` + v, e = [
      `#version 300 es

#define varying in`,
      c ? "" : "out highp vec4 pc_fragColor;",
      c ? "" : "#define gl_FragColor pc_fragColor",
      `#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad`
    ].join(`
`) + `
` + e), A = e + A, y = Zo(f, 35633, v + y), A = Zo(f, 35632, A), f.attachShader(gt, y), f.attachShader(gt, A), n.index0AttributeName !== void 0 ? f.bindAttribLocation(gt, 0, n.index0AttributeName) : a.morphTargets === !0 && f.bindAttribLocation(gt, 0, "position"), f.linkProgram(gt), a = f.getProgramInfoLog(gt).trim(), c = f.getShaderInfoLog(y).trim(), P = f.getShaderInfoLog(A).trim(), H = k = !0, f.getProgramParameter(gt, 35714) === !1 ? (k = !1, console.error(
      "THREE.WebGLProgram: shader error: ",
      f.getError(),
      "35715",
      f.getProgramParameter(gt, 35715),
      "gl.getProgramInfoLog",
      a,
      c,
      P
    )) : a !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a) : (c === "" || P === "") && (H = !1), H && (this.diagnostics = {
      runnable: k,
      material: n,
      programLog: a,
      vertexShader: { log: c, prefix: v },
      fragmentShader: { log: P, prefix: e }
    }), f.deleteShader(y), f.deleteShader(A);
    var At;
    this.getUniforms = function() {
      return At === void 0 && (At = new rs(f, gt, t)), At;
    };
    var wt;
    return this.getAttributes = function() {
      if (wt === void 0) {
        for (var Vt = {}, Z = f.getProgramParameter(gt, 35721), st = 0; st < Z; st++) {
          var zt = f.getActiveAttrib(gt, st).name;
          Vt[zt] = f.getAttribLocation(gt, zt);
        }
        wt = Vt;
      }
      return wt;
    }, this.destroy = function() {
      f.deleteProgram(gt), this.program = void 0;
    }, Object.defineProperties(this, {
      uniforms: {
        get: function() {
          return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
        }
      },
      attributes: {
        get: function() {
          return console.warn(
            "THREE.WebGLProgram: .attributes is now .getAttributes()."
          ), this.getAttributes();
        }
      }
    }), this.name = s.name, this.id = zs++, this.code = i, this.usedTimes = 1, this.program = gt, this.vertexShader = y, this.fragmentShader = A, this;
  }
  function lt(t, e, i) {
    function n(f, v) {
      if (f)
        f.isTexture ? y = f.encoding : f.isWebGLRenderTarget && (console.warn(
          "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
        ), y = f.texture.encoding);
      else
        var y = 3e3;
      return y === 3e3 && v && (y = 3007), y;
    }
    var s = [], a = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "phong",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    }, c = "precision supportsVertexTextures map mapEncoding matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(
      " "
    );
    this.getParameters = function(f, v, y, A, P, k, H) {
      var q = a[f.type];
      if (H.isSkinnedMesh) {
        var K = H.skeleton.bones;
        if (i.floatVertexTextures)
          K = 1024;
        else {
          var rt = Math.min(
            Math.floor((i.maxVertexUniforms - 20) / 4),
            K.length
          );
          rt < K.length ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " + K.length + " bones. This GPU supports " + rt + "."
          ), K = 0) : K = rt;
        }
      } else
        K = 0;
      rt = i.precision, f.precision !== null && (rt = i.getMaxPrecision(f.precision), rt !== f.precision && console.warn(
        "THREE.WebGLProgram.getParameters:",
        f.precision,
        "not supported, using",
        rt,
        "instead."
      ));
      var xt = t.getRenderTarget();
      return {
        shaderID: q,
        precision: rt,
        supportsVertexTextures: i.vertexTextures,
        outputEncoding: n(xt ? xt.texture : null, t.gammaOutput),
        map: !!f.map,
        mapEncoding: n(f.map, t.gammaInput),
        matcap: !!f.matcap,
        matcapEncoding: n(f.matcap, t.gammaInput),
        envMap: !!f.envMap,
        envMapMode: f.envMap && f.envMap.mapping,
        envMapEncoding: n(f.envMap, t.gammaInput),
        envMapCubeUV: !!f.envMap && (f.envMap.mapping === 306 || f.envMap.mapping === 307),
        lightMap: !!f.lightMap,
        aoMap: !!f.aoMap,
        emissiveMap: !!f.emissiveMap,
        emissiveMapEncoding: n(f.emissiveMap, t.gammaInput),
        bumpMap: !!f.bumpMap,
        normalMap: !!f.normalMap,
        objectSpaceNormalMap: f.normalMapType === 1,
        displacementMap: !!f.displacementMap,
        roughnessMap: !!f.roughnessMap,
        metalnessMap: !!f.metalnessMap,
        specularMap: !!f.specularMap,
        alphaMap: !!f.alphaMap,
        gradientMap: !!f.gradientMap,
        combine: f.combine,
        vertexColors: f.vertexColors,
        fog: !!A,
        useFog: f.fog,
        fogExp: A && A.isFogExp2,
        flatShading: f.flatShading,
        sizeAttenuation: f.sizeAttenuation,
        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
        skinning: f.skinning && 0 < K,
        maxBones: K,
        useVertexTexture: i.floatVertexTextures,
        morphTargets: f.morphTargets,
        morphNormals: f.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: v.directional.length,
        numPointLights: v.point.length,
        numSpotLights: v.spot.length,
        numRectAreaLights: v.rectArea.length,
        numHemiLights: v.hemi.length,
        numClippingPlanes: P,
        numClipIntersection: k,
        dithering: f.dithering,
        shadowMapEnabled: t.shadowMap.enabled && H.receiveShadow && 0 < y.length,
        shadowMapType: t.shadowMap.type,
        toneMapping: t.toneMapping,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: f.premultipliedAlpha,
        alphaTest: f.alphaTest,
        doubleSided: f.side === 2,
        flipSided: f.side === 1,
        depthPacking: f.depthPacking !== void 0 ? f.depthPacking : !1
      };
    }, this.getProgramCode = function(f, v) {
      var y = [];
      if (v.shaderID ? y.push(v.shaderID) : (y.push(f.fragmentShader), y.push(f.vertexShader)), f.defines !== void 0)
        for (var A in f.defines)
          y.push(A), y.push(f.defines[A]);
      for (A = 0; A < c.length; A++)
        y.push(v[c[A]]);
      return y.push(f.onBeforeCompile.toString()), y.push(t.gammaOutput), y.push(t.gammaFactor), y.join();
    }, this.acquireProgram = function(f, v, y, A) {
      for (var P, k = 0, H = s.length; k < H; k++) {
        var q = s[k];
        if (q.code === A) {
          P = q, ++P.usedTimes;
          break;
        }
      }
      return P === void 0 && (P = new tt(t, e, A, f, v, y, i), s.push(P)), P;
    }, this.releaseProgram = function(f) {
      if (--f.usedTimes === 0) {
        var v = s.indexOf(f);
        s[v] = s[s.length - 1], s.pop(), f.destroy();
      }
    }, this.programs = s;
  }
  function at() {
    var t = /* @__PURE__ */ new WeakMap();
    return {
      get: function(e) {
        var i = t.get(e);
        return i === void 0 && (i = {}, t.set(e, i)), i;
      },
      remove: function(e) {
        t.delete(e);
      },
      update: function(e, i, n) {
        t.get(e)[i] = n;
      },
      dispose: function() {
        t = /* @__PURE__ */ new WeakMap();
      }
    };
  }
  function X(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
  }
  function St(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
  }
  function ht() {
    var t = [], e = 0, i = [], n = [];
    return {
      opaque: i,
      transparent: n,
      init: function() {
        e = 0, i.length = 0, n.length = 0;
      },
      push: function(s, a, c, f, v) {
        var y = t[e];
        y === void 0 ? (y = {
          id: s.id,
          object: s,
          geometry: a,
          material: c,
          program: c.program,
          renderOrder: s.renderOrder,
          z: f,
          group: v
        }, t[e] = y) : (y.id = s.id, y.object = s, y.geometry = a, y.material = c, y.program = c.program, y.renderOrder = s.renderOrder, y.z = f, y.group = v), (c.transparent === !0 ? n : i).push(y), e++;
      },
      sort: function() {
        1 < i.length && i.sort(X), 1 < n.length && n.sort(St);
      }
    };
  }
  function Rt() {
    var t = {};
    return {
      get: function(e, i) {
        return e = e.id + "," + i.id, i = t[e], i === void 0 && (i = new ht(), t[e] = i), i;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function Ht() {
    var t = {};
    return {
      get: function(e) {
        if (t[e.id] !== void 0)
          return t[e.id];
        switch (e.type) {
          case "DirectionalLight":
            var i = {
              direction: new u(),
              color: new L(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new o()
            };
            break;
          case "SpotLight":
            i = {
              position: new u(),
              direction: new u(),
              color: new L(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new o()
            };
            break;
          case "PointLight":
            i = {
              position: new u(),
              color: new L(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new o(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case "HemisphereLight":
            i = { direction: new u(), skyColor: new L(), groundColor: new L() };
            break;
          case "RectAreaLight":
            i = {
              color: new L(),
              position: new u(),
              halfWidth: new u(),
              halfHeight: new u()
            };
        }
        return t[e.id] = i;
      }
    };
  }
  function kt() {
    var t = new Ht(), e = {
      id: Ph++,
      hash: {
        stateID: -1,
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        shadowsLength: -1
      },
      ambient: [0, 0, 0],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    }, i = new u(), n = new p(), s = new p();
    return {
      setup: function(a, c, f) {
        var v = 0, y = 0, A = 0, P = 0, k = 0, H = 0, q = 0, K = 0;
        f = f.matrixWorldInverse;
        for (var rt = 0, xt = a.length; rt < xt; rt++) {
          var gt = a[rt], At = gt.color, wt = gt.intensity, Vt = gt.distance, Z = gt.shadow && gt.shadow.map ? gt.shadow.map.texture : null;
          if (gt.isAmbientLight)
            v += At.r * wt, y += At.g * wt, A += At.b * wt;
          else if (gt.isDirectionalLight) {
            var st = t.get(gt);
            st.color.copy(gt.color).multiplyScalar(gt.intensity), st.direction.setFromMatrixPosition(gt.matrixWorld), i.setFromMatrixPosition(gt.target.matrixWorld), st.direction.sub(i), st.direction.transformDirection(f), (st.shadow = gt.castShadow) && (At = gt.shadow, st.shadowBias = At.bias, st.shadowRadius = At.radius, st.shadowMapSize = At.mapSize), e.directionalShadowMap[P] = Z, e.directionalShadowMatrix[P] = gt.shadow.matrix, e.directional[P] = st, P++;
          } else
            gt.isSpotLight ? (st = t.get(gt), st.position.setFromMatrixPosition(gt.matrixWorld), st.position.applyMatrix4(f), st.color.copy(At).multiplyScalar(wt), st.distance = Vt, st.direction.setFromMatrixPosition(gt.matrixWorld), i.setFromMatrixPosition(gt.target.matrixWorld), st.direction.sub(i), st.direction.transformDirection(f), st.coneCos = Math.cos(gt.angle), st.penumbraCos = Math.cos(gt.angle * (1 - gt.penumbra)), st.decay = gt.decay, (st.shadow = gt.castShadow) && (At = gt.shadow, st.shadowBias = At.bias, st.shadowRadius = At.radius, st.shadowMapSize = At.mapSize), e.spotShadowMap[H] = Z, e.spotShadowMatrix[H] = gt.shadow.matrix, e.spot[H] = st, H++) : gt.isRectAreaLight ? (st = t.get(gt), st.color.copy(At).multiplyScalar(wt), st.position.setFromMatrixPosition(gt.matrixWorld), st.position.applyMatrix4(f), s.identity(), n.copy(gt.matrixWorld), n.premultiply(f), s.extractRotation(n), st.halfWidth.set(0.5 * gt.width, 0, 0), st.halfHeight.set(0, 0.5 * gt.height, 0), st.halfWidth.applyMatrix4(s), st.halfHeight.applyMatrix4(s), e.rectArea[q] = st, q++) : gt.isPointLight ? (st = t.get(gt), st.position.setFromMatrixPosition(gt.matrixWorld), st.position.applyMatrix4(f), st.color.copy(gt.color).multiplyScalar(gt.intensity), st.distance = gt.distance, st.decay = gt.decay, (st.shadow = gt.castShadow) && (At = gt.shadow, st.shadowBias = At.bias, st.shadowRadius = At.radius, st.shadowMapSize = At.mapSize, st.shadowCameraNear = At.camera.near, st.shadowCameraFar = At.camera.far), e.pointShadowMap[k] = Z, e.pointShadowMatrix[k] = gt.shadow.matrix, e.point[k] = st, k++) : gt.isHemisphereLight && (st = t.get(gt), st.direction.setFromMatrixPosition(gt.matrixWorld), st.direction.transformDirection(f), st.direction.normalize(), st.skyColor.copy(gt.color).multiplyScalar(wt), st.groundColor.copy(gt.groundColor).multiplyScalar(wt), e.hemi[K] = st, K++);
        }
        e.ambient[0] = v, e.ambient[1] = y, e.ambient[2] = A, e.directional.length = P, e.spot.length = H, e.rectArea.length = q, e.point.length = k, e.hemi.length = K, e.hash.stateID = e.id, e.hash.directionalLength = P, e.hash.pointLength = k, e.hash.spotLength = H, e.hash.rectAreaLength = q, e.hash.hemiLength = K, e.hash.shadowsLength = c.length;
      },
      state: e
    };
  }
  function Mt() {
    var t = new kt(), e = [], i = [];
    return {
      init: function() {
        e.length = 0, i.length = 0;
      },
      state: { lightsArray: e, shadowsArray: i, lights: t },
      setupLights: function(n) {
        t.setup(e, i, n);
      },
      pushLight: function(n) {
        e.push(n);
      },
      pushShadow: function(n) {
        i.push(n);
      }
    };
  }
  function he() {
    var t = {};
    return {
      get: function(e, i) {
        if (t[e.id] === void 0) {
          var n = new Mt();
          t[e.id] = {}, t[e.id][i.id] = n;
        } else
          t[e.id][i.id] === void 0 ? (n = new Mt(), t[e.id][i.id] = n) : n = t[e.id][i.id];
        return n;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function oe(t) {
    Yt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t);
  }
  function te(t) {
    Yt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new u(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t);
  }
  function _e(t, e, i) {
    function n(Z, st, zt, ee, $t, qt) {
      var Te = Z.geometry, me = P, Ie = Z.customDepthMaterial;
      return zt && (me = k, Ie = Z.customDistanceMaterial), Ie ? me = Ie : (Ie = !1, st.morphTargets && (Te && Te.isBufferGeometry ? Ie = Te.morphAttributes && Te.morphAttributes.position && 0 < Te.morphAttributes.position.length : Te && Te.isGeometry && (Ie = Te.morphTargets && 0 < Te.morphTargets.length)), Z.isSkinnedMesh && st.skinning === !1 && console.warn(
        "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
        Z
      ), Z = Z.isSkinnedMesh && st.skinning, Te = 0, Ie && (Te |= 1), Z && (Te |= 2), me = me[Te]), t.localClippingEnabled && st.clipShadows === !0 && st.clippingPlanes.length !== 0 && (Te = me.uuid, Ie = st.uuid, Z = H[Te], Z === void 0 && (Z = {}, H[Te] = Z), Te = Z[Ie], Te === void 0 && (Te = me.clone(), Z[Ie] = Te), me = Te), me.visible = st.visible, me.wireframe = st.wireframe, me.side = st.shadowSide != null ? st.shadowSide : q[st.side], me.clipShadows = st.clipShadows, me.clippingPlanes = st.clippingPlanes, me.clipIntersection = st.clipIntersection, me.wireframeLinewidth = st.wireframeLinewidth, me.linewidth = st.linewidth, zt && me.isMeshDistanceMaterial && (me.referencePosition.copy(ee), me.nearDistance = $t, me.farDistance = qt), me;
    }
    function s(Z, st, zt, ee) {
      if (Z.visible !== !1) {
        if (Z.layers.test(st.layers) && (Z.isMesh || Z.isLine || Z.isPoints) && Z.castShadow && (!Z.frustumCulled || a.intersectsObject(Z))) {
          Z.modelViewMatrix.multiplyMatrices(
            zt.matrixWorldInverse,
            Z.matrixWorld
          );
          var $t = e.update(Z), qt = Z.material;
          if (Array.isArray(qt))
            for (var Te = $t.groups, me = 0, Ie = Te.length; me < Ie; me++) {
              var be = Te[me], ae = qt[be.materialIndex];
              ae && ae.visible && (ae = n(Z, ae, ee, A, zt.near, zt.far), t.renderBufferDirect(zt, null, $t, ae, Z, be));
            }
          else
            qt.visible && (ae = n(Z, qt, ee, A, zt.near, zt.far), t.renderBufferDirect(zt, null, $t, ae, Z, null));
        }
        for (Z = Z.children, $t = 0, qt = Z.length; $t < qt; $t++)
          s(Z[$t], st, zt, ee);
      }
    }
    var a = new E(), c = new p(), f = new o(), v = new o(i, i), y = new u(), A = new u(), P = Array(4), k = Array(4), H = {}, q = { 0: 1, 1: 0, 2: 2 }, K = [
      new u(1, 0, 0),
      new u(-1, 0, 0),
      new u(0, 0, 1),
      new u(0, 0, -1),
      new u(0, 1, 0),
      new u(0, -1, 0)
    ], rt = [
      new u(0, 1, 0),
      new u(0, 1, 0),
      new u(0, 1, 0),
      new u(0, 1, 0),
      new u(0, 0, 1),
      new u(0, 0, -1)
    ], xt = [new T(), new T(), new T(), new T(), new T(), new T()];
    for (i = 0; i !== 4; ++i) {
      var gt = (i & 1) !== 0, At = (i & 2) !== 0, wt = new oe({ depthPacking: 3201, morphTargets: gt, skinning: At });
      P[i] = wt, gt = new te({ morphTargets: gt, skinning: At }), k[i] = gt;
    }
    var Vt = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(Z, st, zt) {
      if (Vt.enabled !== !1 && (Vt.autoUpdate !== !1 || Vt.needsUpdate !== !1) && Z.length !== 0) {
        var ee = t.state;
        ee.disable(3042), ee.buffers.color.setClear(1, 1, 1, 1), ee.buffers.depth.setTest(!0), ee.setScissorTest(!1);
        for (var $t, qt = 0, Te = Z.length; qt < Te; qt++) {
          var me = Z[qt];
          $t = me.shadow;
          var Ie = me && me.isPointLight;
          if ($t === void 0)
            console.warn("THREE.WebGLShadowMap:", me, "has no shadow.");
          else {
            var be = $t.camera;
            if (f.copy($t.mapSize), f.min(v), Ie) {
              var ae = f.x, We = f.y;
              xt[0].set(2 * ae, We, ae, We), xt[1].set(0, We, ae, We), xt[2].set(3 * ae, We, ae, We), xt[3].set(ae, We, ae, We), xt[4].set(3 * ae, 0, ae, We), xt[5].set(ae, 0, ae, We), f.x *= 4, f.y *= 2;
            }
            for ($t.map === null && ($t.map = new S(f.x, f.y, {
              minFilter: 1003,
              magFilter: 1003,
              format: 1023
            }), $t.map.texture.name = me.name + ".shadowMap", be.updateProjectionMatrix()), $t.isSpotLightShadow && $t.update(me), ae = $t.map, We = $t.matrix, A.setFromMatrixPosition(me.matrixWorld), be.position.copy(A), Ie ? ($t = 6, We.makeTranslation(-A.x, -A.y, -A.z)) : ($t = 1, y.setFromMatrixPosition(me.target.matrixWorld), be.lookAt(y), be.updateMatrixWorld(), We.set(
              0.5,
              0,
              0,
              0.5,
              0,
              0.5,
              0,
              0.5,
              0,
              0,
              0.5,
              0.5,
              0,
              0,
              0,
              1
            ), We.multiply(be.projectionMatrix), We.multiply(be.matrixWorldInverse)), t.setRenderTarget(ae), t.clear(), me = 0; me < $t; me++)
              Ie && (y.copy(be.position), y.add(K[me]), be.up.copy(rt[me]), be.lookAt(y), be.updateMatrixWorld(), ee.viewport(xt[me])), c.multiplyMatrices(be.projectionMatrix, be.matrixWorldInverse), a.setFromMatrix(c), s(st, zt, be, Ie);
          }
        }
        Vt.needsUpdate = !1;
      }
    };
  }
  function ue(t, e, i, n) {
    function s(Ut, Ye, ei) {
      var Hi = new Uint8Array(4), Ce = t.createTexture();
      for (t.bindTexture(Ut, Ce), t.texParameteri(Ut, 10241, 9728), t.texParameteri(Ut, 10240, 9728), Ut = 0; Ut < ei; Ut++)
        t.texImage2D(Ye + Ut, 0, 6408, 1, 1, 0, 6408, 5121, Hi);
      return Ce;
    }
    function a(Ut, Ye) {
      xt[Ut] = 1, gt[Ut] === 0 && (t.enableVertexAttribArray(Ut), gt[Ut] = 1), At[Ut] !== Ye && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](Ut, Ye), At[Ut] = Ye);
    }
    function c(Ut) {
      wt[Ut] !== !0 && (t.enable(Ut), wt[Ut] = !0);
    }
    function f(Ut) {
      wt[Ut] !== !1 && (t.disable(Ut), wt[Ut] = !1);
    }
    function v(Ut, Ye, ei, Hi, Ce, Xe, ri, Ai) {
      if (Ut === 0)
        st && (f(3042), st = !1);
      else if (st || (c(3042), st = !0), Ut !== 5) {
        if (Ut !== zt || Ai !== be) {
          if ((ee !== 100 || Te !== 100) && (t.blendEquation(32774), Te = ee = 100), Ai)
            switch (Ut) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Ut);
            }
          else
            switch (Ut) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Ut);
            }
          Ie = me = qt = $t = null, zt = Ut, be = Ai;
        }
      } else
        Ce = Ce || Ye, Xe = Xe || ei, ri = ri || Hi, (Ye !== ee || Ce !== Te) && (t.blendEquationSeparate(i.convert(Ye), i.convert(Ce)), ee = Ye, Te = Ce), (ei !== $t || Hi !== qt || Xe !== me || ri !== Ie) && (t.blendFuncSeparate(
          i.convert(ei),
          i.convert(Hi),
          i.convert(Xe),
          i.convert(ri)
        ), $t = ei, qt = Hi, me = Xe, Ie = ri), zt = Ut, be = null;
    }
    function y(Ut) {
      ae !== Ut && (Ut ? t.frontFace(2304) : t.frontFace(2305), ae = Ut);
    }
    function A(Ut) {
      Ut !== 0 ? (c(2884), Ut !== We && (Ut === 1 ? t.cullFace(1029) : Ut === 2 ? t.cullFace(1028) : t.cullFace(1032))) : f(2884), We = Ut;
    }
    function P(Ut, Ye, ei) {
      Ut ? (c(32823), (ci !== Ye || Sn !== ei) && (t.polygonOffset(Ye, ei), ci = Ye, Sn = ei)) : f(32823);
    }
    function k(Ut) {
      Ut === void 0 && (Ut = 33984 + mn - 1), Gi !== Ut && (t.activeTexture(Ut), Gi = Ut);
    }
    var H = new function() {
      var Ut = !1, Ye = new T(), ei = null, Hi = new T(0, 0, 0, 0);
      return {
        setMask: function(Ce) {
          ei === Ce || Ut || (t.colorMask(Ce, Ce, Ce, Ce), ei = Ce);
        },
        setLocked: function(Ce) {
          Ut = Ce;
        },
        setClear: function(Ce, Xe, ri, Ai, bi) {
          bi === !0 && (Ce *= Ai, Xe *= Ai, ri *= Ai), Ye.set(Ce, Xe, ri, Ai), Hi.equals(Ye) === !1 && (t.clearColor(Ce, Xe, ri, Ai), Hi.copy(Ye));
        },
        reset: function() {
          Ut = !1, ei = null, Hi.set(-1, 0, 0, 0);
        }
      };
    }(), q = new function() {
      var Ut = !1, Ye = null, ei = null, Hi = null;
      return {
        setTest: function(Ce) {
          Ce ? c(2929) : f(2929);
        },
        setMask: function(Ce) {
          Ye === Ce || Ut || (t.depthMask(Ce), Ye = Ce);
        },
        setFunc: function(Ce) {
          if (ei !== Ce) {
            if (Ce)
              switch (Ce) {
                case 0:
                  t.depthFunc(512);
                  break;
                case 1:
                  t.depthFunc(519);
                  break;
                case 2:
                  t.depthFunc(513);
                  break;
                case 3:
                  t.depthFunc(515);
                  break;
                case 4:
                  t.depthFunc(514);
                  break;
                case 5:
                  t.depthFunc(518);
                  break;
                case 6:
                  t.depthFunc(516);
                  break;
                case 7:
                  t.depthFunc(517);
                  break;
                default:
                  t.depthFunc(515);
              }
            else
              t.depthFunc(515);
            ei = Ce;
          }
        },
        setLocked: function(Ce) {
          Ut = Ce;
        },
        setClear: function(Ce) {
          Hi !== Ce && (t.clearDepth(Ce), Hi = Ce);
        },
        reset: function() {
          Ut = !1, Hi = ei = Ye = null;
        }
      };
    }(), K = new function() {
      var Ut = !1, Ye = null, ei = null, Hi = null, Ce = null, Xe = null, ri = null, Ai = null, bi = null;
      return {
        setTest: function(ne) {
          ne ? c(2960) : f(2960);
        },
        setMask: function(ne) {
          Ye === ne || Ut || (t.stencilMask(ne), Ye = ne);
        },
        setFunc: function(ne, ii, Ze) {
          (ei !== ne || Hi !== ii || Ce !== Ze) && (t.stencilFunc(ne, ii, Ze), ei = ne, Hi = ii, Ce = Ze);
        },
        setOp: function(ne, ii, Ze) {
          (Xe !== ne || ri !== ii || Ai !== Ze) && (t.stencilOp(ne, ii, Ze), Xe = ne, ri = ii, Ai = Ze);
        },
        setLocked: function(ne) {
          Ut = ne;
        },
        setClear: function(ne) {
          bi !== ne && (t.clearStencil(ne), bi = ne);
        },
        reset: function() {
          Ut = !1, bi = Ai = ri = Xe = Ce = Hi = ei = Ye = null;
        }
      };
    }(), rt = t.getParameter(34921), xt = new Uint8Array(rt), gt = new Uint8Array(rt), At = new Uint8Array(rt), wt = {}, Vt = null, Z = null, st = null, zt = null, ee = null, $t = null, qt = null, Te = null, me = null, Ie = null, be = !1, ae = null, We = null, Ke = null, ci = null, Sn = null, mn = t.getParameter(35661), ji = !1;
    rt = 0, rt = t.getParameter(7938), rt.indexOf("WebGL") !== -1 ? (rt = parseFloat(/^WebGL ([0-9])/.exec(rt)[1]), ji = 1 <= rt) : rt.indexOf("OpenGL ES") !== -1 && (rt = parseFloat(/^OpenGL ES ([0-9])/.exec(rt)[1]), ji = 2 <= rt);
    var Gi = null, en = {}, En = new T(), Ae = new T(), Qe = {};
    return Qe[3553] = s(3553, 3553, 1), Qe[34067] = s(34067, 34069, 6), H.setClear(0, 0, 0, 1), q.setClear(1), K.setClear(0), c(2929), q.setFunc(3), y(!1), A(1), c(2884), v(0), {
      buffers: { color: H, depth: q, stencil: K },
      initAttributes: function() {
        for (var Ut = 0, Ye = xt.length; Ut < Ye; Ut++)
          xt[Ut] = 0;
      },
      enableAttribute: function(Ut) {
        a(Ut, 0);
      },
      enableAttributeAndDivisor: a,
      disableUnusedAttributes: function() {
        for (var Ut = 0, Ye = gt.length; Ut !== Ye; ++Ut)
          gt[Ut] !== xt[Ut] && (t.disableVertexAttribArray(Ut), gt[Ut] = 0);
      },
      enable: c,
      disable: f,
      getCompressedTextureFormats: function() {
        if (Vt === null && (Vt = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
          for (var Ut = t.getParameter(34467), Ye = 0; Ye < Ut.length; Ye++)
            Vt.push(Ut[Ye]);
        return Vt;
      },
      useProgram: function(Ut) {
        return Z !== Ut ? (t.useProgram(Ut), Z = Ut, !0) : !1;
      },
      setBlending: v,
      setMaterial: function(Ut, Ye) {
        Ut.side === 2 ? f(2884) : c(2884);
        var ei = Ut.side === 1;
        Ye && (ei = !ei), y(ei), Ut.blending === 1 && Ut.transparent === !1 ? v(0) : v(
          Ut.blending,
          Ut.blendEquation,
          Ut.blendSrc,
          Ut.blendDst,
          Ut.blendEquationAlpha,
          Ut.blendSrcAlpha,
          Ut.blendDstAlpha,
          Ut.premultipliedAlpha
        ), q.setFunc(Ut.depthFunc), q.setTest(Ut.depthTest), q.setMask(Ut.depthWrite), H.setMask(Ut.colorWrite), P(Ut.polygonOffset, Ut.polygonOffsetFactor, Ut.polygonOffsetUnits);
      },
      setFlipSided: y,
      setCullFace: A,
      setLineWidth: function(Ut) {
        Ut !== Ke && (ji && t.lineWidth(Ut), Ke = Ut);
      },
      setPolygonOffset: P,
      setScissorTest: function(Ut) {
        Ut ? c(3089) : f(3089);
      },
      activeTexture: k,
      bindTexture: function(Ut, Ye) {
        Gi === null && k();
        var ei = en[Gi];
        ei === void 0 && (ei = { type: void 0, texture: void 0 }, en[Gi] = ei), (ei.type !== Ut || ei.texture !== Ye) && (t.bindTexture(Ut, Ye || Qe[Ut]), ei.type = Ut, ei.texture = Ye);
      },
      compressedTexImage2D: function() {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      texImage2D: function() {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      texImage3D: function() {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      scissor: function(Ut) {
        En.equals(Ut) === !1 && (t.scissor(Ut.x, Ut.y, Ut.z, Ut.w), En.copy(Ut));
      },
      viewport: function(Ut) {
        Ae.equals(Ut) === !1 && (t.viewport(Ut.x, Ut.y, Ut.z, Ut.w), Ae.copy(Ut));
      },
      reset: function() {
        for (var Ut = 0; Ut < gt.length; Ut++)
          gt[Ut] === 1 && (t.disableVertexAttribArray(Ut), gt[Ut] = 0);
        wt = {}, Gi = Vt = null, en = {}, We = ae = zt = Z = null, H.reset(), q.reset(), K.reset();
      }
    };
  }
  function je(t, e, i, n, s, a, c) {
    function f(Z, st) {
      if (Z.width > st || Z.height > st) {
        if ("data" in Z) {
          console.warn(
            "THREE.WebGLRenderer: image in DataTexture is too big (" + Z.width + "x" + Z.height + ")."
          );
          return;
        }
        st /= Math.max(Z.width, Z.height);
        var zt = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return zt.width = Math.floor(Z.width * st), zt.height = Math.floor(Z.height * st), zt.getContext("2d").drawImage(
          Z,
          0,
          0,
          Z.width,
          Z.height,
          0,
          0,
          zt.width,
          zt.height
        ), console.warn(
          "THREE.WebGLRenderer: image is too big (" + Z.width + "x" + Z.height + "). Resized to " + zt.width + "x" + zt.height
        ), zt;
      }
      return Z;
    }
    function v(Z) {
      return fi.isPowerOfTwo(Z.width) && fi.isPowerOfTwo(Z.height);
    }
    function y(Z, st) {
      return Z.generateMipmaps && st && Z.minFilter !== 1003 && Z.minFilter !== 1006;
    }
    function A(Z, st, zt, ee) {
      t.generateMipmap(Z), n.get(st).__maxMipLevel = Math.log(Math.max(zt, ee)) * Math.LOG2E;
    }
    function P(Z, st) {
      if (!s.isWebGL2)
        return Z;
      if (Z === 6403) {
        if (st === 5126)
          return 33326;
        if (st === 5131)
          return 33325;
        if (st === 5121)
          return 33321;
      }
      if (Z === 6407) {
        if (st === 5126)
          return 34837;
        if (st === 5131)
          return 34843;
        if (st === 5121)
          return 32849;
      }
      if (Z === 6408) {
        if (st === 5126)
          return 34836;
        if (st === 5131)
          return 34842;
        if (st === 5121)
          return 32856;
      }
      return Z;
    }
    function k(Z) {
      return Z === 1003 || Z === 1004 || Z === 1005 ? 9728 : 9729;
    }
    function H(Z) {
      Z = Z.target, Z.removeEventListener("dispose", H);
      t: {
        var st = n.get(Z);
        if (Z.image && st.__image__webglTextureCube)
          t.deleteTexture(st.__image__webglTextureCube);
        else {
          if (st.__webglInit === void 0)
            break t;
          t.deleteTexture(st.__webglTexture);
        }
        n.remove(Z);
      }
      Z.isVideoTexture && delete wt[Z.id], c.memory.textures--;
    }
    function q(Z) {
      Z = Z.target, Z.removeEventListener("dispose", q);
      var st = n.get(Z), zt = n.get(Z.texture);
      if (Z) {
        if (zt.__webglTexture !== void 0 && t.deleteTexture(zt.__webglTexture), Z.depthTexture && Z.depthTexture.dispose(), Z.isWebGLRenderTargetCube)
          for (zt = 0; 6 > zt; zt++)
            t.deleteFramebuffer(st.__webglFramebuffer[zt]), st.__webglDepthbuffer && t.deleteRenderbuffer(st.__webglDepthbuffer[zt]);
        else
          t.deleteFramebuffer(st.__webglFramebuffer), st.__webglDepthbuffer && t.deleteRenderbuffer(st.__webglDepthbuffer);
        n.remove(Z.texture), n.remove(Z);
      }
      c.memory.textures--;
    }
    function K(Z, st) {
      var zt = n.get(Z);
      if (Z.isVideoTexture) {
        var ee = Z.id, $t = c.render.frame;
        wt[ee] !== $t && (wt[ee] = $t, Z.update());
      }
      if (0 < Z.version && zt.__version !== Z.version)
        if (ee = Z.image, ee === void 0)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined"
          );
        else if (ee.complete === !1)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        else {
          xt(zt, Z, st);
          return;
        }
      i.activeTexture(33984 + st), i.bindTexture(3553, zt.__webglTexture);
    }
    function rt(Z, st, zt) {
      zt ? (t.texParameteri(Z, 10242, a.convert(st.wrapS)), t.texParameteri(Z, 10243, a.convert(st.wrapT)), t.texParameteri(Z, 10240, a.convert(st.magFilter)), t.texParameteri(Z, 10241, a.convert(st.minFilter))) : (t.texParameteri(Z, 10242, 33071), t.texParameteri(Z, 10243, 33071), st.wrapS === 1001 && st.wrapT === 1001 || console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
      ), t.texParameteri(Z, 10240, k(st.magFilter)), t.texParameteri(Z, 10241, k(st.minFilter)), st.minFilter !== 1003 && st.minFilter !== 1006 && console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
      )), !(zt = e.get("EXT_texture_filter_anisotropic")) || st.type === 1015 && e.get("OES_texture_float_linear") === null || st.type === 1016 && (s.isWebGL2 || e.get("OES_texture_half_float_linear")) === null || !(1 < st.anisotropy || n.get(st).__currentAnisotropy) || (t.texParameterf(
        Z,
        zt.TEXTURE_MAX_ANISOTROPY_EXT,
        Math.min(st.anisotropy, s.getMaxAnisotropy())
      ), n.get(st).__currentAnisotropy = st.anisotropy);
    }
    function xt(Z, st, zt) {
      var ee = st.isDataTexture3D ? 32879 : 3553;
      Z.__webglInit === void 0 && (Z.__webglInit = !0, st.addEventListener("dispose", H), Z.__webglTexture = t.createTexture(), c.memory.textures++), i.activeTexture(33984 + zt), i.bindTexture(ee, Z.__webglTexture), t.pixelStorei(37440, st.flipY), t.pixelStorei(37441, st.premultiplyAlpha), t.pixelStorei(3317, st.unpackAlignment), zt = f(st.image, s.maxTextureSize);
      var $t = s.isWebGL2 ? !1 : st.wrapS !== 1001 || st.wrapT !== 1001 || st.minFilter !== 1003 && st.minFilter !== 1006;
      $t && v(zt) === !1 && (zt instanceof HTMLImageElement || zt instanceof HTMLCanvasElement || zt instanceof ImageBitmap) && (Vt === void 0 && (Vt = document.createElementNS(
        "http://www.w3.org/1999/xhtml",
        "canvas"
      )), Vt.width = fi.floorPowerOfTwo(zt.width), Vt.height = fi.floorPowerOfTwo(zt.height), Vt.getContext("2d").drawImage(zt, 0, 0, Vt.width, Vt.height), console.warn(
        "THREE.WebGLRenderer: image is not power of two (" + zt.width + "x" + zt.height + "). Resized to " + Vt.width + "x" + Vt.height
      ), zt = Vt), $t = v(zt);
      var qt = a.convert(st.format), Te = a.convert(st.type), me = P(qt, Te);
      rt(ee, st, $t);
      var Ie = st.mipmaps;
      if (st.isDepthTexture) {
        if (me = 6402, st.type === 1015) {
          if (!s.isWebGL2)
            throw Error("Float Depth Texture only supported in WebGL2.0");
          me = 36012;
        } else
          s.isWebGL2 && (me = 33189);
        st.format === 1026 && me === 6402 && st.type !== 1012 && st.type !== 1014 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
        ), st.type = 1012, Te = a.convert(st.type)), st.format === 1027 && (me = 34041, st.type !== 1020 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
        ), st.type = 1020, Te = a.convert(st.type))), i.texImage2D(3553, 0, me, zt.width, zt.height, 0, qt, Te, null);
      } else if (st.isDataTexture)
        if (0 < Ie.length && $t) {
          for (var be = 0, ae = Ie.length; be < ae; be++)
            ee = Ie[be], i.texImage2D(3553, be, me, ee.width, ee.height, 0, qt, Te, ee.data);
          st.generateMipmaps = !1, Z.__maxMipLevel = Ie.length - 1;
        } else
          i.texImage2D(3553, 0, me, zt.width, zt.height, 0, qt, Te, zt.data), Z.__maxMipLevel = 0;
      else if (st.isCompressedTexture) {
        for (be = 0, ae = Ie.length; be < ae; be++)
          ee = Ie[be], st.format !== 1023 && st.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(qt) ? i.compressedTexImage2D(
            3553,
            be,
            me,
            ee.width,
            ee.height,
            0,
            ee.data
          ) : console.warn(
            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
          ) : i.texImage2D(3553, be, me, ee.width, ee.height, 0, qt, Te, ee.data);
        Z.__maxMipLevel = Ie.length - 1;
      } else if (st.isDataTexture3D)
        i.texImage3D(32879, 0, me, zt.width, zt.height, zt.depth, 0, qt, Te, zt.data), Z.__maxMipLevel = 0;
      else if (0 < Ie.length && $t) {
        for (be = 0, ae = Ie.length; be < ae; be++)
          ee = Ie[be], i.texImage2D(3553, be, me, qt, Te, ee);
        st.generateMipmaps = !1, Z.__maxMipLevel = Ie.length - 1;
      } else
        i.texImage2D(3553, 0, me, qt, Te, zt), Z.__maxMipLevel = 0;
      y(st, $t) && A(3553, st, zt.width, zt.height), Z.__version = st.version, st.onUpdate && st.onUpdate(st);
    }
    function gt(Z, st, zt, ee) {
      var $t = a.convert(st.texture.format), qt = a.convert(st.texture.type), Te = P($t, qt);
      i.texImage2D(ee, 0, Te, st.width, st.height, 0, $t, qt, null), t.bindFramebuffer(36160, Z), t.framebufferTexture2D(36160, zt, ee, n.get(st.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }
    function At(Z, st) {
      t.bindRenderbuffer(36161, Z), st.depthBuffer && !st.stencilBuffer ? (t.renderbufferStorage(36161, 33189, st.width, st.height), t.framebufferRenderbuffer(36160, 36096, 36161, Z)) : st.depthBuffer && st.stencilBuffer ? (t.renderbufferStorage(36161, 34041, st.width, st.height), t.framebufferRenderbuffer(36160, 33306, 36161, Z)) : t.renderbufferStorage(36161, 32854, st.width, st.height), t.bindRenderbuffer(36161, null);
    }
    var wt = {}, Vt;
    this.setTexture2D = K, this.setTexture3D = function(Z, st) {
      var zt = n.get(Z);
      0 < Z.version && zt.__version !== Z.version ? xt(zt, Z, st) : (i.activeTexture(33984 + st), i.bindTexture(32879, zt.__webglTexture));
    }, this.setTextureCube = function(Z, st) {
      var zt = n.get(Z);
      if (Z.image.length === 6)
        if (0 < Z.version && zt.__version !== Z.version) {
          zt.__image__webglTextureCube || (Z.addEventListener("dispose", H), zt.__image__webglTextureCube = t.createTexture(), c.memory.textures++), i.activeTexture(33984 + st), i.bindTexture(34067, zt.__image__webglTextureCube), t.pixelStorei(37440, Z.flipY), st = Z && Z.isCompressedTexture;
          for (var ee = Z.image[0] && Z.image[0].isDataTexture, $t = [], qt = 0; 6 > qt; qt++)
            $t[qt] = st || ee ? ee ? Z.image[qt].image : Z.image[qt] : f(Z.image[qt], s.maxCubemapSize);
          var Te = $t[0], me = v(Te), Ie = a.convert(Z.format), be = a.convert(Z.type), ae = P(Ie, be);
          for (rt(34067, Z, me), qt = 0; 6 > qt; qt++)
            if (st)
              for (var We, Ke = $t[qt].mipmaps, ci = 0, Sn = Ke.length; ci < Sn; ci++)
                We = Ke[ci], Z.format !== 1023 && Z.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(Ie) ? i.compressedTexImage2D(
                  34069 + qt,
                  ci,
                  ae,
                  We.width,
                  We.height,
                  0,
                  We.data
                ) : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                ) : i.texImage2D(
                  34069 + qt,
                  ci,
                  ae,
                  We.width,
                  We.height,
                  0,
                  Ie,
                  be,
                  We.data
                );
            else
              ee ? i.texImage2D(
                34069 + qt,
                0,
                ae,
                $t[qt].width,
                $t[qt].height,
                0,
                Ie,
                be,
                $t[qt].data
              ) : i.texImage2D(34069 + qt, 0, ae, Ie, be, $t[qt]);
          zt.__maxMipLevel = st ? Ke.length - 1 : 0, y(Z, me) && A(34067, Z, Te.width, Te.height), zt.__version = Z.version, Z.onUpdate && Z.onUpdate(Z);
        } else
          i.activeTexture(33984 + st), i.bindTexture(34067, zt.__image__webglTextureCube);
    }, this.setTextureCubeDynamic = function(Z, st) {
      i.activeTexture(33984 + st), i.bindTexture(34067, n.get(Z).__webglTexture);
    }, this.setupRenderTarget = function(Z) {
      var st = n.get(Z), zt = n.get(Z.texture);
      Z.addEventListener("dispose", q), zt.__webglTexture = t.createTexture(), c.memory.textures++;
      var ee = Z.isWebGLRenderTargetCube === !0, $t = v(Z);
      if (ee) {
        st.__webglFramebuffer = [];
        for (var qt = 0; 6 > qt; qt++)
          st.__webglFramebuffer[qt] = t.createFramebuffer();
      } else
        st.__webglFramebuffer = t.createFramebuffer();
      if (ee) {
        for (i.bindTexture(34067, zt.__webglTexture), rt(34067, Z.texture, $t), qt = 0; 6 > qt; qt++)
          gt(st.__webglFramebuffer[qt], Z, 36064, 34069 + qt);
        y(Z.texture, $t) && A(34067, Z.texture, Z.width, Z.height), i.bindTexture(34067, null);
      } else
        i.bindTexture(3553, zt.__webglTexture), rt(3553, Z.texture, $t), gt(st.__webglFramebuffer, Z, 36064, 3553), y(Z.texture, $t) && A(3553, Z.texture, Z.width, Z.height), i.bindTexture(3553, null);
      if (Z.depthBuffer) {
        if (st = n.get(Z), zt = Z.isWebGLRenderTargetCube === !0, Z.depthTexture) {
          if (zt)
            throw Error(
              "target.depthTexture not supported in Cube render targets"
            );
          if (Z && Z.isWebGLRenderTargetCube)
            throw Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (t.bindFramebuffer(36160, st.__webglFramebuffer), !Z.depthTexture || !Z.depthTexture.isDepthTexture)
            throw Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          if (n.get(Z.depthTexture).__webglTexture && Z.depthTexture.image.width === Z.width && Z.depthTexture.image.height === Z.height || (Z.depthTexture.image.width = Z.width, Z.depthTexture.image.height = Z.height, Z.depthTexture.needsUpdate = !0), K(Z.depthTexture, 0), st = n.get(Z.depthTexture).__webglTexture, Z.depthTexture.format === 1026)
            t.framebufferTexture2D(36160, 36096, 3553, st, 0);
          else if (Z.depthTexture.format === 1027)
            t.framebufferTexture2D(36160, 33306, 3553, st, 0);
          else
            throw Error("Unknown depthTexture format");
        } else if (zt)
          for (st.__webglDepthbuffer = [], zt = 0; 6 > zt; zt++)
            t.bindFramebuffer(36160, st.__webglFramebuffer[zt]), st.__webglDepthbuffer[zt] = t.createRenderbuffer(), At(st.__webglDepthbuffer[zt], Z);
        else
          t.bindFramebuffer(36160, st.__webglFramebuffer), st.__webglDepthbuffer = t.createRenderbuffer(), At(st.__webglDepthbuffer, Z);
        t.bindFramebuffer(36160, null);
      }
    }, this.updateRenderTargetMipmap = function(Z) {
      var st = Z.texture, zt = v(Z);
      if (y(st, zt)) {
        zt = Z.isWebGLRenderTargetCube ? 34067 : 3553;
        var ee = n.get(st).__webglTexture;
        i.bindTexture(zt, ee), A(zt, st, Z.width, Z.height), i.bindTexture(zt, null);
      }
    };
  }
  function He(t, e, i) {
    return {
      convert: function(n) {
        if (n === 1e3)
          return 10497;
        if (n === 1001)
          return 33071;
        if (n === 1002)
          return 33648;
        if (n === 1003)
          return 9728;
        if (n === 1004)
          return 9984;
        if (n === 1005)
          return 9986;
        if (n === 1006)
          return 9729;
        if (n === 1007)
          return 9985;
        if (n === 1008)
          return 9987;
        if (n === 1009)
          return 5121;
        if (n === 1017)
          return 32819;
        if (n === 1018)
          return 32820;
        if (n === 1019)
          return 33635;
        if (n === 1010)
          return 5120;
        if (n === 1011)
          return 5122;
        if (n === 1012)
          return 5123;
        if (n === 1013)
          return 5124;
        if (n === 1014)
          return 5125;
        if (n === 1015)
          return 5126;
        if (n === 1016) {
          if (i.isWebGL2)
            return 5131;
          var s = e.get("OES_texture_half_float");
          if (s !== null)
            return s.HALF_FLOAT_OES;
        }
        if (n === 1021)
          return 6406;
        if (n === 1022)
          return 6407;
        if (n === 1023)
          return 6408;
        if (n === 1024)
          return 6409;
        if (n === 1025)
          return 6410;
        if (n === 1026)
          return 6402;
        if (n === 1027)
          return 34041;
        if (n === 1028)
          return 6403;
        if (n === 100)
          return 32774;
        if (n === 101)
          return 32778;
        if (n === 102)
          return 32779;
        if (n === 200)
          return 0;
        if (n === 201)
          return 1;
        if (n === 202)
          return 768;
        if (n === 203)
          return 769;
        if (n === 204)
          return 770;
        if (n === 205)
          return 771;
        if (n === 206)
          return 772;
        if (n === 207)
          return 773;
        if (n === 208)
          return 774;
        if (n === 209)
          return 775;
        if (n === 210)
          return 776;
        if ((n === 33776 || n === 33777 || n === 33778 || n === 33779) && (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null)) {
          if (n === 33776)
            return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (n === 33777)
            return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (n === 33778)
            return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (n === 33779)
            return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if ((n === 35840 || n === 35841 || n === 35842 || n === 35843) && (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null)) {
          if (n === 35840)
            return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (n === 35841)
            return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (n === 35842)
            return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (n === 35843)
            return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (n === 36196 && (s = e.get("WEBGL_compressed_texture_etc1"), s !== null))
          return s.COMPRESSED_RGB_ETC1_WEBGL;
        if ((n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821) && (s = e.get("WEBGL_compressed_texture_astc"), s !== null))
          return n;
        if (n === 103 || n === 104) {
          if (i.isWebGL2) {
            if (n === 103)
              return 32775;
            if (n === 104)
              return 32776;
          }
          if (s = e.get("EXT_blend_minmax"), s !== null) {
            if (n === 103)
              return s.MIN_EXT;
            if (n === 104)
              return s.MAX_EXT;
          }
        }
        if (n === 1020) {
          if (i.isWebGL2)
            return 34042;
          if (s = e.get("WEBGL_depth_texture"), s !== null)
            return s.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      }
    };
  }
  function ui() {
    N.call(this), this.type = "Group";
  }
  function Be() {
    N.call(this), this.type = "Camera", this.matrixWorldInverse = new p(), this.projectionMatrix = new p(), this.projectionMatrixInverse = new p();
  }
  function ye(t, e, i, n) {
    Be.call(this), this.type = "PerspectiveCamera", this.fov = t !== void 0 ? t : 50, this.zoom = 1, this.near = i !== void 0 ? i : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = e !== void 0 ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  function Fe(t) {
    ye.call(this), this.cameras = t || [];
  }
  function pe(t, e, i) {
    to.setFromMatrixPosition(e.matrixWorld), _r.setFromMatrixPosition(i.matrixWorld);
    var n = to.distanceTo(_r), s = e.projectionMatrix.elements, a = i.projectionMatrix.elements, c = s[14] / (s[10] - 1);
    i = s[14] / (s[10] + 1);
    var f = (s[9] + 1) / s[5], v = (s[9] - 1) / s[5], y = (s[8] - 1) / s[0], A = (a[8] + 1) / a[0];
    s = c * y, a = c * A, A = n / (-y + A), y = A * -y, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(y), t.translateZ(A), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = c + A, c = i + A, t.projectionMatrix.makePerspective(
      s - y,
      a + (n - y),
      f * i / c * e,
      v * i / c * e,
      e,
      c
    );
  }
  function di(t) {
    function e() {
      return s !== null && s.isPresenting === !0;
    }
    function i() {
      if (e()) {
        var Z = s.getEyeParameters("left"), st = Z.renderWidth * A;
        Z = Z.renderHeight * A, At = t.getPixelRatio(), gt = t.getSize(), t.setDrawingBufferSize(2 * st, Z, 1), Vt.start();
      } else
        n.enabled && t.setDrawingBufferSize(gt.width, gt.height, At), Vt.stop();
    }
    var n = this, s = null, a = null, c = null, f = [], v = new p(), y = new p(), A = 1, P = "stage";
    typeof window < "u" && "VRFrameData" in window && (a = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", i, !1));
    var k = new p(), H = new d(), q = new u(), K = new ye();
    K.bounds = new T(0, 0, 0.5, 1), K.layers.enable(1);
    var rt = new ye();
    rt.bounds = new T(0.5, 0, 0.5, 1), rt.layers.enable(2);
    var xt = new Fe([K, rt]);
    xt.layers.enable(1), xt.layers.enable(2);
    var gt, At, wt = [];
    this.enabled = !1, this.getController = function(Z) {
      var st = f[Z];
      return st === void 0 && (st = new ui(), st.matrixAutoUpdate = !1, st.visible = !1, f[Z] = st), st;
    }, this.getDevice = function() {
      return s;
    }, this.setDevice = function(Z) {
      Z !== void 0 && (s = Z), Vt.setContext(Z);
    }, this.setFramebufferScaleFactor = function(Z) {
      A = Z;
    }, this.setFrameOfReferenceType = function(Z) {
      P = Z;
    }, this.setPoseTarget = function(Z) {
      Z !== void 0 && (c = Z);
    }, this.getCamera = function(Z) {
      var st = P === "stage" ? 1.6 : 0;
      if (s === null)
        return Z.position.set(0, st, 0), Z;
      if (s.depthNear = Z.near, s.depthFar = Z.far, s.getFrameData(a), P === "stage") {
        var zt = s.stageParameters;
        zt ? v.fromArray(zt.sittingToStandingTransform) : v.makeTranslation(0, st, 0);
      }
      if (st = a.pose, zt = c !== null ? c : Z, zt.matrix.copy(v), zt.matrix.decompose(zt.position, zt.quaternion, zt.scale), st.orientation !== null && (H.fromArray(st.orientation), zt.quaternion.multiply(H)), st.position !== null && (H.setFromRotationMatrix(v), q.fromArray(st.position), q.applyQuaternion(H), zt.position.add(q)), zt.updateMatrixWorld(), s.isPresenting === !1)
        return Z;
      K.near = Z.near, rt.near = Z.near, K.far = Z.far, rt.far = Z.far, K.matrixWorldInverse.fromArray(a.leftViewMatrix), rt.matrixWorldInverse.fromArray(a.rightViewMatrix), y.getInverse(v), P === "stage" && (K.matrixWorldInverse.multiply(y), rt.matrixWorldInverse.multiply(y)), Z = zt.parent, Z !== null && (k.getInverse(Z.matrixWorld), K.matrixWorldInverse.multiply(k), rt.matrixWorldInverse.multiply(k)), K.matrixWorld.getInverse(K.matrixWorldInverse), rt.matrixWorld.getInverse(rt.matrixWorldInverse), K.projectionMatrix.fromArray(a.leftProjectionMatrix), rt.projectionMatrix.fromArray(a.rightProjectionMatrix), pe(xt, K, rt), Z = s.getLayers(), Z.length && (Z = Z[0], Z.leftBounds !== null && Z.leftBounds.length === 4 && K.bounds.fromArray(Z.leftBounds), Z.rightBounds !== null && Z.rightBounds.length === 4 && rt.bounds.fromArray(Z.rightBounds));
      t:
        for (Z = 0; Z < f.length; Z++) {
          st = f[Z];
          e: {
            zt = Z;
            for (var ee = navigator.getGamepads && navigator.getGamepads(), $t = 0, qt = 0, Te = ee.length; $t < Te; $t++) {
              var me = ee[$t];
              if (me && (me.id === "Daydream Controller" || me.id === "Gear VR Controller" || me.id === "Oculus Go Controller" || me.id === "OpenVR Gamepad" || me.id.startsWith("Oculus Touch") || me.id.startsWith("Spatial Controller"))) {
                if (qt === zt) {
                  zt = me;
                  break e;
                }
                qt++;
              }
            }
            zt = void 0;
          }
          if (zt !== void 0 && zt.pose !== void 0) {
            if (zt.pose === null)
              break t;
            ee = zt.pose, ee.hasPosition === !1 && st.position.set(0.2, -0.6, -0.05), ee.position !== null && st.position.fromArray(ee.position), ee.orientation !== null && st.quaternion.fromArray(ee.orientation), st.matrix.compose(st.position, st.quaternion, st.scale), st.matrix.premultiply(v), st.matrix.decompose(st.position, st.quaternion, st.scale), st.matrixWorldNeedsUpdate = !0, st.visible = !0, ee = zt.id === "Daydream Controller" ? 0 : 1, wt[Z] !== zt.buttons[ee].pressed && (wt[Z] = zt.buttons[ee].pressed, wt[Z] === !0 ? st.dispatchEvent({ type: "selectstart" }) : (st.dispatchEvent({ type: "selectend" }), st.dispatchEvent({ type: "select" })));
          } else
            st.visible = !1;
        }
      return xt;
    }, this.getStandingMatrix = function() {
      return v;
    }, this.isPresenting = e;
    var Vt = new x();
    this.setAnimationLoop = function(Z) {
      Vt.setAnimationLoop(Z);
    }, this.submitFrame = function() {
      e() && s.submitFrame();
    }, this.dispose = function() {
      typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", i);
    };
  }
  function Pe(t) {
    function e() {
      return f !== null && y !== null;
    }
    function i(At) {
      var wt = k[H.indexOf(At.inputSource)];
      wt && wt.dispatchEvent({ type: At.type });
    }
    function n() {
      t.setFramebuffer(null), gt.stop();
    }
    function s(At, wt) {
      wt === null ? At.matrixWorld.copy(At.matrix) : At.matrixWorld.multiplyMatrices(wt.matrixWorld, At.matrix), At.matrixWorldInverse.getInverse(At.matrixWorld);
    }
    var a = t.context, c = null, f = null, v = 1, y = null, A = "stage", P = null, k = [], H = [], q = new ye();
    q.layers.enable(1), q.viewport = new T();
    var K = new ye();
    K.layers.enable(2), K.viewport = new T();
    var rt = new Fe([q, K]);
    rt.layers.enable(1), rt.layers.enable(2), this.enabled = !1, this.getController = function(At) {
      var wt = k[At];
      return wt === void 0 && (wt = new ui(), wt.matrixAutoUpdate = !1, wt.visible = !1, k[At] = wt), wt;
    }, this.getDevice = function() {
      return c;
    }, this.setDevice = function(At) {
      At !== void 0 && (c = At), At instanceof XRDevice && a.setCompatibleXRDevice(At);
    }, this.setFramebufferScaleFactor = function(At) {
      v = At;
    }, this.setFrameOfReferenceType = function(At) {
      A = At;
    }, this.setSession = function(At) {
      f = At, f !== null && (f.addEventListener("select", i), f.addEventListener("selectstart", i), f.addEventListener("selectend", i), f.addEventListener("end", n), f.baseLayer = new XRWebGLLayer(f, a, { framebufferScaleFactor: v }), f.requestFrameOfReference(A).then(function(wt) {
        y = wt, t.setFramebuffer(f.baseLayer.framebuffer), gt.setContext(f), gt.start();
      }), H = f.getInputSources(), f.addEventListener("inputsourceschange", function() {
        H = f.getInputSources(), console.log(H);
        for (var wt = 0; wt < k.length; wt++)
          k[wt].userData.inputSource = H[wt];
      }));
    }, this.getCamera = function(At) {
      if (e()) {
        var wt = At.parent, Vt = rt.cameras;
        s(rt, wt);
        for (var Z = 0; Z < Vt.length; Z++)
          s(Vt[Z], wt);
        for (At.matrixWorld.copy(rt.matrixWorld), At = At.children, Z = 0, wt = At.length; Z < wt; Z++)
          At[Z].updateMatrixWorld(!0);
        return pe(rt, q, K), rt;
      }
      return At;
    }, this.isPresenting = e;
    var xt = null, gt = new x();
    gt.setAnimationLoop(function(At, wt) {
      if (P = wt.getDevicePose(y), P !== null)
        for (var Vt = f.baseLayer, Z = wt.views, st = 0; st < Z.length; st++) {
          var zt = Z[st], ee = Vt.getViewport(zt), $t = P.getViewMatrix(zt), qt = rt.cameras[st];
          qt.matrix.fromArray($t).getInverse(qt.matrix), qt.projectionMatrix.fromArray(zt.projectionMatrix), qt.viewport.set(ee.x, ee.y, ee.width, ee.height), st === 0 && rt.matrix.copy(qt.matrix);
        }
      for (st = 0; st < k.length; st++) {
        if (Vt = k[st], (Z = H[st]) && (Z = wt.getInputPose(Z, y), Z !== null)) {
          "targetRay" in Z ? Vt.matrix.elements = Z.targetRay.transformMatrix : "pointerMatrix" in Z && (Vt.matrix.elements = Z.pointerMatrix), Vt.matrix.decompose(Vt.position, Vt.rotation, Vt.scale), Vt.visible = !0;
          continue;
        }
        Vt.visible = !1;
      }
      xt && xt(At);
    }), this.setAnimationLoop = function(At) {
      xt = At;
    }, this.dispose = function() {
    }, this.getStandingMatrix = function() {
      return console.warn(
        "THREE.WebXRManager: getStandingMatrix() is no longer needed."
      ), new THREE.Matrix4();
    }, this.submitFrame = function() {
    };
  }
  function xe(t) {
    var e;
    function i() {
      ii = new Jt(ne), Ze = new Ji(ne, ii, t), Ze.isWebGL2 || (ii.get("WEBGL_depth_texture"), ii.get("OES_texture_float"), ii.get("OES_texture_half_float"), ii.get("OES_texture_half_float_linear"), ii.get("OES_standard_derivatives"), ii.get("OES_element_index_uint"), ii.get("ANGLE_instanced_arrays")), ii.get("OES_texture_float_linear"), Ln = new He(ne, ii, Ze), ai = new ue(ne, ii, Ln, Ze), ai.scissor(ji.copy(Ye).multiplyScalar(Qe)), ai.viewport(mn.copy(Ut).multiplyScalar(Qe)), gn = new dt(), bn = new at(), ks = new je(ne, ii, ai, bn, Ze, Ln, gn), wa = new M(ne), Rh = new Wt(ne, wa, gn), Ta = new Kt(Rh, gn), Oh = new ie(ne), zo = new lt(qt, ii, Ze), cl = new Rt(), ko = new he(), io = new Li(qt, ai, Ta, Z), Ih = new cn(ne, ii, gn, Ze), Qn = new pt(ne, ii, gn, Ze), gn.programs = zo.programs, qt.context = ne, qt.capabilities = Ze, qt.extensions = ii, qt.properties = bn, qt.renderLists = cl, qt.state = ai, qt.info = gn;
    }
    function n(ft) {
      ft.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), Te = !0;
    }
    function s() {
      console.log("THREE.WebGLRenderer: Context Restored."), Te = !1, i();
    }
    function a(ft) {
      ft = ft.target, ft.removeEventListener("dispose", a), c(ft), bn.remove(ft);
    }
    function c(ft) {
      var Tt = bn.get(ft).program;
      ft.program = void 0, Tt !== void 0 && zo.releaseProgram(Tt);
    }
    function f(ft, Tt) {
      ft.render(function(mt) {
        qt.renderBufferImmediate(mt, Tt);
      });
    }
    function v(ft, Tt, mt) {
      if (ft.visible !== !1) {
        if (ft.layers.test(Tt.layers)) {
          if (ft.isLight)
            $t.pushLight(ft), ft.castShadow && $t.pushShadow(ft);
          else if (ft.isSprite) {
            if (!ft.frustumCulled || Hi.intersectsSprite(ft)) {
              mt && bi.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Ai);
              var Me = Ta.update(ft), De = ft.material;
              ee.push(ft, Me, De, bi.z, null);
            }
          } else if (ft.isImmediateRenderObject)
            mt && bi.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Ai), ee.push(ft, null, ft.material, bi.z, null);
          else if ((ft.isMesh || ft.isLine || ft.isPoints) && (ft.isSkinnedMesh && ft.skeleton.update(), !ft.frustumCulled || Hi.intersectsObject(ft)))
            if (mt && bi.setFromMatrixPosition(ft.matrixWorld).applyMatrix4(Ai), Me = Ta.update(ft), De = ft.material, Array.isArray(De))
              for (var Ve = Me.groups, Se = 0, $e = Ve.length; Se < $e; Se++) {
                var Pi = Ve[Se], Zi = De[Pi.materialIndex];
                Zi && Zi.visible && ee.push(ft, Me, Zi, bi.z, Pi);
              }
            else
              De.visible && ee.push(ft, Me, De, bi.z, null);
        }
        for (ft = ft.children, Se = 0, $e = ft.length; Se < $e; Se++)
          v(ft[Se], Tt, mt);
      }
    }
    function y(ft, Tt, mt, Me) {
      for (var De = 0, Ve = ft.length; De < Ve; De++) {
        var Se = ft[De], $e = Se.object, Pi = Se.geometry, Zi = Me === void 0 ? Se.material : Me;
        if (Se = Se.group, mt.isArrayCamera) {
          Sn = mt;
          for (var ve = mt.cameras, yr = 0, zn = ve.length; yr < zn; yr++) {
            var sn = ve[yr];
            if ($e.layers.test(sn.layers)) {
              if ("viewport" in sn)
                ai.viewport(mn.copy(sn.viewport));
              else {
                var hr = sn.bounds;
                ai.viewport(
                  mn.set(hr.x * En, hr.y * Ae, hr.z * En, hr.w * Ae).multiplyScalar(Qe)
                );
              }
              $t.setupLights(sn), A($e, Tt, sn, Pi, Zi, Se);
            }
          }
        } else
          Sn = null, A($e, Tt, mt, Pi, Zi, Se);
      }
    }
    function A(ft, Tt, mt, Me, De, Ve) {
      if (ft.onBeforeRender(qt, Tt, mt, Me, De, Ve), $t = ko.get(Tt, Sn || mt), ft.modelViewMatrix.multiplyMatrices(mt.matrixWorldInverse, ft.matrixWorld), ft.normalMatrix.getNormalMatrix(ft.modelViewMatrix), ft.isImmediateRenderObject) {
        ai.setMaterial(De);
        var Se = k(mt, Tt.fog, De, ft);
        We = e = null, Ke = !1, f(ft, Se);
      } else
        qt.renderBufferDirect(mt, Tt.fog, Me, De, ft, Ve);
      ft.onAfterRender(qt, Tt, mt, Me, De, Ve), $t = ko.get(Tt, Sn || mt);
    }
    function P(ft, Tt, mt) {
      var Me = bn.get(ft), De = $t.state.lights, Ve = Me.lightsHash, Se = De.state.hash;
      mt = zo.getParameters(
        ft,
        De.state,
        $t.state.shadowsArray,
        Tt,
        Ce.numPlanes,
        Ce.numIntersection,
        mt
      );
      var $e = zo.getProgramCode(ft, mt), Pi = Me.program, Zi = !0;
      if (Pi === void 0)
        ft.addEventListener("dispose", a);
      else if (Pi.code !== $e)
        c(ft);
      else {
        if (Ve.stateID !== Se.stateID || Ve.directionalLength !== Se.directionalLength || Ve.pointLength !== Se.pointLength || Ve.spotLength !== Se.spotLength || Ve.rectAreaLength !== Se.rectAreaLength || Ve.hemiLength !== Se.hemiLength || Ve.shadowsLength !== Se.shadowsLength)
          Ve.stateID = Se.stateID, Ve.directionalLength = Se.directionalLength, Ve.pointLength = Se.pointLength, Ve.spotLength = Se.spotLength, Ve.rectAreaLength = Se.rectAreaLength, Ve.hemiLength = Se.hemiLength, Ve.shadowsLength = Se.shadowsLength;
        else if (mt.shaderID !== void 0)
          return;
        Zi = !1;
      }
      if (Zi && (mt.shaderID ? ($e = ms[mt.shaderID], Me.shader = {
        name: ft.type,
        uniforms: Dn.clone($e.uniforms),
        vertexShader: $e.vertexShader,
        fragmentShader: $e.fragmentShader
      }) : Me.shader = {
        name: ft.type,
        uniforms: ft.uniforms,
        vertexShader: ft.vertexShader,
        fragmentShader: ft.fragmentShader
      }, ft.onBeforeCompile(Me.shader, qt), $e = zo.getProgramCode(ft, mt), Pi = zo.acquireProgram(ft, Me.shader, mt, $e), Me.program = Pi, ft.program = Pi), mt = Pi.getAttributes(), ft.morphTargets)
        for ($e = ft.numSupportedMorphTargets = 0; $e < qt.maxMorphTargets; $e++)
          0 <= mt["morphTarget" + $e] && ft.numSupportedMorphTargets++;
      if (ft.morphNormals)
        for ($e = ft.numSupportedMorphNormals = 0; $e < qt.maxMorphNormals; $e++)
          0 <= mt["morphNormal" + $e] && ft.numSupportedMorphNormals++;
      mt = Me.shader.uniforms, (!ft.isShaderMaterial && !ft.isRawShaderMaterial || ft.clipping === !0) && (Me.numClippingPlanes = Ce.numPlanes, Me.numIntersection = Ce.numIntersection, mt.clippingPlanes = Ce.uniform), Me.fog = Tt, Ve === void 0 && (Me.lightsHash = Ve = {}), Ve.stateID = Se.stateID, Ve.directionalLength = Se.directionalLength, Ve.pointLength = Se.pointLength, Ve.spotLength = Se.spotLength, Ve.rectAreaLength = Se.rectAreaLength, Ve.hemiLength = Se.hemiLength, Ve.shadowsLength = Se.shadowsLength, ft.lights && (mt.ambientLightColor.value = De.state.ambient, mt.directionalLights.value = De.state.directional, mt.spotLights.value = De.state.spot, mt.rectAreaLights.value = De.state.rectArea, mt.pointLights.value = De.state.point, mt.hemisphereLights.value = De.state.hemi, mt.directionalShadowMap.value = De.state.directionalShadowMap, mt.directionalShadowMatrix.value = De.state.directionalShadowMatrix, mt.spotShadowMap.value = De.state.spotShadowMap, mt.spotShadowMatrix.value = De.state.spotShadowMatrix, mt.pointShadowMap.value = De.state.pointShadowMap, mt.pointShadowMatrix.value = De.state.pointShadowMatrix), ft = Me.program.getUniforms(), ft = rs.seqWithValue(ft.seq, mt), Me.uniformsList = ft;
    }
    function k(ft, Tt, mt, Me) {
      en = 0;
      var De = bn.get(mt), Ve = De.lightsHash, Se = $t.state.lights.state.hash;
      Xe && (ri || ft !== ci) && Ce.setState(
        mt.clippingPlanes,
        mt.clipIntersection,
        mt.clipShadows,
        ft,
        De,
        ft === ci && mt.id === ae
      ), mt.needsUpdate === !1 && (De.program === void 0 || mt.fog && De.fog !== Tt ? mt.needsUpdate = !0 : (!mt.lights || Ve.stateID === Se.stateID && Ve.directionalLength === Se.directionalLength && Ve.pointLength === Se.pointLength && Ve.spotLength === Se.spotLength && Ve.rectAreaLength === Se.rectAreaLength && Ve.hemiLength === Se.hemiLength && Ve.shadowsLength === Se.shadowsLength) && (De.numClippingPlanes === void 0 || De.numClippingPlanes === Ce.numPlanes && De.numIntersection === Ce.numIntersection) || (mt.needsUpdate = !0)), mt.needsUpdate && (P(mt, Tt, Me), mt.needsUpdate = !1);
      var $e = !1, Pi = !1, Zi = !1;
      Ve = De.program, Se = Ve.getUniforms();
      var ve = De.shader.uniforms;
      if (ai.useProgram(Ve.program) && (Zi = Pi = $e = !0), mt.id !== ae && (ae = mt.id, Pi = !0), ($e || ci !== ft) && (Se.setValue(ne, "projectionMatrix", ft.projectionMatrix), Ze.logarithmicDepthBuffer && Se.setValue(ne, "logDepthBufFC", 2 / (Math.log(ft.far + 1) / Math.LN2)), ci !== ft && (ci = ft, Zi = Pi = !0), (mt.isShaderMaterial || mt.isMeshPhongMaterial || mt.isMeshStandardMaterial || mt.envMap) && ($e = Se.map.cameraPosition, $e !== void 0 && $e.setValue(ne, bi.setFromMatrixPosition(ft.matrixWorld))), (mt.isMeshPhongMaterial || mt.isMeshLambertMaterial || mt.isMeshBasicMaterial || mt.isMeshStandardMaterial || mt.isShaderMaterial || mt.skinning) && Se.setValue(ne, "viewMatrix", ft.matrixWorldInverse)), mt.skinning && (Se.setOptional(ne, Me, "bindMatrix"), Se.setOptional(ne, Me, "bindMatrixInverse"), ft = Me.skeleton))
        if ($e = ft.bones, Ze.floatVertexTextures) {
          if (ft.boneTexture === void 0) {
            $e = Math.sqrt(4 * $e.length), $e = fi.ceilPowerOfTwo($e), $e = Math.max($e, 4);
            var yr = new Float32Array($e * $e * 4);
            yr.set(ft.boneMatrices);
            var zn = new z(yr, $e, $e, 1023, 1015);
            zn.needsUpdate = !0, ft.boneMatrices = yr, ft.boneTexture = zn, ft.boneTextureSize = $e;
          }
          Se.setValue(ne, "boneTexture", ft.boneTexture), Se.setValue(ne, "boneTextureSize", ft.boneTextureSize);
        } else
          Se.setOptional(ne, ft, "boneMatrices");
      return Pi && (Se.setValue(ne, "toneMappingExposure", qt.toneMappingExposure), Se.setValue(ne, "toneMappingWhitePoint", qt.toneMappingWhitePoint), mt.lights && (Pi = Zi, ve.ambientLightColor.needsUpdate = Pi, ve.directionalLights.needsUpdate = Pi, ve.pointLights.needsUpdate = Pi, ve.spotLights.needsUpdate = Pi, ve.rectAreaLights.needsUpdate = Pi, ve.hemisphereLights.needsUpdate = Pi), Tt && mt.fog && (ve.fogColor.value = Tt.color, Tt.isFog ? (ve.fogNear.value = Tt.near, ve.fogFar.value = Tt.far) : Tt.isFogExp2 && (ve.fogDensity.value = Tt.density)), mt.isMeshBasicMaterial ? H(ve, mt) : mt.isMeshLambertMaterial ? (H(ve, mt), mt.emissiveMap && (ve.emissiveMap.value = mt.emissiveMap)) : mt.isMeshPhongMaterial ? (H(ve, mt), mt.isMeshToonMaterial ? (q(ve, mt), mt.gradientMap && (ve.gradientMap.value = mt.gradientMap)) : q(ve, mt)) : mt.isMeshStandardMaterial ? (H(ve, mt), mt.isMeshPhysicalMaterial ? (K(ve, mt), ve.reflectivity.value = mt.reflectivity, ve.clearCoat.value = mt.clearCoat, ve.clearCoatRoughness.value = mt.clearCoatRoughness) : K(ve, mt)) : mt.isMeshMatcapMaterial ? (H(ve, mt), mt.matcap && (ve.matcap.value = mt.matcap), mt.bumpMap && (ve.bumpMap.value = mt.bumpMap, ve.bumpScale.value = mt.bumpScale, mt.side === 1 && (ve.bumpScale.value *= -1)), mt.normalMap && (ve.normalMap.value = mt.normalMap, ve.normalScale.value.copy(mt.normalScale), mt.side === 1 && ve.normalScale.value.negate()), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias)) : mt.isMeshDepthMaterial ? (H(ve, mt), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias)) : mt.isMeshDistanceMaterial ? (H(ve, mt), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias), ve.referencePosition.value.copy(mt.referencePosition), ve.nearDistance.value = mt.nearDistance, ve.farDistance.value = mt.farDistance) : mt.isMeshNormalMaterial ? (H(ve, mt), mt.bumpMap && (ve.bumpMap.value = mt.bumpMap, ve.bumpScale.value = mt.bumpScale, mt.side === 1 && (ve.bumpScale.value *= -1)), mt.normalMap && (ve.normalMap.value = mt.normalMap, ve.normalScale.value.copy(mt.normalScale), mt.side === 1 && ve.normalScale.value.negate()), mt.displacementMap && (ve.displacementMap.value = mt.displacementMap, ve.displacementScale.value = mt.displacementScale, ve.displacementBias.value = mt.displacementBias)) : mt.isLineBasicMaterial ? (ve.diffuse.value = mt.color, ve.opacity.value = mt.opacity, mt.isLineDashedMaterial && (ve.dashSize.value = mt.dashSize, ve.totalSize.value = mt.dashSize + mt.gapSize, ve.scale.value = mt.scale)) : mt.isPointsMaterial ? (ve.diffuse.value = mt.color, ve.opacity.value = mt.opacity, ve.size.value = mt.size * Qe, ve.scale.value = 0.5 * Ae, ve.map.value = mt.map, mt.map !== null && (mt.map.matrixAutoUpdate === !0 && mt.map.updateMatrix(), ve.uvTransform.value.copy(mt.map.matrix))) : mt.isSpriteMaterial ? (ve.diffuse.value = mt.color, ve.opacity.value = mt.opacity, ve.rotation.value = mt.rotation, ve.map.value = mt.map, mt.map !== null && (mt.map.matrixAutoUpdate === !0 && mt.map.updateMatrix(), ve.uvTransform.value.copy(mt.map.matrix))) : mt.isShadowMaterial && (ve.color.value = mt.color, ve.opacity.value = mt.opacity), ve.ltc_1 !== void 0 && (ve.ltc_1.value = qe.LTC_1), ve.ltc_2 !== void 0 && (ve.ltc_2.value = qe.LTC_2), rs.upload(ne, De.uniformsList, ve, qt)), mt.isShaderMaterial && mt.uniformsNeedUpdate === !0 && (rs.upload(ne, De.uniformsList, ve, qt), mt.uniformsNeedUpdate = !1), mt.isSpriteMaterial && Se.setValue(ne, "center", Me.center), Se.setValue(ne, "modelViewMatrix", Me.modelViewMatrix), Se.setValue(ne, "normalMatrix", Me.normalMatrix), Se.setValue(ne, "modelMatrix", Me.matrixWorld), Ve;
    }
    function H(ft, Tt) {
      if (ft.opacity.value = Tt.opacity, Tt.color && (ft.diffuse.value = Tt.color), Tt.emissive && ft.emissive.value.copy(Tt.emissive).multiplyScalar(Tt.emissiveIntensity), Tt.map && (ft.map.value = Tt.map), Tt.alphaMap && (ft.alphaMap.value = Tt.alphaMap), Tt.specularMap && (ft.specularMap.value = Tt.specularMap), Tt.envMap && (ft.envMap.value = Tt.envMap, ft.flipEnvMap.value = Tt.envMap && Tt.envMap.isCubeTexture ? -1 : 1, ft.reflectivity.value = Tt.reflectivity, ft.refractionRatio.value = Tt.refractionRatio, ft.maxMipLevel.value = bn.get(Tt.envMap).__maxMipLevel), Tt.lightMap && (ft.lightMap.value = Tt.lightMap, ft.lightMapIntensity.value = Tt.lightMapIntensity), Tt.aoMap && (ft.aoMap.value = Tt.aoMap, ft.aoMapIntensity.value = Tt.aoMapIntensity), Tt.map)
        var mt = Tt.map;
      else
        Tt.specularMap ? mt = Tt.specularMap : Tt.displacementMap ? mt = Tt.displacementMap : Tt.normalMap ? mt = Tt.normalMap : Tt.bumpMap ? mt = Tt.bumpMap : Tt.roughnessMap ? mt = Tt.roughnessMap : Tt.metalnessMap ? mt = Tt.metalnessMap : Tt.alphaMap ? mt = Tt.alphaMap : Tt.emissiveMap && (mt = Tt.emissiveMap);
      mt !== void 0 && (mt.isWebGLRenderTarget && (mt = mt.texture), mt.matrixAutoUpdate === !0 && mt.updateMatrix(), ft.uvTransform.value.copy(mt.matrix));
    }
    function q(ft, Tt) {
      ft.specular.value = Tt.specular, ft.shininess.value = Math.max(Tt.shininess, 1e-4), Tt.emissiveMap && (ft.emissiveMap.value = Tt.emissiveMap), Tt.bumpMap && (ft.bumpMap.value = Tt.bumpMap, ft.bumpScale.value = Tt.bumpScale, Tt.side === 1 && (ft.bumpScale.value *= -1)), Tt.normalMap && (ft.normalMap.value = Tt.normalMap, ft.normalScale.value.copy(Tt.normalScale), Tt.side === 1 && ft.normalScale.value.negate()), Tt.displacementMap && (ft.displacementMap.value = Tt.displacementMap, ft.displacementScale.value = Tt.displacementScale, ft.displacementBias.value = Tt.displacementBias);
    }
    function K(ft, Tt) {
      ft.roughness.value = Tt.roughness, ft.metalness.value = Tt.metalness, Tt.roughnessMap && (ft.roughnessMap.value = Tt.roughnessMap), Tt.metalnessMap && (ft.metalnessMap.value = Tt.metalnessMap), Tt.emissiveMap && (ft.emissiveMap.value = Tt.emissiveMap), Tt.bumpMap && (ft.bumpMap.value = Tt.bumpMap, ft.bumpScale.value = Tt.bumpScale, Tt.side === 1 && (ft.bumpScale.value *= -1)), Tt.normalMap && (ft.normalMap.value = Tt.normalMap, ft.normalScale.value.copy(Tt.normalScale), Tt.side === 1 && ft.normalScale.value.negate()), Tt.displacementMap && (ft.displacementMap.value = Tt.displacementMap, ft.displacementScale.value = Tt.displacementScale, ft.displacementBias.value = Tt.displacementBias), Tt.envMap && (ft.envMapIntensity.value = Tt.envMapIntensity);
    }
    console.log("THREE.WebGLRenderer", "98"), t = t || {};
    var rt = t.canvas !== void 0 ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), xt = t.context !== void 0 ? t.context : null, gt = t.alpha !== void 0 ? t.alpha : !1, At = t.depth !== void 0 ? t.depth : !0, wt = t.stencil !== void 0 ? t.stencil : !0, Vt = t.antialias !== void 0 ? t.antialias : !1, Z = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, st = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, zt = t.powerPreference !== void 0 ? t.powerPreference : "default", ee = null, $t = null;
    this.domElement = rt, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
    var qt = this, Te = !1, me = null, Ie = null, be = null, ae = -1, We = e = null, Ke = !1, ci = null, Sn = null, mn = new T(), ji = new T(), Gi = null, en = 0, En = rt.width, Ae = rt.height, Qe = 1, Ut = new T(0, 0, En, Ae), Ye = new T(0, 0, En, Ae), ei = !1, Hi = new E(), Ce = new W(), Xe = !1, ri = !1, Ai = new p(), bi = new u();
    try {
      gt = {
        alpha: gt,
        depth: At,
        stencil: wt,
        antialias: Vt,
        premultipliedAlpha: Z,
        preserveDrawingBuffer: st,
        powerPreference: zt
      }, rt.addEventListener("webglcontextlost", n, !1), rt.addEventListener("webglcontextrestored", s, !1);
      var ne = xt || rt.getContext("webgl", gt) || rt.getContext("experimental-webgl", gt);
      if (ne === null)
        throw rt.getContext("webgl") !== null ? Error(
          "Error creating WebGL context with your selected attributes."
        ) : Error("Error creating WebGL context.");
      ne.getShaderPrecisionFormat === void 0 && (ne.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (ft) {
      console.error("THREE.WebGLRenderer: " + ft.message);
    }
    var ii, Ze, ai, gn, bn, ks, wa, Rh, Ta, zo, cl, ko, io, Oh, Ih, Qn, Ln;
    i();
    var _s = null;
    typeof navigator < "u" && (_s = "xr" in navigator ? new Pe(qt) : new di(qt)), this.vr = _s;
    var vu = new _e(qt, Ta, Ze.maxTextureSize);
    this.shadowMap = vu, this.getContext = function() {
      return ne;
    }, this.getContextAttributes = function() {
      return ne.getContextAttributes();
    }, this.forceContextLoss = function() {
      var ft = ii.get("WEBGL_lose_context");
      ft && ft.loseContext();
    }, this.forceContextRestore = function() {
      var ft = ii.get("WEBGL_lose_context");
      ft && ft.restoreContext();
    }, this.getPixelRatio = function() {
      return Qe;
    }, this.setPixelRatio = function(ft) {
      ft !== void 0 && (Qe = ft, this.setSize(En, Ae, !1));
    }, this.getSize = function() {
      return { width: En, height: Ae };
    }, this.setSize = function(ft, Tt, mt) {
      _s.isPresenting() ? console.warn(
        "THREE.WebGLRenderer: Can't change size while VR device is presenting."
      ) : (En = ft, Ae = Tt, rt.width = ft * Qe, rt.height = Tt * Qe, mt !== !1 && (rt.style.width = ft + "px", rt.style.height = Tt + "px"), this.setViewport(0, 0, ft, Tt));
    }, this.getDrawingBufferSize = function() {
      return { width: En * Qe, height: Ae * Qe };
    }, this.setDrawingBufferSize = function(ft, Tt, mt) {
      En = ft, Ae = Tt, Qe = mt, rt.width = ft * mt, rt.height = Tt * mt, this.setViewport(0, 0, ft, Tt);
    }, this.getCurrentViewport = function() {
      return mn;
    }, this.setViewport = function(ft, Tt, mt, Me) {
      Ut.set(ft, Ae - Tt - Me, mt, Me), ai.viewport(mn.copy(Ut).multiplyScalar(Qe));
    }, this.setScissor = function(ft, Tt, mt, Me) {
      Ye.set(ft, Ae - Tt - Me, mt, Me), ai.scissor(ji.copy(Ye).multiplyScalar(Qe));
    }, this.setScissorTest = function(ft) {
      ai.setScissorTest(ei = ft);
    }, this.getClearColor = function() {
      return io.getClearColor();
    }, this.setClearColor = function() {
      io.setClearColor.apply(io, arguments);
    }, this.getClearAlpha = function() {
      return io.getClearAlpha();
    }, this.setClearAlpha = function() {
      io.setClearAlpha.apply(io, arguments);
    }, this.clear = function(ft, Tt, mt) {
      var Me = 0;
      (ft === void 0 || ft) && (Me |= 16384), (Tt === void 0 || Tt) && (Me |= 256), (mt === void 0 || mt) && (Me |= 1024), ne.clear(Me);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      rt.removeEventListener("webglcontextlost", n, !1), rt.removeEventListener("webglcontextrestored", s, !1), cl.dispose(), ko.dispose(), bn.dispose(), Ta.dispose(), _s.dispose(), Bs.stop();
    }, this.renderBufferImmediate = function(ft, Tt) {
      ai.initAttributes();
      var mt = bn.get(ft);
      ft.hasPositions && !mt.position && (mt.position = ne.createBuffer()), ft.hasNormals && !mt.normal && (mt.normal = ne.createBuffer()), ft.hasUvs && !mt.uv && (mt.uv = ne.createBuffer()), ft.hasColors && !mt.color && (mt.color = ne.createBuffer()), Tt = Tt.getAttributes(), ft.hasPositions && (ne.bindBuffer(34962, mt.position), ne.bufferData(34962, ft.positionArray, 35048), ai.enableAttribute(Tt.position), ne.vertexAttribPointer(Tt.position, 3, 5126, !1, 0, 0)), ft.hasNormals && (ne.bindBuffer(34962, mt.normal), ne.bufferData(34962, ft.normalArray, 35048), ai.enableAttribute(Tt.normal), ne.vertexAttribPointer(Tt.normal, 3, 5126, !1, 0, 0)), ft.hasUvs && (ne.bindBuffer(34962, mt.uv), ne.bufferData(34962, ft.uvArray, 35048), ai.enableAttribute(Tt.uv), ne.vertexAttribPointer(Tt.uv, 2, 5126, !1, 0, 0)), ft.hasColors && (ne.bindBuffer(34962, mt.color), ne.bufferData(34962, ft.colorArray, 35048), ai.enableAttribute(Tt.color), ne.vertexAttribPointer(Tt.color, 3, 5126, !1, 0, 0)), ai.disableUnusedAttributes(), ne.drawArrays(4, 0, ft.count), ft.count = 0;
    }, this.renderBufferDirect = function(ft, Tt, mt, Me, De, Ve) {
      var Se = De.isMesh && 0 > De.normalMatrix.determinant();
      ai.setMaterial(Me, Se);
      var $e = k(ft, Tt, Me, De), Pi = !1;
      (e !== mt.id || We !== $e.id || Ke !== (Me.wireframe === !0)) && (e = mt.id, We = $e.id, Ke = Me.wireframe === !0, Pi = !0), De.morphTargetInfluences && (Oh.update(De, mt, Me, $e), Pi = !0), Se = mt.index;
      var Zi = mt.attributes.position;
      if (Tt = 1, Me.wireframe === !0 && (Se = Rh.getWireframeAttribute(mt), Tt = 2), ft = Ih, Se !== null) {
        var ve = wa.get(Se);
        ft = Qn, ft.setIndex(ve);
      }
      if (Pi) {
        if (mt && mt.isInstancedBufferGeometry & !Ze.isWebGL2 && ii.get("ANGLE_instanced_arrays") === null)
          console.error(
            "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        else {
          ai.initAttributes(), Pi = mt.attributes, $e = $e.getAttributes();
          var yr = Me.defaultAttributeValues;
          for (tr in $e) {
            var zn = $e[tr];
            if (0 <= zn) {
              var sn = Pi[tr];
              if (sn !== void 0) {
                var hr = sn.normalized, Dh = sn.itemSize, ys = wa.get(sn);
                if (ys !== void 0) {
                  var zh = ys.buffer, Jl = ys.type;
                  if (ys = ys.bytesPerElement, sn.isInterleavedBufferAttribute) {
                    var Sa = sn.data, _u = Sa.stride;
                    sn = sn.offset, Sa && Sa.isInstancedInterleavedBuffer ? (ai.enableAttributeAndDivisor(zn, Sa.meshPerAttribute), mt.maxInstancedCount === void 0 && (mt.maxInstancedCount = Sa.meshPerAttribute * Sa.count)) : ai.enableAttribute(zn), ne.bindBuffer(34962, zh), ne.vertexAttribPointer(zn, Dh, Jl, hr, _u * ys, sn * ys);
                  } else
                    sn.isInstancedBufferAttribute ? (ai.enableAttributeAndDivisor(zn, sn.meshPerAttribute), mt.maxInstancedCount === void 0 && (mt.maxInstancedCount = sn.meshPerAttribute * sn.count)) : ai.enableAttribute(zn), ne.bindBuffer(34962, zh), ne.vertexAttribPointer(zn, Dh, Jl, hr, 0, 0);
                }
              } else if (yr !== void 0 && (hr = yr[tr], hr !== void 0))
                switch (hr.length) {
                  case 2:
                    ne.vertexAttrib2fv(zn, hr);
                    break;
                  case 3:
                    ne.vertexAttrib3fv(zn, hr);
                    break;
                  case 4:
                    ne.vertexAttrib4fv(zn, hr);
                    break;
                  default:
                    ne.vertexAttrib1fv(zn, hr);
                }
            }
          }
          ai.disableUnusedAttributes();
        }
        Se !== null && ne.bindBuffer(34963, ve.buffer);
      }
      ve = 1 / 0, Se !== null ? ve = Se.count : Zi !== void 0 && (ve = Zi.count), Se = mt.drawRange.start * Tt, Zi = Ve !== null ? Ve.start * Tt : 0;
      var tr = Math.max(Se, Zi);
      if (Ve = Math.max(
        0,
        Math.min(
          ve,
          Se + mt.drawRange.count * Tt,
          Zi + (Ve !== null ? Ve.count * Tt : 1 / 0)
        ) - 1 - tr + 1
      ), Ve !== 0) {
        if (De.isMesh)
          if (Me.wireframe === !0)
            ai.setLineWidth(Me.wireframeLinewidth * (Ie === null ? Qe : 1)), ft.setMode(1);
          else
            switch (De.drawMode) {
              case 0:
                ft.setMode(4);
                break;
              case 1:
                ft.setMode(5);
                break;
              case 2:
                ft.setMode(6);
            }
        else
          De.isLine ? (Me = Me.linewidth, Me === void 0 && (Me = 1), ai.setLineWidth(Me * (Ie === null ? Qe : 1)), De.isLineSegments ? ft.setMode(1) : De.isLineLoop ? ft.setMode(2) : ft.setMode(3)) : De.isPoints ? ft.setMode(0) : De.isSprite && ft.setMode(4);
        mt && mt.isInstancedBufferGeometry ? 0 < mt.maxInstancedCount && ft.renderInstances(mt, tr, Ve) : ft.render(tr, Ve);
      }
    }, this.compile = function(ft, Tt) {
      $t = ko.get(ft, Tt), $t.init(), ft.traverse(function(mt) {
        mt.isLight && ($t.pushLight(mt), mt.castShadow && $t.pushShadow(mt));
      }), $t.setupLights(Tt), ft.traverse(function(mt) {
        if (mt.material)
          if (Array.isArray(mt.material))
            for (var Me = 0; Me < mt.material.length; Me++)
              P(mt.material[Me], ft.fog, mt);
          else
            P(mt.material, ft.fog, mt);
      });
    };
    var Ma = null, Bs = new x();
    Bs.setAnimationLoop(function(ft) {
      _s.isPresenting() || Ma && Ma(ft);
    }), typeof window < "u" && Bs.setContext(window), this.setAnimationLoop = function(ft) {
      Ma = ft, _s.setAnimationLoop(ft), Bs.start();
    }, this.render = function(ft, Tt, mt, Me) {
      if (!Tt || !Tt.isCamera)
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
      else if (!Te) {
        We = e = null, Ke = !1, ae = -1, ci = null, ft.autoUpdate === !0 && ft.updateMatrixWorld(), Tt.parent === null && Tt.updateMatrixWorld(), _s.enabled && (Tt = _s.getCamera(Tt)), $t = ko.get(ft, Tt), $t.init(), ft.onBeforeRender(qt, ft, Tt, mt), Ai.multiplyMatrices(Tt.projectionMatrix, Tt.matrixWorldInverse), Hi.setFromMatrix(Ai), ri = this.localClippingEnabled, Xe = Ce.init(this.clippingPlanes, ri, Tt), ee = cl.get(ft, Tt), ee.init(), v(ft, Tt, qt.sortObjects), qt.sortObjects === !0 && ee.sort(), Xe && Ce.beginShadows(), vu.render($t.state.shadowsArray, ft, Tt), $t.setupLights(Tt), Xe && Ce.endShadows(), this.info.autoReset && this.info.reset(), mt === void 0 && (mt = null), this.setRenderTarget(mt), io.render(ee, ft, Tt, Me), Me = ee.opaque;
        var De = ee.transparent;
        if (ft.overrideMaterial) {
          var Ve = ft.overrideMaterial;
          Me.length && y(Me, ft, Tt, Ve), De.length && y(De, ft, Tt, Ve);
        } else
          Me.length && y(Me, ft, Tt), De.length && y(De, ft, Tt);
        mt && ks.updateRenderTargetMipmap(mt), ai.buffers.depth.setTest(!0), ai.buffers.depth.setMask(!0), ai.buffers.color.setMask(!0), ai.setPolygonOffset(!1), ft.onAfterRender(qt, ft, Tt), _s.enabled && _s.submitFrame(), $t = ee = null;
      }
    }, this.allocTextureUnit = function() {
      var ft = en;
      return ft >= Ze.maxTextures && console.warn(
        "THREE.WebGLRenderer: Trying to use " + ft + " texture units while this GPU supports only " + Ze.maxTextures
      ), en += 1, ft;
    }, this.setTexture2D = function() {
      var ft = !1;
      return function(Tt, mt) {
        Tt && Tt.isWebGLRenderTarget && (ft || (console.warn(
          "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
        ), ft = !0), Tt = Tt.texture), ks.setTexture2D(Tt, mt);
      };
    }(), this.setTexture3D = function() {
      return function(ft, Tt) {
        ks.setTexture3D(ft, Tt);
      };
    }(), this.setTexture = function() {
      var ft = !1;
      return function(Tt, mt) {
        ft || (console.warn(
          "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
        ), ft = !0), ks.setTexture2D(Tt, mt);
      };
    }(), this.setTextureCube = function() {
      var ft = !1;
      return function(Tt, mt) {
        Tt && Tt.isWebGLRenderTargetCube && (ft || (console.warn(
          "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ), ft = !0), Tt = Tt.texture), Tt && Tt.isCubeTexture || Array.isArray(Tt.image) && Tt.image.length === 6 ? ks.setTextureCube(Tt, mt) : ks.setTextureCubeDynamic(Tt, mt);
      };
    }(), this.setFramebuffer = function(ft) {
      me = ft;
    }, this.getRenderTarget = function() {
      return Ie;
    }, this.setRenderTarget = function(ft) {
      (Ie = ft) && bn.get(ft).__webglFramebuffer === void 0 && ks.setupRenderTarget(ft);
      var Tt = me, mt = !1;
      ft ? (Tt = bn.get(ft).__webglFramebuffer, ft.isWebGLRenderTargetCube && (Tt = Tt[ft.activeCubeFace], mt = !0), mn.copy(ft.viewport), ji.copy(ft.scissor), Gi = ft.scissorTest) : (mn.copy(Ut).multiplyScalar(Qe), ji.copy(Ye).multiplyScalar(Qe), Gi = ei), be !== Tt && (ne.bindFramebuffer(36160, Tt), be = Tt), ai.viewport(mn), ai.scissor(ji), ai.setScissorTest(Gi), mt && (mt = bn.get(ft.texture), ne.framebufferTexture2D(
        36160,
        36064,
        34069 + ft.activeCubeFace,
        mt.__webglTexture,
        ft.activeMipMapLevel
      ));
    }, this.readRenderTargetPixels = function(ft, Tt, mt, Me, De, Ve) {
      if (ft && ft.isWebGLRenderTarget) {
        var Se = bn.get(ft).__webglFramebuffer;
        if (Se) {
          var $e = !1;
          Se !== be && (ne.bindFramebuffer(36160, Se), $e = !0);
          try {
            var Pi = ft.texture, Zi = Pi.format, ve = Pi.type;
            Zi !== 1023 && Ln.convert(Zi) !== ne.getParameter(35739) ? console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            ) : ve === 1009 || Ln.convert(ve) === ne.getParameter(35738) || ve === 1015 && (Ze.isWebGL2 || ii.get("OES_texture_float") || ii.get("WEBGL_color_buffer_float")) || ve === 1016 && (Ze.isWebGL2 ? ii.get("EXT_color_buffer_float") : ii.get("EXT_color_buffer_half_float")) ? ne.checkFramebufferStatus(36160) === 36053 ? 0 <= Tt && Tt <= ft.width - Me && 0 <= mt && mt <= ft.height - De && ne.readPixels(Tt, mt, Me, De, Ln.convert(Zi), Ln.convert(ve), Ve) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
            ) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          } finally {
            $e && ne.bindFramebuffer(36160, be);
          }
        }
      } else
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
    }, this.copyFramebufferToTexture = function(ft, Tt, mt) {
      var Me = Tt.image.width, De = Tt.image.height, Ve = Ln.convert(Tt.format);
      this.setTexture2D(Tt, 0), ne.copyTexImage2D(3553, mt || 0, Ve, ft.x, ft.y, Me, De, 0);
    }, this.copyTextureToTexture = function(ft, Tt, mt, Me) {
      var De = Tt.image.width, Ve = Tt.image.height, Se = Ln.convert(mt.format), $e = Ln.convert(mt.type);
      this.setTexture2D(mt, 0), Tt.isDataTexture ? ne.texSubImage2D(3553, Me || 0, ft.x, ft.y, De, Ve, Se, $e, Tt.image.data) : ne.texSubImage2D(3553, Me || 0, ft.x, ft.y, Se, $e, Tt.image);
    };
  }
  function Le(t, e) {
    this.name = "", this.color = new L(t), this.density = e !== void 0 ? e : 25e-5;
  }
  function wn(t, e, i) {
    this.name = "", this.color = new L(t), this.near = e !== void 0 ? e : 1, this.far = i !== void 0 ? i : 1e3;
  }
  function Hn() {
    N.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0;
  }
  function Oi(t, e) {
    this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function Ii(t, e, i, n) {
    this.data = t, this.itemSize = e, this.offset = i, this.normalized = n === !0;
  }
  function Ui(t) {
    Yt.call(this), this.type = "SpriteMaterial", this.color = new L(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t);
  }
  function Qi(t) {
    if (N.call(this), this.type = "Sprite", xa === void 0) {
      xa = new Ft();
      var e = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      e = new Oi(e, 5), xa.setIndex([0, 1, 2, 0, 2, 3]), xa.addAttribute("position", new Ii(e, 3, 0, !1)), xa.addAttribute("uv", new Ii(e, 2, 3, !1));
    }
    this.geometry = xa, this.material = t !== void 0 ? t : new Ui(), this.center = new o(0.5, 0.5);
  }
  function tn() {
    N.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
  }
  function on(t, e) {
    if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), e === void 0)
      this.calculateInverses();
    else if (this.bones.length === e.length)
      this.boneInverses = e.slice(0);
    else
      for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++)
        this.boneInverses.push(new p());
  }
  function an() {
    N.call(this), this.type = "Bone";
  }
  function Fi(t, e) {
    pi.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new p(), this.bindMatrixInverse = new p(), t = this.initBones(), t = new on(t), this.bind(t, this.matrixWorld), this.normalizeSkinWeights();
  }
  function Di(t) {
    Yt.call(this), this.type = "LineBasicMaterial", this.color = new L(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t);
  }
  function Vi(t, e, i) {
    i === 1 && console.error(
      "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
    ), N.call(this), this.type = "Line", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Di({ color: 16777215 * Math.random() });
  }
  function mi(t, e) {
    Vi.call(this, t, e), this.type = "LineSegments";
  }
  function os(t, e) {
    Vi.call(this, t, e), this.type = "LineLoop";
  }
  function Bn(t) {
    Yt.call(this), this.type = "PointsMaterial", this.color = new L(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(t);
  }
  function $o(t, e) {
    N.call(this), this.type = "Points", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Bn({ color: 16777215 * Math.random() });
  }
  function dh(t, e, i, n, s, a, c, f, v) {
    _.call(this, t, e, i, n, s, a, c, f, v), this.generateMipmaps = !1;
  }
  function Gs(t, e, i, n, s, a, c, f, v, y, A, P) {
    _.call(this, null, a, c, f, v, y, n, s, A, P), this.image = { width: e, height: i }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1;
  }
  function Ba(t, e, i, n, s, a, c, f, v) {
    _.call(this, t, e, i, n, s, a, c, f, v), this.needsUpdate = !0;
  }
  function Na(t, e, i, n, s, a, c, f, v, y) {
    if (y = y !== void 0 ? y : 1026, y !== 1026 && y !== 1027)
      throw Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && y === 1026 && (i = 1012), i === void 0 && y === 1027 && (i = 1020), _.call(this, null, n, s, a, c, f, y, i, v), this.image = { width: t, height: e }, this.magFilter = c !== void 0 ? c : 1003, this.minFilter = f !== void 0 ? f : 1003, this.generateMipmaps = this.flipY = !1;
  }
  function Ko(t) {
    Ft.call(this), this.type = "WireframeGeometry";
    var e = [], i, n, s, a = [0, 0], c = {}, f = ["a", "b", "c"];
    if (t && t.isGeometry) {
      var v = t.faces, y = 0;
      for (n = v.length; y < n; y++) {
        var A = v[y];
        for (i = 0; 3 > i; i++) {
          var P = A[f[i]], k = A[f[(i + 1) % 3]];
          a[0] = Math.min(P, k), a[1] = Math.max(P, k), P = a[0] + "," + a[1], c[P] === void 0 && (c[P] = { index1: a[0], index2: a[1] });
        }
      }
      for (P in c)
        y = c[P], f = t.vertices[y.index1], e.push(f.x, f.y, f.z), f = t.vertices[y.index2], e.push(f.x, f.y, f.z);
    } else if (t && t.isBufferGeometry)
      if (f = new u(), t.index !== null) {
        v = t.attributes.position, A = t.index;
        var H = t.groups;
        for (H.length === 0 && (H = [{ start: 0, count: A.count, materialIndex: 0 }]), t = 0, s = H.length; t < s; ++t)
          for (y = H[t], i = y.start, n = y.count, y = i, n = i + n; y < n; y += 3)
            for (i = 0; 3 > i; i++)
              P = A.getX(y + i), k = A.getX(y + (i + 1) % 3), a[0] = Math.min(P, k), a[1] = Math.max(P, k), P = a[0] + "," + a[1], c[P] === void 0 && (c[P] = { index1: a[0], index2: a[1] });
        for (P in c)
          y = c[P], f.fromBufferAttribute(v, y.index1), e.push(f.x, f.y, f.z), f.fromBufferAttribute(v, y.index2), e.push(f.x, f.y, f.z);
      } else
        for (v = t.attributes.position, y = 0, n = v.count / 3; y < n; y++)
          for (i = 0; 3 > i; i++)
            c = 3 * y + i, f.fromBufferAttribute(v, c), e.push(f.x, f.y, f.z), c = 3 * y + (i + 1) % 3, f.fromBufferAttribute(v, c), e.push(f.x, f.y, f.z);
    this.addAttribute("position", new Et(e, 3));
  }
  function Fa(t, e, i) {
    j.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: i }, this.fromBufferGeometry(new Qo(t, e, i)), this.mergeVertices();
  }
  function Qo(t, e, i) {
    Ft.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: i };
    var n = [], s = [], a = [], c = [], f = new u(), v = new u(), y = new u(), A = new u(), P = new u(), k, H;
    3 > t.length && console.error(
      "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
    );
    var q = e + 1;
    for (k = 0; k <= i; k++) {
      var K = k / i;
      for (H = 0; H <= e; H++) {
        var rt = H / e;
        t(rt, K, v), s.push(v.x, v.y, v.z), 0 <= rt - 1e-5 ? (t(rt - 1e-5, K, y), A.subVectors(v, y)) : (t(rt + 1e-5, K, y), A.subVectors(y, v)), 0 <= K - 1e-5 ? (t(rt, K - 1e-5, y), P.subVectors(v, y)) : (t(rt, K + 1e-5, y), P.subVectors(y, v)), f.crossVectors(A, P).normalize(), a.push(f.x, f.y, f.z), c.push(rt, K);
      }
    }
    for (k = 0; k < i; k++)
      for (H = 0; H < e; H++)
        t = k * q + H + 1, f = (k + 1) * q + H + 1, v = (k + 1) * q + H, n.push(k * q + H, t, v), n.push(t, f, v);
    this.setIndex(n), this.addAttribute("position", new Et(s, 3)), this.addAttribute("normal", new Et(a, 3)), this.addAttribute("uv", new Et(c, 2));
  }
  function Wi(t, e, i, n) {
    j.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, this.fromBufferGeometry(new yi(t, e, i, n)), this.mergeVertices();
  }
  function yi(t, e, i, n) {
    function s(y) {
      f.push(y.x, y.y, y.z);
    }
    function a(y, A) {
      y *= 3, A.x = t[y + 0], A.y = t[y + 1], A.z = t[y + 2];
    }
    function c(y, A, P, k) {
      0 > k && y.x === 1 && (v[A] = y.x - 1), P.x === 0 && P.z === 0 && (v[A] = k / 2 / Math.PI + 0.5);
    }
    Ft.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, i = i || 1, n = n || 0;
    var f = [], v = [];
    (function(y) {
      for (var A = new u(), P = new u(), k = new u(), H = 0; H < e.length; H += 3) {
        a(e[H + 0], A), a(e[H + 1], P), a(e[H + 2], k);
        var q, K, rt = A, xt = P, gt = k, At = Math.pow(2, y), wt = [];
        for (K = 0; K <= At; K++) {
          wt[K] = [];
          var Vt = rt.clone().lerp(gt, K / At), Z = xt.clone().lerp(gt, K / At), st = At - K;
          for (q = 0; q <= st; q++)
            wt[K][q] = q === 0 && K === At ? Vt : Vt.clone().lerp(Z, q / st);
        }
        for (K = 0; K < At; K++)
          for (q = 0; q < 2 * (At - K) - 1; q++)
            rt = Math.floor(q / 2), q % 2 === 0 ? (s(wt[K][rt + 1]), s(wt[K + 1][rt]), s(wt[K][rt])) : (s(wt[K][rt + 1]), s(wt[K + 1][rt + 1]), s(wt[K + 1][rt]));
      }
    })(n), function(y) {
      for (var A = new u(), P = 0; P < f.length; P += 3)
        A.x = f[P + 0], A.y = f[P + 1], A.z = f[P + 2], A.normalize().multiplyScalar(y), f[P + 0] = A.x, f[P + 1] = A.y, f[P + 2] = A.z;
    }(i), function() {
      for (var y = new u(), A = 0; A < f.length; A += 3)
        y.x = f[A + 0], y.y = f[A + 1], y.z = f[A + 2], v.push(
          Math.atan2(y.z, -y.x) / 2 / Math.PI + 0.5,
          1 - (Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z)) / Math.PI + 0.5)
        );
      y = new u(), A = new u();
      for (var P = new u(), k = new u(), H = new o(), q = new o(), K = new o(), rt = 0, xt = 0; rt < f.length; rt += 9, xt += 6) {
        y.set(f[rt + 0], f[rt + 1], f[rt + 2]), A.set(f[rt + 3], f[rt + 4], f[rt + 5]), P.set(f[rt + 6], f[rt + 7], f[rt + 8]), H.set(v[xt + 0], v[xt + 1]), q.set(v[xt + 2], v[xt + 3]), K.set(v[xt + 4], v[xt + 5]), k.copy(y).add(A).add(P).divideScalar(3);
        var gt = Math.atan2(k.z, -k.x);
        c(H, xt + 0, y, gt), c(q, xt + 2, A, gt), c(K, xt + 4, P, gt);
      }
      for (y = 0; y < v.length; y += 6)
        A = v[y + 0], P = v[y + 2], k = v[y + 4], H = Math.min(A, P, k), 0.9 < Math.max(A, P, k) && 0.1 > H && (0.2 > A && (v[y + 0] += 1), 0.2 > P && (v[y + 2] += 1), 0.2 > k && (v[y + 4] += 1));
    }(), this.addAttribute("position", new Et(f, 3)), this.addAttribute("normal", new Et(f.slice(), 3)), this.addAttribute("uv", new Et(v, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Ua(t, e) {
    j.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ta(t, e)), this.mergeVertices();
  }
  function ta(t, e) {
    yi.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Ga(t, e) {
    j.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new fo(t, e)), this.mergeVertices();
  }
  function fo(t, e) {
    yi.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Ha(t, e) {
    j.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ea(t, e)), this.mergeVertices();
  }
  function ea(t, e) {
    var i = (1 + Math.sqrt(5)) / 2;
    yi.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1
      ],
      [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ],
      t,
      e
    ), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function ia(t, e) {
    j.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new na(t, e)), this.mergeVertices();
  }
  function na(t, e) {
    var i = (1 + Math.sqrt(5)) / 2, n = 1 / i;
    yi.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n
      ],
      [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ],
      t,
      e
    ), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function fn(t, e, i, n, s, a) {
    j.call(this), this.type = "TubeGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: s
    }, a !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed."), t = new Hs(t, e, i, n, s), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices();
  }
  function Hs(t, e, i, n, s) {
    function a(xt) {
      A = t.getPointAt(xt / e, A);
      var gt = c.normals[xt];
      for (xt = c.binormals[xt], k = 0; k <= n; k++) {
        var At = k / n * Math.PI * 2, wt = Math.sin(At);
        At = -Math.cos(At), v.x = At * gt.x + wt * xt.x, v.y = At * gt.y + wt * xt.y, v.z = At * gt.z + wt * xt.z, v.normalize(), q.push(v.x, v.y, v.z), f.x = A.x + i * v.x, f.y = A.y + i * v.y, f.z = A.z + i * v.z, H.push(f.x, f.y, f.z);
      }
    }
    Ft.call(this), this.type = "TubeBufferGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: s
    }, e = e || 64, i = i || 1, n = n || 8, s = s || !1;
    var c = t.computeFrenetFrames(e, s);
    this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals;
    var f = new u(), v = new u(), y = new o(), A = new u(), P, k, H = [], q = [], K = [], rt = [];
    for (P = 0; P < e; P++)
      a(P);
    for (a(s === !1 ? e : 0), P = 0; P <= e; P++)
      for (k = 0; k <= n; k++)
        y.x = P / e, y.y = k / n, K.push(y.x, y.y);
    (function() {
      for (k = 1; k <= e; k++)
        for (P = 1; P <= n; P++) {
          var xt = (n + 1) * k + (P - 1), gt = (n + 1) * k + P, At = (n + 1) * (k - 1) + P;
          rt.push((n + 1) * (k - 1) + (P - 1), xt, At), rt.push(xt, gt, At);
        }
    })(), this.setIndex(rt), this.addAttribute("position", new Et(H, 3)), this.addAttribute("normal", new Et(q, 3)), this.addAttribute("uv", new Et(K, 2));
  }
  function Vr(t, e, i, n, s, a, c) {
    j.call(this), this.type = "TorusKnotGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: s,
      q: a
    }, c !== void 0 && console.warn(
      "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
    ), this.fromBufferGeometry(new po(t, e, i, n, s, a)), this.mergeVertices();
  }
  function po(t, e, i, n, s, a) {
    function c(Z, st, zt, ee, $t) {
      var qt = Math.sin(Z);
      st = zt / st * Z, zt = Math.cos(st), $t.x = ee * (2 + zt) * 0.5 * Math.cos(Z), $t.y = ee * (2 + zt) * qt * 0.5, $t.z = ee * Math.sin(st) * 0.5;
    }
    Ft.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: s,
      q: a
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, s = s || 2, a = a || 3;
    var f = [], v = [], y = [], A = [], P, k = new u(), H = new u(), q = new u(), K = new u(), rt = new u(), xt = new u(), gt = new u();
    for (P = 0; P <= i; ++P) {
      var At = P / i * s * Math.PI * 2;
      for (c(At, s, a, t, q), c(At + 0.01, s, a, t, K), xt.subVectors(K, q), gt.addVectors(K, q), rt.crossVectors(xt, gt), gt.crossVectors(rt, xt), rt.normalize(), gt.normalize(), At = 0; At <= n; ++At) {
        var wt = At / n * Math.PI * 2, Vt = -e * Math.cos(wt);
        wt = e * Math.sin(wt), k.x = q.x + (Vt * gt.x + wt * rt.x), k.y = q.y + (Vt * gt.y + wt * rt.y), k.z = q.z + (Vt * gt.z + wt * rt.z), v.push(k.x, k.y, k.z), H.subVectors(k, q).normalize(), y.push(H.x, H.y, H.z), A.push(P / i), A.push(At / n);
      }
    }
    for (At = 1; At <= i; At++)
      for (P = 1; P <= n; P++)
        t = (n + 1) * At + (P - 1), e = (n + 1) * At + P, s = (n + 1) * (At - 1) + P, f.push((n + 1) * (At - 1) + (P - 1), t, s), f.push(t, e, s);
    this.setIndex(f), this.addAttribute("position", new Et(v, 3)), this.addAttribute("normal", new Et(y, 3)), this.addAttribute("uv", new Et(A, 2));
  }
  function mo(t, e, i, n, s) {
    j.call(this), this.type = "TorusGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: s
    }, this.fromBufferGeometry(new Nn(t, e, i, n, s)), this.mergeVertices();
  }
  function Nn(t, e, i, n, s) {
    Ft.call(this), this.type = "TorusBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: s
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, s = s || 2 * Math.PI;
    var a = [], c = [], f = [], v = [], y = new u(), A = new u(), P = new u(), k, H;
    for (k = 0; k <= i; k++)
      for (H = 0; H <= n; H++) {
        var q = H / n * s, K = k / i * Math.PI * 2;
        A.x = (t + e * Math.cos(K)) * Math.cos(q), A.y = (t + e * Math.cos(K)) * Math.sin(q), A.z = e * Math.sin(K), c.push(A.x, A.y, A.z), y.x = t * Math.cos(q), y.y = t * Math.sin(q), P.subVectors(A, y).normalize(), f.push(P.x, P.y, P.z), v.push(H / n), v.push(k / i);
      }
    for (k = 1; k <= i; k++)
      for (H = 1; H <= n; H++)
        t = (n + 1) * (k - 1) + H - 1, e = (n + 1) * (k - 1) + H, s = (n + 1) * k + H, a.push((n + 1) * k + H - 1, t, s), a.push(t, e, s);
    this.setIndex(a), this.addAttribute("position", new Et(c, 3)), this.addAttribute("normal", new Et(f, 3)), this.addAttribute("uv", new Et(v, 2));
  }
  function mh(t, e, i, n, s) {
    for (var a, c = 0, f = e, v = i - n; f < i; f += n)
      c += (t[v] - t[f]) * (t[f + 1] + t[v + 1]), v = f;
    if (s === 0 < c)
      for (s = e; s < i; s += n)
        a = Il(s, t[s], t[s + 1], a);
    else
      for (s = i - n; s >= e; s -= n)
        a = Il(s, t[s], t[s + 1], a);
    return a && go(a, a.next) && (Xi(a), a = a.next), a;
  }
  function ra(t, e) {
    if (!t)
      return t;
    e || (e = t);
    do {
      var i = !1;
      if (t.steiner || !go(t, t.next) && Yi(t.prev, t, t.next) !== 0)
        t = t.next;
      else {
        if (Xi(t), t = e = t.prev, t === t.next)
          break;
        i = !0;
      }
    } while (i || t !== e);
    return e;
  }
  function sa(t, e, i, n, s, a, c) {
    if (t) {
      if (!c && a) {
        var f = t, v = f;
        do
          v.z === null && (v.z = Rl(v.x, v.y, n, s, a)), v.prevZ = v.prev, v = v.nextZ = v.next;
        while (v !== f);
        v.prevZ.nextZ = null, v.prevZ = null, f = v;
        var y, A, P, k, H = 1;
        do {
          v = f;
          var q = f = null;
          for (A = 0; v; ) {
            A++;
            var K = v;
            for (y = P = 0; y < H && (P++, K = K.nextZ, K); y++)
              ;
            for (k = H; 0 < P || 0 < k && K; )
              P !== 0 && (k === 0 || !K || v.z <= K.z) ? (y = v, v = v.nextZ, P--) : (y = K, K = K.nextZ, k--), q ? q.nextZ = y : f = y, y.prevZ = q, q = y;
            v = K;
          }
          q.nextZ = null, H *= 2;
        } while (1 < A);
      }
      for (f = t; t.prev !== t.next; ) {
        if (v = t.prev, K = t.next, a)
          t: {
            q = t, k = n;
            var rt = s, xt = a;
            if (A = q.prev, P = q, H = q.next, 0 <= Yi(A, P, H))
              q = !1;
            else {
              var gt = A.x > P.x ? A.x > H.x ? A.x : H.x : P.x > H.x ? P.x : H.x, At = A.y > P.y ? A.y > H.y ? A.y : H.y : P.y > H.y ? P.y : H.y;
              for (y = Rl(
                A.x < P.x ? A.x < H.x ? A.x : H.x : P.x < H.x ? P.x : H.x,
                A.y < P.y ? A.y < H.y ? A.y : H.y : P.y < H.y ? P.y : H.y,
                k,
                rt,
                xt
              ), k = Rl(gt, At, k, rt, xt), rt = q.nextZ; rt && rt.z <= k; ) {
                if (rt !== q.prev && rt !== q.next && Ol(A.x, A.y, P.x, P.y, H.x, H.y, rt.x, rt.y) && 0 <= Yi(rt.prev, rt, rt.next)) {
                  q = !1;
                  break t;
                }
                rt = rt.nextZ;
              }
              for (rt = q.prevZ; rt && rt.z >= y; ) {
                if (rt !== q.prev && rt !== q.next && Ol(A.x, A.y, P.x, P.y, H.x, H.y, rt.x, rt.y) && 0 <= Yi(rt.prev, rt, rt.next)) {
                  q = !1;
                  break t;
                }
                rt = rt.prevZ;
              }
              q = !0;
            }
          }
        else
          t:
            if (q = t, A = q.prev, P = q, H = q.next, 0 <= Yi(A, P, H))
              q = !1;
            else {
              for (y = q.next.next; y !== q.prev; ) {
                if (Ol(A.x, A.y, P.x, P.y, H.x, H.y, y.x, y.y) && 0 <= Yi(y.prev, y, y.next)) {
                  q = !1;
                  break t;
                }
                y = y.next;
              }
              q = !0;
            }
        if (q)
          e.push(v.i / i), e.push(t.i / i), e.push(K.i / i), Xi(t), f = t = K.next;
        else if (t = K, t === f) {
          if (!c)
            sa(ra(t), e, i, n, s, a, 1);
          else if (c === 1) {
            c = e, f = i, v = t;
            do
              K = v.prev, q = v.next.next, !go(K, q) && gh(K, v, v.next, q) && Sr(K, q) && Sr(q, K) && (c.push(K.i / f), c.push(v.i / f), c.push(q.i / f), Xi(v), Xi(v.next), v = t = q), v = v.next;
            while (v !== t);
            t = v, sa(t, e, i, n, s, a, 2);
          } else if (c === 2)
            t: {
              c = t;
              do {
                for (f = c.next.next; f !== c.prev; ) {
                  if (v = c.i !== f.i) {
                    if (v = c, K = f, q = v.next.i !== K.i && v.prev.i !== K.i) {
                      e: {
                        q = v;
                        do {
                          if (q.i !== v.i && q.next.i !== v.i && q.i !== K.i && q.next.i !== K.i && gh(q, q.next, v, K)) {
                            q = !0;
                            break e;
                          }
                          q = q.next;
                        } while (q !== v);
                        q = !1;
                      }
                      q = !q;
                    }
                    if (q = q && Sr(v, K) && Sr(K, v)) {
                      q = v, A = !1, P = (v.x + K.x) / 2, K = (v.y + K.y) / 2;
                      do
                        q.y > K != q.next.y > K && q.next.y !== q.y && P < (q.next.x - q.x) * (K - q.y) / (q.next.y - q.y) + q.x && (A = !A), q = q.next;
                      while (q !== v);
                      q = A;
                    }
                    v = q;
                  }
                  if (v) {
                    t = Va(c, f), c = ra(c, c.next), t = ra(t, t.next), sa(c, e, i, n, s, a), sa(t, e, i, n, s, a);
                    break t;
                  }
                  f = f.next;
                }
                c = c.next;
              } while (c !== t);
            }
          break;
        }
      }
    }
  }
  function tu(t, e) {
    return t.x - e.x;
  }
  function eu(t, e) {
    var i = e, n = t.x, s = t.y, a = -1 / 0;
    do {
      if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
        var c = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
        if (c <= n && c > a) {
          if (a = c, c === n) {
            if (s === i.y)
              return i;
            if (s === i.next.y)
              return i.next;
          }
          var f = i.x < i.next.x ? i : i.next;
        }
      }
      i = i.next;
    } while (i !== e);
    if (!f)
      return null;
    if (n === a)
      return f.prev;
    e = f, c = f.x;
    var v = f.y, y = 1 / 0;
    for (i = f.next; i !== e; ) {
      if (n >= i.x && i.x >= c && n !== i.x && Ol(s < v ? n : a, s, c, v, s < v ? a : n, s, i.x, i.y)) {
        var A = Math.abs(s - i.y) / (n - i.x);
        (A < y || A === y && i.x > f.x) && Sr(i, t) && (f = i, y = A);
      }
      i = i.next;
    }
    return f;
  }
  function Rl(t, e, i, n, s) {
    return t = 32767 * (t - i) * s, e = 32767 * (e - n) * s, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, (t | t << 1) & 1431655765 | ((e | e << 1) & 1431655765) << 1;
  }
  function mr(t) {
    var e = t, i = t;
    do
      e.x < i.x && (i = e), e = e.next;
    while (e !== t);
    return i;
  }
  function Ol(t, e, i, n, s, a, c, f) {
    return 0 <= (s - c) * (e - f) - (t - c) * (a - f) && 0 <= (t - c) * (n - f) - (i - c) * (e - f) && 0 <= (i - c) * (a - f) - (s - c) * (n - f);
  }
  function Yi(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function go(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function gh(t, e, i, n) {
    return go(t, e) && go(i, n) || go(t, n) && go(i, e) ? !0 : 0 < Yi(t, e, i) != 0 < Yi(t, e, n) && 0 < Yi(i, n, t) != 0 < Yi(i, n, e);
  }
  function Sr(t, e) {
    return 0 > Yi(t.prev, t, t.next) ? 0 <= Yi(t, e, t.next) && 0 <= Yi(t, t.prev, e) : 0 > Yi(t, e, t.prev) || 0 > Yi(t, t.next, e);
  }
  function Va(t, e) {
    var i = new as(t.i, t.x, t.y), n = new as(e.i, e.x, e.y), s = t.next, a = e.prev;
    return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, a.next = n, n.prev = a, n;
  }
  function Il(t, e, i, n) {
    return t = new as(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t;
  }
  function Xi(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function as(t, e, i) {
    this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1;
  }
  function Dl(t) {
    var e = t.length;
    2 < e && t[e - 1].equals(t[0]) && t.pop();
  }
  function iu(t, e) {
    for (var i = 0; i < e.length; i++)
      t.push(e[i].x), t.push(e[i].y);
  }
  function As(t, e) {
    j.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new ls(t, e)), this.mergeVertices();
  }
  function ls(t, e) {
    function i(v) {
      function y(Xe, ri, Ai) {
        return ri || console.error("THREE.ExtrudeGeometry: vec does not exist"), ri.clone().multiplyScalar(Ai).add(Xe);
      }
      function A(Xe, ri, Ai) {
        var bi = Xe.x - ri.x, ne = Xe.y - ri.y, ii = Ai.x - Xe.x, Ze = Ai.y - Xe.y, ai = bi * bi + ne * ne;
        if (Math.abs(bi * Ze - ne * ii) > Number.EPSILON) {
          var gn = Math.sqrt(ai), bn = Math.sqrt(ii * ii + Ze * Ze);
          if (ai = ri.x - ne / gn, ri = ri.y + bi / gn, Ze = ((Ai.x - Ze / bn - ai) * Ze - (Ai.y + ii / bn - ri) * ii) / (bi * Ze - ne * ii), ii = ai + bi * Ze - Xe.x, bi = ri + ne * Ze - Xe.y, ne = ii * ii + bi * bi, 2 >= ne)
            return new o(ii, bi);
          ne = Math.sqrt(ne / 2);
        } else
          Xe = !1, bi > Number.EPSILON ? ii > Number.EPSILON && (Xe = !0) : bi < -Number.EPSILON ? ii < -Number.EPSILON && (Xe = !0) : Math.sign(ne) === Math.sign(Ze) && (Xe = !0), Xe ? (ii = -ne, ne = Math.sqrt(ai)) : (ii = bi, bi = ne, ne = Math.sqrt(ai / 2));
        return new o(ii / ne, bi / ne);
      }
      function P(Xe, ri) {
        for (Ae = Xe.length; 0 <= --Ae; ) {
          var Ai = Ae, bi = Ae - 1;
          0 > bi && (bi = Xe.length - 1);
          var ne, ii = gt + 2 * st;
          for (ne = 0; ne < ii; ne++) {
            var Ze = Gi * ne, ai = Gi * (ne + 1), gn = ri + bi + Ze, bn = ri + bi + ai;
            ai = ri + Ai + ai, q(ri + Ai + Ze), q(gn), q(ai), q(gn), q(bn), q(ai), Ze = s.length / 3, Ze = ee.generateSideWallUV(n, s, Ze - 6, Ze - 3, Ze - 2, Ze - 1), K(Ze[0]), K(Ze[1]), K(Ze[3]), K(Ze[1]), K(Ze[2]), K(Ze[3]);
          }
        }
      }
      function k(Xe, ri, Ai) {
        rt.push(Xe), rt.push(ri), rt.push(Ai);
      }
      function H(Xe, ri, Ai) {
        q(Xe), q(ri), q(Ai), Xe = s.length / 3, Xe = ee.generateTopUV(n, s, Xe - 3, Xe - 2, Xe - 1), K(Xe[0]), K(Xe[1]), K(Xe[2]);
      }
      function q(Xe) {
        s.push(rt[3 * Xe]), s.push(rt[3 * Xe + 1]), s.push(rt[3 * Xe + 2]);
      }
      function K(Xe) {
        a.push(Xe.x), a.push(Xe.y);
      }
      var rt = [], xt = e.curveSegments !== void 0 ? e.curveSegments : 12, gt = e.steps !== void 0 ? e.steps : 1, At = e.depth !== void 0 ? e.depth : 100, wt = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, Vt = e.bevelThickness !== void 0 ? e.bevelThickness : 6, Z = e.bevelSize !== void 0 ? e.bevelSize : Vt - 2, st = e.bevelSegments !== void 0 ? e.bevelSegments : 3, zt = e.extrudePath, ee = e.UVGenerator !== void 0 ? e.UVGenerator : ll;
      e.amount !== void 0 && (console.warn(
        "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
      ), At = e.amount);
      var $t = !1;
      if (zt) {
        var qt = zt.getSpacedPoints(gt);
        $t = !0, wt = !1;
        var Te = zt.computeFrenetFrames(gt, !1), me = new u(), Ie = new u(), be = new u();
      }
      wt || (Z = Vt = st = 0);
      var ae;
      xt = v.extractPoints(xt), v = xt.shape;
      var We = xt.holes;
      if (!gs.isClockWise(v)) {
        v = v.reverse();
        var Ke = 0;
        for (ae = We.length; Ke < ae; Ke++) {
          var ci = We[Ke];
          gs.isClockWise(ci) && (We[Ke] = ci.reverse());
        }
      }
      var Sn = gs.triangulateShape(v, We), mn = v;
      for (Ke = 0, ae = We.length; Ke < ae; Ke++)
        ci = We[Ke], v = v.concat(ci);
      var ji, Gi = v.length, en, En = Sn.length;
      xt = [];
      var Ae = 0, Qe = mn.length, Ut = Qe - 1;
      for (ji = Ae + 1; Ae < Qe; Ae++, Ut++, ji++)
        Ut === Qe && (Ut = 0), ji === Qe && (ji = 0), xt[Ae] = A(mn[Ae], mn[Ut], mn[ji]);
      zt = [];
      var Ye = xt.concat();
      for (Ke = 0, ae = We.length; Ke < ae; Ke++) {
        ci = We[Ke];
        var ei = [];
        for (Ae = 0, Qe = ci.length, Ut = Qe - 1, ji = Ae + 1; Ae < Qe; Ae++, Ut++, ji++)
          Ut === Qe && (Ut = 0), ji === Qe && (ji = 0), ei[Ae] = A(ci[Ae], ci[Ut], ci[ji]);
        zt.push(ei), Ye = Ye.concat(ei);
      }
      for (Ut = 0; Ut < st; Ut++) {
        Qe = Ut / st;
        var Hi = Vt * Math.cos(Qe * Math.PI / 2);
        for (ji = Z * Math.sin(Qe * Math.PI / 2), Ae = 0, Qe = mn.length; Ae < Qe; Ae++) {
          var Ce = y(mn[Ae], xt[Ae], ji);
          k(Ce.x, Ce.y, -Hi);
        }
        for (Ke = 0, ae = We.length; Ke < ae; Ke++)
          for (ci = We[Ke], ei = zt[Ke], Ae = 0, Qe = ci.length; Ae < Qe; Ae++)
            Ce = y(ci[Ae], ei[Ae], ji), k(Ce.x, Ce.y, -Hi);
      }
      for (ji = Z, Ae = 0; Ae < Gi; Ae++)
        Ce = wt ? y(v[Ae], Ye[Ae], ji) : v[Ae], $t ? (Ie.copy(Te.normals[0]).multiplyScalar(Ce.x), me.copy(Te.binormals[0]).multiplyScalar(Ce.y), be.copy(qt[0]).add(Ie).add(me), k(be.x, be.y, be.z)) : k(Ce.x, Ce.y, 0);
      for (Qe = 1; Qe <= gt; Qe++)
        for (Ae = 0; Ae < Gi; Ae++)
          Ce = wt ? y(v[Ae], Ye[Ae], ji) : v[Ae], $t ? (Ie.copy(Te.normals[Qe]).multiplyScalar(Ce.x), me.copy(Te.binormals[Qe]).multiplyScalar(Ce.y), be.copy(qt[Qe]).add(Ie).add(me), k(be.x, be.y, be.z)) : k(Ce.x, Ce.y, At / gt * Qe);
      for (Ut = st - 1; 0 <= Ut; Ut--) {
        for (Qe = Ut / st, Hi = Vt * Math.cos(Qe * Math.PI / 2), ji = Z * Math.sin(Qe * Math.PI / 2), Ae = 0, Qe = mn.length; Ae < Qe; Ae++)
          Ce = y(mn[Ae], xt[Ae], ji), k(Ce.x, Ce.y, At + Hi);
        for (Ke = 0, ae = We.length; Ke < ae; Ke++)
          for (ci = We[Ke], ei = zt[Ke], Ae = 0, Qe = ci.length; Ae < Qe; Ae++)
            Ce = y(ci[Ae], ei[Ae], ji), $t ? k(Ce.x, Ce.y + qt[gt - 1].y, qt[gt - 1].x + Hi) : k(Ce.x, Ce.y, At + Hi);
      }
      (function() {
        var Xe = s.length / 3;
        if (wt) {
          var ri = 0 * Gi;
          for (Ae = 0; Ae < En; Ae++)
            en = Sn[Ae], H(en[2] + ri, en[1] + ri, en[0] + ri);
          for (ri = Gi * (gt + 2 * st), Ae = 0; Ae < En; Ae++)
            en = Sn[Ae], H(en[0] + ri, en[1] + ri, en[2] + ri);
        } else {
          for (Ae = 0; Ae < En; Ae++)
            en = Sn[Ae], H(en[2], en[1], en[0]);
          for (Ae = 0; Ae < En; Ae++)
            en = Sn[Ae], H(en[0] + Gi * gt, en[1] + Gi * gt, en[2] + Gi * gt);
        }
        n.addGroup(Xe, s.length / 3 - Xe, 0);
      })(), function() {
        var Xe = s.length / 3, ri = 0;
        for (P(mn, ri), ri += mn.length, Ke = 0, ae = We.length; Ke < ae; Ke++)
          ci = We[Ke], P(ci, ri), ri += ci.length;
        n.addGroup(Xe, s.length / 3 - Xe, 1);
      }();
    }
    Ft.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
    for (var n = this, s = [], a = [], c = 0, f = t.length; c < f; c++)
      i(t[c]);
    this.addAttribute("position", new Et(s, 3)), this.addAttribute("uv", new Et(a, 2)), this.computeVertexNormals();
  }
  function nu(t, e, i) {
    if (i.shapes = [], Array.isArray(t))
      for (var n = 0, s = t.length; n < s; n++)
        i.shapes.push(t[n].uuid);
    else
      i.shapes.push(t.uuid);
    return e.extrudePath !== void 0 && (i.options.extrudePath = e.extrudePath.toJSON()), i;
  }
  function Wa(t, e) {
    j.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new vo(t, e)), this.mergeVertices();
  }
  function vo(t, e) {
    e = e || {};
    var i = e.font;
    if (!i || !i.isFont)
      return console.error(
        "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
      ), new j();
    t = i.generateShapes(t, e.size), e.depth = e.height !== void 0 ? e.height : 50, e.bevelThickness === void 0 && (e.bevelThickness = 10), e.bevelSize === void 0 && (e.bevelSize = 8), e.bevelEnabled === void 0 && (e.bevelEnabled = !1), ls.call(this, t, e), this.type = "TextBufferGeometry";
  }
  function Vs(t, e, i, n, s, a, c) {
    j.call(this), this.type = "SphereGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: s,
      thetaStart: a,
      thetaLength: c
    }, this.fromBufferGeometry(new Er(t, e, i, n, s, a, c)), this.mergeVertices();
  }
  function Er(t, e, i, n, s, a, c) {
    Ft.call(this), this.type = "SphereBufferGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: s,
      thetaStart: a,
      thetaLength: c
    }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = n !== void 0 ? n : 0, s = s !== void 0 ? s : 2 * Math.PI, a = a !== void 0 ? a : 0, c = c !== void 0 ? c : Math.PI;
    var f = a + c, v, y, A = 0, P = [], k = new u(), H = new u(), q = [], K = [], rt = [], xt = [];
    for (y = 0; y <= i; y++) {
      var gt = [], At = y / i;
      for (v = 0; v <= e; v++) {
        var wt = v / e;
        k.x = -t * Math.cos(n + wt * s) * Math.sin(a + At * c), k.y = t * Math.cos(a + At * c), k.z = t * Math.sin(n + wt * s) * Math.sin(a + At * c), K.push(k.x, k.y, k.z), H.set(k.x, k.y, k.z).normalize(), rt.push(H.x, H.y, H.z), xt.push(wt, 1 - At), gt.push(A++);
      }
      P.push(gt);
    }
    for (y = 0; y < i; y++)
      for (v = 0; v < e; v++)
        t = P[y][v + 1], n = P[y][v], s = P[y + 1][v], c = P[y + 1][v + 1], (y !== 0 || 0 < a) && q.push(t, n, c), (y !== i - 1 || f < Math.PI) && q.push(n, s, c);
    this.setIndex(q), this.addAttribute("position", new Et(K, 3)), this.addAttribute("normal", new Et(rt, 3)), this.addAttribute("uv", new Et(xt, 2));
  }
  function ja(t, e, i, n, s, a) {
    j.call(this), this.type = "RingGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: s,
      thetaLength: a
    }, this.fromBufferGeometry(new _o(t, e, i, n, s, a)), this.mergeVertices();
  }
  function _o(t, e, i, n, s, a) {
    Ft.call(this), this.type = "RingBufferGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: s,
      thetaLength: a
    }, t = t || 0.5, e = e || 1, s = s !== void 0 ? s : 0, a = a !== void 0 ? a : 2 * Math.PI, i = i !== void 0 ? Math.max(3, i) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
    var c = [], f = [], v = [], y = [], A = t, P = (e - t) / n, k = new u(), H = new o(), q, K;
    for (q = 0; q <= n; q++) {
      for (K = 0; K <= i; K++)
        t = s + K / i * a, k.x = A * Math.cos(t), k.y = A * Math.sin(t), f.push(k.x, k.y, k.z), v.push(0, 0, 1), H.x = (k.x / e + 1) / 2, H.y = (k.y / e + 1) / 2, y.push(H.x, H.y);
      A += P;
    }
    for (q = 0; q < n; q++)
      for (e = q * (i + 1), K = 0; K < i; K++)
        t = K + e, s = t + i + 1, a = t + i + 2, A = t + 1, c.push(t, s, A), c.push(s, a, A);
    this.setIndex(c), this.addAttribute("position", new Et(f, 3)), this.addAttribute("normal", new Et(v, 3)), this.addAttribute("uv", new Et(y, 2));
  }
  function oa(t, e, i, n) {
    j.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, this.fromBufferGeometry(new Ws(t, e, i, n)), this.mergeVertices();
  }
  function Ws(t, e, i, n) {
    Ft.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = fi.clamp(n, 0, 2 * Math.PI);
    var s = [], a = [], c = [], f = 1 / e, v = new u(), y = new o(), A;
    for (A = 0; A <= e; A++) {
      var P = i + A * f * n, k = Math.sin(P), H = Math.cos(P);
      for (P = 0; P <= t.length - 1; P++)
        v.x = t[P].x * k, v.y = t[P].y, v.z = t[P].x * H, a.push(v.x, v.y, v.z), y.x = A / e, y.y = P / (t.length - 1), c.push(y.x, y.y);
    }
    for (A = 0; A < e; A++)
      for (P = 0; P < t.length - 1; P++)
        i = P + A * t.length, f = i + t.length, v = i + t.length + 1, y = i + 1, s.push(i, f, y), s.push(f, v, y);
    if (this.setIndex(s), this.addAttribute("position", new Et(a, 3)), this.addAttribute("uv", new Et(c, 2)), this.computeVertexNormals(), n === 2 * Math.PI)
      for (n = this.attributes.normal.array, s = new u(), a = new u(), c = new u(), i = e * t.length * 3, P = A = 0; A < t.length; A++, P += 3)
        s.x = n[P + 0], s.y = n[P + 1], s.z = n[P + 2], a.x = n[i + P + 0], a.y = n[i + P + 1], a.z = n[i + P + 2], c.addVectors(s, a).normalize(), n[P + 0] = n[i + P + 0] = c.x, n[P + 1] = n[i + P + 1] = c.y, n[P + 2] = n[i + P + 2] = c.z;
  }
  function Cs(t, e) {
    j.call(this), this.type = "ShapeGeometry", typeof e == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new js(t, e)), this.mergeVertices();
  }
  function js(t, e) {
    function i(A) {
      var P, k = s.length / 3;
      A = A.extractPoints(e);
      var H = A.shape, q = A.holes;
      if (gs.isClockWise(H) === !1)
        for (H = H.reverse(), A = 0, P = q.length; A < P; A++) {
          var K = q[A];
          gs.isClockWise(K) === !0 && (q[A] = K.reverse());
        }
      var rt = gs.triangulateShape(H, q);
      for (A = 0, P = q.length; A < P; A++)
        K = q[A], H = H.concat(K);
      for (A = 0, P = H.length; A < P; A++)
        K = H[A], s.push(K.x, K.y, 0), a.push(0, 0, 1), c.push(K.x, K.y);
      for (A = 0, P = rt.length; A < P; A++)
        H = rt[A], n.push(H[0] + k, H[1] + k, H[2] + k), v += 3;
    }
    Ft.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12;
    var n = [], s = [], a = [], c = [], f = 0, v = 0;
    if (Array.isArray(t) === !1)
      i(t);
    else
      for (var y = 0; y < t.length; y++)
        i(t[y]), this.addGroup(f, v, y), f += v, v = 0;
    this.setIndex(n), this.addAttribute("position", new Et(s, 3)), this.addAttribute("normal", new Et(a, 3)), this.addAttribute("uv", new Et(c, 2));
  }
  function ru(t, e) {
    if (e.shapes = [], Array.isArray(t))
      for (var i = 0, n = t.length; i < n; i++)
        e.shapes.push(t[i].uuid);
    else
      e.shapes.push(t.uuid);
    return e;
  }
  function Xs(t, e) {
    Ft.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e };
    var i = [];
    e = Math.cos(fi.DEG2RAD * (e !== void 0 ? e : 1));
    var n = [0, 0], s = {}, a = ["a", "b", "c"];
    if (t.isBufferGeometry) {
      var c = new j();
      c.fromBufferGeometry(t);
    } else
      c = t.clone();
    c.mergeVertices(), c.computeFaceNormals(), t = c.vertices, c = c.faces;
    for (var f = 0, v = c.length; f < v; f++)
      for (var y = c[f], A = 0; 3 > A; A++) {
        var P = y[a[A]], k = y[a[(A + 1) % 3]];
        n[0] = Math.min(P, k), n[1] = Math.max(P, k), P = n[0] + "," + n[1], s[P] === void 0 ? s[P] = { index1: n[0], index2: n[1], face1: f, face2: void 0 } : s[P].face2 = f;
      }
    for (P in s)
      n = s[P], (n.face2 === void 0 || c[n.face1].normal.dot(c[n.face2].normal) <= e) && (a = t[n.index1], i.push(a.x, a.y, a.z), a = t[n.index2], i.push(a.x, a.y, a.z));
    this.addAttribute("position", new Et(i, 3));
  }
  function Ps(t, e, i, n, s, a, c, f) {
    j.call(this), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: a,
      thetaStart: c,
      thetaLength: f
    }, this.fromBufferGeometry(new Ls(t, e, i, n, s, a, c, f)), this.mergeVertices();
  }
  function Ls(t, e, i, n, s, a, c, f) {
    function v(gt) {
      var At, wt = new o(), Vt = new u(), Z = 0, st = gt === !0 ? t : e, zt = gt === !0 ? 1 : -1, ee = q;
      for (At = 1; At <= n; At++)
        P.push(0, rt * zt, 0), k.push(0, zt, 0), H.push(0.5, 0.5), q++;
      var $t = q;
      for (At = 0; At <= n; At++) {
        var qt = At / n * f + c, Te = Math.cos(qt);
        qt = Math.sin(qt), Vt.x = st * qt, Vt.y = rt * zt, Vt.z = st * Te, P.push(Vt.x, Vt.y, Vt.z), k.push(0, zt, 0), wt.x = 0.5 * Te + 0.5, wt.y = 0.5 * qt * zt + 0.5, H.push(wt.x, wt.y), q++;
      }
      for (At = 0; At < n; At++)
        wt = ee + At, Vt = $t + At, gt === !0 ? A.push(Vt, Vt + 1, wt) : A.push(Vt + 1, Vt, wt), Z += 3;
      y.addGroup(xt, Z, gt === !0 ? 1 : 2), xt += Z;
    }
    Ft.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: a,
      thetaStart: c,
      thetaLength: f
    };
    var y = this;
    t = t !== void 0 ? t : 1, e = e !== void 0 ? e : 1, i = i || 1, n = Math.floor(n) || 8, s = Math.floor(s) || 1, a = a !== void 0 ? a : !1, c = c !== void 0 ? c : 0, f = f !== void 0 ? f : 2 * Math.PI;
    var A = [], P = [], k = [], H = [], q = 0, K = [], rt = i / 2, xt = 0;
    (function() {
      var gt, At, wt = new u(), Vt = new u(), Z = 0, st = (e - t) / i;
      for (At = 0; At <= s; At++) {
        var zt = [], ee = At / s, $t = ee * (e - t) + t;
        for (gt = 0; gt <= n; gt++) {
          var qt = gt / n, Te = qt * f + c, me = Math.sin(Te);
          Te = Math.cos(Te), Vt.x = $t * me, Vt.y = -ee * i + rt, Vt.z = $t * Te, P.push(Vt.x, Vt.y, Vt.z), wt.set(me, st, Te).normalize(), k.push(wt.x, wt.y, wt.z), H.push(qt, 1 - ee), zt.push(q++);
        }
        K.push(zt);
      }
      for (gt = 0; gt < n; gt++)
        for (At = 0; At < s; At++)
          wt = K[At + 1][gt], Vt = K[At + 1][gt + 1], st = K[At][gt + 1], A.push(K[At][gt], wt, st), A.push(wt, Vt, st), Z += 6;
      y.addGroup(xt, Z, 0), xt += Z;
    })(), a === !1 && (0 < t && v(!0), 0 < e && v(!1)), this.setIndex(A), this.addAttribute("position", new Et(P, 3)), this.addAttribute("normal", new Et(k, 3)), this.addAttribute("uv", new Et(H, 2));
  }
  function aa(t, e, i, n, s, a, c) {
    Ps.call(this, 0, t, e, i, n, s, a, c), this.type = "ConeGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: s,
      thetaStart: a,
      thetaLength: c
    };
  }
  function Fn(t, e, i, n, s, a, c) {
    Ls.call(this, 0, t, e, i, n, s, a, c), this.type = "ConeBufferGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: s,
      thetaStart: a,
      thetaLength: c
    };
  }
  function yo(t, e, i, n) {
    j.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new hs(t, e, i, n)), this.mergeVertices();
  }
  function hs(t, e, i, n) {
    Ft.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, t = t || 1, e = e !== void 0 ? Math.max(3, e) : 8, i = i !== void 0 ? i : 0, n = n !== void 0 ? n : 2 * Math.PI;
    var s = [], a = [], c = [], f = [], v, y = new u(), A = new o();
    a.push(0, 0, 0), c.push(0, 0, 1), f.push(0.5, 0.5);
    var P = 0;
    for (v = 3; P <= e; P++, v += 3) {
      var k = i + P / e * n;
      y.x = t * Math.cos(k), y.y = t * Math.sin(k), a.push(y.x, y.y, y.z), c.push(0, 0, 1), A.x = (a[v] / t + 1) / 2, A.y = (a[v + 1] / t + 1) / 2, f.push(A.x, A.y);
    }
    for (v = 1; v <= e; v++)
      s.push(v, v + 1, 0);
    this.setIndex(s), this.addAttribute("position", new Et(a, 3)), this.addAttribute("normal", new Et(c, 3)), this.addAttribute("uv", new Et(f, 2));
  }
  function qs(t) {
    Yt.call(this), this.type = "ShadowMaterial", this.color = new L(0), this.transparent = !0, this.setValues(t);
  }
  function xo(t) {
    ti.call(this, t), this.type = "RawShaderMaterial";
  }
  function us(t) {
    Yt.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new L(16777215), this.metalness = this.roughness = 0.5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new o(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function wo(t) {
    us.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t);
  }
  function Wr(t) {
    Yt.call(this), this.type = "MeshPhongMaterial", this.color = new L(16777215), this.specular = new L(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new o(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function To(t) {
    Wr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t);
  }
  function Mo(t) {
    Yt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new o(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t);
  }
  function br(t) {
    Yt.call(this), this.type = "MeshLambertMaterial", this.color = new L(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function So(t) {
    if (Yt.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new L(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new o(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t), this.matcap === null) {
      t = document.createElement("canvas"), t.width = 1, t.height = 1;
      var e = t.getContext("2d");
      e.fillStyle = "#fff", e.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t);
    }
  }
  function Eo(t) {
    Di.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
  }
  function Zn(t, e, i, n) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i;
  }
  function Xa(t, e, i, n) {
    Zn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function Ar(t, e, i, n) {
    Zn.call(this, t, e, i, n);
  }
  function bo(t, e, i, n) {
    Zn.call(this, t, e, i, n);
  }
  function Un(t, e, i, n) {
    if (t === void 0)
      throw Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = Wn.convertArray(e, this.TimeBufferType), this.values = Wn.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  function zl(t, e, i) {
    Un.call(this, t, e, i);
  }
  function kl(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function jr(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function ir(t, e, i, n) {
    Zn.call(this, t, e, i, n);
  }
  function la(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function Bl(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function ha(t, e, i, n) {
    Un.call(this, t, e, i, n);
  }
  function gr(t, e, i) {
    this.name = t, this.tracks = i, this.duration = e !== void 0 ? e : -1, this.uuid = fi.generateUUID(), 0 > this.duration && this.resetDuration();
  }
  function Ju(t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return jr;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ha;
      case "color":
        return kl;
      case "quaternion":
        return la;
      case "bool":
      case "boolean":
        return zl;
      case "string":
        return Bl;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }
  function $u(t) {
    if (t.type === void 0)
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var e = Ju(t.type);
    if (t.times === void 0) {
      var i = [], n = [];
      Wn.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n;
    }
    return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
  }
  function Ys(t, e, i) {
    var n = this, s = !1, a = 0, c = 0, f = void 0;
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(v) {
      c++, s === !1 && n.onStart !== void 0 && n.onStart(v, a, c), s = !0;
    }, this.itemEnd = function(v) {
      a++, n.onProgress !== void 0 && n.onProgress(v, a, c), a === c && (s = !1, n.onLoad !== void 0) && n.onLoad();
    }, this.itemError = function(v) {
      n.onError !== void 0 && n.onError(v);
    }, this.resolveURL = function(v) {
      return f ? f(v) : v;
    }, this.setURLModifier = function(v) {
      return f = v, this;
    };
  }
  function Lt(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Qt(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Zt(t) {
    this.manager = t !== void 0 ? t : Kn, this._parser = null;
  }
  function Ue(t) {
    this.manager = t !== void 0 ? t : Kn, this._parser = null;
  }
  function oi(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function zi(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function ln(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Ee() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  function Jn(t, e, i, n, s, a, c, f) {
    Ee.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = s || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = c || !1, this.aRotation = f || 0;
  }
  function ua(t, e, i, n, s, a) {
    Jn.call(this, t, e, i, i, n, s, a), this.type = "ArcCurve";
  }
  function nr() {
    var t = 0, e = 0, i = 0, n = 0;
    return {
      initCatmullRom: function(s, a, c, f, v) {
        s = v * (c - s), f = v * (f - a), t = a, e = s, i = -3 * a + 3 * c - 2 * s - f, n = 2 * a - 2 * c + s + f;
      },
      initNonuniformCatmullRom: function(s, a, c, f, v, y, A) {
        s = ((a - s) / v - (c - s) / (v + y) + (c - a) / y) * y, f = ((c - a) / y - (f - a) / (y + A) + (f - c) / A) * y, t = a, e = s, i = -3 * a + 3 * c - 2 * s - f, n = 2 * a - 2 * c + s + f;
      },
      calc: function(s) {
        var a = s * s;
        return t + e * s + i * a + n * a * s;
      }
    };
  }
  function Pn(t, e, i, n) {
    Ee.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || 0.5;
  }
  function su(t, e, i, n, s) {
    e = 0.5 * (n - e), s = 0.5 * (s - i);
    var a = t * t;
    return (2 * i - 2 * n + e + s) * t * a + (-3 * i + 3 * n - 2 * e - s) * a + e * t + i;
  }
  function cs(t, e, i, n) {
    var s = 1 - t;
    return s * s * e + 2 * (1 - t) * t * i + t * t * n;
  }
  function Zs(t, e, i, n, s) {
    var a = 1 - t, c = 1 - t;
    return a * a * a * e + 3 * c * c * t * i + 3 * (1 - t) * t * t * n + t * t * t * s;
  }
  function rr(t, e, i, n) {
    Ee.call(this), this.type = "CubicBezierCurve", this.v0 = t || new o(), this.v1 = e || new o(), this.v2 = i || new o(), this.v3 = n || new o();
  }
  function wi(t, e, i, n) {
    Ee.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new u(), this.v1 = e || new u(), this.v2 = i || new u(), this.v3 = n || new u();
  }
  function sr(t, e) {
    Ee.call(this), this.type = "LineCurve", this.v1 = t || new o(), this.v2 = e || new o();
  }
  function Cr(t, e) {
    Ee.call(this), this.type = "LineCurve3", this.v1 = t || new u(), this.v2 = e || new u();
  }
  function or(t, e, i) {
    Ee.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new o(), this.v1 = e || new o(), this.v2 = i || new o();
  }
  function fs(t, e, i) {
    Ee.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new u(), this.v1 = e || new u(), this.v2 = i || new u();
  }
  function Xr(t) {
    Ee.call(this), this.type = "SplineCurve", this.points = t || [];
  }
  function Rs() {
    Ee.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  function ar(t) {
    Rs.call(this), this.type = "Path", this.currentPoint = new o(), t && this.setFromPoints(t);
  }
  function $n(t) {
    ar.call(this, t), this.uuid = fi.generateUUID(), this.type = "Shape", this.holes = [];
  }
  function $i(t, e) {
    N.call(this), this.type = "Light", this.color = new L(t), this.intensity = e !== void 0 ? e : 1, this.receiveShadow = void 0;
  }
  function qa(t, e, i) {
    $i.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(N.DefaultUp), this.updateMatrix(), this.groundColor = new L(e);
  }
  function ps(t) {
    this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new o(512, 512), this.map = null, this.matrix = new p();
  }
  function Ya() {
    ps.call(this, new ye(50, 1, 0.5, 500));
  }
  function Za(t, e, i, n, s, a) {
    $i.call(this, t, e), this.type = "SpotLight", this.position.copy(N.DefaultUp), this.updateMatrix(), this.target = new N(), Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(c) {
        this.intensity = c / Math.PI;
      }
    }), this.distance = i !== void 0 ? i : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = s !== void 0 ? s : 0, this.decay = a !== void 0 ? a : 1, this.shadow = new Ya();
  }
  function Ao(t, e, i, n) {
    $i.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
      get: function() {
        return 4 * this.intensity * Math.PI;
      },
      set: function(s) {
        this.intensity = s / (4 * Math.PI);
      }
    }), this.distance = i !== void 0 ? i : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new ps(new ye(90, 1, 0.5, 500));
  }
  function ca(t, e, i, n, s, a) {
    Be.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t !== void 0 ? t : -1, this.right = e !== void 0 ? e : 1, this.top = i !== void 0 ? i : 1, this.bottom = n !== void 0 ? n : -1, this.near = s !== void 0 ? s : 0.1, this.far = a !== void 0 ? a : 2e3, this.updateProjectionMatrix();
  }
  function Js() {
    ps.call(this, new ca(-5, 5, 5, -5, 0.5, 500));
  }
  function ds(t, e) {
    $i.call(this, t, e), this.type = "DirectionalLight", this.position.copy(N.DefaultUp), this.updateMatrix(), this.target = new N(), this.shadow = new Js();
  }
  function Co(t, e) {
    $i.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0;
  }
  function Nl(t, e, i, n) {
    $i.call(this, t, e), this.type = "RectAreaLight", this.width = i !== void 0 ? i : 10, this.height = n !== void 0 ? n : 10;
  }
  function Fl(t) {
    this.manager = t !== void 0 ? t : Kn, this.textures = {};
  }
  function vh(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Os() {
  }
  function Po(t) {
    typeof t == "boolean" && (console.warn(
      "THREE.JSONLoader: showStatus parameter has been removed from constructor."
    ), t = void 0), this.manager = t !== void 0 ? t : Kn, this.withCredentials = !1;
  }
  function Ja(t) {
    this.manager = t !== void 0 ? t : Kn, this.resourcePath = "";
  }
  function _h(t) {
    typeof createImageBitmap > "u" && console.warn(
      "THREE.ImageBitmapLoader: createImageBitmap() not supported."
    ), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = t !== void 0 ? t : Kn, this.options = void 0;
  }
  function Ul() {
    this.type = "ShapePath", this.color = new L(), this.subPaths = [], this.currentPath = null;
  }
  function yh(t) {
    this.type = "Font", this.data = t;
  }
  function ou(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function pn(t) {
    this.manager = t !== void 0 ? t : Kn;
  }
  function Gn() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ye(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ye(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
  }
  function $a(t, e, i, n) {
    N.call(this), this.type = "CubeCamera";
    var s = new ye(90, 1, t, e);
    s.up.set(0, -1, 0), s.lookAt(new u(1, 0, 0)), this.add(s);
    var a = new ye(90, 1, t, e);
    a.up.set(0, -1, 0), a.lookAt(new u(-1, 0, 0)), this.add(a);
    var c = new ye(90, 1, t, e);
    c.up.set(0, 0, 1), c.lookAt(new u(0, 1, 0)), this.add(c);
    var f = new ye(90, 1, t, e);
    f.up.set(0, 0, -1), f.lookAt(new u(0, -1, 0)), this.add(f);
    var v = new ye(90, 1, t, e);
    v.up.set(0, -1, 0), v.lookAt(new u(0, 0, 1)), this.add(v);
    var y = new ye(90, 1, t, e);
    y.up.set(0, -1, 0), y.lookAt(new u(0, 0, -1)), this.add(y), n = n || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new C(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(A, P) {
      this.parent === null && this.updateMatrixWorld();
      var k = this.renderTarget, H = k.texture.generateMipmaps;
      k.texture.generateMipmaps = !1, k.activeCubeFace = 0, A.render(P, s, k), k.activeCubeFace = 1, A.render(P, a, k), k.activeCubeFace = 2, A.render(P, c, k), k.activeCubeFace = 3, A.render(P, f, k), k.activeCubeFace = 4, A.render(P, v, k), k.texture.generateMipmaps = H, k.activeCubeFace = 5, A.render(P, y, k), A.setRenderTarget(null);
    }, this.clear = function(A, P, k, H) {
      for (var q = this.renderTarget, K = 0; 6 > K; K++)
        q.activeCubeFace = K, A.setRenderTarget(q), A.clear(P, k, H);
      A.setRenderTarget(null);
    };
  }
  function xh(t) {
    this.autoStart = t !== void 0 ? t : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1;
  }
  function Gl() {
    N.call(this), this.type = "AudioListener", this.context = Lh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0;
  }
  function fa(t) {
    N.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
  }
  function Ka(t) {
    fa.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
  }
  function Lo(t, e) {
    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e !== void 0 ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
  }
  function Qa(t, e, i) {
    switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
      case "quaternion":
        e = this._slerp;
        break;
      case "string":
      case "bool":
        t = Array, e = this._select;
        break;
      default:
        e = this._lerp;
    }
    this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function Ro(t, e, i) {
    i = i || Tn.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }
  function Tn(t, e, i) {
    this.path = e, this.parsedPath = i || Tn.parseTrackName(e), this.node = Tn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
  }
  function pa() {
    this.uuid = fi.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var e = 0, i = arguments.length; e !== i; ++e)
      t[arguments[e].uuid] = e;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  function tl(t, e, i) {
    this._mixer = t, this._clip = e, this._localRoot = i || null, t = e.tracks, e = t.length, i = Array(e);
    for (var n = { endingStart: 2400, endingEnd: 2400 }, s = 0; s !== e; ++s) {
      var a = t[s].createInterpolant(null);
      i[s] = a, a.settings = n;
    }
    this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function $s(t) {
    this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
  }
  function Hl(t, e) {
    typeof t == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t;
  }
  function wh() {
    Ft.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
  }
  function Th(t, e, i) {
    Oi.call(this, t, e), this.meshPerAttribute = i || 1;
  }
  function Mh(t, e, i, n) {
    typeof i == "number" && (n = i, i = !1, console.error(
      "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
    )), J.call(this, t, e, i), this.meshPerAttribute = n || 1;
  }
  function au(t, e, i, n) {
    this.ray = new Ni(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    }, Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          return console.warn(
            "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
          ), this.Points;
        }
      }
    });
  }
  function el(t, e) {
    return t.distance - e.distance;
  }
  function Oo(t, e, i, n) {
    if (t.visible !== !1 && (t.raycast(e, i), n === !0)) {
      t = t.children, n = 0;
      for (var s = t.length; n < s; n++)
        Oo(t[n], e, i, !0);
    }
  }
  function Sh(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.phi = e !== void 0 ? e : 0, this.theta = i !== void 0 ? i : 0, this;
  }
  function it(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.theta = e !== void 0 ? e : 0, this.y = i !== void 0 ? i : 0, this;
  }
  function Ks(t, e) {
    this.min = t !== void 0 ? t : new o(1 / 0, 1 / 0), this.max = e !== void 0 ? e : new o(-1 / 0, -1 / 0);
  }
  function da(t, e) {
    this.start = t !== void 0 ? t : new u(), this.end = e !== void 0 ? e : new u();
  }
  function Vn(t) {
    N.call(this), this.material = t, this.render = function() {
    };
  }
  function _i(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16711680, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new Ft(), e = new Et(6 * e, 3), i.addAttribute("position", e), mi.call(this, i, new Di({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function ma(t, e) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new Ft(), e = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (var i = 0, n = 1; 32 > i; i++, n++) {
      var s = i / 32 * Math.PI * 2, a = n / 32 * Math.PI * 2;
      e.push(Math.cos(s), Math.sin(s), 1, Math.cos(a), Math.sin(a), 1);
    }
    t.addAttribute("position", new Et(e, 3)), e = new Di({ fog: !1 }), this.cone = new mi(t, e), this.add(this.cone), this.update();
  }
  function lu(t) {
    var e = [];
    t && t.isBone && e.push(t);
    for (var i = 0; i < t.children.length; i++)
      e.push.apply(e, lu(t.children[i]));
    return e;
  }
  function ga(t) {
    for (var e = lu(t), i = new Ft(), n = [], s = [], a = new L(0, 0, 1), c = new L(0, 1, 0), f = 0; f < e.length; f++) {
      var v = e[f];
      v.parent && v.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), s.push(a.r, a.g, a.b), s.push(c.r, c.g, c.b));
    }
    i.addAttribute("position", new Et(n, 3)), i.addAttribute("color", new Et(s, 3)), n = new Di({
      vertexColors: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), mi.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
  }
  function Pr(t, e, i) {
    this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new Er(e, 4, 2), e = new Ge({ wireframe: !0, fog: !1 }), pi.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  function va(t, e) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new Di({ fog: !1 }), e = new Ft(), e.addAttribute("position", new J(new Float32Array(15), 3)), this.line = new Vi(e, t), this.add(this.line), this.update();
  }
  function _a(t, e, i) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t = new fo(e), t.rotateY(0.5 * Math.PI), this.material = new Ge({ wireframe: !0, fog: !1 }), this.color === void 0 && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new J(e, 3)), this.add(new pi(t, this.material)), this.update();
  }
  function il(t, e, i, n) {
    t = t || 10, e = e || 10, i = new L(i !== void 0 ? i : 4473924), n = new L(n !== void 0 ? n : 8947848);
    var s = e / 2, a = t / e, c = t / 2;
    t = [];
    for (var f = [], v = 0, y = 0, A = -c; v <= e; v++, A += a) {
      t.push(-c, 0, A, c, 0, A), t.push(A, 0, -c, A, 0, c);
      var P = v === s ? i : n;
      P.toArray(f, y), y += 3, P.toArray(f, y), y += 3, P.toArray(f, y), y += 3, P.toArray(f, y), y += 3;
    }
    e = new Ft(), e.addAttribute("position", new Et(t, 3)), e.addAttribute("color", new Et(f, 3)), i = new Di({ vertexColors: 2 }), mi.call(this, e, i);
  }
  function Vl(t, e, i, n, s, a) {
    t = t || 10, e = e || 16, i = i || 8, n = n || 64, s = new L(s !== void 0 ? s : 4473924), a = new L(a !== void 0 ? a : 8947848);
    var c = [], f = [], v;
    for (v = 0; v <= e; v++) {
      var y = v / e * 2 * Math.PI, A = Math.sin(y) * t;
      y = Math.cos(y) * t, c.push(0, 0, 0), c.push(A, 0, y);
      var P = v & 1 ? s : a;
      f.push(P.r, P.g, P.b), f.push(P.r, P.g, P.b);
    }
    for (v = 0; v <= i; v++) {
      P = v & 1 ? s : a;
      var k = t - t / i * v;
      for (e = 0; e < n; e++)
        y = e / n * 2 * Math.PI, A = Math.sin(y) * k, y = Math.cos(y) * k, c.push(A, 0, y), f.push(P.r, P.g, P.b), y = (e + 1) / n * 2 * Math.PI, A = Math.sin(y) * k, y = Math.cos(y) * k, c.push(A, 0, y), f.push(P.r, P.g, P.b);
    }
    t = new Ft(), t.addAttribute("position", new Et(c, 3)), t.addAttribute("color", new Et(f, 3)), c = new Di({ vertexColors: 2 }), mi.call(this, t, c);
  }
  function nl(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16776960, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn(
      "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
    ), i = new Ft(), e = new Et(6 * e, 3), i.addAttribute("position", e), mi.call(this, i, new Di({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function lr(t, e, i) {
    N.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, e === void 0 && (e = 1), t = new Ft(), t.addAttribute(
      "position",
      new Et([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    ), e = new Di({ fog: !1 }), this.lightPlane = new Vi(t, e), this.add(this.lightPlane), t = new Ft(), t.addAttribute("position", new Et([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Vi(t, e), this.add(this.targetLine), this.update();
  }
  function rl(t) {
    function e(H, q, K) {
      i(H, K), i(q, K);
    }
    function i(H, q) {
      a.push(0, 0, 0), c.push(q.r, q.g, q.b), f[H] === void 0 && (f[H] = []), f[H].push(a.length / 3 - 1);
    }
    var n = new Ft(), s = new Di({ color: 16777215, vertexColors: 1 }), a = [], c = [], f = {}, v = new L(16755200), y = new L(16711680), A = new L(43775), P = new L(16777215), k = new L(3355443);
    e("n1", "n2", v), e("n2", "n4", v), e("n4", "n3", v), e("n3", "n1", v), e("f1", "f2", v), e("f2", "f4", v), e("f4", "f3", v), e("f3", "f1", v), e("n1", "f1", v), e("n2", "f2", v), e("n3", "f3", v), e("n4", "f4", v), e("p", "n1", y), e("p", "n2", y), e("p", "n3", y), e("p", "n4", y), e("u1", "u2", A), e("u2", "u3", A), e("u3", "u1", A), e("c", "t", P), e("p", "c", k), e("cn1", "cn2", k), e("cn3", "cn4", k), e("cf1", "cf2", k), e("cf3", "cf4", k), n.addAttribute("position", new Et(a, 3)), n.addAttribute("color", new Et(c, 3)), mi.call(this, n, s), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = f, this.update();
  }
  function Is(t, e) {
    this.object = t, e === void 0 && (e = 16776960), t = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Float32Array(24), n = new Ft();
    n.setIndex(new J(t, 1)), n.addAttribute("position", new J(i, 3)), mi.call(this, n, new Di({ color: e })), this.matrixAutoUpdate = !1, this.update();
  }
  function sl(t, e) {
    this.type = "Box3Helper", this.box = t, t = e !== void 0 ? e : 16776960, e = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Ft();
    i.setIndex(new J(e, 1)), i.addAttribute(
      "position",
      new Et(
        [
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          -1
        ],
        3
      )
    ), mi.call(this, i, new Di({ color: t })), this.geometry.computeBoundingSphere();
  }
  function ol(t, e, i) {
    this.type = "PlaneHelper", this.plane = t, this.size = e === void 0 ? 1 : e, t = i !== void 0 ? i : 16776960, e = new Ft(), e.addAttribute(
      "position",
      new Et(
        [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        3
      )
    ), e.computeBoundingSphere(), Vi.call(this, e, new Di({ color: t })), e = new Ft(), e.addAttribute(
      "position",
      new Et([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    ), e.computeBoundingSphere(), this.add(
      new pi(
        e,
        new Ge({ color: t, opacity: 0.2, transparent: !0, depthWrite: !1 })
      )
    );
  }
  function Ds(t, e, i, n, s, a) {
    N.call(this), t === void 0 && (t = new THREE.Vector3(0, 0, 1)), e === void 0 && (e = new THREE.Vector3(0, 0, 0)), i === void 0 && (i = 1), n === void 0 && (n = 16776960), s === void 0 && (s = 0.2 * i), a === void 0 && (a = 0.2 * s), Zl === void 0 && (Zl = new Ft(), Zl.addAttribute("position", new Et([0, 0, 0, 0, 1, 0], 3)), ul = new Ls(0, 0.5, 1, 5, 1), ul.translate(0, -0.5, 0)), this.position.copy(e), this.line = new Vi(Zl, new Di({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new pi(ul, new Ge({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, s, a);
  }
  function vr(t) {
    t = t || 1;
    var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
    t = new Ft(), t.addAttribute("position", new Et(e, 3)), t.addAttribute(
      "color",
      new Et([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
    ), e = new Di({ vertexColors: 2 }), mi.call(this, t, e);
  }
  function hu(t) {
    console.warn(
      "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), Pn.call(this, t), this.type = "catmullrom", this.closed = !0;
  }
  function uu(t) {
    console.warn(
      "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), Pn.call(this, t), this.type = "catmullrom";
  }
  function Eh(t) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
    ), Pn.call(this, t), this.type = "catmullrom";
  }
  Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52)), Number.isInteger === void 0 && (Number.isInteger = function(t) {
    return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
  }), Math.sign === void 0 && (Math.sign = function(t) {
    return 0 > t ? -1 : 0 < t ? 1 : +t;
  }), !("name" in Function.prototype) && Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  }), Object.assign === void 0 && function() {
    Object.assign = function(t) {
      if (t == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var e = Object(t), i = 1; i < arguments.length; i++) {
        var n = arguments[i];
        if (n != null)
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
      }
      return e;
    };
  }(), Object.assign(l.prototype, {
    addEventListener: function(t, e) {
      this._listeners === void 0 && (this._listeners = {});
      var i = this._listeners;
      i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
    },
    hasEventListener: function(t, e) {
      if (this._listeners === void 0)
        return !1;
      var i = this._listeners;
      return i[t] !== void 0 && i[t].indexOf(e) !== -1;
    },
    removeEventListener: function(t, e) {
      this._listeners !== void 0 && (t = this._listeners[t], t !== void 0 && (e = t.indexOf(e), e !== -1 && t.splice(e, 1)));
    },
    dispatchEvent: function(t) {
      if (this._listeners !== void 0) {
        var e = this._listeners[t.type];
        if (e !== void 0) {
          t.target = this, e = e.slice(0);
          for (var i = 0, n = e.length; i < n; i++)
            e[i].call(this, t);
        }
      }
    }
  });
  var fi = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      for (var t = [], e = 0; 256 > e; e++)
        t[e] = (16 > e ? "0" : "") + e.toString(16);
      return function() {
        var i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, s = 4294967295 * Math.random() | 0, a = 4294967295 * Math.random() | 0;
        return (t[i & 255] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255] + "-" + t[n & 255] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[s & 63 | 128] + t[s >> 8 & 255] + "-" + t[s >> 16 & 255] + t[s >> 24 & 255] + t[a & 255] + t[a >> 8 & 255] + t[a >> 16 & 255] + t[a >> 24 & 255]).toUpperCase();
      };
    }(),
    clamp: function(t, e, i) {
      return Math.max(e, Math.min(i, t));
    },
    euclideanModulo: function(t, e) {
      return (t % e + e) % e;
    },
    mapLinear: function(t, e, i, n, s) {
      return n + (t - e) * (s - n) / (i - e);
    },
    lerp: function(t, e, i) {
      return (1 - i) * t + i * e;
    },
    smoothstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * (3 - 2 * t));
    },
    smootherstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * t * (t * (6 * t - 15) + 10));
    },
    randInt: function(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function(t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function(t) {
      return t * (0.5 - Math.random());
    },
    degToRad: function(t) {
      return t * fi.DEG2RAD;
    },
    radToDeg: function(t) {
      return t * fi.RAD2DEG;
    },
    isPowerOfTwo: function(t) {
      return (t & t - 1) === 0 && t !== 0;
    },
    ceilPowerOfTwo: function(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    },
    floorPowerOfTwo: function(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }
  };
  Object.defineProperties(o.prototype, {
    width: {
      get: function() {
        return this.x;
      },
      set: function(t) {
        this.x = t;
      }
    },
    height: {
      get: function() {
        return this.y;
      },
      set: function(t) {
        this.y = t;
      }
    }
  }), Object.assign(o.prototype, {
    isVector2: !0,
    set: function(t, e) {
      return this.x = t, this.y = e, this;
    },
    setScalar: function(t) {
      return this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    },
    multiply: function(t) {
      return this.x *= t.x, this.y *= t.y, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this;
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    applyMatrix3: function(t) {
      var e = this.x, i = this.y;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this;
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    },
    clampScalar: function() {
      var t = new o(), e = new o();
      return function(i, n) {
        return t.set(i, i), e.set(n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y;
    },
    cross: function(t) {
      return this.x * t.y - this.y * t.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var t = Math.atan2(this.y, this.x);
      return 0 > t && (t += 2 * Math.PI), t;
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x;
      return t = this.y - t.y, e * e + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this;
    },
    rotateAround: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = this.x - t.x, s = this.y - t.y;
      return this.x = n * i - s * e + t.x, this.y = n * e + s * i + t.y, this;
    }
  }), Object.assign(p.prototype, {
    isMatrix4: !0,
    set: function(t, e, i, n, s, a, c, f, v, y, A, P, k, H, q, K) {
      var rt = this.elements;
      return rt[0] = t, rt[4] = e, rt[8] = i, rt[12] = n, rt[1] = s, rt[5] = a, rt[9] = c, rt[13] = f, rt[2] = v, rt[6] = y, rt[10] = A, rt[14] = P, rt[3] = k, rt[7] = H, rt[11] = q, rt[15] = K, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new p().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this;
    },
    copyPosition: function(t) {
      var e = this.elements;
      return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this;
    },
    extractBasis: function(t, e, i) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
    },
    makeBasis: function(t, e, i) {
      return this.set(
        t.x,
        e.x,
        i.x,
        0,
        t.y,
        e.y,
        i.y,
        0,
        t.z,
        e.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    extractRotation: function() {
      var t = new u();
      return function(e) {
        var i = this.elements, n = e.elements, s = 1 / t.setFromMatrixColumn(e, 0).length(), a = 1 / t.setFromMatrixColumn(e, 1).length();
        return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
      };
    }(),
    makeRotationFromEuler: function(t) {
      t && t.isEuler || console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
      var e = this.elements, i = t.x, n = t.y, s = t.z, a = Math.cos(i);
      i = Math.sin(i);
      var c = Math.cos(n);
      n = Math.sin(n);
      var f = Math.cos(s);
      if (s = Math.sin(s), t.order === "XYZ") {
        t = a * f;
        var v = a * s, y = i * f, A = i * s;
        e[0] = c * f, e[4] = -c * s, e[8] = n, e[1] = v + y * n, e[5] = t - A * n, e[9] = -i * c, e[2] = A - t * n, e[6] = y + v * n, e[10] = a * c;
      } else
        t.order === "YXZ" ? (t = c * f, v = c * s, y = n * f, A = n * s, e[0] = t + A * i, e[4] = y * i - v, e[8] = a * n, e[1] = a * s, e[5] = a * f, e[9] = -i, e[2] = v * i - y, e[6] = A + t * i, e[10] = a * c) : t.order === "ZXY" ? (t = c * f, v = c * s, y = n * f, A = n * s, e[0] = t - A * i, e[4] = -a * s, e[8] = y + v * i, e[1] = v + y * i, e[5] = a * f, e[9] = A - t * i, e[2] = -a * n, e[6] = i, e[10] = a * c) : t.order === "ZYX" ? (t = a * f, v = a * s, y = i * f, A = i * s, e[0] = c * f, e[4] = y * n - v, e[8] = t * n + A, e[1] = c * s, e[5] = A * n + t, e[9] = v * n - y, e[2] = -n, e[6] = i * c, e[10] = a * c) : t.order === "YZX" ? (t = a * c, v = a * n, y = i * c, A = i * n, e[0] = c * f, e[4] = A - t * s, e[8] = y * s + v, e[1] = s, e[5] = a * f, e[9] = -i * f, e[2] = -n * f, e[6] = v * s + y, e[10] = t - A * s) : t.order === "XZY" && (t = a * c, v = a * n, y = i * c, A = i * n, e[0] = c * f, e[4] = -s, e[8] = n * f, e[1] = t * s + A, e[5] = a * f, e[9] = v * s - y, e[2] = y * s - v, e[6] = i * f, e[10] = A * s + t);
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    },
    makeRotationFromQuaternion: function() {
      var t = new u(0, 0, 0), e = new u(1, 1, 1);
      return function(i) {
        return this.compose(t, i, e);
      };
    }(),
    lookAt: function() {
      var t = new u(), e = new u(), i = new u();
      return function(n, s, a) {
        var c = this.elements;
        return i.subVectors(n, s), i.lengthSq() === 0 && (i.z = 1), i.normalize(), t.crossVectors(a, i), t.lengthSq() === 0 && (Math.abs(a.z) === 1 ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(a, i)), t.normalize(), e.crossVectors(i, t), c[0] = t.x, c[4] = e.x, c[8] = i.x, c[1] = t.y, c[5] = e.y, c[9] = i.y, c[2] = t.z, c[6] = e.z, c[10] = i.z, this;
      };
    }(),
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
      ), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var s = i[4], a = i[8], c = i[12], f = i[1], v = i[5], y = i[9], A = i[13], P = i[2], k = i[6], H = i[10], q = i[14], K = i[3], rt = i[7], xt = i[11];
      i = i[15];
      var gt = n[0], At = n[4], wt = n[8], Vt = n[12], Z = n[1], st = n[5], zt = n[9], ee = n[13], $t = n[2], qt = n[6], Te = n[10], me = n[14], Ie = n[3], be = n[7], ae = n[11];
      return n = n[15], e[0] = t * gt + s * Z + a * $t + c * Ie, e[4] = t * At + s * st + a * qt + c * be, e[8] = t * wt + s * zt + a * Te + c * ae, e[12] = t * Vt + s * ee + a * me + c * n, e[1] = f * gt + v * Z + y * $t + A * Ie, e[5] = f * At + v * st + y * qt + A * be, e[9] = f * wt + v * zt + y * Te + A * ae, e[13] = f * Vt + v * ee + y * me + A * n, e[2] = P * gt + k * Z + H * $t + q * Ie, e[6] = P * At + k * st + H * qt + q * be, e[10] = P * wt + k * zt + H * Te + q * ae, e[14] = P * Vt + k * ee + H * me + q * n, e[3] = K * gt + rt * Z + xt * $t + i * Ie, e[7] = K * At + rt * st + xt * qt + i * be, e[11] = K * wt + rt * zt + xt * Te + i * ae, e[15] = K * Vt + rt * ee + xt * me + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    },
    applyToBufferAttribute: function() {
      var t = new u();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    determinant: function() {
      var t = this.elements, e = t[0], i = t[4], n = t[8], s = t[12], a = t[1], c = t[5], f = t[9], v = t[13], y = t[2], A = t[6], P = t[10], k = t[14];
      return t[3] * (+s * f * A - n * v * A - s * c * P + i * v * P + n * c * k - i * f * k) + t[7] * (+e * f * k - e * v * P + s * a * P - n * a * k + n * v * y - s * f * y) + t[11] * (+e * v * A - e * c * k - s * a * A + i * a * k + s * c * y - i * v * y) + t[15] * (-n * c * y - e * f * A + e * c * P + n * a * A - i * a * P + i * f * y);
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    },
    setPosition: function(t) {
      var e = this.elements;
      return e[12] = t.x, e[13] = t.y, e[14] = t.z, this;
    },
    getInverse: function(t, e) {
      var i = this.elements, n = t.elements;
      t = n[0];
      var s = n[1], a = n[2], c = n[3], f = n[4], v = n[5], y = n[6], A = n[7], P = n[8], k = n[9], H = n[10], q = n[11], K = n[12], rt = n[13], xt = n[14];
      n = n[15];
      var gt = k * xt * A - rt * H * A + rt * y * q - v * xt * q - k * y * n + v * H * n, At = K * H * A - P * xt * A - K * y * q + f * xt * q + P * y * n - f * H * n, wt = P * rt * A - K * k * A + K * v * q - f * rt * q - P * v * n + f * k * n, Vt = K * k * y - P * rt * y - K * v * H + f * rt * H + P * v * xt - f * k * xt, Z = t * gt + s * At + a * wt + c * Vt;
      if (Z === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / Z, i[0] = gt * e, i[1] = (rt * H * c - k * xt * c - rt * a * q + s * xt * q + k * a * n - s * H * n) * e, i[2] = (v * xt * c - rt * y * c + rt * a * A - s * xt * A - v * a * n + s * y * n) * e, i[3] = (k * y * c - v * H * c - k * a * A + s * H * A + v * a * q - s * y * q) * e, i[4] = At * e, i[5] = (P * xt * c - K * H * c + K * a * q - t * xt * q - P * a * n + t * H * n) * e, i[6] = (K * y * c - f * xt * c - K * a * A + t * xt * A + f * a * n - t * y * n) * e, i[7] = (f * H * c - P * y * c + P * a * A - t * H * A - f * a * q + t * y * q) * e, i[8] = wt * e, i[9] = (K * k * c - P * rt * c - K * s * q + t * rt * q + P * s * n - t * k * n) * e, i[10] = (f * rt * c - K * v * c + K * s * A - t * rt * A - f * s * n + t * v * n) * e, i[11] = (P * v * c - f * k * c - P * s * A + t * k * A + f * s * q - t * v * q) * e, i[12] = Vt * e, i[13] = (P * rt * a - K * k * a + K * s * H - t * rt * H - P * s * xt + t * k * xt) * e, i[14] = (K * v * a - f * rt * a - K * s * y + t * rt * y + f * s * xt - t * v * xt) * e, i[15] = (f * k * a - P * v * a + P * s * y - t * k * y - f * s * H + t * v * H) * e, this;
    },
    scale: function(t) {
      var e = this.elements, i = t.x, n = t.y;
      return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this;
    },
    getMaxScaleOnAxis: function() {
      var t = this.elements;
      return Math.sqrt(
        Math.max(
          t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
        )
      );
    },
    makeTranslation: function(t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
    },
    makeRotationX: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = 1 - i, s = t.x, a = t.y;
      t = t.z;
      var c = n * s, f = n * a;
      return this.set(
        c * s + i,
        c * a - e * t,
        c * t + e * a,
        0,
        c * a + e * t,
        f * a + i,
        f * t - e * s,
        0,
        c * t - e * a,
        f * t + e * s,
        n * t * t + i,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    makeScale: function(t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    },
    makeShear: function(t, e, i) {
      return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    },
    compose: function(t, e, i) {
      var n = this.elements, s = e._x, a = e._y, c = e._z, f = e._w, v = s + s, y = a + a, A = c + c;
      e = s * v;
      var P = s * y;
      s *= A;
      var k = a * y;
      a *= A, c *= A, v *= f, y *= f, f *= A, A = i.x;
      var H = i.y;
      return i = i.z, n[0] = (1 - (k + c)) * A, n[1] = (P + f) * A, n[2] = (s - y) * A, n[3] = 0, n[4] = (P - f) * H, n[5] = (1 - (e + c)) * H, n[6] = (a + v) * H, n[7] = 0, n[8] = (s + y) * i, n[9] = (a - v) * i, n[10] = (1 - (e + k)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
    },
    decompose: function() {
      var t = new u(), e = new p();
      return function(i, n, s) {
        var a = this.elements, c = t.set(a[0], a[1], a[2]).length(), f = t.set(a[4], a[5], a[6]).length(), v = t.set(a[8], a[9], a[10]).length();
        0 > this.determinant() && (c = -c), i.x = a[12], i.y = a[13], i.z = a[14], e.copy(this), i = 1 / c, a = 1 / f;
        var y = 1 / v;
        return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= a, e.elements[5] *= a, e.elements[6] *= a, e.elements[8] *= y, e.elements[9] *= y, e.elements[10] *= y, n.setFromRotationMatrix(e), s.x = c, s.y = f, s.z = v, this;
      };
    }(),
    makePerspective: function(t, e, i, n, s, a) {
      a === void 0 && console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
      var c = this.elements;
      return c[0] = 2 * s / (e - t), c[4] = 0, c[8] = (e + t) / (e - t), c[12] = 0, c[1] = 0, c[5] = 2 * s / (i - n), c[9] = (i + n) / (i - n), c[13] = 0, c[2] = 0, c[6] = 0, c[10] = -(a + s) / (a - s), c[14] = -2 * a * s / (a - s), c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
    },
    makeOrthographic: function(t, e, i, n, s, a) {
      var c = this.elements, f = 1 / (e - t), v = 1 / (i - n), y = 1 / (a - s);
      return c[0] = 2 * f, c[4] = 0, c[8] = 0, c[12] = -((e + t) * f), c[1] = 0, c[5] = 2 * v, c[9] = 0, c[13] = -((i + n) * v), c[2] = 0, c[6] = 0, c[10] = -2 * y, c[14] = -((a + s) * y), c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 16 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 16 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
    }
  }), Object.assign(d, {
    slerp: function(t, e, i, n) {
      return i.copy(t).slerp(e, n);
    },
    slerpFlat: function(t, e, i, n, s, a, c) {
      var f = i[n + 0], v = i[n + 1], y = i[n + 2];
      i = i[n + 3], n = s[a + 0];
      var A = s[a + 1], P = s[a + 2];
      if (s = s[a + 3], i !== s || f !== n || v !== A || y !== P) {
        a = 1 - c;
        var k = f * n + v * A + y * P + i * s, H = 0 <= k ? 1 : -1, q = 1 - k * k;
        q > Number.EPSILON && (q = Math.sqrt(q), k = Math.atan2(q, k * H), a = Math.sin(a * k) / q, c = Math.sin(c * k) / q), H *= c, f = f * a + n * H, v = v * a + A * H, y = y * a + P * H, i = i * a + s * H, a === 1 - c && (c = 1 / Math.sqrt(f * f + v * v + y * y + i * i), f *= c, v *= c, y *= c, i *= c);
      }
      t[e] = f, t[e + 1] = v, t[e + 2] = y, t[e + 3] = i;
    }
  }), Object.defineProperties(d.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(t) {
        this._w = t, this.onChangeCallback();
      }
    }
  }), Object.assign(d.prototype, {
    isQuaternion: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this;
    },
    setFromEuler: function(t, e) {
      if (!t || !t.isEuler)
        throw Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      var i = t._x, n = t._y, s = t._z;
      t = t.order;
      var a = Math.cos, c = Math.sin, f = a(i / 2), v = a(n / 2);
      return a = a(s / 2), i = c(i / 2), n = c(n / 2), s = c(s / 2), t === "XYZ" ? (this._x = i * v * a + f * n * s, this._y = f * n * a - i * v * s, this._z = f * v * s + i * n * a, this._w = f * v * a - i * n * s) : t === "YXZ" ? (this._x = i * v * a + f * n * s, this._y = f * n * a - i * v * s, this._z = f * v * s - i * n * a, this._w = f * v * a + i * n * s) : t === "ZXY" ? (this._x = i * v * a - f * n * s, this._y = f * n * a + i * v * s, this._z = f * v * s + i * n * a, this._w = f * v * a - i * n * s) : t === "ZYX" ? (this._x = i * v * a - f * n * s, this._y = f * n * a + i * v * s, this._z = f * v * s - i * n * a, this._w = f * v * a + i * n * s) : t === "YZX" ? (this._x = i * v * a + f * n * s, this._y = f * n * a + i * v * s, this._z = f * v * s - i * n * a, this._w = f * v * a - i * n * s) : t === "XZY" && (this._x = i * v * a - f * n * s, this._y = f * n * a - i * v * s, this._z = f * v * s + i * n * a, this._w = f * v * a + i * n * s), e !== !1 && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(t, e) {
      e /= 2;
      var i = Math.sin(e);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t) {
      var e = t.elements, i = e[0];
      t = e[4];
      var n = e[8], s = e[1], a = e[5], c = e[9], f = e[2], v = e[6];
      e = e[10];
      var y = i + a + e;
      return 0 < y ? (i = 0.5 / Math.sqrt(y + 1), this._w = 0.25 / i, this._x = (v - c) * i, this._y = (n - f) * i, this._z = (s - t) * i) : i > a && i > e ? (i = 2 * Math.sqrt(1 + i - a - e), this._w = (v - c) / i, this._x = 0.25 * i, this._y = (t + s) / i, this._z = (n + f) / i) : a > e ? (i = 2 * Math.sqrt(1 + a - i - e), this._w = (n - f) / i, this._x = (t + s) / i, this._y = 0.25 * i, this._z = (c + v) / i) : (i = 2 * Math.sqrt(1 + e - i - a), this._w = (s - t) / i, this._x = (n + f) / i, this._y = (c + v) / i, this._z = 0.25 * i), this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
      var t = new u(), e;
      return function(i, n) {
        return t === void 0 && (t = new u()), e = i.dot(n) + 1, 1e-6 > e ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize();
      };
    }(),
    angleTo: function(t) {
      return 2 * Math.acos(Math.abs(fi.clamp(this.dot(t), -1, 1)));
    },
    rotateTowards: function(t, e) {
      var i = this.angleTo(t);
      return i === 0 ? this : (this.slerp(t, Math.min(1, e / i)), this);
    },
    inverse: function() {
      return this.conjugate();
    },
    conjugate: function() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    },
    lengthSq: function() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
      return Math.sqrt(
        this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      );
    },
    normalize: function() {
      var t = this.length();
      return t === 0 ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
      ), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    },
    premultiply: function(t) {
      return this.multiplyQuaternions(t, this);
    },
    multiplyQuaternions: function(t, e) {
      var i = t._x, n = t._y, s = t._z;
      t = t._w;
      var a = e._x, c = e._y, f = e._z;
      return e = e._w, this._x = i * e + t * a + n * f - s * c, this._y = n * e + t * c + s * a - i * f, this._z = s * e + t * f + i * c - n * a, this._w = t * e - i * a - n * c - s * f, this.onChangeCallback(), this;
    },
    slerp: function(t, e) {
      if (e === 0)
        return this;
      if (e === 1)
        return this.copy(t);
      var i = this._x, n = this._y, s = this._z, a = this._w, c = a * t._w + i * t._x + n * t._y + s * t._z;
      if (0 > c ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, c = -c) : this.copy(t), 1 <= c)
        return this._w = a, this._x = i, this._y = n, this._z = s, this;
      if (t = 1 - c * c, t <= Number.EPSILON)
        return c = 1 - e, this._w = c * a + e * this._w, this._x = c * i + e * this._x, this._y = c * n + e * this._y, this._z = c * s + e * this._z, this.normalize();
      t = Math.sqrt(t);
      var f = Math.atan2(t, c);
      return c = Math.sin((1 - e) * f) / t, e = Math.sin(e * f) / t, this._w = a * c + this._w * e, this._x = i * c + this._x * e, this._y = n * c + this._y * e, this._z = s * c + this._z * e, this.onChangeCallback(), this;
    },
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(u.prototype, {
    isVector3: !0,
    set: function(t, e, i) {
      return this.x = t, this.y = e, this.z = i, this;
    },
    setScalar: function(t) {
      return this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
      ), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    },
    multiplyVectors: function(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    },
    applyEuler: function() {
      var t = new d();
      return function(e) {
        return e && e.isEuler || console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ), this.applyQuaternion(t.setFromEuler(e));
      };
    }(),
    applyAxisAngle: function() {
      var t = new d();
      return function(e, i) {
        return this.applyQuaternion(t.setFromAxisAngle(e, i));
      };
    }(),
    applyMatrix3: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z;
      t = t.elements;
      var s = 1 / (t[3] * e + t[7] * i + t[11] * n + t[15]);
      return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * s, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * s, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * s, this;
    },
    applyQuaternion: function(t) {
      var e = this.x, i = this.y, n = this.z, s = t.x, a = t.y, c = t.z;
      t = t.w;
      var f = t * e + a * n - c * i, v = t * i + c * e - s * n, y = t * n + s * i - a * e;
      return e = -s * e - a * i - c * n, this.x = f * t + e * -s + v * -c - y * -a, this.y = v * t + e * -a + y * -s - f * -c, this.z = y * t + e * -c + f * -a - v * -s, this;
    },
    project: function(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    },
    unproject: function() {
      var t = new p();
      return function(e) {
        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(
          e.matrixWorld
        );
      };
    }(),
    transformDirection: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize();
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    },
    clampScalar: function() {
      var t = new u(), e = new u();
      return function(i, n) {
        return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    cross: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
      ), this.crossVectors(t, e)) : this.crossVectors(this, t);
    },
    crossVectors: function(t, e) {
      var i = t.x, n = t.y;
      t = t.z;
      var s = e.x, a = e.y;
      return e = e.z, this.x = n * e - t * a, this.y = t * s - i * e, this.z = i * a - n * s, this;
    },
    projectOnVector: function(t) {
      var e = t.dot(this) / t.lengthSq();
      return this.copy(t).multiplyScalar(e);
    },
    projectOnPlane: function() {
      var t = new u();
      return function(e) {
        return t.copy(this).projectOnVector(e), this.sub(t);
      };
    }(),
    reflect: function() {
      var t = new u();
      return function(e) {
        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
      };
    }(),
    angleTo: function(t) {
      return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(fi.clamp(t, -1, 1));
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x, i = this.y - t.y;
      return t = this.z - t.z, e * e + i * i + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    },
    setFromSpherical: function(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    },
    setFromSphericalCoords: function(t, e, i) {
      var n = Math.sin(e) * t;
      return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
    },
    setFromCylindrical: function(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    },
    setFromCylindricalCoords: function(t, e, i) {
      return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
    },
    setFromMatrixPosition: function(t) {
      return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this;
    },
    setFromMatrixScale: function(t) {
      var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length();
      return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this;
    },
    setFromMatrixColumn: function(t, e) {
      return this.fromArray(t.elements, 4 * e);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
  }), Object.assign(m.prototype, {
    isMatrix3: !0,
    set: function(t, e, i, n, s, a, c, f, v) {
      var y = this.elements;
      return y[0] = t, y[1] = n, y[2] = c, y[3] = e, y[4] = s, y[5] = f, y[6] = i, y[7] = a, y[8] = v, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this;
    },
    setFromMatrix4: function(t) {
      return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    },
    applyToBufferAttribute: function() {
      var t = new u();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    multiply: function(t) {
      return this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var s = i[3], a = i[6], c = i[1], f = i[4], v = i[7], y = i[2], A = i[5];
      i = i[8];
      var P = n[0], k = n[3], H = n[6], q = n[1], K = n[4], rt = n[7], xt = n[2], gt = n[5];
      return n = n[8], e[0] = t * P + s * q + a * xt, e[3] = t * k + s * K + a * gt, e[6] = t * H + s * rt + a * n, e[1] = c * P + f * q + v * xt, e[4] = c * k + f * K + v * gt, e[7] = c * H + f * rt + v * n, e[2] = y * P + A * q + i * xt, e[5] = y * k + A * K + i * gt, e[8] = y * H + A * rt + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    },
    determinant: function() {
      var t = this.elements, e = t[0], i = t[1], n = t[2], s = t[3], a = t[4], c = t[5], f = t[6], v = t[7];
      return t = t[8], e * a * t - e * c * v - i * s * t + i * c * f + n * s * v - n * a * f;
    },
    getInverse: function(t, e) {
      t && t.isMatrix4 && console.error(
        "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
      );
      var i = t.elements;
      t = this.elements;
      var n = i[0], s = i[1], a = i[2], c = i[3], f = i[4], v = i[5], y = i[6], A = i[7];
      i = i[8];
      var P = i * f - v * A, k = v * y - i * c, H = A * c - f * y, q = n * P + s * k + a * H;
      if (q === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / q, t[0] = P * e, t[1] = (a * A - i * s) * e, t[2] = (v * s - a * f) * e, t[3] = k * e, t[4] = (i * n - a * y) * e, t[5] = (a * c - v * n) * e, t[6] = H * e, t[7] = (s * y - A * n) * e, t[8] = (f * n - s * c) * e, this;
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    },
    getNormalMatrix: function(t) {
      return this.setFromMatrix4(t).getInverse(this).transpose();
    },
    transposeIntoArray: function(t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    },
    setUvTransform: function(t, e, i, n, s, a, c) {
      var f = Math.cos(s);
      s = Math.sin(s), this.set(
        i * f,
        i * s,
        -i * (f * a + s * c) + a + t,
        -n * s,
        n * f,
        -n * (-s * a + f * c) + c + e,
        0,
        0,
        1
      );
    },
    scale: function(t, e) {
      var i = this.elements;
      return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this;
    },
    rotate: function(t) {
      var e = Math.cos(t);
      t = Math.sin(t);
      var i = this.elements, n = i[0], s = i[3], a = i[6], c = i[1], f = i[4], v = i[7];
      return i[0] = e * n + t * c, i[3] = e * s + t * f, i[6] = e * a + t * v, i[1] = -t * n + e * c, i[4] = -t * s + e * f, i[7] = -t * a + e * v, this;
    },
    translate: function(t, e) {
      var i = this.elements;
      return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 9 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 9 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
    }
  });
  var Qs = {
    getDataURL: function(t) {
      if (typeof HTMLCanvasElement > "u")
        return t.src;
      if (t instanceof HTMLCanvasElement)
        var e = t;
      else {
        e = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        ), e.width = t.width, e.height = t.height;
        var i = e.getContext("2d");
        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height);
      }
      return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
    }
  }, Io = 0;
  _.DEFAULT_IMAGE = void 0, _.DEFAULT_MAPPING = 300, _.prototype = Object.assign(Object.create(l.prototype), {
    constructor: _,
    isTexture: !0,
    updateMatrix: function() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
    },
    toJSON: function(t) {
      var e = t === void 0 || typeof t == "string";
      if (!e && t.textures[this.uuid] !== void 0)
        return t.textures[this.uuid];
      var i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY
      };
      if (this.image !== void 0) {
        var n = this.image;
        if (n.uuid === void 0 && (n.uuid = fi.generateUUID()), !e && t.images[n.uuid] === void 0) {
          if (Array.isArray(n))
            for (var s = [], a = 0, c = n.length; a < c; a++)
              s.push(Qs.getDataURL(n[a]));
          else
            s = Qs.getDataURL(n);
          t.images[n.uuid] = { uuid: n.uuid, url: s };
        }
        i.image = n.uuid;
      }
      return e || (t.textures[this.uuid] = i), i;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function(t) {
      if (this.mapping !== 300)
        return t;
      if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x)
        switch (this.wrapS) {
          case 1e3:
            t.x -= Math.floor(t.x);
            break;
          case 1001:
            t.x = 0 > t.x ? 0 : 1;
            break;
          case 1002:
            t.x = Math.abs(Math.floor(t.x) % 2) === 1 ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x);
        }
      if (0 > t.y || 1 < t.y)
        switch (this.wrapT) {
          case 1e3:
            t.y -= Math.floor(t.y);
            break;
          case 1001:
            t.y = 0 > t.y ? 0 : 1;
            break;
          case 1002:
            t.y = Math.abs(Math.floor(t.y) % 2) === 1 ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y);
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
  }), Object.defineProperty(_.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(T.prototype, {
    isVector4: !0,
    set: function(t, e, i, n) {
      return this.x = t, this.y = e, this.z = i, this.w = n, this;
    },
    setScalar: function(t) {
      return this.w = this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setW: function(t) {
      return this.w = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z, s = this.w;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * s, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * s, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * s, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * s, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    setAxisAngleFromQuaternion: function(t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    },
    setAxisAngleFromRotationMatrix: function(t) {
      t = t.elements;
      var e = t[0], i = t[4], n = t[8], s = t[1], a = t[5], c = t[9], f = t[2], v = t[6], y = t[10];
      return 0.01 > Math.abs(i - s) && 0.01 > Math.abs(n - f) && 0.01 > Math.abs(c - v) ? 0.1 > Math.abs(i + s) && 0.1 > Math.abs(n + f) && 0.1 > Math.abs(c + v) && 0.1 > Math.abs(e + a + y - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, e = (e + 1) / 2, a = (a + 1) / 2, y = (y + 1) / 2, i = (i + s) / 4, n = (n + f) / 4, c = (c + v) / 4, e > a && e > y ? 0.01 > e ? (v = 0, i = f = 0.707106781) : (v = Math.sqrt(e), f = i / v, i = n / v) : a > y ? 0.01 > a ? (v = 0.707106781, f = 0, i = 0.707106781) : (f = Math.sqrt(a), v = i / f, i = c / f) : 0.01 > y ? (f = v = 0.707106781, i = 0) : (i = Math.sqrt(y), v = n / i, f = c / i), this.set(v, f, i, t), this) : (t = Math.sqrt((v - c) * (v - c) + (n - f) * (n - f) + (s - i) * (s - i)), 1e-3 > Math.abs(t) && (t = 1), this.x = (v - c) / t, this.y = (n - f) / t, this.z = (s - i) / t, this.w = Math.acos((e + a + y - 1) / 2), this);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    },
    clampScalar: function() {
      var t, e;
      return function(i, n) {
        return t === void 0 && (t = new T(), e = new T()), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
  }), S.prototype = Object.assign(Object.create(l.prototype), {
    constructor: S,
    isWebGLRenderTarget: !0,
    setSize: function(t, e) {
      (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), C.prototype = Object.create(S.prototype), C.prototype.constructor = C, C.prototype.isWebGLRenderTargetCube = !0, z.prototype = Object.create(_.prototype), z.prototype.constructor = z, z.prototype.isDataTexture = !0, Object.assign(B.prototype, {
    isBox3: !0,
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromArray: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, s = -1 / 0, a = -1 / 0, c = -1 / 0, f = 0, v = t.length; f < v; f += 3) {
        var y = t[f], A = t[f + 1], P = t[f + 2];
        y < e && (e = y), A < i && (i = A), P < n && (n = P), y > s && (s = y), A > a && (a = A), P > c && (c = P);
      }
      return this.min.set(e, i, n), this.max.set(s, a, c), this;
    },
    setFromBufferAttribute: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, s = -1 / 0, a = -1 / 0, c = -1 / 0, f = 0, v = t.count; f < v; f++) {
        var y = t.getX(f), A = t.getY(f), P = t.getZ(f);
        y < e && (e = y), A < i && (i = A), P < n && (n = P), y > s && (s = y), A > a && (a = A), P > c && (c = P);
      }
      return this.min.set(e, i, n), this.max.set(s, a, c), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new u();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    setFromObject: function(t) {
      return this.makeEmpty(), this.expandByObject(t);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new u()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), t = new u()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    expandByObject: function() {
      function t(a) {
        var c = a.geometry;
        if (c !== void 0) {
          if (c.isGeometry)
            for (c = c.vertices, i = 0, n = c.length; i < n; i++)
              s.copy(c[i]), s.applyMatrix4(a.matrixWorld), e.expandByPoint(s);
          else if (c.isBufferGeometry && (c = c.attributes.position, c !== void 0))
            for (i = 0, n = c.count; i < n; i++)
              s.fromBufferAttribute(c, i).applyMatrix4(a.matrixWorld), e.expandByPoint(s);
        }
      }
      var e, i, n, s = new u();
      return function(a) {
        return e = this, a.updateMatrixWorld(!0), a.traverse(t), this;
      };
    }(),
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new u()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    },
    intersectsSphere: function() {
      var t = new u();
      return function(e) {
        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius;
      };
    }(),
    intersectsPlane: function(t) {
      if (0 < t.normal.x)
        var e = t.normal.x * this.min.x, i = t.normal.x * this.max.x;
      else
        e = t.normal.x * this.max.x, i = t.normal.x * this.min.x;
      return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
    },
    intersectsTriangle: function() {
      function t(P) {
        var k, H = 0;
        for (k = P.length - 3; H <= k; H += 3) {
          f.fromArray(P, H);
          var q = y.x * Math.abs(f.x) + y.y * Math.abs(f.y) + y.z * Math.abs(f.z), K = e.dot(f), rt = i.dot(f), xt = n.dot(f);
          if (Math.max(-Math.max(K, rt, xt), Math.min(K, rt, xt)) > q)
            return !1;
        }
        return !0;
      }
      var e = new u(), i = new u(), n = new u(), s = new u(), a = new u(), c = new u(), f = new u(), v = new u(), y = new u(), A = new u();
      return function(P) {
        return this.isEmpty() || (this.getCenter(v), y.subVectors(this.max, v), e.subVectors(P.a, v), i.subVectors(P.b, v), n.subVectors(P.c, v), s.subVectors(i, e), a.subVectors(n, i), c.subVectors(e, n), P = [
          0,
          -s.z,
          s.y,
          0,
          -a.z,
          a.y,
          0,
          -c.z,
          c.y,
          s.z,
          0,
          -s.x,
          a.z,
          0,
          -a.x,
          c.z,
          0,
          -c.x,
          -s.y,
          s.x,
          0,
          -a.y,
          a.x,
          0,
          -c.y,
          c.x,
          0
        ], !t(P)) || (P = [1, 0, 0, 0, 1, 0, 0, 0, 1], !t(P)) ? !1 : (A.crossVectors(s, a), P = [A.x, A.y, A.z], t(P));
      };
    }(),
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new u()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new u();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    getBoundingSphere: function() {
      var t = new u();
      return function(e) {
        return e === void 0 && (console.warn(
          "THREE.Box3: .getBoundingSphere() target is now required"
        ), e = new I()), this.getCenter(e.center), e.radius = 0.5 * this.getSize(t).length(), e;
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    applyMatrix4: function() {
      var t = [
        new u(),
        new u(),
        new u(),
        new u(),
        new u(),
        new u(),
        new u(),
        new u()
      ];
      return function(e) {
        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this);
      };
    }(),
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(I.prototype, {
    set: function(t, e) {
      return this.center.copy(t), this.radius = e, this;
    },
    setFromPoints: function() {
      var t = new B();
      return function(e, i) {
        var n = this.center;
        i !== void 0 ? n.copy(i) : t.setFromPoints(e).getCenter(n);
        for (var s = i = 0, a = e.length; s < a; s++)
          i = Math.max(i, n.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    },
    empty: function() {
      return 0 >= this.radius;
    },
    containsPoint: function(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(t) {
      return t.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    },
    intersectsBox: function(t) {
      return t.intersectsSphere(this);
    },
    intersectsPlane: function(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(t, e) {
      var i = this.center.distanceToSquared(t);
      return e === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new u()), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    },
    getBoundingBox: function(t) {
      return t === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new B()), t.set(this.center, this.center), t.expandByScalar(this.radius), t;
    },
    applyMatrix4: function(t) {
      return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this;
    },
    translate: function(t) {
      return this.center.add(t), this;
    },
    equals: function(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
  }), Object.assign(F.prototype, {
    set: function(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    },
    setComponents: function(t, e, i, n) {
      return this.normal.set(t, e, i), this.constant = n, this;
    },
    setFromNormalAndCoplanarPoint: function(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
      var t = new u(), e = new u();
      return function(i, n, s) {
        return n = t.subVectors(s, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    },
    normalize: function() {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    },
    negate: function() {
      return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(t) {
      return this.normal.dot(t) + this.constant;
    },
    distanceToSphere: function(t) {
      return this.distanceToPoint(t.center) - t.radius;
    },
    projectPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new u()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    },
    intersectLine: function() {
      var t = new u();
      return function(e, i) {
        i === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new u());
        var n = e.delta(t), s = this.normal.dot(n);
        if (s === 0) {
          if (this.distanceToPoint(e.start) === 0)
            return i.copy(e.start);
        } else if (s = -(e.start.dot(this.normal) + this.constant) / s, !(0 > s || 1 < s))
          return i.copy(n).multiplyScalar(s).add(e.start);
      };
    }(),
    intersectsLine: function(t) {
      var e = this.distanceToPoint(t.start);
      return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e;
    },
    intersectsBox: function(t) {
      return t.intersectsPlane(this);
    },
    intersectsSphere: function(t) {
      return t.intersectsPlane(this);
    },
    coplanarPoint: function(t) {
      return t === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new u()), t.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
      var t = new u(), e = new m();
      return function(i, n) {
        return n = n || e.getNormalMatrix(i), i = this.coplanarPoint(t).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this;
      };
    }(),
    translate: function(t) {
      return this.constant -= t.dot(this.normal), this;
    },
    equals: function(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
  }), Object.assign(E.prototype, {
    set: function(t, e, i, n, s, a) {
      var c = this.planes;
      return c[0].copy(t), c[1].copy(e), c[2].copy(i), c[3].copy(n), c[4].copy(s), c[5].copy(a), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        e[i].copy(t.planes[i]);
      return this;
    },
    setFromMatrix: function(t) {
      var e = this.planes, i = t.elements;
      t = i[0];
      var n = i[1], s = i[2], a = i[3], c = i[4], f = i[5], v = i[6], y = i[7], A = i[8], P = i[9], k = i[10], H = i[11], q = i[12], K = i[13], rt = i[14];
      return i = i[15], e[0].setComponents(a - t, y - c, H - A, i - q).normalize(), e[1].setComponents(a + t, y + c, H + A, i + q).normalize(), e[2].setComponents(a + n, y + f, H + P, i + K).normalize(), e[3].setComponents(a - n, y - f, H - P, i - K).normalize(), e[4].setComponents(a - s, y - v, H - k, i - rt).normalize(), e[5].setComponents(a + s, y + v, H + k, i + rt).normalize(), this;
    },
    intersectsObject: function() {
      var t = new I();
      return function(e) {
        var i = e.geometry;
        return i.boundingSphere === null && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSprite: function() {
      var t = new I();
      return function(e) {
        return t.center.set(0, 0, 0), t.radius = 0.7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSphere: function(t) {
      var e = this.planes, i = t.center;
      t = -t.radius;
      for (var n = 0; 6 > n; n++)
        if (e[n].distanceToPoint(i) < t)
          return !1;
      return !0;
    },
    intersectsBox: function() {
      var t = new u();
      return function(e) {
        for (var i = this.planes, n = 0; 6 > n; n++) {
          var s = i[n];
          if (t.x = 0 < s.normal.x ? e.max.x : e.min.x, t.y = 0 < s.normal.y ? e.max.y : e.min.y, t.z = 0 < s.normal.z ? e.max.z : e.min.z, 0 > s.distanceToPoint(t))
            return !1;
        }
        return !0;
      };
    }(),
    containsPoint: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        if (0 > e[i].distanceToPoint(t))
          return !1;
      return !0;
    }
  });
  var Ei = {
    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif
`,
    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
`,
    alphatest_fragment: `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif
`,
    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif
`,
    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    begin_vertex: `
vec3 transformed = vec3( position );
`,
    beginnormal_vertex: `
vec3 objectNormal = vec3( normal );
`,
    bsdfs: `float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`,
    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif
`,
    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
	}
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;
		}
		if ( clipped ) discard;
	#endif
#endif
`,
    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
		varying vec3 vViewPosition;
	#endif
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif
`,
    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	varying vec3 vViewPosition;
#endif
`,
    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	vViewPosition = - mvPosition.xyz;
#endif
`,
    color_fragment: `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,
    color_pars_fragment: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif
`,
    color_pars_vertex: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,
    color_vertex: `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`,
    common: `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
`,
    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_textureSize (1024.0)
int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}
#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;
	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	float powScale = exp2_packed.x * exp2_packed.y;
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;
	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);
	float rcpPowScale = 1.0 / powScale;
	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}
#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
vec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;
	level0 += min( floor( s + 0.5 ), 5.0 );
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
	vec4 result = mix(color10, color20, t);
	return vec4(result.rgb, 1.0);
}
#endif
`,
    defaultnormal_vertex: `vec3 transformedNormal = normalMatrix * objectNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
`,
    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif
`,
    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
#endif
`,
    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif
`,
    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif
`,
    encodings_fragment: `  gl_FragColor = linearToOutputTexel( gl_FragColor );
`,
    encodings_pars_fragment: `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`,
    envmap_fragment: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToVertex, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		vec2 sampleUV;
		reflectVec = normalize( reflectVec );
		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	envColor = envMapTexelToLinear( envColor );
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif
`,
    envmap_pars_fragment: `#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif
#ifdef USE_ENVMAP
	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif
`,
    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif
`,
    envmap_physical_pars_fragment: `#if defined( USE_ENVMAP ) && defined( PHYSICAL )
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
		#else
			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif
`,
    envmap_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif
`,
    fog_vertex: `#ifdef USE_FOG
	fogDepth = -mvPosition.z;
#endif
`,
    fog_pars_vertex: `#ifdef USE_FOG
	varying float fogDepth;
#endif
`,
    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`,
    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
`,
    gradientmap_pars_fragment: `#ifdef TOON
	uniform sampler2D gradientMap;
	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
		#ifdef USE_GRADIENTMAP
			return texture2D( gradientMap, coord ).rgb;
		#else
			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
		#endif
	}
#endif
`,
    lightmap_fragment: `#ifdef USE_LIGHTMAP
	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
#endif
`,
    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    lights_lambert_vertex: `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
#endif
`,
    lights_pars_begin: `uniform vec3 ambientLightColor;
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif
`,
    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,
    lights_phong_pars_fragment: `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	#ifdef TOON
		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#else
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;
	#endif
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
`,
    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`,
    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	#ifndef STANDARD
		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
	#ifndef STANDARD
		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}
`,
    lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
#endif
#if defined( RE_IndirectDiffuse )
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );
#endif
`,
    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif
#endif
`,
    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
#endif
`,
    logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
#endif
`,
    logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#else
		uniform float logDepthBufFC;
	#endif
#endif
`,
    logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
	#else
		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
		gl_Position.z *= gl_Position.w;
	#endif
#endif
`,
    map_fragment: `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif
`,
    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif
`,
    map_particle_fragment: `#ifdef USE_MAP
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
`,
    map_particle_pars_fragment: `#ifdef USE_MAP
	uniform mat3 uvTransform;
	uniform sampler2D map;
#endif
`,
    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif
`,
    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif
`,
    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
	#endif
#endif
`,
    normal_fragment_begin: `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
#endif
`,
    normal_fragment_maps: `#ifdef USE_NORMALMAP
	#ifdef OBJECTSPACE_NORMALMAP
		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
		#ifdef FLIP_SIDED
			normal = - normal;
		#endif
		#ifdef DOUBLE_SIDED
			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		normal = normalize( normalMatrix * normal );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif
`,
    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	#ifdef OBJECTSPACE_NORMALMAP
		uniform mat3 normalMatrix;
	#else
		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
			vec2 st0 = dFdx( vUv.st );
			vec2 st1 = dFdy( vUv.st );
			float scale = sign( st1.t * st0.s - st0.t * st1.s );
			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
			vec3 N = normalize( surf_norm );
			mat3 tsn = mat3( S, T, N );
			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
			mapN.xy *= normalScale;
			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			return normalize( tsn * mapN );
		}
	#endif
#endif
`,
    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,
    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
`,
    project_vertex: `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
gl_Position = projectionMatrix * mvPosition;
`,
    dithering_fragment: `#if defined( DITHERING )
  gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif
`,
    dithering_pars_fragment: `#if defined( DITHERING )
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif
`,
    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif
`,
    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    shadowmap_pars_fragment: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
		const vec2 offset = vec2( 0.0, 1.0 );
		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
		vec2 f = fract( uv * size + 0.5 );
		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );
		return c;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif
`,
    shadowmap_pars_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
#endif
`,
    shadowmap_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#endif
#endif
`,
    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#endif
	#endif
	return shadow;
}
`,
    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif
`,
    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif
`,
    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif
`,
    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    tonemapping_fragment: `#if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif
`,
    tonemapping_pars_fragment: `#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
`,
    uv_pars_fragment: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
#endif`,
    uv_pars_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
`,
    uv_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
#endif`,
    uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = uv2;
#endif`,
    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
#endif
`,
    background_frag: `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
}
`,
    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position, 1.0 );
	gl_Position.z = 1.0;
}
`,
    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor.a *= opacity;
}
`,
    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}
`,
    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
	#endif
}
`,
    depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
`,
    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}
`,
    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}
`,
    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV;
	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;
	gl_FragColor = texture2D( tEquirect, sampleUV );
}
`,
    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}
`,
    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	vLineDistance = scale * lineDistance;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`,
    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`,
    meshlambert_frag: `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshlambert_vert: `#define LAMBERT
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	vec4 matcapColor = texture2D( matcap, uv );
	matcapColor = matcapTexelToLinear( matcapColor );
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}
`,
    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshphysical_frag: `#define PHYSICAL
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphysical_vert: `#define PHYSICAL
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    normal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}
`,
    normal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	vViewPosition = - mvPosition.xyz;
#endif
}
`,
    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}
`,
    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <fog_fragment>
}
`,
    shadow_vert: `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`
  }, Dn = {
    merge: function(t) {
      for (var e = {}, i = 0; i < t.length; i++) {
        var n = this.clone(t[i]), s;
        for (s in n)
          e[s] = n[s];
      }
      return e;
    },
    clone: function(t) {
      var e = {}, i;
      for (i in t) {
        e[i] = {};
        for (var n in t[i]) {
          var s = t[i][n];
          s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture) ? e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
        }
      }
      return e;
    }
  }, qr = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Object.assign(L.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function(t) {
      return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this;
    },
    setScalar: function(t) {
      return this.b = this.g = this.r = t, this;
    },
    setHex: function(t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, this;
    },
    setRGB: function(t, e, i) {
      return this.r = t, this.g = e, this.b = i, this;
    },
    setHSL: function() {
      function t(e, i, n) {
        return 0 > n && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (i - e) * n : 0.5 > n ? i : n < 2 / 3 ? e + 6 * (i - e) * (2 / 3 - n) : e;
      }
      return function(e, i, n) {
        return e = fi.euclideanModulo(e, 1), i = fi.clamp(i, 0, 1), n = fi.clamp(n, 0, 1), i === 0 ? this.r = this.g = this.b = n : (i = 0.5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this;
      };
    }(),
    setStyle: function(t) {
      function e(c) {
        c !== void 0 && 1 > parseFloat(c) && console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
      }
      var i;
      if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
        var n = i[2];
        switch (i[1]) {
          case "rgb":
          case "rgba":
            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
            if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
            break;
          case "hsl":
          case "hsla":
            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            )) {
              n = parseFloat(i[1]) / 360;
              var s = parseInt(i[2], 10) / 100, a = parseInt(i[3], 10) / 100;
              return e(i[5]), this.setHSL(n, s, a);
            }
        }
      } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
        if (i = i[1], n = i.length, n === 3)
          return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
        if (n === 6)
          return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this;
      }
      return t && 0 < t.length && (i = qr[t], i !== void 0 ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    },
    copyGammaToLinear: function(t, e) {
      return e === void 0 && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    copyLinearToGamma: function(t, e) {
      return e === void 0 && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    convertGammaToLinear: function(t) {
      return this.copyGammaToLinear(this, t), this;
    },
    convertLinearToGamma: function(t) {
      return this.copyLinearToGamma(this, t), this;
    },
    copySRGBToLinear: function() {
      function t(e) {
        return 0.04045 > e ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    copyLinearToSRGB: function() {
      function t(e) {
        return 31308e-7 > e ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    convertSRGBToLinear: function() {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function() {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(t) {
      t === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });
      var e = this.r, i = this.g, n = this.b, s = Math.max(e, i, n), a = Math.min(e, i, n), c, f = (a + s) / 2;
      if (a === s)
        a = c = 0;
      else {
        var v = s - a;
        switch (a = 0.5 >= f ? v / (s + a) : v / (2 - s - a), s) {
          case e:
            c = (i - n) / v + (i < n ? 6 : 0);
            break;
          case i:
            c = (n - e) / v + 2;
            break;
          case n:
            c = (e - i) / v + 4;
        }
        c /= 6;
      }
      return t.h = c, t.s = a, t.l = f, t;
    },
    getStyle: function() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function() {
      var t = {};
      return function(e, i, n) {
        return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this;
      };
    }(),
    add: function(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    },
    addColors: function(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    },
    addScalar: function(t) {
      return this.r += t, this.g += t, this.b += t, this;
    },
    sub: function(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    },
    multiply: function(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    },
    multiplyScalar: function(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    },
    lerp: function(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    },
    lerpHSL: function() {
      var t = { h: 0, s: 0, l: 0 }, e = { h: 0, s: 0, l: 0 };
      return function(i, n) {
        this.getHSL(t), i.getHSL(e), i = fi.lerp(t.h, e.h, n);
        var s = fi.lerp(t.s, e.s, n);
        return n = fi.lerp(t.l, e.l, n), this.setHSL(i, s, n), this;
      };
    }(),
    equals: function(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  var qe = {
    common: {
      diffuse: { value: new L(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new m() },
      alphaMap: { value: null }
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new o(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new L(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} }
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} }
      }
    },
    points: {
      diffuse: { value: new L(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      uvTransform: { value: new m() }
    },
    sprite: {
      diffuse: { value: new L(15658734) },
      opacity: { value: 1 },
      center: { value: new o(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      uvTransform: { value: new m() }
    }
  }, ms = {
    basic: {
      uniforms: Dn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.fog
      ]),
      vertexShader: Ei.meshbasic_vert,
      fragmentShader: Ei.meshbasic_frag
    },
    lambert: {
      uniforms: Dn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.fog,
        qe.lights,
        { emissive: { value: new L(0) } }
      ]),
      vertexShader: Ei.meshlambert_vert,
      fragmentShader: Ei.meshlambert_frag
    },
    phong: {
      uniforms: Dn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.gradientmap,
        qe.fog,
        qe.lights,
        {
          emissive: { value: new L(0) },
          specular: { value: new L(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: Ei.meshphong_vert,
      fragmentShader: Ei.meshphong_frag
    },
    standard: {
      uniforms: Dn.merge([
        qe.common,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.roughnessmap,
        qe.metalnessmap,
        qe.fog,
        qe.lights,
        {
          emissive: { value: new L(0) },
          roughness: { value: 0.5 },
          metalness: { value: 0.5 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: Ei.meshphysical_vert,
      fragmentShader: Ei.meshphysical_frag
    },
    matcap: {
      uniforms: Dn.merge([
        qe.common,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: Ei.meshmatcap_vert,
      fragmentShader: Ei.meshmatcap_frag
    },
    points: {
      uniforms: Dn.merge([qe.points, qe.fog]),
      vertexShader: Ei.points_vert,
      fragmentShader: Ei.points_frag
    },
    dashed: {
      uniforms: Dn.merge([
        qe.common,
        qe.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: Ei.linedashed_vert,
      fragmentShader: Ei.linedashed_frag
    },
    depth: {
      uniforms: Dn.merge([qe.common, qe.displacementmap]),
      vertexShader: Ei.depth_vert,
      fragmentShader: Ei.depth_frag
    },
    normal: {
      uniforms: Dn.merge([
        qe.common,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: Ei.normal_vert,
      fragmentShader: Ei.normal_frag
    },
    sprite: {
      uniforms: Dn.merge([qe.sprite, qe.fog]),
      vertexShader: Ei.sprite_vert,
      fragmentShader: Ei.sprite_frag
    },
    background: {
      uniforms: { uvTransform: { value: new m() }, t2D: { value: null } },
      vertexShader: Ei.background_vert,
      fragmentShader: Ei.background_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: Ei.cube_vert,
      fragmentShader: Ei.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ei.equirect_vert,
      fragmentShader: Ei.equirect_frag
    },
    distanceRGBA: {
      uniforms: Dn.merge([
        qe.common,
        qe.displacementmap,
        {
          referencePosition: { value: new u() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: Ei.distanceRGBA_vert,
      fragmentShader: Ei.distanceRGBA_frag
    },
    shadow: {
      uniforms: Dn.merge([
        qe.lights,
        qe.fog,
        { color: { value: new L(0) }, opacity: { value: 1 } }
      ]),
      vertexShader: Ei.shadow_vert,
      fragmentShader: Ei.shadow_frag
    }
  };
  ms.physical = {
    uniforms: Dn.merge([
      ms.standard.uniforms,
      { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }
    ]),
    vertexShader: Ei.meshphysical_vert,
    fragmentShader: Ei.meshphysical_frag
  }, Object.assign(R.prototype, {
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
      for (var e = 0, i = t.vertexNormals.length; e < i; e++)
        this.vertexNormals[e] = t.vertexNormals[e].clone();
      for (e = 0, i = t.vertexColors.length; e < i; e++)
        this.vertexColors[e] = t.vertexColors[e].clone();
      return this;
    }
  }), b.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), b.DefaultOrder = "XYZ", Object.defineProperties(b.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(t) {
        this._order = t, this.onChangeCallback();
      }
    }
  }), Object.assign(b.prototype, {
    isEuler: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t, e, i) {
      var n = fi.clamp, s = t.elements;
      t = s[0];
      var a = s[4], c = s[8], f = s[1], v = s[5], y = s[9], A = s[2], P = s[6];
      return s = s[10], e = e || this._order, e === "XYZ" ? (this._y = Math.asin(n(c, -1, 1)), 0.99999 > Math.abs(c) ? (this._x = Math.atan2(-y, s), this._z = Math.atan2(-a, t)) : (this._x = Math.atan2(P, v), this._z = 0)) : e === "YXZ" ? (this._x = Math.asin(-n(y, -1, 1)), 0.99999 > Math.abs(y) ? (this._y = Math.atan2(c, s), this._z = Math.atan2(f, v)) : (this._y = Math.atan2(-A, t), this._z = 0)) : e === "ZXY" ? (this._x = Math.asin(n(P, -1, 1)), 0.99999 > Math.abs(P) ? (this._y = Math.atan2(-A, s), this._z = Math.atan2(-a, v)) : (this._y = 0, this._z = Math.atan2(f, t))) : e === "ZYX" ? (this._y = Math.asin(-n(A, -1, 1)), 0.99999 > Math.abs(A) ? (this._x = Math.atan2(P, s), this._z = Math.atan2(f, t)) : (this._x = 0, this._z = Math.atan2(-a, v))) : e === "YZX" ? (this._z = Math.asin(n(f, -1, 1)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(-y, v), this._y = Math.atan2(-A, t)) : (this._x = 0, this._y = Math.atan2(c, s))) : e === "XZY" ? (this._z = Math.asin(-n(a, -1, 1)), 0.99999 > Math.abs(a) ? (this._x = Math.atan2(P, v), this._y = Math.atan2(c, t)) : (this._x = Math.atan2(-y, s), this._y = 0)) : console.warn(
        "THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e
      ), this._order = e, i !== !1 && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
      var t = new p();
      return function(e, i, n) {
        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n);
      };
    }(),
    setFromVector3: function(t, e) {
      return this.set(t.x, t.y, t.z, e || this._order);
    },
    reorder: function() {
      var t = new d();
      return function(e) {
        return t.setFromEuler(this), this.setFromQuaternion(t, e);
      };
    }(),
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    },
    fromArray: function(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    },
    toVector3: function(t) {
      return t ? t.set(this._x, this._y, this._z) : new u(this._x, this._y, this._z);
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(U.prototype, {
    set: function(t) {
      this.mask = 1 << t | 0;
    },
    enable: function(t) {
      this.mask = this.mask | 1 << t | 0;
    },
    toggle: function(t) {
      this.mask ^= 1 << t | 0;
    },
    disable: function(t) {
      this.mask &= ~(1 << t | 0);
    },
    test: function(t) {
      return (this.mask & t.mask) !== 0;
    }
  });
  var Ku = 0;
  N.DefaultUp = new u(0, 1, 0), N.DefaultMatrixAutoUpdate = !0, N.prototype = Object.assign(Object.create(l.prototype), {
    constructor: N,
    isObject3D: !0,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix: function(t) {
      this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(t) {
      return this.quaternion.premultiply(t), this;
    },
    setRotationFromAxisAngle: function(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    },
    setRotationFromEuler: function(t) {
      this.quaternion.setFromEuler(t, !0);
    },
    setRotationFromMatrix: function(t) {
      this.quaternion.setFromRotationMatrix(t);
    },
    setRotationFromQuaternion: function(t) {
      this.quaternion.copy(t);
    },
    rotateOnAxis: function() {
      var t = new d();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this;
      };
    }(),
    rotateOnWorldAxis: function() {
      var t = new d();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this;
      };
    }(),
    rotateX: function() {
      var t = new u(1, 0, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateY: function() {
      var t = new u(0, 1, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateZ: function() {
      var t = new u(0, 0, 1);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    translateOnAxis: function() {
      var t = new u();
      return function(e, i) {
        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this;
      };
    }(),
    translateX: function() {
      var t = new u(1, 0, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateY: function() {
      var t = new u(0, 1, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateZ: function() {
      var t = new u(0, 0, 1);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    localToWorld: function(t) {
      return t.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
      var t = new p();
      return function(e) {
        return e.applyMatrix4(t.getInverse(this.matrixWorld));
      };
    }(),
    lookAt: function() {
      var t = new d(), e = new p(), i = new u(), n = new u();
      return function(s, a, c) {
        s.isVector3 ? i.copy(s) : i.set(s, a, c), s = this.parent, this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()));
      };
    }(),
    add: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.add(arguments[e]);
        return this;
      }
      return t === this ? (console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        t
      ), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error(
        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
        t
      ), this);
    },
    remove: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.remove(arguments[e]);
        return this;
      }
      return e = this.children.indexOf(t), e !== -1 && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(e, 1)), this;
    },
    getObjectById: function(t) {
      return this.getObjectByProperty("id", t);
    },
    getObjectByName: function(t) {
      return this.getObjectByProperty("name", t);
    },
    getObjectByProperty: function(t, e) {
      if (this[t] === e)
        return this;
      for (var i = 0, n = this.children.length; i < n; i++) {
        var s = this.children[i].getObjectByProperty(t, e);
        if (s !== void 0)
          return s;
      }
    },
    getWorldPosition: function(t) {
      return t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldPosition() target is now required"
      ), t = new u()), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
      var t = new u(), e = new u();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldQuaternion() target is now required"
        ), i = new d()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i;
      };
    }(),
    getWorldScale: function() {
      var t = new u(), e = new d();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldScale() target is now required"
        ), i = new u()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i;
      };
    }(),
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldDirection() target is now required"
      ), t = new u()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(t) {
      t(this);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].traverse(t);
    },
    traverseVisible: function(t) {
      if (this.visible !== !1) {
        t(this);
        for (var e = this.children, i = 0, n = e.length; i < n; i++)
          e[i].traverseVisible(t);
      }
    },
    traverseAncestors: function(t) {
      var e = this.parent;
      e !== null && (t(e), e.traverseAncestors(t));
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), this.matrixWorldNeedsUpdate = !1, t = !0);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].updateMatrixWorld(t);
    },
    updateWorldMatrix: function(t, e) {
      var i = this.parent;
      if (t === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), e === !0)
        for (t = this.children, e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0);
    },
    toJSON: function(t) {
      function e(A, P) {
        return A[P.uuid] === void 0 && (A[P.uuid] = P.toJSON(t)), P.uuid;
      }
      function i(A) {
        var P = [], k;
        for (k in A) {
          var H = A[k];
          delete H.metadata, P.push(H);
        }
        return P;
      }
      var n = t === void 0 || typeof t == "string", s = {};
      n && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      }, s.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var a = {};
      if (a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), this.renderOrder !== 0 && (a.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
        a.geometry = e(t.geometries, this.geometry);
        var c = this.geometry.parameters;
        if (c !== void 0 && c.shapes !== void 0)
          if (c = c.shapes, Array.isArray(c))
            for (var f = 0, v = c.length; f < v; f++)
              e(t.shapes, c[f]);
          else
            e(t.shapes, c);
      }
      if (this.material !== void 0)
        if (Array.isArray(this.material)) {
          for (c = [], f = 0, v = this.material.length; f < v; f++)
            c.push(e(t.materials, this.material[f]));
          a.material = c;
        } else
          a.material = e(t.materials, this.material);
      if (0 < this.children.length)
        for (a.children = [], f = 0; f < this.children.length; f++)
          a.children.push(this.children[f].toJSON(t).object);
      if (n) {
        n = i(t.geometries), f = i(t.materials), v = i(t.textures);
        var y = i(t.images);
        c = i(t.shapes), 0 < n.length && (s.geometries = n), 0 < f.length && (s.materials = f), 0 < v.length && (s.textures = v), 0 < y.length && (s.images = y), 0 < c.length && (s.shapes = c);
      }
      return s.object = a, s;
    },
    clone: function(t) {
      return new this.constructor().copy(this, t);
    },
    copy: function(t, e) {
      if (e === void 0 && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
        for (e = 0; e < t.children.length; e++)
          this.add(t.children[e].clone());
      return this;
    }
  });
  var Qu = 0;
  j.prototype = Object.assign(Object.create(l.prototype), {
    constructor: j,
    isGeometry: !0,
    applyMatrix: function(t) {
      for (var e = new m().getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++)
        this.vertices[i].applyMatrix4(t);
      for (i = 0, n = this.faces.length; i < n; i++) {
        t = this.faces[i], t.normal.applyMatrix3(e).normalize();
        for (var s = 0, a = t.vertexNormals.length; s < a; s++)
          t.vertexNormals[s].applyMatrix3(e).normalize();
      }
      return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
    },
    rotateX: function() {
      var t = new p();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new p();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new p();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new p();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new p();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new N();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    fromBufferGeometry: function(t) {
      function e(q, K, rt, xt) {
        var gt = f === void 0 ? [] : [i.colors[q].clone(), i.colors[K].clone(), i.colors[rt].clone()], At = c === void 0 ? [] : [
          new u().fromArray(c, 3 * q),
          new u().fromArray(c, 3 * K),
          new u().fromArray(c, 3 * rt)
        ];
        xt = new R(q, K, rt, At, gt, xt), i.faces.push(xt), v !== void 0 && i.faceVertexUvs[0].push([
          new o().fromArray(v, 2 * q),
          new o().fromArray(v, 2 * K),
          new o().fromArray(v, 2 * rt)
        ]), y !== void 0 && i.faceVertexUvs[1].push([
          new o().fromArray(y, 2 * q),
          new o().fromArray(y, 2 * K),
          new o().fromArray(y, 2 * rt)
        ]);
      }
      var i = this, n = t.index !== null ? t.index.array : void 0, s = t.attributes, a = s.position.array, c = s.normal !== void 0 ? s.normal.array : void 0, f = s.color !== void 0 ? s.color.array : void 0, v = s.uv !== void 0 ? s.uv.array : void 0, y = s.uv2 !== void 0 ? s.uv2.array : void 0;
      y !== void 0 && (this.faceVertexUvs[1] = []);
      for (var A = s = 0; s < a.length; s += 3, A += 2)
        i.vertices.push(new u().fromArray(a, s)), f !== void 0 && i.colors.push(new L().fromArray(f, s));
      var P = t.groups;
      if (0 < P.length)
        for (s = 0; s < P.length; s++) {
          a = P[s];
          var k = a.start, H = a.count;
          for (A = k, k += H; A < k; A += 3)
            n !== void 0 ? e(n[A], n[A + 1], n[A + 2], a.materialIndex) : e(A, A + 1, A + 2, a.materialIndex);
        }
      else if (n !== void 0)
        for (s = 0; s < n.length; s += 3)
          e(n[s], n[s + 1], n[s + 2]);
      else
        for (s = 0; s < a.length / 3; s += 3)
          e(s, s + 1, s + 2);
      return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
    },
    center: function() {
      var t = new u();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    normalize: function() {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center, e = this.boundingSphere.radius;
      e = e === 0 ? 1 : 1 / e;
      var i = new p();
      return i.set(
        e,
        0,
        0,
        -e * t.x,
        0,
        e,
        0,
        -e * t.y,
        0,
        0,
        e,
        -e * t.z,
        0,
        0,
        0,
        1
      ), this.applyMatrix(i), this;
    },
    computeFaceNormals: function() {
      for (var t = new u(), e = new u(), i = 0, n = this.faces.length; i < n; i++) {
        var s = this.faces[i], a = this.vertices[s.a], c = this.vertices[s.b];
        t.subVectors(this.vertices[s.c], c), e.subVectors(a, c), t.cross(e), t.normalize(), s.normal.copy(t);
      }
    },
    computeVertexNormals: function(t) {
      t === void 0 && (t = !0);
      var e, i = Array(this.vertices.length), n = 0;
      for (e = this.vertices.length; n < e; n++)
        i[n] = new u();
      if (t) {
        var s = new u(), a = new u();
        for (t = 0, n = this.faces.length; t < n; t++) {
          e = this.faces[t];
          var c = this.vertices[e.a], f = this.vertices[e.b], v = this.vertices[e.c];
          s.subVectors(v, f), a.subVectors(c, f), s.cross(a), i[e.a].add(s), i[e.b].add(s), i[e.c].add(s);
        }
      } else
        for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++)
          e = this.faces[t], i[e.a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal);
      for (n = 0, e = this.vertices.length; n < e; n++)
        i[n].normalize();
      for (t = 0, n = this.faces.length; t < n; t++)
        e = this.faces[t], c = e.vertexNormals, c.length === 3 ? (c[0].copy(i[e.a]), c[1].copy(i[e.b]), c[2].copy(i[e.c])) : (c[0] = i[e.a].clone(), c[1] = i[e.b].clone(), c[2] = i[e.c].clone());
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function() {
      var t;
      this.computeFaceNormals();
      var e = 0;
      for (t = this.faces.length; e < t; e++) {
        var i = this.faces[e], n = i.vertexNormals;
        n.length === 3 ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone());
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function() {
      var t, e, i = 0;
      for (e = this.faces.length; i < e; i++) {
        var n = this.faces[i];
        n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
        var s = 0;
        for (t = n.vertexNormals.length; s < t; s++)
          n.__originalVertexNormals[s] ? n.__originalVertexNormals[s].copy(n.vertexNormals[s]) : n.__originalVertexNormals[s] = n.vertexNormals[s].clone();
      }
      var a = new j();
      for (a.faces = this.faces, s = 0, t = this.morphTargets.length; s < t; s++) {
        if (!this.morphNormals[s]) {
          this.morphNormals[s] = {}, this.morphNormals[s].faceNormals = [], this.morphNormals[s].vertexNormals = [], n = this.morphNormals[s].faceNormals;
          var c = this.morphNormals[s].vertexNormals;
          for (i = 0, e = this.faces.length; i < e; i++) {
            var f = new u(), v = { a: new u(), b: new u(), c: new u() };
            n.push(f), c.push(v);
          }
        }
        for (c = this.morphNormals[s], a.vertices = this.morphTargets[s].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++)
          n = this.faces[i], f = c.faceNormals[i], v = c.vertexNormals[i], f.copy(n.normal), v.a.copy(n.vertexNormals[0]), v.b.copy(n.vertexNormals[1]), v.c.copy(n.vertexNormals[2]);
      }
      for (i = 0, e = this.faces.length; i < e; i++)
        n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new B()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      this.boundingSphere === null && (this.boundingSphere = new I()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(t, e, i) {
      if (t && t.isGeometry) {
        var n, s = this.vertices.length, a = this.vertices, c = t.vertices, f = this.faces, v = t.faces, y = this.faceVertexUvs[0], A = t.faceVertexUvs[0], P = this.colors, k = t.colors;
        i === void 0 && (i = 0), e !== void 0 && (n = new m().getNormalMatrix(e)), t = 0;
        for (var H = c.length; t < H; t++) {
          var q = c[t].clone();
          e !== void 0 && q.applyMatrix4(e), a.push(q);
        }
        for (t = 0, H = k.length; t < H; t++)
          P.push(k[t].clone());
        for (t = 0, H = v.length; t < H; t++) {
          c = v[t];
          var K = c.vertexNormals;
          for (k = c.vertexColors, P = new R(c.a + s, c.b + s, c.c + s), P.normal.copy(c.normal), n !== void 0 && P.normal.applyMatrix3(n).normalize(), e = 0, a = K.length; e < a; e++)
            q = K[e].clone(), n !== void 0 && q.applyMatrix3(n).normalize(), P.vertexNormals.push(q);
          for (P.color.copy(c.color), e = 0, a = k.length; e < a; e++)
            q = k[e], P.vertexColors.push(q.clone());
          P.materialIndex = c.materialIndex + i, f.push(P);
        }
        for (t = 0, H = A.length; t < H; t++)
          if (i = A[t], n = [], i !== void 0) {
            for (e = 0, a = i.length; e < a; e++)
              n.push(i[e].clone());
            y.push(n);
          }
      } else
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          t
        );
    },
    mergeMesh: function(t) {
      t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error(
        "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
        t
      );
    },
    mergeVertices: function() {
      var t = {}, e = [], i = [], n = Math.pow(10, 4), s, a = 0;
      for (s = this.vertices.length; a < s; a++) {
        var c = this.vertices[a];
        c = Math.round(c.x * n) + "_" + Math.round(c.y * n) + "_" + Math.round(c.z * n), t[c] === void 0 ? (t[c] = a, e.push(this.vertices[a]), i[a] = e.length - 1) : i[a] = i[t[c]];
      }
      for (t = [], a = 0, s = this.faces.length; a < s; a++)
        for (n = this.faces[a], n.a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], c = 0; 3 > c; c++)
          if (n[c] === n[(c + 1) % 3]) {
            t.push(a);
            break;
          }
      for (a = t.length - 1; 0 <= a; a--)
        for (n = t[a], this.faces.splice(n, 1), i = 0, s = this.faceVertexUvs.length; i < s; i++)
          this.faceVertexUvs[i].splice(n, 1);
      return a = this.vertices.length - e.length, this.vertices = e, a;
    },
    setFromPoints: function(t) {
      this.vertices = [];
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.vertices.push(new u(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++)
        t[i]._id = i;
      t.sort(function(v, y) {
        return v.materialIndex - y.materialIndex;
      });
      var n = this.faceVertexUvs[0], s = this.faceVertexUvs[1], a, c;
      for (n && n.length === e && (a = []), s && s.length === e && (c = []), i = 0; i < e; i++) {
        var f = t[i]._id;
        a && a.push(n[f]), c && c.push(s[f]);
      }
      a && (this.faceVertexUvs[0] = a), c && (this.faceVertexUvs[1] = c);
    },
    toJSON: function() {
      function t(Vt, Z, st) {
        return st ? Vt | 1 << Z : Vt & ~(1 << Z);
      }
      function e(Vt) {
        var Z = Vt.x.toString() + Vt.y.toString() + Vt.z.toString();
        return y[Z] !== void 0 || (y[Z] = v.length / 3, v.push(Vt.x, Vt.y, Vt.z)), y[Z];
      }
      function i(Vt) {
        var Z = Vt.r.toString() + Vt.g.toString() + Vt.b.toString();
        return P[Z] !== void 0 || (P[Z] = A.length, A.push(Vt.getHex())), P[Z];
      }
      function n(Vt) {
        var Z = Vt.x.toString() + Vt.y.toString();
        return H[Z] !== void 0 || (H[Z] = k.length / 2, k.push(Vt.x, Vt.y)), H[Z];
      }
      var s = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      if (s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.parameters !== void 0) {
        var a = this.parameters, c;
        for (c in a)
          a[c] !== void 0 && (s[c] = a[c]);
        return s;
      }
      for (a = [], c = 0; c < this.vertices.length; c++) {
        var f = this.vertices[c];
        a.push(f.x, f.y, f.z);
      }
      f = [];
      var v = [], y = {}, A = [], P = {}, k = [], H = {};
      for (c = 0; c < this.faces.length; c++) {
        var q = this.faces[c], K = this.faceVertexUvs[0][c] !== void 0, rt = 0 < q.normal.length(), xt = 0 < q.vertexNormals.length, gt = q.color.r !== 1 || q.color.g !== 1 || q.color.b !== 1, At = 0 < q.vertexColors.length, wt = 0;
        wt = t(wt, 0, 0), wt = t(wt, 1, !0), wt = t(wt, 2, !1), wt = t(wt, 3, K), wt = t(wt, 4, rt), wt = t(wt, 5, xt), wt = t(wt, 6, gt), wt = t(wt, 7, At), f.push(wt), f.push(q.a, q.b, q.c), f.push(q.materialIndex), K && (K = this.faceVertexUvs[0][c], f.push(n(K[0]), n(K[1]), n(K[2]))), rt && f.push(e(q.normal)), xt && (rt = q.vertexNormals, f.push(e(rt[0]), e(rt[1]), e(rt[2]))), gt && f.push(i(q.color)), At && (q = q.vertexColors, f.push(i(q[0]), i(q[1]), i(q[2])));
      }
      return s.data = {}, s.data.vertices = a, s.data.normals = v, 0 < A.length && (s.data.colors = A), 0 < k.length && (s.data.uvs = [k]), s.data.faces = f, s;
    },
    clone: function() {
      return new j().copy(this);
    },
    copy: function(t) {
      var e, i, n;
      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var s = t.vertices, a = 0;
      for (e = s.length; a < e; a++)
        this.vertices.push(s[a].clone());
      for (s = t.colors, a = 0, e = s.length; a < e; a++)
        this.colors.push(s[a].clone());
      for (s = t.faces, a = 0, e = s.length; a < e; a++)
        this.faces.push(s[a].clone());
      for (a = 0, e = t.faceVertexUvs.length; a < e; a++) {
        var c = t.faceVertexUvs[a];
        for (this.faceVertexUvs[a] === void 0 && (this.faceVertexUvs[a] = []), s = 0, i = c.length; s < i; s++) {
          var f = c[s], v = [], y = 0;
          for (n = f.length; y < n; y++)
            v.push(f[y].clone());
          this.faceVertexUvs[a].push(v);
        }
      }
      for (y = t.morphTargets, a = 0, e = y.length; a < e; a++) {
        if (n = {}, n.name = y[a].name, y[a].vertices !== void 0)
          for (n.vertices = [], s = 0, i = y[a].vertices.length; s < i; s++)
            n.vertices.push(y[a].vertices[s].clone());
        if (y[a].normals !== void 0)
          for (n.normals = [], s = 0, i = y[a].normals.length; s < i; s++)
            n.normals.push(y[a].normals[s].clone());
        this.morphTargets.push(n);
      }
      for (y = t.morphNormals, a = 0, e = y.length; a < e; a++) {
        if (n = {}, y[a].vertexNormals !== void 0)
          for (n.vertexNormals = [], s = 0, i = y[a].vertexNormals.length; s < i; s++)
            c = y[a].vertexNormals[s], f = {}, f.a = c.a.clone(), f.b = c.b.clone(), f.c = c.c.clone(), n.vertexNormals.push(f);
        if (y[a].faceNormals !== void 0)
          for (n.faceNormals = [], s = 0, i = y[a].faceNormals.length; s < i; s++)
            n.faceNormals.push(y[a].faceNormals[s].clone());
        this.morphNormals.push(n);
      }
      for (s = t.skinWeights, a = 0, e = s.length; a < e; a++)
        this.skinWeights.push(s[a].clone());
      for (s = t.skinIndices, a = 0, e = s.length; a < e; a++)
        this.skinIndices.push(s[a].clone());
      for (s = t.lineDistances, a = 0, e = s.length; a < e; a++)
        this.lineDistances.push(s[a]);
      return a = t.boundingBox, a !== null && (this.boundingBox = a.clone()), a = t.boundingSphere, a !== null && (this.boundingSphere = a.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Object.defineProperty(J.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(J.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.itemSize : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.itemSize, i *= e.itemSize;
      for (var n = 0, s = this.itemSize; n < s; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    copyArray: function(t) {
      return this.array.set(t), this;
    },
    copyColorsArray: function(t) {
      for (var e = this.array, i = 0, n = 0, s = t.length; n < s; n++) {
        var a = t[n];
        a === void 0 && (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          n
        ), a = new L()), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b;
      }
      return this;
    },
    copyVector2sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, s = t.length; n < s; n++) {
        var a = t[n];
        a === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          n
        ), a = new o()), e[i++] = a.x, e[i++] = a.y;
      }
      return this;
    },
    copyVector3sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, s = t.length; n < s; n++) {
        var a = t[n];
        a === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          n
        ), a = new u()), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z;
      }
      return this;
    },
    copyVector4sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, s = t.length; n < s; n++) {
        var a = t[n];
        a === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          n
        ), a = new T()), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w;
      }
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    getX: function(t) {
      return this.array[t * this.itemSize];
    },
    setX: function(t, e) {
      return this.array[t * this.itemSize] = e, this;
    },
    getY: function(t) {
      return this.array[t * this.itemSize + 1];
    },
    setY: function(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    },
    getZ: function(t) {
      return this.array[t * this.itemSize + 2];
    },
    setZ: function(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    },
    getW: function(t) {
      return this.array[t * this.itemSize + 3];
    },
    setW: function(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    },
    setXY: function(t, e, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, s) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = s, this;
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }), $.prototype = Object.create(J.prototype), $.prototype.constructor = $, ct.prototype = Object.create(J.prototype), ct.prototype.constructor = ct, It.prototype = Object.create(J.prototype), It.prototype.constructor = It, et.prototype = Object.create(J.prototype), et.prototype.constructor = et, yt.prototype = Object.create(J.prototype), yt.prototype.constructor = yt, G.prototype = Object.create(J.prototype), G.prototype.constructor = G, Pt.prototype = Object.create(J.prototype), Pt.prototype.constructor = Pt, Et.prototype = Object.create(J.prototype), Et.prototype.constructor = Et, Ct.prototype = Object.create(J.prototype), Ct.prototype.constructor = Ct, Object.assign(ce.prototype, {
    computeGroups: function(t) {
      var e = [], i = void 0;
      t = t.faces;
      for (var n = 0; n < t.length; n++) {
        var s = t[n];
        if (s.materialIndex !== i) {
          i = s.materialIndex, a !== void 0 && (a.count = 3 * n - a.start, e.push(a));
          var a = { start: 3 * n, materialIndex: i };
        }
      }
      a !== void 0 && (a.count = 3 * n - a.start, e.push(a)), this.groups = e;
    },
    fromGeometry: function(t) {
      var e = t.faces, i = t.vertices, n = t.faceVertexUvs, s = n[0] && 0 < n[0].length, a = n[1] && 0 < n[1].length, c = t.morphTargets, f = c.length;
      if (0 < f) {
        for (var v = [], y = 0; y < f; y++)
          v[y] = { name: c[y].name, data: [] };
        this.morphTargets.position = v;
      }
      var A = t.morphNormals, P = A.length;
      if (0 < P) {
        var k = [];
        for (y = 0; y < P; y++)
          k[y] = { name: A[y].name, data: [] };
        this.morphTargets.normal = k;
      }
      var H = t.skinIndices, q = t.skinWeights, K = H.length === i.length, rt = q.length === i.length;
      for (0 < i.length && e.length === 0 && console.error(
        "THREE.DirectGeometry: Faceless geometries are not supported."
      ), y = 0; y < e.length; y++) {
        var xt = e[y];
        this.vertices.push(i[xt.a], i[xt.b], i[xt.c]);
        var gt = xt.vertexNormals;
        for (gt.length === 3 ? this.normals.push(gt[0], gt[1], gt[2]) : (gt = xt.normal, this.normals.push(gt, gt, gt)), gt = xt.vertexColors, gt.length === 3 ? this.colors.push(gt[0], gt[1], gt[2]) : (gt = xt.color, this.colors.push(gt, gt, gt)), s === !0 && (gt = n[0][y], gt !== void 0 ? this.uvs.push(gt[0], gt[1], gt[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
          y
        ), this.uvs.push(new o(), new o(), new o()))), a === !0 && (gt = n[1][y], gt !== void 0 ? this.uvs2.push(gt[0], gt[1], gt[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
          y
        ), this.uvs2.push(new o(), new o(), new o()))), gt = 0; gt < f; gt++) {
          var At = c[gt].vertices;
          v[gt].data.push(At[xt.a], At[xt.b], At[xt.c]);
        }
        for (gt = 0; gt < P; gt++)
          At = A[gt].vertexNormals[y], k[gt].data.push(At.a, At.b, At.c);
        K && this.skinIndices.push(H[xt.a], H[xt.b], H[xt.c]), rt && this.skinWeights.push(q[xt.a], q[xt.b], q[xt.c]);
      }
      return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    }
  });
  var tc = 1;
  Ft.prototype = Object.assign(Object.create(l.prototype), {
    constructor: Ft,
    isBufferGeometry: !0,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(t) {
      Array.isArray(t) ? this.index = new (65535 < re(t) ? Pt : yt)(t, 1) : this.index = t;
    },
    addAttribute: function(t, e, i) {
      return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? t === "index" ? (console.warn(
        "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
      ), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn(
        "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
      ), this.addAttribute(t, new J(e, i)));
    },
    getAttribute: function(t) {
      return this.attributes[t];
    },
    removeAttribute: function(t) {
      return delete this.attributes[t], this;
    },
    addGroup: function(t, e, i) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: i !== void 0 ? i : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    },
    applyMatrix: function(t) {
      var e = this.attributes.position;
      return e !== void 0 && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, e !== void 0 && (new m().getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    },
    rotateX: function() {
      var t = new p();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new p();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new p();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new p();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new p();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new N();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    center: function() {
      var t = new u();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    setFromObject: function(t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        t = new Et(3 * e.vertices.length, 3);
        var i = new Et(3 * e.colors.length, 3);
        this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new Et(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
      } else
        t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function(t) {
      for (var e = [], i = 0, n = t.length; i < n; i++) {
        var s = t[i];
        e.push(s.x, s.y, s.z || 0);
      }
      return this.addAttribute("position", new Et(e, 3)), this;
    },
    updateFromObject: function(t) {
      var e = t.geometry;
      if (t.isMesh) {
        var i = e.__directGeometry;
        if (e.elementsNeedUpdate === !0 && (i = void 0, e.elementsNeedUpdate = !1), i === void 0)
          return this.fromGeometry(e);
        i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i;
      }
      return e.verticesNeedUpdate === !0 && (i = this.attributes.position, i !== void 0 && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), e.normalsNeedUpdate === !0 && (i = this.attributes.normal, i !== void 0 && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), e.colorsNeedUpdate === !0 && (i = this.attributes.color, i !== void 0 && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, i !== void 0 && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, i !== void 0 && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
    },
    fromGeometry: function(t) {
      return t.__directGeometry = new ce().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
    },
    fromDirectGeometry: function(t) {
      var e = new Float32Array(3 * t.vertices.length);
      this.addAttribute("position", new J(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new J(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new J(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new J(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new J(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups;
      for (var i in t.morphTargets) {
        e = [];
        for (var n = t.morphTargets[i], s = 0, a = n.length; s < a; s++) {
          var c = n[s], f = new Et(3 * c.data.length, 3);
          f.name = c.name, e.push(f.copyVector3sArray(c.data));
        }
        this.morphAttributes[i] = e;
      }
      return 0 < t.skinIndices.length && (i = new Et(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new Et(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new B());
      var t = this.attributes.position;
      t !== void 0 ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error(
        'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
    },
    computeBoundingSphere: function() {
      var t = new B(), e = new u();
      return function() {
        this.boundingSphere === null && (this.boundingSphere = new I());
        var i = this.attributes.position;
        if (i) {
          var n = this.boundingSphere.center;
          t.setFromBufferAttribute(i), t.getCenter(n);
          for (var s = 0, a = 0, c = i.count; a < c; a++)
            e.x = i.getX(a), e.y = i.getY(a), e.z = i.getZ(a), s = Math.max(s, n.distanceToSquared(e));
          this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
        }
      };
    }(),
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
      var t = this.index, e = this.attributes;
      if (e.position) {
        var i = e.position.array;
        if (e.normal === void 0)
          this.addAttribute("normal", new J(new Float32Array(i.length), 3));
        else
          for (var n = e.normal.array, s = 0, a = n.length; s < a; s++)
            n[s] = 0;
        n = e.normal.array;
        var c = new u(), f = new u(), v = new u(), y = new u(), A = new u();
        if (t) {
          var P = t.array;
          for (s = 0, a = t.count; s < a; s += 3) {
            t = 3 * P[s + 0];
            var k = 3 * P[s + 1], H = 3 * P[s + 2];
            c.fromArray(i, t), f.fromArray(i, k), v.fromArray(i, H), y.subVectors(v, f), A.subVectors(c, f), y.cross(A), n[t] += y.x, n[t + 1] += y.y, n[t + 2] += y.z, n[k] += y.x, n[k + 1] += y.y, n[k + 2] += y.z, n[H] += y.x, n[H + 1] += y.y, n[H + 2] += y.z;
          }
        } else
          for (s = 0, a = i.length; s < a; s += 9)
            c.fromArray(i, s), f.fromArray(i, s + 3), v.fromArray(i, s + 6), y.subVectors(v, f), A.subVectors(c, f), y.cross(A), n[s] = y.x, n[s + 1] = y.y, n[s + 2] = y.z, n[s + 3] = y.x, n[s + 4] = y.y, n[s + 5] = y.z, n[s + 6] = y.x, n[s + 7] = y.y, n[s + 8] = y.z;
        this.normalizeNormals(), e.normal.needsUpdate = !0;
      }
    },
    merge: function(t, e) {
      if (t && t.isBufferGeometry) {
        e === void 0 && (e = 0, console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
        var i = this.attributes, n;
        for (n in i)
          if (t.attributes[n] !== void 0) {
            var s = i[n].array, a = t.attributes[n], c = a.array, f = 0;
            for (a = a.itemSize * e; f < c.length; f++, a++)
              s[a] = c[f];
          }
        return this;
      }
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
    },
    normalizeNormals: function() {
      var t = new u();
      return function() {
        for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z);
      };
    }(),
    toNonIndexed: function() {
      if (this.index === null)
        return console.warn(
          "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
        ), this;
      var t = new Ft(), e = this.index.array, i = this.attributes, n;
      for (n in i) {
        var s = i[n], a = s.array, c = s.itemSize, f = new a.constructor(e.length * c), v = 0;
        s = 0;
        for (var y = e.length; s < y; s++)
          for (var A = e[s] * c, P = 0; P < c; P++)
            f[v++] = a[A++];
        t.addAttribute(n, new J(f, c));
      }
      for (e = this.groups, s = 0, y = e.length; s < y; s++)
        i = e[s], t.addGroup(i.start, i.count, i.materialIndex);
      return t;
    },
    toJSON: function() {
      var t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), this.parameters !== void 0) {
        var e = this.parameters;
        for (s in e)
          e[s] !== void 0 && (t[s] = e[s]);
        return t;
      }
      t.data = { attributes: {} };
      var i = this.index;
      i !== null && (e = Array.prototype.slice.call(i.array), t.data.index = { type: i.array.constructor.name, array: e }), i = this.attributes;
      for (s in i) {
        var n = i[s];
        e = Array.prototype.slice.call(n.array), t.data.attributes[s] = {
          itemSize: n.itemSize,
          type: n.array.constructor.name,
          array: e,
          normalized: n.normalized
        };
      }
      var s = this.groups;
      return 0 < s.length && (t.data.groups = JSON.parse(JSON.stringify(s))), s = this.boundingSphere, s !== null && (t.data.boundingSphere = {
        center: s.center.toArray(),
        radius: s.radius
      }), t;
    },
    clone: function() {
      return new Ft().copy(this);
    },
    copy: function(t) {
      var e;
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var i = t.index;
      i !== null && this.setIndex(i.clone()), i = t.attributes;
      for (c in i)
        this.addAttribute(c, i[c].clone());
      var n = t.morphAttributes;
      for (c in n) {
        var s = [], a = n[c];
        for (i = 0, e = a.length; i < e; i++)
          s.push(a[i].clone());
        this.morphAttributes[c] = s;
      }
      var c = t.groups;
      for (i = 0, e = c.length; i < e; i++)
        n = c[i], this.addGroup(n.start, n.count, n.materialIndex);
      return c = t.boundingBox, c !== null && (this.boundingBox = c.clone()), c = t.boundingSphere, c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Ot.prototype = Object.create(j.prototype), Ot.prototype.constructor = Ot, Bt.prototype = Object.create(Ft.prototype), Bt.prototype.constructor = Bt, ke.prototype = Object.create(j.prototype), ke.prototype.constructor = ke, fe.prototype = Object.create(Ft.prototype), fe.prototype.constructor = fe;
  var cu = 0;
  Yt.prototype = Object.assign(Object.create(l.prototype), {
    constructor: Yt,
    isMaterial: !0,
    onBeforeCompile: function() {
    },
    setValues: function(t) {
      if (t !== void 0)
        for (var e in t) {
          var i = t[e];
          if (i === void 0)
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          else if (e === "shading")
            console.warn(
              "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
            ), this.flatShading = i === 1;
          else {
            var n = this[e];
            n === void 0 ? console.warn(
              "THREE." + this.type + ": '" + e + "' is not a property of this material."
            ) : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
          }
        }
    },
    toJSON: function(t) {
      function e(s) {
        var a = [], c;
        for (c in s) {
          var f = s[c];
          delete f.metadata, a.push(f);
        }
        return a;
      }
      var i = t === void 0 || typeof t == "string";
      i && (t = { textures: {}, images: {} });
      var n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      return n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearCoat !== void 0 && (n.clearCoat = this.clearCoat), this.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== 0 && (n.side = this.side), this.vertexColors !== 0 && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
      var e = t.clippingPlanes, i = null;
      if (e !== null) {
        var n = e.length;
        i = Array(n);
        for (var s = 0; s !== n; ++s)
          i[s] = e[s].clone();
      }
      return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), ti.prototype = Object.create(Yt.prototype), ti.prototype.constructor = ti, ti.prototype.isShaderMaterial = !0, ti.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Dn.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this;
  }, ti.prototype.toJSON = function(t) {
    var e = Yt.prototype.toJSON.call(this, t);
    e.uniforms = {};
    for (var i in this.uniforms) {
      var n = this.uniforms[i].value;
      e.uniforms[i] = n.isTexture ? { type: "t", value: n.toJSON(t).uuid } : n.isColor ? { type: "c", value: n.getHex() } : n.isVector2 ? { type: "v2", value: n.toArray() } : n.isVector3 ? { type: "v3", value: n.toArray() } : n.isVector4 ? { type: "v4", value: n.toArray() } : n.isMatrix4 ? { type: "m4", value: n.toArray() } : { value: n };
    }
    return 0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e;
  }, Object.assign(Ni.prototype, {
    set: function(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Ray: .at() target is now required"), e = new u()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    },
    recast: function() {
      var t = new u();
      return function(e) {
        return this.origin.copy(this.at(e, t)), this;
      };
    }(),
    closestPointToPoint: function(t, e) {
      return e === void 0 && (console.warn(
        "THREE.Ray: .closestPointToPoint() target is now required"
      ), e = new u()), e.subVectors(t, this.origin), t = e.dot(this.direction), 0 > t ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    distanceToPoint: function(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    },
    distanceSqToPoint: function() {
      var t = new u();
      return function(e) {
        var i = t.subVectors(e, this.origin).dot(this.direction);
        return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e));
      };
    }(),
    distanceSqToSegment: function() {
      var t = new u(), e = new u(), i = new u();
      return function(n, s, a, c) {
        t.copy(n).add(s).multiplyScalar(0.5), e.copy(s).sub(n).normalize(), i.copy(this.origin).sub(t);
        var f = 0.5 * n.distanceTo(s), v = -this.direction.dot(e), y = i.dot(this.direction), A = -i.dot(e), P = i.lengthSq(), k = Math.abs(1 - v * v);
        if (0 < k) {
          n = v * A - y, s = v * y - A;
          var H = f * k;
          0 <= n ? s >= -H ? s <= H ? (f = 1 / k, n *= f, s *= f, v = n * (n + v * s + 2 * y) + s * (v * n + s + 2 * A) + P) : (s = f, n = Math.max(0, -(v * s + y)), v = -n * n + s * (s + 2 * A) + P) : (s = -f, n = Math.max(0, -(v * s + y)), v = -n * n + s * (s + 2 * A) + P) : s <= -H ? (n = Math.max(0, -(-v * f + y)), s = 0 < n ? -f : Math.min(Math.max(-f, -A), f), v = -n * n + s * (s + 2 * A) + P) : s <= H ? (n = 0, s = Math.min(Math.max(-f, -A), f), v = s * (s + 2 * A) + P) : (n = Math.max(0, -(v * f + y)), s = 0 < n ? f : Math.min(Math.max(-f, -A), f), v = -n * n + s * (s + 2 * A) + P);
        } else
          s = 0 < v ? -f : f, n = Math.max(0, -(v * s + y)), v = -n * n + s * (s + 2 * A) + P;
        return a && a.copy(this.direction).multiplyScalar(n).add(this.origin), c && c.copy(e).multiplyScalar(s).add(t), v;
      };
    }(),
    intersectSphere: function() {
      var t = new u();
      return function(e, i) {
        t.subVectors(e.center, this.origin);
        var n = t.dot(this.direction), s = t.dot(t) - n * n;
        return e = e.radius * e.radius, s > e ? null : (e = Math.sqrt(e - s), s = n - e, n += e, 0 > s && 0 > n ? null : 0 > s ? this.at(n, i) : this.at(s, i));
      };
    }(),
    intersectsSphere: function(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    },
    distanceToPlane: function(t) {
      var e = t.normal.dot(this.direction);
      return e === 0 ? t.distanceToPoint(this.origin) === 0 ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, 0 <= t ? t : null);
    },
    intersectPlane: function(t, e) {
      return t = this.distanceToPlane(t), t === null ? null : this.at(t, e);
    },
    intersectsPlane: function(t) {
      var e = t.distanceToPoint(this.origin);
      return e === 0 || 0 > t.normal.dot(this.direction) * e;
    },
    intersectBox: function(t, e) {
      var i = 1 / this.direction.x, n = 1 / this.direction.y, s = 1 / this.direction.z, a = this.origin;
      if (0 <= i) {
        var c = (t.min.x - a.x) * i;
        i *= t.max.x - a.x;
      } else
        c = (t.max.x - a.x) * i, i *= t.min.x - a.x;
      if (0 <= n) {
        var f = (t.min.y - a.y) * n;
        n *= t.max.y - a.y;
      } else
        f = (t.max.y - a.y) * n, n *= t.min.y - a.y;
      return c > n || f > i || ((f > c || c !== c) && (c = f), (n < i || i !== i) && (i = n), 0 <= s ? (f = (t.min.z - a.z) * s, t = (t.max.z - a.z) * s) : (f = (t.max.z - a.z) * s, t = (t.min.z - a.z) * s), c > t || f > i) ? null : ((f > c || c !== c) && (c = f), (t < i || i !== i) && (i = t), 0 > i ? null : this.at(0 <= c ? c : i, e));
    },
    intersectsBox: function() {
      var t = new u();
      return function(e) {
        return this.intersectBox(e, t) !== null;
      };
    }(),
    intersectTriangle: function() {
      var t = new u(), e = new u(), i = new u(), n = new u();
      return function(s, a, c, f, v) {
        if (e.subVectors(a, s), i.subVectors(c, s), n.crossVectors(e, i), a = this.direction.dot(n), 0 < a) {
          if (f)
            return null;
          f = 1;
        } else if (0 > a)
          f = -1, a = -a;
        else
          return null;
        return t.subVectors(this.origin, s), s = f * this.direction.dot(i.crossVectors(t, i)), 0 > s || (c = f * this.direction.dot(e.cross(t)), 0 > c || s + c > a) ? null : (s = -f * t.dot(n), 0 > s ? null : this.at(s / a, v));
      };
    }(),
    applyMatrix4: function(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    },
    equals: function(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
  }), Object.assign(Oe, {
    getNormal: function() {
      var t = new u();
      return function(e, i, n, s) {
        return s === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), s = new u()), s.subVectors(n, i), t.subVectors(e, i), s.cross(t), e = s.lengthSq(), 0 < e ? s.multiplyScalar(1 / Math.sqrt(e)) : s.set(0, 0, 0);
      };
    }(),
    getBarycoord: function() {
      var t = new u(), e = new u(), i = new u();
      return function(n, s, a, c, f) {
        t.subVectors(c, s), e.subVectors(a, s), i.subVectors(n, s), n = t.dot(t), s = t.dot(e), a = t.dot(i);
        var v = e.dot(e);
        c = e.dot(i);
        var y = n * v - s * s;
        return f === void 0 && (console.warn(
          "THREE.Triangle: .getBarycoord() target is now required"
        ), f = new u()), y === 0 ? f.set(-2, -1, -1) : (y = 1 / y, v = (v * a - s * c) * y, n = (n * c - s * a) * y, f.set(1 - v - n, n, v));
      };
    }(),
    containsPoint: function() {
      var t = new u();
      return function(e, i, n, s) {
        return Oe.getBarycoord(e, i, n, s, t), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y;
      };
    }(),
    getUV: function() {
      var t = new u();
      return function(e, i, n, s, a, c, f, v) {
        return this.getBarycoord(e, i, n, s, t), v.set(0, 0), v.addScaledVector(a, t.x), v.addScaledVector(c, t.y), v.addScaledVector(f, t.z), v;
      };
    }()
  }), Object.assign(Oe.prototype, {
    set: function(t, e, i) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
    },
    setFromPointsAndIndices: function(t, e, i, n) {
      return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    },
    getArea: function() {
      var t = new u(), e = new u();
      return function() {
        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), 0.5 * t.cross(e).length();
      };
    }(),
    getMidpoint: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new u()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(t) {
      return Oe.getNormal(this.a, this.b, this.c, t);
    },
    getPlane: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new u()), t.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(t, e) {
      return Oe.getBarycoord(t, this.a, this.b, this.c, e);
    },
    containsPoint: function(t) {
      return Oe.containsPoint(t, this.a, this.b, this.c);
    },
    getUV: function(t, e, i, n, s) {
      return Oe.getUV(t, this.a, this.b, this.c, e, i, n, s);
    },
    intersectsBox: function(t) {
      return t.intersectsTriangle(this);
    },
    closestPointToPoint: function() {
      var t = new u(), e = new u(), i = new u(), n = new u(), s = new u(), a = new u();
      return function(c, f) {
        f === void 0 && (console.warn(
          "THREE.Triangle: .closestPointToPoint() target is now required"
        ), f = new u());
        var v = this.a, y = this.b, A = this.c;
        t.subVectors(y, v), e.subVectors(A, v), n.subVectors(c, v);
        var P = t.dot(n), k = e.dot(n);
        if (0 >= P && 0 >= k)
          return f.copy(v);
        s.subVectors(c, y);
        var H = t.dot(s), q = e.dot(s);
        if (0 <= H && q <= H)
          return f.copy(y);
        var K = P * q - H * k;
        if (0 >= K && 0 <= P && 0 >= H)
          return y = P / (P - H), f.copy(v).addScaledVector(t, y);
        a.subVectors(c, A), c = t.dot(a);
        var rt = e.dot(a);
        return 0 <= rt && c <= rt ? f.copy(A) : (P = c * k - P * rt, 0 >= P && 0 <= k && 0 >= rt ? (K = k / (k - rt), f.copy(v).addScaledVector(e, K)) : (k = H * rt - c * q, 0 >= k && 0 <= q - H && 0 <= c - rt ? (i.subVectors(A, y), K = (q - H) / (q - H + (c - rt)), f.copy(y).addScaledVector(i, K)) : (A = 1 / (k + P + K), y = P * A, K *= A, f.copy(v).addScaledVector(t, y).addScaledVector(e, K))));
      };
    }(),
    equals: function(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }), Ge.prototype = Object.create(Yt.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isMeshBasicMaterial = !0, Ge.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
  }, pi.prototype = Object.assign(Object.create(N.prototype), {
    constructor: pi,
    isMesh: !0,
    setDrawMode: function(t) {
      this.drawMode = t;
    },
    copy: function(t) {
      return N.prototype.copy.call(this, t), this.drawMode = t.drawMode, t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign(
        {},
        t.morphTargetDictionary
      )), this;
    },
    updateMorphTargets: function() {
      var t = this.geometry;
      if (t.isBufferGeometry) {
        t = t.morphAttributes;
        var e = Object.keys(t);
        if (0 < e.length) {
          var i = t[e[0]];
          if (i !== void 0)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
              var n = i[t].name || String(t);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
            }
        }
      } else if (i = t.morphTargets, i !== void 0 && 0 < i.length)
        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++)
          n = i[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
    },
    raycast: function() {
      function t(rt, xt, gt, At, wt, Vt, Z, st) {
        return (xt.side === 1 ? At.intersectTriangle(Z, Vt, wt, !0, st) : At.intersectTriangle(wt, Vt, Z, xt.side !== 2, st)) === null ? null : (K.copy(st), K.applyMatrix4(rt.matrixWorld), xt = gt.ray.origin.distanceTo(K), xt < gt.near || xt > gt.far ? null : { distance: xt, point: K.clone(), object: rt });
      }
      function e(rt, xt, gt, At, wt, Vt, Z, st, zt) {
        return a.fromBufferAttribute(wt, Z), c.fromBufferAttribute(wt, st), f.fromBufferAttribute(wt, zt), (rt = t(rt, xt, gt, At, a, c, f, q)) && (Vt && (P.fromBufferAttribute(Vt, Z), k.fromBufferAttribute(Vt, st), H.fromBufferAttribute(Vt, zt), rt.uv = Oe.getUV(q, a, c, f, P, k, H, new o())), Vt = new R(Z, st, zt), Oe.getNormal(a, c, f, Vt.normal), rt.face = Vt), rt;
      }
      var i = new p(), n = new Ni(), s = new I(), a = new u(), c = new u(), f = new u(), v = new u(), y = new u(), A = new u(), P = new o(), k = new o(), H = new o(), q = new u(), K = new u();
      return function(rt, xt) {
        var gt = this.geometry, At = this.material, wt = this.matrixWorld;
        if (At !== void 0 && (gt.boundingSphere === null && gt.computeBoundingSphere(), s.copy(gt.boundingSphere), s.applyMatrix4(wt), rt.ray.intersectsSphere(s) !== !1 && (i.getInverse(wt), n.copy(rt.ray).applyMatrix4(i), gt.boundingBox === null || n.intersectsBox(gt.boundingBox) !== !1))) {
          if (gt.isBufferGeometry) {
            var Vt = gt.index, Z = gt.attributes.position, st = gt.attributes.uv, zt = gt.groups;
            gt = gt.drawRange;
            var ee;
            if (Vt !== null)
              if (Array.isArray(At)) {
                var $t = 0;
                for (ee = zt.length; $t < ee; $t++) {
                  var qt = zt[$t], Te = At[qt.materialIndex];
                  wt = Math.max(qt.start, gt.start);
                  var me = Math.min(qt.start + qt.count, gt.start + gt.count);
                  for (qt = wt; qt < me; qt += 3) {
                    wt = Vt.getX(qt);
                    var Ie = Vt.getX(qt + 1), be = Vt.getX(qt + 2);
                    (wt = e(this, Te, rt, n, Z, st, wt, Ie, be)) && (wt.faceIndex = Math.floor(qt / 3), xt.push(wt));
                  }
                }
              } else
                for (wt = Math.max(0, gt.start), me = Math.min(Vt.count, gt.start + gt.count), $t = wt, ee = me; $t < ee; $t += 3)
                  wt = Vt.getX($t), Ie = Vt.getX($t + 1), be = Vt.getX($t + 2), (wt = e(this, At, rt, n, Z, st, wt, Ie, be)) && (wt.faceIndex = Math.floor($t / 3), xt.push(wt));
            else if (Z !== void 0)
              if (Array.isArray(At))
                for ($t = 0, ee = zt.length; $t < ee; $t++)
                  for (qt = zt[$t], Te = At[qt.materialIndex], wt = Math.max(qt.start, gt.start), me = Math.min(qt.start + qt.count, gt.start + gt.count), qt = wt; qt < me; qt += 3)
                    wt = qt, Ie = qt + 1, be = qt + 2, (wt = e(this, Te, rt, n, Z, st, wt, Ie, be)) && (wt.faceIndex = Math.floor(qt / 3), xt.push(wt));
              else
                for (wt = Math.max(0, gt.start), me = Math.min(Z.count, gt.start + gt.count), $t = wt, ee = me; $t < ee; $t += 3)
                  wt = $t, Ie = $t + 1, be = $t + 2, (wt = e(this, At, rt, n, Z, st, wt, Ie, be)) && (wt.faceIndex = Math.floor($t / 3), xt.push(wt));
          } else if (gt.isGeometry) {
            for (Z = Array.isArray(At), st = gt.vertices, zt = gt.faces, wt = gt.faceVertexUvs[0], 0 < wt.length && (Vt = wt), qt = 0, me = zt.length; qt < me; qt++)
              if (Ie = zt[qt], wt = Z ? At[Ie.materialIndex] : At, wt !== void 0) {
                if ($t = st[Ie.a], ee = st[Ie.b], Te = st[Ie.c], wt.morphTargets === !0) {
                  be = gt.morphTargets;
                  var ae = this.morphTargetInfluences;
                  a.set(0, 0, 0), c.set(0, 0, 0), f.set(0, 0, 0);
                  for (var We = 0, Ke = be.length; We < Ke; We++) {
                    var ci = ae[We];
                    if (ci !== 0) {
                      var Sn = be[We].vertices;
                      a.addScaledVector(v.subVectors(Sn[Ie.a], $t), ci), c.addScaledVector(y.subVectors(Sn[Ie.b], ee), ci), f.addScaledVector(A.subVectors(Sn[Ie.c], Te), ci);
                    }
                  }
                  a.add($t), c.add(ee), f.add(Te), $t = a, ee = c, Te = f;
                }
                (wt = t(this, wt, rt, n, $t, ee, Te, q)) && (Vt && Vt[qt] && (be = Vt[qt], P.copy(be[0]), k.copy(be[1]), H.copy(be[2]), wt.uv = Oe.getUV(q, $t, ee, Te, P, k, H, new o())), wt.face = Ie, wt.faceIndex = qt, xt.push(wt));
              }
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), D.prototype = Object.create(_.prototype), D.prototype.constructor = D, D.prototype.isCubeTexture = !0, Object.defineProperty(D.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(t) {
      this.image = t;
    }
  }), Q.prototype = Object.create(_.prototype), Q.prototype.constructor = Q, Q.prototype.isDataTexture3D = !0;
  var bh = new _(), ec = new Q(), fu = new D(), Wl = [], ya = [], al = new Float32Array(16), pu = new Float32Array(9), Ah = new Float32Array(4);
  Yo.prototype.updateCache = function(t) {
    var e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), vt(e, t);
  }, za.prototype.setValue = function(t, e, i) {
    for (var n = this.seq, s = 0, a = n.length; s !== a; ++s) {
      var c = n[s];
      c.setValue(t, e[c.id], i);
    }
  };
  var Ch = /([\w\d_]+)(\])?(\[|\.)?/g;
  rs.prototype.setValue = function(t, e, i) {
    e = this.map[e], e !== void 0 && e.setValue(t, i, this.renderer);
  }, rs.prototype.setOptional = function(t, e, i) {
    e = e[i], e !== void 0 && this.setValue(t, i, e);
  }, rs.upload = function(t, e, i, n) {
    for (var s = 0, a = e.length; s !== a; ++s) {
      var c = e[s], f = i[c.id];
      f.needsUpdate !== !1 && c.setValue(t, f.value, n);
    }
  }, rs.seqWithValue = function(t, e) {
    for (var i = [], n = 0, s = t.length; n !== s; ++n) {
      var a = t[n];
      a.id in e && i.push(a);
    }
    return i;
  };
  var zs = 0, Ph = 0;
  oe.prototype = Object.create(Yt.prototype), oe.prototype.constructor = oe, oe.prototype.isMeshDepthMaterial = !0, oe.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }, te.prototype = Object.create(Yt.prototype), te.prototype.constructor = te, te.prototype.isMeshDistanceMaterial = !0, te.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }, ui.prototype = Object.assign(Object.create(N.prototype), {
    constructor: ui,
    isGroup: !0
  }), Be.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Be,
    isCamera: !0,
    copy: function(t, e) {
      return N.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    },
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Camera: .getWorldDirection() target is now required"
      ), t = new u()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(t) {
      N.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), ye.prototype = Object.assign(Object.create(Be.prototype), {
    constructor: ye,
    isPerspectiveCamera: !0,
    copy: function(t, e) {
      return Be.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    },
    setFocalLength: function(t) {
      t = 0.5 * this.getFilmHeight() / t, this.fov = 2 * fi.RAD2DEG * Math.atan(t), this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      var t = Math.tan(0.5 * fi.DEG2RAD * this.fov);
      return 0.5 * this.getFilmHeight() / t;
    },
    getEffectiveFOV: function() {
      return 2 * fi.RAD2DEG * Math.atan(Math.tan(0.5 * fi.DEG2RAD * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(t, e, i, n, s, a) {
      this.aspect = t / e, this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = this.near, e = t * Math.tan(0.5 * fi.DEG2RAD * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, s = -0.5 * n, a = this.view;
      if (this.view !== null && this.view.enabled) {
        var c = a.fullWidth, f = a.fullHeight;
        s += a.offsetX * n / c, e -= a.offsetY * i / f, n *= a.width / c, i *= a.height / f;
      }
      a = this.filmOffset, a !== 0 && (s += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = N.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }), Fe.prototype = Object.assign(Object.create(ye.prototype), {
    constructor: Fe,
    isArrayCamera: !0
  });
  var to = new u(), _r = new u();
  Le.prototype.isFogExp2 = !0, Le.prototype.clone = function() {
    return new Le(this.color, this.density);
  }, Le.prototype.toJSON = function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }, wn.prototype.isFog = !0, wn.prototype.clone = function() {
    return new wn(this.color, this.near, this.far);
  }, wn.prototype.toJSON = function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }, Hn.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Hn,
    copy: function(t, e) {
      return N.prototype.copy.call(this, t, e), t.background !== null && (this.background = t.background.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    },
    toJSON: function(t) {
      var e = N.prototype.toJSON.call(this, t);
      return this.background !== null && (e.object.background = this.background.toJSON(t)), this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
    }
  }), Object.defineProperty(Oi.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(Oi.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.stride : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.stride, i *= e.stride;
      for (var n = 0, s = this.stride; n < s; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    }
  }), Object.defineProperties(Ii.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    }
  }), Object.assign(Ii.prototype, {
    isInterleavedBufferAttribute: !0,
    setX: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    },
    setY: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    },
    setZ: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    },
    setW: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    },
    getX: function(t) {
      return this.data.array[t * this.data.stride + this.offset];
    },
    getY: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    },
    getZ: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    },
    getW: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    },
    setXY: function(t, e, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, s) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = s, this;
    }
  }), Ui.prototype = Object.create(Yt.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isSpriteMaterial = !0, Ui.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
  };
  var xa;
  Qi.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Qi,
    isSprite: !0,
    raycast: function() {
      function t(H, q, K, rt, xt, gt) {
        s.subVectors(H, K).addScalar(0.5).multiply(rt), xt !== void 0 ? (a.x = gt * s.x - xt * s.y, a.y = xt * s.x + gt * s.y) : a.copy(s), H.copy(q), H.x += a.x, H.y += a.y, H.applyMatrix4(c);
      }
      var e = new u(), i = new u(), n = new u(), s = new o(), a = new o(), c = new p(), f = new u(), v = new u(), y = new u(), A = new o(), P = new o(), k = new o();
      return function(H, q) {
        i.setFromMatrixScale(this.matrixWorld), c.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
        var K = this.material.rotation;
        if (K !== 0)
          var rt = Math.cos(K), xt = Math.sin(K);
        K = this.center, t(f.set(-0.5, -0.5, 0), n, K, i, xt, rt), t(v.set(0.5, -0.5, 0), n, K, i, xt, rt), t(y.set(0.5, 0.5, 0), n, K, i, xt, rt), A.set(0, 0), P.set(1, 0), k.set(1, 1);
        var gt = H.ray.intersectTriangle(f, v, y, !1, e);
        gt === null && (t(v.set(-0.5, 0.5, 0), n, K, i, xt, rt), P.set(0, 1), gt = H.ray.intersectTriangle(f, y, v, !1, e), gt === null) || (xt = H.ray.origin.distanceTo(e), xt < H.near || xt > H.far || q.push({
          distance: xt,
          point: e.clone(),
          uv: Oe.getUV(e, f, v, y, A, P, k, new o()),
          face: null,
          object: this
        }));
      };
    }(),
    clone: function() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function(t) {
      return N.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this;
    }
  }), tn.prototype = Object.assign(Object.create(N.prototype), {
    constructor: tn,
    copy: function(t) {
      N.prototype.copy.call(this, t, !1), t = t.levels;
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.addLevel(n.object.clone(), n.distance);
      }
      return this;
    },
    addLevel: function(t, e) {
      e === void 0 && (e = 0), e = Math.abs(e);
      for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++)
        ;
      i.splice(n, 0, { distance: e, object: t }), this.add(t);
    },
    getObjectForDistance: function(t) {
      for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
        ;
      return e[i - 1].object;
    },
    raycast: function() {
      var t = new u();
      return function(e, i) {
        t.setFromMatrixPosition(this.matrixWorld);
        var n = e.ray.origin.distanceTo(t);
        this.getObjectForDistance(n).raycast(e, i);
      };
    }(),
    update: function() {
      var t = new u(), e = new u();
      return function(i) {
        var n = this.levels;
        if (1 < n.length) {
          t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0;
          for (var s = 1, a = n.length; s < a && i >= n[s].distance; s++)
            n[s - 1].object.visible = !1, n[s].object.visible = !0;
          for (; s < a; s++)
            n[s].object.visible = !1;
        }
      };
    }(),
    toJSON: function(t) {
      t = N.prototype.toJSON.call(this, t), t.object.levels = [];
      for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
        var s = e[i];
        t.object.levels.push({ object: s.object.uuid, distance: s.distance });
      }
      return t;
    }
  }), Object.assign(on.prototype, {
    calculateInverses: function() {
      this.boneInverses = [];
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var i = new p();
        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i);
      }
    },
    pose: function() {
      var t, e, i = 0;
      for (e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
      for (i = 0, e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
    },
    update: function() {
      var t = new p(), e = new p();
      return function() {
        for (var i = this.bones, n = this.boneInverses, s = this.boneMatrices, a = this.boneTexture, c = 0, f = i.length; c < f; c++)
          t.multiplyMatrices(i[c] ? i[c].matrixWorld : e, n[c]), t.toArray(s, 16 * c);
        a !== void 0 && (a.needsUpdate = !0);
      };
    }(),
    clone: function() {
      return new on(this.bones, this.boneInverses);
    },
    getBoneByName: function(t) {
      for (var e = 0, i = this.bones.length; e < i; e++) {
        var n = this.bones[e];
        if (n.name === t)
          return n;
      }
    }
  }), an.prototype = Object.assign(Object.create(N.prototype), {
    constructor: an,
    isBone: !0
  }), Fi.prototype = Object.assign(Object.create(pi.prototype), {
    constructor: Fi,
    isSkinnedMesh: !0,
    initBones: function() {
      var t = [], e;
      if (this.geometry && this.geometry.bones !== void 0) {
        var i = 0;
        for (e = this.geometry.bones.length; i < e; i++) {
          var n = this.geometry.bones[i], s = new an();
          t.push(s), s.name = n.name, s.position.fromArray(n.pos), s.quaternion.fromArray(n.rotq), n.scl !== void 0 && s.scale.fromArray(n.scl);
        }
        for (i = 0, e = this.geometry.bones.length; i < e; i++)
          n = this.geometry.bones[i], n.parent !== -1 && n.parent !== null && t[n.parent] !== void 0 ? t[n.parent].add(t[i]) : this.add(t[i]);
      }
      return this.updateMatrixWorld(!0), t;
    },
    bind: function(t, e) {
      this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      var t;
      if (this.geometry && this.geometry.isGeometry)
        for (t = 0; t < this.geometry.skinWeights.length; t++) {
          var e = this.geometry.skinWeights[t], i = 1 / e.manhattanLength();
          i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0);
        }
      else if (this.geometry && this.geometry.isBufferGeometry) {
        e = new T();
        var n = this.geometry.attributes.skinWeight;
        for (t = 0; t < n.count; t++)
          e.x = n.getX(t), e.y = n.getY(t), e.z = n.getZ(t), e.w = n.getW(t), i = 1 / e.manhattanLength(), i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), n.setXYZW(t, e.x, e.y, e.z, e.w);
      }
    },
    updateMatrixWorld: function(t) {
      pi.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn(
        "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
      );
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), Di.prototype = Object.create(Yt.prototype), Di.prototype.constructor = Di, Di.prototype.isLineBasicMaterial = !0, Di.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
  }, Vi.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Vi,
    isLine: !0,
    computeLineDistances: function() {
      var t = new u(), e = new u();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, s = [0], a = 1, c = n.count; a < c; a++)
              t.fromBufferAttribute(n, a - 1), e.fromBufferAttribute(n, a), s[a] = s[a - 1], s[a] += t.distanceTo(e);
            i.addAttribute("lineDistance", new Et(s, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, s = i.lineDistances, s[0] = 0, a = 1, c = n.length; a < c; a++)
            s[a] = s[a - 1], s[a] += n[a - 1].distanceTo(n[a]);
        return this;
      };
    }(),
    raycast: function() {
      var t = new p(), e = new Ni(), i = new I();
      return function(n, s) {
        var a = n.linePrecision, c = this.geometry, f = this.matrixWorld;
        if (c.boundingSphere === null && c.computeBoundingSphere(), i.copy(c.boundingSphere), i.applyMatrix4(f), i.radius += a, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(f), e.copy(n.ray).applyMatrix4(t), a /= (this.scale.x + this.scale.y + this.scale.z) / 3, a *= a;
          var v = new u(), y = new u();
          f = new u();
          var A = new u(), P = this && this.isLineSegments ? 2 : 1;
          if (c.isBufferGeometry) {
            var k = c.index, H = c.attributes.position.array;
            if (k !== null) {
              k = k.array, c = 0;
              for (var q = k.length - 1; c < q; c += P) {
                var K = k[c + 1];
                v.fromArray(H, 3 * k[c]), y.fromArray(H, 3 * K), K = e.distanceSqToSegment(v, y, A, f), K > a || (A.applyMatrix4(this.matrixWorld), K = n.ray.origin.distanceTo(A), K < n.near || K > n.far || s.push({
                  distance: K,
                  point: f.clone().applyMatrix4(this.matrixWorld),
                  index: c,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
              }
            } else
              for (c = 0, q = H.length / 3 - 1; c < q; c += P)
                v.fromArray(H, 3 * c), y.fromArray(H, 3 * c + 3), K = e.distanceSqToSegment(v, y, A, f), K > a || (A.applyMatrix4(this.matrixWorld), K = n.ray.origin.distanceTo(A), K < n.near || K > n.far || s.push({
                  distance: K,
                  point: f.clone().applyMatrix4(this.matrixWorld),
                  index: c,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
          } else if (c.isGeometry)
            for (v = c.vertices, y = v.length, c = 0; c < y - 1; c += P)
              K = e.distanceSqToSegment(v[c], v[c + 1], A, f), K > a || (A.applyMatrix4(this.matrixWorld), K = n.ray.origin.distanceTo(A), K < n.near || K > n.far || s.push({
                distance: K,
                point: f.clone().applyMatrix4(this.matrixWorld),
                index: c,
                face: null,
                faceIndex: null,
                object: this
              }));
        }
      };
    }(),
    copy: function(t) {
      return N.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), mi.prototype = Object.assign(Object.create(Vi.prototype), {
    constructor: mi,
    isLineSegments: !0,
    computeLineDistances: function() {
      var t = new u(), e = new u();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, s = [], a = 0, c = n.count; a < c; a += 2)
              t.fromBufferAttribute(n, a), e.fromBufferAttribute(n, a + 1), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + t.distanceTo(e);
            i.addAttribute("lineDistance", new Et(s, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, s = i.lineDistances, a = 0, c = n.length; a < c; a += 2)
            t.copy(n[a]), e.copy(n[a + 1]), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + t.distanceTo(e);
        return this;
      };
    }()
  }), os.prototype = Object.assign(Object.create(Vi.prototype), {
    constructor: os,
    isLineLoop: !0
  }), Bn.prototype = Object.create(Yt.prototype), Bn.prototype.constructor = Bn, Bn.prototype.isPointsMaterial = !0, Bn.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
  }, $o.prototype = Object.assign(Object.create(N.prototype), {
    constructor: $o,
    isPoints: !0,
    raycast: function() {
      var t = new p(), e = new Ni(), i = new I();
      return function(n, s) {
        function a(rt, xt) {
          var gt = e.distanceSqToPoint(rt);
          gt < A && (e.closestPointToPoint(rt, P), P.applyMatrix4(v), rt = n.ray.origin.distanceTo(P), rt < n.near || rt > n.far || s.push({
            distance: rt,
            distanceToRay: Math.sqrt(gt),
            point: P.clone(),
            index: xt,
            face: null,
            object: c
          }));
        }
        var c = this, f = this.geometry, v = this.matrixWorld, y = n.params.Points.threshold;
        if (f.boundingSphere === null && f.computeBoundingSphere(), i.copy(f.boundingSphere), i.applyMatrix4(v), i.radius += y, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(v), e.copy(n.ray).applyMatrix4(t), y /= (this.scale.x + this.scale.y + this.scale.z) / 3;
          var A = y * y;
          y = new u();
          var P = new u();
          if (f.isBufferGeometry) {
            var k = f.index;
            if (f = f.attributes.position.array, k !== null) {
              var H = k.array;
              k = 0;
              for (var q = H.length; k < q; k++) {
                var K = H[k];
                y.fromArray(f, 3 * K), a(y, K);
              }
            } else
              for (k = 0, H = f.length / 3; k < H; k++)
                y.fromArray(f, 3 * k), a(y, k);
          } else
            for (y = f.vertices, k = 0, H = y.length; k < H; k++)
              a(y[k], k);
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), dh.prototype = Object.assign(Object.create(_.prototype), {
    constructor: dh,
    isVideoTexture: !0,
    update: function() {
      var t = this.image;
      t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  }), Gs.prototype = Object.create(_.prototype), Gs.prototype.constructor = Gs, Gs.prototype.isCompressedTexture = !0, Ba.prototype = Object.create(_.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isCanvasTexture = !0, Na.prototype = Object.create(_.prototype), Na.prototype.constructor = Na, Na.prototype.isDepthTexture = !0, Ko.prototype = Object.create(Ft.prototype), Ko.prototype.constructor = Ko, Fa.prototype = Object.create(j.prototype), Fa.prototype.constructor = Fa, Qo.prototype = Object.create(Ft.prototype), Qo.prototype.constructor = Qo, Wi.prototype = Object.create(j.prototype), Wi.prototype.constructor = Wi, yi.prototype = Object.create(Ft.prototype), yi.prototype.constructor = yi, Ua.prototype = Object.create(j.prototype), Ua.prototype.constructor = Ua, ta.prototype = Object.create(yi.prototype), ta.prototype.constructor = ta, Ga.prototype = Object.create(j.prototype), Ga.prototype.constructor = Ga, fo.prototype = Object.create(yi.prototype), fo.prototype.constructor = fo, Ha.prototype = Object.create(j.prototype), Ha.prototype.constructor = Ha, ea.prototype = Object.create(yi.prototype), ea.prototype.constructor = ea, ia.prototype = Object.create(j.prototype), ia.prototype.constructor = ia, na.prototype = Object.create(yi.prototype), na.prototype.constructor = na, fn.prototype = Object.create(j.prototype), fn.prototype.constructor = fn, Hs.prototype = Object.create(Ft.prototype), Hs.prototype.constructor = Hs, Vr.prototype = Object.create(j.prototype), Vr.prototype.constructor = Vr, po.prototype = Object.create(Ft.prototype), po.prototype.constructor = po, mo.prototype = Object.create(j.prototype), mo.prototype.constructor = mo, Nn.prototype = Object.create(Ft.prototype), Nn.prototype.constructor = Nn;
  var du = {
    triangulate: function(t, e, i) {
      i = i || 2;
      var n = e && e.length, s = n ? e[0] * i : t.length, a = mh(t, 0, s, i, !0), c = [];
      if (!a)
        return c;
      var f;
      if (n) {
        var v = i;
        n = [];
        var y, A = 0;
        for (y = e.length; A < y; A++) {
          var P = e[A] * v, k = A < y - 1 ? e[A + 1] * v : t.length;
          P = mh(t, P, k, v, !1), P === P.next && (P.steiner = !0), n.push(mr(P));
        }
        for (n.sort(tu), A = 0; A < n.length; A++)
          e = n[A], v = a, (v = eu(e, v)) && (e = Va(v, e), ra(e, e.next)), a = ra(a, a.next);
      }
      if (t.length > 80 * i) {
        var H = f = t[0], q = n = t[1];
        for (v = i; v < s; v += i)
          A = t[v], e = t[v + 1], A < H && (H = A), e < q && (q = e), A > f && (f = A), e > n && (n = e);
        f = Math.max(f - H, n - q), f = f !== 0 ? 1 / f : 0;
      }
      return sa(a, c, i, H, q, f), c;
    }
  }, gs = {
    area: function(t) {
      for (var e = t.length, i = 0, n = e - 1, s = 0; s < e; n = s++)
        i += t[n].x * t[s].y - t[s].x * t[n].y;
      return 0.5 * i;
    },
    isClockWise: function(t) {
      return 0 > gs.area(t);
    },
    triangulateShape: function(t, e) {
      var i = [], n = [], s = [];
      Dl(t), iu(i, t);
      var a = t.length;
      for (e.forEach(Dl), t = 0; t < e.length; t++)
        n.push(a), a += e[t].length, iu(i, e[t]);
      for (e = du.triangulate(i, n), t = 0; t < e.length; t += 3)
        s.push(e.slice(t, t + 3));
      return s;
    }
  };
  As.prototype = Object.create(j.prototype), As.prototype.constructor = As, As.prototype.toJSON = function() {
    var t = j.prototype.toJSON.call(this);
    return nu(this.parameters.shapes, this.parameters.options, t);
  }, ls.prototype = Object.create(Ft.prototype), ls.prototype.constructor = ls, ls.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return nu(this.parameters.shapes, this.parameters.options, t);
  };
  var ll = {
    generateTopUV: function(t, e, i, n, s) {
      t = e[3 * n], n = e[3 * n + 1];
      var a = e[3 * s];
      return s = e[3 * s + 1], [new o(e[3 * i], e[3 * i + 1]), new o(t, n), new o(a, s)];
    },
    generateSideWallUV: function(t, e, i, n, s, a) {
      t = e[3 * i];
      var c = e[3 * i + 1];
      i = e[3 * i + 2];
      var f = e[3 * n], v = e[3 * n + 1];
      n = e[3 * n + 2];
      var y = e[3 * s], A = e[3 * s + 1];
      s = e[3 * s + 2];
      var P = e[3 * a], k = e[3 * a + 1];
      return e = e[3 * a + 2], 0.01 > Math.abs(c - v) ? [new o(t, 1 - i), new o(f, 1 - n), new o(y, 1 - s), new o(P, 1 - e)] : [new o(c, 1 - i), new o(v, 1 - n), new o(A, 1 - s), new o(k, 1 - e)];
    }
  };
  Wa.prototype = Object.create(j.prototype), Wa.prototype.constructor = Wa, vo.prototype = Object.create(ls.prototype), vo.prototype.constructor = vo, Vs.prototype = Object.create(j.prototype), Vs.prototype.constructor = Vs, Er.prototype = Object.create(Ft.prototype), Er.prototype.constructor = Er, ja.prototype = Object.create(j.prototype), ja.prototype.constructor = ja, _o.prototype = Object.create(Ft.prototype), _o.prototype.constructor = _o, oa.prototype = Object.create(j.prototype), oa.prototype.constructor = oa, Ws.prototype = Object.create(Ft.prototype), Ws.prototype.constructor = Ws, Cs.prototype = Object.create(j.prototype), Cs.prototype.constructor = Cs, Cs.prototype.toJSON = function() {
    var t = j.prototype.toJSON.call(this);
    return ru(this.parameters.shapes, t);
  }, js.prototype = Object.create(Ft.prototype), js.prototype.constructor = js, js.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return ru(this.parameters.shapes, t);
  }, Xs.prototype = Object.create(Ft.prototype), Xs.prototype.constructor = Xs, Ps.prototype = Object.create(j.prototype), Ps.prototype.constructor = Ps, Ls.prototype = Object.create(Ft.prototype), Ls.prototype.constructor = Ls, aa.prototype = Object.create(Ps.prototype), aa.prototype.constructor = aa, Fn.prototype = Object.create(Ls.prototype), Fn.prototype.constructor = Fn, yo.prototype = Object.create(j.prototype), yo.prototype.constructor = yo, hs.prototype = Object.create(Ft.prototype), hs.prototype.constructor = hs;
  var dn = Object.freeze({
    WireframeGeometry: Ko,
    ParametricGeometry: Fa,
    ParametricBufferGeometry: Qo,
    TetrahedronGeometry: Ua,
    TetrahedronBufferGeometry: ta,
    OctahedronGeometry: Ga,
    OctahedronBufferGeometry: fo,
    IcosahedronGeometry: Ha,
    IcosahedronBufferGeometry: ea,
    DodecahedronGeometry: ia,
    DodecahedronBufferGeometry: na,
    PolyhedronGeometry: Wi,
    PolyhedronBufferGeometry: yi,
    TubeGeometry: fn,
    TubeBufferGeometry: Hs,
    TorusKnotGeometry: Vr,
    TorusKnotBufferGeometry: po,
    TorusGeometry: mo,
    TorusBufferGeometry: Nn,
    TextGeometry: Wa,
    TextBufferGeometry: vo,
    SphereGeometry: Vs,
    SphereBufferGeometry: Er,
    RingGeometry: ja,
    RingBufferGeometry: _o,
    PlaneGeometry: ke,
    PlaneBufferGeometry: fe,
    LatheGeometry: oa,
    LatheBufferGeometry: Ws,
    ShapeGeometry: Cs,
    ShapeBufferGeometry: js,
    ExtrudeGeometry: As,
    ExtrudeBufferGeometry: ls,
    EdgesGeometry: Xs,
    ConeGeometry: aa,
    ConeBufferGeometry: Fn,
    CylinderGeometry: Ps,
    CylinderBufferGeometry: Ls,
    CircleGeometry: yo,
    CircleBufferGeometry: hs,
    BoxGeometry: Ot,
    BoxBufferGeometry: Bt
  });
  qs.prototype = Object.create(Yt.prototype), qs.prototype.constructor = qs, qs.prototype.isShadowMaterial = !0, qs.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this;
  }, xo.prototype = Object.create(ti.prototype), xo.prototype.constructor = xo, xo.prototype.isRawShaderMaterial = !0, us.prototype = Object.create(Yt.prototype), us.prototype.constructor = us, us.prototype.isMeshStandardMaterial = !0, us.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, wo.prototype = Object.create(us.prototype), wo.prototype.constructor = wo, wo.prototype.isMeshPhysicalMaterial = !0, wo.prototype.copy = function(t) {
    return us.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this;
  }, Wr.prototype = Object.create(Yt.prototype), Wr.prototype.constructor = Wr, Wr.prototype.isMeshPhongMaterial = !0, Wr.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, To.prototype = Object.create(Wr.prototype), To.prototype.constructor = To, To.prototype.isMeshToonMaterial = !0, To.prototype.copy = function(t) {
    return Wr.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this;
  }, Mo.prototype = Object.create(Yt.prototype), Mo.prototype.constructor = Mo, Mo.prototype.isMeshNormalMaterial = !0, Mo.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, br.prototype = Object.create(Yt.prototype), br.prototype.constructor = br, br.prototype.isMeshLambertMaterial = !0, br.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, So.prototype = Object.create(Yt.prototype), So.prototype.constructor = So, So.prototype.isMeshMatcapMaterial = !0, So.prototype.copy = function(t) {
    return Yt.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Eo.prototype = Object.create(Di.prototype), Eo.prototype.constructor = Eo, Eo.prototype.isLineDashedMaterial = !0, Eo.prototype.copy = function(t) {
    return Di.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
  };
  var mu = Object.freeze({
    ShadowMaterial: qs,
    SpriteMaterial: Ui,
    RawShaderMaterial: xo,
    ShaderMaterial: ti,
    PointsMaterial: Bn,
    MeshPhysicalMaterial: wo,
    MeshStandardMaterial: us,
    MeshPhongMaterial: Wr,
    MeshToonMaterial: To,
    MeshNormalMaterial: Mo,
    MeshLambertMaterial: br,
    MeshDepthMaterial: oe,
    MeshDistanceMaterial: te,
    MeshBasicMaterial: Ge,
    MeshMatcapMaterial: So,
    LineDashedMaterial: Eo,
    LineBasicMaterial: Di,
    Material: Yt
  }), Wn = {
    arraySlice: function(t, e, i) {
      return Wn.isTypedArray(t) ? new t.constructor(t.subarray(e, i !== void 0 ? i : t.length)) : t.slice(e, i);
    },
    convertArray: function(t, e, i) {
      return !t || !i && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
    },
    isTypedArray: function(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function(t) {
      for (var e = t.length, i = Array(e), n = 0; n !== e; ++n)
        i[n] = n;
      return i.sort(function(s, a) {
        return t[s] - t[a];
      }), i;
    },
    sortedArray: function(t, e, i) {
      for (var n = t.length, s = new t.constructor(n), a = 0, c = 0; c !== n; ++a)
        for (var f = i[a] * e, v = 0; v !== e; ++v)
          s[c++] = t[f + v];
      return s;
    },
    flattenJSON: function(t, e, i, n) {
      for (var s = 1, a = t[0]; a !== void 0 && a[n] === void 0; )
        a = t[s++];
      if (a !== void 0) {
        var c = a[n];
        if (c !== void 0)
          if (Array.isArray(c))
            do
              c = a[n], c !== void 0 && (e.push(a.time), i.push.apply(i, c)), a = t[s++];
            while (a !== void 0);
          else if (c.toArray !== void 0)
            do
              c = a[n], c !== void 0 && (e.push(a.time), c.toArray(i, i.length)), a = t[s++];
            while (a !== void 0);
          else
            do
              c = a[n], c !== void 0 && (e.push(a.time), i.push(c)), a = t[s++];
            while (a !== void 0);
      }
    }
  };
  Object.assign(Zn.prototype, {
    evaluate: function(t) {
      var e = this.parameterPositions, i = this._cachedIndex, n = e[i], s = e[i - 1];
      t: {
        e: {
          i: {
            n:
              if (!(t < n)) {
                for (var a = i + 2; ; ) {
                  if (n === void 0) {
                    if (t < s)
                      break n;
                    return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, s);
                  }
                  if (i === a)
                    break;
                  if (s = n, n = e[++i], t < n)
                    break e;
                }
                n = e.length;
                break i;
              }
            if (t >= s)
              break t;
            for (a = e[1], t < a && (i = 2, s = a), a = i - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, n);
              if (i === a)
                break;
              if (n = s, s = e[--i - 1], t >= s)
                break e;
            }
            n = i, i = 0;
          }
          for (; i < n; )
            s = i + n >>> 1, t < e[s] ? n = s : i = s + 1;
          if (n = e[i], s = e[i - 1], s === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t, n);
          if (n === void 0)
            return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, s, t);
        }
        this._cachedIndex = i, this.intervalChanged_(i, s, n);
      }
      return this.interpolate_(i, s, t, n);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(t) {
      var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize;
      t *= n;
      for (var s = 0; s !== n; ++s)
        e[s] = i[t + s];
      return e;
    },
    interpolate_: function() {
      throw Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  }), Object.assign(Zn.prototype, {
    beforeStart_: Zn.prototype.copySampleValue_,
    afterEnd_: Zn.prototype.copySampleValue_
  }), Xa.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: Xa,
    DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
    intervalChanged_: function(t, e, i) {
      var n = this.parameterPositions, s = t - 2, a = t + 1, c = n[s], f = n[a];
      if (c === void 0)
        switch (this.getSettings_().endingStart) {
          case 2401:
            s = t, c = 2 * e - i;
            break;
          case 2402:
            s = n.length - 2, c = e + n[s] - n[s + 1];
            break;
          default:
            s = t, c = i;
        }
      if (f === void 0)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            a = t, f = 2 * i - e;
            break;
          case 2402:
            a = 1, f = i + n[1] - n[0];
            break;
          default:
            a = t - 1, f = e;
        }
      t = 0.5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - c), this._weightNext = t / (f - i), this._offsetPrev = s * n, this._offsetNext = a * n;
    },
    interpolate_: function(t, e, i, n) {
      var s = this.resultBuffer, a = this.sampleValues, c = this.valueSize;
      t *= c;
      var f = t - c, v = this._offsetPrev, y = this._offsetNext, A = this._weightPrev, P = this._weightNext, k = (i - e) / (n - e);
      for (i = k * k, n = i * k, e = -A * n + 2 * A * i - A * k, A = (1 + A) * n + (-1.5 - 2 * A) * i + (-0.5 + A) * k + 1, k = (-1 - P) * n + (1.5 + P) * i + 0.5 * k, P = P * n - P * i, i = 0; i !== c; ++i)
        s[i] = e * a[v + i] + A * a[f + i] + k * a[t + i] + P * a[y + i];
      return s;
    }
  }), Ar.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: Ar,
    interpolate_: function(t, e, i, n) {
      var s = this.resultBuffer, a = this.sampleValues, c = this.valueSize;
      t *= c;
      var f = t - c;
      for (e = (i - e) / (n - e), i = 1 - e, n = 0; n !== c; ++n)
        s[n] = a[f + n] * i + a[t + n] * e;
      return s;
    }
  }), bo.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: bo,
    interpolate_: function(t) {
      return this.copySampleValue_(t - 1);
    }
  }), Object.assign(Un, {
    toJSON: function(t) {
      var e = t.constructor;
      if (e.toJSON !== void 0)
        e = e.toJSON(t);
      else {
        e = {
          name: t.name,
          times: Wn.convertArray(t.times, Array),
          values: Wn.convertArray(t.values, Array)
        };
        var i = t.getInterpolation();
        i !== t.DefaultInterpolation && (e.interpolation = i);
      }
      return e.type = t.ValueTypeName, e;
    }
  }), Object.assign(Un.prototype, {
    constructor: Un,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function(t) {
      return new bo(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodLinear: function(t) {
      return new Ar(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: function(t) {
      return new Xa(this.times, this.values, this.getValueSize(), t);
    },
    setInterpolation: function(t) {
      switch (t) {
        case 2300:
          var e = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (e === void 0) {
        if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, this.createInterpolant === void 0)
          if (t !== this.DefaultInterpolation)
            this.setInterpolation(this.DefaultInterpolation);
          else
            throw Error(e);
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return this.createInterpolant = e, this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(t) {
      if (t !== 0)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] += t;
      return this;
    },
    scale: function(t) {
      if (t !== 1)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] *= t;
      return this;
    },
    trim: function(t, e) {
      for (var i = this.times, n = i.length, s = 0, a = n - 1; s !== n && i[s] < t; )
        ++s;
      for (; a !== -1 && i[a] > e; )
        --a;
      return ++a, (s !== 0 || a !== n) && (s >= a && (a = Math.max(a, 1), s = a - 1), t = this.getValueSize(), this.times = Wn.arraySlice(i, s, a), this.values = Wn.arraySlice(this.values, s * t, a * t)), this;
    },
    validate: function() {
      var t = !0, e = this.getValueSize();
      e - Math.floor(e) !== 0 && (console.error(
        "THREE.KeyframeTrack: Invalid value size in track.",
        this
      ), t = !1);
      var i = this.times;
      e = this.values;
      var n = i.length;
      n === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      for (var s = null, a = 0; a !== n; a++) {
        var c = i[a];
        if (typeof c == "number" && isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            a,
            c
          ), t = !1;
          break;
        }
        if (s !== null && s > c) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            a,
            c,
            s
          ), t = !1;
          break;
        }
        s = c;
      }
      if (e !== void 0 && Wn.isTypedArray(e)) {
        for (a = 0, i = e.length; a !== i; ++a)
          if (n = e[a], isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              a,
              n
            ), t = !1;
            break;
          }
      }
      return t;
    },
    optimize: function() {
      for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === 2302, s = 1, a = t.length - 1, c = 1; c < a; ++c) {
        var f = !1, v = t[c];
        if (v !== t[c + 1] && (c !== 1 || v !== v[0]))
          if (n)
            f = !0;
          else {
            var y = c * i, A = y - i, P = y + i;
            for (v = 0; v !== i; ++v) {
              var k = e[y + v];
              if (k !== e[A + v] || k !== e[P + v]) {
                f = !0;
                break;
              }
            }
          }
        if (f) {
          if (c !== s)
            for (t[s] = t[c], f = c * i, y = s * i, v = 0; v !== i; ++v)
              e[y + v] = e[f + v];
          ++s;
        }
      }
      if (0 < a) {
        for (t[s] = t[a], f = a * i, y = s * i, v = 0; v !== i; ++v)
          e[y + v] = e[f + v];
        ++s;
      }
      return s !== t.length && (this.times = Wn.arraySlice(t, 0, s), this.values = Wn.arraySlice(e, 0, s * i)), this;
    }
  }), zl.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: zl,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), kl.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: kl,
    ValueTypeName: "color"
  }), jr.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: jr,
    ValueTypeName: "number"
  }), ir.prototype = Object.assign(Object.create(Zn.prototype), {
    constructor: ir,
    interpolate_: function(t, e, i, n) {
      var s = this.resultBuffer, a = this.sampleValues, c = this.valueSize;
      for (t *= c, e = (i - e) / (n - e), i = t + c; t !== i; t += 4)
        d.slerpFlat(s, 0, a, t - c, a, t, e);
      return s;
    }
  }), la.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: la,
    ValueTypeName: "quaternion",
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodLinear: function(t) {
      return new ir(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: void 0
  }), Bl.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: Bl,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), ha.prototype = Object.assign(Object.create(Un.prototype), {
    constructor: ha,
    ValueTypeName: "vector"
  }), Object.assign(gr, {
    parse: function(t) {
      for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), s = 0, a = i.length; s !== a; ++s)
        e.push($u(i[s]).scale(n));
      return new gr(t.name, t.duration, e);
    },
    toJSON: function(t) {
      var e = [], i = t.tracks;
      t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid };
      for (var n = 0, s = i.length; n !== s; ++n)
        e.push(Un.toJSON(i[n]));
      return t;
    },
    CreateFromMorphTargetSequence: function(t, e, i, n) {
      for (var s = e.length, a = [], c = 0; c < s; c++) {
        var f = [], v = [];
        f.push((c + s - 1) % s, c, (c + 1) % s), v.push(0, 1, 0);
        var y = Wn.getKeyframeOrder(f);
        f = Wn.sortedArray(f, 1, y), v = Wn.sortedArray(v, 1, y), n || f[0] !== 0 || (f.push(s), v.push(v[0])), a.push(
          new jr(".morphTargetInfluences[" + e[c].name + "]", f, v).scale(1 / i)
        );
      }
      return new gr(t, -1, a);
    },
    findByName: function(t, e) {
      var i = t;
      for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)
        if (i[t].name === e)
          return i[t];
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(t, e, i) {
      for (var n = {}, s = /^([\w-]*?)([\d]+)$/, a = 0, c = t.length; a < c; a++) {
        var f = t[a], v = f.name.match(s);
        if (v && 1 < v.length) {
          var y = v[1];
          (v = n[y]) || (n[y] = v = []), v.push(f);
        }
      }
      t = [];
      for (y in n)
        t.push(gr.CreateFromMorphTargetSequence(y, n[y], e, i));
      return t;
    },
    parseAnimation: function(t, e) {
      if (!t)
        return console.error(
          "THREE.AnimationClip: No animation in JSONLoader data."
        ), null;
      var i = function(K, rt, xt, gt, At) {
        if (xt.length !== 0) {
          var wt = [], Vt = [];
          Wn.flattenJSON(xt, wt, Vt, gt), wt.length !== 0 && At.push(new K(rt, wt, Vt));
        }
      }, n = [], s = t.name || "default", a = t.length || -1, c = t.fps || 30;
      t = t.hierarchy || [];
      for (var f = 0; f < t.length; f++) {
        var v = t[f].keys;
        if (v && v.length !== 0)
          if (v[0].morphTargets) {
            a = {};
            for (var y = 0; y < v.length; y++)
              if (v[y].morphTargets)
                for (var A = 0; A < v[y].morphTargets.length; A++)
                  a[v[y].morphTargets[A]] = -1;
            for (var P in a) {
              var k = [], H = [];
              for (A = 0; A !== v[y].morphTargets.length; ++A) {
                var q = v[y];
                k.push(q.time), H.push(q.morphTarget === P ? 1 : 0);
              }
              n.push(new jr(".morphTargetInfluence[" + P + "]", k, H));
            }
            a = a.length * (c || 1);
          } else
            y = ".bones[" + e[f].name + "]", i(ha, y + ".position", v, "pos", n), i(la, y + ".quaternion", v, "rot", n), i(ha, y + ".scale", v, "scl", n);
      }
      return n.length === 0 ? null : new gr(s, a, n);
    }
  }), Object.assign(gr.prototype, {
    resetDuration: function() {
      for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
        var n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return this.duration = t, this;
    },
    trim: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    },
    validate: function() {
      for (var t = !0, e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    },
    optimize: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].optimize();
      return this;
    }
  });
  var vs = {
    enabled: !1,
    files: {},
    add: function(t, e) {
      this.enabled !== !1 && (this.files[t] = e);
    },
    get: function(t) {
      if (this.enabled !== !1)
        return this.files[t];
    },
    remove: function(t) {
      delete this.files[t];
    },
    clear: function() {
      this.files = {};
    }
  }, Kn = new Ys(), Lr = {};
  Object.assign(Lt.prototype, {
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var s = this, a = vs.get(t);
      if (a !== void 0)
        return s.manager.itemStart(t), setTimeout(function() {
          e && e(a), s.manager.itemEnd(t);
        }, 0), a;
      if (Lr[t] !== void 0)
        Lr[t].push({ onLoad: e, onProgress: i, onError: n });
      else {
        var c = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (c) {
          i = c[1];
          var f = !!c[2];
          c = c[3], c = decodeURIComponent(c), f && (c = atob(c));
          try {
            var v = (this.responseType || "").toLowerCase();
            switch (v) {
              case "arraybuffer":
              case "blob":
                var y = new Uint8Array(c.length);
                for (f = 0; f < c.length; f++)
                  y[f] = c.charCodeAt(f);
                var A = v === "blob" ? new Blob([y.buffer], { type: i }) : y.buffer;
                break;
              case "document":
                A = new DOMParser().parseFromString(c, i);
                break;
              case "json":
                A = JSON.parse(c);
                break;
              default:
                A = c;
            }
            setTimeout(function() {
              e && e(A), s.manager.itemEnd(t);
            }, 0);
          } catch (k) {
            setTimeout(function() {
              n && n(k), s.manager.itemError(t), s.manager.itemEnd(t);
            }, 0);
          }
        } else {
          Lr[t] = [], Lr[t].push({ onLoad: e, onProgress: i, onError: n });
          var P = new XMLHttpRequest();
          P.open("GET", t, !0), P.addEventListener(
            "load",
            function(k) {
              var H = this.response;
              vs.add(t, H);
              var q = Lr[t];
              if (delete Lr[t], this.status === 200 || this.status === 0) {
                this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var K = 0, rt = q.length; K < rt; K++) {
                  var xt = q[K];
                  xt.onLoad && xt.onLoad(H);
                }
              } else {
                for (K = 0, rt = q.length; K < rt; K++)
                  xt = q[K], xt.onError && xt.onError(k);
                s.manager.itemError(t);
              }
              s.manager.itemEnd(t);
            },
            !1
          ), P.addEventListener(
            "progress",
            function(k) {
              for (var H = Lr[t], q = 0, K = H.length; q < K; q++) {
                var rt = H[q];
                rt.onProgress && rt.onProgress(k);
              }
            },
            !1
          ), P.addEventListener(
            "error",
            function(k) {
              var H = Lr[t];
              delete Lr[t];
              for (var q = 0, K = H.length; q < K; q++) {
                var rt = H[q];
                rt.onError && rt.onError(k);
              }
              s.manager.itemError(t), s.manager.itemEnd(t);
            },
            !1
          ), P.addEventListener(
            "abort",
            function(k) {
              var H = Lr[t];
              delete Lr[t];
              for (var q = 0, K = H.length; q < K; q++) {
                var rt = H[q];
                rt.onError && rt.onError(k);
              }
              s.manager.itemError(t), s.manager.itemEnd(t);
            },
            !1
          ), this.responseType !== void 0 && (P.responseType = this.responseType), this.withCredentials !== void 0 && (P.withCredentials = this.withCredentials), P.overrideMimeType && P.overrideMimeType(
            this.mimeType !== void 0 ? this.mimeType : "text/plain"
          );
          for (f in this.requestHeader)
            P.setRequestHeader(f, this.requestHeader[f]);
          P.send(null);
        }
        return s.manager.itemStart(t), P;
      }
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResponseType: function(t) {
      return this.responseType = t, this;
    },
    setWithCredentials: function(t) {
      return this.withCredentials = t, this;
    },
    setMimeType: function(t) {
      return this.mimeType = t, this;
    },
    setRequestHeader: function(t) {
      return this.requestHeader = t, this;
    }
  }), Object.assign(Qt.prototype, {
    load: function(t, e, i, n) {
      var s = this, a = new Lt(s.manager);
      a.setPath(s.path), a.load(
        t,
        function(c) {
          e(s.parse(JSON.parse(c)));
        },
        i,
        n
      );
    },
    parse: function(t, e) {
      for (var i = [], n = 0; n < t.length; n++) {
        var s = gr.parse(t[n]);
        i.push(s);
      }
      e(i);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Zt.prototype, {
    load: function(t, e, i, n) {
      function s(k) {
        v.load(
          t[k],
          function(H) {
            H = a._parser(H, !0), c[k] = {
              width: H.width,
              height: H.height,
              format: H.format,
              mipmaps: H.mipmaps
            }, y += 1, y === 6 && (H.mipmapCount === 1 && (f.minFilter = 1006), f.format = H.format, f.needsUpdate = !0, e && e(f));
          },
          i,
          n
        );
      }
      var a = this, c = [], f = new Gs();
      f.image = c;
      var v = new Lt(this.manager);
      if (v.setPath(this.path), v.setResponseType("arraybuffer"), Array.isArray(t))
        for (var y = 0, A = 0, P = t.length; A < P; ++A)
          s(A);
      else
        v.load(
          t,
          function(k) {
            if (k = a._parser(k, !0), k.isCubemap)
              for (var H = k.mipmaps.length / k.mipmapCount, q = 0; q < H; q++) {
                c[q] = { mipmaps: [] };
                for (var K = 0; K < k.mipmapCount; K++)
                  c[q].mipmaps.push(k.mipmaps[q * k.mipmapCount + K]), c[q].format = k.format, c[q].width = k.width, c[q].height = k.height;
              }
            else
              f.image.width = k.width, f.image.height = k.height, f.mipmaps = k.mipmaps;
            k.mipmapCount === 1 && (f.minFilter = 1006), f.format = k.format, f.needsUpdate = !0, e && e(f);
          },
          i,
          n
        );
      return f;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ue.prototype, {
    load: function(t, e, i, n) {
      var s = this, a = new z(), c = new Lt(this.manager);
      return c.setResponseType("arraybuffer"), c.setPath(this.path), c.load(
        t,
        function(f) {
          (f = s._parser(f)) && (f.image !== void 0 ? a.image = f.image : f.data !== void 0 && (a.image.width = f.width, a.image.height = f.height, a.image.data = f.data), a.wrapS = f.wrapS !== void 0 ? f.wrapS : 1001, a.wrapT = f.wrapT !== void 0 ? f.wrapT : 1001, a.magFilter = f.magFilter !== void 0 ? f.magFilter : 1006, a.minFilter = f.minFilter !== void 0 ? f.minFilter : 1008, a.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1, f.format !== void 0 && (a.format = f.format), f.type !== void 0 && (a.type = f.type), f.mipmaps !== void 0 && (a.mipmaps = f.mipmaps), f.mipmapCount === 1 && (a.minFilter = 1006), a.needsUpdate = !0, e && e(a, f));
        },
        i,
        n
      ), a;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(oi.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function s() {
        v.removeEventListener("load", s, !1), v.removeEventListener("error", a, !1), vs.add(t, this), e && e(this), c.manager.itemEnd(t);
      }
      function a(y) {
        v.removeEventListener("load", s, !1), v.removeEventListener("error", a, !1), n && n(y), c.manager.itemError(t), c.manager.itemEnd(t);
      }
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var c = this, f = vs.get(t);
      if (f !== void 0)
        return c.manager.itemStart(t), setTimeout(function() {
          e && e(f), c.manager.itemEnd(t);
        }, 0), f;
      var v = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      return v.addEventListener("load", s, !1), v.addEventListener("error", a, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (v.crossOrigin = this.crossOrigin), c.manager.itemStart(t), v.src = t, v;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(zi.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function s(v) {
        c.load(
          t[v],
          function(y) {
            a.images[v] = y, f++, f === 6 && (a.needsUpdate = !0, e && e(a));
          },
          void 0,
          n
        );
      }
      var a = new D(), c = new oi(this.manager);
      c.setCrossOrigin(this.crossOrigin), c.setPath(this.path);
      var f = 0;
      for (i = 0; i < t.length; ++i)
        s(i);
      return a;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(ln.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var s = new _(), a = new oi(this.manager);
      return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(
        t,
        function(c) {
          s.image = c, c = 0 < t.search(/\.jpe?g$/i) || t.search(/^data:image\/jpeg/) === 0, s.format = c ? 1022 : 1023, s.needsUpdate = !0, e !== void 0 && e(s);
        },
        i,
        n
      ), s;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ee.prototype, {
    getPoint: function() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    },
    getPointAt: function(t, e) {
      return t = this.getUtoTmapping(t), this.getPoint(t, e);
    },
    getPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return e;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPointAt(i / t));
      return e;
    },
    getLength: function() {
      var t = this.getLengths();
      return t[t.length - 1];
    },
    getLengths: function(t) {
      if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      var e = [], i = this.getPoint(0), n, s = 0;
      for (e.push(0), n = 1; n <= t; n++) {
        var a = this.getPoint(n / t);
        s += a.distanceTo(i), e.push(s), i = a;
      }
      return this.cacheArcLengths = e;
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.getLengths();
    },
    getUtoTmapping: function(t, e) {
      var i = this.getLengths(), n = i.length;
      e = e || t * i[n - 1];
      for (var s = 0, a = n - 1, c; s <= a; )
        if (t = Math.floor(s + (a - s) / 2), c = i[t] - e, 0 > c)
          s = t + 1;
        else if (0 < c)
          a = t - 1;
        else {
          a = t;
          break;
        }
      return t = a, i[t] === e ? t / (n - 1) : (s = i[t], (t + (e - s) / (i[t + 1] - s)) / (n - 1));
    },
    getTangent: function(t) {
      var e = t - 1e-4;
      return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize();
    },
    getTangentAt: function(t) {
      return t = this.getUtoTmapping(t), this.getTangent(t);
    },
    computeFrenetFrames: function(t, e) {
      var i = new u(), n = [], s = [], a = [], c = new u(), f = new p(), v;
      for (v = 0; v <= t; v++) {
        var y = v / t;
        n[v] = this.getTangentAt(y), n[v].normalize();
      }
      s[0] = new u(), a[0] = new u(), v = Number.MAX_VALUE, y = Math.abs(n[0].x);
      var A = Math.abs(n[0].y), P = Math.abs(n[0].z);
      for (y <= v && (v = y, i.set(1, 0, 0)), A <= v && (v = A, i.set(0, 1, 0)), P <= v && i.set(0, 0, 1), c.crossVectors(n[0], i).normalize(), s[0].crossVectors(n[0], c), a[0].crossVectors(n[0], s[0]), v = 1; v <= t; v++)
        s[v] = s[v - 1].clone(), a[v] = a[v - 1].clone(), c.crossVectors(n[v - 1], n[v]), c.length() > Number.EPSILON && (c.normalize(), i = Math.acos(fi.clamp(n[v - 1].dot(n[v]), -1, 1)), s[v].applyMatrix4(f.makeRotationAxis(c, i))), a[v].crossVectors(n[v], s[v]);
      if (e === !0)
        for (i = Math.acos(fi.clamp(s[0].dot(s[t]), -1, 1)), i /= t, 0 < n[0].dot(c.crossVectors(s[0], s[t])) && (i = -i), v = 1; v <= t; v++)
          s[v].applyMatrix4(f.makeRotationAxis(n[v], i * v)), a[v].crossVectors(n[v], s[v]);
      return { tangents: n, normals: s, binormals: a };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    },
    toJSON: function() {
      var t = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" }
      };
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    },
    fromJSON: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  }), Jn.prototype = Object.create(Ee.prototype), Jn.prototype.constructor = Jn, Jn.prototype.isEllipseCurve = !0, Jn.prototype.getPoint = function(t, e) {
    e = e || new o();
    for (var i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, s = Math.abs(n) < Number.EPSILON; 0 > n; )
      n += i;
    for (; n > i; )
      n -= i;
    n < Number.EPSILON && (n = s ? 0 : i), this.aClockwise !== !0 || s || (n = n === i ? -i : n - i), i = this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(i);
    var a = this.aY + this.yRadius * Math.sin(i);
    return this.aRotation !== 0 && (i = Math.cos(this.aRotation), n = Math.sin(this.aRotation), s = t - this.aX, a -= this.aY, t = s * i - a * n + this.aX, a = s * n + a * i + this.aY), e.set(t, a);
  }, Jn.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, Jn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }, Jn.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, ua.prototype = Object.create(Jn.prototype), ua.prototype.constructor = ua, ua.prototype.isArcCurve = !0;
  var Mn = new u(), hl = new nr(), jl = new nr(), Rr = new nr();
  Pn.prototype = Object.create(Ee.prototype), Pn.prototype.constructor = Pn, Pn.prototype.isCatmullRomCurve3 = !0, Pn.prototype.getPoint = function(t, e) {
    e = e || new u();
    var i = this.points, n = i.length;
    t *= n - (this.closed ? 0 : 1);
    var s = Math.floor(t);
    if (t -= s, this.closed ? s += 0 < s ? 0 : (Math.floor(Math.abs(s) / n) + 1) * n : t === 0 && s === n - 1 && (s = n - 2, t = 1), this.closed || 0 < s)
      var a = i[(s - 1) % n];
    else
      Mn.subVectors(i[0], i[1]).add(i[0]), a = Mn;
    var c = i[s % n], f = i[(s + 1) % n];
    if (this.closed || s + 2 < n ? i = i[(s + 2) % n] : (Mn.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Mn), this.curveType === "centripetal" || this.curveType === "chordal") {
      var v = this.curveType === "chordal" ? 0.5 : 0.25;
      n = Math.pow(a.distanceToSquared(c), v), s = Math.pow(c.distanceToSquared(f), v), v = Math.pow(f.distanceToSquared(i), v), 1e-4 > s && (s = 1), 1e-4 > n && (n = s), 1e-4 > v && (v = s), hl.initNonuniformCatmullRom(a.x, c.x, f.x, i.x, n, s, v), jl.initNonuniformCatmullRom(a.y, c.y, f.y, i.y, n, s, v), Rr.initNonuniformCatmullRom(a.z, c.z, f.z, i.z, n, s, v);
    } else
      this.curveType === "catmullrom" && (hl.initCatmullRom(a.x, c.x, f.x, i.x, this.tension), jl.initCatmullRom(a.y, c.y, f.y, i.y, this.tension), Rr.initCatmullRom(a.z, c.z, f.z, i.z, this.tension));
    return e.set(hl.calc(t), jl.calc(t), Rr.calc(t)), e;
  }, Pn.prototype.copy = function(t) {
    Ee.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, Pn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }, Pn.prototype.fromJSON = function(t) {
    Ee.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new u().fromArray(n));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, rr.prototype = Object.create(Ee.prototype), rr.prototype.constructor = rr, rr.prototype.isCubicBezierCurve = !0, rr.prototype.getPoint = function(t, e) {
    e = e || new o();
    var i = this.v0, n = this.v1, s = this.v2, a = this.v3;
    return e.set(Zs(t, i.x, n.x, s.x, a.x), Zs(t, i.y, n.y, s.y, a.y)), e;
  }, rr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, rr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, rr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, wi.prototype = Object.create(Ee.prototype), wi.prototype.constructor = wi, wi.prototype.isCubicBezierCurve3 = !0, wi.prototype.getPoint = function(t, e) {
    e = e || new u();
    var i = this.v0, n = this.v1, s = this.v2, a = this.v3;
    return e.set(
      Zs(t, i.x, n.x, s.x, a.x),
      Zs(t, i.y, n.y, s.y, a.y),
      Zs(t, i.z, n.z, s.z, a.z)
    ), e;
  }, wi.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, wi.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, wi.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, sr.prototype = Object.create(Ee.prototype), sr.prototype.constructor = sr, sr.prototype.isLineCurve = !0, sr.prototype.getPoint = function(t, e) {
    return e = e || new o(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, sr.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, sr.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
  }, sr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, sr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, sr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Cr.prototype = Object.create(Ee.prototype), Cr.prototype.constructor = Cr, Cr.prototype.isLineCurve3 = !0, Cr.prototype.getPoint = function(t, e) {
    return e = e || new u(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, Cr.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, Cr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Cr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Cr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, or.prototype = Object.create(Ee.prototype), or.prototype.constructor = or, or.prototype.isQuadraticBezierCurve = !0, or.prototype.getPoint = function(t, e) {
    e = e || new o();
    var i = this.v0, n = this.v1, s = this.v2;
    return e.set(cs(t, i.x, n.x, s.x), cs(t, i.y, n.y, s.y)), e;
  }, or.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, or.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, or.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, fs.prototype = Object.create(Ee.prototype), fs.prototype.constructor = fs, fs.prototype.isQuadraticBezierCurve3 = !0, fs.prototype.getPoint = function(t, e) {
    e = e || new u();
    var i = this.v0, n = this.v1, s = this.v2;
    return e.set(cs(t, i.x, n.x, s.x), cs(t, i.y, n.y, s.y), cs(t, i.z, n.z, s.z)), e;
  }, fs.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, fs.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, fs.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Xr.prototype = Object.create(Ee.prototype), Xr.prototype.constructor = Xr, Xr.prototype.isSplineCurve = !0, Xr.prototype.getPoint = function(t, e) {
    e = e || new o();
    var i = this.points, n = (i.length - 1) * t;
    t = Math.floor(n), n -= t;
    var s = i[t === 0 ? t : t - 1], a = i[t], c = i[t > i.length - 2 ? i.length - 1 : t + 1];
    return i = i[t > i.length - 3 ? i.length - 1 : t + 2], e.set(su(n, s.x, a.x, c.x, i.x), su(n, s.y, a.y, c.y, i.y)), e;
  }, Xr.prototype.copy = function(t) {
    Ee.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this;
  }, Xr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t;
  }, Xr.prototype.fromJSON = function(t) {
    Ee.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new o().fromArray(n));
    }
    return this;
  };
  var Xl = Object.freeze({
    ArcCurve: ua,
    CatmullRomCurve3: Pn,
    CubicBezierCurve: rr,
    CubicBezierCurve3: wi,
    EllipseCurve: Jn,
    LineCurve: sr,
    LineCurve3: Cr,
    QuadraticBezierCurve: or,
    QuadraticBezierCurve3: fs,
    SplineCurve: Xr
  });
  Rs.prototype = Object.assign(Object.create(Ee.prototype), {
    constructor: Rs,
    add: function(t) {
      this.curves.push(t);
    },
    closePath: function() {
      var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new sr(e, t));
    },
    getPoint: function(t) {
      var e = t * this.getLength(), i = this.getCurveLengths();
      for (t = 0; t < i.length; ) {
        if (i[t] >= e)
          return e = i[t] - e, t = this.curves[t], i = t.getLength(), t.getPointAt(i === 0 ? 0 : 1 - e / i);
        t++;
      }
      return null;
    },
    getLength: function() {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
        e += this.curves[i].getLength(), t.push(e);
      return this.cacheLengths = t;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 40);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]), e;
    },
    getPoints: function(t) {
      t = t || 12;
      for (var e = [], i, n = 0, s = this.curves; n < s.length; n++) {
        var a = s[n];
        a = a.getPoints(
          a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t
        );
        for (var c = 0; c < a.length; c++) {
          var f = a[c];
          i && i.equals(f) || (e.push(f), i = f);
        }
      }
      return this.autoClose && 1 < e.length && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
    },
    copy: function(t) {
      Ee.prototype.copy.call(this, t), this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++)
        this.curves.push(t.curves[e].clone());
      return this.autoClose = t.autoClose, this;
    },
    toJSON: function() {
      var t = Ee.prototype.toJSON.call(this);
      t.autoClose = this.autoClose, t.curves = [];
      for (var e = 0, i = this.curves.length; e < i; e++)
        t.curves.push(this.curves[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      Ee.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var n = t.curves[e];
        this.curves.push(new Xl[n.type]().fromJSON(n));
      }
      return this;
    }
  }), ar.prototype = Object.assign(Object.create(Rs.prototype), {
    constructor: ar,
    setFromPoints: function(t) {
      this.moveTo(t[0].x, t[0].y);
      for (var e = 1, i = t.length; e < i; e++)
        this.lineTo(t[e].x, t[e].y);
    },
    moveTo: function(t, e) {
      this.currentPoint.set(t, e);
    },
    lineTo: function(t, e) {
      var i = new sr(this.currentPoint.clone(), new o(t, e));
      this.curves.push(i), this.currentPoint.set(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      t = new or(this.currentPoint.clone(), new o(t, e), new o(i, n)), this.curves.push(t), this.currentPoint.set(i, n);
    },
    bezierCurveTo: function(t, e, i, n, s, a) {
      t = new rr(
        this.currentPoint.clone(),
        new o(t, e),
        new o(i, n),
        new o(s, a)
      ), this.curves.push(t), this.currentPoint.set(s, a);
    },
    splineThru: function(t) {
      var e = [this.currentPoint.clone()].concat(t);
      e = new Xr(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
    },
    arc: function(t, e, i, n, s, a) {
      this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, s, a);
    },
    absarc: function(t, e, i, n, s, a) {
      this.absellipse(t, e, i, i, n, s, a);
    },
    ellipse: function(t, e, i, n, s, a, c, f) {
      this.absellipse(
        t + this.currentPoint.x,
        e + this.currentPoint.y,
        i,
        n,
        s,
        a,
        c,
        f
      );
    },
    absellipse: function(t, e, i, n, s, a, c, f) {
      t = new Jn(t, e, i, n, s, a, c, f), 0 < this.curves.length && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t);
    },
    copy: function(t) {
      return Rs.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
    },
    toJSON: function() {
      var t = Rs.prototype.toJSON.call(this);
      return t.currentPoint = this.currentPoint.toArray(), t;
    },
    fromJSON: function(t) {
      return Rs.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
    }
  }), $n.prototype = Object.assign(Object.create(ar.prototype), {
    constructor: $n,
    getPointsHoles: function(t) {
      for (var e = [], i = 0, n = this.holes.length; i < n; i++)
        e[i] = this.holes[i].getPoints(t);
      return e;
    },
    extractPoints: function(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    },
    copy: function(t) {
      ar.prototype.copy.call(this, t), this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++)
        this.holes.push(t.holes[e].clone());
      return this;
    },
    toJSON: function() {
      var t = ar.prototype.toJSON.call(this);
      t.uuid = this.uuid, t.holes = [];
      for (var e = 0, i = this.holes.length; e < i; e++)
        t.holes.push(this.holes[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      ar.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++) {
        var n = t.holes[e];
        this.holes.push(new ar().fromJSON(n));
      }
      return this;
    }
  }), $i.prototype = Object.assign(Object.create(N.prototype), {
    constructor: $i,
    isLight: !0,
    copy: function(t) {
      return N.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
    },
    toJSON: function(t) {
      return t = N.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
  }), qa.prototype = Object.assign(Object.create($i.prototype), {
    constructor: qa,
    isHemisphereLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    }
  }), Object.assign(ps.prototype, {
    copy: function(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var t = {};
      return this.bias !== 0 && (t.bias = this.bias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
  }), Ya.prototype = Object.assign(Object.create(ps.prototype), {
    constructor: Ya,
    isSpotLightShadow: !0,
    update: function(t) {
      var e = this.camera, i = 2 * fi.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height;
      t = t.distance || e.far, (i !== e.fov || n !== e.aspect || t !== e.far) && (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix());
    }
  }), Za.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Za,
    isSpotLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), Ao.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Ao,
    isPointLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }), ca.prototype = Object.assign(Object.create(Be.prototype), {
    constructor: ca,
    isOrthographicCamera: !0,
    copy: function(t, e) {
      return Be.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
    },
    setViewOffset: function(t, e, i, n, s, a) {
      this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, s = i - t;
      if (i += t, t = n + e, e = n - e, this.view !== null && this.view.enabled) {
        i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight);
        var a = (this.right - this.left) / this.view.width;
        n = (this.top - this.bottom) / this.view.height, s += this.view.offsetX / i * a, i = s + this.view.width / i * a, t -= this.view.offsetY / e * n, e = t - this.view.height / e * n;
      }
      this.projectionMatrix.makeOrthographic(s, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = N.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }), Js.prototype = Object.assign(Object.create(ps.prototype), {
    constructor: Js
  }), ds.prototype = Object.assign(Object.create($i.prototype), {
    constructor: ds,
    isDirectionalLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), Co.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Co,
    isAmbientLight: !0
  }), Nl.prototype = Object.assign(Object.create($i.prototype), {
    constructor: Nl,
    isRectAreaLight: !0,
    copy: function(t) {
      return $i.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
    },
    toJSON: function(t) {
      return t = $i.prototype.toJSON.call(this, t), t.object.width = this.width, t.object.height = this.height, t;
    }
  }), Object.assign(Fl.prototype, {
    load: function(t, e, i, n) {
      var s = this, a = new Lt(s.manager);
      a.setPath(s.path), a.load(
        t,
        function(c) {
          e(s.parse(JSON.parse(c)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      function e(c) {
        return i[c] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", c), i[c];
      }
      var i = this.textures, n = new mu[t.type]();
      if (t.uuid !== void 0 && (n.uuid = t.uuid), t.name !== void 0 && (n.name = t.name), t.color !== void 0 && n.color.setHex(t.color), t.roughness !== void 0 && (n.roughness = t.roughness), t.metalness !== void 0 && (n.metalness = t.metalness), t.emissive !== void 0 && n.emissive.setHex(t.emissive), t.specular !== void 0 && n.specular.setHex(t.specular), t.shininess !== void 0 && (n.shininess = t.shininess), t.clearCoat !== void 0 && (n.clearCoat = t.clearCoat), t.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = t.clearCoatRoughness), t.vertexColors !== void 0 && (n.vertexColors = t.vertexColors), t.fog !== void 0 && (n.fog = t.fog), t.flatShading !== void 0 && (n.flatShading = t.flatShading), t.blending !== void 0 && (n.blending = t.blending), t.combine !== void 0 && (n.combine = t.combine), t.side !== void 0 && (n.side = t.side), t.opacity !== void 0 && (n.opacity = t.opacity), t.transparent !== void 0 && (n.transparent = t.transparent), t.alphaTest !== void 0 && (n.alphaTest = t.alphaTest), t.depthTest !== void 0 && (n.depthTest = t.depthTest), t.depthWrite !== void 0 && (n.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (n.colorWrite = t.colorWrite), t.wireframe !== void 0 && (n.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (n.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (n.rotation = t.rotation), t.linewidth !== 1 && (n.linewidth = t.linewidth), t.dashSize !== void 0 && (n.dashSize = t.dashSize), t.gapSize !== void 0 && (n.gapSize = t.gapSize), t.scale !== void 0 && (n.scale = t.scale), t.polygonOffset !== void 0 && (n.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (n.skinning = t.skinning), t.morphTargets !== void 0 && (n.morphTargets = t.morphTargets), t.dithering !== void 0 && (n.dithering = t.dithering), t.visible !== void 0 && (n.visible = t.visible), t.userData !== void 0 && (n.userData = t.userData), t.uniforms !== void 0)
        for (var s in t.uniforms) {
          var a = t.uniforms[s];
          switch (n.uniforms[s] = {}, a.type) {
            case "t":
              n.uniforms[s].value = e(a.value);
              break;
            case "c":
              n.uniforms[s].value = new L().setHex(a.value);
              break;
            case "v2":
              n.uniforms[s].value = new o().fromArray(a.value);
              break;
            case "v3":
              n.uniforms[s].value = new u().fromArray(a.value);
              break;
            case "v4":
              n.uniforms[s].value = new T().fromArray(a.value);
              break;
            case "m4":
              n.uniforms[s].value = new p().fromArray(a.value);
              break;
            default:
              n.uniforms[s].value = a.value;
          }
        }
      return t.defines !== void 0 && (n.defines = t.defines), t.vertexShader !== void 0 && (n.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (n.fragmentShader = t.fragmentShader), t.shading !== void 0 && (n.flatShading = t.shading === 1), t.size !== void 0 && (n.size = t.size), t.sizeAttenuation !== void 0 && (n.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (n.map = e(t.map)), t.alphaMap !== void 0 && (n.alphaMap = e(t.alphaMap), n.transparent = !0), t.bumpMap !== void 0 && (n.bumpMap = e(t.bumpMap)), t.bumpScale !== void 0 && (n.bumpScale = t.bumpScale), t.normalMap !== void 0 && (n.normalMap = e(t.normalMap)), t.normalMapType !== void 0 && (n.normalMapType = t.normalMapType), t.normalScale !== void 0 && (s = t.normalScale, Array.isArray(s) === !1 && (s = [s, s]), n.normalScale = new o().fromArray(s)), t.displacementMap !== void 0 && (n.displacementMap = e(t.displacementMap)), t.displacementScale !== void 0 && (n.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (n.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (n.roughnessMap = e(t.roughnessMap)), t.metalnessMap !== void 0 && (n.metalnessMap = e(t.metalnessMap)), t.emissiveMap !== void 0 && (n.emissiveMap = e(t.emissiveMap)), t.emissiveIntensity !== void 0 && (n.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (n.specularMap = e(t.specularMap)), t.envMap !== void 0 && (n.envMap = e(t.envMap)), t.envMapIntensity !== void 0 && (n.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (n.reflectivity = t.reflectivity), t.lightMap !== void 0 && (n.lightMap = e(t.lightMap)), t.lightMapIntensity !== void 0 && (n.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (n.aoMap = e(t.aoMap)), t.aoMapIntensity !== void 0 && (n.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (n.gradientMap = e(t.gradientMap)), n;
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setTextures: function(t) {
      return this.textures = t, this;
    }
  });
  var Do = {
    decodeText: function(t) {
      if (typeof TextDecoder < "u")
        return new TextDecoder().decode(t);
      for (var e = "", i = 0, n = t.length; i < n; i++)
        e += String.fromCharCode(t[i]);
      return decodeURIComponent(escape(e));
    },
    extractUrlBase: function(t) {
      var e = t.lastIndexOf("/");
      return e === -1 ? "./" : t.substr(0, e + 1);
    }
  };
  Object.assign(vh.prototype, {
    load: function(t, e, i, n) {
      var s = this, a = new Lt(s.manager);
      a.setPath(s.path), a.load(
        t,
        function(c) {
          e(s.parse(JSON.parse(c)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      var e = new Ft(), i = t.data.index;
      i !== void 0 && (i = new eo[i.type](i.array), e.setIndex(new J(i, 1)));
      var n = t.data.attributes;
      for (a in n) {
        var s = n[a];
        i = new eo[s.type](s.array), e.addAttribute(a, new J(i, s.itemSize, s.normalized));
      }
      var a = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (a !== void 0)
        for (i = 0, n = a.length; i !== n; ++i)
          s = a[i], e.addGroup(s.start, s.count, s.materialIndex);
      return t = t.data.boundingSphere, t !== void 0 && (a = new u(), t.center !== void 0 && a.fromArray(t.center), e.boundingSphere = new I(a, t.radius)), e;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var eo = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  Os.Handlers = {
    handlers: [],
    add: function(t, e) {
      this.handlers.push(t, e);
    },
    get: function(t) {
      for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
        var s = e[i + 1];
        if (e[i].test(t))
          return s;
      }
      return null;
    }
  }, Object.assign(Os.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {
    },
    onLoadProgress: function() {
    },
    onLoadComplete: function() {
    },
    initMaterials: function(t, e, i) {
      for (var n = [], s = 0; s < t.length; ++s)
        n[s] = this.createMaterial(t[s], e, i);
      return n;
    },
    createMaterial: function() {
      var t = {
        NoBlending: 0,
        NormalBlending: 1,
        AdditiveBlending: 2,
        SubtractiveBlending: 3,
        MultiplyBlending: 4,
        CustomBlending: 5
      }, e = new L(), i = new ln(), n = new Fl();
      return function(s, a, c) {
        function f(k, H, q, K, rt) {
          k = a + k;
          var xt = Os.Handlers.get(k);
          return xt !== null ? k = xt.load(k) : (i.setCrossOrigin(c), k = i.load(k)), H !== void 0 && (k.repeat.fromArray(H), H[0] !== 1 && (k.wrapS = 1e3), H[1] !== 1 && (k.wrapT = 1e3)), q !== void 0 && k.offset.fromArray(q), K !== void 0 && (K[0] === "repeat" && (k.wrapS = 1e3), K[0] === "mirror" && (k.wrapS = 1002), K[1] === "repeat" && (k.wrapT = 1e3), K[1] === "mirror" && (k.wrapT = 1002)), rt !== void 0 && (k.anisotropy = rt), H = fi.generateUUID(), v[H] = k, H;
        }
        var v = {}, y = { uuid: fi.generateUUID(), type: "MeshLambertMaterial" }, A;
        for (A in s) {
          var P = s[A];
          switch (A) {
            case "DbgColor":
            case "DbgIndex":
            case "opticalDensity":
            case "illumination":
              break;
            case "DbgName":
              y.name = P;
              break;
            case "blending":
              y.blending = t[P];
              break;
            case "colorAmbient":
            case "mapAmbient":
              console.warn(
                "THREE.Loader.createMaterial:",
                A,
                "is no longer supported."
              );
              break;
            case "colorDiffuse":
              y.color = e.fromArray(P).getHex();
              break;
            case "colorSpecular":
              y.specular = e.fromArray(P).getHex();
              break;
            case "colorEmissive":
              y.emissive = e.fromArray(P).getHex();
              break;
            case "specularCoef":
              y.shininess = P;
              break;
            case "shading":
              P.toLowerCase() === "basic" && (y.type = "MeshBasicMaterial"), P.toLowerCase() === "phong" && (y.type = "MeshPhongMaterial"), P.toLowerCase() === "standard" && (y.type = "MeshStandardMaterial");
              break;
            case "mapDiffuse":
              y.map = f(
                P,
                s.mapDiffuseRepeat,
                s.mapDiffuseOffset,
                s.mapDiffuseWrap,
                s.mapDiffuseAnisotropy
              );
              break;
            case "mapDiffuseRepeat":
            case "mapDiffuseOffset":
            case "mapDiffuseWrap":
            case "mapDiffuseAnisotropy":
              break;
            case "mapEmissive":
              y.emissiveMap = f(
                P,
                s.mapEmissiveRepeat,
                s.mapEmissiveOffset,
                s.mapEmissiveWrap,
                s.mapEmissiveAnisotropy
              );
              break;
            case "mapEmissiveRepeat":
            case "mapEmissiveOffset":
            case "mapEmissiveWrap":
            case "mapEmissiveAnisotropy":
              break;
            case "mapLight":
              y.lightMap = f(
                P,
                s.mapLightRepeat,
                s.mapLightOffset,
                s.mapLightWrap,
                s.mapLightAnisotropy
              );
              break;
            case "mapLightRepeat":
            case "mapLightOffset":
            case "mapLightWrap":
            case "mapLightAnisotropy":
              break;
            case "mapAO":
              y.aoMap = f(
                P,
                s.mapAORepeat,
                s.mapAOOffset,
                s.mapAOWrap,
                s.mapAOAnisotropy
              );
              break;
            case "mapAORepeat":
            case "mapAOOffset":
            case "mapAOWrap":
            case "mapAOAnisotropy":
              break;
            case "mapBump":
              y.bumpMap = f(
                P,
                s.mapBumpRepeat,
                s.mapBumpOffset,
                s.mapBumpWrap,
                s.mapBumpAnisotropy
              );
              break;
            case "mapBumpScale":
              y.bumpScale = P;
              break;
            case "mapBumpRepeat":
            case "mapBumpOffset":
            case "mapBumpWrap":
            case "mapBumpAnisotropy":
              break;
            case "mapNormal":
              y.normalMap = f(
                P,
                s.mapNormalRepeat,
                s.mapNormalOffset,
                s.mapNormalWrap,
                s.mapNormalAnisotropy
              );
              break;
            case "mapNormalFactor":
              y.normalScale = P;
              break;
            case "mapNormalRepeat":
            case "mapNormalOffset":
            case "mapNormalWrap":
            case "mapNormalAnisotropy":
              break;
            case "mapSpecular":
              y.specularMap = f(
                P,
                s.mapSpecularRepeat,
                s.mapSpecularOffset,
                s.mapSpecularWrap,
                s.mapSpecularAnisotropy
              );
              break;
            case "mapSpecularRepeat":
            case "mapSpecularOffset":
            case "mapSpecularWrap":
            case "mapSpecularAnisotropy":
              break;
            case "mapMetalness":
              y.metalnessMap = f(
                P,
                s.mapMetalnessRepeat,
                s.mapMetalnessOffset,
                s.mapMetalnessWrap,
                s.mapMetalnessAnisotropy
              );
              break;
            case "mapMetalnessRepeat":
            case "mapMetalnessOffset":
            case "mapMetalnessWrap":
            case "mapMetalnessAnisotropy":
              break;
            case "mapRoughness":
              y.roughnessMap = f(
                P,
                s.mapRoughnessRepeat,
                s.mapRoughnessOffset,
                s.mapRoughnessWrap,
                s.mapRoughnessAnisotropy
              );
              break;
            case "mapRoughnessRepeat":
            case "mapRoughnessOffset":
            case "mapRoughnessWrap":
            case "mapRoughnessAnisotropy":
              break;
            case "mapAlpha":
              y.alphaMap = f(
                P,
                s.mapAlphaRepeat,
                s.mapAlphaOffset,
                s.mapAlphaWrap,
                s.mapAlphaAnisotropy
              );
              break;
            case "mapAlphaRepeat":
            case "mapAlphaOffset":
            case "mapAlphaWrap":
            case "mapAlphaAnisotropy":
              break;
            case "flipSided":
              y.side = 1;
              break;
            case "doubleSided":
              y.side = 2;
              break;
            case "transparency":
              console.warn(
                "THREE.Loader.createMaterial: transparency has been renamed to opacity"
              ), y.opacity = P;
              break;
            case "depthTest":
            case "depthWrite":
            case "colorWrite":
            case "opacity":
            case "reflectivity":
            case "transparent":
            case "visible":
            case "wireframe":
              y[A] = P;
              break;
            case "vertexColors":
              P === !0 && (y.vertexColors = 2), P === "face" && (y.vertexColors = 1);
              break;
            default:
              console.error("THREE.Loader.createMaterial: Unsupported", A, P);
          }
        }
        return y.type === "MeshBasicMaterial" && delete y.emissive, y.type !== "MeshPhongMaterial" && delete y.specular, 1 > y.opacity && (y.transparent = !0), n.setTextures(v), n.parse(y);
      };
    }()
  }), Object.assign(Po.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var s = this, a = this.path === void 0 ? Do.extractUrlBase(t) : this.path, c = new Lt(this.manager);
      c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
        t,
        function(f) {
          f = JSON.parse(f);
          var v = f.metadata;
          if (v !== void 0 && (v = v.type, v !== void 0 && v.toLowerCase() === "object")) {
            console.error(
              "THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead."
            );
            return;
          }
          f = s.parse(f, a), e(f.geometry, f.materials);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function() {
      return function(t, e) {
        t.data !== void 0 && (t = t.data), t.scale = t.scale !== void 0 ? 1 / t.scale : 1;
        var i = new j(), n = t, s, a, c, f = n.faces, v = n.vertices, y = n.normals, A = n.colors, P = n.scale, k = 0;
        if (n.uvs !== void 0) {
          for (s = 0; s < n.uvs.length; s++)
            n.uvs[s].length && k++;
          for (s = 0; s < k; s++)
            i.faceVertexUvs[s] = [];
        }
        var H = 0;
        for (c = v.length; H < c; )
          s = new u(), s.x = v[H++] * P, s.y = v[H++] * P, s.z = v[H++] * P, i.vertices.push(s);
        for (H = 0, c = f.length; H < c; ) {
          v = f[H++];
          var q = v & 1, K = v & 2;
          s = v & 8;
          var rt = v & 16, xt = v & 32;
          if (P = v & 64, v &= 128, q) {
            q = new R(), q.a = f[H], q.b = f[H + 1], q.c = f[H + 3];
            var gt = new R();
            if (gt.a = f[H + 1], gt.b = f[H + 2], gt.c = f[H + 3], H += 4, K && (K = f[H++], q.materialIndex = K, gt.materialIndex = K), K = i.faces.length, s)
              for (s = 0; s < k; s++) {
                var At = n.uvs[s];
                for (i.faceVertexUvs[s][K] = [], i.faceVertexUvs[s][K + 1] = [], a = 0; 4 > a; a++) {
                  var wt = f[H++], Vt = At[2 * wt];
                  wt = At[2 * wt + 1], Vt = new o(Vt, wt), a !== 2 && i.faceVertexUvs[s][K].push(Vt), a !== 0 && i.faceVertexUvs[s][K + 1].push(Vt);
                }
              }
            if (rt && (rt = 3 * f[H++], q.normal.set(y[rt++], y[rt++], y[rt]), gt.normal.copy(q.normal)), xt)
              for (s = 0; 4 > s; s++)
                rt = 3 * f[H++], xt = new u(y[rt++], y[rt++], y[rt]), s !== 2 && q.vertexNormals.push(xt), s !== 0 && gt.vertexNormals.push(xt);
            if (P && (P = f[H++], P = A[P], q.color.setHex(P), gt.color.setHex(P)), v)
              for (s = 0; 4 > s; s++)
                P = f[H++], P = A[P], s !== 2 && q.vertexColors.push(new L(P)), s !== 0 && gt.vertexColors.push(new L(P));
            i.faces.push(q), i.faces.push(gt);
          } else {
            if (q = new R(), q.a = f[H++], q.b = f[H++], q.c = f[H++], K && (K = f[H++], q.materialIndex = K), K = i.faces.length, s)
              for (s = 0; s < k; s++)
                for (At = n.uvs[s], i.faceVertexUvs[s][K] = [], a = 0; 3 > a; a++)
                  wt = f[H++], Vt = At[2 * wt], wt = At[2 * wt + 1], Vt = new o(Vt, wt), i.faceVertexUvs[s][K].push(Vt);
            if (rt && (rt = 3 * f[H++], q.normal.set(y[rt++], y[rt++], y[rt])), xt)
              for (s = 0; 3 > s; s++)
                rt = 3 * f[H++], xt = new u(y[rt++], y[rt++], y[rt]), q.vertexNormals.push(xt);
            if (P && (P = f[H++], q.color.setHex(A[P])), v)
              for (s = 0; 3 > s; s++)
                P = f[H++], q.vertexColors.push(new L(A[P]));
            i.faces.push(q);
          }
        }
        if (n = t, H = n.influencesPerVertex !== void 0 ? n.influencesPerVertex : 2, n.skinWeights)
          for (c = 0, f = n.skinWeights.length; c < f; c += H)
            i.skinWeights.push(
              new T(
                n.skinWeights[c],
                1 < H ? n.skinWeights[c + 1] : 0,
                2 < H ? n.skinWeights[c + 2] : 0,
                3 < H ? n.skinWeights[c + 3] : 0
              )
            );
        if (n.skinIndices)
          for (c = 0, f = n.skinIndices.length; c < f; c += H)
            i.skinIndices.push(
              new T(
                n.skinIndices[c],
                1 < H ? n.skinIndices[c + 1] : 0,
                2 < H ? n.skinIndices[c + 2] : 0,
                3 < H ? n.skinIndices[c + 3] : 0
              )
            );
        if (i.bones = n.bones, i.bones && 0 < i.bones.length && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && console.warn(
          "When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match."
        ), c = t, f = c.scale, c.morphTargets !== void 0)
          for (n = 0, H = c.morphTargets.length; n < H; n++)
            for (i.morphTargets[n] = {}, i.morphTargets[n].name = c.morphTargets[n].name, i.morphTargets[n].vertices = [], y = i.morphTargets[n].vertices, A = c.morphTargets[n].vertices, k = 0, v = A.length; k < v; k += 3)
              P = new u(), P.x = A[k] * f, P.y = A[k + 1] * f, P.z = A[k + 2] * f, y.push(P);
        if (c.morphColors !== void 0 && 0 < c.morphColors.length)
          for (console.warn(
            'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
          ), f = i.faces, c = c.morphColors[0].colors, n = 0, H = f.length; n < H; n++)
            f[n].color.fromArray(c, 3 * n);
        for (c = t, n = [], H = [], c.animation !== void 0 && H.push(c.animation), c.animations !== void 0 && (c.animations.length ? H = H.concat(c.animations) : H.push(c.animations)), c = 0; c < H.length; c++)
          (f = gr.parseAnimation(H[c], i.bones)) && n.push(f);
        return i.morphTargets && (H = gr.CreateClipsFromMorphTargetSequences(i.morphTargets, 10), n = n.concat(H)), 0 < n.length && (i.animations = n), i.computeFaceNormals(), i.computeBoundingSphere(), t.materials === void 0 || t.materials.length === 0 ? { geometry: i } : (t = Os.prototype.initMaterials(
          t.materials,
          this.resourcePath || e,
          this.crossOrigin
        ), { geometry: i, materials: t });
      };
    }()
  }), Object.assign(Ja.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var s = this, a = this.path === void 0 ? Do.extractUrlBase(t) : this.path;
      this.resourcePath = this.resourcePath || a, a = new Lt(s.manager), a.setPath(this.path), a.load(
        t,
        function(c) {
          var f = null;
          try {
            f = JSON.parse(c);
          } catch (v) {
            n !== void 0 && n(v), console.error(
              "THREE:ObjectLoader: Can't parse " + t + ".",
              v.message
            );
            return;
          }
          c = f.metadata, c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry" ? console.error(
            "THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead."
          ) : s.parse(f, e);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function(t, e) {
      var i = this.parseShape(t.shapes);
      i = this.parseGeometries(t.geometries, i);
      var n = this.parseImages(t.images, function() {
        e !== void 0 && e(s);
      });
      n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n);
      var s = this.parseObject(t.object, i, n);
      return t.animations && (s.animations = this.parseAnimations(t.animations)), t.images !== void 0 && t.images.length !== 0 || e === void 0 || e(s), s;
    },
    parseShape: function(t) {
      var e = {};
      if (t !== void 0)
        for (var i = 0, n = t.length; i < n; i++) {
          var s = new $n().fromJSON(t[i]);
          e[s.uuid] = s;
        }
      return e;
    },
    parseGeometries: function(t, e) {
      var i = {};
      if (t !== void 0)
        for (var n = new Po(), s = new vh(), a = 0, c = t.length; a < c; a++) {
          var f = t[a];
          switch (f.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              var v = new dn[f.type](
                f.width,
                f.height,
                f.widthSegments,
                f.heightSegments
              );
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
              v = new dn[f.type](
                f.width,
                f.height,
                f.depth,
                f.widthSegments,
                f.heightSegments,
                f.depthSegments
              );
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              v = new dn[f.type](
                f.radius,
                f.segments,
                f.thetaStart,
                f.thetaLength
              );
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              v = new dn[f.type](
                f.radiusTop,
                f.radiusBottom,
                f.height,
                f.radialSegments,
                f.heightSegments,
                f.openEnded,
                f.thetaStart,
                f.thetaLength
              );
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              v = new dn[f.type](
                f.radius,
                f.height,
                f.radialSegments,
                f.heightSegments,
                f.openEnded,
                f.thetaStart,
                f.thetaLength
              );
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              v = new dn[f.type](
                f.radius,
                f.widthSegments,
                f.heightSegments,
                f.phiStart,
                f.phiLength,
                f.thetaStart,
                f.thetaLength
              );
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              v = new dn[f.type](f.radius, f.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              v = new dn[f.type](
                f.innerRadius,
                f.outerRadius,
                f.thetaSegments,
                f.phiSegments,
                f.thetaStart,
                f.thetaLength
              );
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              v = new dn[f.type](
                f.radius,
                f.tube,
                f.radialSegments,
                f.tubularSegments,
                f.arc
              );
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              v = new dn[f.type](
                f.radius,
                f.tube,
                f.tubularSegments,
                f.radialSegments,
                f.p,
                f.q
              );
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              v = new dn[f.type](f.points, f.segments, f.phiStart, f.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              v = new dn[f.type](f.vertices, f.indices, f.radius, f.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              v = [];
              for (var y = 0, A = f.shapes.length; y < A; y++) {
                var P = e[f.shapes[y]];
                v.push(P);
              }
              v = new dn[f.type](v, f.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              for (v = [], y = 0, A = f.shapes.length; y < A; y++)
                P = e[f.shapes[y]], v.push(P);
              y = f.options.extrudePath, y !== void 0 && (f.options.extrudePath = new Xl[y.type]().fromJSON(y)), v = new dn[f.type](v, f.options);
              break;
            case "BufferGeometry":
              v = s.parse(f);
              break;
            case "Geometry":
              v = n.parse(f, this.resourcePath).geometry;
              break;
            default:
              console.warn(
                'THREE.ObjectLoader: Unsupported geometry type "' + f.type + '"'
              );
              continue;
          }
          v.uuid = f.uuid, f.name !== void 0 && (v.name = f.name), v.isBufferGeometry === !0 && f.userData !== void 0 && (v.userData = f.userData), i[f.uuid] = v;
        }
      return i;
    },
    parseMaterials: function(t, e) {
      var i = {}, n = {};
      if (t !== void 0) {
        var s = new Fl();
        s.setTextures(e), e = 0;
        for (var a = t.length; e < a; e++) {
          var c = t[e];
          if (c.type === "MultiMaterial") {
            for (var f = [], v = 0; v < c.materials.length; v++) {
              var y = c.materials[v];
              i[y.uuid] === void 0 && (i[y.uuid] = s.parse(y)), f.push(i[y.uuid]);
            }
            n[c.uuid] = f;
          } else
            n[c.uuid] = s.parse(c), i[c.uuid] = n[c.uuid];
        }
      }
      return n;
    },
    parseAnimations: function(t) {
      for (var e = [], i = 0; i < t.length; i++) {
        var n = t[i], s = gr.parse(n);
        n.uuid !== void 0 && (s.uuid = n.uuid), e.push(s);
      }
      return e;
    },
    parseImages: function(t, e) {
      function i(k) {
        return n.manager.itemStart(k), a.load(
          k,
          function() {
            n.manager.itemEnd(k);
          },
          void 0,
          function() {
            n.manager.itemError(k), n.manager.itemEnd(k);
          }
        );
      }
      var n = this, s = {};
      if (t !== void 0 && 0 < t.length) {
        e = new Ys(e);
        var a = new oi(e);
        a.setCrossOrigin(this.crossOrigin), e = 0;
        for (var c = t.length; e < c; e++) {
          var f = t[e], v = f.url;
          if (Array.isArray(v)) {
            s[f.uuid] = [];
            for (var y = 0, A = v.length; y < A; y++) {
              var P = v[y];
              P = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(P) ? P : n.resourcePath + P, s[f.uuid].push(i(P));
            }
          } else
            P = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f.url) ? f.url : n.resourcePath + f.url, s[f.uuid] = i(P);
        }
      }
      return s;
    },
    parseTextures: function(t, e) {
      function i(v, y) {
        return typeof v == "number" ? v : (console.warn(
          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
          v
        ), y[v]);
      }
      var n = {};
      if (t !== void 0)
        for (var s = 0, a = t.length; s < a; s++) {
          var c = t[s];
          c.image === void 0 && console.warn(
            'THREE.ObjectLoader: No "image" specified for',
            c.uuid
          ), e[c.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", c.image);
          var f = Array.isArray(e[c.image]) ? new D(e[c.image]) : new _(e[c.image]);
          f.needsUpdate = !0, f.uuid = c.uuid, c.name !== void 0 && (f.name = c.name), c.mapping !== void 0 && (f.mapping = i(c.mapping, gu)), c.offset !== void 0 && f.offset.fromArray(c.offset), c.repeat !== void 0 && f.repeat.fromArray(c.repeat), c.center !== void 0 && f.center.fromArray(c.center), c.rotation !== void 0 && (f.rotation = c.rotation), c.wrap !== void 0 && (f.wrapS = i(c.wrap[0], jn), f.wrapT = i(c.wrap[1], jn)), c.format !== void 0 && (f.format = c.format), c.minFilter !== void 0 && (f.minFilter = i(c.minFilter, ql)), c.magFilter !== void 0 && (f.magFilter = i(c.magFilter, ql)), c.anisotropy !== void 0 && (f.anisotropy = c.anisotropy), c.flipY !== void 0 && (f.flipY = c.flipY), n[c.uuid] = f;
        }
      return n;
    },
    parseObject: function(t, e, i) {
      function n(y) {
        return e[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", y), e[y];
      }
      function s(y) {
        if (y !== void 0) {
          if (Array.isArray(y)) {
            for (var A = [], P = 0, k = y.length; P < k; P++) {
              var H = y[P];
              i[H] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", H), A.push(i[H]);
            }
            return A;
          }
          return i[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", y), i[y];
        }
      }
      switch (t.type) {
        case "Scene":
          var a = new Hn();
          t.background !== void 0 && Number.isInteger(t.background) && (a.background = new L(t.background)), t.fog !== void 0 && (t.fog.type === "Fog" ? a.fog = new wn(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (a.fog = new Le(t.fog.color, t.fog.density)));
          break;
        case "PerspectiveCamera":
          a = new ye(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (a.focus = t.focus), t.zoom !== void 0 && (a.zoom = t.zoom), t.filmGauge !== void 0 && (a.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (a.filmOffset = t.filmOffset), t.view !== void 0 && (a.view = Object.assign({}, t.view));
          break;
        case "OrthographicCamera":
          a = new ca(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (a.zoom = t.zoom), t.view !== void 0 && (a.view = Object.assign({}, t.view));
          break;
        case "AmbientLight":
          a = new Co(t.color, t.intensity);
          break;
        case "DirectionalLight":
          a = new ds(t.color, t.intensity);
          break;
        case "PointLight":
          a = new Ao(t.color, t.intensity, t.distance, t.decay);
          break;
        case "RectAreaLight":
          a = new Nl(t.color, t.intensity, t.width, t.height);
          break;
        case "SpotLight":
          a = new Za(
            t.color,
            t.intensity,
            t.distance,
            t.angle,
            t.penumbra,
            t.decay
          );
          break;
        case "HemisphereLight":
          a = new qa(t.color, t.groundColor, t.intensity);
          break;
        case "SkinnedMesh":
          console.warn(
            "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
          );
        case "Mesh":
          a = n(t.geometry);
          var c = s(t.material);
          a = a.bones && 0 < a.bones.length ? new Fi(a, c) : new pi(a, c);
          break;
        case "LOD":
          a = new tn();
          break;
        case "Line":
          a = new Vi(n(t.geometry), s(t.material), t.mode);
          break;
        case "LineLoop":
          a = new os(n(t.geometry), s(t.material));
          break;
        case "LineSegments":
          a = new mi(n(t.geometry), s(t.material));
          break;
        case "PointCloud":
        case "Points":
          a = new $o(n(t.geometry), s(t.material));
          break;
        case "Sprite":
          a = new Qi(s(t.material));
          break;
        case "Group":
          a = new ui();
          break;
        default:
          a = new N();
      }
      if (a.uuid = t.uuid, t.name !== void 0 && (a.name = t.name), t.matrix !== void 0 ? (a.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = t.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (t.position !== void 0 && a.position.fromArray(t.position), t.rotation !== void 0 && a.rotation.fromArray(t.rotation), t.quaternion !== void 0 && a.quaternion.fromArray(t.quaternion), t.scale !== void 0 && a.scale.fromArray(t.scale)), t.castShadow !== void 0 && (a.castShadow = t.castShadow), t.receiveShadow !== void 0 && (a.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (a.shadow.bias = t.shadow.bias), t.shadow.radius !== void 0 && (a.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (a.visible = t.visible), t.frustumCulled !== void 0 && (a.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (a.renderOrder = t.renderOrder), t.userData !== void 0 && (a.userData = t.userData), t.layers !== void 0 && (a.layers.mask = t.layers), t.children !== void 0) {
        c = t.children;
        for (var f = 0; f < c.length; f++)
          a.add(this.parseObject(c[f], e, i));
      }
      if (t.type === "LOD")
        for (t = t.levels, c = 0; c < t.length; c++) {
          f = t[c];
          var v = a.getObjectByProperty("uuid", f.object);
          v !== void 0 && a.addLevel(v, f.distance);
        }
      return a;
    }
  });
  var gu = {
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307
  }, jn = {
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002
  }, ql = {
    NearestFilter: 1003,
    NearestMipMapNearestFilter: 1004,
    NearestMipMapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipMapNearestFilter: 1007,
    LinearMipMapLinearFilter: 1008
  };
  _h.prototype = {
    constructor: _h,
    setOptions: function(t) {
      return this.options = t, this;
    },
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var s = this, a = vs.get(t);
      if (a !== void 0)
        return s.manager.itemStart(t), setTimeout(function() {
          e && e(a), s.manager.itemEnd(t);
        }, 0), a;
      fetch(t).then(function(c) {
        return c.blob();
      }).then(function(c) {
        return createImageBitmap(c, s.options);
      }).then(function(c) {
        vs.add(t, c), e && e(c), s.manager.itemEnd(t);
      }).catch(function(c) {
        n && n(c), s.manager.itemError(t), s.manager.itemEnd(t);
      });
    },
    setCrossOrigin: function() {
      return this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }, Object.assign(Ul.prototype, {
    moveTo: function(t, e) {
      this.currentPath = new ar(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e);
    },
    lineTo: function(t, e) {
      this.currentPath.lineTo(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      this.currentPath.quadraticCurveTo(t, e, i, n);
    },
    bezierCurveTo: function(t, e, i, n, s, a) {
      this.currentPath.bezierCurveTo(t, e, i, n, s, a);
    },
    splineThru: function(t) {
      this.currentPath.splineThru(t);
    },
    toShapes: function(t, e) {
      function i(rt) {
        for (var xt = [], gt = 0, At = rt.length; gt < At; gt++) {
          var wt = rt[gt], Vt = new $n();
          Vt.curves = wt.curves, xt.push(Vt);
        }
        return xt;
      }
      function n(rt, xt) {
        for (var gt = xt.length, At = !1, wt = gt - 1, Vt = 0; Vt < gt; wt = Vt++) {
          var Z = xt[wt], st = xt[Vt], zt = st.x - Z.x, ee = st.y - Z.y;
          if (Math.abs(ee) > Number.EPSILON) {
            if (0 > ee && (Z = xt[Vt], zt = -zt, st = xt[wt], ee = -ee), !(rt.y < Z.y || rt.y > st.y))
              if (rt.y === Z.y) {
                if (rt.x === Z.x)
                  return !0;
              } else {
                if (wt = ee * (rt.x - Z.x) - zt * (rt.y - Z.y), wt === 0)
                  return !0;
                0 > wt || (At = !At);
              }
          } else if (rt.y === Z.y && (st.x <= rt.x && rt.x <= Z.x || Z.x <= rt.x && rt.x <= st.x))
            return !0;
        }
        return At;
      }
      var s = gs.isClockWise, a = this.subPaths;
      if (a.length === 0)
        return [];
      if (e === !0)
        return i(a);
      if (e = [], a.length === 1) {
        var c = a[0], f = new $n();
        return f.curves = c.curves, e.push(f), e;
      }
      var v = !s(a[0].getPoints());
      v = t ? !v : v, f = [];
      var y = [], A = [], P = 0;
      y[P] = void 0, A[P] = [];
      for (var k = 0, H = a.length; k < H; k++) {
        c = a[k];
        var q = c.getPoints(), K = s(q);
        (K = t ? !K : K) ? (!v && y[P] && P++, y[P] = { s: new $n(), p: q }, y[P].s.curves = c.curves, v && P++, A[P] = []) : A[P].push({ h: c, p: q[0] });
      }
      if (!y[0])
        return i(a);
      if (1 < y.length) {
        for (k = !1, t = [], s = 0, a = y.length; s < a; s++)
          f[s] = [];
        for (s = 0, a = y.length; s < a; s++)
          for (c = A[s], K = 0; K < c.length; K++) {
            for (v = c[K], P = !0, q = 0; q < y.length; q++)
              n(v.p, y[q].p) && (s !== q && t.push({ froms: s, tos: q, hole: K }), P ? (P = !1, f[q].push(v)) : k = !0);
            P && f[s].push(v);
          }
        0 < t.length && (k || (A = f));
      }
      for (k = 0, s = y.length; k < s; k++)
        for (f = y[k].s, e.push(f), t = A[k], a = 0, c = t.length; a < c; a++)
          f.holes.push(t[a].h);
      return e;
    }
  }), Object.assign(yh.prototype, {
    isFont: !0,
    generateShapes: function(t, e) {
      e === void 0 && (e = 100);
      var i = [], n = e;
      e = this.data;
      var s = Array.from ? Array.from(t) : String(t).split("");
      n /= e.resolution;
      var a = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
      t = [];
      for (var c = 0, f = 0, v = 0; v < s.length; v++) {
        var y = s[v];
        if (y === `
`)
          c = 0, f -= a;
        else {
          var A = n, P = c, k = f;
          if (y = e.glyphs[y] || e.glyphs["?"]) {
            var H = new Ul();
            if (y.o)
              for (var q = y._cachedOutline || (y._cachedOutline = y.o.split(" ")), K = 0, rt = q.length; K < rt; )
                switch (q[K++]) {
                  case "m":
                    var xt = q[K++] * A + P, gt = q[K++] * A + k;
                    H.moveTo(xt, gt);
                    break;
                  case "l":
                    xt = q[K++] * A + P, gt = q[K++] * A + k, H.lineTo(xt, gt);
                    break;
                  case "q":
                    var At = q[K++] * A + P, wt = q[K++] * A + k, Vt = q[K++] * A + P, Z = q[K++] * A + k;
                    H.quadraticCurveTo(Vt, Z, At, wt);
                    break;
                  case "b":
                    At = q[K++] * A + P, wt = q[K++] * A + k, Vt = q[K++] * A + P, Z = q[K++] * A + k, xt = q[K++] * A + P, gt = q[K++] * A + k, H.bezierCurveTo(Vt, Z, xt, gt, At, wt);
                }
            A = { offsetX: y.ha * A, path: H };
          } else
            A = void 0;
          c += A.offsetX, t.push(A.path);
        }
      }
      for (e = 0, s = t.length; e < s; e++)
        Array.prototype.push.apply(i, t[e].toShapes());
      return i;
    }
  }), Object.assign(ou.prototype, {
    load: function(t, e, i, n) {
      var s = this, a = new Lt(this.manager);
      a.setPath(this.path), a.load(
        t,
        function(c) {
          try {
            var f = JSON.parse(c);
          } catch {
            console.warn(
              "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
            ), f = JSON.parse(c.substring(65, c.length - 2));
          }
          c = s.parse(f), e && e(c);
        },
        i,
        n
      );
    },
    parse: function(t) {
      return new yh(t);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var Yl, Lh = {
    getContext: function() {
      return Yl === void 0 && (Yl = new (window.AudioContext || window.webkitAudioContext)()), Yl;
    },
    setContext: function(t) {
      Yl = t;
    }
  };
  Object.assign(pn.prototype, {
    load: function(t, e, i, n) {
      var s = new Lt(this.manager);
      s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(
        t,
        function(a) {
          a = a.slice(0), Lh.getContext().decodeAudioData(a, function(c) {
            e(c);
          });
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Gn.prototype, {
    update: function() {
      var t, e, i, n, s, a, c, f, v = new p(), y = new p();
      return function(A) {
        if (t !== this || e !== A.focus || i !== A.fov || n !== A.aspect * this.aspect || s !== A.near || a !== A.far || c !== A.zoom || f !== this.eyeSep) {
          t = this, e = A.focus, i = A.fov, n = A.aspect * this.aspect, s = A.near, a = A.far, c = A.zoom;
          var P = A.projectionMatrix.clone();
          f = this.eyeSep / 2;
          var k = f * s / e, H = s * Math.tan(fi.DEG2RAD * i * 0.5) / c;
          y.elements[12] = -f, v.elements[12] = f;
          var q = -H * n + k, K = H * n + k;
          P.elements[0] = 2 * s / (K - q), P.elements[8] = (K + q) / (K - q), this.cameraL.projectionMatrix.copy(P), q = -H * n - k, K = H * n - k, P.elements[0] = 2 * s / (K - q), P.elements[8] = (K + q) / (K - q), this.cameraR.projectionMatrix.copy(P);
        }
        this.cameraL.matrixWorld.copy(A.matrixWorld).multiply(y), this.cameraR.matrixWorld.copy(A.matrixWorld).multiply(v);
      };
    }()
  }), $a.prototype = Object.create(N.prototype), $a.prototype.constructor = $a, Object.assign(xh.prototype, {
    start: function() {
      this.oldTime = this.startTime = (typeof performance > "u" ? Date : performance).now(), this.elapsedTime = 0, this.running = !0;
    },
    stop: function() {
      this.getElapsedTime(), this.autoStart = this.running = !1;
    },
    getElapsedTime: function() {
      return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
      var t = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        var e = (typeof performance > "u" ? Date : performance).now();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }
      return t;
    }
  }), Gl.prototype = Object.assign(Object.create(N.prototype), {
    constructor: Gl,
    getInput: function() {
      return this.gain;
    },
    removeFilter: function() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    },
    getFilter: function() {
      return this.filter;
    },
    setFilter: function(t) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    },
    getMasterVolume: function() {
      return this.gain.gain.value;
    },
    setMasterVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    },
    updateMatrixWorld: function() {
      var t = new u(), e = new d(), i = new u(), n = new u(), s = new xh();
      return function(a) {
        N.prototype.updateMatrixWorld.call(this, a), a = this.context.listener;
        var c = this.up;
        if (this.timeDelta = s.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), a.positionX) {
          var f = this.context.currentTime + this.timeDelta;
          a.positionX.linearRampToValueAtTime(t.x, f), a.positionY.linearRampToValueAtTime(t.y, f), a.positionZ.linearRampToValueAtTime(t.z, f), a.forwardX.linearRampToValueAtTime(n.x, f), a.forwardY.linearRampToValueAtTime(n.y, f), a.forwardZ.linearRampToValueAtTime(n.z, f), a.upX.linearRampToValueAtTime(c.x, f), a.upY.linearRampToValueAtTime(c.y, f), a.upZ.linearRampToValueAtTime(c.z, f);
        } else
          a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z, c.x, c.y, c.z);
      };
    }()
  }), fa.prototype = Object.assign(Object.create(N.prototype), {
    constructor: fa,
    getOutput: function() {
      return this.gain;
    },
    setNodeSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    },
    setMediaElementSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    },
    setBuffer: function(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    },
    play: function() {
      if (this.isPlaying === !0)
        console.warn("THREE.Audio: Audio is already playing.");
      else if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else {
        var t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect();
      }
    },
    pause: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.isPlaying === !0 && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
    },
    stop: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
    },
    connect: function() {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this;
    },
    disconnect: function() {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this;
    },
    getFilters: function() {
      return this.filters;
    },
    setFilters: function(t) {
      return t || (t = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this;
    },
    getFilter: function() {
      return this.getFilters()[0];
    },
    setFilter: function(t) {
      return this.setFilters(t ? [t] : []);
    },
    setPlaybackRate: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(
          this.playbackRate,
          this.context.currentTime
        ), this;
    },
    getPlaybackRate: function() {
      return this.playbackRate;
    },
    onEnded: function() {
      this.isPlaying = !1;
    },
    getLoop: function() {
      return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    },
    setLoop: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    },
    getVolume: function() {
      return this.gain.gain.value;
    },
    setVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    }
  }), Ka.prototype = Object.assign(Object.create(fa.prototype), {
    constructor: Ka,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(t) {
      return this.panner.refDistance = t, this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(t) {
      return this.panner.rolloffFactor = t, this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(t) {
      return this.panner.distanceModel = t, this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(t) {
      return this.panner.maxDistance = t, this;
    },
    setDirectionalCone: function(t, e, i) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this;
    },
    updateMatrixWorld: function() {
      var t = new u(), e = new d(), i = new u(), n = new u();
      return function(s) {
        if (N.prototype.updateMatrixWorld.call(this, s), s = this.panner, this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), s.positionX) {
          var a = this.context.currentTime + this.listener.timeDelta;
          s.positionX.linearRampToValueAtTime(t.x, a), s.positionY.linearRampToValueAtTime(t.y, a), s.positionZ.linearRampToValueAtTime(t.z, a), s.orientationX.linearRampToValueAtTime(n.x, a), s.orientationY.linearRampToValueAtTime(n.y, a), s.orientationZ.linearRampToValueAtTime(n.z, a);
        } else
          s.setPosition(t.x, t.y, t.z), s.setOrientation(n.x, n.y, n.z);
      };
    }()
  }), Object.assign(Lo.prototype, {
    getFrequencyData: function() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    },
    getAverageFrequency: function() {
      for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)
        t += e[i];
      return t / e.length;
    }
  }), Object.assign(Qa.prototype, {
    accumulate: function(t, e) {
      var i = this.buffer, n = this.valueSize;
      t = t * n + n;
      var s = this.cumulativeWeight;
      if (s === 0) {
        for (s = 0; s !== n; ++s)
          i[t + s] = i[s];
        s = e;
      } else
        s += e, this._mixBufferRegion(i, t, 0, e / s, n);
      this.cumulativeWeight = s;
    },
    apply: function(t) {
      var e = this.valueSize, i = this.buffer;
      t = t * e + e;
      var n = this.cumulativeWeight, s = this.binding;
      this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e;
      for (var a = e + e; n !== a; ++n)
        if (i[n] !== i[n + e]) {
          s.setValue(i, t);
          break;
        }
    },
    saveOriginalState: function() {
      var t = this.buffer, e = this.valueSize, i = 3 * e;
      this.binding.getValue(t, i);
      for (var n = e; n !== i; ++n)
        t[n] = t[i + n % e];
      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
      this.binding.setValue(this.buffer, 3 * this.valueSize);
    },
    _select: function(t, e, i, n, s) {
      if (0.5 <= n)
        for (n = 0; n !== s; ++n)
          t[e + n] = t[i + n];
    },
    _slerp: function(t, e, i, n) {
      d.slerpFlat(t, e, t, e, t, i, n);
    },
    _lerp: function(t, e, i, n, s) {
      for (var a = 1 - n, c = 0; c !== s; ++c) {
        var f = e + c;
        t[f] = t[f] * a + t[i + c] * n;
      }
    }
  }), Object.assign(Ro.prototype, {
    getValue: function(t, e) {
      this.bind();
      var i = this._bindings[this._targetGroup.nCachedObjects_];
      i !== void 0 && i.getValue(t, e);
    },
    setValue: function(t, e) {
      for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n)
        i[n].setValue(t, e);
    },
    bind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].bind();
    },
    unbind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].unbind();
    }
  }), Object.assign(Tn, {
    Composite: Ro,
    create: function(t, e, i) {
      return t && t.isAnimationObjectGroup ? new Tn.Composite(t, e, i) : new Tn(t, e, i);
    },
    sanitizeNodeName: function() {
      var t = /[\[\]\.:\/]/g;
      return function(e) {
        return e.replace(/\s/g, "_").replace(t, "");
      };
    }(),
    parseTrackName: function() {
      var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
      t = /(WCOD+)?/.source.replace("WCOD", t);
      var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
        "WC",
        "[^\\[\\]\\.:\\/]"
      ), n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), s = new RegExp("^" + e + t + i + n + "$"), a = ["material", "materials", "bones"];
      return function(c) {
        var f = s.exec(c);
        if (!f)
          throw Error("PropertyBinding: Cannot parse trackName: " + c);
        f = {
          nodeName: f[2],
          objectName: f[3],
          objectIndex: f[4],
          propertyName: f[5],
          propertyIndex: f[6]
        };
        var v = f.nodeName && f.nodeName.lastIndexOf(".");
        if (v !== void 0 && v !== -1) {
          var y = f.nodeName.substring(v + 1);
          a.indexOf(y) !== -1 && (f.nodeName = f.nodeName.substring(0, v), f.objectName = y);
        }
        if (f.propertyName === null || f.propertyName.length === 0)
          throw Error(
            "PropertyBinding: can not parse propertyName from trackName: " + c
          );
        return f;
      };
    }(),
    findNode: function(t, e) {
      if (!e || e === "" || e === "root" || e === "." || e === -1 || e === t.name || e === t.uuid)
        return t;
      if (t.skeleton) {
        var i = t.skeleton.getBoneByName(e);
        if (i !== void 0)
          return i;
      }
      if (t.children) {
        var n = function(s) {
          for (var a = 0; a < s.length; a++) {
            var c = s[a];
            if (c.name === e || c.uuid === e || (c = n(c.children)))
              return c;
          }
          return null;
        };
        if (t = n(t.children))
          return t;
      }
      return null;
    }
  }), Object.assign(Tn.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
    GetterByBindingType: [
      function(t, e) {
        t[e] = this.node[this.propertyName];
      },
      function(t, e) {
        for (var i = this.resolvedProperty, n = 0, s = i.length; n !== s; ++n)
          t[e++] = i[n];
      },
      function(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      },
      function(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function(t, e) {
          this.targetObject[this.propertyName] = t[e];
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, s = i.length; n !== s; ++n)
            i[n] = t[e++];
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, s = i.length; n !== s; ++n)
            i[n] = t[e++];
          this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, s = i.length; n !== s; ++n)
            i[n] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty.fromArray(t, e);
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ]
    ],
    getValue: function(t, e) {
      this.bind(), this.getValue(t, e);
    },
    setValue: function(t, e) {
      this.bind(), this.setValue(t, e);
    },
    bind: function() {
      var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, s = e.propertyIndex;
      if (t || (this.node = t = Tn.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
        if (i) {
          var a = e.objectIndex;
          switch (i) {
            case "materials":
              if (!t.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!t.material.materials) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
                return;
              }
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
                return;
              }
              for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                if (t[i].name === a) {
                  a = i;
                  break;
                }
              break;
            default:
              if (t[i] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
                return;
              }
              t = t[i];
          }
          if (a !== void 0) {
            if (t[a] === void 0) {
              console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                t
              );
              return;
            }
            t = t[a];
          }
        }
        if (a = t[n], a === void 0)
          console.error(
            "THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.",
            t
          );
        else {
          if (e = this.Versioning.None, this.targetObject = t, t.needsUpdate !== void 0 ? e = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, s !== void 0) {
            if (n === "morphTargetInfluences") {
              if (!t.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (t.geometry.isBufferGeometry) {
                if (!t.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                  if (t.geometry.morphAttributes.position[i].name === s) {
                    s = i;
                    break;
                  }
              } else {
                if (!t.geometry.morphTargets) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                  if (t.geometry.morphTargets[i].name === s) {
                    s = i;
                    break;
                  }
              }
            }
            i = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
          } else
            a.fromArray !== void 0 && a.toArray !== void 0 ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (i = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e];
        }
      } else
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."
        );
    },
    unbind: function() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }), Object.assign(Tn.prototype, {
    _getValue_unbound: Tn.prototype.getValue,
    _setValue_unbound: Tn.prototype.setValue
  }), Object.assign(pa.prototype, {
    isAnimationObjectGroup: !0,
    add: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, s = this._paths, a = this._parsedPaths, c = this._bindings, f = c.length, v = void 0, y = 0, A = arguments.length; y !== A; ++y) {
        var P = arguments[y], k = P.uuid, H = n[k];
        if (H === void 0) {
          H = e++, n[k] = H, t.push(P), k = 0;
          for (var q = f; k !== q; ++k)
            c[k].push(new Tn(P, s[k], a[k]));
        } else if (H < i) {
          v = t[H];
          var K = --i;
          for (q = t[K], n[q.uuid] = H, t[H] = q, n[k] = K, t[K] = P, k = 0, q = f; k !== q; ++k) {
            var rt = c[k], xt = rt[H];
            rt[H] = rt[K], xt === void 0 && (xt = new Tn(P, s[k], a[k])), rt[K] = xt;
          }
        } else
          t[H] !== v && console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
      }
      this.nCachedObjects_ = i;
    },
    remove: function() {
      for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, s = n.length, a = 0, c = arguments.length; a !== c; ++a) {
        var f = arguments[a], v = f.uuid, y = i[v];
        if (y !== void 0 && y >= e) {
          var A = e++, P = t[A];
          for (i[P.uuid] = y, t[y] = P, i[v] = A, t[A] = f, f = 0, v = s; f !== v; ++f) {
            P = n[f];
            var k = P[y];
            P[y] = P[A], P[A] = k;
          }
        }
      }
      this.nCachedObjects_ = e;
    },
    uncache: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, s = this._bindings, a = s.length, c = 0, f = arguments.length; c !== f; ++c) {
        var v = arguments[c].uuid, y = n[v];
        if (y !== void 0)
          if (delete n[v], y < i) {
            v = --i;
            var A = t[v], P = --e, k = t[P];
            for (n[A.uuid] = y, t[y] = A, n[k.uuid] = v, t[v] = k, t.pop(), A = 0, k = a; A !== k; ++A) {
              var H = s[A], q = H[P];
              H[y] = H[v], H[v] = q, H.pop();
            }
          } else
            for (P = --e, k = t[P], n[k.uuid] = y, t[y] = k, t.pop(), A = 0, k = a; A !== k; ++A)
              H = s[A], H[y] = H[P], H.pop();
      }
      this.nCachedObjects_ = i;
    },
    subscribe_: function(t, e) {
      var i = this._bindingsIndicesByPath, n = i[t], s = this._bindings;
      if (n !== void 0)
        return s[n];
      var a = this._paths, c = this._parsedPaths, f = this._objects, v = this.nCachedObjects_, y = Array(f.length);
      for (n = s.length, i[t] = n, a.push(t), c.push(e), s.push(y), i = v, n = f.length; i !== n; ++i)
        y[i] = new Tn(f[i], t, e);
      return y;
    },
    unsubscribe_: function(t) {
      var e = this._bindingsIndicesByPath, i = e[t];
      if (i !== void 0) {
        var n = this._paths, s = this._parsedPaths, a = this._bindings, c = a.length - 1, f = a[c];
        e[t[c]] = i, a[i] = f, a.pop(), s[i] = s[c], s.pop(), n[i] = n[c], n.pop();
      }
    }
  }), Object.assign(tl.prototype, {
    play: function() {
      return this._mixer._activateAction(this), this;
    },
    stop: function() {
      return this._mixer._deactivateAction(this), this.reset();
    },
    reset: function() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    },
    isRunning: function() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(t) {
      return this._startTime = t, this;
    },
    setLoop: function(t, e) {
      return this.loop = t, this.repetitions = e, this;
    },
    setEffectiveWeight: function(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(t) {
      return this._scheduleFading(t, 0, 1);
    },
    fadeOut: function(t) {
      return this._scheduleFading(t, 1, 0);
    },
    crossFadeFrom: function(t, e, i) {
      if (t.fadeOut(e), this.fadeIn(e), i) {
        i = this._clip.duration;
        var n = t._clip.duration, s = i / n;
        t.warp(1, n / i, e), this.warp(s, 1, e);
      }
      return this;
    },
    crossFadeTo: function(t, e, i) {
      return t.crossFadeFrom(this, e, i);
    },
    stopFading: function() {
      var t = this._weightInterpolant;
      return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    setEffectiveTimeScale: function(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    },
    syncWith: function(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    },
    halt: function(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    },
    warp: function(t, e, i) {
      var n = this._mixer, s = n.time, a = this._timeScaleInterpolant, c = this.timeScale;
      return a === null && (this._timeScaleInterpolant = a = n._lendControlInterpolant()), n = a.parameterPositions, a = a.sampleValues, n[0] = s, n[1] = s + i, a[0] = t / c, a[1] = e / c, this;
    },
    stopWarping: function() {
      var t = this._timeScaleInterpolant;
      return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(t, e, i, n) {
      if (this.enabled) {
        var s = this._startTime;
        if (s !== null) {
          if (e = (t - s) * i, 0 > e || i === 0)
            return;
          this._startTime = null, e *= i;
        }
        if (e *= this._updateTimeScale(t), i = this._updateTime(e), t = this._updateWeight(t), 0 < t) {
          e = this._interpolants, s = this._propertyBindings;
          for (var a = 0, c = e.length; a !== c; ++a)
            e[a].evaluate(i), s[a].accumulate(n, t);
        }
      } else
        this._updateWeight(t);
    },
    _updateWeight: function(t) {
      var e = 0;
      if (this.enabled) {
        e = this.weight;
        var i = this._weightInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
        }
      }
      return this._effectiveWeight = e;
    },
    _updateTimeScale: function(t) {
      var e = 0;
      if (!this.paused) {
        e = this.timeScale;
        var i = this._timeScaleInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
        }
      }
      return this._effectiveTimeScale = e;
    },
    _updateTime: function(t) {
      var e = this.time + t, i = this._clip.duration, n = this.loop, s = this._loopCount, a = n === 2202;
      if (t === 0)
        return s === -1 ? e : a && (s & 1) === 1 ? i - e : e;
      if (n === 2200)
        t: {
          if (s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i)
            e = i;
          else if (0 > e)
            e = 0;
          else
            break t;
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 > t ? -1 : 1
          });
        }
      else {
        if (s === -1 && (0 <= t ? (s = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), e >= i || 0 > e) {
          n = Math.floor(e / i), e -= i * n, s += Math.abs(n);
          var c = this.repetitions - s;
          0 >= c ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 < t ? 1 : -1
          })) : (c === 1 ? (t = 0 > t, this._setEndings(t, !t, a)) : this._setEndings(!1, !1, a), this._loopCount = s, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: n
          }));
        }
        if (a && (s & 1) === 1)
          return this.time = e, i - e;
      }
      return this.time = e;
    },
    _setEndings: function(t, e, i) {
      var n = this._interpolantSettings;
      i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    },
    _scheduleFading: function(t, e, i) {
      var n = this._mixer, s = n.time, a = this._weightInterpolant;
      return a === null && (this._weightInterpolant = a = n._lendControlInterpolant()), n = a.parameterPositions, a = a.sampleValues, n[0] = s, a[0] = e, n[1] = s + t, a[1] = i, this;
    }
  }), $s.prototype = Object.assign(Object.create(l.prototype), {
    constructor: $s,
    _bindAction: function(t, e) {
      var i = t._localRoot || this._root, n = t._clip.tracks, s = n.length, a = t._propertyBindings;
      t = t._interpolants;
      var c = i.uuid, f = this._bindingsByRootAndName, v = f[c];
      for (v === void 0 && (v = {}, f[c] = v), f = 0; f !== s; ++f) {
        var y = n[f], A = y.name, P = v[A];
        if (P === void 0) {
          if (P = a[f], P !== void 0) {
            P._cacheIndex === null && (++P.referenceCount, this._addInactiveBinding(P, c, A));
            continue;
          }
          P = new Qa(
            Tn.create(i, A, e && e._propertyBindings[f].binding.parsedPath),
            y.ValueTypeName,
            y.getValueSize()
          ), ++P.referenceCount, this._addInactiveBinding(P, c, A);
        }
        a[f] = P, t[f].resultBuffer = P.buffer;
      }
    },
    _activateAction: function(t) {
      if (!this._isActiveAction(t)) {
        if (t._cacheIndex === null) {
          var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
          this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
        }
        for (e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var s = e[i];
          s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
        }
        this._lendAction(t);
      }
    },
    _deactivateAction: function(t) {
      if (this._isActiveAction(t)) {
        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var s = e[i];
          --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
        }
        this._takeBackAction(t);
      }
    },
    _initMemoryManager: function() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },
          get inUse() {
            return t._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return t._bindings.length;
          },
          get inUse() {
            return t._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },
          get inUse() {
            return t._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(t) {
      return t = t._cacheIndex, t !== null && t < this._nActiveActions;
    },
    _addInactiveAction: function(t, e, i) {
      var n = this._actions, s = this._actionsByClip, a = s[e];
      a === void 0 ? (a = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, s[e] = a) : (e = a.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t;
    },
    _removeInactiveAction: function(t) {
      var e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
      i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid, i = this._actionsByClip, n = i[e];
      var s = n.knownActions, a = s[s.length - 1], c = t._byClipCacheIndex;
      a._byClipCacheIndex = c, s[c] = a, s.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], s.length === 0 && delete i[e], this._removeInactiveBindingsForAction(t);
    },
    _removeInactiveBindingsForAction: function(t) {
      t = t._propertyBindings;
      for (var e = 0, i = t.length; e !== i; ++e) {
        var n = t[e];
        --n.referenceCount === 0 && this._removeInactiveBinding(n);
      }
    },
    _lendAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, s = e[n];
      t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s;
    },
    _takeBackAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, s = e[n];
      t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s;
    },
    _addInactiveBinding: function(t, e, i) {
      var n = this._bindingsByRootAndName, s = n[e], a = this._bindings;
      s === void 0 && (s = {}, n[e] = s), s[i] = t, t._cacheIndex = a.length, a.push(t);
    },
    _removeInactiveBinding: function(t) {
      var e = this._bindings, i = t.binding, n = i.rootNode.uuid;
      i = i.path;
      var s = this._bindingsByRootAndName, a = s[n], c = e[e.length - 1];
      t = t._cacheIndex, c._cacheIndex = t, e[t] = c, e.pop(), delete a[i];
      t: {
        for (var f in a)
          break t;
        delete s[n];
      }
    },
    _lendBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, s = e[n];
      t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s;
    },
    _takeBackBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, s = e[n];
      t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s;
    },
    _lendControlInterpolant: function() {
      var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
      return i === void 0 && (i = new Ar(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      ), i.__cacheIndex = e, t[e] = i), i;
    },
    _takeBackControlInterpolant: function(t) {
      var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, s = e[n];
      t.__cacheIndex = n, e[n] = t, s.__cacheIndex = i, e[i] = s;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(t, e) {
      var i = e || this._root, n = i.uuid;
      i = typeof t == "string" ? gr.findByName(i, t) : t, t = i !== null ? i.uuid : t;
      var s = this._actionsByClip[t], a = null;
      if (s !== void 0) {
        if (a = s.actionByRoot[n], a !== void 0)
          return a;
        a = s.knownActions[0], i === null && (i = a._clip);
      }
      return i === null ? null : (e = new tl(this, i, e), this._bindAction(e, a), this._addInactiveAction(e, t, n), e);
    },
    existingAction: function(t, e) {
      var i = e || this._root;
      return e = i.uuid, i = typeof t == "string" ? gr.findByName(i, t) : t, t = this._actionsByClip[i ? i.uuid : t], t !== void 0 && t.actionByRoot[e] || null;
    },
    stopAllAction: function() {
      for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, s = this._nActiveBindings = this._nActiveActions = 0; s !== e; ++s)
        t[s].reset();
      for (s = 0; s !== n; ++s)
        i[s].useCount = 0;
      return this;
    },
    update: function(t) {
      t *= this.timeScale;
      for (var e = this._actions, i = this._nActiveActions, n = this.time += t, s = Math.sign(t), a = this._accuIndex ^= 1, c = 0; c !== i; ++c)
        e[c]._update(n, t, s, a);
      for (t = this._bindings, e = this._nActiveBindings, c = 0; c !== e; ++c)
        t[c].apply(a);
      return this;
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(t) {
      var e = this._actions;
      t = t.uuid;
      var i = this._actionsByClip, n = i[t];
      if (n !== void 0) {
        n = n.knownActions;
        for (var s = 0, a = n.length; s !== a; ++s) {
          var c = n[s];
          this._deactivateAction(c);
          var f = c._cacheIndex, v = e[e.length - 1];
          c._cacheIndex = null, c._byClipCacheIndex = null, v._cacheIndex = f, e[f] = v, e.pop(), this._removeInactiveBindingsForAction(c);
        }
        delete i[t];
      }
    },
    uncacheRoot: function(t) {
      t = t.uuid;
      var e = this._actionsByClip;
      for (n in e) {
        var i = e[n].actionByRoot[t];
        i !== void 0 && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
      var n = this._bindingsByRootAndName[t];
      if (n !== void 0)
        for (var s in n)
          t = n[s], t.restoreOriginalState(), this._removeInactiveBinding(t);
    },
    uncacheAction: function(t, e) {
      t = this.existingAction(t, e), t !== null && (this._deactivateAction(t), this._removeInactiveAction(t));
    }
  }), Hl.prototype.clone = function() {
    return new Hl(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }, wh.prototype = Object.assign(Object.create(Ft.prototype), {
    constructor: wh,
    isInstancedBufferGeometry: !0,
    copy: function(t) {
      return Ft.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), Th.prototype = Object.assign(Object.create(Oi.prototype), {
    constructor: Th,
    isInstancedInterleavedBuffer: !0,
    copy: function(t) {
      return Oi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), Mh.prototype = Object.assign(Object.create(J.prototype), {
    constructor: Mh,
    isInstancedBufferAttribute: !0,
    copy: function(t) {
      return J.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), Object.assign(au.prototype, {
    linePrecision: 1,
    set: function(t, e) {
      this.ray.set(t, e);
    },
    setFromCamera: function(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
    },
    intersectObject: function(t, e, i) {
      return i = i || [], Oo(t, this, i, e), i.sort(el), i;
    },
    intersectObjects: function(t, e, i) {
      if (i = i || [], Array.isArray(t) === !1)
        return console.warn(
          "THREE.Raycaster.intersectObjects: objects is not an Array."
        ), i;
      for (var n = 0, s = t.length; n < s; n++)
        Oo(t[n], this, i, e);
      return i.sort(el), i;
    }
  }), Object.assign(Sh.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.phi = e, this.theta = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    },
    makeSafe: function() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + e * e + i * i), this.radius === 0 ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(fi.clamp(e / this.radius, -1, 1))), this;
    }
  }), Object.assign(it.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.theta = e, this.y = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this;
    }
  }), Object.assign(Ks.prototype, {
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new o();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new o()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), t = new o()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new o()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    },
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new o()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new o();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(da.prototype, {
    set: function(t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new u()), t.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), t = new u()), t.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Line3: .at() target is now required"), e = new u()), this.delta(e).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
      var t = new u(), e = new u();
      return function(i, n) {
        return t.subVectors(i, this.start), e.subVectors(this.end, this.start), i = e.dot(e), i = e.dot(t) / i, n && (i = fi.clamp(i, 0, 1)), i;
      };
    }(),
    closestPointToPoint: function(t, e, i) {
      return t = this.closestPointToPointParameter(t, e), i === void 0 && (console.warn(
        "THREE.Line3: .closestPointToPoint() target is now required"
      ), i = new u()), this.delta(i).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    },
    equals: function(t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }
  }), Vn.prototype = Object.create(N.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isImmediateRenderObject = !0, _i.prototype = Object.create(mi.prototype), _i.prototype.constructor = _i, _i.prototype.update = function() {
    var t = new u(), e = new u(), i = new m();
    return function() {
      var n = ["a", "b", "c"];
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var s = this.object.matrixWorld, a = this.geometry.attributes.position, c = this.object.geometry;
      if (c && c.isGeometry)
        for (var f = c.vertices, v = c.faces, y = c = 0, A = v.length; y < A; y++)
          for (var P = v[y], k = 0, H = P.vertexNormals.length; k < H; k++) {
            var q = P.vertexNormals[k];
            t.copy(f[P[n[k]]]).applyMatrix4(s), e.copy(q).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a.setXYZ(c, t.x, t.y, t.z), c += 1, a.setXYZ(c, e.x, e.y, e.z), c += 1;
          }
      else if (c && c.isBufferGeometry)
        for (n = c.attributes.position, f = c.attributes.normal, k = c = 0, H = n.count; k < H; k++)
          t.set(n.getX(k), n.getY(k), n.getZ(k)).applyMatrix4(s), e.set(f.getX(k), f.getY(k), f.getZ(k)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a.setXYZ(c, t.x, t.y, t.z), c += 1, a.setXYZ(c, e.x, e.y, e.z), c += 1;
      a.needsUpdate = !0;
    };
  }(), ma.prototype = Object.create(N.prototype), ma.prototype.constructor = ma, ma.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }, ma.prototype.update = function() {
    var t = new u(), e = new u();
    return function() {
      this.light.updateMatrixWorld();
      var i = this.light.distance ? this.light.distance : 1e3, n = i * Math.tan(this.light.angle);
      this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    };
  }(), ga.prototype = Object.create(mi.prototype), ga.prototype.constructor = ga, ga.prototype.updateMatrixWorld = function() {
    var t = new u(), e = new p(), i = new p();
    return function(n) {
      var s = this.bones, a = this.geometry, c = a.getAttribute("position");
      i.getInverse(this.root.matrixWorld);
      for (var f = 0, v = 0; f < s.length; f++) {
        var y = s[f];
        y.parent && y.parent.isBone && (e.multiplyMatrices(i, y.matrixWorld), t.setFromMatrixPosition(e), c.setXYZ(v, t.x, t.y, t.z), e.multiplyMatrices(i, y.parent.matrixWorld), t.setFromMatrixPosition(e), c.setXYZ(v + 1, t.x, t.y, t.z), v += 2);
      }
      a.getAttribute("position").needsUpdate = !0, N.prototype.updateMatrixWorld.call(this, n);
    };
  }(), Pr.prototype = Object.create(pi.prototype), Pr.prototype.constructor = Pr, Pr.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
  }, Pr.prototype.update = function() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }, va.prototype = Object.create(N.prototype), va.prototype.constructor = va, va.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, va.prototype.update = function() {
    var t = 0.5 * this.light.width, e = 0.5 * this.light.height, i = this.line.geometry.attributes.position, n = i.array;
    n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, this.color !== void 0 ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
  }, _a.prototype = Object.create(N.prototype), _a.prototype.constructor = _a, _a.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, _a.prototype.update = function() {
    var t = new u(), e = new L(), i = new L();
    return function() {
      var n = this.children[0];
      if (this.color !== void 0)
        this.material.color.set(this.color);
      else {
        var s = n.geometry.getAttribute("color");
        e.copy(this.light.color), i.copy(this.light.groundColor);
        for (var a = 0, c = s.count; a < c; a++) {
          var f = a < c / 2 ? e : i;
          s.setXYZ(a, f.r, f.g, f.b);
        }
        s.needsUpdate = !0;
      }
      n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }(), il.prototype = Object.create(mi.prototype), il.prototype.constructor = il, Vl.prototype = Object.create(mi.prototype), Vl.prototype.constructor = Vl, nl.prototype = Object.create(mi.prototype), nl.prototype.constructor = nl, nl.prototype.update = function() {
    var t = new u(), e = new u(), i = new m();
    return function() {
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var n = this.object.matrixWorld, s = this.geometry.attributes.position, a = this.object.geometry, c = a.vertices;
      a = a.faces;
      for (var f = 0, v = 0, y = a.length; v < y; v++) {
        var A = a[v], P = A.normal;
        t.copy(c[A.a]).add(c[A.b]).add(c[A.c]).divideScalar(3).applyMatrix4(n), e.copy(P).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(f, t.x, t.y, t.z), f += 1, s.setXYZ(f, e.x, e.y, e.z), f += 1;
      }
      s.needsUpdate = !0;
    };
  }(), lr.prototype = Object.create(N.prototype), lr.prototype.constructor = lr, lr.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }, lr.prototype.update = function() {
    var t = new u(), e = new u(), i = new u();
    return function() {
      t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length();
    };
  }(), rl.prototype = Object.create(mi.prototype), rl.prototype.constructor = rl, rl.prototype.update = function() {
    function t(a, c, f, v) {
      if (n.set(c, f, v).unproject(s), a = i[a], a !== void 0)
        for (c = e.getAttribute("position"), f = 0, v = a.length; f < v; f++)
          c.setXYZ(a[f], n.x, n.y, n.z);
    }
    var e, i, n = new u(), s = new Be();
    return function() {
      e = this.geometry, i = this.pointMap, s.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", 0.7, 1.1, -1), t("u2", -0.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
    };
  }(), Is.prototype = Object.create(mi.prototype), Is.prototype.constructor = Is, Is.prototype.update = function() {
    var t = new B();
    return function(e) {
      if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && t.setFromObject(this.object), !t.isEmpty()) {
        e = t.min;
        var i = t.max, n = this.geometry.attributes.position, s = n.array;
        s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = e.x, s[4] = i.y, s[5] = i.z, s[6] = e.x, s[7] = e.y, s[8] = i.z, s[9] = i.x, s[10] = e.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = e.z, s[15] = e.x, s[16] = i.y, s[17] = e.z, s[18] = e.x, s[19] = e.y, s[20] = e.z, s[21] = i.x, s[22] = e.y, s[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
      }
    };
  }(), Is.prototype.setFromObject = function(t) {
    return this.object = t, this.update(), this;
  }, Is.prototype.copy = function(t) {
    return mi.prototype.copy.call(this, t), this.object = t.object, this;
  }, Is.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, sl.prototype = Object.create(mi.prototype), sl.prototype.constructor = sl, sl.prototype.updateMatrixWorld = function(t) {
    var e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), N.prototype.updateMatrixWorld.call(this, t));
  }, ol.prototype = Object.create(Vi.prototype), ol.prototype.constructor = ol, ol.prototype.updateMatrixWorld = function(t) {
    var e = -this.plane.constant;
    1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), N.prototype.updateMatrixWorld.call(this, t);
  };
  var Zl, ul;
  Ds.prototype = Object.create(N.prototype), Ds.prototype.constructor = Ds, Ds.prototype.setDirection = function() {
    var t = new u(), e;
    return function(i) {
      0.99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e));
    };
  }(), Ds.prototype.setLength = function(t, e, i) {
    e === void 0 && (e = 0.2 * t), i === void 0 && (i = 0.2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix();
  }, Ds.prototype.setColor = function(t) {
    this.line.material.color.copy(t), this.cone.material.color.copy(t);
  }, Ds.prototype.copy = function(t) {
    return N.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
  }, Ds.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, vr.prototype = Object.create(mi.prototype), vr.prototype.constructor = vr, Ee.create = function(t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ee.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
  }, Object.assign(Rs.prototype, {
    createPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getPoints(t), this.createGeometry(t);
    },
    createSpacedPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getSpacedPoints(t), this.createGeometry(t);
    },
    createGeometry: function(t) {
      console.warn(
        "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      for (var e = new j(), i = 0, n = t.length; i < n; i++) {
        var s = t[i];
        e.vertices.push(new u(s.x, s.y, s.z || 0));
      }
      return e;
    }
  }), Object.assign(ar.prototype, {
    fromPoints: function(t) {
      console.warn(
        "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
      ), this.setFromPoints(t);
    }
  }), hu.prototype = Object.create(Pn.prototype), uu.prototype = Object.create(Pn.prototype), Eh.prototype = Object.create(Pn.prototype), Object.assign(Eh.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error(
        "THREE.Spline: .reparametrizeByArcLength() has been removed."
      );
    }
  }), il.prototype.setColors = function() {
    console.error(
      "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
  }, ga.prototype.update = function() {
    console.error(
      "THREE.SkeletonHelper: update() no longer needs to be called."
    );
  }, Object.assign(Os.prototype, {
    extractUrlBase: function(t) {
      return console.warn(
        "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
      ), Do.extractUrlBase(t);
    }
  }), Object.assign(Po.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(Ja.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(Ks.prototype, {
    center: function(t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    size: function(t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), Object.assign(B.prototype, {
    center: function(t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    },
    size: function(t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), da.prototype.center = function(t) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  }, Object.assign(fi, {
    random16: function() {
      return console.warn(
        "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
      ), Math.random();
    },
    nearestPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
      ), fi.floorPowerOfTwo(t);
    },
    nextPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
      ), fi.ceilPowerOfTwo(t);
    }
  }), Object.assign(m.prototype, {
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
      ), t.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  }), Object.assign(p.prototype, {
    extractPosition: function(t) {
      return console.warn(
        "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
      ), this.copyPosition(t);
    },
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    getPosition: function() {
      var t;
      return function() {
        return t === void 0 && (t = new u()), console.warn(
          "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
        ), t.setFromMatrixColumn(this, 3);
      };
    }(),
    setRotationFromQuaternion: function(t) {
      return console.warn(
        "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
      ), this.makeRotationFromQuaternion(t);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector4: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(t) {
      console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
      ), t.transformDirection(this);
    },
    crossVector: function(t) {
      return console.warn(
        "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(t, e, i, n, s, a) {
      return console.warn(
        "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
      ), this.makePerspective(t, e, n, i, s, a);
    }
  }), F.prototype.isIntersectionLine = function(t) {
    return console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ), this.intersectsLine(t);
  }, d.prototype.multiplyVector3 = function(t) {
    return console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ), t.applyQuaternion(this);
  }, Object.assign(Ni.prototype, {
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionPlane: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
      ), this.intersectsPlane(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    }
  }), Object.assign(Oe.prototype, {
    area: function() {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    },
    barycoordFromPoint: function(t, e) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), this.getBarycoord(t, e);
    },
    midpoint: function(t) {
      return console.warn(
        "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
      ), this.getMidpoint(t);
    },
    normal: function(t) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), this.getNormal(t);
    },
    plane: function(t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    }
  }), Object.assign(Oe, {
    barycoordFromPoint: function(t, e, i, n, s) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), Oe.getBarycoord(t, e, i, n, s);
    },
    normal: function(t, e, i, n) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), Oe.getNormal(t, e, i, n);
    }
  }), Object.assign($n.prototype, {
    extractAllPoints: function(t) {
      return console.warn(
        "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
      ), this.extractPoints(t);
    },
    extrude: function(t) {
      return console.warn(
        "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
      ), new As(this, t);
    },
    makeGeometry: function(t) {
      return console.warn(
        "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
      ), new Cs(this, t);
    }
  }), Object.assign(o.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(u.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
      );
    },
    setEulerFromQuaternion: function() {
      console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
      );
    },
    getPositionFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
      ), this.setFromMatrixPosition(t);
    },
    getScaleFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
      ), this.setFromMatrixScale(t);
    },
    getColumnFromMatrix: function(t, e) {
      return console.warn(
        "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
      ), this.setFromMatrixColumn(e, t);
    },
    applyProjection: function(t) {
      return console.warn(
        "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
      ), this.applyMatrix4(t);
    },
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(T.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(j.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
  }), Object.assign(N.prototype, {
    getChildByName: function(t) {
      return console.warn(
        "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
      ), this.getObjectByName(t);
    },
    renderDepth: function() {
      console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
      );
    },
    translate: function(t, e) {
      return console.warn(
        "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
      ), this.translateOnAxis(e, t);
    },
    getWorldRotation: function() {
      console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
      );
    }
  }), Object.defineProperties(N.prototype, {
    eulerOrder: {
      get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      },
      set: function(t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
      set: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      }
    }
  }), Object.defineProperties(tn.prototype, {
    objects: {
      get: function() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      }
    }
  }), Object.defineProperty(on.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  }), Object.defineProperty(Ee.prototype, "__arcLengthDivisions", {
    get: function() {
      return console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions;
    },
    set: function(t) {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions = t;
    }
  }), ye.prototype.setLens = function(t, e) {
    console.warn(
      "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    ), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
  }, Object.defineProperties($i.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
        ), this.shadow.camera.fov = t;
      }
    },
    shadowCameraLeft: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
        ), this.shadow.camera.left = t;
      }
    },
    shadowCameraRight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
        ), this.shadow.camera.right = t;
      }
    },
    shadowCameraTop: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
        ), this.shadow.camera.top = t;
      }
    },
    shadowCameraBottom: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
        ), this.shadow.camera.bottom = t;
      }
    },
    shadowCameraNear: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
        ), this.shadow.camera.near = t;
      }
    },
    shadowCameraFar: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
        ), this.shadow.camera.far = t;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn(
          "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
        );
      }
    },
    shadowBias: {
      set: function(t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
        ), this.shadow.mapSize.width = t;
      }
    },
    shadowMapHeight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
        ), this.shadow.mapSize.height = t;
      }
    }
  }), Object.defineProperties(J.prototype, {
    length: {
      get: function() {
        return console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ), this.array.length;
      }
    },
    copyIndicesArray: function() {
      console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
      );
    }
  }), Object.assign(Ft.prototype, {
    addIndex: function(t) {
      console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
      ), this.setIndex(t);
    },
    addDrawCall: function(t, e, i) {
      i !== void 0 && console.warn(
        "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
      ), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    },
    clearDrawCalls: function() {
      console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
      ), this.clearGroups();
    },
    computeTangents: function() {
      console.warn(
        "THREE.BufferGeometry: .computeTangents() has been removed."
      );
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
  }), Object.defineProperties(Ft.prototype, {
    drawcalls: {
      get: function() {
        return console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ), this.groups;
      }
    },
    offsets: {
      get: function() {
        return console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ), this.groups;
      }
    }
  }), Object.assign(ls.prototype, {
    getArrays: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
      );
    },
    addShapeList: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
      );
    },
    addShape: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
      );
    }
  }), Object.defineProperties(Hl.prototype, {
    dynamic: {
      set: function() {
        console.warn(
          "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
        );
      }
    },
    onUpdate: {
      value: function() {
        return console.warn(
          "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
        ), this;
      }
    }
  }), Object.defineProperties(Yt.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new L();
      }
    },
    shading: {
      get: function() {
        console.error(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        );
      },
      set: function(t) {
        console.warn(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        ), this.flatShading = t === 1;
      }
    }
  }), Object.defineProperties(Wr.prototype, {
    metal: {
      get: function() {
        return console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
        ), !1;
      },
      set: function() {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
        );
      }
    }
  }), Object.defineProperties(ti.prototype, {
    derivatives: {
      get: function() {
        return console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives;
      },
      set: function(t) {
        console.warn(
          "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives = t;
      }
    }
  }), Object.assign(xe.prototype, {
    clearTarget: function(t, e, i, n) {
      console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
      ), this.setRenderTarget(t), this.clear(e, i, n);
    },
    animate: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
      ), this.setAnimationLoop(t);
    },
    getCurrentRenderTarget: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
      ), this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
      ), this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
      ), this.capabilities.precision;
    },
    resetGLState: function() {
      return console.warn(
        "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
      ), this.state.reset();
    },
    supportsFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      ), this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      ), this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      ), this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      ), this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      ), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      ), this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
      ), this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      ), this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
      ), this.setScissorTest(t);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }
  }), Object.defineProperties(xe.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
        ), this.shadowMap.enabled = t;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
        ), this.shadowMap.type = t;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(_e.prototype, {
    cullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(S.prototype, {
    wrapS: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
      }
    },
    wrapT: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
      }
    },
    magFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter = t;
      }
    },
    minFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter = t;
      }
    },
    anisotropy: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy = t;
      }
    },
    offset: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset = t;
      }
    },
    repeat: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat = t;
      }
    },
    format: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format = t;
      }
    },
    type: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
      }
    },
    generateMipmaps: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps = t;
      }
    }
  }), Object.defineProperties(di.prototype, {
    standing: {
      set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      }
    },
    userHeight: {
      set: function() {
        console.warn("THREE.WebVRManager: .userHeight has been removed.");
      }
    }
  }), fa.prototype.load = function(t) {
    console.warn(
      "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
    );
    var e = this;
    return new pn().load(t, function(i) {
      e.setBuffer(i);
    }), this;
  }, Lo.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  }, $a.prototype.updateCubeMap = function(t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
  }, Qs.crossOrigin = void 0, Qs.loadTexture = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    var s = new ln();
    return s.setCrossOrigin(this.crossOrigin), t = s.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, Qs.loadTextureCube = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    var s = new zi();
    return s.setCrossOrigin(this.crossOrigin), t = s.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, Qs.loadCompressedTexture = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
  }, Qs.loadCompressedTextureCube = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
  }, w.WebGLRenderTargetCube = C, w.WebGLRenderTarget = S, w.WebGLRenderer = xe, w.ShaderLib = ms, w.UniformsLib = qe, w.UniformsUtils = Dn, w.ShaderChunk = Ei, w.FogExp2 = Le, w.Fog = wn, w.Scene = Hn, w.Sprite = Qi, w.LOD = tn, w.SkinnedMesh = Fi, w.Skeleton = on, w.Bone = an, w.Mesh = pi, w.LineSegments = mi, w.LineLoop = os, w.Line = Vi, w.Points = $o, w.Group = ui, w.VideoTexture = dh, w.DataTexture = z, w.DataTexture3D = Q, w.CompressedTexture = Gs, w.CubeTexture = D, w.CanvasTexture = Ba, w.DepthTexture = Na, w.Texture = _, w.AnimationLoader = Qt, w.CompressedTextureLoader = Zt, w.DataTextureLoader = Ue, w.CubeTextureLoader = zi, w.TextureLoader = ln, w.ObjectLoader = Ja, w.MaterialLoader = Fl, w.BufferGeometryLoader = vh, w.DefaultLoadingManager = Kn, w.LoadingManager = Ys, w.JSONLoader = Po, w.ImageLoader = oi, w.ImageBitmapLoader = _h, w.FontLoader = ou, w.FileLoader = Lt, w.Loader = Os, w.LoaderUtils = Do, w.Cache = vs, w.AudioLoader = pn, w.SpotLightShadow = Ya, w.SpotLight = Za, w.PointLight = Ao, w.RectAreaLight = Nl, w.HemisphereLight = qa, w.DirectionalLightShadow = Js, w.DirectionalLight = ds, w.AmbientLight = Co, w.LightShadow = ps, w.Light = $i, w.StereoCamera = Gn, w.PerspectiveCamera = ye, w.OrthographicCamera = ca, w.CubeCamera = $a, w.ArrayCamera = Fe, w.Camera = Be, w.AudioListener = Gl, w.PositionalAudio = Ka, w.AudioContext = Lh, w.AudioAnalyser = Lo, w.Audio = fa, w.VectorKeyframeTrack = ha, w.StringKeyframeTrack = Bl, w.QuaternionKeyframeTrack = la, w.NumberKeyframeTrack = jr, w.ColorKeyframeTrack = kl, w.BooleanKeyframeTrack = zl, w.PropertyMixer = Qa, w.PropertyBinding = Tn, w.KeyframeTrack = Un, w.AnimationUtils = Wn, w.AnimationObjectGroup = pa, w.AnimationMixer = $s, w.AnimationClip = gr, w.Uniform = Hl, w.InstancedBufferGeometry = wh, w.BufferGeometry = Ft, w.Geometry = j, w.InterleavedBufferAttribute = Ii, w.InstancedInterleavedBuffer = Th, w.InterleavedBuffer = Oi, w.InstancedBufferAttribute = Mh, w.Face3 = R, w.Object3D = N, w.Raycaster = au, w.Layers = U, w.EventDispatcher = l, w.Clock = xh, w.QuaternionLinearInterpolant = ir, w.LinearInterpolant = Ar, w.DiscreteInterpolant = bo, w.CubicInterpolant = Xa, w.Interpolant = Zn, w.Triangle = Oe, w.Math = fi, w.Spherical = Sh, w.Cylindrical = it, w.Plane = F, w.Frustum = E, w.Sphere = I, w.Ray = Ni, w.Matrix4 = p, w.Matrix3 = m, w.Box3 = B, w.Box2 = Ks, w.Line3 = da, w.Euler = b, w.Vector4 = T, w.Vector3 = u, w.Vector2 = o, w.Quaternion = d, w.Color = L, w.ImmediateRenderObject = Vn, w.VertexNormalsHelper = _i, w.SpotLightHelper = ma, w.SkeletonHelper = ga, w.PointLightHelper = Pr, w.RectAreaLightHelper = va, w.HemisphereLightHelper = _a, w.GridHelper = il, w.PolarGridHelper = Vl, w.FaceNormalsHelper = nl, w.DirectionalLightHelper = lr, w.CameraHelper = rl, w.BoxHelper = Is, w.Box3Helper = sl, w.PlaneHelper = ol, w.ArrowHelper = Ds, w.AxesHelper = vr, w.Shape = $n, w.Path = ar, w.ShapePath = Ul, w.Font = yh, w.CurvePath = Rs, w.Curve = Ee, w.ImageUtils = Qs, w.ShapeUtils = gs, w.WebGLUtils = He, w.WireframeGeometry = Ko, w.ParametricGeometry = Fa, w.ParametricBufferGeometry = Qo, w.TetrahedronGeometry = Ua, w.TetrahedronBufferGeometry = ta, w.OctahedronGeometry = Ga, w.OctahedronBufferGeometry = fo, w.IcosahedronGeometry = Ha, w.IcosahedronBufferGeometry = ea, w.DodecahedronGeometry = ia, w.DodecahedronBufferGeometry = na, w.PolyhedronGeometry = Wi, w.PolyhedronBufferGeometry = yi, w.TubeGeometry = fn, w.TubeBufferGeometry = Hs, w.TorusKnotGeometry = Vr, w.TorusKnotBufferGeometry = po, w.TorusGeometry = mo, w.TorusBufferGeometry = Nn, w.TextGeometry = Wa, w.TextBufferGeometry = vo, w.SphereGeometry = Vs, w.SphereBufferGeometry = Er, w.RingGeometry = ja, w.RingBufferGeometry = _o, w.PlaneGeometry = ke, w.PlaneBufferGeometry = fe, w.LatheGeometry = oa, w.LatheBufferGeometry = Ws, w.ShapeGeometry = Cs, w.ShapeBufferGeometry = js, w.ExtrudeGeometry = As, w.ExtrudeBufferGeometry = ls, w.EdgesGeometry = Xs, w.ConeGeometry = aa, w.ConeBufferGeometry = Fn, w.CylinderGeometry = Ps, w.CylinderBufferGeometry = Ls, w.CircleGeometry = yo, w.CircleBufferGeometry = hs, w.BoxGeometry = Ot, w.BoxBufferGeometry = Bt, w.ShadowMaterial = qs, w.SpriteMaterial = Ui, w.RawShaderMaterial = xo, w.ShaderMaterial = ti, w.PointsMaterial = Bn, w.MeshPhysicalMaterial = wo, w.MeshStandardMaterial = us, w.MeshPhongMaterial = Wr, w.MeshToonMaterial = To, w.MeshNormalMaterial = Mo, w.MeshLambertMaterial = br, w.MeshDepthMaterial = oe, w.MeshDistanceMaterial = te, w.MeshBasicMaterial = Ge, w.MeshMatcapMaterial = So, w.LineDashedMaterial = Eo, w.LineBasicMaterial = Di, w.Material = Yt, w.Float64BufferAttribute = Ct, w.Float32BufferAttribute = Et, w.Uint32BufferAttribute = Pt, w.Int32BufferAttribute = G, w.Uint16BufferAttribute = yt, w.Int16BufferAttribute = et, w.Uint8ClampedBufferAttribute = It, w.Uint8BufferAttribute = ct, w.Int8BufferAttribute = $, w.BufferAttribute = J, w.ArcCurve = ua, w.CatmullRomCurve3 = Pn, w.CubicBezierCurve = rr, w.CubicBezierCurve3 = wi, w.EllipseCurve = Jn, w.LineCurve = sr, w.LineCurve3 = Cr, w.QuadraticBezierCurve = or, w.QuadraticBezierCurve3 = fs, w.SplineCurve = Xr, w.REVISION = "98", w.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, w.CullFaceNone = 0, w.CullFaceBack = 1, w.CullFaceFront = 2, w.CullFaceFrontBack = 3, w.FrontFaceDirectionCW = 0, w.FrontFaceDirectionCCW = 1, w.BasicShadowMap = 0, w.PCFShadowMap = 1, w.PCFSoftShadowMap = 2, w.FrontSide = 0, w.BackSide = 1, w.DoubleSide = 2, w.FlatShading = 1, w.SmoothShading = 2, w.NoColors = 0, w.FaceColors = 1, w.VertexColors = 2, w.NoBlending = 0, w.NormalBlending = 1, w.AdditiveBlending = 2, w.SubtractiveBlending = 3, w.MultiplyBlending = 4, w.CustomBlending = 5, w.AddEquation = 100, w.SubtractEquation = 101, w.ReverseSubtractEquation = 102, w.MinEquation = 103, w.MaxEquation = 104, w.ZeroFactor = 200, w.OneFactor = 201, w.SrcColorFactor = 202, w.OneMinusSrcColorFactor = 203, w.SrcAlphaFactor = 204, w.OneMinusSrcAlphaFactor = 205, w.DstAlphaFactor = 206, w.OneMinusDstAlphaFactor = 207, w.DstColorFactor = 208, w.OneMinusDstColorFactor = 209, w.SrcAlphaSaturateFactor = 210, w.NeverDepth = 0, w.AlwaysDepth = 1, w.LessDepth = 2, w.LessEqualDepth = 3, w.EqualDepth = 4, w.GreaterEqualDepth = 5, w.GreaterDepth = 6, w.NotEqualDepth = 7, w.MultiplyOperation = 0, w.MixOperation = 1, w.AddOperation = 2, w.NoToneMapping = 0, w.LinearToneMapping = 1, w.ReinhardToneMapping = 2, w.Uncharted2ToneMapping = 3, w.CineonToneMapping = 4, w.UVMapping = 300, w.CubeReflectionMapping = 301, w.CubeRefractionMapping = 302, w.EquirectangularReflectionMapping = 303, w.EquirectangularRefractionMapping = 304, w.SphericalReflectionMapping = 305, w.CubeUVReflectionMapping = 306, w.CubeUVRefractionMapping = 307, w.RepeatWrapping = 1e3, w.ClampToEdgeWrapping = 1001, w.MirroredRepeatWrapping = 1002, w.NearestFilter = 1003, w.NearestMipMapNearestFilter = 1004, w.NearestMipMapLinearFilter = 1005, w.LinearFilter = 1006, w.LinearMipMapNearestFilter = 1007, w.LinearMipMapLinearFilter = 1008, w.UnsignedByteType = 1009, w.ByteType = 1010, w.ShortType = 1011, w.UnsignedShortType = 1012, w.IntType = 1013, w.UnsignedIntType = 1014, w.FloatType = 1015, w.HalfFloatType = 1016, w.UnsignedShort4444Type = 1017, w.UnsignedShort5551Type = 1018, w.UnsignedShort565Type = 1019, w.UnsignedInt248Type = 1020, w.AlphaFormat = 1021, w.RGBFormat = 1022, w.RGBAFormat = 1023, w.LuminanceFormat = 1024, w.LuminanceAlphaFormat = 1025, w.RGBEFormat = 1023, w.DepthFormat = 1026, w.DepthStencilFormat = 1027, w.RedFormat = 1028, w.RGB_S3TC_DXT1_Format = 33776, w.RGBA_S3TC_DXT1_Format = 33777, w.RGBA_S3TC_DXT3_Format = 33778, w.RGBA_S3TC_DXT5_Format = 33779, w.RGB_PVRTC_4BPPV1_Format = 35840, w.RGB_PVRTC_2BPPV1_Format = 35841, w.RGBA_PVRTC_4BPPV1_Format = 35842, w.RGBA_PVRTC_2BPPV1_Format = 35843, w.RGB_ETC1_Format = 36196, w.RGBA_ASTC_4x4_Format = 37808, w.RGBA_ASTC_5x4_Format = 37809, w.RGBA_ASTC_5x5_Format = 37810, w.RGBA_ASTC_6x5_Format = 37811, w.RGBA_ASTC_6x6_Format = 37812, w.RGBA_ASTC_8x5_Format = 37813, w.RGBA_ASTC_8x6_Format = 37814, w.RGBA_ASTC_8x8_Format = 37815, w.RGBA_ASTC_10x5_Format = 37816, w.RGBA_ASTC_10x6_Format = 37817, w.RGBA_ASTC_10x8_Format = 37818, w.RGBA_ASTC_10x10_Format = 37819, w.RGBA_ASTC_12x10_Format = 37820, w.RGBA_ASTC_12x12_Format = 37821, w.LoopOnce = 2200, w.LoopRepeat = 2201, w.LoopPingPong = 2202, w.InterpolateDiscrete = 2300, w.InterpolateLinear = 2301, w.InterpolateSmooth = 2302, w.ZeroCurvatureEnding = 2400, w.ZeroSlopeEnding = 2401, w.WrapAroundEnding = 2402, w.TrianglesDrawMode = 0, w.TriangleStripDrawMode = 1, w.TriangleFanDrawMode = 2, w.LinearEncoding = 3e3, w.sRGBEncoding = 3001, w.GammaEncoding = 3007, w.RGBEEncoding = 3002, w.LogLuvEncoding = 3003, w.RGBM7Encoding = 3004, w.RGBM16Encoding = 3005, w.RGBDEncoding = 3006, w.BasicDepthPacking = 3200, w.RGBADepthPacking = 3201, w.TangentSpaceNormalMap = 0, w.ObjectSpaceNormalMap = 1, w.CubeGeometry = Ot, w.Face4 = function(t, e, i, n, s, a, c) {
    return console.warn(
      "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
    ), new R(t, e, i, s, a, c);
  }, w.LineStrip = 0, w.LinePieces = 1, w.MeshFaceMaterial = function(t) {
    return console.warn(
      "THREE.MeshFaceMaterial has been removed. Use an Array instead."
    ), t;
  }, w.MultiMaterial = function(t) {
    return t === void 0 && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
      return t.slice();
    }, t;
  }, w.PointCloud = function(t, e) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new $o(t, e);
  }, w.Particle = function(t) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Qi(t);
  }, w.ParticleSystem = function(t, e) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new $o(t, e);
  }, w.PointCloudMaterial = function(t) {
    return console.warn(
      "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
    ), new Bn(t);
  }, w.ParticleBasicMaterial = function(t) {
    return console.warn(
      "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
    ), new Bn(t);
  }, w.ParticleSystemMaterial = function(t) {
    return console.warn(
      "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
    ), new Bn(t);
  }, w.Vertex = function(t, e, i) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new u(t, e, i);
  }, w.DynamicBufferAttribute = function(t, e) {
    return console.warn(
      "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
    ), new J(t, e).setDynamic(!0);
  }, w.Int8Attribute = function(t, e) {
    return console.warn(
      "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
    ), new $(t, e);
  }, w.Uint8Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
    ), new ct(t, e);
  }, w.Uint8ClampedAttribute = function(t, e) {
    return console.warn(
      "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
    ), new It(t, e);
  }, w.Int16Attribute = function(t, e) {
    return console.warn(
      "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
    ), new et(t, e);
  }, w.Uint16Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
    ), new yt(t, e);
  }, w.Int32Attribute = function(t, e) {
    return console.warn(
      "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
    ), new G(t, e);
  }, w.Uint32Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
    ), new Pt(t, e);
  }, w.Float32Attribute = function(t, e) {
    return console.warn(
      "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
    ), new Et(t, e);
  }, w.Float64Attribute = function(t, e) {
    return console.warn(
      "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
    ), new Ct(t, e);
  }, w.ClosedSplineCurve3 = hu, w.SplineCurve3 = uu, w.Spline = Eh, w.AxisHelper = function(t) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new vr(t);
  }, w.BoundingBoxHelper = function(t, e) {
    return console.warn(
      "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
    ), new Is(t, e);
  }, w.EdgesHelper = function(t, e) {
    return console.warn(
      "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
    ), new mi(
      new Xs(t.geometry),
      new Di({ color: e !== void 0 ? e : 16777215 })
    );
  }, w.WireframeHelper = function(t, e) {
    return console.warn(
      "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
    ), new mi(
      new Ko(t.geometry),
      new Di({ color: e !== void 0 ? e : 16777215 })
    );
  }, w.XHRLoader = function(t) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Lt(t);
  }, w.BinaryTextureLoader = function(t) {
    return console.warn(
      "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
    ), new Ue(t);
  }, w.GeometryUtils = {
    merge: function(t, e, i) {
      if (console.warn(
        "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
      ), e.isMesh) {
        e.matrixAutoUpdate && e.updateMatrix();
        var n = e.matrix;
        e = e.geometry;
      }
      t.merge(e, n, i);
    },
    center: function(t) {
      return console.warn(
        "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
      ), t.center();
    }
  }, w.Projector = function() {
    console.error(
      "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
    ), this.projectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .projectVector() is now vector.project()."
      ), t.project(e);
    }, this.unprojectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .unprojectVector() is now vector.unproject()."
      ), t.unproject(e);
    }, this.pickingRay = function() {
      console.error(
        "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
      );
    };
  }, w.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  }, w.SceneUtils = {
    createMultiMaterialObject: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    detach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    attach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    }
  }, w.LensFlare = function() {
    console.error(
      "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
    );
  }, Object.defineProperty(w, "__esModule", { value: !0 });
});
THREE.Sky = function() {
  var w = THREE.Sky.SkyShader, l = new THREE.ShaderMaterial({
    fragmentShader: w.fragmentShader,
    vertexShader: w.vertexShader,
    uniforms: THREE.UniformsUtils.clone(w.uniforms),
    side: THREE.BackSide
  });
  THREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), l);
};
THREE.Sky.prototype = Object.create(THREE.Mesh.prototype);
THREE.Sky.SkyShader = {
  uniforms: {
    luminance: { value: 1 },
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new THREE.Vector3() }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    // wavelength of used primaries, according to preetham
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
    // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    // mie stuff
    // K coefficient for the primaries
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    // earth shadow hack
    // cutoffAngle = pi / 1.95;
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    // set z to camera.far
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    // extinction (absorbtion + out scattering)
    // rayleigh coefficients
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    // mie coefficients
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join(`
`),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float luminance;",
    "uniform float mieDirectionalG;",
    "const vec3 cameraPos = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    // refractive index of air
    "const float N = 2.545E25;",
    // number of molecules per unit volume for air at
    // 288.15K and 1013mb (sea level -45 celsius)
    // optical length at zenith for molecules
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // 66 arc seconds -> degrees, and the cosine of that
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    // 3.0 / ( 16.0 * pi )
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    // 1.0 / ( 4.0 * pi )
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    // Filmic ToneMapping http://filmicgames.com/archives/75
    "const float A = 0.15;",
    "const float B = 0.50;",
    "const float C = 0.10;",
    "const float D = 0.20;",
    "const float E = 0.02;",
    "const float F = 0.30;",
    "const float whiteScale = 1.0748724675633854;",
    // 1.0 / Uncharted2Tonemap(1000.0)
    "vec3 Uncharted2Tonemap( vec3 x ) {",
    "	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
    "}",
    "void main() {",
    // optical length
    // cutoff angle at 90 to avoid singularity in next formula.
    "	float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    // combined extinction factor
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    // in scattering
    "	float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    // nightsky
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    // composition + solar disc
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );",
    "	vec3 color = curr * whiteScale;",
    "	vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "}"
  ].join(`
`)
};
(function(w) {
  typeof module > "u" ? window.charming = w : module.exports = w;
})(function(w, l) {
  l = l || {};
  var o = l.tagName || "span", p = l.classPrefix != null ? l.classPrefix : "char", d = 1, u = function(m) {
    for (var _ = m.parentNode, T = m.nodeValue, S = T.length, C = -1; ++C < S; ) {
      var z = document.createElement(o);
      p && (z.className = p + d, d++), z.appendChild(document.createTextNode(T[C])), _.insertBefore(z, m);
    }
    _.removeChild(m);
  };
  return function m(_) {
    for (var T = [].slice.call(_.childNodes), S = T.length, C = -1; ++C < S; )
      m(T[C]);
    _.nodeType === Node.TEXT_NODE && u(_);
  }(w), w;
});
class c1 {
  constructor(l = []) {
    mars3d ? (this.tilesetLayer, this.modelArr = l, this.bimObliquePhotographyId = [], this.editDate = {
      id: null
    }) : console.error("未引入指定插件");
  }
  /**
   * 给 modelArr 添加数据
   * @param  { Object } mode 模型数据
   */
  pushModel(l) {
    this.modelArr.push(l);
  }
  /**
   * add 模型方法
   * @param  { Object || String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   * @param  { Object } customAttributes 自定义属性
   */
  add(l, o, p) {
    console.log("customAttributes", p);
    let d = p == null ? void 0 : p.isClone;
    const u = /* @__PURE__ */ new Map([
      ["click", mars3d.EventType.click],
      ["initialTilesLoaded", mars3d.EventType.initialTilesLoaded]
    ]);
    return new Promise((m, _) => {
      let T, S, C, z, B, I, F, E, L;
      if (typeof l != "object") {
        let b = this.query(l);
        b || _("缺少树结构");
        let { id: U, bimModelExcavationDetails: N, bimModel: j } = b;
        T = U, S = j.modelType, C = j.tender, z = j.releasedDistance, B = j.modelName, I = j.isDynamicReleased, F = {
          bimModelExcavationDetails: N
        }, E = b.url, L = j.modelColor;
      } else
        T = l.modelId, S = l.modelType, C = l.tender, z = l.releasedDistance, B = l.modelTitle, I = l.permission, F = l.customize, E = l.url, L = l.color;
      let x = { enabled: !0, precise: !1 }, M = { enabled: !0, precise: !1 };
      p && (p.color && (L = p.color), p.clip && (x.area = p.clip.handleDataList), p.flat && (M.area = p.flat.handleDataList));
      let R = window.map.getLayer(l, "modelId");
      if (R)
        return m(R), p.color && this.editColor(
          l,
          p.color,
          p
        ), !1;
      if (E.indexOf("tileset.json") < 0)
        return console.error("链接不完整", B), m({
          tite: "【模型】<" + B + ">链接地址有误",
          type: "error",
          id: T,
          url: E
        }), !1;
      new Cesium.Resource({
        url: E
      }).fetchJson().then((U) => {
        let N = null;
        L && (N = {
          color: { conditions: [["true", L]] }
        }), this.tilesetLayer = new mars3d.layer.TilesetLayer({
          modelId: T,
          modelType: S,
          tender: C,
          releasedDistance: z,
          modelTitle: B,
          permission: I,
          customize: F,
          url: encodeURI(E),
          skipLevelOfDetail: !1,
          loadSiblings: !0,
          cullRequestsWhileMoving: !0,
          cullRequestsWhileMovingMultiplier: 10,
          preferLeaves: !0,
          progressiveResolutionHeightFraction: 0.5,
          dynamicScreenSpaceError: !0,
          preloadWhenHidden: !1,
          style: N,
          clip: x,
          flat: M,
          maximumScreenSpaceError: 16,
          maximumMemoryUsage: 1024,
          cacheBytes: 1073741824 * 2,
          // 1024MB = 1024*1024*1024
          maximumCacheOverflowBytes: 2147483648 * 2
          // 2048MB = 2048*1024*1024
          // 1.04版本
          // customShader: new Cesium.CustomShader({
          //   lightingModel: Cesium.LightingModel.UNLIT,
          // }),
        }), this.tilesetLayer.bindPopup((j) => {
          if (j.graphic) {
            const J = j.graphic.attr;
            let $ = null, ct = null;
            return JSON.stringify(J) !== "{}" ? (J.name && ($ = J.name.lastIndexOf("@")), $ && $ > -1 && (ct = J.name.slice(0, $)), J.name ? `&nbsp;&nbsp;<span>${ct || J.name}</span>&nbsp;&nbsp;` : `&nbsp;&nbsp;<span>${B}</span>&nbsp;&nbsp;`) : `&nbsp;&nbsp;<span>${B}</span>&nbsp;&nbsp;`;
          } else
            return `&nbsp;&nbsp;<span>${B}</span>&nbsp;&nbsp;`;
        }), this.tilesetLayer.readyPromise.then((j) => {
          m(j);
          let { modelId: J } = j.options;
          j.clip.options.area.forEach(($) => {
            window.bimClip.activeObj[J][$.id].id == null && (window.bimClip.activeObj[J][$.id].id = $.id);
          });
        }).catch((j) => {
          m();
        }), this.tilesetLayer.on("click", (j) => {
          j.layer.style == null && map.bimMapEdit == "0" && j.layer.openHighlight(
            {
              color: "rgba(255,0,0,1)"
            },
            !0
          );
        }), o && Object.keys(o).forEach((j) => {
          this.tilesetLayer.on(u.get(j), (J) => {
            o[j](J);
          });
        }), S == 0 && this.bimObliquePhotographyId.push(T), d ? window.mapClone && window.mapClone.mapEx.addLayer(this.tilesetLayer) : window.map.addLayer(this.tilesetLayer);
      }).catch((U) => {
        console.error("数据加载失败", B), m({
          tite: "【模型】<" + B + ">无法加载",
          type: "error",
          id: T,
          url: E
        });
      });
    });
  }
  /**
   * 移除模型方法
   * @param  { String } id 模型id
   *
   */
  remove(l, o) {
    let p = o == null ? void 0 : o.isClone;
    window.map.getLayer(l, "modelId") && (p ? (window.mapClone.mapEx.getLayer(l, "modelId").closeHighlight(), window.mapClone.mapEx.removeLayer(
      window.mapClone.mapEx.getLayer(l, "modelId")
    )) : (window.map.getLayer(l, "modelId").closeHighlight(), window.map.removeLayer(window.map.getLayer(l, "modelId"))));
  }
  /**
   * 选中模型
   * @param  { String } id 模型id
   * @param  { Object } fn 自定义注册事件
   *
   */
  selected(l, o, p, d = !0) {
    return new Promise((u, m) => {
      let _ = window.map.getLayer(l, "modelId");
      _ ? (_.style == null && map.bimMapEdit == "0" && _.openHighlight(
        {
          color: "rgba(255,0,0,1)"
        },
        !0
      ), d ? _.flyTo({
        complete: () => {
          u(_);
        }
      }) : u(_)) : this.add(l, o, p).then((T) => {
        T && (T.style == null && map.bimMapEdit == "0" && T.openHighlight(
          {
            color: "rgba(255,0,0,1)"
          },
          !0
        ), d ? T.flyTo({
          complete: () => {
            u(T);
          }
        }) : u(T));
      });
    });
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArr = [], this.bimObliquePhotographyId = [], this.tilesetLayer = null;
  }
  /**
   * 查询动态释放模型方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(l) {
    return this.modelArr.length == 0 ? !1 : this.modelArr.find((o) => o.id == l);
  }
  /**
   * 查询矢量数据的实体
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 返回标绘实体
   */
  queryModel(l) {
    return window.map.getLayer(l, "modelId");
  }
  /**
   * 用户操作的模型
   * @param  { String } id 模型属性
   */
  postEditDate(l) {
    this.editDate = {
      id: l
    };
  }
  /**
   * 更新模型颜色
   * @param  { String | Object} id 模型属性 或者 模型对象
   * @param  { String | Number } newColor 需要着色的颜色
   * @param  { String } selectcontent 判断逻辑 默认是全部染色
   */
  editColor(l, o, p, d = "true") {
    let u, m = p == null ? void 0 : p.isClone;
    if (typeof l != "object" && (m ? u = window.mapClone.mapEx.getLayer(l, "modelId") : u = window.map.getLayer(l, "modelId")), u)
      if (o)
        u.style = {
          color: {
            conditions: [[d, o]]
          }
        };
      else {
        let _ = this.query(l).modelColor;
        _ ? u.style = {
          color: { conditions: [[d, _]] }
        } : u.style = null;
      }
  }
  /**
   * 更新模型透明度
   * @param  { String } id 模型属性
   * @param  { String | Number } opacity 透明度值
   */
  editOpacity(l, o) {
    window.map.getLayer(l, "modelId").opacity = o;
  }
  /**
   * 模型挖洞
   */
  addClip(l) {
    return new Promise((o, p) => {
      window.bimClip ? o(bimClip.clipModelAdd(l)) : p("挖洞工具未初始化");
    });
  }
  /**
   * 模型挖洞 移除
   */
  removeClip(l) {
    window.bimClip ? window.bimClip.clipModelremoveClip(l) : console.log("挖洞工具未初始化");
  }
}
const Lu = (w) => Object.prototype.toString.call(w) === "[object Object]";
function ku() {
  const w = Array.from(arguments);
  if (w.length < 2)
    return w[0];
  let l = w[0];
  return w.shift(), w.forEach((o) => {
    if (Lu(o)) {
      Lu(l) || (l = {});
      for (let p in o)
        l[p] && Lu(o[p]) ? l[p] = ku(l[p], o[p]) : l[p] = o[p];
    } else
      o instanceof Array && (l instanceof Array || (l = []), o.forEach((p, d) => {
        Lu(p) ? l[d] = ku(l[d]) : l[d] = p;
      }));
  }), l;
}
let Fh = {};
const zp = (w, l, o) => {
  Fh = {};
  let { vectorStyle: p, difference: d } = w;
  if (p) {
    let { divType: u } = p, m = "";
    if (u) {
      let {
        theme_color: _,
        title: T,
        font_color: S,
        content: C,
        scaleByDistance: z,
        scaleByDistance_far: B,
        scaleByDistance_farValue: I,
        scaleByDistance_near: F,
        scaleByDistance_nearValue: E,
        distanceDisplayCondition: L,
        distanceDisplayCondition_far: x,
        distanceDisplayCondition_near: M,
        clampToGround: R,
        divStyle: b
        // theme_color2,
        // theme_color3,
      } = p, { theme_color2: U, theme_color3: N } = b;
      switch (u) {
        case "1":
          m = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${_};--theme-font-color1:${S};">
            <div class="title">${T}</div>
          </div >`;
          break;
        case "2":
          m = `<div class="entity-div-style entity-div-style2" style="--theme-color1:${_};--theme-font-color1:${S};">
            <div class="title">${T}</div>
             <div class="mars3d-divUpLabel-line"></div>
          </div >`;
          break;
        case "3":
          m = `<div class="entity-div-style entity-div-style3" style="--theme-color1:${_};--theme-font-color1:${S};--theme-color2:${U};--theme-color3:${N}">
            <div class="image"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="infotop"><div class="title">${T}</div><div class="content overflow-auto scrollbar h-full">${C}</div></div>
          </div >`;
          break;
        case "4":
          m = `<div class="entity-div-style entity-div-style4" style="--theme-color1:${_};--theme-font-color1:${S};">
            <div class="title">${T}</div>
          </div >`;
          break;
        case "5":
          m = `<div class="entity-div-style entity-div-style5 marsTiltPanel marsTiltPanel-theme-green" style="--theme-color1:${_};--theme-font-color1:${S};--theme-color2:${U};">
            <div class="marsTiltPanel-wrap">
              <div class="area">
                <div class="arrow-lt"></div>
                <div class="b-t"></div>
                <div class="b-r"></div>
                <div class="b-b"></div>
                <div class="b-l"></div>
                <div class="arrow-rb"></div>
                <div class="label-wrap">
                  <div class="title">${T}</div>
                  <div class="content">${C}</div>
                </div>
              </div>
              <div class="b-t-l"></div>
              <div class="b-b-r"></div>
            </div>
            <div class="arrow"></div>
          </div >`;
          break;
        case "6":
          m = `<div class="entity-div-style entity-div-style6" style="--theme-color1:${_};--theme-font-color1:${S};--theme-color2:${U};">
            <div class="title">${T}</div>
          </div >`;
          break;
        case "7":
          m = `<div class="entity-div-style entity-div-style7" style="--theme-color1:${_};--theme-font-color1:${S};">
            <div class="title">${T}</div>
            <div class="pile-number">
              <div class="circular"></div>
              <div class="pole"></div>
            </div>
          </div >`;
          break;
      }
      Fh = {
        html: m,
        scaleByDistance: z,
        scaleByDistance_far: B,
        scaleByDistance_farValue: I,
        scaleByDistance_near: F,
        scaleByDistance_nearValue: E,
        distanceDisplayCondition: L,
        distanceDisplayCondition_far: x,
        distanceDisplayCondition_near: M,
        clampToGround: R
      };
    } else
      w.difference && w.difference.length > 0 && w.difference.forEach((_) => {
        ku(Fh, {
          [_]: p[_]
        });
      }), l && l.difference && l.difference.length > 0 && l.difference.forEach((_) => {
        ku(Fh, {
          label: {
            [_]: l.labelStyle[_]
          }
        });
      });
  }
  return Fh;
};
var zr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nf(w) {
  return w && w.__esModule && Object.prototype.hasOwnProperty.call(w, "default") ? w.default : w;
}
var Bu = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Bu.exports;
(function(w, l) {
  (function() {
    var o, p = "4.17.21", d = 200, u = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", m = "Expected a function", _ = "Invalid `variable` option passed into `_.template`", T = "__lodash_hash_undefined__", S = 500, C = "__lodash_placeholder__", z = 1, B = 2, I = 4, F = 1, E = 2, L = 1, x = 2, M = 4, R = 8, b = 16, U = 32, N = 64, j = 128, J = 256, $ = 512, ct = 30, It = "...", et = 800, yt = 16, G = 1, Pt = 2, Et = 3, Ct = 1 / 0, ce = 9007199254740991, re = 17976931348623157e292, Ft = 0 / 0, Ot = 4294967295, Bt = Ot - 1, ke = Ot >>> 1, fe = [
      ["ary", j],
      ["bind", L],
      ["bindKey", x],
      ["curry", R],
      ["curryRight", b],
      ["flip", $],
      ["partial", U],
      ["partialRight", N],
      ["rearg", J]
    ], Yt = "[object Arguments]", ti = "[object Array]", Ni = "[object AsyncFunction]", Oe = "[object Boolean]", Ge = "[object Date]", pi = "[object DOMException]", Li = "[object Error]", cn = "[object Function]", Ji = "[object GeneratorFunction]", W = "[object Map]", Jt = "[object Number]", Wt = "[object Null]", pt = "[object Object]", dt = "[object Promise]", Dt = "[object Proxy]", ie = "[object RegExp]", Kt = "[object Set]", D = "[object String]", Q = "[object Symbol]", ot = "[object Undefined]", nt = "[object WeakMap]", vt = "[object WeakSet]", Gt = "[object ArrayBuffer]", Xt = "[object DataView]", jt = "[object Float32Array]", Ne = "[object Float64Array]", Re = "[object Int8Array]", ge = "[object Int16Array]", we = "[object Int32Array]", vi = "[object Uint8Array]", Mi = "[object Uint8ClampedArray]", ni = "[object Uint16Array]", Si = "[object Uint32Array]", Gr = /\b__p \+= '';/g, er = /\b(__p \+=) '' \+/g, rn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, bs = /&(?:amp|lt|gt|quot|#39);/g, Ri = /[&<>"']/g, Us = RegExp(bs.source), is = RegExp(Ri.source), bl = /<%-([\s\S]+?)%>/g, xn = /<%([\s\S]+?)%>/g, Xo = /<%=([\s\S]+?)%>/g, ho = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, dr = /^\w*$/, qo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Da = /[\\^$.*+?()[\]{}|]/g, Al = RegExp(Da.source), ns = /^\s+/, ch = /\s/, Yo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, za = /\{\n\/\* \[wrapped with (.+)\] \*/, rs = /,? & /, ka = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Zo = /[()=,{}\[\]\/\s]/, Jo = /\\(\\)?/g, ss = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Cl = /\w*$/, fh = /^[-+]0x[0-9a-f]+$/i, ph = /^0b[01]+$/i, uo = /^\[object .+?Constructor\]$/, co = /^0o[0-7]+$/i, Pl = /^(?:0|[1-9]\d*)$/, Ll = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Hr = /($^)/, V = /['\n\r\u2028\u2029\\]/g, tt = "\\ud800-\\udfff", lt = "\\u0300-\\u036f", at = "\\ufe20-\\ufe2f", X = "\\u20d0-\\u20ff", St = lt + at + X, ht = "\\u2700-\\u27bf", Rt = "a-z\\xdf-\\xf6\\xf8-\\xff", Ht = "\\xac\\xb1\\xd7\\xf7", kt = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Mt = "\\u2000-\\u206f", he = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", oe = "A-Z\\xc0-\\xd6\\xd8-\\xde", te = "\\ufe0e\\ufe0f", _e = Ht + kt + Mt + he, ue = "['’]", je = "[" + tt + "]", He = "[" + _e + "]", ui = "[" + St + "]", Be = "\\d+", ye = "[" + ht + "]", Fe = "[" + Rt + "]", pe = "[^" + tt + _e + Be + ht + Rt + oe + "]", di = "\\ud83c[\\udffb-\\udfff]", Pe = "(?:" + ui + "|" + di + ")", xe = "[^" + tt + "]", Le = "(?:\\ud83c[\\udde6-\\uddff]){2}", wn = "[\\ud800-\\udbff][\\udc00-\\udfff]", Hn = "[" + oe + "]", Oi = "\\u200d", Ii = "(?:" + Fe + "|" + pe + ")", Ui = "(?:" + Hn + "|" + pe + ")", Qi = "(?:" + ue + "(?:d|ll|m|re|s|t|ve))?", tn = "(?:" + ue + "(?:D|LL|M|RE|S|T|VE))?", on = Pe + "?", an = "[" + te + "]?", Fi = "(?:" + Oi + "(?:" + [xe, Le, wn].join("|") + ")" + an + on + ")*", Di = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Vi = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", mi = an + on + Fi, os = "(?:" + [ye, Le, wn].join("|") + ")" + mi, Bn = "(?:" + [xe + ui + "?", ui, Le, wn, je].join("|") + ")", $o = RegExp(ue, "g"), dh = RegExp(ui, "g"), Gs = RegExp(di + "(?=" + di + ")|" + Bn + mi, "g"), Ba = RegExp([
      Hn + "?" + Fe + "+" + Qi + "(?=" + [He, Hn, "$"].join("|") + ")",
      Ui + "+" + tn + "(?=" + [He, Hn + Ii, "$"].join("|") + ")",
      Hn + "?" + Ii + "+" + Qi,
      Hn + "+" + tn,
      Vi,
      Di,
      Be,
      os
    ].join("|"), "g"), Na = RegExp("[" + Oi + tt + St + te + "]"), Ko = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Fa = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Qo = -1, Wi = {};
    Wi[jt] = Wi[Ne] = Wi[Re] = Wi[ge] = Wi[we] = Wi[vi] = Wi[Mi] = Wi[ni] = Wi[Si] = !0, Wi[Yt] = Wi[ti] = Wi[Gt] = Wi[Oe] = Wi[Xt] = Wi[Ge] = Wi[Li] = Wi[cn] = Wi[W] = Wi[Jt] = Wi[pt] = Wi[ie] = Wi[Kt] = Wi[D] = Wi[nt] = !1;
    var yi = {};
    yi[Yt] = yi[ti] = yi[Gt] = yi[Xt] = yi[Oe] = yi[Ge] = yi[jt] = yi[Ne] = yi[Re] = yi[ge] = yi[we] = yi[W] = yi[Jt] = yi[pt] = yi[ie] = yi[Kt] = yi[D] = yi[Q] = yi[vi] = yi[Mi] = yi[ni] = yi[Si] = !0, yi[Li] = yi[cn] = yi[nt] = !1;
    var Ua = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, ta = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Ga = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, fo = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Ha = parseFloat, ea = parseInt, ia = typeof zr == "object" && zr && zr.Object === Object && zr, na = typeof self == "object" && self && self.Object === Object && self, fn = ia || na || Function("return this")(), Hs = l && !l.nodeType && l, Vr = Hs && !0 && w && !w.nodeType && w, po = Vr && Vr.exports === Hs, mo = po && ia.process, Nn = function() {
      try {
        var Lt = Vr && Vr.require && Vr.require("util").types;
        return Lt || mo && mo.binding && mo.binding("util");
      } catch {
      }
    }(), mh = Nn && Nn.isArrayBuffer, ra = Nn && Nn.isDate, sa = Nn && Nn.isMap, tu = Nn && Nn.isRegExp, eu = Nn && Nn.isSet, Rl = Nn && Nn.isTypedArray;
    function mr(Lt, Qt, Zt) {
      switch (Zt.length) {
        case 0:
          return Lt.call(Qt);
        case 1:
          return Lt.call(Qt, Zt[0]);
        case 2:
          return Lt.call(Qt, Zt[0], Zt[1]);
        case 3:
          return Lt.call(Qt, Zt[0], Zt[1], Zt[2]);
      }
      return Lt.apply(Qt, Zt);
    }
    function Ol(Lt, Qt, Zt, Ue) {
      for (var oi = -1, zi = Lt == null ? 0 : Lt.length; ++oi < zi; ) {
        var ln = Lt[oi];
        Qt(Ue, ln, Zt(ln), Lt);
      }
      return Ue;
    }
    function Yi(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length; ++Zt < Ue && Qt(Lt[Zt], Zt, Lt) !== !1; )
        ;
      return Lt;
    }
    function go(Lt, Qt) {
      for (var Zt = Lt == null ? 0 : Lt.length; Zt-- && Qt(Lt[Zt], Zt, Lt) !== !1; )
        ;
      return Lt;
    }
    function gh(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length; ++Zt < Ue; )
        if (!Qt(Lt[Zt], Zt, Lt))
          return !1;
      return !0;
    }
    function Sr(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length, oi = 0, zi = []; ++Zt < Ue; ) {
        var ln = Lt[Zt];
        Qt(ln, Zt, Lt) && (zi[oi++] = ln);
      }
      return zi;
    }
    function Va(Lt, Qt) {
      var Zt = Lt == null ? 0 : Lt.length;
      return !!Zt && Er(Lt, Qt, 0) > -1;
    }
    function Il(Lt, Qt, Zt) {
      for (var Ue = -1, oi = Lt == null ? 0 : Lt.length; ++Ue < oi; )
        if (Zt(Qt, Lt[Ue]))
          return !0;
      return !1;
    }
    function Xi(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length, oi = Array(Ue); ++Zt < Ue; )
        oi[Zt] = Qt(Lt[Zt], Zt, Lt);
      return oi;
    }
    function as(Lt, Qt) {
      for (var Zt = -1, Ue = Qt.length, oi = Lt.length; ++Zt < Ue; )
        Lt[oi + Zt] = Qt[Zt];
      return Lt;
    }
    function Dl(Lt, Qt, Zt, Ue) {
      var oi = -1, zi = Lt == null ? 0 : Lt.length;
      for (Ue && zi && (Zt = Lt[++oi]); ++oi < zi; )
        Zt = Qt(Zt, Lt[oi], oi, Lt);
      return Zt;
    }
    function iu(Lt, Qt, Zt, Ue) {
      var oi = Lt == null ? 0 : Lt.length;
      for (Ue && oi && (Zt = Lt[--oi]); oi--; )
        Zt = Qt(Zt, Lt[oi], oi, Lt);
      return Zt;
    }
    function As(Lt, Qt) {
      for (var Zt = -1, Ue = Lt == null ? 0 : Lt.length; ++Zt < Ue; )
        if (Qt(Lt[Zt], Zt, Lt))
          return !0;
      return !1;
    }
    var ls = Ws("length");
    function nu(Lt) {
      return Lt.split("");
    }
    function Wa(Lt) {
      return Lt.match(ka) || [];
    }
    function vo(Lt, Qt, Zt) {
      var Ue;
      return Zt(Lt, function(oi, zi, ln) {
        if (Qt(oi, zi, ln))
          return Ue = zi, !1;
      }), Ue;
    }
    function Vs(Lt, Qt, Zt, Ue) {
      for (var oi = Lt.length, zi = Zt + (Ue ? 1 : -1); Ue ? zi-- : ++zi < oi; )
        if (Qt(Lt[zi], zi, Lt))
          return zi;
      return -1;
    }
    function Er(Lt, Qt, Zt) {
      return Qt === Qt ? zl(Lt, Qt, Zt) : Vs(Lt, _o, Zt);
    }
    function ja(Lt, Qt, Zt, Ue) {
      for (var oi = Zt - 1, zi = Lt.length; ++oi < zi; )
        if (Ue(Lt[oi], Qt))
          return oi;
      return -1;
    }
    function _o(Lt) {
      return Lt !== Lt;
    }
    function oa(Lt, Qt) {
      var Zt = Lt == null ? 0 : Lt.length;
      return Zt ? Xs(Lt, Qt) / Zt : Ft;
    }
    function Ws(Lt) {
      return function(Qt) {
        return Qt == null ? o : Qt[Lt];
      };
    }
    function Cs(Lt) {
      return function(Qt) {
        return Lt == null ? o : Lt[Qt];
      };
    }
    function js(Lt, Qt, Zt, Ue, oi) {
      return oi(Lt, function(zi, ln, Ee) {
        Zt = Ue ? (Ue = !1, zi) : Qt(Zt, zi, ln, Ee);
      }), Zt;
    }
    function ru(Lt, Qt) {
      var Zt = Lt.length;
      for (Lt.sort(Qt); Zt--; )
        Lt[Zt] = Lt[Zt].value;
      return Lt;
    }
    function Xs(Lt, Qt) {
      for (var Zt, Ue = -1, oi = Lt.length; ++Ue < oi; ) {
        var zi = Qt(Lt[Ue]);
        zi !== o && (Zt = Zt === o ? zi : Zt + zi);
      }
      return Zt;
    }
    function Ps(Lt, Qt) {
      for (var Zt = -1, Ue = Array(Lt); ++Zt < Lt; )
        Ue[Zt] = Qt(Zt);
      return Ue;
    }
    function Ls(Lt, Qt) {
      return Xi(Qt, function(Zt) {
        return [Zt, Lt[Zt]];
      });
    }
    function aa(Lt) {
      return Lt && Lt.slice(0, la(Lt) + 1).replace(ns, "");
    }
    function Fn(Lt) {
      return function(Qt) {
        return Lt(Qt);
      };
    }
    function yo(Lt, Qt) {
      return Xi(Qt, function(Zt) {
        return Lt[Zt];
      });
    }
    function hs(Lt, Qt) {
      return Lt.has(Qt);
    }
    function qs(Lt, Qt) {
      for (var Zt = -1, Ue = Lt.length; ++Zt < Ue && Er(Qt, Lt[Zt], 0) > -1; )
        ;
      return Zt;
    }
    function xo(Lt, Qt) {
      for (var Zt = Lt.length; Zt-- && Er(Qt, Lt[Zt], 0) > -1; )
        ;
      return Zt;
    }
    function us(Lt, Qt) {
      for (var Zt = Lt.length, Ue = 0; Zt--; )
        Lt[Zt] === Qt && ++Ue;
      return Ue;
    }
    var wo = Cs(Ua), Wr = Cs(ta);
    function To(Lt) {
      return "\\" + fo[Lt];
    }
    function Mo(Lt, Qt) {
      return Lt == null ? o : Lt[Qt];
    }
    function br(Lt) {
      return Na.test(Lt);
    }
    function So(Lt) {
      return Ko.test(Lt);
    }
    function Eo(Lt) {
      for (var Qt, Zt = []; !(Qt = Lt.next()).done; )
        Zt.push(Qt.value);
      return Zt;
    }
    function Zn(Lt) {
      var Qt = -1, Zt = Array(Lt.size);
      return Lt.forEach(function(Ue, oi) {
        Zt[++Qt] = [oi, Ue];
      }), Zt;
    }
    function Xa(Lt, Qt) {
      return function(Zt) {
        return Lt(Qt(Zt));
      };
    }
    function Ar(Lt, Qt) {
      for (var Zt = -1, Ue = Lt.length, oi = 0, zi = []; ++Zt < Ue; ) {
        var ln = Lt[Zt];
        (ln === Qt || ln === C) && (Lt[Zt] = C, zi[oi++] = Zt);
      }
      return zi;
    }
    function bo(Lt) {
      var Qt = -1, Zt = Array(Lt.size);
      return Lt.forEach(function(Ue) {
        Zt[++Qt] = Ue;
      }), Zt;
    }
    function Un(Lt) {
      var Qt = -1, Zt = Array(Lt.size);
      return Lt.forEach(function(Ue) {
        Zt[++Qt] = [Ue, Ue];
      }), Zt;
    }
    function zl(Lt, Qt, Zt) {
      for (var Ue = Zt - 1, oi = Lt.length; ++Ue < oi; )
        if (Lt[Ue] === Qt)
          return Ue;
      return -1;
    }
    function kl(Lt, Qt, Zt) {
      for (var Ue = Zt + 1; Ue--; )
        if (Lt[Ue] === Qt)
          return Ue;
      return Ue;
    }
    function jr(Lt) {
      return br(Lt) ? ha(Lt) : ls(Lt);
    }
    function ir(Lt) {
      return br(Lt) ? gr(Lt) : nu(Lt);
    }
    function la(Lt) {
      for (var Qt = Lt.length; Qt-- && ch.test(Lt.charAt(Qt)); )
        ;
      return Qt;
    }
    var Bl = Cs(Ga);
    function ha(Lt) {
      for (var Qt = Gs.lastIndex = 0; Gs.test(Lt); )
        ++Qt;
      return Qt;
    }
    function gr(Lt) {
      return Lt.match(Gs) || [];
    }
    function Ju(Lt) {
      return Lt.match(Ba) || [];
    }
    var $u = function Lt(Qt) {
      Qt = Qt == null ? fn : Ys.defaults(fn.Object(), Qt, Ys.pick(fn, Fa));
      var Zt = Qt.Array, Ue = Qt.Date, oi = Qt.Error, zi = Qt.Function, ln = Qt.Math, Ee = Qt.Object, Jn = Qt.RegExp, ua = Qt.String, nr = Qt.TypeError, Pn = Zt.prototype, su = zi.prototype, cs = Ee.prototype, Zs = Qt["__core-js_shared__"], rr = su.toString, wi = cs.hasOwnProperty, sr = 0, Cr = function() {
        var r = /[^.]+$/.exec(Zs && Zs.keys && Zs.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : "";
      }(), or = cs.toString, fs = rr.call(Ee), Xr = fn._, Rs = Jn(
        "^" + rr.call(wi).replace(Da, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), ar = po ? Qt.Buffer : o, $n = Qt.Symbol, $i = Qt.Uint8Array, qa = ar ? ar.allocUnsafe : o, ps = Xa(Ee.getPrototypeOf, Ee), Ya = Ee.create, Za = cs.propertyIsEnumerable, Ao = Pn.splice, ca = $n ? $n.isConcatSpreadable : o, Js = $n ? $n.iterator : o, ds = $n ? $n.toStringTag : o, Co = function() {
        try {
          var r = fl(Ee, "defineProperty");
          return r({}, "", {}), r;
        } catch {
        }
      }(), Nl = Qt.clearTimeout !== fn.clearTimeout && Qt.clearTimeout, Fl = Ue && Ue.now !== fn.Date.now && Ue.now, vh = Qt.setTimeout !== fn.setTimeout && Qt.setTimeout, Os = ln.ceil, Po = ln.floor, Ja = Ee.getOwnPropertySymbols, _h = ar ? ar.isBuffer : o, Ul = Qt.isFinite, yh = Pn.join, ou = Xa(Ee.keys, Ee), pn = ln.max, Gn = ln.min, $a = Ue.now, xh = Qt.parseInt, Gl = ln.random, fa = Pn.reverse, Ka = fl(Qt, "DataView"), Lo = fl(Qt, "Map"), Qa = fl(Qt, "Promise"), Ro = fl(Qt, "Set"), Tn = fl(Qt, "WeakMap"), pa = fl(Ee, "create"), tl = Tn && new Tn(), $s = {}, Hl = pl(Ka), wh = pl(Lo), Th = pl(Qa), Mh = pl(Ro), au = pl(Tn), el = $n ? $n.prototype : o, Oo = el ? el.valueOf : o, Sh = el ? el.toString : o;
      function it(r) {
        if (An(r) && !gi(r) && !(r instanceof _i)) {
          if (r instanceof Vn)
            return r;
          if (wi.call(r, "__wrapped__"))
            return zf(r);
        }
        return new Vn(r);
      }
      var Ks = function() {
        function r() {
        }
        return function(h) {
          if (!vn(h))
            return {};
          if (Ya)
            return Ya(h);
          r.prototype = h;
          var g = new r();
          return r.prototype = o, g;
        };
      }();
      function da() {
      }
      function Vn(r, h) {
        this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = o;
      }
      it.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: bl,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: xn,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Xo,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: it
        }
      }, it.prototype = da.prototype, it.prototype.constructor = it, Vn.prototype = Ks(da.prototype), Vn.prototype.constructor = Vn;
      function _i(r) {
        this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Ot, this.__views__ = [];
      }
      function ma() {
        var r = new _i(this.__wrapped__);
        return r.__actions__ = Qn(this.__actions__), r.__dir__ = this.__dir__, r.__filtered__ = this.__filtered__, r.__iteratees__ = Qn(this.__iteratees__), r.__takeCount__ = this.__takeCount__, r.__views__ = Qn(this.__views__), r;
      }
      function lu() {
        if (this.__filtered__) {
          var r = new _i(this);
          r.__dir__ = -1, r.__filtered__ = !0;
        } else
          r = this.clone(), r.__dir__ *= -1;
        return r;
      }
      function ga() {
        var r = this.__wrapped__.value(), h = this.__dir__, g = gi(r), O = h < 0, Y = g ? r.length : 0, ut = Gd(0, Y, this.__views__), _t = ut.start, bt = ut.end, Nt = bt - _t, se = O ? bt : _t - 1, le = this.__iteratees__, de = le.length, ze = 0, Je = Gn(Nt, this.__takeCount__);
        if (!g || !O && Y == Nt && Je == Nt)
          return ri(r, this.__actions__);
        var li = [];
        t:
          for (; Nt-- && ze < Je; ) {
            se += h;
            for (var Ti = -1, hi = r[se]; ++Ti < de; ) {
              var Ci = le[Ti], ki = Ci.iteratee, Zr = Ci.type, wr = ki(hi);
              if (Zr == Pt)
                hi = wr;
              else if (!wr) {
                if (Zr == G)
                  continue t;
                break t;
              }
            }
            li[ze++] = hi;
          }
        return li;
      }
      _i.prototype = Ks(da.prototype), _i.prototype.constructor = _i;
      function Pr(r) {
        var h = -1, g = r == null ? 0 : r.length;
        for (this.clear(); ++h < g; ) {
          var O = r[h];
          this.set(O[0], O[1]);
        }
      }
      function va() {
        this.__data__ = pa ? pa(null) : {}, this.size = 0;
      }
      function _a(r) {
        var h = this.has(r) && delete this.__data__[r];
        return this.size -= h ? 1 : 0, h;
      }
      function il(r) {
        var h = this.__data__;
        if (pa) {
          var g = h[r];
          return g === T ? o : g;
        }
        return wi.call(h, r) ? h[r] : o;
      }
      function Vl(r) {
        var h = this.__data__;
        return pa ? h[r] !== o : wi.call(h, r);
      }
      function nl(r, h) {
        var g = this.__data__;
        return this.size += this.has(r) ? 0 : 1, g[r] = pa && h === o ? T : h, this;
      }
      Pr.prototype.clear = va, Pr.prototype.delete = _a, Pr.prototype.get = il, Pr.prototype.has = Vl, Pr.prototype.set = nl;
      function lr(r) {
        var h = -1, g = r == null ? 0 : r.length;
        for (this.clear(); ++h < g; ) {
          var O = r[h];
          this.set(O[0], O[1]);
        }
      }
      function rl() {
        this.__data__ = [], this.size = 0;
      }
      function Is(r) {
        var h = this.__data__, g = al(h, r);
        if (g < 0)
          return !1;
        var O = h.length - 1;
        return g == O ? h.pop() : Ao.call(h, g, 1), --this.size, !0;
      }
      function sl(r) {
        var h = this.__data__, g = al(h, r);
        return g < 0 ? o : h[g][1];
      }
      function ol(r) {
        return al(this.__data__, r) > -1;
      }
      function Ds(r, h) {
        var g = this.__data__, O = al(g, r);
        return O < 0 ? (++this.size, g.push([r, h])) : g[O][1] = h, this;
      }
      lr.prototype.clear = rl, lr.prototype.delete = Is, lr.prototype.get = sl, lr.prototype.has = ol, lr.prototype.set = Ds;
      function vr(r) {
        var h = -1, g = r == null ? 0 : r.length;
        for (this.clear(); ++h < g; ) {
          var O = r[h];
          this.set(O[0], O[1]);
        }
      }
      function hu() {
        this.size = 0, this.__data__ = {
          hash: new Pr(),
          map: new (Lo || lr)(),
          string: new Pr()
        };
      }
      function uu(r) {
        var h = xu(this, r).delete(r);
        return this.size -= h ? 1 : 0, h;
      }
      function Eh(r) {
        return xu(this, r).get(r);
      }
      function fi(r) {
        return xu(this, r).has(r);
      }
      function Qs(r, h) {
        var g = xu(this, r), O = g.size;
        return g.set(r, h), this.size += g.size == O ? 0 : 1, this;
      }
      vr.prototype.clear = hu, vr.prototype.delete = uu, vr.prototype.get = Eh, vr.prototype.has = fi, vr.prototype.set = Qs;
      function Io(r) {
        var h = -1, g = r == null ? 0 : r.length;
        for (this.__data__ = new vr(); ++h < g; )
          this.add(r[h]);
      }
      function Ei(r) {
        return this.__data__.set(r, T), this;
      }
      function Dn(r) {
        return this.__data__.has(r);
      }
      Io.prototype.add = Io.prototype.push = Ei, Io.prototype.has = Dn;
      function qr(r) {
        var h = this.__data__ = new lr(r);
        this.size = h.size;
      }
      function qe() {
        this.__data__ = new lr(), this.size = 0;
      }
      function ms(r) {
        var h = this.__data__, g = h.delete(r);
        return this.size = h.size, g;
      }
      function Ku(r) {
        return this.__data__.get(r);
      }
      function Qu(r) {
        return this.__data__.has(r);
      }
      function tc(r, h) {
        var g = this.__data__;
        if (g instanceof lr) {
          var O = g.__data__;
          if (!Lo || O.length < d - 1)
            return O.push([r, h]), this.size = ++g.size, this;
          g = this.__data__ = new vr(O);
        }
        return g.set(r, h), this.size = g.size, this;
      }
      qr.prototype.clear = qe, qr.prototype.delete = ms, qr.prototype.get = Ku, qr.prototype.has = Qu, qr.prototype.set = tc;
      function cu(r, h) {
        var g = gi(r), O = !g && dl(r), Y = !g && !O && Ea(r), ut = !g && !O && !Y && Kl(r), _t = g || O || Y || ut, bt = _t ? Ps(r.length, ua) : [], Nt = bt.length;
        for (var se in r)
          (h || wi.call(r, se)) && !(_t && // Safari 9 has enumerable `arguments.length` in strict mode.
          (se == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          Y && (se == "offset" || se == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ut && (se == "buffer" || se == "byteLength" || se == "byteOffset") || // Skip index properties.
          No(se, Nt))) && bt.push(se);
        return bt;
      }
      function bh(r) {
        var h = r.length;
        return h ? r[me(0, h - 1)] : o;
      }
      function ec(r, h) {
        return wu(Qn(r), to(h, 0, r.length));
      }
      function fu(r) {
        return wu(Qn(r));
      }
      function Wl(r, h, g) {
        (g !== o && !Ns(r[h], g) || g === o && !(h in r)) && zs(r, h, g);
      }
      function ya(r, h, g) {
        var O = r[h];
        (!(wi.call(r, h) && Ns(O, g)) || g === o && !(h in r)) && zs(r, h, g);
      }
      function al(r, h) {
        for (var g = r.length; g--; )
          if (Ns(r[g][0], h))
            return g;
        return -1;
      }
      function pu(r, h, g, O) {
        return dn(r, function(Y, ut, _t) {
          h(O, Y, g(Y), _t);
        }), O;
      }
      function Ah(r, h) {
        return r && Ln(h, Xn(h), r);
      }
      function Ch(r, h) {
        return r && Ln(h, Ir(h), r);
      }
      function zs(r, h, g) {
        h == "__proto__" && Co ? Co(r, h, {
          configurable: !0,
          enumerable: !0,
          value: g,
          writable: !0
        }) : r[h] = g;
      }
      function Ph(r, h) {
        for (var g = -1, O = h.length, Y = Zt(O), ut = r == null; ++g < O; )
          Y[g] = ut ? o : vc(r, h[g]);
        return Y;
      }
      function to(r, h, g) {
        return r === r && (g !== o && (r = r <= g ? r : g), h !== o && (r = r >= h ? r : h)), r;
      }
      function _r(r, h, g, O, Y, ut) {
        var _t, bt = h & z, Nt = h & B, se = h & I;
        if (g && (_t = Y ? g(r, O, Y, ut) : g(r)), _t !== o)
          return _t;
        if (!vn(r))
          return r;
        var le = gi(r);
        if (le) {
          if (_t = Vd(r), !bt)
            return Qn(r, _t);
        } else {
          var de = ur(r), ze = de == cn || de == Ji;
          if (Ea(r))
            return ks(r, bt);
          if (de == pt || de == Yt || ze && !Y) {
            if (_t = Nt || ze ? {} : bf(r), !bt)
              return Nt ? vu(r, Ch(_t, r)) : _s(r, Ah(_t, r));
          } else {
            if (!yi[de])
              return Y ? r : {};
            _t = Wd(r, de, bt);
          }
        }
        ut || (ut = new qr());
        var Je = ut.get(r);
        if (Je)
          return Je;
        ut.set(r, _t), ep(r) ? r.forEach(function(hi) {
          _t.add(_r(hi, h, g, hi, r, ut));
        }) : Qf(r) && r.forEach(function(hi, Ci) {
          _t.set(Ci, _r(hi, h, g, Ci, r, ut));
        });
        var li = se ? Nt ? nc : ic : Nt ? Ir : Xn, Ti = le ? o : li(r);
        return Yi(Ti || r, function(hi, Ci) {
          Ti && (Ci = hi, hi = r[Ci]), ya(_t, Ci, _r(hi, h, g, Ci, r, ut));
        }), _t;
      }
      function xa(r) {
        var h = Xn(r);
        return function(g) {
          return du(g, r, h);
        };
      }
      function du(r, h, g) {
        var O = g.length;
        if (r == null)
          return !O;
        for (r = Ee(r); O--; ) {
          var Y = g[O], ut = h[Y], _t = r[Y];
          if (_t === o && !(Y in r) || !ut(_t))
            return !1;
        }
        return !0;
      }
      function gs(r, h, g) {
        if (typeof r != "function")
          throw new nr(m);
        return Bh(function() {
          r.apply(o, g);
        }, h);
      }
      function ll(r, h, g, O) {
        var Y = -1, ut = Va, _t = !0, bt = r.length, Nt = [], se = h.length;
        if (!bt)
          return Nt;
        g && (h = Xi(h, Fn(g))), O ? (ut = Il, _t = !1) : h.length >= d && (ut = hs, _t = !1, h = new Io(h));
        t:
          for (; ++Y < bt; ) {
            var le = r[Y], de = g == null ? le : g(le);
            if (le = O || le !== 0 ? le : 0, _t && de === de) {
              for (var ze = se; ze--; )
                if (h[ze] === de)
                  continue t;
              Nt.push(le);
            } else
              ut(h, de, O) || Nt.push(le);
          }
        return Nt;
      }
      var dn = ft(Rr), mu = ft(Xl, !0);
      function Wn(r, h) {
        var g = !0;
        return dn(r, function(O, Y, ut) {
          return g = !!h(O, Y, ut), g;
        }), g;
      }
      function vs(r, h, g) {
        for (var O = -1, Y = r.length; ++O < Y; ) {
          var ut = r[O], _t = h(ut);
          if (_t != null && (bt === o ? _t === _t && !Yr(_t) : g(_t, bt)))
            var bt = _t, Nt = ut;
        }
        return Nt;
      }
      function Kn(r, h, g, O) {
        var Y = r.length;
        for (g = xi(g), g < 0 && (g = -g > Y ? 0 : Y + g), O = O === o || O > Y ? Y : xi(O), O < 0 && (O += Y), O = g > O ? 0 : np(O); g < O; )
          r[g++] = h;
        return r;
      }
      function Lr(r, h) {
        var g = [];
        return dn(r, function(O, Y, ut) {
          h(O, Y, ut) && g.push(O);
        }), g;
      }
      function Mn(r, h, g, O, Y) {
        var ut = -1, _t = r.length;
        for (g || (g = Xd), Y || (Y = []); ++ut < _t; ) {
          var bt = r[ut];
          h > 0 && g(bt) ? h > 1 ? Mn(bt, h - 1, g, O, Y) : as(Y, bt) : O || (Y[Y.length] = bt);
        }
        return Y;
      }
      var hl = Tt(), jl = Tt(!0);
      function Rr(r, h) {
        return r && hl(r, h, Xn);
      }
      function Xl(r, h) {
        return r && jl(r, h, Xn);
      }
      function Do(r, h) {
        return Sr(h, function(g) {
          return Fo(r[g]);
        });
      }
      function eo(r, h) {
        h = Ze(h, r);
        for (var g = 0, O = h.length; r != null && g < O; )
          r = r[no(h[g++])];
        return g && g == O ? r : o;
      }
      function gu(r, h, g) {
        var O = h(r);
        return gi(r) ? O : as(O, g(r));
      }
      function jn(r) {
        return r == null ? r === o ? ot : Wt : ds && ds in Ee(r) ? Ud(r) : Qd(r);
      }
      function ql(r, h) {
        return r > h;
      }
      function Yl(r, h) {
        return r != null && wi.call(r, h);
      }
      function Lh(r, h) {
        return r != null && h in Ee(r);
      }
      function Zl(r, h, g) {
        return r >= Gn(h, g) && r < pn(h, g);
      }
      function ul(r, h, g) {
        for (var O = g ? Il : Va, Y = r[0].length, ut = r.length, _t = ut, bt = Zt(ut), Nt = 1 / 0, se = []; _t--; ) {
          var le = r[_t];
          _t && h && (le = Xi(le, Fn(h))), Nt = Gn(le.length, Nt), bt[_t] = !g && (h || Y >= 120 && le.length >= 120) ? new Io(_t && le) : o;
        }
        le = r[0];
        var de = -1, ze = bt[0];
        t:
          for (; ++de < Y && se.length < Nt; ) {
            var Je = le[de], li = h ? h(Je) : Je;
            if (Je = g || Je !== 0 ? Je : 0, !(ze ? hs(ze, li) : O(se, li, g))) {
              for (_t = ut; --_t; ) {
                var Ti = bt[_t];
                if (!(Ti ? hs(Ti, li) : O(r[_t], li, g)))
                  continue t;
              }
              ze && ze.push(li), se.push(Je);
            }
          }
        return se;
      }
      function t(r, h, g, O) {
        return Rr(r, function(Y, ut, _t) {
          h(O, g(Y), ut, _t);
        }), O;
      }
      function e(r, h, g) {
        h = Ze(h, r), r = Lf(r, h);
        var O = r == null ? r : r[no(xs(h))];
        return O == null ? o : mr(O, r, g);
      }
      function i(r) {
        return An(r) && jn(r) == Yt;
      }
      function n(r) {
        return An(r) && jn(r) == Gt;
      }
      function s(r) {
        return An(r) && jn(r) == Ge;
      }
      function a(r, h, g, O, Y) {
        return r === h ? !0 : r == null || h == null || !An(r) && !An(h) ? r !== r && h !== h : c(r, h, g, O, a, Y);
      }
      function c(r, h, g, O, Y, ut) {
        var _t = gi(r), bt = gi(h), Nt = _t ? ti : ur(r), se = bt ? ti : ur(h);
        Nt = Nt == Yt ? pt : Nt, se = se == Yt ? pt : se;
        var le = Nt == pt, de = se == pt, ze = Nt == se;
        if (ze && Ea(r)) {
          if (!Ea(h))
            return !1;
          _t = !0, le = !1;
        }
        if (ze && !le)
          return ut || (ut = new qr()), _t || Kl(r) ? Mf(r, h, g, O, Y, ut) : Nd(r, h, Nt, g, O, Y, ut);
        if (!(g & F)) {
          var Je = le && wi.call(r, "__wrapped__"), li = de && wi.call(h, "__wrapped__");
          if (Je || li) {
            var Ti = Je ? r.value() : r, hi = li ? h.value() : h;
            return ut || (ut = new qr()), Y(Ti, hi, g, O, ut);
          }
        }
        return ze ? (ut || (ut = new qr()), Fd(r, h, g, O, Y, ut)) : !1;
      }
      function f(r) {
        return An(r) && ur(r) == W;
      }
      function v(r, h, g, O) {
        var Y = g.length, ut = Y, _t = !O;
        if (r == null)
          return !ut;
        for (r = Ee(r); Y--; ) {
          var bt = g[Y];
          if (_t && bt[2] ? bt[1] !== r[bt[0]] : !(bt[0] in r))
            return !1;
        }
        for (; ++Y < ut; ) {
          bt = g[Y];
          var Nt = bt[0], se = r[Nt], le = bt[1];
          if (_t && bt[2]) {
            if (se === o && !(Nt in r))
              return !1;
          } else {
            var de = new qr();
            if (O)
              var ze = O(se, le, Nt, r, h, de);
            if (!(ze === o ? a(le, se, F | E, O, de) : ze))
              return !1;
          }
        }
        return !0;
      }
      function y(r) {
        if (!vn(r) || Yd(r))
          return !1;
        var h = Fo(r) ? Rs : uo;
        return h.test(pl(r));
      }
      function A(r) {
        return An(r) && jn(r) == ie;
      }
      function P(r) {
        return An(r) && ur(r) == Kt;
      }
      function k(r) {
        return An(r) && Au(r.length) && !!Wi[jn(r)];
      }
      function H(r) {
        return typeof r == "function" ? r : r == null ? Dr : typeof r == "object" ? gi(r) ? At(r[0], r[1]) : gt(r) : dp(r);
      }
      function q(r) {
        if (!kh(r))
          return ou(r);
        var h = [];
        for (var g in Ee(r))
          wi.call(r, g) && g != "constructor" && h.push(g);
        return h;
      }
      function K(r) {
        if (!vn(r))
          return Kd(r);
        var h = kh(r), g = [];
        for (var O in r)
          O == "constructor" && (h || !wi.call(r, O)) || g.push(O);
        return g;
      }
      function rt(r, h) {
        return r < h;
      }
      function xt(r, h) {
        var g = -1, O = Or(r) ? Zt(r.length) : [];
        return dn(r, function(Y, ut, _t) {
          O[++g] = h(Y, ut, _t);
        }), O;
      }
      function gt(r) {
        var h = sc(r);
        return h.length == 1 && h[0][2] ? Cf(h[0][0], h[0][1]) : function(g) {
          return g === r || v(g, r, h);
        };
      }
      function At(r, h) {
        return ac(r) && Af(h) ? Cf(no(r), h) : function(g) {
          var O = vc(g, r);
          return O === o && O === h ? _c(g, r) : a(h, O, F | E);
        };
      }
      function wt(r, h, g, O, Y) {
        r !== h && hl(h, function(ut, _t) {
          if (Y || (Y = new qr()), vn(ut))
            Vt(r, h, _t, g, wt, O, Y);
          else {
            var bt = O ? O(hc(r, _t), ut, _t + "", r, h, Y) : o;
            bt === o && (bt = ut), Wl(r, _t, bt);
          }
        }, Ir);
      }
      function Vt(r, h, g, O, Y, ut, _t) {
        var bt = hc(r, g), Nt = hc(h, g), se = _t.get(Nt);
        if (se) {
          Wl(r, g, se);
          return;
        }
        var le = ut ? ut(bt, Nt, g + "", r, h, _t) : o, de = le === o;
        if (de) {
          var ze = gi(Nt), Je = !ze && Ea(Nt), li = !ze && !Je && Kl(Nt);
          le = Nt, ze || Je || li ? gi(bt) ? le = bt : Rn(bt) ? le = Qn(bt) : Je ? (de = !1, le = ks(Nt, !0)) : li ? (de = !1, le = cl(Nt, !0)) : le = [] : Nh(Nt) || dl(Nt) ? (le = bt, dl(bt) ? le = rp(bt) : (!vn(bt) || Fo(bt)) && (le = bf(Nt))) : de = !1;
        }
        de && (_t.set(Nt, le), Y(le, Nt, O, ut, _t), _t.delete(Nt)), Wl(r, g, le);
      }
      function Z(r, h) {
        var g = r.length;
        if (g)
          return h += h < 0 ? g : 0, No(h, g) ? r[h] : o;
      }
      function st(r, h, g) {
        h.length ? h = Xi(h, function(ut) {
          return gi(ut) ? function(_t) {
            return eo(_t, ut.length === 1 ? ut[0] : ut);
          } : ut;
        }) : h = [Dr];
        var O = -1;
        h = Xi(h, Fn(si()));
        var Y = xt(r, function(ut, _t, bt) {
          var Nt = Xi(h, function(se) {
            return se(ut);
          });
          return { criteria: Nt, index: ++O, value: ut };
        });
        return ru(Y, function(ut, _t) {
          return io(ut, _t, g);
        });
      }
      function zt(r, h) {
        return ee(r, h, function(g, O) {
          return _c(r, O);
        });
      }
      function ee(r, h, g) {
        for (var O = -1, Y = h.length, ut = {}; ++O < Y; ) {
          var _t = h[O], bt = eo(r, _t);
          g(bt, _t) && ci(ut, Ze(_t, r), bt);
        }
        return ut;
      }
      function $t(r) {
        return function(h) {
          return eo(h, r);
        };
      }
      function qt(r, h, g, O) {
        var Y = O ? ja : Er, ut = -1, _t = h.length, bt = r;
        for (r === h && (h = Qn(h)), g && (bt = Xi(r, Fn(g))); ++ut < _t; )
          for (var Nt = 0, se = h[ut], le = g ? g(se) : se; (Nt = Y(bt, le, Nt, O)) > -1; )
            bt !== r && Ao.call(bt, Nt, 1), Ao.call(r, Nt, 1);
        return r;
      }
      function Te(r, h) {
        for (var g = r ? h.length : 0, O = g - 1; g--; ) {
          var Y = h[g];
          if (g == O || Y !== ut) {
            var ut = Y;
            No(Y) ? Ao.call(r, Y, 1) : Hi(r, Y);
          }
        }
        return r;
      }
      function me(r, h) {
        return r + Po(Gl() * (h - r + 1));
      }
      function Ie(r, h, g, O) {
        for (var Y = -1, ut = pn(Os((h - r) / (g || 1)), 0), _t = Zt(ut); ut--; )
          _t[O ? ut : ++Y] = r, r += g;
        return _t;
      }
      function be(r, h) {
        var g = "";
        if (!r || h < 1 || h > ce)
          return g;
        do
          h % 2 && (g += r), h = Po(h / 2), h && (r += r);
        while (h);
        return g;
      }
      function ae(r, h) {
        return uc(Pf(r, h, Dr), r + "");
      }
      function We(r) {
        return bh(Ql(r));
      }
      function Ke(r, h) {
        var g = Ql(r);
        return wu(g, to(h, 0, g.length));
      }
      function ci(r, h, g, O) {
        if (!vn(r))
          return r;
        h = Ze(h, r);
        for (var Y = -1, ut = h.length, _t = ut - 1, bt = r; bt != null && ++Y < ut; ) {
          var Nt = no(h[Y]), se = g;
          if (Nt === "__proto__" || Nt === "constructor" || Nt === "prototype")
            return r;
          if (Y != _t) {
            var le = bt[Nt];
            se = O ? O(le, Nt, bt) : o, se === o && (se = vn(le) ? le : No(h[Y + 1]) ? [] : {});
          }
          ya(bt, Nt, se), bt = bt[Nt];
        }
        return r;
      }
      var Sn = tl ? function(r, h) {
        return tl.set(r, h), r;
      } : Dr, mn = Co ? function(r, h) {
        return Co(r, "toString", {
          configurable: !0,
          enumerable: !1,
          value: xc(h),
          writable: !0
        });
      } : Dr;
      function ji(r) {
        return wu(Ql(r));
      }
      function Gi(r, h, g) {
        var O = -1, Y = r.length;
        h < 0 && (h = -h > Y ? 0 : Y + h), g = g > Y ? Y : g, g < 0 && (g += Y), Y = h > g ? 0 : g - h >>> 0, h >>>= 0;
        for (var ut = Zt(Y); ++O < Y; )
          ut[O] = r[O + h];
        return ut;
      }
      function en(r, h) {
        var g;
        return dn(r, function(O, Y, ut) {
          return g = h(O, Y, ut), !g;
        }), !!g;
      }
      function En(r, h, g) {
        var O = 0, Y = r == null ? O : r.length;
        if (typeof h == "number" && h === h && Y <= ke) {
          for (; O < Y; ) {
            var ut = O + Y >>> 1, _t = r[ut];
            _t !== null && !Yr(_t) && (g ? _t <= h : _t < h) ? O = ut + 1 : Y = ut;
          }
          return Y;
        }
        return Ae(r, h, Dr, g);
      }
      function Ae(r, h, g, O) {
        var Y = 0, ut = r == null ? 0 : r.length;
        if (ut === 0)
          return 0;
        h = g(h);
        for (var _t = h !== h, bt = h === null, Nt = Yr(h), se = h === o; Y < ut; ) {
          var le = Po((Y + ut) / 2), de = g(r[le]), ze = de !== o, Je = de === null, li = de === de, Ti = Yr(de);
          if (_t)
            var hi = O || li;
          else
            se ? hi = li && (O || ze) : bt ? hi = li && ze && (O || !Je) : Nt ? hi = li && ze && !Je && (O || !Ti) : Je || Ti ? hi = !1 : hi = O ? de <= h : de < h;
          hi ? Y = le + 1 : ut = le;
        }
        return Gn(ut, Bt);
      }
      function Qe(r, h) {
        for (var g = -1, O = r.length, Y = 0, ut = []; ++g < O; ) {
          var _t = r[g], bt = h ? h(_t) : _t;
          if (!g || !Ns(bt, Nt)) {
            var Nt = bt;
            ut[Y++] = _t === 0 ? 0 : _t;
          }
        }
        return ut;
      }
      function Ut(r) {
        return typeof r == "number" ? r : Yr(r) ? Ft : +r;
      }
      function Ye(r) {
        if (typeof r == "string")
          return r;
        if (gi(r))
          return Xi(r, Ye) + "";
        if (Yr(r))
          return Sh ? Sh.call(r) : "";
        var h = r + "";
        return h == "0" && 1 / r == -Ct ? "-0" : h;
      }
      function ei(r, h, g) {
        var O = -1, Y = Va, ut = r.length, _t = !0, bt = [], Nt = bt;
        if (g)
          _t = !1, Y = Il;
        else if (ut >= d) {
          var se = h ? null : Sa(r);
          if (se)
            return bo(se);
          _t = !1, Y = hs, Nt = new Io();
        } else
          Nt = h ? [] : bt;
        t:
          for (; ++O < ut; ) {
            var le = r[O], de = h ? h(le) : le;
            if (le = g || le !== 0 ? le : 0, _t && de === de) {
              for (var ze = Nt.length; ze--; )
                if (Nt[ze] === de)
                  continue t;
              h && Nt.push(de), bt.push(le);
            } else
              Y(Nt, de, g) || (Nt !== bt && Nt.push(de), bt.push(le));
          }
        return bt;
      }
      function Hi(r, h) {
        return h = Ze(h, r), r = Lf(r, h), r == null || delete r[no(xs(h))];
      }
      function Ce(r, h, g, O) {
        return ci(r, h, g(eo(r, h)), O);
      }
      function Xe(r, h, g, O) {
        for (var Y = r.length, ut = O ? Y : -1; (O ? ut-- : ++ut < Y) && h(r[ut], ut, r); )
          ;
        return g ? Gi(r, O ? 0 : ut, O ? ut + 1 : Y) : Gi(r, O ? ut + 1 : 0, O ? Y : ut);
      }
      function ri(r, h) {
        var g = r;
        return g instanceof _i && (g = g.value()), Dl(h, function(O, Y) {
          return Y.func.apply(Y.thisArg, as([O], Y.args));
        }, g);
      }
      function Ai(r, h, g) {
        var O = r.length;
        if (O < 2)
          return O ? ei(r[0]) : [];
        for (var Y = -1, ut = Zt(O); ++Y < O; )
          for (var _t = r[Y], bt = -1; ++bt < O; )
            bt != Y && (ut[Y] = ll(ut[Y] || _t, r[bt], h, g));
        return ei(Mn(ut, 1), h, g);
      }
      function bi(r, h, g) {
        for (var O = -1, Y = r.length, ut = h.length, _t = {}; ++O < Y; ) {
          var bt = O < ut ? h[O] : o;
          g(_t, r[O], bt);
        }
        return _t;
      }
      function ne(r) {
        return Rn(r) ? r : [];
      }
      function ii(r) {
        return typeof r == "function" ? r : Dr;
      }
      function Ze(r, h) {
        return gi(r) ? r : ac(r, h) ? [r] : Df(qi(r));
      }
      var ai = ae;
      function gn(r, h, g) {
        var O = r.length;
        return g = g === o ? O : g, !h && g >= O ? r : Gi(r, h, g);
      }
      var bn = Nl || function(r) {
        return fn.clearTimeout(r);
      };
      function ks(r, h) {
        if (h)
          return r.slice();
        var g = r.length, O = qa ? qa(g) : new r.constructor(g);
        return r.copy(O), O;
      }
      function wa(r) {
        var h = new r.constructor(r.byteLength);
        return new $i(h).set(new $i(r)), h;
      }
      function Rh(r, h) {
        var g = h ? wa(r.buffer) : r.buffer;
        return new r.constructor(g, r.byteOffset, r.byteLength);
      }
      function Ta(r) {
        var h = new r.constructor(r.source, Cl.exec(r));
        return h.lastIndex = r.lastIndex, h;
      }
      function zo(r) {
        return Oo ? Ee(Oo.call(r)) : {};
      }
      function cl(r, h) {
        var g = h ? wa(r.buffer) : r.buffer;
        return new r.constructor(g, r.byteOffset, r.length);
      }
      function ko(r, h) {
        if (r !== h) {
          var g = r !== o, O = r === null, Y = r === r, ut = Yr(r), _t = h !== o, bt = h === null, Nt = h === h, se = Yr(h);
          if (!bt && !se && !ut && r > h || ut && _t && Nt && !bt && !se || O && _t && Nt || !g && Nt || !Y)
            return 1;
          if (!O && !ut && !se && r < h || se && g && Y && !O && !ut || bt && g && Y || !_t && Y || !Nt)
            return -1;
        }
        return 0;
      }
      function io(r, h, g) {
        for (var O = -1, Y = r.criteria, ut = h.criteria, _t = Y.length, bt = g.length; ++O < _t; ) {
          var Nt = ko(Y[O], ut[O]);
          if (Nt) {
            if (O >= bt)
              return Nt;
            var se = g[O];
            return Nt * (se == "desc" ? -1 : 1);
          }
        }
        return r.index - h.index;
      }
      function Oh(r, h, g, O) {
        for (var Y = -1, ut = r.length, _t = g.length, bt = -1, Nt = h.length, se = pn(ut - _t, 0), le = Zt(Nt + se), de = !O; ++bt < Nt; )
          le[bt] = h[bt];
        for (; ++Y < _t; )
          (de || Y < ut) && (le[g[Y]] = r[Y]);
        for (; se--; )
          le[bt++] = r[Y++];
        return le;
      }
      function Ih(r, h, g, O) {
        for (var Y = -1, ut = r.length, _t = -1, bt = g.length, Nt = -1, se = h.length, le = pn(ut - bt, 0), de = Zt(le + se), ze = !O; ++Y < le; )
          de[Y] = r[Y];
        for (var Je = Y; ++Nt < se; )
          de[Je + Nt] = h[Nt];
        for (; ++_t < bt; )
          (ze || Y < ut) && (de[Je + g[_t]] = r[Y++]);
        return de;
      }
      function Qn(r, h) {
        var g = -1, O = r.length;
        for (h || (h = Zt(O)); ++g < O; )
          h[g] = r[g];
        return h;
      }
      function Ln(r, h, g, O) {
        var Y = !g;
        g || (g = {});
        for (var ut = -1, _t = h.length; ++ut < _t; ) {
          var bt = h[ut], Nt = O ? O(g[bt], r[bt], bt, g, r) : o;
          Nt === o && (Nt = r[bt]), Y ? zs(g, bt, Nt) : ya(g, bt, Nt);
        }
        return g;
      }
      function _s(r, h) {
        return Ln(r, oc(r), h);
      }
      function vu(r, h) {
        return Ln(r, Sf(r), h);
      }
      function Ma(r, h) {
        return function(g, O) {
          var Y = gi(g) ? Ol : pu, ut = h ? h() : {};
          return Y(g, r, si(O, 2), ut);
        };
      }
      function Bs(r) {
        return ae(function(h, g) {
          var O = -1, Y = g.length, ut = Y > 1 ? g[Y - 1] : o, _t = Y > 2 ? g[2] : o;
          for (ut = r.length > 3 && typeof ut == "function" ? (Y--, ut) : o, _t && xr(g[0], g[1], _t) && (ut = Y < 3 ? o : ut, Y = 1), h = Ee(h); ++O < Y; ) {
            var bt = g[O];
            bt && r(h, bt, O, ut);
          }
          return h;
        });
      }
      function ft(r, h) {
        return function(g, O) {
          if (g == null)
            return g;
          if (!Or(g))
            return r(g, O);
          for (var Y = g.length, ut = h ? Y : -1, _t = Ee(g); (h ? ut-- : ++ut < Y) && O(_t[ut], ut, _t) !== !1; )
            ;
          return g;
        };
      }
      function Tt(r) {
        return function(h, g, O) {
          for (var Y = -1, ut = Ee(h), _t = O(h), bt = _t.length; bt--; ) {
            var Nt = _t[r ? bt : ++Y];
            if (g(ut[Nt], Nt, ut) === !1)
              break;
          }
          return h;
        };
      }
      function mt(r, h, g) {
        var O = h & L, Y = Ve(r);
        function ut() {
          var _t = this && this !== fn && this instanceof ut ? Y : r;
          return _t.apply(O ? g : this, arguments);
        }
        return ut;
      }
      function Me(r) {
        return function(h) {
          h = qi(h);
          var g = br(h) ? ir(h) : o, O = g ? g[0] : h.charAt(0), Y = g ? gn(g, 1).join("") : h.slice(1);
          return O[r]() + Y;
        };
      }
      function De(r) {
        return function(h) {
          return Dl(fp(cp(h).replace($o, "")), r, "");
        };
      }
      function Ve(r) {
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return new r();
            case 1:
              return new r(h[0]);
            case 2:
              return new r(h[0], h[1]);
            case 3:
              return new r(h[0], h[1], h[2]);
            case 4:
              return new r(h[0], h[1], h[2], h[3]);
            case 5:
              return new r(h[0], h[1], h[2], h[3], h[4]);
            case 6:
              return new r(h[0], h[1], h[2], h[3], h[4], h[5]);
            case 7:
              return new r(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
          }
          var g = Ks(r.prototype), O = r.apply(g, h);
          return vn(O) ? O : g;
        };
      }
      function Se(r, h, g) {
        var O = Ve(r);
        function Y() {
          for (var ut = arguments.length, _t = Zt(ut), bt = ut, Nt = $l(Y); bt--; )
            _t[bt] = arguments[bt];
          var se = ut < 3 && _t[0] !== Nt && _t[ut - 1] !== Nt ? [] : Ar(_t, Nt);
          if (ut -= se.length, ut < g)
            return zh(
              r,
              h,
              Zi,
              Y.placeholder,
              o,
              _t,
              se,
              o,
              o,
              g - ut
            );
          var le = this && this !== fn && this instanceof Y ? O : r;
          return mr(le, this, _t);
        }
        return Y;
      }
      function $e(r) {
        return function(h, g, O) {
          var Y = Ee(h);
          if (!Or(h)) {
            var ut = si(g, 3);
            h = Xn(h), g = function(bt) {
              return ut(Y[bt], bt, Y);
            };
          }
          var _t = r(h, g, O);
          return _t > -1 ? Y[ut ? h[_t] : _t] : o;
        };
      }
      function Pi(r) {
        return Bo(function(h) {
          var g = h.length, O = g, Y = Vn.prototype.thru;
          for (r && h.reverse(); O--; ) {
            var ut = h[O];
            if (typeof ut != "function")
              throw new nr(m);
            if (Y && !_t && yu(ut) == "wrapper")
              var _t = new Vn([], !0);
          }
          for (O = _t ? O : g; ++O < g; ) {
            ut = h[O];
            var bt = yu(ut), Nt = bt == "wrapper" ? rc(ut) : o;
            Nt && lc(Nt[0]) && Nt[1] == (j | R | U | J) && !Nt[4].length && Nt[9] == 1 ? _t = _t[yu(Nt[0])].apply(_t, Nt[3]) : _t = ut.length == 1 && lc(ut) ? _t[bt]() : _t.thru(ut);
          }
          return function() {
            var se = arguments, le = se[0];
            if (_t && se.length == 1 && gi(le))
              return _t.plant(le).value();
            for (var de = 0, ze = g ? h[de].apply(this, se) : le; ++de < g; )
              ze = h[de].call(this, ze);
            return ze;
          };
        });
      }
      function Zi(r, h, g, O, Y, ut, _t, bt, Nt, se) {
        var le = h & j, de = h & L, ze = h & x, Je = h & (R | b), li = h & $, Ti = ze ? o : Ve(r);
        function hi() {
          for (var Ci = arguments.length, ki = Zt(Ci), Zr = Ci; Zr--; )
            ki[Zr] = arguments[Zr];
          if (Je)
            var wr = $l(hi), Jr = us(ki, wr);
          if (O && (ki = Oh(ki, O, Y, Je)), ut && (ki = Ih(ki, ut, _t, Je)), Ci -= Jr, Je && Ci < se) {
            var On = Ar(ki, wr);
            return zh(
              r,
              h,
              Zi,
              hi.placeholder,
              g,
              ki,
              On,
              bt,
              Nt,
              se - Ci
            );
          }
          var Fs = de ? g : this, Go = ze ? Fs[r] : r;
          return Ci = ki.length, bt ? ki = tm(ki, bt) : li && Ci > 1 && ki.reverse(), le && Nt < Ci && (ki.length = Nt), this && this !== fn && this instanceof hi && (Go = Ti || Ve(Go)), Go.apply(Fs, ki);
        }
        return hi;
      }
      function ve(r, h) {
        return function(g, O) {
          return t(g, r, h(O), {});
        };
      }
      function yr(r, h) {
        return function(g, O) {
          var Y;
          if (g === o && O === o)
            return h;
          if (g !== o && (Y = g), O !== o) {
            if (Y === o)
              return O;
            typeof g == "string" || typeof O == "string" ? (g = Ye(g), O = Ye(O)) : (g = Ut(g), O = Ut(O)), Y = r(g, O);
          }
          return Y;
        };
      }
      function zn(r) {
        return Bo(function(h) {
          return h = Xi(h, Fn(si())), ae(function(g) {
            var O = this;
            return r(h, function(Y) {
              return mr(Y, O, g);
            });
          });
        });
      }
      function sn(r, h) {
        h = h === o ? " " : Ye(h);
        var g = h.length;
        if (g < 2)
          return g ? be(h, r) : h;
        var O = be(h, Os(r / jr(h)));
        return br(h) ? gn(ir(O), 0, r).join("") : O.slice(0, r);
      }
      function hr(r, h, g, O) {
        var Y = h & L, ut = Ve(r);
        function _t() {
          for (var bt = -1, Nt = arguments.length, se = -1, le = O.length, de = Zt(le + Nt), ze = this && this !== fn && this instanceof _t ? ut : r; ++se < le; )
            de[se] = O[se];
          for (; Nt--; )
            de[se++] = arguments[++bt];
          return mr(ze, Y ? g : this, de);
        }
        return _t;
      }
      function Dh(r) {
        return function(h, g, O) {
          return O && typeof O != "number" && xr(h, g, O) && (g = O = o), h = Uo(h), g === o ? (g = h, h = 0) : g = Uo(g), O = O === o ? h < g ? 1 : -1 : Uo(O), Ie(h, g, O, r);
        };
      }
      function ys(r) {
        return function(h, g) {
          return typeof h == "string" && typeof g == "string" || (h = ws(h), g = ws(g)), r(h, g);
        };
      }
      function zh(r, h, g, O, Y, ut, _t, bt, Nt, se) {
        var le = h & R, de = le ? _t : o, ze = le ? o : _t, Je = le ? ut : o, li = le ? o : ut;
        h |= le ? U : N, h &= ~(le ? N : U), h & M || (h &= ~(L | x));
        var Ti = [
          r,
          h,
          Y,
          Je,
          de,
          li,
          ze,
          bt,
          Nt,
          se
        ], hi = g.apply(o, Ti);
        return lc(r) && Rf(hi, Ti), hi.placeholder = O, Of(hi, r, h);
      }
      function Jl(r) {
        var h = ln[r];
        return function(g, O) {
          if (g = ws(g), O = O == null ? 0 : Gn(xi(O), 292), O && Ul(g)) {
            var Y = (qi(g) + "e").split("e"), ut = h(Y[0] + "e" + (+Y[1] + O));
            return Y = (qi(ut) + "e").split("e"), +(Y[0] + "e" + (+Y[1] - O));
          }
          return h(g);
        };
      }
      var Sa = Ro && 1 / bo(new Ro([, -0]))[1] == Ct ? function(r) {
        return new Ro(r);
      } : Mc;
      function _u(r) {
        return function(h) {
          var g = ur(h);
          return g == W ? Zn(h) : g == Kt ? Un(h) : Ls(h, r(h));
        };
      }
      function tr(r, h, g, O, Y, ut, _t, bt) {
        var Nt = h & x;
        if (!Nt && typeof r != "function")
          throw new nr(m);
        var se = O ? O.length : 0;
        if (se || (h &= ~(U | N), O = Y = o), _t = _t === o ? _t : pn(xi(_t), 0), bt = bt === o ? bt : xi(bt), se -= Y ? Y.length : 0, h & N) {
          var le = O, de = Y;
          O = Y = o;
        }
        var ze = Nt ? o : rc(r), Je = [
          r,
          h,
          g,
          O,
          Y,
          le,
          de,
          ut,
          _t,
          bt
        ];
        if (ze && $d(Je, ze), r = Je[0], h = Je[1], g = Je[2], O = Je[3], Y = Je[4], bt = Je[9] = Je[9] === o ? Nt ? 0 : r.length : pn(Je[9] - se, 0), !bt && h & (R | b) && (h &= ~(R | b)), !h || h == L)
          var li = mt(r, h, g);
        else
          h == R || h == b ? li = Se(r, h, bt) : (h == U || h == (L | U)) && !Y.length ? li = hr(r, h, g, O) : li = Zi.apply(o, Je);
        var Ti = ze ? Sn : Rf;
        return Of(Ti(li, Je), r, h);
      }
      function wf(r, h, g, O) {
        return r === o || Ns(r, cs[g]) && !wi.call(O, g) ? h : r;
      }
      function Tf(r, h, g, O, Y, ut) {
        return vn(r) && vn(h) && (ut.set(h, r), wt(r, h, o, Tf, ut), ut.delete(h)), r;
      }
      function Bd(r) {
        return Nh(r) ? o : r;
      }
      function Mf(r, h, g, O, Y, ut) {
        var _t = g & F, bt = r.length, Nt = h.length;
        if (bt != Nt && !(_t && Nt > bt))
          return !1;
        var se = ut.get(r), le = ut.get(h);
        if (se && le)
          return se == h && le == r;
        var de = -1, ze = !0, Je = g & E ? new Io() : o;
        for (ut.set(r, h), ut.set(h, r); ++de < bt; ) {
          var li = r[de], Ti = h[de];
          if (O)
            var hi = _t ? O(Ti, li, de, h, r, ut) : O(li, Ti, de, r, h, ut);
          if (hi !== o) {
            if (hi)
              continue;
            ze = !1;
            break;
          }
          if (Je) {
            if (!As(h, function(Ci, ki) {
              if (!hs(Je, ki) && (li === Ci || Y(li, Ci, g, O, ut)))
                return Je.push(ki);
            })) {
              ze = !1;
              break;
            }
          } else if (!(li === Ti || Y(li, Ti, g, O, ut))) {
            ze = !1;
            break;
          }
        }
        return ut.delete(r), ut.delete(h), ze;
      }
      function Nd(r, h, g, O, Y, ut, _t) {
        switch (g) {
          case Xt:
            if (r.byteLength != h.byteLength || r.byteOffset != h.byteOffset)
              return !1;
            r = r.buffer, h = h.buffer;
          case Gt:
            return !(r.byteLength != h.byteLength || !ut(new $i(r), new $i(h)));
          case Oe:
          case Ge:
          case Jt:
            return Ns(+r, +h);
          case Li:
            return r.name == h.name && r.message == h.message;
          case ie:
          case D:
            return r == h + "";
          case W:
            var bt = Zn;
          case Kt:
            var Nt = O & F;
            if (bt || (bt = bo), r.size != h.size && !Nt)
              return !1;
            var se = _t.get(r);
            if (se)
              return se == h;
            O |= E, _t.set(r, h);
            var le = Mf(bt(r), bt(h), O, Y, ut, _t);
            return _t.delete(r), le;
          case Q:
            if (Oo)
              return Oo.call(r) == Oo.call(h);
        }
        return !1;
      }
      function Fd(r, h, g, O, Y, ut) {
        var _t = g & F, bt = ic(r), Nt = bt.length, se = ic(h), le = se.length;
        if (Nt != le && !_t)
          return !1;
        for (var de = Nt; de--; ) {
          var ze = bt[de];
          if (!(_t ? ze in h : wi.call(h, ze)))
            return !1;
        }
        var Je = ut.get(r), li = ut.get(h);
        if (Je && li)
          return Je == h && li == r;
        var Ti = !0;
        ut.set(r, h), ut.set(h, r);
        for (var hi = _t; ++de < Nt; ) {
          ze = bt[de];
          var Ci = r[ze], ki = h[ze];
          if (O)
            var Zr = _t ? O(ki, Ci, ze, h, r, ut) : O(Ci, ki, ze, r, h, ut);
          if (!(Zr === o ? Ci === ki || Y(Ci, ki, g, O, ut) : Zr)) {
            Ti = !1;
            break;
          }
          hi || (hi = ze == "constructor");
        }
        if (Ti && !hi) {
          var wr = r.constructor, Jr = h.constructor;
          wr != Jr && "constructor" in r && "constructor" in h && !(typeof wr == "function" && wr instanceof wr && typeof Jr == "function" && Jr instanceof Jr) && (Ti = !1);
        }
        return ut.delete(r), ut.delete(h), Ti;
      }
      function Bo(r) {
        return uc(Pf(r, o, Nf), r + "");
      }
      function ic(r) {
        return gu(r, Xn, oc);
      }
      function nc(r) {
        return gu(r, Ir, Sf);
      }
      var rc = tl ? function(r) {
        return tl.get(r);
      } : Mc;
      function yu(r) {
        for (var h = r.name + "", g = $s[h], O = wi.call($s, h) ? g.length : 0; O--; ) {
          var Y = g[O], ut = Y.func;
          if (ut == null || ut == r)
            return Y.name;
        }
        return h;
      }
      function $l(r) {
        var h = wi.call(it, "placeholder") ? it : r;
        return h.placeholder;
      }
      function si() {
        var r = it.iteratee || wc;
        return r = r === wc ? H : r, arguments.length ? r(arguments[0], arguments[1]) : r;
      }
      function xu(r, h) {
        var g = r.__data__;
        return qd(h) ? g[typeof h == "string" ? "string" : "hash"] : g.map;
      }
      function sc(r) {
        for (var h = Xn(r), g = h.length; g--; ) {
          var O = h[g], Y = r[O];
          h[g] = [O, Y, Af(Y)];
        }
        return h;
      }
      function fl(r, h) {
        var g = Mo(r, h);
        return y(g) ? g : o;
      }
      function Ud(r) {
        var h = wi.call(r, ds), g = r[ds];
        try {
          r[ds] = o;
          var O = !0;
        } catch {
        }
        var Y = or.call(r);
        return O && (h ? r[ds] = g : delete r[ds]), Y;
      }
      var oc = Ja ? function(r) {
        return r == null ? [] : (r = Ee(r), Sr(Ja(r), function(h) {
          return Za.call(r, h);
        }));
      } : Sc, Sf = Ja ? function(r) {
        for (var h = []; r; )
          as(h, oc(r)), r = ps(r);
        return h;
      } : Sc, ur = jn;
      (Ka && ur(new Ka(new ArrayBuffer(1))) != Xt || Lo && ur(new Lo()) != W || Qa && ur(Qa.resolve()) != dt || Ro && ur(new Ro()) != Kt || Tn && ur(new Tn()) != nt) && (ur = function(r) {
        var h = jn(r), g = h == pt ? r.constructor : o, O = g ? pl(g) : "";
        if (O)
          switch (O) {
            case Hl:
              return Xt;
            case wh:
              return W;
            case Th:
              return dt;
            case Mh:
              return Kt;
            case au:
              return nt;
          }
        return h;
      });
      function Gd(r, h, g) {
        for (var O = -1, Y = g.length; ++O < Y; ) {
          var ut = g[O], _t = ut.size;
          switch (ut.type) {
            case "drop":
              r += _t;
              break;
            case "dropRight":
              h -= _t;
              break;
            case "take":
              h = Gn(h, r + _t);
              break;
            case "takeRight":
              r = pn(r, h - _t);
              break;
          }
        }
        return { start: r, end: h };
      }
      function Hd(r) {
        var h = r.match(za);
        return h ? h[1].split(rs) : [];
      }
      function Ef(r, h, g) {
        h = Ze(h, r);
        for (var O = -1, Y = h.length, ut = !1; ++O < Y; ) {
          var _t = no(h[O]);
          if (!(ut = r != null && g(r, _t)))
            break;
          r = r[_t];
        }
        return ut || ++O != Y ? ut : (Y = r == null ? 0 : r.length, !!Y && Au(Y) && No(_t, Y) && (gi(r) || dl(r)));
      }
      function Vd(r) {
        var h = r.length, g = new r.constructor(h);
        return h && typeof r[0] == "string" && wi.call(r, "index") && (g.index = r.index, g.input = r.input), g;
      }
      function bf(r) {
        return typeof r.constructor == "function" && !kh(r) ? Ks(ps(r)) : {};
      }
      function Wd(r, h, g) {
        var O = r.constructor;
        switch (h) {
          case Gt:
            return wa(r);
          case Oe:
          case Ge:
            return new O(+r);
          case Xt:
            return Rh(r, g);
          case jt:
          case Ne:
          case Re:
          case ge:
          case we:
          case vi:
          case Mi:
          case ni:
          case Si:
            return cl(r, g);
          case W:
            return new O();
          case Jt:
          case D:
            return new O(r);
          case ie:
            return Ta(r);
          case Kt:
            return new O();
          case Q:
            return zo(r);
        }
      }
      function jd(r, h) {
        var g = h.length;
        if (!g)
          return r;
        var O = g - 1;
        return h[O] = (g > 1 ? "& " : "") + h[O], h = h.join(g > 2 ? ", " : " "), r.replace(Yo, `{
/* [wrapped with ` + h + `] */
`);
      }
      function Xd(r) {
        return gi(r) || dl(r) || !!(ca && r && r[ca]);
      }
      function No(r, h) {
        var g = typeof r;
        return h = h ?? ce, !!h && (g == "number" || g != "symbol" && Pl.test(r)) && r > -1 && r % 1 == 0 && r < h;
      }
      function xr(r, h, g) {
        if (!vn(g))
          return !1;
        var O = typeof h;
        return (O == "number" ? Or(g) && No(h, g.length) : O == "string" && h in g) ? Ns(g[h], r) : !1;
      }
      function ac(r, h) {
        if (gi(r))
          return !1;
        var g = typeof r;
        return g == "number" || g == "symbol" || g == "boolean" || r == null || Yr(r) ? !0 : dr.test(r) || !ho.test(r) || h != null && r in Ee(h);
      }
      function qd(r) {
        var h = typeof r;
        return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? r !== "__proto__" : r === null;
      }
      function lc(r) {
        var h = yu(r), g = it[h];
        if (typeof g != "function" || !(h in _i.prototype))
          return !1;
        if (r === g)
          return !0;
        var O = rc(g);
        return !!O && r === O[0];
      }
      function Yd(r) {
        return !!Cr && Cr in r;
      }
      var Zd = Zs ? Fo : Ec;
      function kh(r) {
        var h = r && r.constructor, g = typeof h == "function" && h.prototype || cs;
        return r === g;
      }
      function Af(r) {
        return r === r && !vn(r);
      }
      function Cf(r, h) {
        return function(g) {
          return g == null ? !1 : g[r] === h && (h !== o || r in Ee(g));
        };
      }
      function Jd(r) {
        var h = Eu(r, function(O) {
          return g.size === S && g.clear(), O;
        }), g = h.cache;
        return h;
      }
      function $d(r, h) {
        var g = r[1], O = h[1], Y = g | O, ut = Y < (L | x | j), _t = O == j && g == R || O == j && g == J && r[7].length <= h[8] || O == (j | J) && h[7].length <= h[8] && g == R;
        if (!(ut || _t))
          return r;
        O & L && (r[2] = h[2], Y |= g & L ? 0 : M);
        var bt = h[3];
        if (bt) {
          var Nt = r[3];
          r[3] = Nt ? Oh(Nt, bt, h[4]) : bt, r[4] = Nt ? Ar(r[3], C) : h[4];
        }
        return bt = h[5], bt && (Nt = r[5], r[5] = Nt ? Ih(Nt, bt, h[6]) : bt, r[6] = Nt ? Ar(r[5], C) : h[6]), bt = h[7], bt && (r[7] = bt), O & j && (r[8] = r[8] == null ? h[8] : Gn(r[8], h[8])), r[9] == null && (r[9] = h[9]), r[0] = h[0], r[1] = Y, r;
      }
      function Kd(r) {
        var h = [];
        if (r != null)
          for (var g in Ee(r))
            h.push(g);
        return h;
      }
      function Qd(r) {
        return or.call(r);
      }
      function Pf(r, h, g) {
        return h = pn(h === o ? r.length - 1 : h, 0), function() {
          for (var O = arguments, Y = -1, ut = pn(O.length - h, 0), _t = Zt(ut); ++Y < ut; )
            _t[Y] = O[h + Y];
          Y = -1;
          for (var bt = Zt(h + 1); ++Y < h; )
            bt[Y] = O[Y];
          return bt[h] = g(_t), mr(r, this, bt);
        };
      }
      function Lf(r, h) {
        return h.length < 2 ? r : eo(r, Gi(h, 0, -1));
      }
      function tm(r, h) {
        for (var g = r.length, O = Gn(h.length, g), Y = Qn(r); O--; ) {
          var ut = h[O];
          r[O] = No(ut, g) ? Y[ut] : o;
        }
        return r;
      }
      function hc(r, h) {
        if (!(h === "constructor" && typeof r[h] == "function") && h != "__proto__")
          return r[h];
      }
      var Rf = If(Sn), Bh = vh || function(r, h) {
        return fn.setTimeout(r, h);
      }, uc = If(mn);
      function Of(r, h, g) {
        var O = h + "";
        return uc(r, jd(O, em(Hd(O), g)));
      }
      function If(r) {
        var h = 0, g = 0;
        return function() {
          var O = $a(), Y = yt - (O - g);
          if (g = O, Y > 0) {
            if (++h >= et)
              return arguments[0];
          } else
            h = 0;
          return r.apply(o, arguments);
        };
      }
      function wu(r, h) {
        var g = -1, O = r.length, Y = O - 1;
        for (h = h === o ? O : h; ++g < h; ) {
          var ut = me(g, Y), _t = r[ut];
          r[ut] = r[g], r[g] = _t;
        }
        return r.length = h, r;
      }
      var Df = Jd(function(r) {
        var h = [];
        return r.charCodeAt(0) === 46 && h.push(""), r.replace(qo, function(g, O, Y, ut) {
          h.push(Y ? ut.replace(Jo, "$1") : O || g);
        }), h;
      });
      function no(r) {
        if (typeof r == "string" || Yr(r))
          return r;
        var h = r + "";
        return h == "0" && 1 / r == -Ct ? "-0" : h;
      }
      function pl(r) {
        if (r != null) {
          try {
            return rr.call(r);
          } catch {
          }
          try {
            return r + "";
          } catch {
          }
        }
        return "";
      }
      function em(r, h) {
        return Yi(fe, function(g) {
          var O = "_." + g[0];
          h & g[1] && !Va(r, O) && r.push(O);
        }), r.sort();
      }
      function zf(r) {
        if (r instanceof _i)
          return r.clone();
        var h = new Vn(r.__wrapped__, r.__chain__);
        return h.__actions__ = Qn(r.__actions__), h.__index__ = r.__index__, h.__values__ = r.__values__, h;
      }
      function im(r, h, g) {
        (g ? xr(r, h, g) : h === o) ? h = 1 : h = pn(xi(h), 0);
        var O = r == null ? 0 : r.length;
        if (!O || h < 1)
          return [];
        for (var Y = 0, ut = 0, _t = Zt(Os(O / h)); Y < O; )
          _t[ut++] = Gi(r, Y, Y += h);
        return _t;
      }
      function nm(r) {
        for (var h = -1, g = r == null ? 0 : r.length, O = 0, Y = []; ++h < g; ) {
          var ut = r[h];
          ut && (Y[O++] = ut);
        }
        return Y;
      }
      function rm() {
        var r = arguments.length;
        if (!r)
          return [];
        for (var h = Zt(r - 1), g = arguments[0], O = r; O--; )
          h[O - 1] = arguments[O];
        return as(gi(g) ? Qn(g) : [g], Mn(h, 1));
      }
      var sm = ae(function(r, h) {
        return Rn(r) ? ll(r, Mn(h, 1, Rn, !0)) : [];
      }), om = ae(function(r, h) {
        var g = xs(h);
        return Rn(g) && (g = o), Rn(r) ? ll(r, Mn(h, 1, Rn, !0), si(g, 2)) : [];
      }), am = ae(function(r, h) {
        var g = xs(h);
        return Rn(g) && (g = o), Rn(r) ? ll(r, Mn(h, 1, Rn, !0), o, g) : [];
      });
      function lm(r, h, g) {
        var O = r == null ? 0 : r.length;
        return O ? (h = g || h === o ? 1 : xi(h), Gi(r, h < 0 ? 0 : h, O)) : [];
      }
      function hm(r, h, g) {
        var O = r == null ? 0 : r.length;
        return O ? (h = g || h === o ? 1 : xi(h), h = O - h, Gi(r, 0, h < 0 ? 0 : h)) : [];
      }
      function um(r, h) {
        return r && r.length ? Xe(r, si(h, 3), !0, !0) : [];
      }
      function cm(r, h) {
        return r && r.length ? Xe(r, si(h, 3), !0) : [];
      }
      function fm(r, h, g, O) {
        var Y = r == null ? 0 : r.length;
        return Y ? (g && typeof g != "number" && xr(r, h, g) && (g = 0, O = Y), Kn(r, h, g, O)) : [];
      }
      function kf(r, h, g) {
        var O = r == null ? 0 : r.length;
        if (!O)
          return -1;
        var Y = g == null ? 0 : xi(g);
        return Y < 0 && (Y = pn(O + Y, 0)), Vs(r, si(h, 3), Y);
      }
      function Bf(r, h, g) {
        var O = r == null ? 0 : r.length;
        if (!O)
          return -1;
        var Y = O - 1;
        return g !== o && (Y = xi(g), Y = g < 0 ? pn(O + Y, 0) : Gn(Y, O - 1)), Vs(r, si(h, 3), Y, !0);
      }
      function Nf(r) {
        var h = r == null ? 0 : r.length;
        return h ? Mn(r, 1) : [];
      }
      function pm(r) {
        var h = r == null ? 0 : r.length;
        return h ? Mn(r, Ct) : [];
      }
      function dm(r, h) {
        var g = r == null ? 0 : r.length;
        return g ? (h = h === o ? 1 : xi(h), Mn(r, h)) : [];
      }
      function mm(r) {
        for (var h = -1, g = r == null ? 0 : r.length, O = {}; ++h < g; ) {
          var Y = r[h];
          O[Y[0]] = Y[1];
        }
        return O;
      }
      function Ff(r) {
        return r && r.length ? r[0] : o;
      }
      function gm(r, h, g) {
        var O = r == null ? 0 : r.length;
        if (!O)
          return -1;
        var Y = g == null ? 0 : xi(g);
        return Y < 0 && (Y = pn(O + Y, 0)), Er(r, h, Y);
      }
      function vm(r) {
        var h = r == null ? 0 : r.length;
        return h ? Gi(r, 0, -1) : [];
      }
      var _m = ae(function(r) {
        var h = Xi(r, ne);
        return h.length && h[0] === r[0] ? ul(h) : [];
      }), ym = ae(function(r) {
        var h = xs(r), g = Xi(r, ne);
        return h === xs(g) ? h = o : g.pop(), g.length && g[0] === r[0] ? ul(g, si(h, 2)) : [];
      }), xm = ae(function(r) {
        var h = xs(r), g = Xi(r, ne);
        return h = typeof h == "function" ? h : o, h && g.pop(), g.length && g[0] === r[0] ? ul(g, o, h) : [];
      });
      function wm(r, h) {
        return r == null ? "" : yh.call(r, h);
      }
      function xs(r) {
        var h = r == null ? 0 : r.length;
        return h ? r[h - 1] : o;
      }
      function Tm(r, h, g) {
        var O = r == null ? 0 : r.length;
        if (!O)
          return -1;
        var Y = O;
        return g !== o && (Y = xi(g), Y = Y < 0 ? pn(O + Y, 0) : Gn(Y, O - 1)), h === h ? kl(r, h, Y) : Vs(r, _o, Y, !0);
      }
      function Mm(r, h) {
        return r && r.length ? Z(r, xi(h)) : o;
      }
      var Sm = ae(Uf);
      function Uf(r, h) {
        return r && r.length && h && h.length ? qt(r, h) : r;
      }
      function Em(r, h, g) {
        return r && r.length && h && h.length ? qt(r, h, si(g, 2)) : r;
      }
      function bm(r, h, g) {
        return r && r.length && h && h.length ? qt(r, h, o, g) : r;
      }
      var Am = Bo(function(r, h) {
        var g = r == null ? 0 : r.length, O = Ph(r, h);
        return Te(r, Xi(h, function(Y) {
          return No(Y, g) ? +Y : Y;
        }).sort(ko)), O;
      });
      function Cm(r, h) {
        var g = [];
        if (!(r && r.length))
          return g;
        var O = -1, Y = [], ut = r.length;
        for (h = si(h, 3); ++O < ut; ) {
          var _t = r[O];
          h(_t, O, r) && (g.push(_t), Y.push(O));
        }
        return Te(r, Y), g;
      }
      function cc(r) {
        return r == null ? r : fa.call(r);
      }
      function Pm(r, h, g) {
        var O = r == null ? 0 : r.length;
        return O ? (g && typeof g != "number" && xr(r, h, g) ? (h = 0, g = O) : (h = h == null ? 0 : xi(h), g = g === o ? O : xi(g)), Gi(r, h, g)) : [];
      }
      function Lm(r, h) {
        return En(r, h);
      }
      function Rm(r, h, g) {
        return Ae(r, h, si(g, 2));
      }
      function Om(r, h) {
        var g = r == null ? 0 : r.length;
        if (g) {
          var O = En(r, h);
          if (O < g && Ns(r[O], h))
            return O;
        }
        return -1;
      }
      function Im(r, h) {
        return En(r, h, !0);
      }
      function Dm(r, h, g) {
        return Ae(r, h, si(g, 2), !0);
      }
      function zm(r, h) {
        var g = r == null ? 0 : r.length;
        if (g) {
          var O = En(r, h, !0) - 1;
          if (Ns(r[O], h))
            return O;
        }
        return -1;
      }
      function km(r) {
        return r && r.length ? Qe(r) : [];
      }
      function Bm(r, h) {
        return r && r.length ? Qe(r, si(h, 2)) : [];
      }
      function Nm(r) {
        var h = r == null ? 0 : r.length;
        return h ? Gi(r, 1, h) : [];
      }
      function Fm(r, h, g) {
        return r && r.length ? (h = g || h === o ? 1 : xi(h), Gi(r, 0, h < 0 ? 0 : h)) : [];
      }
      function Um(r, h, g) {
        var O = r == null ? 0 : r.length;
        return O ? (h = g || h === o ? 1 : xi(h), h = O - h, Gi(r, h < 0 ? 0 : h, O)) : [];
      }
      function Gm(r, h) {
        return r && r.length ? Xe(r, si(h, 3), !1, !0) : [];
      }
      function Hm(r, h) {
        return r && r.length ? Xe(r, si(h, 3)) : [];
      }
      var Vm = ae(function(r) {
        return ei(Mn(r, 1, Rn, !0));
      }), Wm = ae(function(r) {
        var h = xs(r);
        return Rn(h) && (h = o), ei(Mn(r, 1, Rn, !0), si(h, 2));
      }), jm = ae(function(r) {
        var h = xs(r);
        return h = typeof h == "function" ? h : o, ei(Mn(r, 1, Rn, !0), o, h);
      });
      function Xm(r) {
        return r && r.length ? ei(r) : [];
      }
      function qm(r, h) {
        return r && r.length ? ei(r, si(h, 2)) : [];
      }
      function Ym(r, h) {
        return h = typeof h == "function" ? h : o, r && r.length ? ei(r, o, h) : [];
      }
      function fc(r) {
        if (!(r && r.length))
          return [];
        var h = 0;
        return r = Sr(r, function(g) {
          if (Rn(g))
            return h = pn(g.length, h), !0;
        }), Ps(h, function(g) {
          return Xi(r, Ws(g));
        });
      }
      function Gf(r, h) {
        if (!(r && r.length))
          return [];
        var g = fc(r);
        return h == null ? g : Xi(g, function(O) {
          return mr(h, o, O);
        });
      }
      var Zm = ae(function(r, h) {
        return Rn(r) ? ll(r, h) : [];
      }), Jm = ae(function(r) {
        return Ai(Sr(r, Rn));
      }), $m = ae(function(r) {
        var h = xs(r);
        return Rn(h) && (h = o), Ai(Sr(r, Rn), si(h, 2));
      }), Km = ae(function(r) {
        var h = xs(r);
        return h = typeof h == "function" ? h : o, Ai(Sr(r, Rn), o, h);
      }), Qm = ae(fc);
      function tg(r, h) {
        return bi(r || [], h || [], ya);
      }
      function eg(r, h) {
        return bi(r || [], h || [], ci);
      }
      var ig = ae(function(r) {
        var h = r.length, g = h > 1 ? r[h - 1] : o;
        return g = typeof g == "function" ? (r.pop(), g) : o, Gf(r, g);
      });
      function Hf(r) {
        var h = it(r);
        return h.__chain__ = !0, h;
      }
      function ng(r, h) {
        return h(r), r;
      }
      function Tu(r, h) {
        return h(r);
      }
      var rg = Bo(function(r) {
        var h = r.length, g = h ? r[0] : 0, O = this.__wrapped__, Y = function(ut) {
          return Ph(ut, r);
        };
        return h > 1 || this.__actions__.length || !(O instanceof _i) || !No(g) ? this.thru(Y) : (O = O.slice(g, +g + (h ? 1 : 0)), O.__actions__.push({
          func: Tu,
          args: [Y],
          thisArg: o
        }), new Vn(O, this.__chain__).thru(function(ut) {
          return h && !ut.length && ut.push(o), ut;
        }));
      });
      function sg() {
        return Hf(this);
      }
      function og() {
        return new Vn(this.value(), this.__chain__);
      }
      function ag() {
        this.__values__ === o && (this.__values__ = ip(this.value()));
        var r = this.__index__ >= this.__values__.length, h = r ? o : this.__values__[this.__index__++];
        return { done: r, value: h };
      }
      function lg() {
        return this;
      }
      function hg(r) {
        for (var h, g = this; g instanceof da; ) {
          var O = zf(g);
          O.__index__ = 0, O.__values__ = o, h ? Y.__wrapped__ = O : h = O;
          var Y = O;
          g = g.__wrapped__;
        }
        return Y.__wrapped__ = r, h;
      }
      function ug() {
        var r = this.__wrapped__;
        if (r instanceof _i) {
          var h = r;
          return this.__actions__.length && (h = new _i(this)), h = h.reverse(), h.__actions__.push({
            func: Tu,
            args: [cc],
            thisArg: o
          }), new Vn(h, this.__chain__);
        }
        return this.thru(cc);
      }
      function cg() {
        return ri(this.__wrapped__, this.__actions__);
      }
      var fg = Ma(function(r, h, g) {
        wi.call(r, g) ? ++r[g] : zs(r, g, 1);
      });
      function pg(r, h, g) {
        var O = gi(r) ? gh : Wn;
        return g && xr(r, h, g) && (h = o), O(r, si(h, 3));
      }
      function dg(r, h) {
        var g = gi(r) ? Sr : Lr;
        return g(r, si(h, 3));
      }
      var mg = $e(kf), gg = $e(Bf);
      function vg(r, h) {
        return Mn(Mu(r, h), 1);
      }
      function _g(r, h) {
        return Mn(Mu(r, h), Ct);
      }
      function yg(r, h, g) {
        return g = g === o ? 1 : xi(g), Mn(Mu(r, h), g);
      }
      function Vf(r, h) {
        var g = gi(r) ? Yi : dn;
        return g(r, si(h, 3));
      }
      function Wf(r, h) {
        var g = gi(r) ? go : mu;
        return g(r, si(h, 3));
      }
      var xg = Ma(function(r, h, g) {
        wi.call(r, g) ? r[g].push(h) : zs(r, g, [h]);
      });
      function wg(r, h, g, O) {
        r = Or(r) ? r : Ql(r), g = g && !O ? xi(g) : 0;
        var Y = r.length;
        return g < 0 && (g = pn(Y + g, 0)), Cu(r) ? g <= Y && r.indexOf(h, g) > -1 : !!Y && Er(r, h, g) > -1;
      }
      var Tg = ae(function(r, h, g) {
        var O = -1, Y = typeof h == "function", ut = Or(r) ? Zt(r.length) : [];
        return dn(r, function(_t) {
          ut[++O] = Y ? mr(h, _t, g) : e(_t, h, g);
        }), ut;
      }), Mg = Ma(function(r, h, g) {
        zs(r, g, h);
      });
      function Mu(r, h) {
        var g = gi(r) ? Xi : xt;
        return g(r, si(h, 3));
      }
      function Sg(r, h, g, O) {
        return r == null ? [] : (gi(h) || (h = h == null ? [] : [h]), g = O ? o : g, gi(g) || (g = g == null ? [] : [g]), st(r, h, g));
      }
      var Eg = Ma(function(r, h, g) {
        r[g ? 0 : 1].push(h);
      }, function() {
        return [[], []];
      });
      function bg(r, h, g) {
        var O = gi(r) ? Dl : js, Y = arguments.length < 3;
        return O(r, si(h, 4), g, Y, dn);
      }
      function Ag(r, h, g) {
        var O = gi(r) ? iu : js, Y = arguments.length < 3;
        return O(r, si(h, 4), g, Y, mu);
      }
      function Cg(r, h) {
        var g = gi(r) ? Sr : Lr;
        return g(r, bu(si(h, 3)));
      }
      function Pg(r) {
        var h = gi(r) ? bh : We;
        return h(r);
      }
      function Lg(r, h, g) {
        (g ? xr(r, h, g) : h === o) ? h = 1 : h = xi(h);
        var O = gi(r) ? ec : Ke;
        return O(r, h);
      }
      function Rg(r) {
        var h = gi(r) ? fu : ji;
        return h(r);
      }
      function Og(r) {
        if (r == null)
          return 0;
        if (Or(r))
          return Cu(r) ? jr(r) : r.length;
        var h = ur(r);
        return h == W || h == Kt ? r.size : q(r).length;
      }
      function Ig(r, h, g) {
        var O = gi(r) ? As : en;
        return g && xr(r, h, g) && (h = o), O(r, si(h, 3));
      }
      var Dg = ae(function(r, h) {
        if (r == null)
          return [];
        var g = h.length;
        return g > 1 && xr(r, h[0], h[1]) ? h = [] : g > 2 && xr(h[0], h[1], h[2]) && (h = [h[0]]), st(r, Mn(h, 1), []);
      }), Su = Fl || function() {
        return fn.Date.now();
      };
      function zg(r, h) {
        if (typeof h != "function")
          throw new nr(m);
        return r = xi(r), function() {
          if (--r < 1)
            return h.apply(this, arguments);
        };
      }
      function jf(r, h, g) {
        return h = g ? o : h, h = r && h == null ? r.length : h, tr(r, j, o, o, o, o, h);
      }
      function Xf(r, h) {
        var g;
        if (typeof h != "function")
          throw new nr(m);
        return r = xi(r), function() {
          return --r > 0 && (g = h.apply(this, arguments)), r <= 1 && (h = o), g;
        };
      }
      var pc = ae(function(r, h, g) {
        var O = L;
        if (g.length) {
          var Y = Ar(g, $l(pc));
          O |= U;
        }
        return tr(r, O, h, g, Y);
      }), qf = ae(function(r, h, g) {
        var O = L | x;
        if (g.length) {
          var Y = Ar(g, $l(qf));
          O |= U;
        }
        return tr(h, O, r, g, Y);
      });
      function Yf(r, h, g) {
        h = g ? o : h;
        var O = tr(r, R, o, o, o, o, o, h);
        return O.placeholder = Yf.placeholder, O;
      }
      function Zf(r, h, g) {
        h = g ? o : h;
        var O = tr(r, b, o, o, o, o, o, h);
        return O.placeholder = Zf.placeholder, O;
      }
      function Jf(r, h, g) {
        var O, Y, ut, _t, bt, Nt, se = 0, le = !1, de = !1, ze = !0;
        if (typeof r != "function")
          throw new nr(m);
        h = ws(h) || 0, vn(g) && (le = !!g.leading, de = "maxWait" in g, ut = de ? pn(ws(g.maxWait) || 0, h) : ut, ze = "trailing" in g ? !!g.trailing : ze);
        function Je(On) {
          var Fs = O, Go = Y;
          return O = Y = o, se = On, _t = r.apply(Go, Fs), _t;
        }
        function li(On) {
          return se = On, bt = Bh(Ci, h), le ? Je(On) : _t;
        }
        function Ti(On) {
          var Fs = On - Nt, Go = On - se, mp = h - Fs;
          return de ? Gn(mp, ut - Go) : mp;
        }
        function hi(On) {
          var Fs = On - Nt, Go = On - se;
          return Nt === o || Fs >= h || Fs < 0 || de && Go >= ut;
        }
        function Ci() {
          var On = Su();
          if (hi(On))
            return ki(On);
          bt = Bh(Ci, Ti(On));
        }
        function ki(On) {
          return bt = o, ze && O ? Je(On) : (O = Y = o, _t);
        }
        function Zr() {
          bt !== o && bn(bt), se = 0, O = Nt = Y = bt = o;
        }
        function wr() {
          return bt === o ? _t : ki(Su());
        }
        function Jr() {
          var On = Su(), Fs = hi(On);
          if (O = arguments, Y = this, Nt = On, Fs) {
            if (bt === o)
              return li(Nt);
            if (de)
              return bn(bt), bt = Bh(Ci, h), Je(Nt);
          }
          return bt === o && (bt = Bh(Ci, h)), _t;
        }
        return Jr.cancel = Zr, Jr.flush = wr, Jr;
      }
      var kg = ae(function(r, h) {
        return gs(r, 1, h);
      }), Bg = ae(function(r, h, g) {
        return gs(r, ws(h) || 0, g);
      });
      function Ng(r) {
        return tr(r, $);
      }
      function Eu(r, h) {
        if (typeof r != "function" || h != null && typeof h != "function")
          throw new nr(m);
        var g = function() {
          var O = arguments, Y = h ? h.apply(this, O) : O[0], ut = g.cache;
          if (ut.has(Y))
            return ut.get(Y);
          var _t = r.apply(this, O);
          return g.cache = ut.set(Y, _t) || ut, _t;
        };
        return g.cache = new (Eu.Cache || vr)(), g;
      }
      Eu.Cache = vr;
      function bu(r) {
        if (typeof r != "function")
          throw new nr(m);
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return !r.call(this);
            case 1:
              return !r.call(this, h[0]);
            case 2:
              return !r.call(this, h[0], h[1]);
            case 3:
              return !r.call(this, h[0], h[1], h[2]);
          }
          return !r.apply(this, h);
        };
      }
      function Fg(r) {
        return Xf(2, r);
      }
      var Ug = ai(function(r, h) {
        h = h.length == 1 && gi(h[0]) ? Xi(h[0], Fn(si())) : Xi(Mn(h, 1), Fn(si()));
        var g = h.length;
        return ae(function(O) {
          for (var Y = -1, ut = Gn(O.length, g); ++Y < ut; )
            O[Y] = h[Y].call(this, O[Y]);
          return mr(r, this, O);
        });
      }), dc = ae(function(r, h) {
        var g = Ar(h, $l(dc));
        return tr(r, U, o, h, g);
      }), $f = ae(function(r, h) {
        var g = Ar(h, $l($f));
        return tr(r, N, o, h, g);
      }), Gg = Bo(function(r, h) {
        return tr(r, J, o, o, o, h);
      });
      function Hg(r, h) {
        if (typeof r != "function")
          throw new nr(m);
        return h = h === o ? h : xi(h), ae(r, h);
      }
      function Vg(r, h) {
        if (typeof r != "function")
          throw new nr(m);
        return h = h == null ? 0 : pn(xi(h), 0), ae(function(g) {
          var O = g[h], Y = gn(g, 0, h);
          return O && as(Y, O), mr(r, this, Y);
        });
      }
      function Wg(r, h, g) {
        var O = !0, Y = !0;
        if (typeof r != "function")
          throw new nr(m);
        return vn(g) && (O = "leading" in g ? !!g.leading : O, Y = "trailing" in g ? !!g.trailing : Y), Jf(r, h, {
          leading: O,
          maxWait: h,
          trailing: Y
        });
      }
      function jg(r) {
        return jf(r, 1);
      }
      function Xg(r, h) {
        return dc(ii(h), r);
      }
      function qg() {
        if (!arguments.length)
          return [];
        var r = arguments[0];
        return gi(r) ? r : [r];
      }
      function Yg(r) {
        return _r(r, I);
      }
      function Zg(r, h) {
        return h = typeof h == "function" ? h : o, _r(r, I, h);
      }
      function Jg(r) {
        return _r(r, z | I);
      }
      function $g(r, h) {
        return h = typeof h == "function" ? h : o, _r(r, z | I, h);
      }
      function Kg(r, h) {
        return h == null || du(r, h, Xn(h));
      }
      function Ns(r, h) {
        return r === h || r !== r && h !== h;
      }
      var Qg = ys(ql), t0 = ys(function(r, h) {
        return r >= h;
      }), dl = i(function() {
        return arguments;
      }()) ? i : function(r) {
        return An(r) && wi.call(r, "callee") && !Za.call(r, "callee");
      }, gi = Zt.isArray, e0 = mh ? Fn(mh) : n;
      function Or(r) {
        return r != null && Au(r.length) && !Fo(r);
      }
      function Rn(r) {
        return An(r) && Or(r);
      }
      function i0(r) {
        return r === !0 || r === !1 || An(r) && jn(r) == Oe;
      }
      var Ea = _h || Ec, n0 = ra ? Fn(ra) : s;
      function r0(r) {
        return An(r) && r.nodeType === 1 && !Nh(r);
      }
      function s0(r) {
        if (r == null)
          return !0;
        if (Or(r) && (gi(r) || typeof r == "string" || typeof r.splice == "function" || Ea(r) || Kl(r) || dl(r)))
          return !r.length;
        var h = ur(r);
        if (h == W || h == Kt)
          return !r.size;
        if (kh(r))
          return !q(r).length;
        for (var g in r)
          if (wi.call(r, g))
            return !1;
        return !0;
      }
      function o0(r, h) {
        return a(r, h);
      }
      function a0(r, h, g) {
        g = typeof g == "function" ? g : o;
        var O = g ? g(r, h) : o;
        return O === o ? a(r, h, o, g) : !!O;
      }
      function mc(r) {
        if (!An(r))
          return !1;
        var h = jn(r);
        return h == Li || h == pi || typeof r.message == "string" && typeof r.name == "string" && !Nh(r);
      }
      function l0(r) {
        return typeof r == "number" && Ul(r);
      }
      function Fo(r) {
        if (!vn(r))
          return !1;
        var h = jn(r);
        return h == cn || h == Ji || h == Ni || h == Dt;
      }
      function Kf(r) {
        return typeof r == "number" && r == xi(r);
      }
      function Au(r) {
        return typeof r == "number" && r > -1 && r % 1 == 0 && r <= ce;
      }
      function vn(r) {
        var h = typeof r;
        return r != null && (h == "object" || h == "function");
      }
      function An(r) {
        return r != null && typeof r == "object";
      }
      var Qf = sa ? Fn(sa) : f;
      function h0(r, h) {
        return r === h || v(r, h, sc(h));
      }
      function u0(r, h, g) {
        return g = typeof g == "function" ? g : o, v(r, h, sc(h), g);
      }
      function c0(r) {
        return tp(r) && r != +r;
      }
      function f0(r) {
        if (Zd(r))
          throw new oi(u);
        return y(r);
      }
      function p0(r) {
        return r === null;
      }
      function d0(r) {
        return r == null;
      }
      function tp(r) {
        return typeof r == "number" || An(r) && jn(r) == Jt;
      }
      function Nh(r) {
        if (!An(r) || jn(r) != pt)
          return !1;
        var h = ps(r);
        if (h === null)
          return !0;
        var g = wi.call(h, "constructor") && h.constructor;
        return typeof g == "function" && g instanceof g && rr.call(g) == fs;
      }
      var gc = tu ? Fn(tu) : A;
      function m0(r) {
        return Kf(r) && r >= -ce && r <= ce;
      }
      var ep = eu ? Fn(eu) : P;
      function Cu(r) {
        return typeof r == "string" || !gi(r) && An(r) && jn(r) == D;
      }
      function Yr(r) {
        return typeof r == "symbol" || An(r) && jn(r) == Q;
      }
      var Kl = Rl ? Fn(Rl) : k;
      function g0(r) {
        return r === o;
      }
      function v0(r) {
        return An(r) && ur(r) == nt;
      }
      function _0(r) {
        return An(r) && jn(r) == vt;
      }
      var y0 = ys(rt), x0 = ys(function(r, h) {
        return r <= h;
      });
      function ip(r) {
        if (!r)
          return [];
        if (Or(r))
          return Cu(r) ? ir(r) : Qn(r);
        if (Js && r[Js])
          return Eo(r[Js]());
        var h = ur(r), g = h == W ? Zn : h == Kt ? bo : Ql;
        return g(r);
      }
      function Uo(r) {
        if (!r)
          return r === 0 ? r : 0;
        if (r = ws(r), r === Ct || r === -Ct) {
          var h = r < 0 ? -1 : 1;
          return h * re;
        }
        return r === r ? r : 0;
      }
      function xi(r) {
        var h = Uo(r), g = h % 1;
        return h === h ? g ? h - g : h : 0;
      }
      function np(r) {
        return r ? to(xi(r), 0, Ot) : 0;
      }
      function ws(r) {
        if (typeof r == "number")
          return r;
        if (Yr(r))
          return Ft;
        if (vn(r)) {
          var h = typeof r.valueOf == "function" ? r.valueOf() : r;
          r = vn(h) ? h + "" : h;
        }
        if (typeof r != "string")
          return r === 0 ? r : +r;
        r = aa(r);
        var g = ph.test(r);
        return g || co.test(r) ? ea(r.slice(2), g ? 2 : 8) : fh.test(r) ? Ft : +r;
      }
      function rp(r) {
        return Ln(r, Ir(r));
      }
      function w0(r) {
        return r ? to(xi(r), -ce, ce) : r === 0 ? r : 0;
      }
      function qi(r) {
        return r == null ? "" : Ye(r);
      }
      var T0 = Bs(function(r, h) {
        if (kh(h) || Or(h)) {
          Ln(h, Xn(h), r);
          return;
        }
        for (var g in h)
          wi.call(h, g) && ya(r, g, h[g]);
      }), sp = Bs(function(r, h) {
        Ln(h, Ir(h), r);
      }), Pu = Bs(function(r, h, g, O) {
        Ln(h, Ir(h), r, O);
      }), M0 = Bs(function(r, h, g, O) {
        Ln(h, Xn(h), r, O);
      }), S0 = Bo(Ph);
      function E0(r, h) {
        var g = Ks(r);
        return h == null ? g : Ah(g, h);
      }
      var b0 = ae(function(r, h) {
        r = Ee(r);
        var g = -1, O = h.length, Y = O > 2 ? h[2] : o;
        for (Y && xr(h[0], h[1], Y) && (O = 1); ++g < O; )
          for (var ut = h[g], _t = Ir(ut), bt = -1, Nt = _t.length; ++bt < Nt; ) {
            var se = _t[bt], le = r[se];
            (le === o || Ns(le, cs[se]) && !wi.call(r, se)) && (r[se] = ut[se]);
          }
        return r;
      }), A0 = ae(function(r) {
        return r.push(o, Tf), mr(op, o, r);
      });
      function C0(r, h) {
        return vo(r, si(h, 3), Rr);
      }
      function P0(r, h) {
        return vo(r, si(h, 3), Xl);
      }
      function L0(r, h) {
        return r == null ? r : hl(r, si(h, 3), Ir);
      }
      function R0(r, h) {
        return r == null ? r : jl(r, si(h, 3), Ir);
      }
      function O0(r, h) {
        return r && Rr(r, si(h, 3));
      }
      function I0(r, h) {
        return r && Xl(r, si(h, 3));
      }
      function D0(r) {
        return r == null ? [] : Do(r, Xn(r));
      }
      function z0(r) {
        return r == null ? [] : Do(r, Ir(r));
      }
      function vc(r, h, g) {
        var O = r == null ? o : eo(r, h);
        return O === o ? g : O;
      }
      function k0(r, h) {
        return r != null && Ef(r, h, Yl);
      }
      function _c(r, h) {
        return r != null && Ef(r, h, Lh);
      }
      var B0 = ve(function(r, h, g) {
        h != null && typeof h.toString != "function" && (h = or.call(h)), r[h] = g;
      }, xc(Dr)), N0 = ve(function(r, h, g) {
        h != null && typeof h.toString != "function" && (h = or.call(h)), wi.call(r, h) ? r[h].push(g) : r[h] = [g];
      }, si), F0 = ae(e);
      function Xn(r) {
        return Or(r) ? cu(r) : q(r);
      }
      function Ir(r) {
        return Or(r) ? cu(r, !0) : K(r);
      }
      function U0(r, h) {
        var g = {};
        return h = si(h, 3), Rr(r, function(O, Y, ut) {
          zs(g, h(O, Y, ut), O);
        }), g;
      }
      function G0(r, h) {
        var g = {};
        return h = si(h, 3), Rr(r, function(O, Y, ut) {
          zs(g, Y, h(O, Y, ut));
        }), g;
      }
      var H0 = Bs(function(r, h, g) {
        wt(r, h, g);
      }), op = Bs(function(r, h, g, O) {
        wt(r, h, g, O);
      }), V0 = Bo(function(r, h) {
        var g = {};
        if (r == null)
          return g;
        var O = !1;
        h = Xi(h, function(ut) {
          return ut = Ze(ut, r), O || (O = ut.length > 1), ut;
        }), Ln(r, nc(r), g), O && (g = _r(g, z | B | I, Bd));
        for (var Y = h.length; Y--; )
          Hi(g, h[Y]);
        return g;
      });
      function W0(r, h) {
        return ap(r, bu(si(h)));
      }
      var j0 = Bo(function(r, h) {
        return r == null ? {} : zt(r, h);
      });
      function ap(r, h) {
        if (r == null)
          return {};
        var g = Xi(nc(r), function(O) {
          return [O];
        });
        return h = si(h), ee(r, g, function(O, Y) {
          return h(O, Y[0]);
        });
      }
      function X0(r, h, g) {
        h = Ze(h, r);
        var O = -1, Y = h.length;
        for (Y || (Y = 1, r = o); ++O < Y; ) {
          var ut = r == null ? o : r[no(h[O])];
          ut === o && (O = Y, ut = g), r = Fo(ut) ? ut.call(r) : ut;
        }
        return r;
      }
      function q0(r, h, g) {
        return r == null ? r : ci(r, h, g);
      }
      function Y0(r, h, g, O) {
        return O = typeof O == "function" ? O : o, r == null ? r : ci(r, h, g, O);
      }
      var lp = _u(Xn), hp = _u(Ir);
      function Z0(r, h, g) {
        var O = gi(r), Y = O || Ea(r) || Kl(r);
        if (h = si(h, 4), g == null) {
          var ut = r && r.constructor;
          Y ? g = O ? new ut() : [] : vn(r) ? g = Fo(ut) ? Ks(ps(r)) : {} : g = {};
        }
        return (Y ? Yi : Rr)(r, function(_t, bt, Nt) {
          return h(g, _t, bt, Nt);
        }), g;
      }
      function J0(r, h) {
        return r == null ? !0 : Hi(r, h);
      }
      function $0(r, h, g) {
        return r == null ? r : Ce(r, h, ii(g));
      }
      function K0(r, h, g, O) {
        return O = typeof O == "function" ? O : o, r == null ? r : Ce(r, h, ii(g), O);
      }
      function Ql(r) {
        return r == null ? [] : yo(r, Xn(r));
      }
      function Q0(r) {
        return r == null ? [] : yo(r, Ir(r));
      }
      function tv(r, h, g) {
        return g === o && (g = h, h = o), g !== o && (g = ws(g), g = g === g ? g : 0), h !== o && (h = ws(h), h = h === h ? h : 0), to(ws(r), h, g);
      }
      function ev(r, h, g) {
        return h = Uo(h), g === o ? (g = h, h = 0) : g = Uo(g), r = ws(r), Zl(r, h, g);
      }
      function iv(r, h, g) {
        if (g && typeof g != "boolean" && xr(r, h, g) && (h = g = o), g === o && (typeof h == "boolean" ? (g = h, h = o) : typeof r == "boolean" && (g = r, r = o)), r === o && h === o ? (r = 0, h = 1) : (r = Uo(r), h === o ? (h = r, r = 0) : h = Uo(h)), r > h) {
          var O = r;
          r = h, h = O;
        }
        if (g || r % 1 || h % 1) {
          var Y = Gl();
          return Gn(r + Y * (h - r + Ha("1e-" + ((Y + "").length - 1))), h);
        }
        return me(r, h);
      }
      var nv = De(function(r, h, g) {
        return h = h.toLowerCase(), r + (g ? up(h) : h);
      });
      function up(r) {
        return yc(qi(r).toLowerCase());
      }
      function cp(r) {
        return r = qi(r), r && r.replace(Ll, wo).replace(dh, "");
      }
      function rv(r, h, g) {
        r = qi(r), h = Ye(h);
        var O = r.length;
        g = g === o ? O : to(xi(g), 0, O);
        var Y = g;
        return g -= h.length, g >= 0 && r.slice(g, Y) == h;
      }
      function sv(r) {
        return r = qi(r), r && is.test(r) ? r.replace(Ri, Wr) : r;
      }
      function ov(r) {
        return r = qi(r), r && Al.test(r) ? r.replace(Da, "\\$&") : r;
      }
      var av = De(function(r, h, g) {
        return r + (g ? "-" : "") + h.toLowerCase();
      }), lv = De(function(r, h, g) {
        return r + (g ? " " : "") + h.toLowerCase();
      }), hv = Me("toLowerCase");
      function uv(r, h, g) {
        r = qi(r), h = xi(h);
        var O = h ? jr(r) : 0;
        if (!h || O >= h)
          return r;
        var Y = (h - O) / 2;
        return sn(Po(Y), g) + r + sn(Os(Y), g);
      }
      function cv(r, h, g) {
        r = qi(r), h = xi(h);
        var O = h ? jr(r) : 0;
        return h && O < h ? r + sn(h - O, g) : r;
      }
      function fv(r, h, g) {
        r = qi(r), h = xi(h);
        var O = h ? jr(r) : 0;
        return h && O < h ? sn(h - O, g) + r : r;
      }
      function pv(r, h, g) {
        return g || h == null ? h = 0 : h && (h = +h), xh(qi(r).replace(ns, ""), h || 0);
      }
      function dv(r, h, g) {
        return (g ? xr(r, h, g) : h === o) ? h = 1 : h = xi(h), be(qi(r), h);
      }
      function mv() {
        var r = arguments, h = qi(r[0]);
        return r.length < 3 ? h : h.replace(r[1], r[2]);
      }
      var gv = De(function(r, h, g) {
        return r + (g ? "_" : "") + h.toLowerCase();
      });
      function vv(r, h, g) {
        return g && typeof g != "number" && xr(r, h, g) && (h = g = o), g = g === o ? Ot : g >>> 0, g ? (r = qi(r), r && (typeof h == "string" || h != null && !gc(h)) && (h = Ye(h), !h && br(r)) ? gn(ir(r), 0, g) : r.split(h, g)) : [];
      }
      var _v = De(function(r, h, g) {
        return r + (g ? " " : "") + yc(h);
      });
      function yv(r, h, g) {
        return r = qi(r), g = g == null ? 0 : to(xi(g), 0, r.length), h = Ye(h), r.slice(g, g + h.length) == h;
      }
      function xv(r, h, g) {
        var O = it.templateSettings;
        g && xr(r, h, g) && (h = o), r = qi(r), h = Pu({}, h, O, wf);
        var Y = Pu({}, h.imports, O.imports, wf), ut = Xn(Y), _t = yo(Y, ut), bt, Nt, se = 0, le = h.interpolate || Hr, de = "__p += '", ze = Jn(
          (h.escape || Hr).source + "|" + le.source + "|" + (le === Xo ? ss : Hr).source + "|" + (h.evaluate || Hr).source + "|$",
          "g"
        ), Je = "//# sourceURL=" + (wi.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Qo + "]") + `
`;
        r.replace(ze, function(hi, Ci, ki, Zr, wr, Jr) {
          return ki || (ki = Zr), de += r.slice(se, Jr).replace(V, To), Ci && (bt = !0, de += `' +
__e(` + Ci + `) +
'`), wr && (Nt = !0, de += `';
` + wr + `;
__p += '`), ki && (de += `' +
((__t = (` + ki + `)) == null ? '' : __t) +
'`), se = Jr + hi.length, hi;
        }), de += `';
`;
        var li = wi.call(h, "variable") && h.variable;
        if (!li)
          de = `with (obj) {
` + de + `
}
`;
        else if (Zo.test(li))
          throw new oi(_);
        de = (Nt ? de.replace(Gr, "") : de).replace(er, "$1").replace(rn, "$1;"), de = "function(" + (li || "obj") + `) {
` + (li ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (bt ? ", __e = _.escape" : "") + (Nt ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + de + `return __p
}`;
        var Ti = pp(function() {
          return zi(ut, Je + "return " + de).apply(o, _t);
        });
        if (Ti.source = de, mc(Ti))
          throw Ti;
        return Ti;
      }
      function wv(r) {
        return qi(r).toLowerCase();
      }
      function Tv(r) {
        return qi(r).toUpperCase();
      }
      function Mv(r, h, g) {
        if (r = qi(r), r && (g || h === o))
          return aa(r);
        if (!r || !(h = Ye(h)))
          return r;
        var O = ir(r), Y = ir(h), ut = qs(O, Y), _t = xo(O, Y) + 1;
        return gn(O, ut, _t).join("");
      }
      function Sv(r, h, g) {
        if (r = qi(r), r && (g || h === o))
          return r.slice(0, la(r) + 1);
        if (!r || !(h = Ye(h)))
          return r;
        var O = ir(r), Y = xo(O, ir(h)) + 1;
        return gn(O, 0, Y).join("");
      }
      function Ev(r, h, g) {
        if (r = qi(r), r && (g || h === o))
          return r.replace(ns, "");
        if (!r || !(h = Ye(h)))
          return r;
        var O = ir(r), Y = qs(O, ir(h));
        return gn(O, Y).join("");
      }
      function bv(r, h) {
        var g = ct, O = It;
        if (vn(h)) {
          var Y = "separator" in h ? h.separator : Y;
          g = "length" in h ? xi(h.length) : g, O = "omission" in h ? Ye(h.omission) : O;
        }
        r = qi(r);
        var ut = r.length;
        if (br(r)) {
          var _t = ir(r);
          ut = _t.length;
        }
        if (g >= ut)
          return r;
        var bt = g - jr(O);
        if (bt < 1)
          return O;
        var Nt = _t ? gn(_t, 0, bt).join("") : r.slice(0, bt);
        if (Y === o)
          return Nt + O;
        if (_t && (bt += Nt.length - bt), gc(Y)) {
          if (r.slice(bt).search(Y)) {
            var se, le = Nt;
            for (Y.global || (Y = Jn(Y.source, qi(Cl.exec(Y)) + "g")), Y.lastIndex = 0; se = Y.exec(le); )
              var de = se.index;
            Nt = Nt.slice(0, de === o ? bt : de);
          }
        } else if (r.indexOf(Ye(Y), bt) != bt) {
          var ze = Nt.lastIndexOf(Y);
          ze > -1 && (Nt = Nt.slice(0, ze));
        }
        return Nt + O;
      }
      function Av(r) {
        return r = qi(r), r && Us.test(r) ? r.replace(bs, Bl) : r;
      }
      var Cv = De(function(r, h, g) {
        return r + (g ? " " : "") + h.toUpperCase();
      }), yc = Me("toUpperCase");
      function fp(r, h, g) {
        return r = qi(r), h = g ? o : h, h === o ? So(r) ? Ju(r) : Wa(r) : r.match(h) || [];
      }
      var pp = ae(function(r, h) {
        try {
          return mr(r, o, h);
        } catch (g) {
          return mc(g) ? g : new oi(g);
        }
      }), Pv = Bo(function(r, h) {
        return Yi(h, function(g) {
          g = no(g), zs(r, g, pc(r[g], r));
        }), r;
      });
      function Lv(r) {
        var h = r == null ? 0 : r.length, g = si();
        return r = h ? Xi(r, function(O) {
          if (typeof O[1] != "function")
            throw new nr(m);
          return [g(O[0]), O[1]];
        }) : [], ae(function(O) {
          for (var Y = -1; ++Y < h; ) {
            var ut = r[Y];
            if (mr(ut[0], this, O))
              return mr(ut[1], this, O);
          }
        });
      }
      function Rv(r) {
        return xa(_r(r, z));
      }
      function xc(r) {
        return function() {
          return r;
        };
      }
      function Ov(r, h) {
        return r == null || r !== r ? h : r;
      }
      var Iv = Pi(), Dv = Pi(!0);
      function Dr(r) {
        return r;
      }
      function wc(r) {
        return H(typeof r == "function" ? r : _r(r, z));
      }
      function zv(r) {
        return gt(_r(r, z));
      }
      function kv(r, h) {
        return At(r, _r(h, z));
      }
      var Bv = ae(function(r, h) {
        return function(g) {
          return e(g, r, h);
        };
      }), Nv = ae(function(r, h) {
        return function(g) {
          return e(r, g, h);
        };
      });
      function Tc(r, h, g) {
        var O = Xn(h), Y = Do(h, O);
        g == null && !(vn(h) && (Y.length || !O.length)) && (g = h, h = r, r = this, Y = Do(h, Xn(h)));
        var ut = !(vn(g) && "chain" in g) || !!g.chain, _t = Fo(r);
        return Yi(Y, function(bt) {
          var Nt = h[bt];
          r[bt] = Nt, _t && (r.prototype[bt] = function() {
            var se = this.__chain__;
            if (ut || se) {
              var le = r(this.__wrapped__), de = le.__actions__ = Qn(this.__actions__);
              return de.push({ func: Nt, args: arguments, thisArg: r }), le.__chain__ = se, le;
            }
            return Nt.apply(r, as([this.value()], arguments));
          });
        }), r;
      }
      function Fv() {
        return fn._ === this && (fn._ = Xr), this;
      }
      function Mc() {
      }
      function Uv(r) {
        return r = xi(r), ae(function(h) {
          return Z(h, r);
        });
      }
      var Gv = zn(Xi), Hv = zn(gh), Vv = zn(As);
      function dp(r) {
        return ac(r) ? Ws(no(r)) : $t(r);
      }
      function Wv(r) {
        return function(h) {
          return r == null ? o : eo(r, h);
        };
      }
      var jv = Dh(), Xv = Dh(!0);
      function Sc() {
        return [];
      }
      function Ec() {
        return !1;
      }
      function qv() {
        return {};
      }
      function Yv() {
        return "";
      }
      function Zv() {
        return !0;
      }
      function Jv(r, h) {
        if (r = xi(r), r < 1 || r > ce)
          return [];
        var g = Ot, O = Gn(r, Ot);
        h = si(h), r -= Ot;
        for (var Y = Ps(O, h); ++g < r; )
          h(g);
        return Y;
      }
      function $v(r) {
        return gi(r) ? Xi(r, no) : Yr(r) ? [r] : Qn(Df(qi(r)));
      }
      function Kv(r) {
        var h = ++sr;
        return qi(r) + h;
      }
      var Qv = yr(function(r, h) {
        return r + h;
      }, 0), t_ = Jl("ceil"), e_ = yr(function(r, h) {
        return r / h;
      }, 1), i_ = Jl("floor");
      function n_(r) {
        return r && r.length ? vs(r, Dr, ql) : o;
      }
      function r_(r, h) {
        return r && r.length ? vs(r, si(h, 2), ql) : o;
      }
      function s_(r) {
        return oa(r, Dr);
      }
      function o_(r, h) {
        return oa(r, si(h, 2));
      }
      function a_(r) {
        return r && r.length ? vs(r, Dr, rt) : o;
      }
      function l_(r, h) {
        return r && r.length ? vs(r, si(h, 2), rt) : o;
      }
      var h_ = yr(function(r, h) {
        return r * h;
      }, 1), u_ = Jl("round"), c_ = yr(function(r, h) {
        return r - h;
      }, 0);
      function f_(r) {
        return r && r.length ? Xs(r, Dr) : 0;
      }
      function p_(r, h) {
        return r && r.length ? Xs(r, si(h, 2)) : 0;
      }
      return it.after = zg, it.ary = jf, it.assign = T0, it.assignIn = sp, it.assignInWith = Pu, it.assignWith = M0, it.at = S0, it.before = Xf, it.bind = pc, it.bindAll = Pv, it.bindKey = qf, it.castArray = qg, it.chain = Hf, it.chunk = im, it.compact = nm, it.concat = rm, it.cond = Lv, it.conforms = Rv, it.constant = xc, it.countBy = fg, it.create = E0, it.curry = Yf, it.curryRight = Zf, it.debounce = Jf, it.defaults = b0, it.defaultsDeep = A0, it.defer = kg, it.delay = Bg, it.difference = sm, it.differenceBy = om, it.differenceWith = am, it.drop = lm, it.dropRight = hm, it.dropRightWhile = um, it.dropWhile = cm, it.fill = fm, it.filter = dg, it.flatMap = vg, it.flatMapDeep = _g, it.flatMapDepth = yg, it.flatten = Nf, it.flattenDeep = pm, it.flattenDepth = dm, it.flip = Ng, it.flow = Iv, it.flowRight = Dv, it.fromPairs = mm, it.functions = D0, it.functionsIn = z0, it.groupBy = xg, it.initial = vm, it.intersection = _m, it.intersectionBy = ym, it.intersectionWith = xm, it.invert = B0, it.invertBy = N0, it.invokeMap = Tg, it.iteratee = wc, it.keyBy = Mg, it.keys = Xn, it.keysIn = Ir, it.map = Mu, it.mapKeys = U0, it.mapValues = G0, it.matches = zv, it.matchesProperty = kv, it.memoize = Eu, it.merge = H0, it.mergeWith = op, it.method = Bv, it.methodOf = Nv, it.mixin = Tc, it.negate = bu, it.nthArg = Uv, it.omit = V0, it.omitBy = W0, it.once = Fg, it.orderBy = Sg, it.over = Gv, it.overArgs = Ug, it.overEvery = Hv, it.overSome = Vv, it.partial = dc, it.partialRight = $f, it.partition = Eg, it.pick = j0, it.pickBy = ap, it.property = dp, it.propertyOf = Wv, it.pull = Sm, it.pullAll = Uf, it.pullAllBy = Em, it.pullAllWith = bm, it.pullAt = Am, it.range = jv, it.rangeRight = Xv, it.rearg = Gg, it.reject = Cg, it.remove = Cm, it.rest = Hg, it.reverse = cc, it.sampleSize = Lg, it.set = q0, it.setWith = Y0, it.shuffle = Rg, it.slice = Pm, it.sortBy = Dg, it.sortedUniq = km, it.sortedUniqBy = Bm, it.split = vv, it.spread = Vg, it.tail = Nm, it.take = Fm, it.takeRight = Um, it.takeRightWhile = Gm, it.takeWhile = Hm, it.tap = ng, it.throttle = Wg, it.thru = Tu, it.toArray = ip, it.toPairs = lp, it.toPairsIn = hp, it.toPath = $v, it.toPlainObject = rp, it.transform = Z0, it.unary = jg, it.union = Vm, it.unionBy = Wm, it.unionWith = jm, it.uniq = Xm, it.uniqBy = qm, it.uniqWith = Ym, it.unset = J0, it.unzip = fc, it.unzipWith = Gf, it.update = $0, it.updateWith = K0, it.values = Ql, it.valuesIn = Q0, it.without = Zm, it.words = fp, it.wrap = Xg, it.xor = Jm, it.xorBy = $m, it.xorWith = Km, it.zip = Qm, it.zipObject = tg, it.zipObjectDeep = eg, it.zipWith = ig, it.entries = lp, it.entriesIn = hp, it.extend = sp, it.extendWith = Pu, Tc(it, it), it.add = Qv, it.attempt = pp, it.camelCase = nv, it.capitalize = up, it.ceil = t_, it.clamp = tv, it.clone = Yg, it.cloneDeep = Jg, it.cloneDeepWith = $g, it.cloneWith = Zg, it.conformsTo = Kg, it.deburr = cp, it.defaultTo = Ov, it.divide = e_, it.endsWith = rv, it.eq = Ns, it.escape = sv, it.escapeRegExp = ov, it.every = pg, it.find = mg, it.findIndex = kf, it.findKey = C0, it.findLast = gg, it.findLastIndex = Bf, it.findLastKey = P0, it.floor = i_, it.forEach = Vf, it.forEachRight = Wf, it.forIn = L0, it.forInRight = R0, it.forOwn = O0, it.forOwnRight = I0, it.get = vc, it.gt = Qg, it.gte = t0, it.has = k0, it.hasIn = _c, it.head = Ff, it.identity = Dr, it.includes = wg, it.indexOf = gm, it.inRange = ev, it.invoke = F0, it.isArguments = dl, it.isArray = gi, it.isArrayBuffer = e0, it.isArrayLike = Or, it.isArrayLikeObject = Rn, it.isBoolean = i0, it.isBuffer = Ea, it.isDate = n0, it.isElement = r0, it.isEmpty = s0, it.isEqual = o0, it.isEqualWith = a0, it.isError = mc, it.isFinite = l0, it.isFunction = Fo, it.isInteger = Kf, it.isLength = Au, it.isMap = Qf, it.isMatch = h0, it.isMatchWith = u0, it.isNaN = c0, it.isNative = f0, it.isNil = d0, it.isNull = p0, it.isNumber = tp, it.isObject = vn, it.isObjectLike = An, it.isPlainObject = Nh, it.isRegExp = gc, it.isSafeInteger = m0, it.isSet = ep, it.isString = Cu, it.isSymbol = Yr, it.isTypedArray = Kl, it.isUndefined = g0, it.isWeakMap = v0, it.isWeakSet = _0, it.join = wm, it.kebabCase = av, it.last = xs, it.lastIndexOf = Tm, it.lowerCase = lv, it.lowerFirst = hv, it.lt = y0, it.lte = x0, it.max = n_, it.maxBy = r_, it.mean = s_, it.meanBy = o_, it.min = a_, it.minBy = l_, it.stubArray = Sc, it.stubFalse = Ec, it.stubObject = qv, it.stubString = Yv, it.stubTrue = Zv, it.multiply = h_, it.nth = Mm, it.noConflict = Fv, it.noop = Mc, it.now = Su, it.pad = uv, it.padEnd = cv, it.padStart = fv, it.parseInt = pv, it.random = iv, it.reduce = bg, it.reduceRight = Ag, it.repeat = dv, it.replace = mv, it.result = X0, it.round = u_, it.runInContext = Lt, it.sample = Pg, it.size = Og, it.snakeCase = gv, it.some = Ig, it.sortedIndex = Lm, it.sortedIndexBy = Rm, it.sortedIndexOf = Om, it.sortedLastIndex = Im, it.sortedLastIndexBy = Dm, it.sortedLastIndexOf = zm, it.startCase = _v, it.startsWith = yv, it.subtract = c_, it.sum = f_, it.sumBy = p_, it.template = xv, it.times = Jv, it.toFinite = Uo, it.toInteger = xi, it.toLength = np, it.toLower = wv, it.toNumber = ws, it.toSafeInteger = w0, it.toString = qi, it.toUpper = Tv, it.trim = Mv, it.trimEnd = Sv, it.trimStart = Ev, it.truncate = bv, it.unescape = Av, it.uniqueId = Kv, it.upperCase = Cv, it.upperFirst = yc, it.each = Vf, it.eachRight = Wf, it.first = Ff, Tc(it, function() {
        var r = {};
        return Rr(it, function(h, g) {
          wi.call(it.prototype, g) || (r[g] = h);
        }), r;
      }(), { chain: !1 }), it.VERSION = p, Yi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(r) {
        it[r].placeholder = it;
      }), Yi(["drop", "take"], function(r, h) {
        _i.prototype[r] = function(g) {
          g = g === o ? 1 : pn(xi(g), 0);
          var O = this.__filtered__ && !h ? new _i(this) : this.clone();
          return O.__filtered__ ? O.__takeCount__ = Gn(g, O.__takeCount__) : O.__views__.push({
            size: Gn(g, Ot),
            type: r + (O.__dir__ < 0 ? "Right" : "")
          }), O;
        }, _i.prototype[r + "Right"] = function(g) {
          return this.reverse()[r](g).reverse();
        };
      }), Yi(["filter", "map", "takeWhile"], function(r, h) {
        var g = h + 1, O = g == G || g == Et;
        _i.prototype[r] = function(Y) {
          var ut = this.clone();
          return ut.__iteratees__.push({
            iteratee: si(Y, 3),
            type: g
          }), ut.__filtered__ = ut.__filtered__ || O, ut;
        };
      }), Yi(["head", "last"], function(r, h) {
        var g = "take" + (h ? "Right" : "");
        _i.prototype[r] = function() {
          return this[g](1).value()[0];
        };
      }), Yi(["initial", "tail"], function(r, h) {
        var g = "drop" + (h ? "" : "Right");
        _i.prototype[r] = function() {
          return this.__filtered__ ? new _i(this) : this[g](1);
        };
      }), _i.prototype.compact = function() {
        return this.filter(Dr);
      }, _i.prototype.find = function(r) {
        return this.filter(r).head();
      }, _i.prototype.findLast = function(r) {
        return this.reverse().find(r);
      }, _i.prototype.invokeMap = ae(function(r, h) {
        return typeof r == "function" ? new _i(this) : this.map(function(g) {
          return e(g, r, h);
        });
      }), _i.prototype.reject = function(r) {
        return this.filter(bu(si(r)));
      }, _i.prototype.slice = function(r, h) {
        r = xi(r);
        var g = this;
        return g.__filtered__ && (r > 0 || h < 0) ? new _i(g) : (r < 0 ? g = g.takeRight(-r) : r && (g = g.drop(r)), h !== o && (h = xi(h), g = h < 0 ? g.dropRight(-h) : g.take(h - r)), g);
      }, _i.prototype.takeRightWhile = function(r) {
        return this.reverse().takeWhile(r).reverse();
      }, _i.prototype.toArray = function() {
        return this.take(Ot);
      }, Rr(_i.prototype, function(r, h) {
        var g = /^(?:filter|find|map|reject)|While$/.test(h), O = /^(?:head|last)$/.test(h), Y = it[O ? "take" + (h == "last" ? "Right" : "") : h], ut = O || /^find/.test(h);
        Y && (it.prototype[h] = function() {
          var _t = this.__wrapped__, bt = O ? [1] : arguments, Nt = _t instanceof _i, se = bt[0], le = Nt || gi(_t), de = function(Ci) {
            var ki = Y.apply(it, as([Ci], bt));
            return O && ze ? ki[0] : ki;
          };
          le && g && typeof se == "function" && se.length != 1 && (Nt = le = !1);
          var ze = this.__chain__, Je = !!this.__actions__.length, li = ut && !ze, Ti = Nt && !Je;
          if (!ut && le) {
            _t = Ti ? _t : new _i(this);
            var hi = r.apply(_t, bt);
            return hi.__actions__.push({ func: Tu, args: [de], thisArg: o }), new Vn(hi, ze);
          }
          return li && Ti ? r.apply(this, bt) : (hi = this.thru(de), li ? O ? hi.value()[0] : hi.value() : hi);
        });
      }), Yi(["pop", "push", "shift", "sort", "splice", "unshift"], function(r) {
        var h = Pn[r], g = /^(?:push|sort|unshift)$/.test(r) ? "tap" : "thru", O = /^(?:pop|shift)$/.test(r);
        it.prototype[r] = function() {
          var Y = arguments;
          if (O && !this.__chain__) {
            var ut = this.value();
            return h.apply(gi(ut) ? ut : [], Y);
          }
          return this[g](function(_t) {
            return h.apply(gi(_t) ? _t : [], Y);
          });
        };
      }), Rr(_i.prototype, function(r, h) {
        var g = it[h];
        if (g) {
          var O = g.name + "";
          wi.call($s, O) || ($s[O] = []), $s[O].push({ name: h, func: g });
        }
      }), $s[Zi(o, x).name] = [{
        name: "wrapper",
        func: o
      }], _i.prototype.clone = ma, _i.prototype.reverse = lu, _i.prototype.value = ga, it.prototype.at = rg, it.prototype.chain = sg, it.prototype.commit = og, it.prototype.next = ag, it.prototype.plant = hg, it.prototype.reverse = ug, it.prototype.toJSON = it.prototype.valueOf = it.prototype.value = cg, it.prototype.first = it.prototype.head, Js && (it.prototype[Js] = lg), it;
    }, Ys = $u();
    Vr ? ((Vr.exports = Ys)._ = Ys, Hs._ = Ys) : fn._ = Ys;
  }).call(zr);
})(Bu, Bu.exports);
var V_ = Bu.exports;
const Bc = /* @__PURE__ */ nf(V_);
class f1 {
  constructor(l, o = [], p = !1) {
    /**
     * 矢量数据简化
     * @param {*} geojson  geojson数据
     * @returns  { Object }
     */
    bc(this, "simplifyFunc", (l) => {
      try {
        l = turf.simplify(l, {
          tolerance: 5e-4,
          highQuality: !1,
          mutate: !0
        });
      } catch {
      }
      return l;
    });
    mars3d ? (this.vectorArr = o, this.geoJsonType = /* @__PURE__ */ new Map([
      ["Point"],
      ["LineString"],
      ["Polygon"],
      ["MultiPoint"],
      ["MultiLineString"],
      ["MultiPolygon"]
    ]), this.avoidanceArr = [], this.editDate = {
      id: ""
    }, this.isDynamicMasking = p) : console.error("未引入指定插件");
  }
  /**
   * 移除矢量数据
   * @param  { String } id 矢量数据id
   *
   */
  remove(l, o = null) {
    o ? o.isClone && window.mapClone.mapEx.removeLayer(
      window.mapClone.mapEx.getLayer(l, "vectorId")
    ) : (window.map.removeLayer(window.map.getLayer(l, "vectorId")), window.dynamicMasking && window.dynamicMasking.remove(l));
  }
  /**
   * add 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } customAttributes 自定义属性
   */
  add(l, o) {
    return new Promise((p, d) => {
      let u, m = o == null ? void 0 : o.isClone;
      if (typeof l != "object") {
        let B = window.map.getLayer(l, "vectorId");
        if (B)
          return p(B);
        u = this.query(l);
      } else {
        let B = window.map.getLayer(l.id, "vectorId");
        if (B)
          return p(B);
        u = l;
      }
      let { value: _, url: T, id: S, title: C } = u;
      new Cesium.Resource({
        url: T
      }).fetchJson().then((B) => {
        let { id: I, title: F, shpInfo: E } = u, { attributes: L, geometryType: x, geometryCount: M, pointCount: R } = E;
        if (L) {
          let {
            width: b,
            materialType: U,
            materialOptions: N,
            clampToGround: j,
            distanceDisplayCondition: J,
            distanceDisplayCondition_near: $,
            distanceDisplayCondition_far: ct,
            zIndex: It,
            label: et,
            fill: yt,
            diffHeight: G,
            outline: Pt,
            outlineStyle: Et,
            color: Ct,
            pixelSize: ce,
            outlineColor: re,
            outlineWidth: Ft,
            classificationType: Ot
          } = JSON.parse(L), Bt;
          switch (this.isDynamicMasking ? (et.color = Cesium.Color.fromCssColorString(
            et.color
          ).withAlpha(0), et.outlineColor = Cesium.Color.fromCssColorString(
            et.outlineColor
          ).withAlpha(1e-3), et.backgroundColor = Cesium.Color.fromCssColorString(
            et.backgroundColor
          ).withAlpha(1e-3), et.background = !1, et.outline = !1, et.show = !1) : (et.color = Cesium.Color.fromCssColorString(et.color), et.outlineColor = Cesium.Color.fromCssColorString(
            et.outlineColor
          ), et.backgroundColor = Cesium.Color.fromCssColorString(
            et.backgroundColor
          )), x) {
            case "LineString":
            case "MultiLineString":
              et.backgroundPadding = 5, Bt = new mars3d.layer.GeoJsonLayer({
                data: B,
                vectorId: I,
                format: R > 1e4 ? this.simplifyFunc : null,
                symbol: {
                  type: "polylineC",
                  styleOptions: {
                    width: b,
                    clampToGround: j,
                    distanceDisplayCondition: J,
                    distanceDisplayCondition_far: ct,
                    distanceDisplayCondition_near: $,
                    materialType: U,
                    materialOptions: N,
                    classificationType: Ot,
                    label: et
                  }
                },
                // popup: `&nbsp;&nbsp; ${title} &nbsp;&nbsp;`,
                hasZIndex: !0,
                zIndex: It
              });
              break;
            case "Polygon":
            case "MultiPolygon":
              U == "PolyGrass" && (N = {
                evenColor: new Cesium.Color(0.25, 0.4, 0.1, 1),
                oddColor: new Cesium.Color(0.1, 0.1, 0.1, 1),
                frequency: 1.5
                // 斑驳
              }), Bt = new mars3d.layer.GeoJsonLayer({
                data: B,
                vectorId: I,
                format: R > 1e4 ? this.simplifyFunc : null,
                symbol: {
                  type: "polygon",
                  styleOptions: {
                    fill: yt,
                    diffHeight: G,
                    clampToGround: j,
                    materialType: U,
                    materialOptions: N,
                    distanceDisplayCondition: J,
                    distanceDisplayCondition_far: ct,
                    distanceDisplayCondition_near: $,
                    outlineStyle: Et,
                    outline: Pt,
                    classificationType: Ot,
                    label: et
                  }
                }
                // popup: `&nbsp;&nbsp; ${title} &nbsp;&nbsp;`,
              });
              break;
            case "Point":
            case "MultiPoint":
              Bt = new mars3d.layer.GeoJsonLayer({
                data: B,
                vectorId: I,
                format: R > 1e4 ? this.simplifyFunc : null,
                symbol: {
                  type: "pointP",
                  styleOptions: {
                    color: Ct,
                    pixelSize: ce,
                    outline: Pt,
                    outlineColor: re,
                    outlineWidth: Ft,
                    visibleDepth: !1,
                    label: et
                  }
                }
              });
              break;
          }
          m ? window.mapClone.mapEx.addLayer(Bt) : window.map.addLayer(Bt), Bt.bindPopup((fe) => {
            console.log("event", fe);
          });
          let ke = Bc.debounce((fe) => {
            console.log("测试shp矢量加载完成"), window.dynamicMasking.add(fe, JSON.parse(L));
          }, 500);
          Bt.readyPromise.then((fe) => {
            window.dynamicMasking && ke(fe), p(fe);
          }).catch((fe) => {
            console.error("测试shp矢量加载失败", fe), p({
              tite: "【矢量】<" + F + ">无法加载",
              type: "error",
              id: I,
              url: T
            });
          });
        } else
          p({
            tite: "【矢量】<" + F + ">无法加载",
            type: "error",
            id: I,
            url: T
          });
      }).catch((B) => {
        console.error("数据有误", B), p({
          tite: "【矢量】<" + C + ">链接地址有误",
          type: "error",
          id: S,
          url: T
        });
      });
    });
  }
  /**
   * 更新 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData(l) {
    this.vectorArr = l;
  }
  /**
   * 处理kml数据
   * @param  { Object } item 查询出来的对象
   * @returns { Object } 样式对象
   */
  processingKML(l) {
    let o, p = 2e3, d = !0, { kmlInfo: u } = l, {
      fill: m,
      areaColor: _,
      areaSideColor: T,
      transparency: S,
      isAreaSideColor: C,
      minDistinct: z,
      textDistinct: B,
      textSize: I,
      textColor: F,
      fontStyle: E,
      outLine: L,
      sideColor: x,
      backGround: M,
      backGroundColor: R,
      clampToGround: b
    } = u, U = {
      fill: m,
      color: _,
      opacity: S || 0.5,
      outline: C,
      outlineColor: T,
      outlineWidth: 2,
      clampToGround: b,
      // distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1000000),
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: B || 1e6,
      distanceDisplayCondition_near: z || 0,
      classificationType: o,
      opacity: String(S)
    }, N = {
      text: "{name}",
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      pixelOffsetY: -10,
      font_size: 26,
      color: F || "#ffffff",
      font_family: E || "黑体",
      outline: L || !0,
      outlineColor: x || "#000000",
      outlineWidth: 4,
      scaleByDistance: !0,
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: B || 1e6,
      distanceDisplayCondition_near: z || 0,
      background: M || !1,
      backgroundColor: R || "",
      visibleDepth: d,
      clampToGround: b || !1,
      disableDepthTestDistance: p
    };
    return {
      ...U,
      label: N
    };
  }
  /**
   * 选中矢量
   * @param  { String } id 模型id
   *
   */
  selected(l) {
    window.map.getLayer(l, "vectorId") && window.map.getLayer(l, "vectorId").flyTo();
  }
  /**
   * 查询矢量数据的对象wwwwwwwwww
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(l) {
    return this.vectorArr.length == 0 ? !1 : this.vectorArr.find((o) => o.id == l);
  }
  /**
   * 查询矢量实体的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  queryVector(l) {
    return window.map.getLayer(l, "vectorId");
  }
  /**
   * 批量编辑矢量
   * @param  { String } id 对象id
   * @param  { Object } vector 矢量对象
   * @param  { Object } label  注记对象
   * @returns { Object }
   */
  editVector(l, o, p) {
    let d = window.map.getLayer(l, "vectorId"), u = zp(o, p);
    d && (d.eachGraphic((m) => {
      m.label.show === !1 && (delete m.label.outline, delete m.label.background, delete m.label.outlineColor, delete m.label.backgroundColor), m.setStyle({
        ...u
      });
    }), window.dynamicMasking && dynamicMasking.modify(l, u));
  }
  /**
   * 加载国家边界线
   *
   * @returns { any }
   */
  nationalBoundaries() {
    let l = "/gis/nationalBoundaries.json", o = new mars3d.layer.GeoJsonLayer({
      name: "国界",
      url: l,
      format: (p) => {
        try {
          p = turf.simplify(p, {
            tolerance: 1e-5,
            highQuality: !1,
            mutate: !0
          });
        } catch (d) {
          console.error(d);
        }
        return p;
      },
      symbol: {
        type: "polylineC",
        styleOptions: {
          width: 2,
          materialType: "Color",
          materialOptions: {
            color: "#CD9B1D"
          },
          distanceDisplayCondition: !0,
          distanceDisplayCondition_near: 1e3,
          distanceDisplayCondition_far: 2e7,
          clampToGround: !0,
          classificationType: Cesium.ClassificationType.TERRAIN
        }
      }
    });
    map.addLayer(o);
  }
  /**
   * 切换动态避让
   * @returns { any }
   */
  switchDynamicMasking(l) {
    this.isDynamicMasking = l;
  }
}
class p1 {
  constructor(l = []) {
    mars3d ? (this.terrainProviderArr = l, this.terrainProviderId = "", this.events = {}, window.map.on(mars3d.EventType.terrainLoadError, (o) => {
      console.error("地形服务加载失败", o), this.hide();
    }), window.map.viewer.scene.globe.tileLoadProgressEvent.addEventListener(
      (o) => {
        window.map.viewer.scene.globe.tilesLoaded && this.emit("load", o);
      }
    )) : console.error("未引入指定插件");
  }
  /**
   * add 添加地形
   * @param  { Object || String } terrainProviderParameter 地形属性 或者 地形id
   */
  add(l) {
    let { url: o, id: p } = l;
    if (this.terrainProviderId == p && window.map.terrainProvider._layers)
      return !1;
    window.map.terrainProvider = mars3d.LayerUtil.createTerrainProvider({
      imageXyzId: p,
      type: "xyz",
      url: o,
      //item.gisInfo.gisUrl,
      requestVertexNormals: !0,
      requestMetadata: !0
    }), this.terrainProviderId = p;
  }
  /**
   * 开启地形
   *
   */
  show() {
    window.map.hasTerrain = !0;
  }
  /**
   * 隐藏地形
   *
   */
  hide() {
    window.map.hasTerrain = !1;
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(l, o) {
    l == "load" ? this.events[l] ? this.events[l].push(o) : this.events[l] = [o] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(l, ...o) {
    this.events[l] != null && this.events[l].forEach((p) => p(...o));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(l, o) {
    this.events[l] = this.events[l].filter((p) => p !== o);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(l, o) {
    const p = () => {
      o(), this.off(l, p);
    };
    this.on(l, p);
  }
  /**
   * 地形裁剪
   */
  addClip(l) {
    return new Promise((o, p) => {
      window.bimClip ? o(bimClip.clipGisAdd(l)) : p("挖洞工具未初始化");
    });
  }
}
class d1 {
  constructor(l = []) {
    mars3d ? (this.elevationImageArr = l, this.elevationImageLayer, this.form = {
      brightnessVal: 1.3,
      //环境亮度配置
      msaaSamples: 4,
      //反锯齿配置
      surfaceOpacity: 1,
      //地表不透明度
      layerOpacity: 1,
      //瓦片透明度
      layerBrightness: 2,
      //瓦片亮度
      layerContrast: 1,
      //瓦片对比度
      layerHue: 0,
      //瓦片色彩
      layerSaturation: 1,
      //瓦片饱和度
      layerGamma: 1
      //瓦片伽马值
    }) : console.error("未引入指定插件");
  }
  /**
   * 给影像数组添加数据
   * @param  { Object } data 集合数据
   */
  pushVector(l) {
    this.elevationImageArr.push(l);
  }
  /**
   * 添加影像
   * @param  { Object || String } xyzParameter 影像属性 或者 影像id
   * @param  { Object } fn 监听函数
   *
   */
  add(l, o) {
    let p;
    if (typeof l != "object" ? p = l : p = l.imageXyzId, window.map.getLayer(p, "imageXyzId"))
      return !1;
    const {
      layerOpacity: d,
      layerBrightness: u,
      layerContrast: m,
      layerHue: _,
      layerSaturation: T,
      layerGamma: S,
      surfaceOpacity: C
    } = this.exposureEnvironmentSettings();
    return new Promise((z, B) => {
      let I, F, E, L, x, M;
      if (typeof l != "object") {
        let R = this.query(l);
        R || B("缺少树结构");
        let { gisInfo: b } = R;
        I = b.id, E = b.order, F = R.url, L = b.minLevel, x = b.maxLevel;
      } else
        I = l.imageXyzId, F = l.url, E = l.zIndex, L = l.minimumLevel, x = l.maximumLevel, M = l.chinaCRS;
      this.elevationImageLayer = new mars3d.layer.XyzLayer({
        imageXyzId: I,
        type: "xyz",
        url: F,
        //item.gisUrl,
        hasZIndex: !0,
        //是否可以调整图层顺序（在同类型图层间）
        zIndex: E.toString(),
        //图层顺序，数字大的在上面。（当hasZIndex为true时）
        brightness: u,
        //亮度0.0-1.0。
        opacity: d,
        saturation: T,
        contrast: m,
        hue: _,
        gamma: S,
        alpha: C,
        show: !0,
        minimumLevel: L || 0,
        maximumLevel: x || 15,
        chinaCRS: M
        // queryParameters: { token: "zhang" },
        // headers: { Authorization: "zhang" },
      }), this.elevationImageLayer.on(mars3d.EventType.load, (R) => {
        z(R);
      }), window.map.addLayer(this.elevationImageLayer), o && Object.keys(o).forEach((R) => {
        this.elevationImageLayer.on(fnType.get(R), (b) => {
          o[R](b);
        });
      });
    });
  }
  /**
   * 移除影像方法
   * @param  { String } id 影像id
   *
   */
  remove(l) {
    console.log(l), window.map.removeLayer(window.map.getLayer(l, "imageXyzId"));
  }
  /**
   * 查询影像方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的对象 或者 false
   */
  query(l) {
    return this.elevationImageArr.length == 0 ? !1 : this.elevationImageArr.find((o) => o.id == l);
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.elevationImageArr = [], this.elevationImageLayer = null;
  }
  /**
   *
   * 是否读取本地化数据 来初始化地球
   * @returns { any }
   */
  exposureEnvironmentSettings() {
    return localStorage.getItem("environmentSettings") ? JSON.parse(localStorage.getItem("environmentSettings")) : (localStorage.setItem("environmentSettings", JSON.stringify(this.form)), JSON.parse(JSON.stringify(this.form)));
  }
}
class m1 {
  constructor(l, o, ...p) {
    /**
     * 手动释放 1秒防抖
     * @param  { object } data - 模型的树形结构
     * @returns { any }
     */
    bc(this, "manualFreed", Bc.debounce(() => {
      let { lng: l, lat: o, alt: p, pitch: d } = this.map.getCameraView(), u;
      this.modelArray.forEach((m) => {
        u = m.releasedDistance ? m.releasedDistance : 1e4, this.disTance(
          [l, o, p],
          [m.center._lng, m.center._lat, m.center._alt],
          this.calculateDistance(d, u)
        ) ? this.map.getLayer(m.id, "modelId") && this.emit("leave", m) : this.map.getLayer(m.id, "modelId") || this.emit("enter", m);
      });
    }, 200));
    mars3d ? (l && l != null && (this.modelArray = l), this.showModelArray = [], o && o != null && (this.map = o), this.Cesium = mars3d.Cesium, this.events = {}) : console.error("未引入指定插件");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(l, o) {
    l == "enter" || l == "leave" ? this.events[l] ? this.events[l].push(o) : this.events[l] = [o] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(l, ...o) {
    this.events[l] != null && this.events[l].forEach((p) => p(...o));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(l, o) {
    this.events[l] = this.events[l].filter((p) => p !== o);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(l, o) {
    const p = () => {
      o(), this.off(l, p);
    };
    this.on(l, p);
  }
  /**
   * modelArray
   * 读取数据
   * @param  { string | number } key - 需要查询对象的key 目前只有 modelArray 和 showModelIdArray
   * @returns { any }
   */
  say(l) {
    return this[l];
  }
  /**
   * modelArray
   * 添加数据
   * @param  { string | number } key - 需要添加对象的key 目前只有 modelArray 和 showModelArray
   * @param  { object | array } item - 添加的数据item
   * @returns { any }
   */
  add(l, o) {
    this[l].push(o);
  }
  /**
   * modelArray
   * 移除数据
   * @param  { string | number } key - 需要添加对象的key 目前只有 showModelArray
   * @param  { object | array } item - 添加的数据item
   * @returns { any }
   */
  remove(l, o) {
    this[l] = this[l].filter(function(p) {
      return p !== o;
    });
  }
  /**
   * modelArray && events
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArray = [], this.events = {};
  }
  /**
   * 工具函数
   * modelArray - excavationDetails
   * 更新 modelArray 自定义属性 excavationDetails
   * @param  { string } parentId - 模型id
   * @param  { string } id - 自己实例的id
   * @param  { string } type - update | delete | add | edit 操作类型
   * @param  { object | array } data - 更新的数据
   * @returns { object }
   */
  updateCustomExcavationDetails(l, o, p, d = [], u = {}) {
    let m, _, T;
    switch (m = this.modelArray.find((S) => S.modelId == l).customize.bimModelExcavationDetails, T = m.find((S, C) => {
      if (S.id == o)
        return _ = C, S;
    }), p) {
      case "delete":
        m.splice(_, 1);
        break;
      case "update":
        T.excavationDetails = d;
        break;
      case "add":
        m.push(u);
        break;
      case "edit":
        T.excavationDetails = u.excavationDetails, T.kId = u.kId;
        break;
    }
    return m;
  }
  /**
   * 工具函数
   * 开启视角监听事件 调用freed来实现动态释放逻辑
   * @param  { object } data - 模型的树形结构 重要数据
   * @returns { any }
   */
  resourceRelease() {
    this.map.viewer.camera.moveEnd.addEventListener(() => {
      this.freed();
    });
  }
  /**
   * 功能函数
   * 动态释放的主要逻辑
   * @param  { object } data - 模型的树形结构
   * @returns { any }
   */
  freed() {
    let { alt: l } = this.map.getCameraView();
    l < 2e4 && (this.freed = Bc.throttle(() => {
      let { lng: o, lat: p, alt: d, pitch: u } = this.map.getCameraView();
      this.modelArray && this.modelArray.forEach((m) => {
        let _ = m.bimModel.releasedDistance ? m.bimModel.releasedDistance : 1e4;
        m.center && this.disTance(
          [o, p, d],
          [m.center._lng, m.center._lat, m.center._alt],
          this.calculateDistance(u, _)
        ) ? this.map.getLayer(m.id, "modelId") && this.emit("leave", m) : this.showModelArray.indexOf(m.id) >= 0 && !this.map.getLayer(m.id, "modelId") && this.emit("enter", m);
      });
    }, 2e3), this.freed());
  }
  /**
   * 通过id查询对象
   * @param  { object } data - 模型的树形结构
   * @param  { string } id - 模型id
   * @param  { string } type - 查找类型
   * @returns { boolean }
   */
  findPnodeId(l, o, p = "id") {
    let d;
    if (l) {
      for (var u = 0; u < l.length; u++) {
        let m = l[u];
        if (m[p] == o)
          return d = m, d;
        if (m.children && m.children.length > 0 && (d = this.findPnodeId(m.children, o, p), d))
          return d;
      }
      return d;
    }
  }
  /**
   * modelArray
   * 动态释放的计算方法
   * @param  { array } positionsStart - 起始坐标
   * @param  { array } positionsEnd - 结束坐标
   * @param  { number } limit - 设置的长度
   * @returns { boolean }
   */
  disTance(l, o, p) {
    let d, u, m;
    return d = Cesium.Cartesian3.fromDegrees(...l), u = Cesium.Cartesian3.fromDegrees(...o), m = Cesium.Cartesian3.distance(d, u), m > p;
  }
  /**
   * @function 获取模型的可视范围
   * @param { number } angle 当前角度
   * @param { number } maxDistance 最大可视距离
   * @returns { number } 当前可视距离
   * */
  calculateDistance(l, o) {
    let p = (l + 180) % 360 - 180;
    p = Math.max(-90, Math.min(p, 90));
    let d = (o - o / 5) * (Math.abs(p) / 90) + o / 5;
    return Math.round(d);
  }
}
class g1 {
  constructor(l = [], o) {
    mars3d ? (this.entityArr = l, this.entityLayer = new mars3d.layer.GraphicLayer({
      entityId: "bimEntity"
    }), window.map.addLayer(this.entityLayer), this.entityItem = null, this.events = {}, this.entityCloneLayer) : console.error("未引入指定插件");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持change和collection
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(l, o) {
    l == "change" || l == "collection" ? this.events[l] ? this.events[l].push(o) : this.events[l] = [o] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(l, ...o) {
    this.events[l] != null && this.events[l].forEach((p) => p(...o));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(l, o) {
    this.events[l] = this.events[l].filter((p) => p !== o);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(l, o) {
    const p = () => {
      o(), this.off(l, p);
    };
    this.on(l, p);
  }
  /**
   * 添加标会实例
   * @param  { String } modelParameter 标绘实例id 或者 标绘参数
   *
   */
  add(l, o = null, p) {
    return new Promise((d, u) => {
      var m;
      if (this.entityLayer) {
        let _, T, S;
        if (p == null ? void 0 : p.isClone)
          this.entityCloneLayer && (T = this.query(l), S = JSON.parse(T.bimPlanPainting.graphic), S.attr = S.attr || {}, S.attr.entityId = l, this.entityCloneLayer.addGraphic(S));
        else {
          if (typeof l != "object" ? (_ = this.entityLayer.getGraphicByAttr(
            l,
            "entityId"
          ), T = this.query(l), S = JSON.parse(T.bimPlanPainting.graphic), S.attr = S.attr || {}, S.attr.entityId = l) : (_ = this.entityLayer.getGraphicByAttr(
            l.id,
            "entityId"
          ), S = JSON.parse(JSON.stringify(l)), S.attr = S.attr || {}, S.attr.entityId = S.attr.entityId || o, S.attr == null ? S.attr = {
            entityId: l.id
          } : ((m = S.attr) == null ? void 0 : m.entityId) == null && o && (S.attr.entityId = o)), _)
            return d();
          this.entityLayer.addGraphic(S), d(S);
        }
      } else
        d(), console.error("未初始化标绘实例图层");
    });
  }
  /**
   * 查询矢量数据的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(l) {
    return this.entityArr.length == 0 ? !1 : this.entityArr.find((o) => o.id == l);
  }
  /**
   * 查询矢量数据的实体
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 返回标绘实体
   */
  queryEntity(l) {
    if (bimEntity.entityLayer)
      return bimEntity.entityLayer.getGraphicByAttr(l, "entityId");
  }
  /**
   * 选中标绘
   * @param  { String } id 模型id
   *
   */
  selected(l, o = null) {
    let p = this.entityLayer.getGraphicByAttr(l, "entityId");
    o == null || o.isClone, p._point && p._point._alt > 0 ? p.flyTo({
      radius: p._point._alt + 500
    }) : p.flyTo();
  }
  /**
   * 移除标绘
   * @param  { String } id 模型id
   *
   */
  remove(l, o = null) {
    (o == null ? void 0 : o.isClone) ? this.entityCloneLayer && this.entityCloneLayer.getGraphicByAttr(l, "entityId").remove() : this.entityLayer.getGraphicByAttr(l, "entityId") && (this.entityLayer.getGraphicByAttr(l, "entityId").remove(), this.entityItem && (this.entityItem._state == "destroy" || this.entityItem.options.attr.entityId == l) && (this.entityItem = null));
  }
  entityCloneLayerInit() {
    this.entityCloneLayer == null && (this.entityCloneLayer = window.mapClone._mapEx.getLayer(
      "bimEntity",
      "entityId"
    ));
  }
  /**
   * 移除克隆场景的标绘
   *
   */
  entityCloneLayerRemove() {
    console.log("没用移除"), this.entityCloneLayer.remove(), this.entityCloneLayer = null;
  }
  /**
   * 移除当前标绘对象
   * @param  { String } id 模型id
   *
   */
  removeEntityItem() {
    this.entityItem = null;
  }
  /**
   * 更新 矢量数据集合
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData(l) {
    this.entityArr = l;
  }
  /**
   * 开始绘制标绘
   * @param  { Object } data 标绘参数
   *
   */
  startDrawGraphic(l) {
    let { type: o, style: p } = l;
    if (o == "div")
      if (p.html)
        this.entityLayer.startDraw(l).then((d) => {
          setTimeout(() => {
            this.entityItem = d, this.entityLayer.startEditing(d);
          }, 500);
        });
      else {
        let {
          title: d,
          divType: u,
          theme_color: m,
          font_color: _,
          scaleByDistance: T,
          scaleByDistance_far: S,
          scaleByDistance_farValue: C,
          scaleByDistance_near: z,
          scaleByDistance_nearValue: B,
          distanceDisplayCondition: I,
          distanceDisplayCondition_far: F,
          distanceDisplayCondition_near: E,
          clampToGround: L
        } = p, x = {
          type: "div",
          style: {
            pointerEvents: !0,
            scaleByDistance: T,
            scaleByDistance_far: S,
            scaleByDistance_farValue: C,
            scaleByDistance_near: z,
            scaleByDistance_nearValue: B,
            distanceDisplayCondition: I,
            distanceDisplayCondition_far: F,
            distanceDisplayCondition_near: E,
            clampToGround: L,
            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM
          }
        };
        switch (u) {
          case "1":
            x.style.html = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${m};--theme-font-color1:${_};">
            <div class="title">${d}</div>
          </div>`, x.style.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
            break;
        }
        this.entityLayer.startDraw(x).then((M) => {
          setTimeout(() => {
            this.entityItem = M, this.entityLayer.startEditing(M);
          }, 500);
        });
      }
    else
      this.entityLayer.startDraw(l).then((d) => {
        setTimeout(() => {
          this.entityItem = d, this.entityLayer.startEditing(d);
        }, 500);
      });
  }
  /**
   * 停止绘制标绘
   *
   */
  stopDraw(l = !0) {
    this.entityLayer && this.entityLayer.stopDraw(), l && this.entityItem && (this.entityItem.stopEditing(), this.entityItem.remove(), this.entityItem = null);
  }
  /**
   * 更新标绘
   * @param  { Object } data 标绘参数
   *
   */
  updateEntityItem(l) {
    let o = this.entityLayer.getGraphicByAttr(l, "entityId");
    o && (this.entityItem = o);
  }
  /**
   * 编辑标绘
   * @param  { String | Number } id 标绘id或者是edit新建标绘
   * @param  { Object } vector 标绘主体
   * @param  { Object } label 标绘label
   * @param  { String } 自定义类型 目前有div
   */
  edit(l, o, p, d) {
    let u = zp(o, p);
    o.vectorStyle && this.entityItem && (o.vectorStyle.divType == 5 ? this.entityItem.setStyle({
      ...u,
      horizontalOrigin: Cesium.HorizontalOrigin.LEFT
    }) : this.entityItem.setStyle({
      ...u
      // horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
    }));
  }
  /**
   * 开启拖动/关闭拖动
   * @param  { Boolean } isEnableDragging 是否开启
   */
  enableDragging(l = !0) {
    l ? this.entityLayer.startEditing(this.entityItem) : (this.entityLayer.stopDraw(), this.entityItem && this.entityItem.stopEditing());
  }
  /**
   * 添加右键菜单
   *
   */
  addRightMenu() {
    this.entityLayer.bindContextMenu([
      {
        text: "编辑对象",
        callback: (l) => {
          this.emit("change", l);
        }
      },
      {
        text: "收藏对象",
        callback: (l) => {
          this.emit("collection", l);
        }
      }
    ]);
  }
  /**
   * 移除右键菜单
   *
   */
  removeRightMenu() {
    this.entityLayer.hasContextMenu() && this.entityLayer.unbindContextMenu();
  }
  /**
   * 解耦div数据
   * @param  { String } htmlString HTML字符串
   * @returns { Object } 返回的是表单数据
   */
  processDivData(l) {
    let o = {
      "--theme-color1": "theme_color",
      "--theme-font-color1": "font_color",
      "--theme-color2": "theme_color2",
      "--theme-color3": "theme_color3"
    }, p = {
      title: "",
      theme_color: "",
      font_color: "",
      content: "",
      divType: "",
      divStyle: {}
    };
    const d = document.createElement("div");
    d.innerHTML = l;
    const u = d.querySelector(".entity-div-style");
    return console.log("解耦", u), Object.keys(o).forEach((m) => {
      m == "--theme-color2" || m == "--theme-color3" ? p.divStyle[o[m]] = u.style.getPropertyValue(m) || "#fff" : p[o[m]] = u.style.getPropertyValue(m);
    }), p.title = u.querySelector(".title") ? u.querySelector(".title").innerText : "标题", p.content = u.querySelector(".content") ? u.querySelector(".content").innerText : "内容", p.divType = u.classList[1] ? u.classList[1].replace("entity-div-style", "") : "", p;
  }
  /**
   * 更新html数据
   * @param  { String } divType 类型
   * @param  { Object } list 配合类型的样式参数
   * @returns { Object } html 字符串
   */
  updateHtml(l, o) {
    let { theme_color: p, font_color: d, title: u, content: m, divStyle: _ } = o, { theme_color2: T, theme_color3: S } = _, C = "";
    switch (l) {
      case "1":
        C = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${p};--theme-font-color1:${d};">
            <div class="title">${u}</div>
          </div>`;
        break;
      case "2":
        C = `<div class="entity-div-style entity-div-style2" style="--theme-color1:${p};--theme-font-color1:${d};">
            <div class="title">${u}</div>
            <div class="mars3d-divUpLabel-line"></div>
          </div>`;
        break;
      case "3":
        C = `<div class="entity-div-style entity-div-style3" style="--theme-color1:${p};--theme-font-color1:${d};--theme-color2:${T};--theme-color3:${S}">
            <div class="image"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="infotop"><div class="title">${u}</div><div class="content overflow-auto scrollbar h-full">${m}</div></div>
          </div >`;
        break;
      case "4":
        C = `<div class="entity-div-style entity-div-style4" style="--theme-color1:${p};--theme-font-color1:${d};">
            <div class="title">${u}</div>
          </div >`;
        break;
      case "5":
        C = `<div class="entity-div-style entity-div-style5 marsTiltPanel marsTiltPanel-theme-green" style="--theme-color1:${p};--theme-font-color1:${d};--theme-color2:${T};">
            <div class="marsTiltPanel-wrap">
              <div class="area">
                <div class="arrow-lt"></div>
                <div class="b-t"></div>
                <div class="b-r"></div>
                <div class="b-b"></div>
                <div class="b-l"></div>
                <div class="arrow-rb"></div>
                <div class="label-wrap">
                  <div class="title">${u}</div>
                  <div class="content">${m}</div>
                </div>
              </div>
              <div class="b-t-l"></div>
              <div class="b-b-r"></div>
            </div>
            <div class="arrow"></div>
          </div >`;
        break;
      case "6":
        C = `<div class="entity-div-style entity-div-style6" style="--theme-color1:${p};--theme-font-color1:${d};--theme-color2:${T};">
            <div class="title">${u}</div>
          </div >`;
        break;
      case "7":
        C = `<div class="entity-div-style entity-div-style7" style="--theme-color1:${p};--theme-font-color1:${d};">
            <div class="title">${u}</div>
            <div class="pile-number">
              <div class="circular"></div>
              <div class="pole"></div>
            </div>
          </div >`;
        break;
    }
    return C;
  }
}
function Ru(w) {
  throw new Error('Could not dynamically require "' + w + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var kp = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(w, l) {
  (function(o) {
    w.exports = o();
  })(function() {
    return function o(p, d, u) {
      function m(S, C) {
        if (!d[S]) {
          if (!p[S]) {
            var z = typeof Ru == "function" && Ru;
            if (!C && z)
              return z(S, !0);
            if (_)
              return _(S, !0);
            var B = new Error("Cannot find module '" + S + "'");
            throw B.code = "MODULE_NOT_FOUND", B;
          }
          var I = d[S] = { exports: {} };
          p[S][0].call(I.exports, function(F) {
            var E = p[S][1][F];
            return m(E || F);
          }, I, I.exports, o, p, d, u);
        }
        return d[S].exports;
      }
      for (var _ = typeof Ru == "function" && Ru, T = 0; T < u.length; T++)
        m(u[T]);
      return m;
    }({ 1: [function(o, p, d) {
      var u = o("./utils"), m = o("./support"), _ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      d.encode = function(T) {
        for (var S, C, z, B, I, F, E, L = [], x = 0, M = T.length, R = M, b = u.getTypeOf(T) !== "string"; x < T.length; )
          R = M - x, z = b ? (S = T[x++], C = x < M ? T[x++] : 0, x < M ? T[x++] : 0) : (S = T.charCodeAt(x++), C = x < M ? T.charCodeAt(x++) : 0, x < M ? T.charCodeAt(x++) : 0), B = S >> 2, I = (3 & S) << 4 | C >> 4, F = 1 < R ? (15 & C) << 2 | z >> 6 : 64, E = 2 < R ? 63 & z : 64, L.push(_.charAt(B) + _.charAt(I) + _.charAt(F) + _.charAt(E));
        return L.join("");
      }, d.decode = function(T) {
        var S, C, z, B, I, F, E = 0, L = 0, x = "data:";
        if (T.substr(0, x.length) === x)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var M, R = 3 * (T = T.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (T.charAt(T.length - 1) === _.charAt(64) && R--, T.charAt(T.length - 2) === _.charAt(64) && R--, R % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (M = m.uint8array ? new Uint8Array(0 | R) : new Array(0 | R); E < T.length; )
          S = _.indexOf(T.charAt(E++)) << 2 | (B = _.indexOf(T.charAt(E++))) >> 4, C = (15 & B) << 4 | (I = _.indexOf(T.charAt(E++))) >> 2, z = (3 & I) << 6 | (F = _.indexOf(T.charAt(E++))), M[L++] = S, I !== 64 && (M[L++] = C), F !== 64 && (M[L++] = z);
        return M;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(o, p, d) {
      var u = o("./external"), m = o("./stream/DataWorker"), _ = o("./stream/Crc32Probe"), T = o("./stream/DataLengthProbe");
      function S(C, z, B, I, F) {
        this.compressedSize = C, this.uncompressedSize = z, this.crc32 = B, this.compression = I, this.compressedContent = F;
      }
      S.prototype = { getContentWorker: function() {
        var C = new m(u.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new T("data_length")), z = this;
        return C.on("end", function() {
          if (this.streamInfo.data_length !== z.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), C;
      }, getCompressedWorker: function() {
        return new m(u.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, S.createWorkerFrom = function(C, z, B) {
        return C.pipe(new _()).pipe(new T("uncompressedSize")).pipe(z.compressWorker(B)).pipe(new T("compressedSize")).withStreamInfo("compression", z);
      }, p.exports = S;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(o, p, d) {
      var u = o("./stream/GenericWorker");
      d.STORE = { magic: "\0\0", compressWorker: function() {
        return new u("STORE compression");
      }, uncompressWorker: function() {
        return new u("STORE decompression");
      } }, d.DEFLATE = o("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(o, p, d) {
      var u = o("./utils"), m = function() {
        for (var _, T = [], S = 0; S < 256; S++) {
          _ = S;
          for (var C = 0; C < 8; C++)
            _ = 1 & _ ? 3988292384 ^ _ >>> 1 : _ >>> 1;
          T[S] = _;
        }
        return T;
      }();
      p.exports = function(_, T) {
        return _ !== void 0 && _.length ? u.getTypeOf(_) !== "string" ? function(S, C, z, B) {
          var I = m, F = B + z;
          S ^= -1;
          for (var E = B; E < F; E++)
            S = S >>> 8 ^ I[255 & (S ^ C[E])];
          return -1 ^ S;
        }(0 | T, _, _.length, 0) : function(S, C, z, B) {
          var I = m, F = B + z;
          S ^= -1;
          for (var E = B; E < F; E++)
            S = S >>> 8 ^ I[255 & (S ^ C.charCodeAt(E))];
          return -1 ^ S;
        }(0 | T, _, _.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(o, p, d) {
      d.base64 = !1, d.binary = !1, d.dir = !1, d.createFolders = !0, d.date = null, d.compression = null, d.compressionOptions = null, d.comment = null, d.unixPermissions = null, d.dosPermissions = null;
    }, {}], 6: [function(o, p, d) {
      var u = null;
      u = typeof Promise < "u" ? Promise : o("lie"), p.exports = { Promise: u };
    }, { lie: 37 }], 7: [function(o, p, d) {
      var u = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", m = o("pako"), _ = o("./utils"), T = o("./stream/GenericWorker"), S = u ? "uint8array" : "array";
      function C(z, B) {
        T.call(this, "FlateWorker/" + z), this._pako = null, this._pakoAction = z, this._pakoOptions = B, this.meta = {};
      }
      d.magic = "\b\0", _.inherits(C, T), C.prototype.processChunk = function(z) {
        this.meta = z.meta, this._pako === null && this._createPako(), this._pako.push(_.transformTo(S, z.data), !1);
      }, C.prototype.flush = function() {
        T.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, C.prototype.cleanUp = function() {
        T.prototype.cleanUp.call(this), this._pako = null;
      }, C.prototype._createPako = function() {
        this._pako = new m[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var z = this;
        this._pako.onData = function(B) {
          z.push({ data: B, meta: z.meta });
        };
      }, d.compressWorker = function(z) {
        return new C("Deflate", z);
      }, d.uncompressWorker = function() {
        return new C("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(o, p, d) {
      function u(I, F) {
        var E, L = "";
        for (E = 0; E < F; E++)
          L += String.fromCharCode(255 & I), I >>>= 8;
        return L;
      }
      function m(I, F, E, L, x, M) {
        var R, b, U = I.file, N = I.compression, j = M !== S.utf8encode, J = _.transformTo("string", M(U.name)), $ = _.transformTo("string", S.utf8encode(U.name)), ct = U.comment, It = _.transformTo("string", M(ct)), et = _.transformTo("string", S.utf8encode(ct)), yt = $.length !== U.name.length, G = et.length !== ct.length, Pt = "", Et = "", Ct = "", ce = U.dir, re = U.date, Ft = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        F && !E || (Ft.crc32 = I.crc32, Ft.compressedSize = I.compressedSize, Ft.uncompressedSize = I.uncompressedSize);
        var Ot = 0;
        F && (Ot |= 8), j || !yt && !G || (Ot |= 2048);
        var Bt = 0, ke = 0;
        ce && (Bt |= 16), x === "UNIX" ? (ke = 798, Bt |= function(Yt, ti) {
          var Ni = Yt;
          return Yt || (Ni = ti ? 16893 : 33204), (65535 & Ni) << 16;
        }(U.unixPermissions, ce)) : (ke = 20, Bt |= function(Yt) {
          return 63 & (Yt || 0);
        }(U.dosPermissions)), R = re.getUTCHours(), R <<= 6, R |= re.getUTCMinutes(), R <<= 5, R |= re.getUTCSeconds() / 2, b = re.getUTCFullYear() - 1980, b <<= 4, b |= re.getUTCMonth() + 1, b <<= 5, b |= re.getUTCDate(), yt && (Et = u(1, 1) + u(C(J), 4) + $, Pt += "up" + u(Et.length, 2) + Et), G && (Ct = u(1, 1) + u(C(It), 4) + et, Pt += "uc" + u(Ct.length, 2) + Ct);
        var fe = "";
        return fe += `
\0`, fe += u(Ot, 2), fe += N.magic, fe += u(R, 2), fe += u(b, 2), fe += u(Ft.crc32, 4), fe += u(Ft.compressedSize, 4), fe += u(Ft.uncompressedSize, 4), fe += u(J.length, 2), fe += u(Pt.length, 2), { fileRecord: z.LOCAL_FILE_HEADER + fe + J + Pt, dirRecord: z.CENTRAL_FILE_HEADER + u(ke, 2) + fe + u(It.length, 2) + "\0\0\0\0" + u(Bt, 4) + u(L, 4) + J + Pt + It };
      }
      var _ = o("../utils"), T = o("../stream/GenericWorker"), S = o("../utf8"), C = o("../crc32"), z = o("../signature");
      function B(I, F, E, L) {
        T.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = F, this.zipPlatform = E, this.encodeFileName = L, this.streamFiles = I, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      _.inherits(B, T), B.prototype.push = function(I) {
        var F = I.meta.percent || 0, E = this.entriesCount, L = this._sources.length;
        this.accumulate ? this.contentBuffer.push(I) : (this.bytesWritten += I.data.length, T.prototype.push.call(this, { data: I.data, meta: { currentFile: this.currentFile, percent: E ? (F + 100 * (E - L - 1)) / E : 100 } }));
      }, B.prototype.openedSource = function(I) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = I.file.name;
        var F = this.streamFiles && !I.file.dir;
        if (F) {
          var E = m(I, F, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: E.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, B.prototype.closedSource = function(I) {
        this.accumulate = !1;
        var F = this.streamFiles && !I.file.dir, E = m(I, F, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(E.dirRecord), F)
          this.push({ data: function(L) {
            return z.DATA_DESCRIPTOR + u(L.crc32, 4) + u(L.compressedSize, 4) + u(L.uncompressedSize, 4);
          }(I), meta: { percent: 100 } });
        else
          for (this.push({ data: E.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, B.prototype.flush = function() {
        for (var I = this.bytesWritten, F = 0; F < this.dirRecords.length; F++)
          this.push({ data: this.dirRecords[F], meta: { percent: 100 } });
        var E = this.bytesWritten - I, L = function(x, M, R, b, U) {
          var N = _.transformTo("string", U(b));
          return z.CENTRAL_DIRECTORY_END + "\0\0\0\0" + u(x, 2) + u(x, 2) + u(M, 4) + u(R, 4) + u(N.length, 2) + N;
        }(this.dirRecords.length, E, I, this.zipComment, this.encodeFileName);
        this.push({ data: L, meta: { percent: 100 } });
      }, B.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, B.prototype.registerPrevious = function(I) {
        this._sources.push(I);
        var F = this;
        return I.on("data", function(E) {
          F.processChunk(E);
        }), I.on("end", function() {
          F.closedSource(F.previous.streamInfo), F._sources.length ? F.prepareNextSource() : F.end();
        }), I.on("error", function(E) {
          F.error(E);
        }), this;
      }, B.prototype.resume = function() {
        return !!T.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, B.prototype.error = function(I) {
        var F = this._sources;
        if (!T.prototype.error.call(this, I))
          return !1;
        for (var E = 0; E < F.length; E++)
          try {
            F[E].error(I);
          } catch {
          }
        return !0;
      }, B.prototype.lock = function() {
        T.prototype.lock.call(this);
        for (var I = this._sources, F = 0; F < I.length; F++)
          I[F].lock();
      }, p.exports = B;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(o, p, d) {
      var u = o("../compressions"), m = o("./ZipFileWorker");
      d.generateWorker = function(_, T, S) {
        var C = new m(T.streamFiles, S, T.platform, T.encodeFileName), z = 0;
        try {
          _.forEach(function(B, I) {
            z++;
            var F = function(M, R) {
              var b = M || R, U = u[b];
              if (!U)
                throw new Error(b + " is not a valid compression method !");
              return U;
            }(I.options.compression, T.compression), E = I.options.compressionOptions || T.compressionOptions || {}, L = I.dir, x = I.date;
            I._compressWorker(F, E).withStreamInfo("file", { name: B, dir: L, date: x, comment: I.comment || "", unixPermissions: I.unixPermissions, dosPermissions: I.dosPermissions }).pipe(C);
          }), C.entriesCount = z;
        } catch (B) {
          C.error(B);
        }
        return C;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(o, p, d) {
      function u() {
        if (!(this instanceof u))
          return new u();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var m = new u();
          for (var _ in this)
            typeof this[_] != "function" && (m[_] = this[_]);
          return m;
        };
      }
      (u.prototype = o("./object")).loadAsync = o("./load"), u.support = o("./support"), u.defaults = o("./defaults"), u.version = "3.10.1", u.loadAsync = function(m, _) {
        return new u().loadAsync(m, _);
      }, u.external = o("./external"), p.exports = u;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(o, p, d) {
      var u = o("./utils"), m = o("./external"), _ = o("./utf8"), T = o("./zipEntries"), S = o("./stream/Crc32Probe"), C = o("./nodejsUtils");
      function z(B) {
        return new m.Promise(function(I, F) {
          var E = B.decompressed.getContentWorker().pipe(new S());
          E.on("error", function(L) {
            F(L);
          }).on("end", function() {
            E.streamInfo.crc32 !== B.decompressed.crc32 ? F(new Error("Corrupted zip : CRC32 mismatch")) : I();
          }).resume();
        });
      }
      p.exports = function(B, I) {
        var F = this;
        return I = u.extend(I || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: _.utf8decode }), C.isNode && C.isStream(B) ? m.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", B, !0, I.optimizedBinaryString, I.base64).then(function(E) {
          var L = new T(I);
          return L.load(E), L;
        }).then(function(E) {
          var L = [m.Promise.resolve(E)], x = E.files;
          if (I.checkCRC32)
            for (var M = 0; M < x.length; M++)
              L.push(z(x[M]));
          return m.Promise.all(L);
        }).then(function(E) {
          for (var L = E.shift(), x = L.files, M = 0; M < x.length; M++) {
            var R = x[M], b = R.fileNameStr, U = u.resolve(R.fileNameStr);
            F.file(U, R.decompressed, { binary: !0, optimizedBinaryString: !0, date: R.date, dir: R.dir, comment: R.fileCommentStr.length ? R.fileCommentStr : null, unixPermissions: R.unixPermissions, dosPermissions: R.dosPermissions, createFolders: I.createFolders }), R.dir || (F.file(U).unsafeOriginalName = b);
          }
          return L.zipComment.length && (F.comment = L.zipComment), F;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(o, p, d) {
      var u = o("../utils"), m = o("../stream/GenericWorker");
      function _(T, S) {
        m.call(this, "Nodejs stream input adapter for " + T), this._upstreamEnded = !1, this._bindStream(S);
      }
      u.inherits(_, m), _.prototype._bindStream = function(T) {
        var S = this;
        (this._stream = T).pause(), T.on("data", function(C) {
          S.push({ data: C, meta: { percent: 0 } });
        }).on("error", function(C) {
          S.isPaused ? this.generatedError = C : S.error(C);
        }).on("end", function() {
          S.isPaused ? S._upstreamEnded = !0 : S.end();
        });
      }, _.prototype.pause = function() {
        return !!m.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, _.prototype.resume = function() {
        return !!m.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, p.exports = _;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(o, p, d) {
      var u = o("readable-stream").Readable;
      function m(_, T, S) {
        u.call(this, T), this._helper = _;
        var C = this;
        _.on("data", function(z, B) {
          C.push(z) || C._helper.pause(), S && S(B);
        }).on("error", function(z) {
          C.emit("error", z);
        }).on("end", function() {
          C.push(null);
        });
      }
      o("../utils").inherits(m, u), m.prototype._read = function() {
        this._helper.resume();
      }, p.exports = m;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(o, p, d) {
      p.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(u, m) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(u, m);
        if (typeof u == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(u, m);
      }, allocBuffer: function(u) {
        if (Buffer.alloc)
          return Buffer.alloc(u);
        var m = new Buffer(u);
        return m.fill(0), m;
      }, isBuffer: function(u) {
        return Buffer.isBuffer(u);
      }, isStream: function(u) {
        return u && typeof u.on == "function" && typeof u.pause == "function" && typeof u.resume == "function";
      } };
    }, {}], 15: [function(o, p, d) {
      function u(U, N, j) {
        var J, $ = _.getTypeOf(N), ct = _.extend(j || {}, C);
        ct.date = ct.date || /* @__PURE__ */ new Date(), ct.compression !== null && (ct.compression = ct.compression.toUpperCase()), typeof ct.unixPermissions == "string" && (ct.unixPermissions = parseInt(ct.unixPermissions, 8)), ct.unixPermissions && 16384 & ct.unixPermissions && (ct.dir = !0), ct.dosPermissions && 16 & ct.dosPermissions && (ct.dir = !0), ct.dir && (U = x(U)), ct.createFolders && (J = L(U)) && M.call(this, J, !0);
        var It = $ === "string" && ct.binary === !1 && ct.base64 === !1;
        j && j.binary !== void 0 || (ct.binary = !It), (N instanceof z && N.uncompressedSize === 0 || ct.dir || !N || N.length === 0) && (ct.base64 = !1, ct.binary = !0, N = "", ct.compression = "STORE", $ = "string");
        var et = null;
        et = N instanceof z || N instanceof T ? N : F.isNode && F.isStream(N) ? new E(U, N) : _.prepareContent(U, N, ct.binary, ct.optimizedBinaryString, ct.base64);
        var yt = new B(U, et, ct);
        this.files[U] = yt;
      }
      var m = o("./utf8"), _ = o("./utils"), T = o("./stream/GenericWorker"), S = o("./stream/StreamHelper"), C = o("./defaults"), z = o("./compressedObject"), B = o("./zipObject"), I = o("./generate"), F = o("./nodejsUtils"), E = o("./nodejs/NodejsStreamInputAdapter"), L = function(U) {
        U.slice(-1) === "/" && (U = U.substring(0, U.length - 1));
        var N = U.lastIndexOf("/");
        return 0 < N ? U.substring(0, N) : "";
      }, x = function(U) {
        return U.slice(-1) !== "/" && (U += "/"), U;
      }, M = function(U, N) {
        return N = N !== void 0 ? N : C.createFolders, U = x(U), this.files[U] || u.call(this, U, null, { dir: !0, createFolders: N }), this.files[U];
      };
      function R(U) {
        return Object.prototype.toString.call(U) === "[object RegExp]";
      }
      var b = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(U) {
        var N, j, J;
        for (N in this.files)
          J = this.files[N], (j = N.slice(this.root.length, N.length)) && N.slice(0, this.root.length) === this.root && U(j, J);
      }, filter: function(U) {
        var N = [];
        return this.forEach(function(j, J) {
          U(j, J) && N.push(J);
        }), N;
      }, file: function(U, N, j) {
        if (arguments.length !== 1)
          return U = this.root + U, u.call(this, U, N, j), this;
        if (R(U)) {
          var J = U;
          return this.filter(function(ct, It) {
            return !It.dir && J.test(ct);
          });
        }
        var $ = this.files[this.root + U];
        return $ && !$.dir ? $ : null;
      }, folder: function(U) {
        if (!U)
          return this;
        if (R(U))
          return this.filter(function($, ct) {
            return ct.dir && U.test($);
          });
        var N = this.root + U, j = M.call(this, N), J = this.clone();
        return J.root = j.name, J;
      }, remove: function(U) {
        U = this.root + U;
        var N = this.files[U];
        if (N || (U.slice(-1) !== "/" && (U += "/"), N = this.files[U]), N && !N.dir)
          delete this.files[U];
        else
          for (var j = this.filter(function($, ct) {
            return ct.name.slice(0, U.length) === U;
          }), J = 0; J < j.length; J++)
            delete this.files[j[J].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(U) {
        var N, j = {};
        try {
          if ((j = _.extend(U || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: m.utf8encode })).type = j.type.toLowerCase(), j.compression = j.compression.toUpperCase(), j.type === "binarystring" && (j.type = "string"), !j.type)
            throw new Error("No output type specified.");
          _.checkSupport(j.type), j.platform !== "darwin" && j.platform !== "freebsd" && j.platform !== "linux" && j.platform !== "sunos" || (j.platform = "UNIX"), j.platform === "win32" && (j.platform = "DOS");
          var J = j.comment || this.comment || "";
          N = I.generateWorker(this, j, J);
        } catch ($) {
          (N = new T("error")).error($);
        }
        return new S(N, j.type || "string", j.mimeType);
      }, generateAsync: function(U, N) {
        return this.generateInternalStream(U).accumulate(N);
      }, generateNodeStream: function(U, N) {
        return (U = U || {}).type || (U.type = "nodebuffer"), this.generateInternalStream(U).toNodejsStream(N);
      } };
      p.exports = b;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(o, p, d) {
      p.exports = o("stream");
    }, { stream: void 0 }], 17: [function(o, p, d) {
      var u = o("./DataReader");
      function m(_) {
        u.call(this, _);
        for (var T = 0; T < this.data.length; T++)
          _[T] = 255 & _[T];
      }
      o("../utils").inherits(m, u), m.prototype.byteAt = function(_) {
        return this.data[this.zero + _];
      }, m.prototype.lastIndexOfSignature = function(_) {
        for (var T = _.charCodeAt(0), S = _.charCodeAt(1), C = _.charCodeAt(2), z = _.charCodeAt(3), B = this.length - 4; 0 <= B; --B)
          if (this.data[B] === T && this.data[B + 1] === S && this.data[B + 2] === C && this.data[B + 3] === z)
            return B - this.zero;
        return -1;
      }, m.prototype.readAndCheckSignature = function(_) {
        var T = _.charCodeAt(0), S = _.charCodeAt(1), C = _.charCodeAt(2), z = _.charCodeAt(3), B = this.readData(4);
        return T === B[0] && S === B[1] && C === B[2] && z === B[3];
      }, m.prototype.readData = function(_) {
        if (this.checkOffset(_), _ === 0)
          return [];
        var T = this.data.slice(this.zero + this.index, this.zero + this.index + _);
        return this.index += _, T;
      }, p.exports = m;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(o, p, d) {
      var u = o("../utils");
      function m(_) {
        this.data = _, this.length = _.length, this.index = 0, this.zero = 0;
      }
      m.prototype = { checkOffset: function(_) {
        this.checkIndex(this.index + _);
      }, checkIndex: function(_) {
        if (this.length < this.zero + _ || _ < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + _ + "). Corrupted zip ?");
      }, setIndex: function(_) {
        this.checkIndex(_), this.index = _;
      }, skip: function(_) {
        this.setIndex(this.index + _);
      }, byteAt: function() {
      }, readInt: function(_) {
        var T, S = 0;
        for (this.checkOffset(_), T = this.index + _ - 1; T >= this.index; T--)
          S = (S << 8) + this.byteAt(T);
        return this.index += _, S;
      }, readString: function(_) {
        return u.transformTo("string", this.readData(_));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var _ = this.readInt(4);
        return new Date(Date.UTC(1980 + (_ >> 25 & 127), (_ >> 21 & 15) - 1, _ >> 16 & 31, _ >> 11 & 31, _ >> 5 & 63, (31 & _) << 1));
      } }, p.exports = m;
    }, { "../utils": 32 }], 19: [function(o, p, d) {
      var u = o("./Uint8ArrayReader");
      function m(_) {
        u.call(this, _);
      }
      o("../utils").inherits(m, u), m.prototype.readData = function(_) {
        this.checkOffset(_);
        var T = this.data.slice(this.zero + this.index, this.zero + this.index + _);
        return this.index += _, T;
      }, p.exports = m;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(o, p, d) {
      var u = o("./DataReader");
      function m(_) {
        u.call(this, _);
      }
      o("../utils").inherits(m, u), m.prototype.byteAt = function(_) {
        return this.data.charCodeAt(this.zero + _);
      }, m.prototype.lastIndexOfSignature = function(_) {
        return this.data.lastIndexOf(_) - this.zero;
      }, m.prototype.readAndCheckSignature = function(_) {
        return _ === this.readData(4);
      }, m.prototype.readData = function(_) {
        this.checkOffset(_);
        var T = this.data.slice(this.zero + this.index, this.zero + this.index + _);
        return this.index += _, T;
      }, p.exports = m;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(o, p, d) {
      var u = o("./ArrayReader");
      function m(_) {
        u.call(this, _);
      }
      o("../utils").inherits(m, u), m.prototype.readData = function(_) {
        if (this.checkOffset(_), _ === 0)
          return new Uint8Array(0);
        var T = this.data.subarray(this.zero + this.index, this.zero + this.index + _);
        return this.index += _, T;
      }, p.exports = m;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(o, p, d) {
      var u = o("../utils"), m = o("../support"), _ = o("./ArrayReader"), T = o("./StringReader"), S = o("./NodeBufferReader"), C = o("./Uint8ArrayReader");
      p.exports = function(z) {
        var B = u.getTypeOf(z);
        return u.checkSupport(B), B !== "string" || m.uint8array ? B === "nodebuffer" ? new S(z) : m.uint8array ? new C(u.transformTo("uint8array", z)) : new _(u.transformTo("array", z)) : new T(z);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(o, p, d) {
      d.LOCAL_FILE_HEADER = "PK", d.CENTRAL_FILE_HEADER = "PK", d.CENTRAL_DIRECTORY_END = "PK", d.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", d.ZIP64_CENTRAL_DIRECTORY_END = "PK", d.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(o, p, d) {
      var u = o("./GenericWorker"), m = o("../utils");
      function _(T) {
        u.call(this, "ConvertWorker to " + T), this.destType = T;
      }
      m.inherits(_, u), _.prototype.processChunk = function(T) {
        this.push({ data: m.transformTo(this.destType, T.data), meta: T.meta });
      }, p.exports = _;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(o, p, d) {
      var u = o("./GenericWorker"), m = o("../crc32");
      function _() {
        u.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      o("../utils").inherits(_, u), _.prototype.processChunk = function(T) {
        this.streamInfo.crc32 = m(T.data, this.streamInfo.crc32 || 0), this.push(T);
      }, p.exports = _;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(o, p, d) {
      var u = o("../utils"), m = o("./GenericWorker");
      function _(T) {
        m.call(this, "DataLengthProbe for " + T), this.propName = T, this.withStreamInfo(T, 0);
      }
      u.inherits(_, m), _.prototype.processChunk = function(T) {
        if (T) {
          var S = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = S + T.data.length;
        }
        m.prototype.processChunk.call(this, T);
      }, p.exports = _;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(o, p, d) {
      var u = o("../utils"), m = o("./GenericWorker");
      function _(T) {
        m.call(this, "DataWorker");
        var S = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, T.then(function(C) {
          S.dataIsReady = !0, S.data = C, S.max = C && C.length || 0, S.type = u.getTypeOf(C), S.isPaused || S._tickAndRepeat();
        }, function(C) {
          S.error(C);
        });
      }
      u.inherits(_, m), _.prototype.cleanUp = function() {
        m.prototype.cleanUp.call(this), this.data = null;
      }, _.prototype.resume = function() {
        return !!m.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, u.delay(this._tickAndRepeat, [], this)), !0);
      }, _.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (u.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, _.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var T = null, S = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            T = this.data.substring(this.index, S);
            break;
          case "uint8array":
            T = this.data.subarray(this.index, S);
            break;
          case "array":
          case "nodebuffer":
            T = this.data.slice(this.index, S);
        }
        return this.index = S, this.push({ data: T, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, p.exports = _;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(o, p, d) {
      function u(m) {
        this.name = m || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      u.prototype = { push: function(m) {
        this.emit("data", m);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (m) {
          this.emit("error", m);
        }
        return !0;
      }, error: function(m) {
        return !this.isFinished && (this.isPaused ? this.generatedError = m : (this.isFinished = !0, this.emit("error", m), this.previous && this.previous.error(m), this.cleanUp()), !0);
      }, on: function(m, _) {
        return this._listeners[m].push(_), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(m, _) {
        if (this._listeners[m])
          for (var T = 0; T < this._listeners[m].length; T++)
            this._listeners[m][T].call(this, _);
      }, pipe: function(m) {
        return m.registerPrevious(this);
      }, registerPrevious: function(m) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = m.streamInfo, this.mergeStreamInfo(), this.previous = m;
        var _ = this;
        return m.on("data", function(T) {
          _.processChunk(T);
        }), m.on("end", function() {
          _.end();
        }), m.on("error", function(T) {
          _.error(T);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var m = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), m = !0), this.previous && this.previous.resume(), !m;
      }, flush: function() {
      }, processChunk: function(m) {
        this.push(m);
      }, withStreamInfo: function(m, _) {
        return this.extraStreamInfo[m] = _, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var m in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, m) && (this.streamInfo[m] = this.extraStreamInfo[m]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var m = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + m : m;
      } }, p.exports = u;
    }, {}], 29: [function(o, p, d) {
      var u = o("../utils"), m = o("./ConvertWorker"), _ = o("./GenericWorker"), T = o("../base64"), S = o("../support"), C = o("../external"), z = null;
      if (S.nodestream)
        try {
          z = o("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function B(F, E) {
        return new C.Promise(function(L, x) {
          var M = [], R = F._internalType, b = F._outputType, U = F._mimeType;
          F.on("data", function(N, j) {
            M.push(N), E && E(j);
          }).on("error", function(N) {
            M = [], x(N);
          }).on("end", function() {
            try {
              var N = function(j, J, $) {
                switch (j) {
                  case "blob":
                    return u.newBlob(u.transformTo("arraybuffer", J), $);
                  case "base64":
                    return T.encode(J);
                  default:
                    return u.transformTo(j, J);
                }
              }(b, function(j, J) {
                var $, ct = 0, It = null, et = 0;
                for ($ = 0; $ < J.length; $++)
                  et += J[$].length;
                switch (j) {
                  case "string":
                    return J.join("");
                  case "array":
                    return Array.prototype.concat.apply([], J);
                  case "uint8array":
                    for (It = new Uint8Array(et), $ = 0; $ < J.length; $++)
                      It.set(J[$], ct), ct += J[$].length;
                    return It;
                  case "nodebuffer":
                    return Buffer.concat(J);
                  default:
                    throw new Error("concat : unsupported type '" + j + "'");
                }
              }(R, M), U);
              L(N);
            } catch (j) {
              x(j);
            }
            M = [];
          }).resume();
        });
      }
      function I(F, E, L) {
        var x = E;
        switch (E) {
          case "blob":
          case "arraybuffer":
            x = "uint8array";
            break;
          case "base64":
            x = "string";
        }
        try {
          this._internalType = x, this._outputType = E, this._mimeType = L, u.checkSupport(x), this._worker = F.pipe(new m(x)), F.lock();
        } catch (M) {
          this._worker = new _("error"), this._worker.error(M);
        }
      }
      I.prototype = { accumulate: function(F) {
        return B(this, F);
      }, on: function(F, E) {
        var L = this;
        return F === "data" ? this._worker.on(F, function(x) {
          E.call(L, x.data, x.meta);
        }) : this._worker.on(F, function() {
          u.delay(E, arguments, L);
        }), this;
      }, resume: function() {
        return u.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(F) {
        if (u.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new z(this, { objectMode: this._outputType !== "nodebuffer" }, F);
      } }, p.exports = I;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(o, p, d) {
      if (d.base64 = !0, d.array = !0, d.string = !0, d.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", d.nodebuffer = typeof Buffer < "u", d.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        d.blob = !1;
      else {
        var u = new ArrayBuffer(0);
        try {
          d.blob = new Blob([u], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            m.append(u), d.blob = m.getBlob("application/zip").size === 0;
          } catch {
            d.blob = !1;
          }
        }
      }
      try {
        d.nodestream = !!o("readable-stream").Readable;
      } catch {
        d.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(o, p, d) {
      for (var u = o("./utils"), m = o("./support"), _ = o("./nodejsUtils"), T = o("./stream/GenericWorker"), S = new Array(256), C = 0; C < 256; C++)
        S[C] = 252 <= C ? 6 : 248 <= C ? 5 : 240 <= C ? 4 : 224 <= C ? 3 : 192 <= C ? 2 : 1;
      S[254] = S[254] = 1;
      function z() {
        T.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function B() {
        T.call(this, "utf-8 encode");
      }
      d.utf8encode = function(I) {
        return m.nodebuffer ? _.newBufferFrom(I, "utf-8") : function(F) {
          var E, L, x, M, R, b = F.length, U = 0;
          for (M = 0; M < b; M++)
            (64512 & (L = F.charCodeAt(M))) == 55296 && M + 1 < b && (64512 & (x = F.charCodeAt(M + 1))) == 56320 && (L = 65536 + (L - 55296 << 10) + (x - 56320), M++), U += L < 128 ? 1 : L < 2048 ? 2 : L < 65536 ? 3 : 4;
          for (E = m.uint8array ? new Uint8Array(U) : new Array(U), M = R = 0; R < U; M++)
            (64512 & (L = F.charCodeAt(M))) == 55296 && M + 1 < b && (64512 & (x = F.charCodeAt(M + 1))) == 56320 && (L = 65536 + (L - 55296 << 10) + (x - 56320), M++), L < 128 ? E[R++] = L : (L < 2048 ? E[R++] = 192 | L >>> 6 : (L < 65536 ? E[R++] = 224 | L >>> 12 : (E[R++] = 240 | L >>> 18, E[R++] = 128 | L >>> 12 & 63), E[R++] = 128 | L >>> 6 & 63), E[R++] = 128 | 63 & L);
          return E;
        }(I);
      }, d.utf8decode = function(I) {
        return m.nodebuffer ? u.transformTo("nodebuffer", I).toString("utf-8") : function(F) {
          var E, L, x, M, R = F.length, b = new Array(2 * R);
          for (E = L = 0; E < R; )
            if ((x = F[E++]) < 128)
              b[L++] = x;
            else if (4 < (M = S[x]))
              b[L++] = 65533, E += M - 1;
            else {
              for (x &= M === 2 ? 31 : M === 3 ? 15 : 7; 1 < M && E < R; )
                x = x << 6 | 63 & F[E++], M--;
              1 < M ? b[L++] = 65533 : x < 65536 ? b[L++] = x : (x -= 65536, b[L++] = 55296 | x >> 10 & 1023, b[L++] = 56320 | 1023 & x);
            }
          return b.length !== L && (b.subarray ? b = b.subarray(0, L) : b.length = L), u.applyFromCharCode(b);
        }(I = u.transformTo(m.uint8array ? "uint8array" : "array", I));
      }, u.inherits(z, T), z.prototype.processChunk = function(I) {
        var F = u.transformTo(m.uint8array ? "uint8array" : "array", I.data);
        if (this.leftOver && this.leftOver.length) {
          if (m.uint8array) {
            var E = F;
            (F = new Uint8Array(E.length + this.leftOver.length)).set(this.leftOver, 0), F.set(E, this.leftOver.length);
          } else
            F = this.leftOver.concat(F);
          this.leftOver = null;
        }
        var L = function(M, R) {
          var b;
          for ((R = R || M.length) > M.length && (R = M.length), b = R - 1; 0 <= b && (192 & M[b]) == 128; )
            b--;
          return b < 0 || b === 0 ? R : b + S[M[b]] > R ? b : R;
        }(F), x = F;
        L !== F.length && (m.uint8array ? (x = F.subarray(0, L), this.leftOver = F.subarray(L, F.length)) : (x = F.slice(0, L), this.leftOver = F.slice(L, F.length))), this.push({ data: d.utf8decode(x), meta: I.meta });
      }, z.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: d.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, d.Utf8DecodeWorker = z, u.inherits(B, T), B.prototype.processChunk = function(I) {
        this.push({ data: d.utf8encode(I.data), meta: I.meta });
      }, d.Utf8EncodeWorker = B;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(o, p, d) {
      var u = o("./support"), m = o("./base64"), _ = o("./nodejsUtils"), T = o("./external");
      function S(E) {
        return E;
      }
      function C(E, L) {
        for (var x = 0; x < E.length; ++x)
          L[x] = 255 & E.charCodeAt(x);
        return L;
      }
      o("setimmediate"), d.newBlob = function(E, L) {
        d.checkSupport("blob");
        try {
          return new Blob([E], { type: L });
        } catch {
          try {
            var x = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return x.append(E), x.getBlob(L);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var z = { stringifyByChunk: function(E, L, x) {
        var M = [], R = 0, b = E.length;
        if (b <= x)
          return String.fromCharCode.apply(null, E);
        for (; R < b; )
          L === "array" || L === "nodebuffer" ? M.push(String.fromCharCode.apply(null, E.slice(R, Math.min(R + x, b)))) : M.push(String.fromCharCode.apply(null, E.subarray(R, Math.min(R + x, b)))), R += x;
        return M.join("");
      }, stringifyByChar: function(E) {
        for (var L = "", x = 0; x < E.length; x++)
          L += String.fromCharCode(E[x]);
        return L;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return u.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return u.nodebuffer && String.fromCharCode.apply(null, _.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function B(E) {
        var L = 65536, x = d.getTypeOf(E), M = !0;
        if (x === "uint8array" ? M = z.applyCanBeUsed.uint8array : x === "nodebuffer" && (M = z.applyCanBeUsed.nodebuffer), M)
          for (; 1 < L; )
            try {
              return z.stringifyByChunk(E, x, L);
            } catch {
              L = Math.floor(L / 2);
            }
        return z.stringifyByChar(E);
      }
      function I(E, L) {
        for (var x = 0; x < E.length; x++)
          L[x] = E[x];
        return L;
      }
      d.applyFromCharCode = B;
      var F = {};
      F.string = { string: S, array: function(E) {
        return C(E, new Array(E.length));
      }, arraybuffer: function(E) {
        return F.string.uint8array(E).buffer;
      }, uint8array: function(E) {
        return C(E, new Uint8Array(E.length));
      }, nodebuffer: function(E) {
        return C(E, _.allocBuffer(E.length));
      } }, F.array = { string: B, array: S, arraybuffer: function(E) {
        return new Uint8Array(E).buffer;
      }, uint8array: function(E) {
        return new Uint8Array(E);
      }, nodebuffer: function(E) {
        return _.newBufferFrom(E);
      } }, F.arraybuffer = { string: function(E) {
        return B(new Uint8Array(E));
      }, array: function(E) {
        return I(new Uint8Array(E), new Array(E.byteLength));
      }, arraybuffer: S, uint8array: function(E) {
        return new Uint8Array(E);
      }, nodebuffer: function(E) {
        return _.newBufferFrom(new Uint8Array(E));
      } }, F.uint8array = { string: B, array: function(E) {
        return I(E, new Array(E.length));
      }, arraybuffer: function(E) {
        return E.buffer;
      }, uint8array: S, nodebuffer: function(E) {
        return _.newBufferFrom(E);
      } }, F.nodebuffer = { string: B, array: function(E) {
        return I(E, new Array(E.length));
      }, arraybuffer: function(E) {
        return F.nodebuffer.uint8array(E).buffer;
      }, uint8array: function(E) {
        return I(E, new Uint8Array(E.length));
      }, nodebuffer: S }, d.transformTo = function(E, L) {
        if (L = L || "", !E)
          return L;
        d.checkSupport(E);
        var x = d.getTypeOf(L);
        return F[x][E](L);
      }, d.resolve = function(E) {
        for (var L = E.split("/"), x = [], M = 0; M < L.length; M++) {
          var R = L[M];
          R === "." || R === "" && M !== 0 && M !== L.length - 1 || (R === ".." ? x.pop() : x.push(R));
        }
        return x.join("/");
      }, d.getTypeOf = function(E) {
        return typeof E == "string" ? "string" : Object.prototype.toString.call(E) === "[object Array]" ? "array" : u.nodebuffer && _.isBuffer(E) ? "nodebuffer" : u.uint8array && E instanceof Uint8Array ? "uint8array" : u.arraybuffer && E instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, d.checkSupport = function(E) {
        if (!u[E.toLowerCase()])
          throw new Error(E + " is not supported by this platform");
      }, d.MAX_VALUE_16BITS = 65535, d.MAX_VALUE_32BITS = -1, d.pretty = function(E) {
        var L, x, M = "";
        for (x = 0; x < (E || "").length; x++)
          M += "\\x" + ((L = E.charCodeAt(x)) < 16 ? "0" : "") + L.toString(16).toUpperCase();
        return M;
      }, d.delay = function(E, L, x) {
        setImmediate(function() {
          E.apply(x || null, L || []);
        });
      }, d.inherits = function(E, L) {
        function x() {
        }
        x.prototype = L.prototype, E.prototype = new x();
      }, d.extend = function() {
        var E, L, x = {};
        for (E = 0; E < arguments.length; E++)
          for (L in arguments[E])
            Object.prototype.hasOwnProperty.call(arguments[E], L) && x[L] === void 0 && (x[L] = arguments[E][L]);
        return x;
      }, d.prepareContent = function(E, L, x, M, R) {
        return T.Promise.resolve(L).then(function(b) {
          return u.blob && (b instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(b)) !== -1) && typeof FileReader < "u" ? new T.Promise(function(U, N) {
            var j = new FileReader();
            j.onload = function(J) {
              U(J.target.result);
            }, j.onerror = function(J) {
              N(J.target.error);
            }, j.readAsArrayBuffer(b);
          }) : b;
        }).then(function(b) {
          var U = d.getTypeOf(b);
          return U ? (U === "arraybuffer" ? b = d.transformTo("uint8array", b) : U === "string" && (R ? b = m.decode(b) : x && M !== !0 && (b = function(N) {
            return C(N, u.uint8array ? new Uint8Array(N.length) : new Array(N.length));
          }(b))), b) : T.Promise.reject(new Error("Can't read the data of '" + E + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(o, p, d) {
      var u = o("./reader/readerFor"), m = o("./utils"), _ = o("./signature"), T = o("./zipEntry"), S = o("./support");
      function C(z) {
        this.files = [], this.loadOptions = z;
      }
      C.prototype = { checkSignature: function(z) {
        if (!this.reader.readAndCheckSignature(z)) {
          this.reader.index -= 4;
          var B = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + m.pretty(B) + ", expected " + m.pretty(z) + ")");
        }
      }, isSignature: function(z, B) {
        var I = this.reader.index;
        this.reader.setIndex(z);
        var F = this.reader.readString(4) === B;
        return this.reader.setIndex(I), F;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var z = this.reader.readData(this.zipCommentLength), B = S.uint8array ? "uint8array" : "array", I = m.transformTo(B, z);
        this.zipComment = this.loadOptions.decodeFileName(I);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var z, B, I, F = this.zip64EndOfCentralSize - 44; 0 < F; )
          z = this.reader.readInt(2), B = this.reader.readInt(4), I = this.reader.readData(B), this.zip64ExtensibleData[z] = { id: z, length: B, value: I };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var z, B;
        for (z = 0; z < this.files.length; z++)
          B = this.files[z], this.reader.setIndex(B.localHeaderOffset), this.checkSignature(_.LOCAL_FILE_HEADER), B.readLocalPart(this.reader), B.handleUTF8(), B.processAttributes();
      }, readCentralDir: function() {
        var z;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(_.CENTRAL_FILE_HEADER); )
          (z = new T({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(z);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var z = this.reader.lastIndexOfSignature(_.CENTRAL_DIRECTORY_END);
        if (z < 0)
          throw this.isSignature(0, _.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(z);
        var B = z;
        if (this.checkSignature(_.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === m.MAX_VALUE_16BITS || this.diskWithCentralDirStart === m.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === m.MAX_VALUE_16BITS || this.centralDirRecords === m.MAX_VALUE_16BITS || this.centralDirSize === m.MAX_VALUE_32BITS || this.centralDirOffset === m.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (z = this.reader.lastIndexOfSignature(_.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(z), this.checkSignature(_.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, _.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(_.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(_.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var I = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (I += 20, I += 12 + this.zip64EndOfCentralSize);
        var F = B - I;
        if (0 < F)
          this.isSignature(B, _.CENTRAL_FILE_HEADER) || (this.reader.zero = F);
        else if (F < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(F) + " bytes.");
      }, prepareReader: function(z) {
        this.reader = u(z);
      }, load: function(z) {
        this.prepareReader(z), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, p.exports = C;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(o, p, d) {
      var u = o("./reader/readerFor"), m = o("./utils"), _ = o("./compressedObject"), T = o("./crc32"), S = o("./utf8"), C = o("./compressions"), z = o("./support");
      function B(I, F) {
        this.options = I, this.loadOptions = F;
      }
      B.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(I) {
        var F, E;
        if (I.skip(22), this.fileNameLength = I.readInt(2), E = I.readInt(2), this.fileName = I.readData(this.fileNameLength), I.skip(E), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((F = function(L) {
          for (var x in C)
            if (Object.prototype.hasOwnProperty.call(C, x) && C[x].magic === L)
              return C[x];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + m.pretty(this.compressionMethod) + " unknown (inner file : " + m.transformTo("string", this.fileName) + ")");
        this.decompressed = new _(this.compressedSize, this.uncompressedSize, this.crc32, F, I.readData(this.compressedSize));
      }, readCentralPart: function(I) {
        this.versionMadeBy = I.readInt(2), I.skip(2), this.bitFlag = I.readInt(2), this.compressionMethod = I.readString(2), this.date = I.readDate(), this.crc32 = I.readInt(4), this.compressedSize = I.readInt(4), this.uncompressedSize = I.readInt(4);
        var F = I.readInt(2);
        if (this.extraFieldsLength = I.readInt(2), this.fileCommentLength = I.readInt(2), this.diskNumberStart = I.readInt(2), this.internalFileAttributes = I.readInt(2), this.externalFileAttributes = I.readInt(4), this.localHeaderOffset = I.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        I.skip(F), this.readExtraFields(I), this.parseZIP64ExtraField(I), this.fileComment = I.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var I = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), I == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), I == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var I = u(this.extraFields[1].value);
          this.uncompressedSize === m.MAX_VALUE_32BITS && (this.uncompressedSize = I.readInt(8)), this.compressedSize === m.MAX_VALUE_32BITS && (this.compressedSize = I.readInt(8)), this.localHeaderOffset === m.MAX_VALUE_32BITS && (this.localHeaderOffset = I.readInt(8)), this.diskNumberStart === m.MAX_VALUE_32BITS && (this.diskNumberStart = I.readInt(4));
        }
      }, readExtraFields: function(I) {
        var F, E, L, x = I.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); I.index + 4 < x; )
          F = I.readInt(2), E = I.readInt(2), L = I.readData(E), this.extraFields[F] = { id: F, length: E, value: L };
        I.setIndex(x);
      }, handleUTF8: function() {
        var I = z.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = S.utf8decode(this.fileName), this.fileCommentStr = S.utf8decode(this.fileComment);
        else {
          var F = this.findExtraFieldUnicodePath();
          if (F !== null)
            this.fileNameStr = F;
          else {
            var E = m.transformTo(I, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(E);
          }
          var L = this.findExtraFieldUnicodeComment();
          if (L !== null)
            this.fileCommentStr = L;
          else {
            var x = m.transformTo(I, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(x);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var I = this.extraFields[28789];
        if (I) {
          var F = u(I.value);
          return F.readInt(1) !== 1 || T(this.fileName) !== F.readInt(4) ? null : S.utf8decode(F.readData(I.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var I = this.extraFields[25461];
        if (I) {
          var F = u(I.value);
          return F.readInt(1) !== 1 || T(this.fileComment) !== F.readInt(4) ? null : S.utf8decode(F.readData(I.length - 5));
        }
        return null;
      } }, p.exports = B;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(o, p, d) {
      function u(F, E, L) {
        this.name = F, this.dir = L.dir, this.date = L.date, this.comment = L.comment, this.unixPermissions = L.unixPermissions, this.dosPermissions = L.dosPermissions, this._data = E, this._dataBinary = L.binary, this.options = { compression: L.compression, compressionOptions: L.compressionOptions };
      }
      var m = o("./stream/StreamHelper"), _ = o("./stream/DataWorker"), T = o("./utf8"), S = o("./compressedObject"), C = o("./stream/GenericWorker");
      u.prototype = { internalStream: function(F) {
        var E = null, L = "string";
        try {
          if (!F)
            throw new Error("No output type specified.");
          var x = (L = F.toLowerCase()) === "string" || L === "text";
          L !== "binarystring" && L !== "text" || (L = "string"), E = this._decompressWorker();
          var M = !this._dataBinary;
          M && !x && (E = E.pipe(new T.Utf8EncodeWorker())), !M && x && (E = E.pipe(new T.Utf8DecodeWorker()));
        } catch (R) {
          (E = new C("error")).error(R);
        }
        return new m(E, L, "");
      }, async: function(F, E) {
        return this.internalStream(F).accumulate(E);
      }, nodeStream: function(F, E) {
        return this.internalStream(F || "nodebuffer").toNodejsStream(E);
      }, _compressWorker: function(F, E) {
        if (this._data instanceof S && this._data.compression.magic === F.magic)
          return this._data.getCompressedWorker();
        var L = this._decompressWorker();
        return this._dataBinary || (L = L.pipe(new T.Utf8EncodeWorker())), S.createWorkerFrom(L, F, E);
      }, _decompressWorker: function() {
        return this._data instanceof S ? this._data.getContentWorker() : this._data instanceof C ? this._data : new _(this._data);
      } };
      for (var z = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], B = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, I = 0; I < z.length; I++)
        u.prototype[z[I]] = B;
      p.exports = u;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(o, p, d) {
      (function(u) {
        var m, _, T = u.MutationObserver || u.WebKitMutationObserver;
        if (T) {
          var S = 0, C = new T(F), z = u.document.createTextNode("");
          C.observe(z, { characterData: !0 }), m = function() {
            z.data = S = ++S % 2;
          };
        } else if (u.setImmediate || u.MessageChannel === void 0)
          m = "document" in u && "onreadystatechange" in u.document.createElement("script") ? function() {
            var E = u.document.createElement("script");
            E.onreadystatechange = function() {
              F(), E.onreadystatechange = null, E.parentNode.removeChild(E), E = null;
            }, u.document.documentElement.appendChild(E);
          } : function() {
            setTimeout(F, 0);
          };
        else {
          var B = new u.MessageChannel();
          B.port1.onmessage = F, m = function() {
            B.port2.postMessage(0);
          };
        }
        var I = [];
        function F() {
          var E, L;
          _ = !0;
          for (var x = I.length; x; ) {
            for (L = I, I = [], E = -1; ++E < x; )
              L[E]();
            x = I.length;
          }
          _ = !1;
        }
        p.exports = function(E) {
          I.push(E) !== 1 || _ || m();
        };
      }).call(this, typeof zr < "u" ? zr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(o, p, d) {
      var u = o("immediate");
      function m() {
      }
      var _ = {}, T = ["REJECTED"], S = ["FULFILLED"], C = ["PENDING"];
      function z(x) {
        if (typeof x != "function")
          throw new TypeError("resolver must be a function");
        this.state = C, this.queue = [], this.outcome = void 0, x !== m && E(this, x);
      }
      function B(x, M, R) {
        this.promise = x, typeof M == "function" && (this.onFulfilled = M, this.callFulfilled = this.otherCallFulfilled), typeof R == "function" && (this.onRejected = R, this.callRejected = this.otherCallRejected);
      }
      function I(x, M, R) {
        u(function() {
          var b;
          try {
            b = M(R);
          } catch (U) {
            return _.reject(x, U);
          }
          b === x ? _.reject(x, new TypeError("Cannot resolve promise with itself")) : _.resolve(x, b);
        });
      }
      function F(x) {
        var M = x && x.then;
        if (x && (typeof x == "object" || typeof x == "function") && typeof M == "function")
          return function() {
            M.apply(x, arguments);
          };
      }
      function E(x, M) {
        var R = !1;
        function b(j) {
          R || (R = !0, _.reject(x, j));
        }
        function U(j) {
          R || (R = !0, _.resolve(x, j));
        }
        var N = L(function() {
          M(U, b);
        });
        N.status === "error" && b(N.value);
      }
      function L(x, M) {
        var R = {};
        try {
          R.value = x(M), R.status = "success";
        } catch (b) {
          R.status = "error", R.value = b;
        }
        return R;
      }
      (p.exports = z).prototype.finally = function(x) {
        if (typeof x != "function")
          return this;
        var M = this.constructor;
        return this.then(function(R) {
          return M.resolve(x()).then(function() {
            return R;
          });
        }, function(R) {
          return M.resolve(x()).then(function() {
            throw R;
          });
        });
      }, z.prototype.catch = function(x) {
        return this.then(null, x);
      }, z.prototype.then = function(x, M) {
        if (typeof x != "function" && this.state === S || typeof M != "function" && this.state === T)
          return this;
        var R = new this.constructor(m);
        return this.state !== C ? I(R, this.state === S ? x : M, this.outcome) : this.queue.push(new B(R, x, M)), R;
      }, B.prototype.callFulfilled = function(x) {
        _.resolve(this.promise, x);
      }, B.prototype.otherCallFulfilled = function(x) {
        I(this.promise, this.onFulfilled, x);
      }, B.prototype.callRejected = function(x) {
        _.reject(this.promise, x);
      }, B.prototype.otherCallRejected = function(x) {
        I(this.promise, this.onRejected, x);
      }, _.resolve = function(x, M) {
        var R = L(F, M);
        if (R.status === "error")
          return _.reject(x, R.value);
        var b = R.value;
        if (b)
          E(x, b);
        else {
          x.state = S, x.outcome = M;
          for (var U = -1, N = x.queue.length; ++U < N; )
            x.queue[U].callFulfilled(M);
        }
        return x;
      }, _.reject = function(x, M) {
        x.state = T, x.outcome = M;
        for (var R = -1, b = x.queue.length; ++R < b; )
          x.queue[R].callRejected(M);
        return x;
      }, z.resolve = function(x) {
        return x instanceof this ? x : _.resolve(new this(m), x);
      }, z.reject = function(x) {
        var M = new this(m);
        return _.reject(M, x);
      }, z.all = function(x) {
        var M = this;
        if (Object.prototype.toString.call(x) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var R = x.length, b = !1;
        if (!R)
          return this.resolve([]);
        for (var U = new Array(R), N = 0, j = -1, J = new this(m); ++j < R; )
          $(x[j], j);
        return J;
        function $(ct, It) {
          M.resolve(ct).then(function(et) {
            U[It] = et, ++N !== R || b || (b = !0, _.resolve(J, U));
          }, function(et) {
            b || (b = !0, _.reject(J, et));
          });
        }
      }, z.race = function(x) {
        var M = this;
        if (Object.prototype.toString.call(x) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var R = x.length, b = !1;
        if (!R)
          return this.resolve([]);
        for (var U = -1, N = new this(m); ++U < R; )
          j = x[U], M.resolve(j).then(function(J) {
            b || (b = !0, _.resolve(N, J));
          }, function(J) {
            b || (b = !0, _.reject(N, J));
          });
        var j;
        return N;
      };
    }, { immediate: 36 }], 38: [function(o, p, d) {
      var u = {};
      (0, o("./lib/utils/common").assign)(u, o("./lib/deflate"), o("./lib/inflate"), o("./lib/zlib/constants")), p.exports = u;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(o, p, d) {
      var u = o("./zlib/deflate"), m = o("./utils/common"), _ = o("./utils/strings"), T = o("./zlib/messages"), S = o("./zlib/zstream"), C = Object.prototype.toString, z = 0, B = -1, I = 0, F = 8;
      function E(x) {
        if (!(this instanceof E))
          return new E(x);
        this.options = m.assign({ level: B, method: F, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: I, to: "" }, x || {});
        var M = this.options;
        M.raw && 0 < M.windowBits ? M.windowBits = -M.windowBits : M.gzip && 0 < M.windowBits && M.windowBits < 16 && (M.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new S(), this.strm.avail_out = 0;
        var R = u.deflateInit2(this.strm, M.level, M.method, M.windowBits, M.memLevel, M.strategy);
        if (R !== z)
          throw new Error(T[R]);
        if (M.header && u.deflateSetHeader(this.strm, M.header), M.dictionary) {
          var b;
          if (b = typeof M.dictionary == "string" ? _.string2buf(M.dictionary) : C.call(M.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(M.dictionary) : M.dictionary, (R = u.deflateSetDictionary(this.strm, b)) !== z)
            throw new Error(T[R]);
          this._dict_set = !0;
        }
      }
      function L(x, M) {
        var R = new E(M);
        if (R.push(x, !0), R.err)
          throw R.msg || T[R.err];
        return R.result;
      }
      E.prototype.push = function(x, M) {
        var R, b, U = this.strm, N = this.options.chunkSize;
        if (this.ended)
          return !1;
        b = M === ~~M ? M : M === !0 ? 4 : 0, typeof x == "string" ? U.input = _.string2buf(x) : C.call(x) === "[object ArrayBuffer]" ? U.input = new Uint8Array(x) : U.input = x, U.next_in = 0, U.avail_in = U.input.length;
        do {
          if (U.avail_out === 0 && (U.output = new m.Buf8(N), U.next_out = 0, U.avail_out = N), (R = u.deflate(U, b)) !== 1 && R !== z)
            return this.onEnd(R), !(this.ended = !0);
          U.avail_out !== 0 && (U.avail_in !== 0 || b !== 4 && b !== 2) || (this.options.to === "string" ? this.onData(_.buf2binstring(m.shrinkBuf(U.output, U.next_out))) : this.onData(m.shrinkBuf(U.output, U.next_out)));
        } while ((0 < U.avail_in || U.avail_out === 0) && R !== 1);
        return b === 4 ? (R = u.deflateEnd(this.strm), this.onEnd(R), this.ended = !0, R === z) : b !== 2 || (this.onEnd(z), !(U.avail_out = 0));
      }, E.prototype.onData = function(x) {
        this.chunks.push(x);
      }, E.prototype.onEnd = function(x) {
        x === z && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = m.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
      }, d.Deflate = E, d.deflate = L, d.deflateRaw = function(x, M) {
        return (M = M || {}).raw = !0, L(x, M);
      }, d.gzip = function(x, M) {
        return (M = M || {}).gzip = !0, L(x, M);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(o, p, d) {
      var u = o("./zlib/inflate"), m = o("./utils/common"), _ = o("./utils/strings"), T = o("./zlib/constants"), S = o("./zlib/messages"), C = o("./zlib/zstream"), z = o("./zlib/gzheader"), B = Object.prototype.toString;
      function I(E) {
        if (!(this instanceof I))
          return new I(E);
        this.options = m.assign({ chunkSize: 16384, windowBits: 0, to: "" }, E || {});
        var L = this.options;
        L.raw && 0 <= L.windowBits && L.windowBits < 16 && (L.windowBits = -L.windowBits, L.windowBits === 0 && (L.windowBits = -15)), !(0 <= L.windowBits && L.windowBits < 16) || E && E.windowBits || (L.windowBits += 32), 15 < L.windowBits && L.windowBits < 48 && !(15 & L.windowBits) && (L.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new C(), this.strm.avail_out = 0;
        var x = u.inflateInit2(this.strm, L.windowBits);
        if (x !== T.Z_OK)
          throw new Error(S[x]);
        this.header = new z(), u.inflateGetHeader(this.strm, this.header);
      }
      function F(E, L) {
        var x = new I(L);
        if (x.push(E, !0), x.err)
          throw x.msg || S[x.err];
        return x.result;
      }
      I.prototype.push = function(E, L) {
        var x, M, R, b, U, N, j = this.strm, J = this.options.chunkSize, $ = this.options.dictionary, ct = !1;
        if (this.ended)
          return !1;
        M = L === ~~L ? L : L === !0 ? T.Z_FINISH : T.Z_NO_FLUSH, typeof E == "string" ? j.input = _.binstring2buf(E) : B.call(E) === "[object ArrayBuffer]" ? j.input = new Uint8Array(E) : j.input = E, j.next_in = 0, j.avail_in = j.input.length;
        do {
          if (j.avail_out === 0 && (j.output = new m.Buf8(J), j.next_out = 0, j.avail_out = J), (x = u.inflate(j, T.Z_NO_FLUSH)) === T.Z_NEED_DICT && $ && (N = typeof $ == "string" ? _.string2buf($) : B.call($) === "[object ArrayBuffer]" ? new Uint8Array($) : $, x = u.inflateSetDictionary(this.strm, N)), x === T.Z_BUF_ERROR && ct === !0 && (x = T.Z_OK, ct = !1), x !== T.Z_STREAM_END && x !== T.Z_OK)
            return this.onEnd(x), !(this.ended = !0);
          j.next_out && (j.avail_out !== 0 && x !== T.Z_STREAM_END && (j.avail_in !== 0 || M !== T.Z_FINISH && M !== T.Z_SYNC_FLUSH) || (this.options.to === "string" ? (R = _.utf8border(j.output, j.next_out), b = j.next_out - R, U = _.buf2string(j.output, R), j.next_out = b, j.avail_out = J - b, b && m.arraySet(j.output, j.output, R, b, 0), this.onData(U)) : this.onData(m.shrinkBuf(j.output, j.next_out)))), j.avail_in === 0 && j.avail_out === 0 && (ct = !0);
        } while ((0 < j.avail_in || j.avail_out === 0) && x !== T.Z_STREAM_END);
        return x === T.Z_STREAM_END && (M = T.Z_FINISH), M === T.Z_FINISH ? (x = u.inflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === T.Z_OK) : M !== T.Z_SYNC_FLUSH || (this.onEnd(T.Z_OK), !(j.avail_out = 0));
      }, I.prototype.onData = function(E) {
        this.chunks.push(E);
      }, I.prototype.onEnd = function(E) {
        E === T.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = m.flattenChunks(this.chunks)), this.chunks = [], this.err = E, this.msg = this.strm.msg;
      }, d.Inflate = I, d.inflate = F, d.inflateRaw = function(E, L) {
        return (L = L || {}).raw = !0, F(E, L);
      }, d.ungzip = F;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(o, p, d) {
      var u = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      d.assign = function(T) {
        for (var S = Array.prototype.slice.call(arguments, 1); S.length; ) {
          var C = S.shift();
          if (C) {
            if (typeof C != "object")
              throw new TypeError(C + "must be non-object");
            for (var z in C)
              C.hasOwnProperty(z) && (T[z] = C[z]);
          }
        }
        return T;
      }, d.shrinkBuf = function(T, S) {
        return T.length === S ? T : T.subarray ? T.subarray(0, S) : (T.length = S, T);
      };
      var m = { arraySet: function(T, S, C, z, B) {
        if (S.subarray && T.subarray)
          T.set(S.subarray(C, C + z), B);
        else
          for (var I = 0; I < z; I++)
            T[B + I] = S[C + I];
      }, flattenChunks: function(T) {
        var S, C, z, B, I, F;
        for (S = z = 0, C = T.length; S < C; S++)
          z += T[S].length;
        for (F = new Uint8Array(z), S = B = 0, C = T.length; S < C; S++)
          I = T[S], F.set(I, B), B += I.length;
        return F;
      } }, _ = { arraySet: function(T, S, C, z, B) {
        for (var I = 0; I < z; I++)
          T[B + I] = S[C + I];
      }, flattenChunks: function(T) {
        return [].concat.apply([], T);
      } };
      d.setTyped = function(T) {
        T ? (d.Buf8 = Uint8Array, d.Buf16 = Uint16Array, d.Buf32 = Int32Array, d.assign(d, m)) : (d.Buf8 = Array, d.Buf16 = Array, d.Buf32 = Array, d.assign(d, _));
      }, d.setTyped(u);
    }, {}], 42: [function(o, p, d) {
      var u = o("./common"), m = !0, _ = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        m = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        _ = !1;
      }
      for (var T = new u.Buf8(256), S = 0; S < 256; S++)
        T[S] = 252 <= S ? 6 : 248 <= S ? 5 : 240 <= S ? 4 : 224 <= S ? 3 : 192 <= S ? 2 : 1;
      function C(z, B) {
        if (B < 65537 && (z.subarray && _ || !z.subarray && m))
          return String.fromCharCode.apply(null, u.shrinkBuf(z, B));
        for (var I = "", F = 0; F < B; F++)
          I += String.fromCharCode(z[F]);
        return I;
      }
      T[254] = T[254] = 1, d.string2buf = function(z) {
        var B, I, F, E, L, x = z.length, M = 0;
        for (E = 0; E < x; E++)
          (64512 & (I = z.charCodeAt(E))) == 55296 && E + 1 < x && (64512 & (F = z.charCodeAt(E + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (F - 56320), E++), M += I < 128 ? 1 : I < 2048 ? 2 : I < 65536 ? 3 : 4;
        for (B = new u.Buf8(M), E = L = 0; L < M; E++)
          (64512 & (I = z.charCodeAt(E))) == 55296 && E + 1 < x && (64512 & (F = z.charCodeAt(E + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (F - 56320), E++), I < 128 ? B[L++] = I : (I < 2048 ? B[L++] = 192 | I >>> 6 : (I < 65536 ? B[L++] = 224 | I >>> 12 : (B[L++] = 240 | I >>> 18, B[L++] = 128 | I >>> 12 & 63), B[L++] = 128 | I >>> 6 & 63), B[L++] = 128 | 63 & I);
        return B;
      }, d.buf2binstring = function(z) {
        return C(z, z.length);
      }, d.binstring2buf = function(z) {
        for (var B = new u.Buf8(z.length), I = 0, F = B.length; I < F; I++)
          B[I] = z.charCodeAt(I);
        return B;
      }, d.buf2string = function(z, B) {
        var I, F, E, L, x = B || z.length, M = new Array(2 * x);
        for (I = F = 0; I < x; )
          if ((E = z[I++]) < 128)
            M[F++] = E;
          else if (4 < (L = T[E]))
            M[F++] = 65533, I += L - 1;
          else {
            for (E &= L === 2 ? 31 : L === 3 ? 15 : 7; 1 < L && I < x; )
              E = E << 6 | 63 & z[I++], L--;
            1 < L ? M[F++] = 65533 : E < 65536 ? M[F++] = E : (E -= 65536, M[F++] = 55296 | E >> 10 & 1023, M[F++] = 56320 | 1023 & E);
          }
        return C(M, F);
      }, d.utf8border = function(z, B) {
        var I;
        for ((B = B || z.length) > z.length && (B = z.length), I = B - 1; 0 <= I && (192 & z[I]) == 128; )
          I--;
        return I < 0 || I === 0 ? B : I + T[z[I]] > B ? I : B;
      };
    }, { "./common": 41 }], 43: [function(o, p, d) {
      p.exports = function(u, m, _, T) {
        for (var S = 65535 & u | 0, C = u >>> 16 & 65535 | 0, z = 0; _ !== 0; ) {
          for (_ -= z = 2e3 < _ ? 2e3 : _; C = C + (S = S + m[T++] | 0) | 0, --z; )
            ;
          S %= 65521, C %= 65521;
        }
        return S | C << 16 | 0;
      };
    }, {}], 44: [function(o, p, d) {
      p.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(o, p, d) {
      var u = function() {
        for (var m, _ = [], T = 0; T < 256; T++) {
          m = T;
          for (var S = 0; S < 8; S++)
            m = 1 & m ? 3988292384 ^ m >>> 1 : m >>> 1;
          _[T] = m;
        }
        return _;
      }();
      p.exports = function(m, _, T, S) {
        var C = u, z = S + T;
        m ^= -1;
        for (var B = S; B < z; B++)
          m = m >>> 8 ^ C[255 & (m ^ _[B])];
        return -1 ^ m;
      };
    }, {}], 46: [function(o, p, d) {
      var u, m = o("../utils/common"), _ = o("./trees"), T = o("./adler32"), S = o("./crc32"), C = o("./messages"), z = 0, B = 4, I = 0, F = -2, E = -1, L = 4, x = 2, M = 8, R = 9, b = 286, U = 30, N = 19, j = 2 * b + 1, J = 15, $ = 3, ct = 258, It = ct + $ + 1, et = 42, yt = 113, G = 1, Pt = 2, Et = 3, Ct = 4;
      function ce(W, Jt) {
        return W.msg = C[Jt], Jt;
      }
      function re(W) {
        return (W << 1) - (4 < W ? 9 : 0);
      }
      function Ft(W) {
        for (var Jt = W.length; 0 <= --Jt; )
          W[Jt] = 0;
      }
      function Ot(W) {
        var Jt = W.state, Wt = Jt.pending;
        Wt > W.avail_out && (Wt = W.avail_out), Wt !== 0 && (m.arraySet(W.output, Jt.pending_buf, Jt.pending_out, Wt, W.next_out), W.next_out += Wt, Jt.pending_out += Wt, W.total_out += Wt, W.avail_out -= Wt, Jt.pending -= Wt, Jt.pending === 0 && (Jt.pending_out = 0));
      }
      function Bt(W, Jt) {
        _._tr_flush_block(W, 0 <= W.block_start ? W.block_start : -1, W.strstart - W.block_start, Jt), W.block_start = W.strstart, Ot(W.strm);
      }
      function ke(W, Jt) {
        W.pending_buf[W.pending++] = Jt;
      }
      function fe(W, Jt) {
        W.pending_buf[W.pending++] = Jt >>> 8 & 255, W.pending_buf[W.pending++] = 255 & Jt;
      }
      function Yt(W, Jt) {
        var Wt, pt, dt = W.max_chain_length, Dt = W.strstart, ie = W.prev_length, Kt = W.nice_match, D = W.strstart > W.w_size - It ? W.strstart - (W.w_size - It) : 0, Q = W.window, ot = W.w_mask, nt = W.prev, vt = W.strstart + ct, Gt = Q[Dt + ie - 1], Xt = Q[Dt + ie];
        W.prev_length >= W.good_match && (dt >>= 2), Kt > W.lookahead && (Kt = W.lookahead);
        do
          if (Q[(Wt = Jt) + ie] === Xt && Q[Wt + ie - 1] === Gt && Q[Wt] === Q[Dt] && Q[++Wt] === Q[Dt + 1]) {
            Dt += 2, Wt++;
            do
              ;
            while (Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Q[++Dt] === Q[++Wt] && Dt < vt);
            if (pt = ct - (vt - Dt), Dt = vt - ct, ie < pt) {
              if (W.match_start = Jt, Kt <= (ie = pt))
                break;
              Gt = Q[Dt + ie - 1], Xt = Q[Dt + ie];
            }
          }
        while ((Jt = nt[Jt & ot]) > D && --dt != 0);
        return ie <= W.lookahead ? ie : W.lookahead;
      }
      function ti(W) {
        var Jt, Wt, pt, dt, Dt, ie, Kt, D, Q, ot, nt = W.w_size;
        do {
          if (dt = W.window_size - W.lookahead - W.strstart, W.strstart >= nt + (nt - It)) {
            for (m.arraySet(W.window, W.window, nt, nt, 0), W.match_start -= nt, W.strstart -= nt, W.block_start -= nt, Jt = Wt = W.hash_size; pt = W.head[--Jt], W.head[Jt] = nt <= pt ? pt - nt : 0, --Wt; )
              ;
            for (Jt = Wt = nt; pt = W.prev[--Jt], W.prev[Jt] = nt <= pt ? pt - nt : 0, --Wt; )
              ;
            dt += nt;
          }
          if (W.strm.avail_in === 0)
            break;
          if (ie = W.strm, Kt = W.window, D = W.strstart + W.lookahead, Q = dt, ot = void 0, ot = ie.avail_in, Q < ot && (ot = Q), Wt = ot === 0 ? 0 : (ie.avail_in -= ot, m.arraySet(Kt, ie.input, ie.next_in, ot, D), ie.state.wrap === 1 ? ie.adler = T(ie.adler, Kt, ot, D) : ie.state.wrap === 2 && (ie.adler = S(ie.adler, Kt, ot, D)), ie.next_in += ot, ie.total_in += ot, ot), W.lookahead += Wt, W.lookahead + W.insert >= $)
            for (Dt = W.strstart - W.insert, W.ins_h = W.window[Dt], W.ins_h = (W.ins_h << W.hash_shift ^ W.window[Dt + 1]) & W.hash_mask; W.insert && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[Dt + $ - 1]) & W.hash_mask, W.prev[Dt & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = Dt, Dt++, W.insert--, !(W.lookahead + W.insert < $)); )
              ;
        } while (W.lookahead < It && W.strm.avail_in !== 0);
      }
      function Ni(W, Jt) {
        for (var Wt, pt; ; ) {
          if (W.lookahead < It) {
            if (ti(W), W.lookahead < It && Jt === z)
              return G;
            if (W.lookahead === 0)
              break;
          }
          if (Wt = 0, W.lookahead >= $ && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + $ - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart), Wt !== 0 && W.strstart - Wt <= W.w_size - It && (W.match_length = Yt(W, Wt)), W.match_length >= $)
            if (pt = _._tr_tally(W, W.strstart - W.match_start, W.match_length - $), W.lookahead -= W.match_length, W.match_length <= W.max_lazy_match && W.lookahead >= $) {
              for (W.match_length--; W.strstart++, W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + $ - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart, --W.match_length != 0; )
                ;
              W.strstart++;
            } else
              W.strstart += W.match_length, W.match_length = 0, W.ins_h = W.window[W.strstart], W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + 1]) & W.hash_mask;
          else
            pt = _._tr_tally(W, 0, W.window[W.strstart]), W.lookahead--, W.strstart++;
          if (pt && (Bt(W, !1), W.strm.avail_out === 0))
            return G;
        }
        return W.insert = W.strstart < $ - 1 ? W.strstart : $ - 1, Jt === B ? (Bt(W, !0), W.strm.avail_out === 0 ? Et : Ct) : W.last_lit && (Bt(W, !1), W.strm.avail_out === 0) ? G : Pt;
      }
      function Oe(W, Jt) {
        for (var Wt, pt, dt; ; ) {
          if (W.lookahead < It) {
            if (ti(W), W.lookahead < It && Jt === z)
              return G;
            if (W.lookahead === 0)
              break;
          }
          if (Wt = 0, W.lookahead >= $ && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + $ - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart), W.prev_length = W.match_length, W.prev_match = W.match_start, W.match_length = $ - 1, Wt !== 0 && W.prev_length < W.max_lazy_match && W.strstart - Wt <= W.w_size - It && (W.match_length = Yt(W, Wt), W.match_length <= 5 && (W.strategy === 1 || W.match_length === $ && 4096 < W.strstart - W.match_start) && (W.match_length = $ - 1)), W.prev_length >= $ && W.match_length <= W.prev_length) {
            for (dt = W.strstart + W.lookahead - $, pt = _._tr_tally(W, W.strstart - 1 - W.prev_match, W.prev_length - $), W.lookahead -= W.prev_length - 1, W.prev_length -= 2; ++W.strstart <= dt && (W.ins_h = (W.ins_h << W.hash_shift ^ W.window[W.strstart + $ - 1]) & W.hash_mask, Wt = W.prev[W.strstart & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = W.strstart), --W.prev_length != 0; )
              ;
            if (W.match_available = 0, W.match_length = $ - 1, W.strstart++, pt && (Bt(W, !1), W.strm.avail_out === 0))
              return G;
          } else if (W.match_available) {
            if ((pt = _._tr_tally(W, 0, W.window[W.strstart - 1])) && Bt(W, !1), W.strstart++, W.lookahead--, W.strm.avail_out === 0)
              return G;
          } else
            W.match_available = 1, W.strstart++, W.lookahead--;
        }
        return W.match_available && (pt = _._tr_tally(W, 0, W.window[W.strstart - 1]), W.match_available = 0), W.insert = W.strstart < $ - 1 ? W.strstart : $ - 1, Jt === B ? (Bt(W, !0), W.strm.avail_out === 0 ? Et : Ct) : W.last_lit && (Bt(W, !1), W.strm.avail_out === 0) ? G : Pt;
      }
      function Ge(W, Jt, Wt, pt, dt) {
        this.good_length = W, this.max_lazy = Jt, this.nice_length = Wt, this.max_chain = pt, this.func = dt;
      }
      function pi() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = M, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new m.Buf16(2 * j), this.dyn_dtree = new m.Buf16(2 * (2 * U + 1)), this.bl_tree = new m.Buf16(2 * (2 * N + 1)), Ft(this.dyn_ltree), Ft(this.dyn_dtree), Ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new m.Buf16(J + 1), this.heap = new m.Buf16(2 * b + 1), Ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new m.Buf16(2 * b + 1), Ft(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Li(W) {
        var Jt;
        return W && W.state ? (W.total_in = W.total_out = 0, W.data_type = x, (Jt = W.state).pending = 0, Jt.pending_out = 0, Jt.wrap < 0 && (Jt.wrap = -Jt.wrap), Jt.status = Jt.wrap ? et : yt, W.adler = Jt.wrap === 2 ? 0 : 1, Jt.last_flush = z, _._tr_init(Jt), I) : ce(W, F);
      }
      function cn(W) {
        var Jt = Li(W);
        return Jt === I && function(Wt) {
          Wt.window_size = 2 * Wt.w_size, Ft(Wt.head), Wt.max_lazy_match = u[Wt.level].max_lazy, Wt.good_match = u[Wt.level].good_length, Wt.nice_match = u[Wt.level].nice_length, Wt.max_chain_length = u[Wt.level].max_chain, Wt.strstart = 0, Wt.block_start = 0, Wt.lookahead = 0, Wt.insert = 0, Wt.match_length = Wt.prev_length = $ - 1, Wt.match_available = 0, Wt.ins_h = 0;
        }(W.state), Jt;
      }
      function Ji(W, Jt, Wt, pt, dt, Dt) {
        if (!W)
          return F;
        var ie = 1;
        if (Jt === E && (Jt = 6), pt < 0 ? (ie = 0, pt = -pt) : 15 < pt && (ie = 2, pt -= 16), dt < 1 || R < dt || Wt !== M || pt < 8 || 15 < pt || Jt < 0 || 9 < Jt || Dt < 0 || L < Dt)
          return ce(W, F);
        pt === 8 && (pt = 9);
        var Kt = new pi();
        return (W.state = Kt).strm = W, Kt.wrap = ie, Kt.gzhead = null, Kt.w_bits = pt, Kt.w_size = 1 << Kt.w_bits, Kt.w_mask = Kt.w_size - 1, Kt.hash_bits = dt + 7, Kt.hash_size = 1 << Kt.hash_bits, Kt.hash_mask = Kt.hash_size - 1, Kt.hash_shift = ~~((Kt.hash_bits + $ - 1) / $), Kt.window = new m.Buf8(2 * Kt.w_size), Kt.head = new m.Buf16(Kt.hash_size), Kt.prev = new m.Buf16(Kt.w_size), Kt.lit_bufsize = 1 << dt + 6, Kt.pending_buf_size = 4 * Kt.lit_bufsize, Kt.pending_buf = new m.Buf8(Kt.pending_buf_size), Kt.d_buf = 1 * Kt.lit_bufsize, Kt.l_buf = 3 * Kt.lit_bufsize, Kt.level = Jt, Kt.strategy = Dt, Kt.method = Wt, cn(W);
      }
      u = [new Ge(0, 0, 0, 0, function(W, Jt) {
        var Wt = 65535;
        for (Wt > W.pending_buf_size - 5 && (Wt = W.pending_buf_size - 5); ; ) {
          if (W.lookahead <= 1) {
            if (ti(W), W.lookahead === 0 && Jt === z)
              return G;
            if (W.lookahead === 0)
              break;
          }
          W.strstart += W.lookahead, W.lookahead = 0;
          var pt = W.block_start + Wt;
          if ((W.strstart === 0 || W.strstart >= pt) && (W.lookahead = W.strstart - pt, W.strstart = pt, Bt(W, !1), W.strm.avail_out === 0) || W.strstart - W.block_start >= W.w_size - It && (Bt(W, !1), W.strm.avail_out === 0))
            return G;
        }
        return W.insert = 0, Jt === B ? (Bt(W, !0), W.strm.avail_out === 0 ? Et : Ct) : (W.strstart > W.block_start && (Bt(W, !1), W.strm.avail_out), G);
      }), new Ge(4, 4, 8, 4, Ni), new Ge(4, 5, 16, 8, Ni), new Ge(4, 6, 32, 32, Ni), new Ge(4, 4, 16, 16, Oe), new Ge(8, 16, 32, 32, Oe), new Ge(8, 16, 128, 128, Oe), new Ge(8, 32, 128, 256, Oe), new Ge(32, 128, 258, 1024, Oe), new Ge(32, 258, 258, 4096, Oe)], d.deflateInit = function(W, Jt) {
        return Ji(W, Jt, M, 15, 8, 0);
      }, d.deflateInit2 = Ji, d.deflateReset = cn, d.deflateResetKeep = Li, d.deflateSetHeader = function(W, Jt) {
        return W && W.state ? W.state.wrap !== 2 ? F : (W.state.gzhead = Jt, I) : F;
      }, d.deflate = function(W, Jt) {
        var Wt, pt, dt, Dt;
        if (!W || !W.state || 5 < Jt || Jt < 0)
          return W ? ce(W, F) : F;
        if (pt = W.state, !W.output || !W.input && W.avail_in !== 0 || pt.status === 666 && Jt !== B)
          return ce(W, W.avail_out === 0 ? -5 : F);
        if (pt.strm = W, Wt = pt.last_flush, pt.last_flush = Jt, pt.status === et)
          if (pt.wrap === 2)
            W.adler = 0, ke(pt, 31), ke(pt, 139), ke(pt, 8), pt.gzhead ? (ke(pt, (pt.gzhead.text ? 1 : 0) + (pt.gzhead.hcrc ? 2 : 0) + (pt.gzhead.extra ? 4 : 0) + (pt.gzhead.name ? 8 : 0) + (pt.gzhead.comment ? 16 : 0)), ke(pt, 255 & pt.gzhead.time), ke(pt, pt.gzhead.time >> 8 & 255), ke(pt, pt.gzhead.time >> 16 & 255), ke(pt, pt.gzhead.time >> 24 & 255), ke(pt, pt.level === 9 ? 2 : 2 <= pt.strategy || pt.level < 2 ? 4 : 0), ke(pt, 255 & pt.gzhead.os), pt.gzhead.extra && pt.gzhead.extra.length && (ke(pt, 255 & pt.gzhead.extra.length), ke(pt, pt.gzhead.extra.length >> 8 & 255)), pt.gzhead.hcrc && (W.adler = S(W.adler, pt.pending_buf, pt.pending, 0)), pt.gzindex = 0, pt.status = 69) : (ke(pt, 0), ke(pt, 0), ke(pt, 0), ke(pt, 0), ke(pt, 0), ke(pt, pt.level === 9 ? 2 : 2 <= pt.strategy || pt.level < 2 ? 4 : 0), ke(pt, 3), pt.status = yt);
          else {
            var ie = M + (pt.w_bits - 8 << 4) << 8;
            ie |= (2 <= pt.strategy || pt.level < 2 ? 0 : pt.level < 6 ? 1 : pt.level === 6 ? 2 : 3) << 6, pt.strstart !== 0 && (ie |= 32), ie += 31 - ie % 31, pt.status = yt, fe(pt, ie), pt.strstart !== 0 && (fe(pt, W.adler >>> 16), fe(pt, 65535 & W.adler)), W.adler = 1;
          }
        if (pt.status === 69)
          if (pt.gzhead.extra) {
            for (dt = pt.pending; pt.gzindex < (65535 & pt.gzhead.extra.length) && (pt.pending !== pt.pending_buf_size || (pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Ot(W), dt = pt.pending, pt.pending !== pt.pending_buf_size)); )
              ke(pt, 255 & pt.gzhead.extra[pt.gzindex]), pt.gzindex++;
            pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), pt.gzindex === pt.gzhead.extra.length && (pt.gzindex = 0, pt.status = 73);
          } else
            pt.status = 73;
        if (pt.status === 73)
          if (pt.gzhead.name) {
            dt = pt.pending;
            do {
              if (pt.pending === pt.pending_buf_size && (pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Ot(W), dt = pt.pending, pt.pending === pt.pending_buf_size)) {
                Dt = 1;
                break;
              }
              Dt = pt.gzindex < pt.gzhead.name.length ? 255 & pt.gzhead.name.charCodeAt(pt.gzindex++) : 0, ke(pt, Dt);
            } while (Dt !== 0);
            pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Dt === 0 && (pt.gzindex = 0, pt.status = 91);
          } else
            pt.status = 91;
        if (pt.status === 91)
          if (pt.gzhead.comment) {
            dt = pt.pending;
            do {
              if (pt.pending === pt.pending_buf_size && (pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Ot(W), dt = pt.pending, pt.pending === pt.pending_buf_size)) {
                Dt = 1;
                break;
              }
              Dt = pt.gzindex < pt.gzhead.comment.length ? 255 & pt.gzhead.comment.charCodeAt(pt.gzindex++) : 0, ke(pt, Dt);
            } while (Dt !== 0);
            pt.gzhead.hcrc && pt.pending > dt && (W.adler = S(W.adler, pt.pending_buf, pt.pending - dt, dt)), Dt === 0 && (pt.status = 103);
          } else
            pt.status = 103;
        if (pt.status === 103 && (pt.gzhead.hcrc ? (pt.pending + 2 > pt.pending_buf_size && Ot(W), pt.pending + 2 <= pt.pending_buf_size && (ke(pt, 255 & W.adler), ke(pt, W.adler >> 8 & 255), W.adler = 0, pt.status = yt)) : pt.status = yt), pt.pending !== 0) {
          if (Ot(W), W.avail_out === 0)
            return pt.last_flush = -1, I;
        } else if (W.avail_in === 0 && re(Jt) <= re(Wt) && Jt !== B)
          return ce(W, -5);
        if (pt.status === 666 && W.avail_in !== 0)
          return ce(W, -5);
        if (W.avail_in !== 0 || pt.lookahead !== 0 || Jt !== z && pt.status !== 666) {
          var Kt = pt.strategy === 2 ? function(D, Q) {
            for (var ot; ; ) {
              if (D.lookahead === 0 && (ti(D), D.lookahead === 0)) {
                if (Q === z)
                  return G;
                break;
              }
              if (D.match_length = 0, ot = _._tr_tally(D, 0, D.window[D.strstart]), D.lookahead--, D.strstart++, ot && (Bt(D, !1), D.strm.avail_out === 0))
                return G;
            }
            return D.insert = 0, Q === B ? (Bt(D, !0), D.strm.avail_out === 0 ? Et : Ct) : D.last_lit && (Bt(D, !1), D.strm.avail_out === 0) ? G : Pt;
          }(pt, Jt) : pt.strategy === 3 ? function(D, Q) {
            for (var ot, nt, vt, Gt, Xt = D.window; ; ) {
              if (D.lookahead <= ct) {
                if (ti(D), D.lookahead <= ct && Q === z)
                  return G;
                if (D.lookahead === 0)
                  break;
              }
              if (D.match_length = 0, D.lookahead >= $ && 0 < D.strstart && (nt = Xt[vt = D.strstart - 1]) === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt]) {
                Gt = D.strstart + ct;
                do
                  ;
                while (nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && nt === Xt[++vt] && vt < Gt);
                D.match_length = ct - (Gt - vt), D.match_length > D.lookahead && (D.match_length = D.lookahead);
              }
              if (D.match_length >= $ ? (ot = _._tr_tally(D, 1, D.match_length - $), D.lookahead -= D.match_length, D.strstart += D.match_length, D.match_length = 0) : (ot = _._tr_tally(D, 0, D.window[D.strstart]), D.lookahead--, D.strstart++), ot && (Bt(D, !1), D.strm.avail_out === 0))
                return G;
            }
            return D.insert = 0, Q === B ? (Bt(D, !0), D.strm.avail_out === 0 ? Et : Ct) : D.last_lit && (Bt(D, !1), D.strm.avail_out === 0) ? G : Pt;
          }(pt, Jt) : u[pt.level].func(pt, Jt);
          if (Kt !== Et && Kt !== Ct || (pt.status = 666), Kt === G || Kt === Et)
            return W.avail_out === 0 && (pt.last_flush = -1), I;
          if (Kt === Pt && (Jt === 1 ? _._tr_align(pt) : Jt !== 5 && (_._tr_stored_block(pt, 0, 0, !1), Jt === 3 && (Ft(pt.head), pt.lookahead === 0 && (pt.strstart = 0, pt.block_start = 0, pt.insert = 0))), Ot(W), W.avail_out === 0))
            return pt.last_flush = -1, I;
        }
        return Jt !== B ? I : pt.wrap <= 0 ? 1 : (pt.wrap === 2 ? (ke(pt, 255 & W.adler), ke(pt, W.adler >> 8 & 255), ke(pt, W.adler >> 16 & 255), ke(pt, W.adler >> 24 & 255), ke(pt, 255 & W.total_in), ke(pt, W.total_in >> 8 & 255), ke(pt, W.total_in >> 16 & 255), ke(pt, W.total_in >> 24 & 255)) : (fe(pt, W.adler >>> 16), fe(pt, 65535 & W.adler)), Ot(W), 0 < pt.wrap && (pt.wrap = -pt.wrap), pt.pending !== 0 ? I : 1);
      }, d.deflateEnd = function(W) {
        var Jt;
        return W && W.state ? (Jt = W.state.status) !== et && Jt !== 69 && Jt !== 73 && Jt !== 91 && Jt !== 103 && Jt !== yt && Jt !== 666 ? ce(W, F) : (W.state = null, Jt === yt ? ce(W, -3) : I) : F;
      }, d.deflateSetDictionary = function(W, Jt) {
        var Wt, pt, dt, Dt, ie, Kt, D, Q, ot = Jt.length;
        if (!W || !W.state || (Dt = (Wt = W.state).wrap) === 2 || Dt === 1 && Wt.status !== et || Wt.lookahead)
          return F;
        for (Dt === 1 && (W.adler = T(W.adler, Jt, ot, 0)), Wt.wrap = 0, ot >= Wt.w_size && (Dt === 0 && (Ft(Wt.head), Wt.strstart = 0, Wt.block_start = 0, Wt.insert = 0), Q = new m.Buf8(Wt.w_size), m.arraySet(Q, Jt, ot - Wt.w_size, Wt.w_size, 0), Jt = Q, ot = Wt.w_size), ie = W.avail_in, Kt = W.next_in, D = W.input, W.avail_in = ot, W.next_in = 0, W.input = Jt, ti(Wt); Wt.lookahead >= $; ) {
          for (pt = Wt.strstart, dt = Wt.lookahead - ($ - 1); Wt.ins_h = (Wt.ins_h << Wt.hash_shift ^ Wt.window[pt + $ - 1]) & Wt.hash_mask, Wt.prev[pt & Wt.w_mask] = Wt.head[Wt.ins_h], Wt.head[Wt.ins_h] = pt, pt++, --dt; )
            ;
          Wt.strstart = pt, Wt.lookahead = $ - 1, ti(Wt);
        }
        return Wt.strstart += Wt.lookahead, Wt.block_start = Wt.strstart, Wt.insert = Wt.lookahead, Wt.lookahead = 0, Wt.match_length = Wt.prev_length = $ - 1, Wt.match_available = 0, W.next_in = Kt, W.input = D, W.avail_in = ie, Wt.wrap = Dt, I;
      }, d.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(o, p, d) {
      p.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(o, p, d) {
      p.exports = function(u, m) {
        var _, T, S, C, z, B, I, F, E, L, x, M, R, b, U, N, j, J, $, ct, It, et, yt, G, Pt;
        _ = u.state, T = u.next_in, G = u.input, S = T + (u.avail_in - 5), C = u.next_out, Pt = u.output, z = C - (m - u.avail_out), B = C + (u.avail_out - 257), I = _.dmax, F = _.wsize, E = _.whave, L = _.wnext, x = _.window, M = _.hold, R = _.bits, b = _.lencode, U = _.distcode, N = (1 << _.lenbits) - 1, j = (1 << _.distbits) - 1;
        t:
          do {
            R < 15 && (M += G[T++] << R, R += 8, M += G[T++] << R, R += 8), J = b[M & N];
            e:
              for (; ; ) {
                if (M >>>= $ = J >>> 24, R -= $, ($ = J >>> 16 & 255) === 0)
                  Pt[C++] = 65535 & J;
                else {
                  if (!(16 & $)) {
                    if (!(64 & $)) {
                      J = b[(65535 & J) + (M & (1 << $) - 1)];
                      continue e;
                    }
                    if (32 & $) {
                      _.mode = 12;
                      break t;
                    }
                    u.msg = "invalid literal/length code", _.mode = 30;
                    break t;
                  }
                  ct = 65535 & J, ($ &= 15) && (R < $ && (M += G[T++] << R, R += 8), ct += M & (1 << $) - 1, M >>>= $, R -= $), R < 15 && (M += G[T++] << R, R += 8, M += G[T++] << R, R += 8), J = U[M & j];
                  i:
                    for (; ; ) {
                      if (M >>>= $ = J >>> 24, R -= $, !(16 & ($ = J >>> 16 & 255))) {
                        if (!(64 & $)) {
                          J = U[(65535 & J) + (M & (1 << $) - 1)];
                          continue i;
                        }
                        u.msg = "invalid distance code", _.mode = 30;
                        break t;
                      }
                      if (It = 65535 & J, R < ($ &= 15) && (M += G[T++] << R, (R += 8) < $ && (M += G[T++] << R, R += 8)), I < (It += M & (1 << $) - 1)) {
                        u.msg = "invalid distance too far back", _.mode = 30;
                        break t;
                      }
                      if (M >>>= $, R -= $, ($ = C - z) < It) {
                        if (E < ($ = It - $) && _.sane) {
                          u.msg = "invalid distance too far back", _.mode = 30;
                          break t;
                        }
                        if (yt = x, (et = 0) === L) {
                          if (et += F - $, $ < ct) {
                            for (ct -= $; Pt[C++] = x[et++], --$; )
                              ;
                            et = C - It, yt = Pt;
                          }
                        } else if (L < $) {
                          if (et += F + L - $, ($ -= L) < ct) {
                            for (ct -= $; Pt[C++] = x[et++], --$; )
                              ;
                            if (et = 0, L < ct) {
                              for (ct -= $ = L; Pt[C++] = x[et++], --$; )
                                ;
                              et = C - It, yt = Pt;
                            }
                          }
                        } else if (et += L - $, $ < ct) {
                          for (ct -= $; Pt[C++] = x[et++], --$; )
                            ;
                          et = C - It, yt = Pt;
                        }
                        for (; 2 < ct; )
                          Pt[C++] = yt[et++], Pt[C++] = yt[et++], Pt[C++] = yt[et++], ct -= 3;
                        ct && (Pt[C++] = yt[et++], 1 < ct && (Pt[C++] = yt[et++]));
                      } else {
                        for (et = C - It; Pt[C++] = Pt[et++], Pt[C++] = Pt[et++], Pt[C++] = Pt[et++], 2 < (ct -= 3); )
                          ;
                        ct && (Pt[C++] = Pt[et++], 1 < ct && (Pt[C++] = Pt[et++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (T < S && C < B);
        T -= ct = R >> 3, M &= (1 << (R -= ct << 3)) - 1, u.next_in = T, u.next_out = C, u.avail_in = T < S ? S - T + 5 : 5 - (T - S), u.avail_out = C < B ? B - C + 257 : 257 - (C - B), _.hold = M, _.bits = R;
      };
    }, {}], 49: [function(o, p, d) {
      var u = o("../utils/common"), m = o("./adler32"), _ = o("./crc32"), T = o("./inffast"), S = o("./inftrees"), C = 1, z = 2, B = 0, I = -2, F = 1, E = 852, L = 592;
      function x(et) {
        return (et >>> 24 & 255) + (et >>> 8 & 65280) + ((65280 & et) << 8) + ((255 & et) << 24);
      }
      function M() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new u.Buf16(320), this.work = new u.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function R(et) {
        var yt;
        return et && et.state ? (yt = et.state, et.total_in = et.total_out = yt.total = 0, et.msg = "", yt.wrap && (et.adler = 1 & yt.wrap), yt.mode = F, yt.last = 0, yt.havedict = 0, yt.dmax = 32768, yt.head = null, yt.hold = 0, yt.bits = 0, yt.lencode = yt.lendyn = new u.Buf32(E), yt.distcode = yt.distdyn = new u.Buf32(L), yt.sane = 1, yt.back = -1, B) : I;
      }
      function b(et) {
        var yt;
        return et && et.state ? ((yt = et.state).wsize = 0, yt.whave = 0, yt.wnext = 0, R(et)) : I;
      }
      function U(et, yt) {
        var G, Pt;
        return et && et.state ? (Pt = et.state, yt < 0 ? (G = 0, yt = -yt) : (G = 1 + (yt >> 4), yt < 48 && (yt &= 15)), yt && (yt < 8 || 15 < yt) ? I : (Pt.window !== null && Pt.wbits !== yt && (Pt.window = null), Pt.wrap = G, Pt.wbits = yt, b(et))) : I;
      }
      function N(et, yt) {
        var G, Pt;
        return et ? (Pt = new M(), (et.state = Pt).window = null, (G = U(et, yt)) !== B && (et.state = null), G) : I;
      }
      var j, J, $ = !0;
      function ct(et) {
        if ($) {
          var yt;
          for (j = new u.Buf32(512), J = new u.Buf32(32), yt = 0; yt < 144; )
            et.lens[yt++] = 8;
          for (; yt < 256; )
            et.lens[yt++] = 9;
          for (; yt < 280; )
            et.lens[yt++] = 7;
          for (; yt < 288; )
            et.lens[yt++] = 8;
          for (S(C, et.lens, 0, 288, j, 0, et.work, { bits: 9 }), yt = 0; yt < 32; )
            et.lens[yt++] = 5;
          S(z, et.lens, 0, 32, J, 0, et.work, { bits: 5 }), $ = !1;
        }
        et.lencode = j, et.lenbits = 9, et.distcode = J, et.distbits = 5;
      }
      function It(et, yt, G, Pt) {
        var Et, Ct = et.state;
        return Ct.window === null && (Ct.wsize = 1 << Ct.wbits, Ct.wnext = 0, Ct.whave = 0, Ct.window = new u.Buf8(Ct.wsize)), Pt >= Ct.wsize ? (u.arraySet(Ct.window, yt, G - Ct.wsize, Ct.wsize, 0), Ct.wnext = 0, Ct.whave = Ct.wsize) : (Pt < (Et = Ct.wsize - Ct.wnext) && (Et = Pt), u.arraySet(Ct.window, yt, G - Pt, Et, Ct.wnext), (Pt -= Et) ? (u.arraySet(Ct.window, yt, G - Pt, Pt, 0), Ct.wnext = Pt, Ct.whave = Ct.wsize) : (Ct.wnext += Et, Ct.wnext === Ct.wsize && (Ct.wnext = 0), Ct.whave < Ct.wsize && (Ct.whave += Et))), 0;
      }
      d.inflateReset = b, d.inflateReset2 = U, d.inflateResetKeep = R, d.inflateInit = function(et) {
        return N(et, 15);
      }, d.inflateInit2 = N, d.inflate = function(et, yt) {
        var G, Pt, Et, Ct, ce, re, Ft, Ot, Bt, ke, fe, Yt, ti, Ni, Oe, Ge, pi, Li, cn, Ji, W, Jt, Wt, pt, dt = 0, Dt = new u.Buf8(4), ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!et || !et.state || !et.output || !et.input && et.avail_in !== 0)
          return I;
        (G = et.state).mode === 12 && (G.mode = 13), ce = et.next_out, Et = et.output, Ft = et.avail_out, Ct = et.next_in, Pt = et.input, re = et.avail_in, Ot = G.hold, Bt = G.bits, ke = re, fe = Ft, Jt = B;
        t:
          for (; ; )
            switch (G.mode) {
              case F:
                if (G.wrap === 0) {
                  G.mode = 13;
                  break;
                }
                for (; Bt < 16; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                if (2 & G.wrap && Ot === 35615) {
                  Dt[G.check = 0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = _(G.check, Dt, 2, 0), Bt = Ot = 0, G.mode = 2;
                  break;
                }
                if (G.flags = 0, G.head && (G.head.done = !1), !(1 & G.wrap) || (((255 & Ot) << 8) + (Ot >> 8)) % 31) {
                  et.msg = "incorrect header check", G.mode = 30;
                  break;
                }
                if ((15 & Ot) != 8) {
                  et.msg = "unknown compression method", G.mode = 30;
                  break;
                }
                if (Bt -= 4, W = 8 + (15 & (Ot >>>= 4)), G.wbits === 0)
                  G.wbits = W;
                else if (W > G.wbits) {
                  et.msg = "invalid window size", G.mode = 30;
                  break;
                }
                G.dmax = 1 << W, et.adler = G.check = 1, G.mode = 512 & Ot ? 10 : 12, Bt = Ot = 0;
                break;
              case 2:
                for (; Bt < 16; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                if (G.flags = Ot, (255 & G.flags) != 8) {
                  et.msg = "unknown compression method", G.mode = 30;
                  break;
                }
                if (57344 & G.flags) {
                  et.msg = "unknown header flags set", G.mode = 30;
                  break;
                }
                G.head && (G.head.text = Ot >> 8 & 1), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = _(G.check, Dt, 2, 0)), Bt = Ot = 0, G.mode = 3;
              case 3:
                for (; Bt < 32; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                G.head && (G.head.time = Ot), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, Dt[2] = Ot >>> 16 & 255, Dt[3] = Ot >>> 24 & 255, G.check = _(G.check, Dt, 4, 0)), Bt = Ot = 0, G.mode = 4;
              case 4:
                for (; Bt < 16; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                G.head && (G.head.xflags = 255 & Ot, G.head.os = Ot >> 8), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = _(G.check, Dt, 2, 0)), Bt = Ot = 0, G.mode = 5;
              case 5:
                if (1024 & G.flags) {
                  for (; Bt < 16; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  G.length = Ot, G.head && (G.head.extra_len = Ot), 512 & G.flags && (Dt[0] = 255 & Ot, Dt[1] = Ot >>> 8 & 255, G.check = _(G.check, Dt, 2, 0)), Bt = Ot = 0;
                } else
                  G.head && (G.head.extra = null);
                G.mode = 6;
              case 6:
                if (1024 & G.flags && (re < (Yt = G.length) && (Yt = re), Yt && (G.head && (W = G.head.extra_len - G.length, G.head.extra || (G.head.extra = new Array(G.head.extra_len)), u.arraySet(G.head.extra, Pt, Ct, Yt, W)), 512 & G.flags && (G.check = _(G.check, Pt, Yt, Ct)), re -= Yt, Ct += Yt, G.length -= Yt), G.length))
                  break t;
                G.length = 0, G.mode = 7;
              case 7:
                if (2048 & G.flags) {
                  if (re === 0)
                    break t;
                  for (Yt = 0; W = Pt[Ct + Yt++], G.head && W && G.length < 65536 && (G.head.name += String.fromCharCode(W)), W && Yt < re; )
                    ;
                  if (512 & G.flags && (G.check = _(G.check, Pt, Yt, Ct)), re -= Yt, Ct += Yt, W)
                    break t;
                } else
                  G.head && (G.head.name = null);
                G.length = 0, G.mode = 8;
              case 8:
                if (4096 & G.flags) {
                  if (re === 0)
                    break t;
                  for (Yt = 0; W = Pt[Ct + Yt++], G.head && W && G.length < 65536 && (G.head.comment += String.fromCharCode(W)), W && Yt < re; )
                    ;
                  if (512 & G.flags && (G.check = _(G.check, Pt, Yt, Ct)), re -= Yt, Ct += Yt, W)
                    break t;
                } else
                  G.head && (G.head.comment = null);
                G.mode = 9;
              case 9:
                if (512 & G.flags) {
                  for (; Bt < 16; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  if (Ot !== (65535 & G.check)) {
                    et.msg = "header crc mismatch", G.mode = 30;
                    break;
                  }
                  Bt = Ot = 0;
                }
                G.head && (G.head.hcrc = G.flags >> 9 & 1, G.head.done = !0), et.adler = G.check = 0, G.mode = 12;
                break;
              case 10:
                for (; Bt < 32; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                et.adler = G.check = x(Ot), Bt = Ot = 0, G.mode = 11;
              case 11:
                if (G.havedict === 0)
                  return et.next_out = ce, et.avail_out = Ft, et.next_in = Ct, et.avail_in = re, G.hold = Ot, G.bits = Bt, 2;
                et.adler = G.check = 1, G.mode = 12;
              case 12:
                if (yt === 5 || yt === 6)
                  break t;
              case 13:
                if (G.last) {
                  Ot >>>= 7 & Bt, Bt -= 7 & Bt, G.mode = 27;
                  break;
                }
                for (; Bt < 3; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                switch (G.last = 1 & Ot, Bt -= 1, 3 & (Ot >>>= 1)) {
                  case 0:
                    G.mode = 14;
                    break;
                  case 1:
                    if (ct(G), G.mode = 20, yt !== 6)
                      break;
                    Ot >>>= 2, Bt -= 2;
                    break t;
                  case 2:
                    G.mode = 17;
                    break;
                  case 3:
                    et.msg = "invalid block type", G.mode = 30;
                }
                Ot >>>= 2, Bt -= 2;
                break;
              case 14:
                for (Ot >>>= 7 & Bt, Bt -= 7 & Bt; Bt < 32; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                if ((65535 & Ot) != (Ot >>> 16 ^ 65535)) {
                  et.msg = "invalid stored block lengths", G.mode = 30;
                  break;
                }
                if (G.length = 65535 & Ot, Bt = Ot = 0, G.mode = 15, yt === 6)
                  break t;
              case 15:
                G.mode = 16;
              case 16:
                if (Yt = G.length) {
                  if (re < Yt && (Yt = re), Ft < Yt && (Yt = Ft), Yt === 0)
                    break t;
                  u.arraySet(Et, Pt, Ct, Yt, ce), re -= Yt, Ct += Yt, Ft -= Yt, ce += Yt, G.length -= Yt;
                  break;
                }
                G.mode = 12;
                break;
              case 17:
                for (; Bt < 14; ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                if (G.nlen = 257 + (31 & Ot), Ot >>>= 5, Bt -= 5, G.ndist = 1 + (31 & Ot), Ot >>>= 5, Bt -= 5, G.ncode = 4 + (15 & Ot), Ot >>>= 4, Bt -= 4, 286 < G.nlen || 30 < G.ndist) {
                  et.msg = "too many length or distance symbols", G.mode = 30;
                  break;
                }
                G.have = 0, G.mode = 18;
              case 18:
                for (; G.have < G.ncode; ) {
                  for (; Bt < 3; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  G.lens[ie[G.have++]] = 7 & Ot, Ot >>>= 3, Bt -= 3;
                }
                for (; G.have < 19; )
                  G.lens[ie[G.have++]] = 0;
                if (G.lencode = G.lendyn, G.lenbits = 7, Wt = { bits: G.lenbits }, Jt = S(0, G.lens, 0, 19, G.lencode, 0, G.work, Wt), G.lenbits = Wt.bits, Jt) {
                  et.msg = "invalid code lengths set", G.mode = 30;
                  break;
                }
                G.have = 0, G.mode = 19;
              case 19:
                for (; G.have < G.nlen + G.ndist; ) {
                  for (; Ge = (dt = G.lencode[Ot & (1 << G.lenbits) - 1]) >>> 16 & 255, pi = 65535 & dt, !((Oe = dt >>> 24) <= Bt); ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  if (pi < 16)
                    Ot >>>= Oe, Bt -= Oe, G.lens[G.have++] = pi;
                  else {
                    if (pi === 16) {
                      for (pt = Oe + 2; Bt < pt; ) {
                        if (re === 0)
                          break t;
                        re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                      }
                      if (Ot >>>= Oe, Bt -= Oe, G.have === 0) {
                        et.msg = "invalid bit length repeat", G.mode = 30;
                        break;
                      }
                      W = G.lens[G.have - 1], Yt = 3 + (3 & Ot), Ot >>>= 2, Bt -= 2;
                    } else if (pi === 17) {
                      for (pt = Oe + 3; Bt < pt; ) {
                        if (re === 0)
                          break t;
                        re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                      }
                      Bt -= Oe, W = 0, Yt = 3 + (7 & (Ot >>>= Oe)), Ot >>>= 3, Bt -= 3;
                    } else {
                      for (pt = Oe + 7; Bt < pt; ) {
                        if (re === 0)
                          break t;
                        re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                      }
                      Bt -= Oe, W = 0, Yt = 11 + (127 & (Ot >>>= Oe)), Ot >>>= 7, Bt -= 7;
                    }
                    if (G.have + Yt > G.nlen + G.ndist) {
                      et.msg = "invalid bit length repeat", G.mode = 30;
                      break;
                    }
                    for (; Yt--; )
                      G.lens[G.have++] = W;
                  }
                }
                if (G.mode === 30)
                  break;
                if (G.lens[256] === 0) {
                  et.msg = "invalid code -- missing end-of-block", G.mode = 30;
                  break;
                }
                if (G.lenbits = 9, Wt = { bits: G.lenbits }, Jt = S(C, G.lens, 0, G.nlen, G.lencode, 0, G.work, Wt), G.lenbits = Wt.bits, Jt) {
                  et.msg = "invalid literal/lengths set", G.mode = 30;
                  break;
                }
                if (G.distbits = 6, G.distcode = G.distdyn, Wt = { bits: G.distbits }, Jt = S(z, G.lens, G.nlen, G.ndist, G.distcode, 0, G.work, Wt), G.distbits = Wt.bits, Jt) {
                  et.msg = "invalid distances set", G.mode = 30;
                  break;
                }
                if (G.mode = 20, yt === 6)
                  break t;
              case 20:
                G.mode = 21;
              case 21:
                if (6 <= re && 258 <= Ft) {
                  et.next_out = ce, et.avail_out = Ft, et.next_in = Ct, et.avail_in = re, G.hold = Ot, G.bits = Bt, T(et, fe), ce = et.next_out, Et = et.output, Ft = et.avail_out, Ct = et.next_in, Pt = et.input, re = et.avail_in, Ot = G.hold, Bt = G.bits, G.mode === 12 && (G.back = -1);
                  break;
                }
                for (G.back = 0; Ge = (dt = G.lencode[Ot & (1 << G.lenbits) - 1]) >>> 16 & 255, pi = 65535 & dt, !((Oe = dt >>> 24) <= Bt); ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                if (Ge && !(240 & Ge)) {
                  for (Li = Oe, cn = Ge, Ji = pi; Ge = (dt = G.lencode[Ji + ((Ot & (1 << Li + cn) - 1) >> Li)]) >>> 16 & 255, pi = 65535 & dt, !(Li + (Oe = dt >>> 24) <= Bt); ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  Ot >>>= Li, Bt -= Li, G.back += Li;
                }
                if (Ot >>>= Oe, Bt -= Oe, G.back += Oe, G.length = pi, Ge === 0) {
                  G.mode = 26;
                  break;
                }
                if (32 & Ge) {
                  G.back = -1, G.mode = 12;
                  break;
                }
                if (64 & Ge) {
                  et.msg = "invalid literal/length code", G.mode = 30;
                  break;
                }
                G.extra = 15 & Ge, G.mode = 22;
              case 22:
                if (G.extra) {
                  for (pt = G.extra; Bt < pt; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  G.length += Ot & (1 << G.extra) - 1, Ot >>>= G.extra, Bt -= G.extra, G.back += G.extra;
                }
                G.was = G.length, G.mode = 23;
              case 23:
                for (; Ge = (dt = G.distcode[Ot & (1 << G.distbits) - 1]) >>> 16 & 255, pi = 65535 & dt, !((Oe = dt >>> 24) <= Bt); ) {
                  if (re === 0)
                    break t;
                  re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                }
                if (!(240 & Ge)) {
                  for (Li = Oe, cn = Ge, Ji = pi; Ge = (dt = G.distcode[Ji + ((Ot & (1 << Li + cn) - 1) >> Li)]) >>> 16 & 255, pi = 65535 & dt, !(Li + (Oe = dt >>> 24) <= Bt); ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  Ot >>>= Li, Bt -= Li, G.back += Li;
                }
                if (Ot >>>= Oe, Bt -= Oe, G.back += Oe, 64 & Ge) {
                  et.msg = "invalid distance code", G.mode = 30;
                  break;
                }
                G.offset = pi, G.extra = 15 & Ge, G.mode = 24;
              case 24:
                if (G.extra) {
                  for (pt = G.extra; Bt < pt; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  G.offset += Ot & (1 << G.extra) - 1, Ot >>>= G.extra, Bt -= G.extra, G.back += G.extra;
                }
                if (G.offset > G.dmax) {
                  et.msg = "invalid distance too far back", G.mode = 30;
                  break;
                }
                G.mode = 25;
              case 25:
                if (Ft === 0)
                  break t;
                if (Yt = fe - Ft, G.offset > Yt) {
                  if ((Yt = G.offset - Yt) > G.whave && G.sane) {
                    et.msg = "invalid distance too far back", G.mode = 30;
                    break;
                  }
                  ti = Yt > G.wnext ? (Yt -= G.wnext, G.wsize - Yt) : G.wnext - Yt, Yt > G.length && (Yt = G.length), Ni = G.window;
                } else
                  Ni = Et, ti = ce - G.offset, Yt = G.length;
                for (Ft < Yt && (Yt = Ft), Ft -= Yt, G.length -= Yt; Et[ce++] = Ni[ti++], --Yt; )
                  ;
                G.length === 0 && (G.mode = 21);
                break;
              case 26:
                if (Ft === 0)
                  break t;
                Et[ce++] = G.length, Ft--, G.mode = 21;
                break;
              case 27:
                if (G.wrap) {
                  for (; Bt < 32; ) {
                    if (re === 0)
                      break t;
                    re--, Ot |= Pt[Ct++] << Bt, Bt += 8;
                  }
                  if (fe -= Ft, et.total_out += fe, G.total += fe, fe && (et.adler = G.check = G.flags ? _(G.check, Et, fe, ce - fe) : m(G.check, Et, fe, ce - fe)), fe = Ft, (G.flags ? Ot : x(Ot)) !== G.check) {
                    et.msg = "incorrect data check", G.mode = 30;
                    break;
                  }
                  Bt = Ot = 0;
                }
                G.mode = 28;
              case 28:
                if (G.wrap && G.flags) {
                  for (; Bt < 32; ) {
                    if (re === 0)
                      break t;
                    re--, Ot += Pt[Ct++] << Bt, Bt += 8;
                  }
                  if (Ot !== (4294967295 & G.total)) {
                    et.msg = "incorrect length check", G.mode = 30;
                    break;
                  }
                  Bt = Ot = 0;
                }
                G.mode = 29;
              case 29:
                Jt = 1;
                break t;
              case 30:
                Jt = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return I;
            }
        return et.next_out = ce, et.avail_out = Ft, et.next_in = Ct, et.avail_in = re, G.hold = Ot, G.bits = Bt, (G.wsize || fe !== et.avail_out && G.mode < 30 && (G.mode < 27 || yt !== 4)) && It(et, et.output, et.next_out, fe - et.avail_out) ? (G.mode = 31, -4) : (ke -= et.avail_in, fe -= et.avail_out, et.total_in += ke, et.total_out += fe, G.total += fe, G.wrap && fe && (et.adler = G.check = G.flags ? _(G.check, Et, fe, et.next_out - fe) : m(G.check, Et, fe, et.next_out - fe)), et.data_type = G.bits + (G.last ? 64 : 0) + (G.mode === 12 ? 128 : 0) + (G.mode === 20 || G.mode === 15 ? 256 : 0), (ke == 0 && fe === 0 || yt === 4) && Jt === B && (Jt = -5), Jt);
      }, d.inflateEnd = function(et) {
        if (!et || !et.state)
          return I;
        var yt = et.state;
        return yt.window && (yt.window = null), et.state = null, B;
      }, d.inflateGetHeader = function(et, yt) {
        var G;
        return et && et.state && 2 & (G = et.state).wrap ? ((G.head = yt).done = !1, B) : I;
      }, d.inflateSetDictionary = function(et, yt) {
        var G, Pt = yt.length;
        return et && et.state ? (G = et.state).wrap !== 0 && G.mode !== 11 ? I : G.mode === 11 && m(1, yt, Pt, 0) !== G.check ? -3 : It(et, yt, Pt, Pt) ? (G.mode = 31, -4) : (G.havedict = 1, B) : I;
      }, d.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(o, p, d) {
      var u = o("../utils/common"), m = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], _ = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], T = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], S = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      p.exports = function(C, z, B, I, F, E, L, x) {
        var M, R, b, U, N, j, J, $, ct, It = x.bits, et = 0, yt = 0, G = 0, Pt = 0, Et = 0, Ct = 0, ce = 0, re = 0, Ft = 0, Ot = 0, Bt = null, ke = 0, fe = new u.Buf16(16), Yt = new u.Buf16(16), ti = null, Ni = 0;
        for (et = 0; et <= 15; et++)
          fe[et] = 0;
        for (yt = 0; yt < I; yt++)
          fe[z[B + yt]]++;
        for (Et = It, Pt = 15; 1 <= Pt && fe[Pt] === 0; Pt--)
          ;
        if (Pt < Et && (Et = Pt), Pt === 0)
          return F[E++] = 20971520, F[E++] = 20971520, x.bits = 1, 0;
        for (G = 1; G < Pt && fe[G] === 0; G++)
          ;
        for (Et < G && (Et = G), et = re = 1; et <= 15; et++)
          if (re <<= 1, (re -= fe[et]) < 0)
            return -1;
        if (0 < re && (C === 0 || Pt !== 1))
          return -1;
        for (Yt[1] = 0, et = 1; et < 15; et++)
          Yt[et + 1] = Yt[et] + fe[et];
        for (yt = 0; yt < I; yt++)
          z[B + yt] !== 0 && (L[Yt[z[B + yt]]++] = yt);
        if (j = C === 0 ? (Bt = ti = L, 19) : C === 1 ? (Bt = m, ke -= 257, ti = _, Ni -= 257, 256) : (Bt = T, ti = S, -1), et = G, N = E, ce = yt = Ot = 0, b = -1, U = (Ft = 1 << (Ct = Et)) - 1, C === 1 && 852 < Ft || C === 2 && 592 < Ft)
          return 1;
        for (; ; ) {
          for (J = et - ce, ct = L[yt] < j ? ($ = 0, L[yt]) : L[yt] > j ? ($ = ti[Ni + L[yt]], Bt[ke + L[yt]]) : ($ = 96, 0), M = 1 << et - ce, G = R = 1 << Ct; F[N + (Ot >> ce) + (R -= M)] = J << 24 | $ << 16 | ct | 0, R !== 0; )
            ;
          for (M = 1 << et - 1; Ot & M; )
            M >>= 1;
          if (M !== 0 ? (Ot &= M - 1, Ot += M) : Ot = 0, yt++, --fe[et] == 0) {
            if (et === Pt)
              break;
            et = z[B + L[yt]];
          }
          if (Et < et && (Ot & U) !== b) {
            for (ce === 0 && (ce = Et), N += G, re = 1 << (Ct = et - ce); Ct + ce < Pt && !((re -= fe[Ct + ce]) <= 0); )
              Ct++, re <<= 1;
            if (Ft += 1 << Ct, C === 1 && 852 < Ft || C === 2 && 592 < Ft)
              return 1;
            F[b = Ot & U] = Et << 24 | Ct << 16 | N - E | 0;
          }
        }
        return Ot !== 0 && (F[N + Ot] = et - ce << 24 | 64 << 16 | 0), x.bits = Et, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(o, p, d) {
      p.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(o, p, d) {
      var u = o("../utils/common"), m = 0, _ = 1;
      function T(dt) {
        for (var Dt = dt.length; 0 <= --Dt; )
          dt[Dt] = 0;
      }
      var S = 0, C = 29, z = 256, B = z + 1 + C, I = 30, F = 19, E = 2 * B + 1, L = 15, x = 16, M = 7, R = 256, b = 16, U = 17, N = 18, j = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], J = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], $ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ct = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], It = new Array(2 * (B + 2));
      T(It);
      var et = new Array(2 * I);
      T(et);
      var yt = new Array(512);
      T(yt);
      var G = new Array(256);
      T(G);
      var Pt = new Array(C);
      T(Pt);
      var Et, Ct, ce, re = new Array(I);
      function Ft(dt, Dt, ie, Kt, D) {
        this.static_tree = dt, this.extra_bits = Dt, this.extra_base = ie, this.elems = Kt, this.max_length = D, this.has_stree = dt && dt.length;
      }
      function Ot(dt, Dt) {
        this.dyn_tree = dt, this.max_code = 0, this.stat_desc = Dt;
      }
      function Bt(dt) {
        return dt < 256 ? yt[dt] : yt[256 + (dt >>> 7)];
      }
      function ke(dt, Dt) {
        dt.pending_buf[dt.pending++] = 255 & Dt, dt.pending_buf[dt.pending++] = Dt >>> 8 & 255;
      }
      function fe(dt, Dt, ie) {
        dt.bi_valid > x - ie ? (dt.bi_buf |= Dt << dt.bi_valid & 65535, ke(dt, dt.bi_buf), dt.bi_buf = Dt >> x - dt.bi_valid, dt.bi_valid += ie - x) : (dt.bi_buf |= Dt << dt.bi_valid & 65535, dt.bi_valid += ie);
      }
      function Yt(dt, Dt, ie) {
        fe(dt, ie[2 * Dt], ie[2 * Dt + 1]);
      }
      function ti(dt, Dt) {
        for (var ie = 0; ie |= 1 & dt, dt >>>= 1, ie <<= 1, 0 < --Dt; )
          ;
        return ie >>> 1;
      }
      function Ni(dt, Dt, ie) {
        var Kt, D, Q = new Array(L + 1), ot = 0;
        for (Kt = 1; Kt <= L; Kt++)
          Q[Kt] = ot = ot + ie[Kt - 1] << 1;
        for (D = 0; D <= Dt; D++) {
          var nt = dt[2 * D + 1];
          nt !== 0 && (dt[2 * D] = ti(Q[nt]++, nt));
        }
      }
      function Oe(dt) {
        var Dt;
        for (Dt = 0; Dt < B; Dt++)
          dt.dyn_ltree[2 * Dt] = 0;
        for (Dt = 0; Dt < I; Dt++)
          dt.dyn_dtree[2 * Dt] = 0;
        for (Dt = 0; Dt < F; Dt++)
          dt.bl_tree[2 * Dt] = 0;
        dt.dyn_ltree[2 * R] = 1, dt.opt_len = dt.static_len = 0, dt.last_lit = dt.matches = 0;
      }
      function Ge(dt) {
        8 < dt.bi_valid ? ke(dt, dt.bi_buf) : 0 < dt.bi_valid && (dt.pending_buf[dt.pending++] = dt.bi_buf), dt.bi_buf = 0, dt.bi_valid = 0;
      }
      function pi(dt, Dt, ie, Kt) {
        var D = 2 * Dt, Q = 2 * ie;
        return dt[D] < dt[Q] || dt[D] === dt[Q] && Kt[Dt] <= Kt[ie];
      }
      function Li(dt, Dt, ie) {
        for (var Kt = dt.heap[ie], D = ie << 1; D <= dt.heap_len && (D < dt.heap_len && pi(Dt, dt.heap[D + 1], dt.heap[D], dt.depth) && D++, !pi(Dt, Kt, dt.heap[D], dt.depth)); )
          dt.heap[ie] = dt.heap[D], ie = D, D <<= 1;
        dt.heap[ie] = Kt;
      }
      function cn(dt, Dt, ie) {
        var Kt, D, Q, ot, nt = 0;
        if (dt.last_lit !== 0)
          for (; Kt = dt.pending_buf[dt.d_buf + 2 * nt] << 8 | dt.pending_buf[dt.d_buf + 2 * nt + 1], D = dt.pending_buf[dt.l_buf + nt], nt++, Kt === 0 ? Yt(dt, D, Dt) : (Yt(dt, (Q = G[D]) + z + 1, Dt), (ot = j[Q]) !== 0 && fe(dt, D -= Pt[Q], ot), Yt(dt, Q = Bt(--Kt), ie), (ot = J[Q]) !== 0 && fe(dt, Kt -= re[Q], ot)), nt < dt.last_lit; )
            ;
        Yt(dt, R, Dt);
      }
      function Ji(dt, Dt) {
        var ie, Kt, D, Q = Dt.dyn_tree, ot = Dt.stat_desc.static_tree, nt = Dt.stat_desc.has_stree, vt = Dt.stat_desc.elems, Gt = -1;
        for (dt.heap_len = 0, dt.heap_max = E, ie = 0; ie < vt; ie++)
          Q[2 * ie] !== 0 ? (dt.heap[++dt.heap_len] = Gt = ie, dt.depth[ie] = 0) : Q[2 * ie + 1] = 0;
        for (; dt.heap_len < 2; )
          Q[2 * (D = dt.heap[++dt.heap_len] = Gt < 2 ? ++Gt : 0)] = 1, dt.depth[D] = 0, dt.opt_len--, nt && (dt.static_len -= ot[2 * D + 1]);
        for (Dt.max_code = Gt, ie = dt.heap_len >> 1; 1 <= ie; ie--)
          Li(dt, Q, ie);
        for (D = vt; ie = dt.heap[1], dt.heap[1] = dt.heap[dt.heap_len--], Li(dt, Q, 1), Kt = dt.heap[1], dt.heap[--dt.heap_max] = ie, dt.heap[--dt.heap_max] = Kt, Q[2 * D] = Q[2 * ie] + Q[2 * Kt], dt.depth[D] = (dt.depth[ie] >= dt.depth[Kt] ? dt.depth[ie] : dt.depth[Kt]) + 1, Q[2 * ie + 1] = Q[2 * Kt + 1] = D, dt.heap[1] = D++, Li(dt, Q, 1), 2 <= dt.heap_len; )
          ;
        dt.heap[--dt.heap_max] = dt.heap[1], function(Xt, jt) {
          var Ne, Re, ge, we, vi, Mi, ni = jt.dyn_tree, Si = jt.max_code, Gr = jt.stat_desc.static_tree, er = jt.stat_desc.has_stree, rn = jt.stat_desc.extra_bits, bs = jt.stat_desc.extra_base, Ri = jt.stat_desc.max_length, Us = 0;
          for (we = 0; we <= L; we++)
            Xt.bl_count[we] = 0;
          for (ni[2 * Xt.heap[Xt.heap_max] + 1] = 0, Ne = Xt.heap_max + 1; Ne < E; Ne++)
            Ri < (we = ni[2 * ni[2 * (Re = Xt.heap[Ne]) + 1] + 1] + 1) && (we = Ri, Us++), ni[2 * Re + 1] = we, Si < Re || (Xt.bl_count[we]++, vi = 0, bs <= Re && (vi = rn[Re - bs]), Mi = ni[2 * Re], Xt.opt_len += Mi * (we + vi), er && (Xt.static_len += Mi * (Gr[2 * Re + 1] + vi)));
          if (Us !== 0) {
            do {
              for (we = Ri - 1; Xt.bl_count[we] === 0; )
                we--;
              Xt.bl_count[we]--, Xt.bl_count[we + 1] += 2, Xt.bl_count[Ri]--, Us -= 2;
            } while (0 < Us);
            for (we = Ri; we !== 0; we--)
              for (Re = Xt.bl_count[we]; Re !== 0; )
                Si < (ge = Xt.heap[--Ne]) || (ni[2 * ge + 1] !== we && (Xt.opt_len += (we - ni[2 * ge + 1]) * ni[2 * ge], ni[2 * ge + 1] = we), Re--);
          }
        }(dt, Dt), Ni(Q, Gt, dt.bl_count);
      }
      function W(dt, Dt, ie) {
        var Kt, D, Q = -1, ot = Dt[1], nt = 0, vt = 7, Gt = 4;
        for (ot === 0 && (vt = 138, Gt = 3), Dt[2 * (ie + 1) + 1] = 65535, Kt = 0; Kt <= ie; Kt++)
          D = ot, ot = Dt[2 * (Kt + 1) + 1], ++nt < vt && D === ot || (nt < Gt ? dt.bl_tree[2 * D] += nt : D !== 0 ? (D !== Q && dt.bl_tree[2 * D]++, dt.bl_tree[2 * b]++) : nt <= 10 ? dt.bl_tree[2 * U]++ : dt.bl_tree[2 * N]++, Q = D, Gt = (nt = 0) === ot ? (vt = 138, 3) : D === ot ? (vt = 6, 3) : (vt = 7, 4));
      }
      function Jt(dt, Dt, ie) {
        var Kt, D, Q = -1, ot = Dt[1], nt = 0, vt = 7, Gt = 4;
        for (ot === 0 && (vt = 138, Gt = 3), Kt = 0; Kt <= ie; Kt++)
          if (D = ot, ot = Dt[2 * (Kt + 1) + 1], !(++nt < vt && D === ot)) {
            if (nt < Gt)
              for (; Yt(dt, D, dt.bl_tree), --nt != 0; )
                ;
            else
              D !== 0 ? (D !== Q && (Yt(dt, D, dt.bl_tree), nt--), Yt(dt, b, dt.bl_tree), fe(dt, nt - 3, 2)) : nt <= 10 ? (Yt(dt, U, dt.bl_tree), fe(dt, nt - 3, 3)) : (Yt(dt, N, dt.bl_tree), fe(dt, nt - 11, 7));
            Q = D, Gt = (nt = 0) === ot ? (vt = 138, 3) : D === ot ? (vt = 6, 3) : (vt = 7, 4);
          }
      }
      T(re);
      var Wt = !1;
      function pt(dt, Dt, ie, Kt) {
        fe(dt, (S << 1) + (Kt ? 1 : 0), 3), function(D, Q, ot, nt) {
          Ge(D), nt && (ke(D, ot), ke(D, ~ot)), u.arraySet(D.pending_buf, D.window, Q, ot, D.pending), D.pending += ot;
        }(dt, Dt, ie, !0);
      }
      d._tr_init = function(dt) {
        Wt || (function() {
          var Dt, ie, Kt, D, Q, ot = new Array(L + 1);
          for (D = Kt = 0; D < C - 1; D++)
            for (Pt[D] = Kt, Dt = 0; Dt < 1 << j[D]; Dt++)
              G[Kt++] = D;
          for (G[Kt - 1] = D, D = Q = 0; D < 16; D++)
            for (re[D] = Q, Dt = 0; Dt < 1 << J[D]; Dt++)
              yt[Q++] = D;
          for (Q >>= 7; D < I; D++)
            for (re[D] = Q << 7, Dt = 0; Dt < 1 << J[D] - 7; Dt++)
              yt[256 + Q++] = D;
          for (ie = 0; ie <= L; ie++)
            ot[ie] = 0;
          for (Dt = 0; Dt <= 143; )
            It[2 * Dt + 1] = 8, Dt++, ot[8]++;
          for (; Dt <= 255; )
            It[2 * Dt + 1] = 9, Dt++, ot[9]++;
          for (; Dt <= 279; )
            It[2 * Dt + 1] = 7, Dt++, ot[7]++;
          for (; Dt <= 287; )
            It[2 * Dt + 1] = 8, Dt++, ot[8]++;
          for (Ni(It, B + 1, ot), Dt = 0; Dt < I; Dt++)
            et[2 * Dt + 1] = 5, et[2 * Dt] = ti(Dt, 5);
          Et = new Ft(It, j, z + 1, B, L), Ct = new Ft(et, J, 0, I, L), ce = new Ft(new Array(0), $, 0, F, M);
        }(), Wt = !0), dt.l_desc = new Ot(dt.dyn_ltree, Et), dt.d_desc = new Ot(dt.dyn_dtree, Ct), dt.bl_desc = new Ot(dt.bl_tree, ce), dt.bi_buf = 0, dt.bi_valid = 0, Oe(dt);
      }, d._tr_stored_block = pt, d._tr_flush_block = function(dt, Dt, ie, Kt) {
        var D, Q, ot = 0;
        0 < dt.level ? (dt.strm.data_type === 2 && (dt.strm.data_type = function(nt) {
          var vt, Gt = 4093624447;
          for (vt = 0; vt <= 31; vt++, Gt >>>= 1)
            if (1 & Gt && nt.dyn_ltree[2 * vt] !== 0)
              return m;
          if (nt.dyn_ltree[18] !== 0 || nt.dyn_ltree[20] !== 0 || nt.dyn_ltree[26] !== 0)
            return _;
          for (vt = 32; vt < z; vt++)
            if (nt.dyn_ltree[2 * vt] !== 0)
              return _;
          return m;
        }(dt)), Ji(dt, dt.l_desc), Ji(dt, dt.d_desc), ot = function(nt) {
          var vt;
          for (W(nt, nt.dyn_ltree, nt.l_desc.max_code), W(nt, nt.dyn_dtree, nt.d_desc.max_code), Ji(nt, nt.bl_desc), vt = F - 1; 3 <= vt && nt.bl_tree[2 * ct[vt] + 1] === 0; vt--)
            ;
          return nt.opt_len += 3 * (vt + 1) + 5 + 5 + 4, vt;
        }(dt), D = dt.opt_len + 3 + 7 >>> 3, (Q = dt.static_len + 3 + 7 >>> 3) <= D && (D = Q)) : D = Q = ie + 5, ie + 4 <= D && Dt !== -1 ? pt(dt, Dt, ie, Kt) : dt.strategy === 4 || Q === D ? (fe(dt, 2 + (Kt ? 1 : 0), 3), cn(dt, It, et)) : (fe(dt, 4 + (Kt ? 1 : 0), 3), function(nt, vt, Gt, Xt) {
          var jt;
          for (fe(nt, vt - 257, 5), fe(nt, Gt - 1, 5), fe(nt, Xt - 4, 4), jt = 0; jt < Xt; jt++)
            fe(nt, nt.bl_tree[2 * ct[jt] + 1], 3);
          Jt(nt, nt.dyn_ltree, vt - 1), Jt(nt, nt.dyn_dtree, Gt - 1);
        }(dt, dt.l_desc.max_code + 1, dt.d_desc.max_code + 1, ot + 1), cn(dt, dt.dyn_ltree, dt.dyn_dtree)), Oe(dt), Kt && Ge(dt);
      }, d._tr_tally = function(dt, Dt, ie) {
        return dt.pending_buf[dt.d_buf + 2 * dt.last_lit] = Dt >>> 8 & 255, dt.pending_buf[dt.d_buf + 2 * dt.last_lit + 1] = 255 & Dt, dt.pending_buf[dt.l_buf + dt.last_lit] = 255 & ie, dt.last_lit++, Dt === 0 ? dt.dyn_ltree[2 * ie]++ : (dt.matches++, Dt--, dt.dyn_ltree[2 * (G[ie] + z + 1)]++, dt.dyn_dtree[2 * Bt(Dt)]++), dt.last_lit === dt.lit_bufsize - 1;
      }, d._tr_align = function(dt) {
        fe(dt, 2, 3), Yt(dt, R, It), function(Dt) {
          Dt.bi_valid === 16 ? (ke(Dt, Dt.bi_buf), Dt.bi_buf = 0, Dt.bi_valid = 0) : 8 <= Dt.bi_valid && (Dt.pending_buf[Dt.pending++] = 255 & Dt.bi_buf, Dt.bi_buf >>= 8, Dt.bi_valid -= 8);
        }(dt);
      };
    }, { "../utils/common": 41 }], 53: [function(o, p, d) {
      p.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(o, p, d) {
      (function(u) {
        (function(m, _) {
          if (!m.setImmediate) {
            var T, S, C, z, B = 1, I = {}, F = !1, E = m.document, L = Object.getPrototypeOf && Object.getPrototypeOf(m);
            L = L && L.setTimeout ? L : m, T = {}.toString.call(m.process) === "[object process]" ? function(b) {
              process.nextTick(function() {
                M(b);
              });
            } : function() {
              if (m.postMessage && !m.importScripts) {
                var b = !0, U = m.onmessage;
                return m.onmessage = function() {
                  b = !1;
                }, m.postMessage("", "*"), m.onmessage = U, b;
              }
            }() ? (z = "setImmediate$" + Math.random() + "$", m.addEventListener ? m.addEventListener("message", R, !1) : m.attachEvent("onmessage", R), function(b) {
              m.postMessage(z + b, "*");
            }) : m.MessageChannel ? ((C = new MessageChannel()).port1.onmessage = function(b) {
              M(b.data);
            }, function(b) {
              C.port2.postMessage(b);
            }) : E && "onreadystatechange" in E.createElement("script") ? (S = E.documentElement, function(b) {
              var U = E.createElement("script");
              U.onreadystatechange = function() {
                M(b), U.onreadystatechange = null, S.removeChild(U), U = null;
              }, S.appendChild(U);
            }) : function(b) {
              setTimeout(M, 0, b);
            }, L.setImmediate = function(b) {
              typeof b != "function" && (b = new Function("" + b));
              for (var U = new Array(arguments.length - 1), N = 0; N < U.length; N++)
                U[N] = arguments[N + 1];
              var j = { callback: b, args: U };
              return I[B] = j, T(B), B++;
            }, L.clearImmediate = x;
          }
          function x(b) {
            delete I[b];
          }
          function M(b) {
            if (F)
              setTimeout(M, 0, b);
            else {
              var U = I[b];
              if (U) {
                F = !0;
                try {
                  (function(N) {
                    var j = N.callback, J = N.args;
                    switch (J.length) {
                      case 0:
                        j();
                        break;
                      case 1:
                        j(J[0]);
                        break;
                      case 2:
                        j(J[0], J[1]);
                        break;
                      case 3:
                        j(J[0], J[1], J[2]);
                        break;
                      default:
                        j.apply(_, J);
                    }
                  })(U);
                } finally {
                  x(b), F = !1;
                }
              }
            }
          }
          function R(b) {
            b.source === m && typeof b.data == "string" && b.data.indexOf(z) === 0 && M(+b.data.slice(z.length));
          }
        })(typeof self > "u" ? u === void 0 ? this : u : self);
      }).call(this, typeof zr < "u" ? zr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(kp);
var W_ = kp.exports;
const j_ = /* @__PURE__ */ nf(W_);
var Bp = { exports: {} };
(function(w, l) {
  (function(o, p) {
    p();
  })(zr, function() {
    function o(S, C) {
      return typeof C > "u" ? C = { autoBom: !1 } : typeof C != "object" && (console.warn("Deprecated: Expected third argument to be a object"), C = { autoBom: !C }), C.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(S.type) ? new Blob(["\uFEFF", S], { type: S.type }) : S;
    }
    function p(S, C, z) {
      var B = new XMLHttpRequest();
      B.open("GET", S), B.responseType = "blob", B.onload = function() {
        T(B.response, C, z);
      }, B.onerror = function() {
        console.error("could not download file");
      }, B.send();
    }
    function d(S) {
      var C = new XMLHttpRequest();
      C.open("HEAD", S, !1);
      try {
        C.send();
      } catch {
      }
      return 200 <= C.status && 299 >= C.status;
    }
    function u(S) {
      try {
        S.dispatchEvent(new MouseEvent("click"));
      } catch {
        var C = document.createEvent("MouseEvents");
        C.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), S.dispatchEvent(C);
      }
    }
    var m = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof zr == "object" && zr.global === zr ? zr : void 0, _ = m.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), T = m.saveAs || (typeof window != "object" || window !== m ? function() {
    } : "download" in HTMLAnchorElement.prototype && !_ ? function(S, C, z) {
      var B = m.URL || m.webkitURL, I = document.createElement("a");
      C = C || S.name || "download", I.download = C, I.rel = "noopener", typeof S == "string" ? (I.href = S, I.origin === location.origin ? u(I) : d(I.href) ? p(S, C, z) : u(I, I.target = "_blank")) : (I.href = B.createObjectURL(S), setTimeout(function() {
        B.revokeObjectURL(I.href);
      }, 4e4), setTimeout(function() {
        u(I);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(S, C, z) {
      if (C = C || S.name || "download", typeof S != "string")
        navigator.msSaveOrOpenBlob(o(S, z), C);
      else if (d(S))
        p(S, C, z);
      else {
        var B = document.createElement("a");
        B.href = S, B.target = "_blank", setTimeout(function() {
          u(B);
        });
      }
    } : function(S, C, z, B) {
      if (B = B || open("", "_blank"), B && (B.document.title = B.document.body.innerText = "downloading..."), typeof S == "string")
        return p(S, C, z);
      var I = S.type === "application/octet-stream", F = /constructor/i.test(m.HTMLElement) || m.safari, E = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((E || I && F || _) && typeof FileReader < "u") {
        var L = new FileReader();
        L.onloadend = function() {
          var R = L.result;
          R = E ? R : R.replace(/^data:[^;]*;/, "data:attachment/file;"), B ? B.location.href = R : location = R, B = null;
        }, L.readAsDataURL(S);
      } else {
        var x = m.URL || m.webkitURL, M = x.createObjectURL(S);
        B ? B.location = M : location.href = M, B = null, setTimeout(function() {
          x.revokeObjectURL(M);
        }, 4e4);
      }
    });
    m.saveAs = T.saveAs = T, w.exports = T;
  });
})(Bp);
var X_ = Bp.exports;
const q_ = /* @__PURE__ */ nf(X_);
class v1 {
  constructor(l, o) {
    window.mars3d ? (this.map = l, this.panoramicViewClass = o, this.coordinate = [
      {
        heading: 0,
        pitch: 0,
        stop: 5
      },
      {
        heading: 90,
        pitch: 0,
        stop: 5
      },
      {
        heading: 180,
        pitch: 0,
        stop: 5
      },
      {
        heading: 270,
        pitch: 0,
        stop: 5
      },
      {
        heading: 0,
        pitch: 90,
        stop: 5
      },
      {
        heading: 0,
        pitch: -90,
        stop: 5
      }
    ], this.screenshotArray = [], this.events = {}, this.timestamp = 0, this.lat, this.lng, this.alt) : console.error("未引入指定插件");
  }
  /**
   * 开启全景图下载
   * @returns { any }
   */
  start(l = !0) {
    var o, p;
    if (l) {
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
      const d = document.getElementById("app"), u = window.innerHeight, m = document.getElementById("mars3dContainer");
      m && (m.style.width = u.toString() + "px", m.style.height = u.toString() + "px"), d !== null && d.classList.add(this.panoramicViewClass);
      let { lat: _, lng: T, alt: S } = this.map.getCameraView();
      this.lat = _, this.lng = T, this.alt = S, this.map.viewer.scene.camera.frustum.fov = window.Cesium.Math.PI_OVER_THREE * 1.5;
    }
    this.screenshotArray && this.coordinate ? this.coordinate[(o = this.screenshotArray) == null ? void 0 : o.length] ? this.map.setCameraView(
      {
        lat: this.lat,
        lng: this.lng,
        alt: this.alt,
        ...this.coordinate[(p = this.screenshotArray) == null ? void 0 : p.length]
      },
      {
        complete: () => {
          setTimeout(() => {
            var d;
            this.screenshot((d = this.screenshotArray) == null ? void 0 : d.length);
          }, 100);
        }
      }
    ) : (this.downloadImagesAsZip(), this.screenshotArray = []) : (console.error("初始化失效"), this.emit("state", {
      type: "error"
    }));
  }
  /**
   * 截图
   * @returns { any }
   */
  async screenshot(l) {
    const o = await this.map.expImage({ download: !1 }), p = this.map.container.getElementsByClassName(
      "cesium-viewer-cesiumWidgetContainer"
    ), d = await window.domtoimage.toPng(this.map.container, {
      filter: (u) => u !== p[0]
    });
    this.mergeImage(o.image, d, o.width, o.height).then(
      (u) => {
        var T;
        let m = Number(l) + 1, _ = {
          src: u,
          name: "全景图_" + this.timestamp + "_" + m + ".jpg"
        };
        this.emit("intercept", _), (T = this.screenshotArray) == null || T.push(_), this.start(!1);
      }
    );
  }
  /**
   * 合成图片
   * @param {any} width
   * @param {any} height
   * @returns {any}
   */
  mergeImage(l, o, p, d) {
    return new Promise((u, m) => {
      const _ = document.createElement("canvas");
      _.width = p, _.height = d;
      const T = _.getContext("2d");
      if (_ && T) {
        const S = new Image();
        S.crossOrigin = "Anonymous", S.onload = () => {
          T.drawImage(S, 0, 0, p, d);
          const C = new Image();
          C.crossOrigin = "Anonymous", C.onload = () => {
            T.drawImage(C, 0, 0, p, d);
            const z = _.toDataURL("image/png");
            u(z);
          }, C.src = o;
        }, S.src = l;
      } else
        m();
    });
  }
  /**
   * 下载图片
   * @returns {any}
   */
  download() {
    this.screenshotArray && this.screenshotArray.forEach((l) => {
      window.mars3d.Util.downloadBase64Image(l.name, l.src);
    });
  }
  /**
   * 下载压缩包
   * @returns
   */
  async downloadImagesAsZip() {
    if (this.screenshotArray) {
      const l = new j_();
      this.screenshotArray.forEach((p) => {
        const d = p.src.split(",")[1], u = atob(d), m = [];
        for (let S = 0; S < u.length; S += 1024) {
          const C = u.slice(S, S + 1024), z = new Array(C.length);
          for (let I = 0; I < C.length; I++)
            z[I] = C.charCodeAt(I);
          const B = new Uint8Array(z);
          m.push(B);
        }
        const _ = new Blob(m, { type: "image/jpeg" }), T = `${p.name}`;
        l.file(T, _, { binary: !0 });
      });
      const o = await l.generateAsync({ type: "blob" });
      q_(o, "CHBIM-Panorama.zip"), this.emit("state", {
        type: "success",
        schedule: 100
      }), this.init();
    }
  }
  /**
   * 初始化
   */
  init() {
    const l = document.getElementById("app");
    l && l.classList.remove(this.panoramicViewClass);
    const o = document.getElementById("mars3dContainer");
    o && (o.style.width = "", o.style.height = "");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { Function } fn - 回调函数
   * @returns { any }
   */
  on(l, o) {
    this.events[l] ? this.events[l].push(o) : this.events[l] = [o];
  }
  /**
   * events
   * 事件触发
   * @param  { string } event - 事件名
   * @returns { any }
   */
  emit(l, ...o) {
    this.events[l] != null && this.events[l].forEach((p) => p(...o));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(l, o) {
    this.events[l] = this.events[l].filter(
      (p) => p !== o
    );
  }
}
function Ho(w) {
  if (w === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return w;
}
function Np(w, l) {
  w.prototype = Object.create(l.prototype), w.prototype.constructor = w, w.__proto__ = l;
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var ts = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, oh = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, rf, fr, un, Ms = 1e8, nn = 1 / Ms, Nc = Math.PI * 2, Y_ = Nc / 4, Z_ = 0, Fp = Math.sqrt, J_ = Math.cos, $_ = Math.sin, Yn = function(l) {
  return typeof l == "string";
}, Cn = function(l) {
  return typeof l == "function";
}, Wo = function(l) {
  return typeof l == "number";
}, sf = function(l) {
  return typeof l > "u";
}, lo = function(l) {
  return typeof l == "object";
}, kr = function(l) {
  return l !== !1;
}, of = function() {
  return typeof window < "u";
}, Ou = function(l) {
  return Cn(l) || Yn(l);
}, Up = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, pr = Array.isArray, Fc = /(?:-?\.?\d|\.)+/gi, Gp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, eh = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Ac = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Hp = /[+-]=-?[.\d]+/, Vp = /[^,'"\[\]\s]+/gi, K_ = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _n, ro, Uc, af, es = {}, Nu = {}, Wp, jp = function(l) {
  return (Nu = Ml(l, es)) && Ur;
}, lf = function(l, o) {
  return console.warn("Invalid property", l, "set to", o, "Missing plugin? gsap.registerPlugin()");
}, Xh = function(l, o) {
  return !o && console.warn(l);
}, Xp = function(l, o) {
  return l && (es[l] = o) && Nu && (Nu[l] = o) || es;
}, qh = function() {
  return 0;
}, Q_ = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, Iu = {
  suppressEvents: !0,
  kill: !1
}, ty = {
  suppressEvents: !0
}, hf = {}, Pa = [], Gc = {}, qp, $r = {}, Cc = {}, vp = 30, Du = [], uf = "", cf = function(l) {
  var o = l[0], p, d;
  if (lo(o) || Cn(o) || (l = [l]), !(p = (o._gsap || {}).harness)) {
    for (d = Du.length; d-- && !Du[d].targetTest(o); )
      ;
    p = Du[d];
  }
  for (d = l.length; d--; )
    l[d] && (l[d]._gsap || (l[d]._gsap = new vd(l[d], p))) || l.splice(d, 1);
  return l;
}, yl = function(l) {
  return l._gsap || cf(Ss(l))[0]._gsap;
}, Yp = function(l, o, p) {
  return (p = l[o]) && Cn(p) ? l[o]() : sf(p) && l.getAttribute && l.getAttribute(o) || p;
}, Br = function(l, o) {
  return (l = l.split(",")).forEach(o) || l;
}, In = function(l) {
  return Math.round(l * 1e5) / 1e5 || 0;
}, qn = function(l) {
  return Math.round(l * 1e7) / 1e7 || 0;
}, nh = function(l, o) {
  var p = o.charAt(0), d = parseFloat(o.substr(2));
  return l = parseFloat(l), p === "+" ? l + d : p === "-" ? l - d : p === "*" ? l * d : l / d;
}, ey = function(l, o) {
  for (var p = o.length, d = 0; l.indexOf(o[d]) < 0 && ++d < p; )
    ;
  return d < p;
}, Fu = function() {
  var l = Pa.length, o = Pa.slice(0), p, d;
  for (Gc = {}, Pa.length = 0, p = 0; p < l; p++)
    d = o[p], d && d._lazy && (d.render(d._lazy[0], d._lazy[1], !0)._lazy = 0);
}, Zp = function(l, o, p, d) {
  Pa.length && !fr && Fu(), l.render(o, p, d || fr && o < 0 && (l._initted || l._startAt)), Pa.length && !fr && Fu();
}, Jp = function(l) {
  var o = parseFloat(l);
  return (o || o === 0) && (l + "").match(Vp).length < 2 ? o : Yn(l) ? l.trim() : l;
}, $p = function(l) {
  return l;
}, Es = function(l, o) {
  for (var p in o)
    p in l || (l[p] = o[p]);
  return l;
}, iy = function(l) {
  return function(o, p) {
    for (var d in p)
      d in o || d === "duration" && l || d === "ease" || (o[d] = p[d]);
  };
}, Ml = function(l, o) {
  for (var p in o)
    l[p] = o[p];
  return l;
}, _p = function w(l, o) {
  for (var p in o)
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (l[p] = lo(o[p]) ? w(l[p] || (l[p] = {}), o[p]) : o[p]);
  return l;
}, Uu = function(l, o) {
  var p = {}, d;
  for (d in l)
    d in o || (p[d] = l[d]);
  return p;
}, Vh = function(l) {
  var o = l.parent || _n, p = l.keyframes ? iy(pr(l.keyframes)) : Es;
  if (kr(l.inherit))
    for (; o; )
      p(l, o.vars.defaults), o = o.parent || o._dp;
  return l;
}, ny = function(l, o) {
  for (var p = l.length, d = p === o.length; d && p-- && l[p] === o[p]; )
    ;
  return p < 0;
}, Kp = function(l, o, p, d, u) {
  p === void 0 && (p = "_first"), d === void 0 && (d = "_last");
  var m = l[d], _;
  if (u)
    for (_ = o[u]; m && m[u] > _; )
      m = m._prev;
  return m ? (o._next = m._next, m._next = o) : (o._next = l[p], l[p] = o), o._next ? o._next._prev = o : l[d] = o, o._prev = m, o.parent = o._dp = l, o;
}, qu = function(l, o, p, d) {
  p === void 0 && (p = "_first"), d === void 0 && (d = "_last");
  var u = o._prev, m = o._next;
  u ? u._next = m : l[p] === o && (l[p] = m), m ? m._prev = u : l[d] === o && (l[d] = u), o._next = o._prev = o.parent = null;
}, Ra = function(l, o) {
  l.parent && (!o || l.parent.autoRemoveChildren) && l.parent.remove && l.parent.remove(l), l._act = 0;
}, xl = function(l, o) {
  if (l && (!o || o._end > l._dur || o._start < 0))
    for (var p = l; p; )
      p._dirty = 1, p = p.parent;
  return l;
}, ry = function(l) {
  for (var o = l.parent; o && o.parent; )
    o._dirty = 1, o.totalDuration(), o = o.parent;
  return l;
}, Hc = function(l, o, p, d) {
  return l._startAt && (fr ? l._startAt.revert(Iu) : l.vars.immediateRender && !l.vars.autoRevert || l._startAt.render(o, !0, d));
}, sy = function w(l) {
  return !l || l._ts && w(l.parent);
}, yp = function(l) {
  return l._repeat ? ah(l._tTime, l = l.duration() + l._rDelay) * l : 0;
}, ah = function(l, o) {
  var p = Math.floor(l /= o);
  return l && p === l ? p - 1 : p;
}, Gu = function(l, o) {
  return (l - o._start) * o._ts + (o._ts >= 0 ? 0 : o._dirty ? o.totalDuration() : o._tDur);
}, Yu = function(l) {
  return l._end = qn(l._start + (l._tDur / Math.abs(l._ts || l._rts || nn) || 0));
}, Zu = function(l, o) {
  var p = l._dp;
  return p && p.smoothChildTiming && l._ts && (l._start = qn(p._time - (l._ts > 0 ? o / l._ts : ((l._dirty ? l.totalDuration() : l._tDur) - o) / -l._ts)), Yu(l), p._dirty || xl(p, l)), l;
}, Qp = function(l, o) {
  var p;
  if ((o._time || !o._dur && o._initted || o._start < l._time && (o._dur || !o.add)) && (p = Gu(l.rawTime(), o), (!o._dur || Qh(0, o.totalDuration(), p) - o._tTime > nn) && o.render(p, !0)), xl(l, o)._dp && l._initted && l._time >= l._dur && l._ts) {
    if (l._dur < l.duration())
      for (p = l; p._dp; )
        p.rawTime() >= 0 && p.totalTime(p._tTime), p = p._dp;
    l._zTime = -nn;
  }
}, so = function(l, o, p, d) {
  return o.parent && Ra(o), o._start = qn((Wo(p) ? p : p || l !== _n ? Ts(l, p, o) : l._time) + o._delay), o._end = qn(o._start + (o.totalDuration() / Math.abs(o.timeScale()) || 0)), Kp(l, o, "_first", "_last", l._sort ? "_start" : 0), Vc(o) || (l._recent = o), d || Qp(l, o), l._ts < 0 && Zu(l, l._tTime), l;
}, td = function(l, o) {
  return (es.ScrollTrigger || lf("scrollTrigger", o)) && es.ScrollTrigger.create(o, l);
}, ed = function(l, o, p, d, u) {
  if (pf(l, o, u), !l._initted)
    return 1;
  if (!p && l._pt && !fr && (l._dur && l.vars.lazy !== !1 || !l._dur && l.vars.lazy) && qp !== Kr.frame)
    return Pa.push(l), l._lazy = [u, d], 1;
}, oy = function w(l) {
  var o = l.parent;
  return o && o._ts && o._initted && !o._lock && (o.rawTime() < 0 || w(o));
}, Vc = function(l) {
  var o = l.data;
  return o === "isFromStart" || o === "isStart";
}, ay = function(l, o, p, d) {
  var u = l.ratio, m = o < 0 || !o && (!l._start && oy(l) && !(!l._initted && Vc(l)) || (l._ts < 0 || l._dp._ts < 0) && !Vc(l)) ? 0 : 1, _ = l._rDelay, T = 0, S, C, z;
  if (_ && l._repeat && (T = Qh(0, l._tDur, o), C = ah(T, _), l._yoyo && C & 1 && (m = 1 - m), C !== ah(l._tTime, _) && (u = 1 - m, l.vars.repeatRefresh && l._initted && l.invalidate())), m !== u || fr || d || l._zTime === nn || !o && l._zTime) {
    if (!l._initted && ed(l, o, d, p, T))
      return;
    for (z = l._zTime, l._zTime = o || (p ? nn : 0), p || (p = o && !z), l.ratio = m, l._from && (m = 1 - m), l._time = 0, l._tTime = T, S = l._pt; S; )
      S.r(m, S.d), S = S._next;
    o < 0 && Hc(l, o, p, !0), l._onUpdate && !p && Qr(l, "onUpdate"), T && l._repeat && !p && l.parent && Qr(l, "onRepeat"), (o >= l._tDur || o < 0) && l.ratio === m && (m && Ra(l, 1), !p && !fr && (Qr(l, m ? "onComplete" : "onReverseComplete", !0), l._prom && l._prom()));
  } else
    l._zTime || (l._zTime = o);
}, ly = function(l, o, p) {
  var d;
  if (p > o)
    for (d = l._first; d && d._start <= p; ) {
      if (d.data === "isPause" && d._start > o)
        return d;
      d = d._next;
    }
  else
    for (d = l._last; d && d._start >= p; ) {
      if (d.data === "isPause" && d._start < o)
        return d;
      d = d._prev;
    }
}, lh = function(l, o, p, d) {
  var u = l._repeat, m = qn(o) || 0, _ = l._tTime / l._tDur;
  return _ && !d && (l._time *= m / l._dur), l._dur = m, l._tDur = u ? u < 0 ? 1e10 : qn(m * (u + 1) + l._rDelay * u) : m, _ > 0 && !d && Zu(l, l._tTime = l._tDur * _), l.parent && Yu(l), p || xl(l.parent, l), l;
}, xp = function(l) {
  return l instanceof Tr ? xl(l) : lh(l, l._dur);
}, hy = {
  _start: 0,
  endTime: qh,
  totalDuration: qh
}, Ts = function w(l, o, p) {
  var d = l.labels, u = l._recent || hy, m = l.duration() >= Ms ? u.endTime(!1) : l._dur, _, T, S;
  return Yn(o) && (isNaN(o) || o in d) ? (T = o.charAt(0), S = o.substr(-1) === "%", _ = o.indexOf("="), T === "<" || T === ">" ? (_ >= 0 && (o = o.replace(/=/, "")), (T === "<" ? u._start : u.endTime(u._repeat >= 0)) + (parseFloat(o.substr(1)) || 0) * (S ? (_ < 0 ? u : p).totalDuration() / 100 : 1)) : _ < 0 ? (o in d || (d[o] = m), d[o]) : (T = parseFloat(o.charAt(_ - 1) + o.substr(_ + 1)), S && p && (T = T / 100 * (pr(p) ? p[0] : p).totalDuration()), _ > 1 ? w(l, o.substr(0, _ - 1), p) + T : m + T)) : o == null ? m : +o;
}, Wh = function(l, o, p) {
  var d = Wo(o[1]), u = (d ? 2 : 1) + (l < 2 ? 0 : 1), m = o[u], _, T;
  if (d && (m.duration = o[1]), m.parent = p, l) {
    for (_ = m, T = p; T && !("immediateRender" in _); )
      _ = T.vars.defaults || {}, T = kr(T.vars.inherit) && T.parent;
    m.immediateRender = kr(_.immediateRender), l < 2 ? m.runBackwards = 1 : m.startAt = o[u - 1];
  }
  return new kn(o[0], m, o[u + 1]);
}, Ia = function(l, o) {
  return l || l === 0 ? o(l) : o;
}, Qh = function(l, o, p) {
  return p < l ? l : p > o ? o : p;
}, cr = function(l, o) {
  return !Yn(l) || !(o = K_.exec(l)) ? "" : o[1];
}, uy = function(l, o, p) {
  return Ia(p, function(d) {
    return Qh(l, o, d);
  });
}, Wc = [].slice, id = function(l, o) {
  return l && lo(l) && "length" in l && (!o && !l.length || l.length - 1 in l && lo(l[0])) && !l.nodeType && l !== ro;
}, cy = function(l, o, p) {
  return p === void 0 && (p = []), l.forEach(function(d) {
    var u;
    return Yn(d) && !o || id(d, 1) ? (u = p).push.apply(u, Ss(d)) : p.push(d);
  }) || p;
}, Ss = function(l, o, p) {
  return un && !o && un.selector ? un.selector(l) : Yn(l) && !p && (Uc || !hh()) ? Wc.call((o || af).querySelectorAll(l), 0) : pr(l) ? cy(l, p) : id(l) ? Wc.call(l, 0) : l ? [l] : [];
}, jc = function(l) {
  return l = Ss(l)[0] || Xh("Invalid scope") || {}, function(o) {
    var p = l.current || l.nativeElement || l;
    return Ss(o, p.querySelectorAll ? p : p === l ? Xh("Invalid scope") || af.createElement("div") : l);
  };
}, nd = function(l) {
  return l.sort(function() {
    return 0.5 - Math.random();
  });
}, rd = function(l) {
  if (Cn(l))
    return l;
  var o = lo(l) ? l : {
    each: l
  }, p = wl(o.ease), d = o.from || 0, u = parseFloat(o.base) || 0, m = {}, _ = d > 0 && d < 1, T = isNaN(d) || _, S = o.axis, C = d, z = d;
  return Yn(d) ? C = z = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[d] || 0 : !_ && T && (C = d[0], z = d[1]), function(B, I, F) {
    var E = (F || o).length, L = m[E], x, M, R, b, U, N, j, J, $;
    if (!L) {
      if ($ = o.grid === "auto" ? 0 : (o.grid || [1, Ms])[1], !$) {
        for (j = -Ms; j < (j = F[$++].getBoundingClientRect().left) && $ < E; )
          ;
        $ < E && $--;
      }
      for (L = m[E] = [], x = T ? Math.min($, E) * C - 0.5 : d % $, M = $ === Ms ? 0 : T ? E * z / $ - 0.5 : d / $ | 0, j = 0, J = Ms, N = 0; N < E; N++)
        R = N % $ - x, b = M - (N / $ | 0), L[N] = U = S ? Math.abs(S === "y" ? b : R) : Fp(R * R + b * b), U > j && (j = U), U < J && (J = U);
      d === "random" && nd(L), L.max = j - J, L.min = J, L.v = E = (parseFloat(o.amount) || parseFloat(o.each) * ($ > E ? E - 1 : S ? S === "y" ? E / $ : $ : Math.max($, E / $)) || 0) * (d === "edges" ? -1 : 1), L.b = E < 0 ? u - E : u, L.u = cr(o.amount || o.each) || 0, p = p && E < 0 ? dd(p) : p;
    }
    return E = (L[B] - L.min) / L.max || 0, qn(L.b + (p ? p(E) : E) * L.v) + L.u;
  };
}, Xc = function(l) {
  var o = Math.pow(10, ((l + "").split(".")[1] || "").length);
  return function(p) {
    var d = qn(Math.round(parseFloat(p) / l) * l * o);
    return (d - d % 1) / o + (Wo(p) ? 0 : cr(p));
  };
}, sd = function(l, o) {
  var p = pr(l), d, u;
  return !p && lo(l) && (d = p = l.radius || Ms, l.values ? (l = Ss(l.values), (u = !Wo(l[0])) && (d *= d)) : l = Xc(l.increment)), Ia(o, p ? Cn(l) ? function(m) {
    return u = l(m), Math.abs(u - m) <= d ? u : m;
  } : function(m) {
    for (var _ = parseFloat(u ? m.x : m), T = parseFloat(u ? m.y : 0), S = Ms, C = 0, z = l.length, B, I; z--; )
      u ? (B = l[z].x - _, I = l[z].y - T, B = B * B + I * I) : B = Math.abs(l[z] - _), B < S && (S = B, C = z);
    return C = !d || S <= d ? l[C] : m, u || C === m || Wo(m) ? C : C + cr(m);
  } : Xc(l));
}, od = function(l, o, p, d) {
  return Ia(pr(l) ? !o : p === !0 ? !!(p = 0) : !d, function() {
    return pr(l) ? l[~~(Math.random() * l.length)] : (p = p || 1e-5) && (d = p < 1 ? Math.pow(10, (p + "").length - 2) : 1) && Math.floor(Math.round((l - p / 2 + Math.random() * (o - l + p * 0.99)) / p) * p * d) / d;
  });
}, fy = function() {
  for (var l = arguments.length, o = new Array(l), p = 0; p < l; p++)
    o[p] = arguments[p];
  return function(d) {
    return o.reduce(function(u, m) {
      return m(u);
    }, d);
  };
}, py = function(l, o) {
  return function(p) {
    return l(parseFloat(p)) + (o || cr(p));
  };
}, dy = function(l, o, p) {
  return ld(l, o, 0, 1, p);
}, ad = function(l, o, p) {
  return Ia(p, function(d) {
    return l[~~o(d)];
  });
}, my = function w(l, o, p) {
  var d = o - l;
  return pr(l) ? ad(l, w(0, l.length), o) : Ia(p, function(u) {
    return (d + (u - l) % d) % d + l;
  });
}, gy = function w(l, o, p) {
  var d = o - l, u = d * 2;
  return pr(l) ? ad(l, w(0, l.length - 1), o) : Ia(p, function(m) {
    return m = (u + (m - l) % u) % u || 0, l + (m > d ? u - m : m);
  });
}, Yh = function(l) {
  for (var o = 0, p = "", d, u, m, _; ~(d = l.indexOf("random(", o)); )
    m = l.indexOf(")", d), _ = l.charAt(d + 7) === "[", u = l.substr(d + 7, m - d - 7).match(_ ? Vp : Fc), p += l.substr(o, d - o) + od(_ ? u : +u[0], _ ? 0 : +u[1], +u[2] || 1e-5), o = m + 1;
  return p + l.substr(o, l.length - o);
}, ld = function(l, o, p, d, u) {
  var m = o - l, _ = d - p;
  return Ia(u, function(T) {
    return p + ((T - l) / m * _ || 0);
  });
}, vy = function w(l, o, p, d) {
  var u = isNaN(l + o) ? 0 : function(I) {
    return (1 - I) * l + I * o;
  };
  if (!u) {
    var m = Yn(l), _ = {}, T, S, C, z, B;
    if (p === !0 && (d = 1) && (p = null), m)
      l = {
        p: l
      }, o = {
        p: o
      };
    else if (pr(l) && !pr(o)) {
      for (C = [], z = l.length, B = z - 2, S = 1; S < z; S++)
        C.push(w(l[S - 1], l[S]));
      z--, u = function(F) {
        F *= z;
        var E = Math.min(B, ~~F);
        return C[E](F - E);
      }, p = o;
    } else
      d || (l = Ml(pr(l) ? [] : {}, l));
    if (!C) {
      for (T in o)
        ff.call(_, l, T, "get", o[T]);
      u = function(F) {
        return gf(F, _) || (m ? l.p : l);
      };
    }
  }
  return Ia(p, u);
}, wp = function(l, o, p) {
  var d = l.labels, u = Ms, m, _, T;
  for (m in d)
    _ = d[m] - o, _ < 0 == !!p && _ && u > (_ = Math.abs(_)) && (T = m, u = _);
  return T;
}, Qr = function(l, o, p) {
  var d = l.vars, u = d[o], m = un, _ = l._ctx, T, S, C;
  if (u)
    return T = d[o + "Params"], S = d.callbackScope || l, p && Pa.length && Fu(), _ && (un = _), C = T ? u.apply(S, T) : u.call(S), un = m, C;
}, Gh = function(l) {
  return Ra(l), l.scrollTrigger && l.scrollTrigger.kill(!!fr), l.progress() < 1 && Qr(l, "onInterrupt"), l;
}, ih, hd = [], ud = function(l) {
  if (l)
    if (l = !l.name && l.default || l, of() || l.headless) {
      var o = l.name, p = Cn(l), d = o && !p && l.init ? function() {
        this._props = [];
      } : l, u = {
        init: qh,
        render: gf,
        add: ff,
        kill: Iy,
        modifier: Oy,
        rawVars: 0
      }, m = {
        targetTest: 0,
        get: 0,
        getSetter: mf,
        aliases: {},
        register: 0
      };
      if (hh(), l !== d) {
        if ($r[o])
          return;
        Es(d, Es(Uu(l, u), m)), Ml(d.prototype, Ml(u, Uu(l, m))), $r[d.prop = o] = d, l.targetTest && (Du.push(d), hf[o] = 1), o = (o === "css" ? "CSS" : o.charAt(0).toUpperCase() + o.substr(1)) + "Plugin";
      }
      Xp(o, d), l.register && l.register(Ur, d, Nr);
    } else
      hd.push(l);
}, Ki = 255, Hh = {
  aqua: [0, Ki, Ki],
  lime: [0, Ki, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, Ki],
  navy: [0, 0, 128],
  white: [Ki, Ki, Ki],
  olive: [128, 128, 0],
  yellow: [Ki, Ki, 0],
  orange: [Ki, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [Ki, 0, 0],
  pink: [Ki, 192, 203],
  cyan: [0, Ki, Ki],
  transparent: [Ki, Ki, Ki, 0]
}, Pc = function(l, o, p) {
  return l += l < 0 ? 1 : l > 1 ? -1 : 0, (l * 6 < 1 ? o + (p - o) * l * 6 : l < 0.5 ? p : l * 3 < 2 ? o + (p - o) * (2 / 3 - l) * 6 : o) * Ki + 0.5 | 0;
}, cd = function(l, o, p) {
  var d = l ? Wo(l) ? [l >> 16, l >> 8 & Ki, l & Ki] : 0 : Hh.black, u, m, _, T, S, C, z, B, I, F;
  if (!d) {
    if (l.substr(-1) === "," && (l = l.substr(0, l.length - 1)), Hh[l])
      d = Hh[l];
    else if (l.charAt(0) === "#") {
      if (l.length < 6 && (u = l.charAt(1), m = l.charAt(2), _ = l.charAt(3), l = "#" + u + u + m + m + _ + _ + (l.length === 5 ? l.charAt(4) + l.charAt(4) : "")), l.length === 9)
        return d = parseInt(l.substr(1, 6), 16), [d >> 16, d >> 8 & Ki, d & Ki, parseInt(l.substr(7), 16) / 255];
      l = parseInt(l.substr(1), 16), d = [l >> 16, l >> 8 & Ki, l & Ki];
    } else if (l.substr(0, 3) === "hsl") {
      if (d = F = l.match(Fc), !o)
        T = +d[0] % 360 / 360, S = +d[1] / 100, C = +d[2] / 100, m = C <= 0.5 ? C * (S + 1) : C + S - C * S, u = C * 2 - m, d.length > 3 && (d[3] *= 1), d[0] = Pc(T + 1 / 3, u, m), d[1] = Pc(T, u, m), d[2] = Pc(T - 1 / 3, u, m);
      else if (~l.indexOf("="))
        return d = l.match(Gp), p && d.length < 4 && (d[3] = 1), d;
    } else
      d = l.match(Fc) || Hh.transparent;
    d = d.map(Number);
  }
  return o && !F && (u = d[0] / Ki, m = d[1] / Ki, _ = d[2] / Ki, z = Math.max(u, m, _), B = Math.min(u, m, _), C = (z + B) / 2, z === B ? T = S = 0 : (I = z - B, S = C > 0.5 ? I / (2 - z - B) : I / (z + B), T = z === u ? (m - _) / I + (m < _ ? 6 : 0) : z === m ? (_ - u) / I + 2 : (u - m) / I + 4, T *= 60), d[0] = ~~(T + 0.5), d[1] = ~~(S * 100 + 0.5), d[2] = ~~(C * 100 + 0.5)), p && d.length < 4 && (d[3] = 1), d;
}, fd = function(l) {
  var o = [], p = [], d = -1;
  return l.split(La).forEach(function(u) {
    var m = u.match(eh) || [];
    o.push.apply(o, m), p.push(d += m.length + 1);
  }), o.c = p, o;
}, Tp = function(l, o, p) {
  var d = "", u = (l + d).match(La), m = o ? "hsla(" : "rgba(", _ = 0, T, S, C, z;
  if (!u)
    return l;
  if (u = u.map(function(B) {
    return (B = cd(B, o, 1)) && m + (o ? B[0] + "," + B[1] + "%," + B[2] + "%," + B[3] : B.join(",")) + ")";
  }), p && (C = fd(l), T = p.c, T.join(d) !== C.c.join(d)))
    for (S = l.replace(La, "1").split(eh), z = S.length - 1; _ < z; _++)
      d += S[_] + (~T.indexOf(_) ? u.shift() || m + "0,0,0,0)" : (C.length ? C : u.length ? u : p).shift());
  if (!S)
    for (S = l.split(La), z = S.length - 1; _ < z; _++)
      d += S[_] + u[_];
  return d + S[z];
}, La = function() {
  var w = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", l;
  for (l in Hh)
    w += "|" + l + "\\b";
  return new RegExp(w + ")", "gi");
}(), _y = /hsl[a]?\(/, pd = function(l) {
  var o = l.join(" "), p;
  if (La.lastIndex = 0, La.test(o))
    return p = _y.test(o), l[1] = Tp(l[1], p), l[0] = Tp(l[0], p, fd(l[1])), !0;
}, Zh, Kr = function() {
  var w = Date.now, l = 500, o = 33, p = w(), d = p, u = 1e3 / 240, m = u, _ = [], T, S, C, z, B, I, F = function E(L) {
    var x = w() - d, M = L === !0, R, b, U, N;
    if ((x > l || x < 0) && (p += x - o), d += x, U = d - p, R = U - m, (R > 0 || M) && (N = ++z.frame, B = U - z.time * 1e3, z.time = U = U / 1e3, m += R + (R >= u ? 4 : u - R), b = 1), M || (T = S(E)), b)
      for (I = 0; I < _.length; I++)
        _[I](U, B, N, L);
  };
  return z = {
    time: 0,
    frame: 0,
    tick: function() {
      F(!0);
    },
    deltaRatio: function(L) {
      return B / (1e3 / (L || 60));
    },
    wake: function() {
      Wp && (!Uc && of() && (ro = Uc = window, af = ro.document || {}, es.gsap = Ur, (ro.gsapVersions || (ro.gsapVersions = [])).push(Ur.version), jp(Nu || ro.GreenSockGlobals || !ro.gsap && ro || {}), hd.forEach(ud)), C = typeof requestAnimationFrame < "u" && requestAnimationFrame, T && z.sleep(), S = C || function(L) {
        return setTimeout(L, m - z.time * 1e3 + 1 | 0);
      }, Zh = 1, F(2));
    },
    sleep: function() {
      (C ? cancelAnimationFrame : clearTimeout)(T), Zh = 0, S = qh;
    },
    lagSmoothing: function(L, x) {
      l = L || 1 / 0, o = Math.min(x || 33, l);
    },
    fps: function(L) {
      u = 1e3 / (L || 240), m = z.time * 1e3 + u;
    },
    add: function(L, x, M) {
      var R = x ? function(b, U, N, j) {
        L(b, U, N, j), z.remove(R);
      } : L;
      return z.remove(L), _[M ? "unshift" : "push"](R), hh(), R;
    },
    remove: function(L, x) {
      ~(x = _.indexOf(L)) && _.splice(x, 1) && I >= x && I--;
    },
    _listeners: _
  }, z;
}(), hh = function() {
  return !Zh && Kr.wake();
}, Bi = {}, yy = /^[\d.\-M][\d.\-,\s]/, xy = /["']/g, wy = function(l) {
  for (var o = {}, p = l.substr(1, l.length - 3).split(":"), d = p[0], u = 1, m = p.length, _, T, S; u < m; u++)
    T = p[u], _ = u !== m - 1 ? T.lastIndexOf(",") : T.length, S = T.substr(0, _), o[d] = isNaN(S) ? S.replace(xy, "").trim() : +S, d = T.substr(_ + 1).trim();
  return o;
}, Ty = function(l) {
  var o = l.indexOf("(") + 1, p = l.indexOf(")"), d = l.indexOf("(", o);
  return l.substring(o, ~d && d < p ? l.indexOf(")", p + 1) : p);
}, My = function(l) {
  var o = (l + "").split("("), p = Bi[o[0]];
  return p && o.length > 1 && p.config ? p.config.apply(null, ~l.indexOf("{") ? [wy(o[1])] : Ty(l).split(",").map(Jp)) : Bi._CE && yy.test(l) ? Bi._CE("", l) : p;
}, dd = function(l) {
  return function(o) {
    return 1 - l(1 - o);
  };
}, md = function w(l, o) {
  for (var p = l._first, d; p; )
    p instanceof Tr ? w(p, o) : p.vars.yoyoEase && (!p._yoyo || !p._repeat) && p._yoyo !== o && (p.timeline ? w(p.timeline, o) : (d = p._ease, p._ease = p._yEase, p._yEase = d, p._yoyo = o)), p = p._next;
}, wl = function(l, o) {
  return l && (Cn(l) ? l : Bi[l] || My(l)) || o;
}, El = function(l, o, p, d) {
  p === void 0 && (p = function(T) {
    return 1 - o(1 - T);
  }), d === void 0 && (d = function(T) {
    return T < 0.5 ? o(T * 2) / 2 : 1 - o((1 - T) * 2) / 2;
  });
  var u = {
    easeIn: o,
    easeOut: p,
    easeInOut: d
  }, m;
  return Br(l, function(_) {
    Bi[_] = es[_] = u, Bi[m = _.toLowerCase()] = p;
    for (var T in u)
      Bi[m + (T === "easeIn" ? ".in" : T === "easeOut" ? ".out" : ".inOut")] = Bi[_ + "." + T] = u[T];
  }), u;
}, gd = function(l) {
  return function(o) {
    return o < 0.5 ? (1 - l(1 - o * 2)) / 2 : 0.5 + l((o - 0.5) * 2) / 2;
  };
}, Lc = function w(l, o, p) {
  var d = o >= 1 ? o : 1, u = (p || (l ? 0.3 : 0.45)) / (o < 1 ? o : 1), m = u / Nc * (Math.asin(1 / d) || 0), _ = function(C) {
    return C === 1 ? 1 : d * Math.pow(2, -10 * C) * $_((C - m) * u) + 1;
  }, T = l === "out" ? _ : l === "in" ? function(S) {
    return 1 - _(1 - S);
  } : gd(_);
  return u = Nc / u, T.config = function(S, C) {
    return w(l, S, C);
  }, T;
}, Rc = function w(l, o) {
  o === void 0 && (o = 1.70158);
  var p = function(m) {
    return m ? --m * m * ((o + 1) * m + o) + 1 : 0;
  }, d = l === "out" ? p : l === "in" ? function(u) {
    return 1 - p(1 - u);
  } : gd(p);
  return d.config = function(u) {
    return w(l, u);
  }, d;
};
Br("Linear,Quad,Cubic,Quart,Quint,Strong", function(w, l) {
  var o = l < 5 ? l + 1 : l;
  El(w + ",Power" + (o - 1), l ? function(p) {
    return Math.pow(p, o);
  } : function(p) {
    return p;
  }, function(p) {
    return 1 - Math.pow(1 - p, o);
  }, function(p) {
    return p < 0.5 ? Math.pow(p * 2, o) / 2 : 1 - Math.pow((1 - p) * 2, o) / 2;
  });
});
Bi.Linear.easeNone = Bi.none = Bi.Linear.easeIn;
El("Elastic", Lc("in"), Lc("out"), Lc());
(function(w, l) {
  var o = 1 / l, p = 2 * o, d = 2.5 * o, u = function(_) {
    return _ < o ? w * _ * _ : _ < p ? w * Math.pow(_ - 1.5 / l, 2) + 0.75 : _ < d ? w * (_ -= 2.25 / l) * _ + 0.9375 : w * Math.pow(_ - 2.625 / l, 2) + 0.984375;
  };
  El("Bounce", function(m) {
    return 1 - u(1 - m);
  }, u);
})(7.5625, 2.75);
El("Expo", function(w) {
  return w ? Math.pow(2, 10 * (w - 1)) : 0;
});
El("Circ", function(w) {
  return -(Fp(1 - w * w) - 1);
});
El("Sine", function(w) {
  return w === 1 ? 1 : -J_(w * Y_) + 1;
});
El("Back", Rc("in"), Rc("out"), Rc());
Bi.SteppedEase = Bi.steps = es.SteppedEase = {
  config: function(l, o) {
    l === void 0 && (l = 1);
    var p = 1 / l, d = l + (o ? 0 : 1), u = o ? 1 : 0, m = 1 - nn;
    return function(_) {
      return ((d * Qh(0, m, _) | 0) + u) * p;
    };
  }
};
oh.ease = Bi["quad.out"];
Br("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(w) {
  return uf += w + "," + w + "Params,";
});
var vd = function(l, o) {
  this.id = Z_++, l._gsap = this, this.target = l, this.harness = o, this.get = o ? o.get : Yp, this.set = o ? o.getSetter : mf;
}, Jh = /* @__PURE__ */ function() {
  function w(o) {
    this.vars = o, this._delay = +o.delay || 0, (this._repeat = o.repeat === 1 / 0 ? -2 : o.repeat || 0) && (this._rDelay = o.repeatDelay || 0, this._yoyo = !!o.yoyo || !!o.yoyoEase), this._ts = 1, lh(this, +o.duration, 1, 1), this.data = o.data, un && (this._ctx = un, un.data.push(this)), Zh || Kr.wake();
  }
  var l = w.prototype;
  return l.delay = function(p) {
    return p || p === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + p - this._delay), this._delay = p, this) : this._delay;
  }, l.duration = function(p) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? p + (p + this._rDelay) * this._repeat : p) : this.totalDuration() && this._dur;
  }, l.totalDuration = function(p) {
    return arguments.length ? (this._dirty = 0, lh(this, this._repeat < 0 ? p : (p - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, l.totalTime = function(p, d) {
    if (hh(), !arguments.length)
      return this._tTime;
    var u = this._dp;
    if (u && u.smoothChildTiming && this._ts) {
      for (Zu(this, p), !u._dp || u.parent || Qp(u, this); u && u.parent; )
        u.parent._time !== u._start + (u._ts >= 0 ? u._tTime / u._ts : (u.totalDuration() - u._tTime) / -u._ts) && u.totalTime(u._tTime, !0), u = u.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && p < this._tDur || this._ts < 0 && p > 0 || !this._tDur && !p) && so(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== p || !this._dur && !d || this._initted && Math.abs(this._zTime) === nn || !p && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = p), Zp(this, p, d)), this;
  }, l.time = function(p, d) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), p + yp(this)) % (this._dur + this._rDelay) || (p ? this._dur : 0), d) : this._time;
  }, l.totalProgress = function(p, d) {
    return arguments.length ? this.totalTime(this.totalDuration() * p, d) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, l.progress = function(p, d) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - p : p) + yp(this), d) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, l.iteration = function(p, d) {
    var u = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (p - 1) * u, d) : this._repeat ? ah(this._tTime, u) + 1 : 1;
  }, l.timeScale = function(p, d) {
    if (!arguments.length)
      return this._rts === -nn ? 0 : this._rts;
    if (this._rts === p)
      return this;
    var u = this.parent && this._ts ? Gu(this.parent._time, this) : this._tTime;
    return this._rts = +p || 0, this._ts = this._ps || p === -nn ? 0 : this._rts, this.totalTime(Qh(-Math.abs(this._delay), this._tDur, u), d !== !1), Yu(this), ry(this);
  }, l.paused = function(p) {
    return arguments.length ? (this._ps !== p && (this._ps = p, p ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (hh(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== nn && (this._tTime -= nn)))), this) : this._ps;
  }, l.startTime = function(p) {
    if (arguments.length) {
      this._start = p;
      var d = this.parent || this._dp;
      return d && (d._sort || !this.parent) && so(d, this, p - this._delay), this;
    }
    return this._start;
  }, l.endTime = function(p) {
    return this._start + (kr(p) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, l.rawTime = function(p) {
    var d = this.parent || this._dp;
    return d ? p && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Gu(d.rawTime(p), this) : this._tTime : this._tTime;
  }, l.revert = function(p) {
    p === void 0 && (p = ty);
    var d = fr;
    return fr = p, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(p), this.totalTime(-0.01, p.suppressEvents)), this.data !== "nested" && p.kill !== !1 && this.kill(), fr = d, this;
  }, l.globalTime = function(p) {
    for (var d = this, u = arguments.length ? p : d.rawTime(); d; )
      u = d._start + u / (Math.abs(d._ts) || 1), d = d._dp;
    return !this.parent && this._sat ? this._sat.globalTime(p) : u;
  }, l.repeat = function(p) {
    return arguments.length ? (this._repeat = p === 1 / 0 ? -2 : p, xp(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, l.repeatDelay = function(p) {
    if (arguments.length) {
      var d = this._time;
      return this._rDelay = p, xp(this), d ? this.time(d) : this;
    }
    return this._rDelay;
  }, l.yoyo = function(p) {
    return arguments.length ? (this._yoyo = p, this) : this._yoyo;
  }, l.seek = function(p, d) {
    return this.totalTime(Ts(this, p), kr(d));
  }, l.restart = function(p, d) {
    return this.play().totalTime(p ? -this._delay : 0, kr(d));
  }, l.play = function(p, d) {
    return p != null && this.seek(p, d), this.reversed(!1).paused(!1);
  }, l.reverse = function(p, d) {
    return p != null && this.seek(p || this.totalDuration(), d), this.reversed(!0).paused(!1);
  }, l.pause = function(p, d) {
    return p != null && this.seek(p, d), this.paused(!0);
  }, l.resume = function() {
    return this.paused(!1);
  }, l.reversed = function(p) {
    return arguments.length ? (!!p !== this.reversed() && this.timeScale(-this._rts || (p ? -nn : 0)), this) : this._rts < 0;
  }, l.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -nn, this;
  }, l.isActive = function() {
    var p = this.parent || this._dp, d = this._start, u;
    return !!(!p || this._ts && this._initted && p.isActive() && (u = p.rawTime(!0)) >= d && u < this.endTime(!0) - nn);
  }, l.eventCallback = function(p, d, u) {
    var m = this.vars;
    return arguments.length > 1 ? (d ? (m[p] = d, u && (m[p + "Params"] = u), p === "onUpdate" && (this._onUpdate = d)) : delete m[p], this) : m[p];
  }, l.then = function(p) {
    var d = this;
    return new Promise(function(u) {
      var m = Cn(p) ? p : $p, _ = function() {
        var S = d.then;
        d.then = null, Cn(m) && (m = m(d)) && (m.then || m === d) && (d.then = S), u(m), d.then = S;
      };
      d._initted && d.totalProgress() === 1 && d._ts >= 0 || !d._tTime && d._ts < 0 ? _() : d._prom = _;
    });
  }, l.kill = function() {
    Gh(this);
  }, w;
}();
Es(Jh.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -nn,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Tr = /* @__PURE__ */ function(w) {
  Np(l, w);
  function l(p, d) {
    var u;
    return p === void 0 && (p = {}), u = w.call(this, p) || this, u.labels = {}, u.smoothChildTiming = !!p.smoothChildTiming, u.autoRemoveChildren = !!p.autoRemoveChildren, u._sort = kr(p.sortChildren), _n && so(p.parent || _n, Ho(u), d), p.reversed && u.reverse(), p.paused && u.paused(!0), p.scrollTrigger && td(Ho(u), p.scrollTrigger), u;
  }
  var o = l.prototype;
  return o.to = function(d, u, m) {
    return Wh(0, arguments, this), this;
  }, o.from = function(d, u, m) {
    return Wh(1, arguments, this), this;
  }, o.fromTo = function(d, u, m, _) {
    return Wh(2, arguments, this), this;
  }, o.set = function(d, u, m) {
    return u.duration = 0, u.parent = this, Vh(u).repeatDelay || (u.repeat = 0), u.immediateRender = !!u.immediateRender, new kn(d, u, Ts(this, m), 1), this;
  }, o.call = function(d, u, m) {
    return so(this, kn.delayedCall(0, d, u), m);
  }, o.staggerTo = function(d, u, m, _, T, S, C) {
    return m.duration = u, m.stagger = m.stagger || _, m.onComplete = S, m.onCompleteParams = C, m.parent = this, new kn(d, m, Ts(this, T)), this;
  }, o.staggerFrom = function(d, u, m, _, T, S, C) {
    return m.runBackwards = 1, Vh(m).immediateRender = kr(m.immediateRender), this.staggerTo(d, u, m, _, T, S, C);
  }, o.staggerFromTo = function(d, u, m, _, T, S, C, z) {
    return _.startAt = m, Vh(_).immediateRender = kr(_.immediateRender), this.staggerTo(d, u, _, T, S, C, z);
  }, o.render = function(d, u, m) {
    var _ = this._time, T = this._dirty ? this.totalDuration() : this._tDur, S = this._dur, C = d <= 0 ? 0 : qn(d), z = this._zTime < 0 != d < 0 && (this._initted || !S), B, I, F, E, L, x, M, R, b, U, N, j;
    if (this !== _n && C > T && d >= 0 && (C = T), C !== this._tTime || m || z) {
      if (_ !== this._time && S && (C += this._time - _, d += this._time - _), B = C, b = this._start, R = this._ts, x = !R, z && (S || (_ = this._zTime), (d || !u) && (this._zTime = d)), this._repeat) {
        if (N = this._yoyo, L = S + this._rDelay, this._repeat < -1 && d < 0)
          return this.totalTime(L * 100 + d, u, m);
        if (B = qn(C % L), C === T ? (E = this._repeat, B = S) : (E = ~~(C / L), E && E === C / L && (B = S, E--), B > S && (B = S)), U = ah(this._tTime, L), !_ && this._tTime && U !== E && this._tTime - U * L - this._dur <= 0 && (U = E), N && E & 1 && (B = S - B, j = 1), E !== U && !this._lock) {
          var J = N && U & 1, $ = J === (N && E & 1);
          if (E < U && (J = !J), _ = J ? 0 : C % S ? S : C, this._lock = 1, this.render(_ || (j ? 0 : qn(E * L)), u, !S)._lock = 0, this._tTime = C, !u && this.parent && Qr(this, "onRepeat"), this.vars.repeatRefresh && !j && (this.invalidate()._lock = 1), _ && _ !== this._time || x !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (S = this._dur, T = this._tDur, $ && (this._lock = 2, _ = J ? S : -1e-4, this.render(_, !0), this.vars.repeatRefresh && !j && this.invalidate()), this._lock = 0, !this._ts && !x)
            return this;
          md(this, j);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (M = ly(this, qn(_), qn(B)), M && (C -= B - (B = M._start))), this._tTime = C, this._time = B, this._act = !R, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = d, _ = 0), !_ && B && !u && !E && (Qr(this, "onStart"), this._tTime !== C))
        return this;
      if (B >= _ && d >= 0)
        for (I = this._first; I; ) {
          if (F = I._next, (I._act || B >= I._start) && I._ts && M !== I) {
            if (I.parent !== this)
              return this.render(d, u, m);
            if (I.render(I._ts > 0 ? (B - I._start) * I._ts : (I._dirty ? I.totalDuration() : I._tDur) + (B - I._start) * I._ts, u, m), B !== this._time || !this._ts && !x) {
              M = 0, F && (C += this._zTime = -nn);
              break;
            }
          }
          I = F;
        }
      else {
        I = this._last;
        for (var ct = d < 0 ? d : B; I; ) {
          if (F = I._prev, (I._act || ct <= I._end) && I._ts && M !== I) {
            if (I.parent !== this)
              return this.render(d, u, m);
            if (I.render(I._ts > 0 ? (ct - I._start) * I._ts : (I._dirty ? I.totalDuration() : I._tDur) + (ct - I._start) * I._ts, u, m || fr && (I._initted || I._startAt)), B !== this._time || !this._ts && !x) {
              M = 0, F && (C += this._zTime = ct ? -nn : nn);
              break;
            }
          }
          I = F;
        }
      }
      if (M && !u && (this.pause(), M.render(B >= _ ? 0 : -nn)._zTime = B >= _ ? 1 : -1, this._ts))
        return this._start = b, Yu(this), this.render(d, u, m);
      this._onUpdate && !u && Qr(this, "onUpdate", !0), (C === T && this._tTime >= this.totalDuration() || !C && _) && (b === this._start || Math.abs(R) !== Math.abs(this._ts)) && (this._lock || ((d || !S) && (C === T && this._ts > 0 || !C && this._ts < 0) && Ra(this, 1), !u && !(d < 0 && !_) && (C || _ || !T) && (Qr(this, C === T && d >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(C < T && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, o.add = function(d, u) {
    var m = this;
    if (Wo(u) || (u = Ts(this, u, d)), !(d instanceof Jh)) {
      if (pr(d))
        return d.forEach(function(_) {
          return m.add(_, u);
        }), this;
      if (Yn(d))
        return this.addLabel(d, u);
      if (Cn(d))
        d = kn.delayedCall(0, d);
      else
        return this;
    }
    return this !== d ? so(this, d, u) : this;
  }, o.getChildren = function(d, u, m, _) {
    d === void 0 && (d = !0), u === void 0 && (u = !0), m === void 0 && (m = !0), _ === void 0 && (_ = -Ms);
    for (var T = [], S = this._first; S; )
      S._start >= _ && (S instanceof kn ? u && T.push(S) : (m && T.push(S), d && T.push.apply(T, S.getChildren(!0, u, m)))), S = S._next;
    return T;
  }, o.getById = function(d) {
    for (var u = this.getChildren(1, 1, 1), m = u.length; m--; )
      if (u[m].vars.id === d)
        return u[m];
  }, o.remove = function(d) {
    return Yn(d) ? this.removeLabel(d) : Cn(d) ? this.killTweensOf(d) : (qu(this, d), d === this._recent && (this._recent = this._last), xl(this));
  }, o.totalTime = function(d, u) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = qn(Kr.time - (this._ts > 0 ? d / this._ts : (this.totalDuration() - d) / -this._ts))), w.prototype.totalTime.call(this, d, u), this._forcing = 0, this) : this._tTime;
  }, o.addLabel = function(d, u) {
    return this.labels[d] = Ts(this, u), this;
  }, o.removeLabel = function(d) {
    return delete this.labels[d], this;
  }, o.addPause = function(d, u, m) {
    var _ = kn.delayedCall(0, u || qh, m);
    return _.data = "isPause", this._hasPause = 1, so(this, _, Ts(this, d));
  }, o.removePause = function(d) {
    var u = this._first;
    for (d = Ts(this, d); u; )
      u._start === d && u.data === "isPause" && Ra(u), u = u._next;
  }, o.killTweensOf = function(d, u, m) {
    for (var _ = this.getTweensOf(d, m), T = _.length; T--; )
      ba !== _[T] && _[T].kill(d, u);
    return this;
  }, o.getTweensOf = function(d, u) {
    for (var m = [], _ = Ss(d), T = this._first, S = Wo(u), C; T; )
      T instanceof kn ? ey(T._targets, _) && (S ? (!ba || T._initted && T._ts) && T.globalTime(0) <= u && T.globalTime(T.totalDuration()) > u : !u || T.isActive()) && m.push(T) : (C = T.getTweensOf(_, u)).length && m.push.apply(m, C), T = T._next;
    return m;
  }, o.tweenTo = function(d, u) {
    u = u || {};
    var m = this, _ = Ts(m, d), T = u, S = T.startAt, C = T.onStart, z = T.onStartParams, B = T.immediateRender, I, F = kn.to(m, Es({
      ease: u.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: _,
      overwrite: "auto",
      duration: u.duration || Math.abs((_ - (S && "time" in S ? S.time : m._time)) / m.timeScale()) || nn,
      onStart: function() {
        if (m.pause(), !I) {
          var L = u.duration || Math.abs((_ - (S && "time" in S ? S.time : m._time)) / m.timeScale());
          F._dur !== L && lh(F, L, 0, 1).render(F._time, !0, !0), I = 1;
        }
        C && C.apply(F, z || []);
      }
    }, u));
    return B ? F.render(0) : F;
  }, o.tweenFromTo = function(d, u, m) {
    return this.tweenTo(u, Es({
      startAt: {
        time: Ts(this, d)
      }
    }, m));
  }, o.recent = function() {
    return this._recent;
  }, o.nextLabel = function(d) {
    return d === void 0 && (d = this._time), wp(this, Ts(this, d));
  }, o.previousLabel = function(d) {
    return d === void 0 && (d = this._time), wp(this, Ts(this, d), 1);
  }, o.currentLabel = function(d) {
    return arguments.length ? this.seek(d, !0) : this.previousLabel(this._time + nn);
  }, o.shiftChildren = function(d, u, m) {
    m === void 0 && (m = 0);
    for (var _ = this._first, T = this.labels, S; _; )
      _._start >= m && (_._start += d, _._end += d), _ = _._next;
    if (u)
      for (S in T)
        T[S] >= m && (T[S] += d);
    return xl(this);
  }, o.invalidate = function(d) {
    var u = this._first;
    for (this._lock = 0; u; )
      u.invalidate(d), u = u._next;
    return w.prototype.invalidate.call(this, d);
  }, o.clear = function(d) {
    d === void 0 && (d = !0);
    for (var u = this._first, m; u; )
      m = u._next, this.remove(u), u = m;
    return this._dp && (this._time = this._tTime = this._pTime = 0), d && (this.labels = {}), xl(this);
  }, o.totalDuration = function(d) {
    var u = 0, m = this, _ = m._last, T = Ms, S, C, z;
    if (arguments.length)
      return m.timeScale((m._repeat < 0 ? m.duration() : m.totalDuration()) / (m.reversed() ? -d : d));
    if (m._dirty) {
      for (z = m.parent; _; )
        S = _._prev, _._dirty && _.totalDuration(), C = _._start, C > T && m._sort && _._ts && !m._lock ? (m._lock = 1, so(m, _, C - _._delay, 1)._lock = 0) : T = C, C < 0 && _._ts && (u -= C, (!z && !m._dp || z && z.smoothChildTiming) && (m._start += C / m._ts, m._time -= C, m._tTime -= C), m.shiftChildren(-C, !1, -1 / 0), T = 0), _._end > u && _._ts && (u = _._end), _ = S;
      lh(m, m === _n && m._time > u ? m._time : u, 1, 1), m._dirty = 0;
    }
    return m._tDur;
  }, l.updateRoot = function(d) {
    if (_n._ts && (Zp(_n, Gu(d, _n)), qp = Kr.frame), Kr.frame >= vp) {
      vp += ts.autoSleep || 120;
      var u = _n._first;
      if ((!u || !u._ts) && ts.autoSleep && Kr._listeners.length < 2) {
        for (; u && !u._ts; )
          u = u._next;
        u || Kr.sleep();
      }
    }
  }, l;
}(Jh);
Es(Tr.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var Sy = function(l, o, p, d, u, m, _) {
  var T = new Nr(this._pt, l, o, 0, 1, Md, null, u), S = 0, C = 0, z, B, I, F, E, L, x, M;
  for (T.b = p, T.e = d, p += "", d += "", (x = ~d.indexOf("random(")) && (d = Yh(d)), m && (M = [p, d], m(M, l, o), p = M[0], d = M[1]), B = p.match(Ac) || []; z = Ac.exec(d); )
    F = z[0], E = d.substring(S, z.index), I ? I = (I + 1) % 5 : E.substr(-5) === "rgba(" && (I = 1), F !== B[C++] && (L = parseFloat(B[C - 1]) || 0, T._pt = {
      _next: T._pt,
      p: E || C === 1 ? E : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: L,
      c: F.charAt(1) === "=" ? nh(L, F) - L : parseFloat(F) - L,
      m: I && I < 4 ? Math.round : 0
    }, S = Ac.lastIndex);
  return T.c = S < d.length ? d.substring(S, d.length) : "", T.fp = _, (Hp.test(d) || x) && (T.e = 0), this._pt = T, T;
}, ff = function(l, o, p, d, u, m, _, T, S, C) {
  Cn(d) && (d = d(u || 0, l, m));
  var z = l[o], B = p !== "get" ? p : Cn(z) ? S ? l[o.indexOf("set") || !Cn(l["get" + o.substr(3)]) ? o : "get" + o.substr(3)](S) : l[o]() : z, I = Cn(z) ? S ? Py : wd : df, F;
  if (Yn(d) && (~d.indexOf("random(") && (d = Yh(d)), d.charAt(1) === "=" && (F = nh(B, d) + (cr(B) || 0), (F || F === 0) && (d = F))), !C || B !== d || qc)
    return !isNaN(B * d) && d !== "" ? (F = new Nr(this._pt, l, o, +B || 0, d - (B || 0), typeof z == "boolean" ? Ry : Td, 0, I), S && (F.fp = S), _ && F.modifier(_, this, l), this._pt = F) : (!z && !(o in l) && lf(o, d), Sy.call(this, l, o, B, d, I, T || ts.stringFilter, S));
}, Ey = function(l, o, p, d, u) {
  if (Cn(l) && (l = jh(l, u, o, p, d)), !lo(l) || l.style && l.nodeType || pr(l) || Up(l))
    return Yn(l) ? jh(l, u, o, p, d) : l;
  var m = {}, _;
  for (_ in l)
    m[_] = jh(l[_], u, o, p, d);
  return m;
}, _d = function(l, o, p, d, u, m) {
  var _, T, S, C;
  if ($r[l] && (_ = new $r[l]()).init(u, _.rawVars ? o[l] : Ey(o[l], d, u, m, p), p, d, m) !== !1 && (p._pt = T = new Nr(p._pt, u, l, 0, 1, _.render, _, 0, _.priority), p !== ih))
    for (S = p._ptLookup[p._targets.indexOf(u)], C = _._props.length; C--; )
      S[_._props[C]] = T;
  return _;
}, ba, qc, pf = function w(l, o, p) {
  var d = l.vars, u = d.ease, m = d.startAt, _ = d.immediateRender, T = d.lazy, S = d.onUpdate, C = d.runBackwards, z = d.yoyoEase, B = d.keyframes, I = d.autoRevert, F = l._dur, E = l._startAt, L = l._targets, x = l.parent, M = x && x.data === "nested" ? x.vars.targets : L, R = l._overwrite === "auto" && !rf, b = l.timeline, U, N, j, J, $, ct, It, et, yt, G, Pt, Et, Ct;
  if (b && (!B || !u) && (u = "none"), l._ease = wl(u, oh.ease), l._yEase = z ? dd(wl(z === !0 ? u : z, oh.ease)) : 0, z && l._yoyo && !l._repeat && (z = l._yEase, l._yEase = l._ease, l._ease = z), l._from = !b && !!d.runBackwards, !b || B && !d.stagger) {
    if (et = L[0] ? yl(L[0]).harness : 0, Et = et && d[et.prop], U = Uu(d, hf), E && (E._zTime < 0 && E.progress(1), o < 0 && C && _ && !I ? E.render(-1, !0) : E.revert(C && F ? Iu : Q_), E._lazy = 0), m) {
      if (Ra(l._startAt = kn.set(L, Es({
        data: "isStart",
        overwrite: !1,
        parent: x,
        immediateRender: !0,
        lazy: !E && kr(T),
        startAt: null,
        delay: 0,
        onUpdate: S && function() {
          return Qr(l, "onUpdate");
        },
        stagger: 0
      }, m))), l._startAt._dp = 0, l._startAt._sat = l, o < 0 && (fr || !_ && !I) && l._startAt.revert(Iu), _ && F && o <= 0 && p <= 0) {
        o && (l._zTime = o);
        return;
      }
    } else if (C && F && !E) {
      if (o && (_ = !1), j = Es({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: _ && !E && kr(T),
        immediateRender: _,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: x
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, U), Et && (j[et.prop] = Et), Ra(l._startAt = kn.set(L, j)), l._startAt._dp = 0, l._startAt._sat = l, o < 0 && (fr ? l._startAt.revert(Iu) : l._startAt.render(-1, !0)), l._zTime = o, !_)
        w(l._startAt, nn, nn);
      else if (!o)
        return;
    }
    for (l._pt = l._ptCache = 0, T = F && kr(T) || T && !F, N = 0; N < L.length; N++) {
      if ($ = L[N], It = $._gsap || cf(L)[N]._gsap, l._ptLookup[N] = G = {}, Gc[It.id] && Pa.length && Fu(), Pt = M === L ? N : M.indexOf($), et && (yt = new et()).init($, Et || U, l, Pt, M) !== !1 && (l._pt = J = new Nr(l._pt, $, yt.name, 0, 1, yt.render, yt, 0, yt.priority), yt._props.forEach(function(ce) {
        G[ce] = J;
      }), yt.priority && (ct = 1)), !et || Et)
        for (j in U)
          $r[j] && (yt = _d(j, U, l, Pt, $, M)) ? yt.priority && (ct = 1) : G[j] = J = ff.call(l, $, j, "get", U[j], Pt, M, 0, d.stringFilter);
      l._op && l._op[N] && l.kill($, l._op[N]), R && l._pt && (ba = l, _n.killTweensOf($, G, l.globalTime(o)), Ct = !l.parent, ba = 0), l._pt && T && (Gc[It.id] = 1);
    }
    ct && Sd(l), l._onInit && l._onInit(l);
  }
  l._onUpdate = S, l._initted = (!l._op || l._pt) && !Ct, B && o <= 0 && b.render(Ms, !0, !0);
}, by = function(l, o, p, d, u, m, _, T) {
  var S = (l._pt && l._ptCache || (l._ptCache = {}))[o], C, z, B, I;
  if (!S)
    for (S = l._ptCache[o] = [], B = l._ptLookup, I = l._targets.length; I--; ) {
      if (C = B[I][o], C && C.d && C.d._pt)
        for (C = C.d._pt; C && C.p !== o && C.fp !== o; )
          C = C._next;
      if (!C)
        return qc = 1, l.vars[o] = "+=0", pf(l, _), qc = 0, T ? Xh(o + " not eligible for reset") : 1;
      S.push(C);
    }
  for (I = S.length; I--; )
    z = S[I], C = z._pt || z, C.s = (d || d === 0) && !u ? d : C.s + (d || 0) + m * C.c, C.c = p - C.s, z.e && (z.e = In(p) + cr(z.e)), z.b && (z.b = C.s + cr(z.b));
}, Ay = function(l, o) {
  var p = l[0] ? yl(l[0]).harness : 0, d = p && p.aliases, u, m, _, T;
  if (!d)
    return o;
  u = Ml({}, o);
  for (m in d)
    if (m in u)
      for (T = d[m].split(","), _ = T.length; _--; )
        u[T[_]] = u[m];
  return u;
}, Cy = function(l, o, p, d) {
  var u = o.ease || d || "power1.inOut", m, _;
  if (pr(o))
    _ = p[l] || (p[l] = []), o.forEach(function(T, S) {
      return _.push({
        t: S / (o.length - 1) * 100,
        v: T,
        e: u
      });
    });
  else
    for (m in o)
      _ = p[m] || (p[m] = []), m === "ease" || _.push({
        t: parseFloat(l),
        v: o[m],
        e: u
      });
}, jh = function(l, o, p, d, u) {
  return Cn(l) ? l.call(o, p, d, u) : Yn(l) && ~l.indexOf("random(") ? Yh(l) : l;
}, yd = uf + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", xd = {};
Br(yd + ",id,stagger,delay,duration,paused,scrollTrigger", function(w) {
  return xd[w] = 1;
});
var kn = /* @__PURE__ */ function(w) {
  Np(l, w);
  function l(p, d, u, m) {
    var _;
    typeof d == "number" && (u.duration = d, d = u, u = null), _ = w.call(this, m ? d : Vh(d)) || this;
    var T = _.vars, S = T.duration, C = T.delay, z = T.immediateRender, B = T.stagger, I = T.overwrite, F = T.keyframes, E = T.defaults, L = T.scrollTrigger, x = T.yoyoEase, M = d.parent || _n, R = (pr(p) || Up(p) ? Wo(p[0]) : "length" in d) ? [p] : Ss(p), b, U, N, j, J, $, ct, It;
    if (_._targets = R.length ? cf(R) : Xh("GSAP target " + p + " not found. https://gsap.com", !ts.nullTargetWarn) || [], _._ptLookup = [], _._overwrite = I, F || B || Ou(S) || Ou(C)) {
      if (d = _.vars, b = _.timeline = new Tr({
        data: "nested",
        defaults: E || {},
        targets: M && M.data === "nested" ? M.vars.targets : R
      }), b.kill(), b.parent = b._dp = Ho(_), b._start = 0, B || Ou(S) || Ou(C)) {
        if (j = R.length, ct = B && rd(B), lo(B))
          for (J in B)
            ~yd.indexOf(J) && (It || (It = {}), It[J] = B[J]);
        for (U = 0; U < j; U++)
          N = Uu(d, xd), N.stagger = 0, x && (N.yoyoEase = x), It && Ml(N, It), $ = R[U], N.duration = +jh(S, Ho(_), U, $, R), N.delay = (+jh(C, Ho(_), U, $, R) || 0) - _._delay, !B && j === 1 && N.delay && (_._delay = C = N.delay, _._start += C, N.delay = 0), b.to($, N, ct ? ct(U, $, R) : 0), b._ease = Bi.none;
        b.duration() ? S = C = 0 : _.timeline = 0;
      } else if (F) {
        Vh(Es(b.vars.defaults, {
          ease: "none"
        })), b._ease = wl(F.ease || d.ease || "none");
        var et = 0, yt, G, Pt;
        if (pr(F))
          F.forEach(function(Et) {
            return b.to(R, Et, ">");
          }), b.duration();
        else {
          N = {};
          for (J in F)
            J === "ease" || J === "easeEach" || Cy(J, F[J], N, F.easeEach);
          for (J in N)
            for (yt = N[J].sort(function(Et, Ct) {
              return Et.t - Ct.t;
            }), et = 0, U = 0; U < yt.length; U++)
              G = yt[U], Pt = {
                ease: G.e,
                duration: (G.t - (U ? yt[U - 1].t : 0)) / 100 * S
              }, Pt[J] = G.v, b.to(R, Pt, et), et += Pt.duration;
          b.duration() < S && b.to({}, {
            duration: S - b.duration()
          });
        }
      }
      S || _.duration(S = b.duration());
    } else
      _.timeline = 0;
    return I === !0 && !rf && (ba = Ho(_), _n.killTweensOf(R), ba = 0), so(M, Ho(_), u), d.reversed && _.reverse(), d.paused && _.paused(!0), (z || !S && !F && _._start === qn(M._time) && kr(z) && sy(Ho(_)) && M.data !== "nested") && (_._tTime = -nn, _.render(Math.max(0, -C) || 0)), L && td(Ho(_), L), _;
  }
  var o = l.prototype;
  return o.render = function(d, u, m) {
    var _ = this._time, T = this._tDur, S = this._dur, C = d < 0, z = d > T - nn && !C ? T : d < nn ? 0 : d, B, I, F, E, L, x, M, R, b;
    if (!S)
      ay(this, d, u, m);
    else if (z !== this._tTime || !d || m || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== C) {
      if (B = z, R = this.timeline, this._repeat) {
        if (E = S + this._rDelay, this._repeat < -1 && C)
          return this.totalTime(E * 100 + d, u, m);
        if (B = qn(z % E), z === T ? (F = this._repeat, B = S) : (F = ~~(z / E), F && F === qn(z / E) && (B = S, F--), B > S && (B = S)), x = this._yoyo && F & 1, x && (b = this._yEase, B = S - B), L = ah(this._tTime, E), B === _ && !m && this._initted && F === L)
          return this._tTime = z, this;
        F !== L && (R && this._yEase && md(R, x), this.vars.repeatRefresh && !x && !this._lock && this._time !== E && this._initted && (this._lock = m = 1, this.render(qn(E * F), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (ed(this, C ? d : B, m, u, z))
          return this._tTime = 0, this;
        if (_ !== this._time && !(m && this.vars.repeatRefresh && F !== L))
          return this;
        if (S !== this._dur)
          return this.render(d, u, m);
      }
      if (this._tTime = z, this._time = B, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = M = (b || this._ease)(B / S), this._from && (this.ratio = M = 1 - M), B && !_ && !u && !F && (Qr(this, "onStart"), this._tTime !== z))
        return this;
      for (I = this._pt; I; )
        I.r(M, I.d), I = I._next;
      R && R.render(d < 0 ? d : R._dur * R._ease(B / this._dur), u, m) || this._startAt && (this._zTime = d), this._onUpdate && !u && (C && Hc(this, d, u, m), Qr(this, "onUpdate")), this._repeat && F !== L && this.vars.onRepeat && !u && this.parent && Qr(this, "onRepeat"), (z === this._tDur || !z) && this._tTime === z && (C && !this._onUpdate && Hc(this, d, !0, !0), (d || !S) && (z === this._tDur && this._ts > 0 || !z && this._ts < 0) && Ra(this, 1), !u && !(C && !_) && (z || _ || x) && (Qr(this, z === T ? "onComplete" : "onReverseComplete", !0), this._prom && !(z < T && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, o.targets = function() {
    return this._targets;
  }, o.invalidate = function(d) {
    return (!d || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(d), w.prototype.invalidate.call(this, d);
  }, o.resetTo = function(d, u, m, _, T) {
    Zh || Kr.wake(), this._ts || this.play();
    var S = Math.min(this._dur, (this._dp._time - this._start) * this._ts), C;
    return this._initted || pf(this, S), C = this._ease(S / this._dur), by(this, d, u, m, _, C, S, T) ? this.resetTo(d, u, m, _, 1) : (Zu(this, 0), this.parent || Kp(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, o.kill = function(d, u) {
    if (u === void 0 && (u = "all"), !d && (!u || u === "all"))
      return this._lazy = this._pt = 0, this.parent ? Gh(this) : this;
    if (this.timeline) {
      var m = this.timeline.totalDuration();
      return this.timeline.killTweensOf(d, u, ba && ba.vars.overwrite !== !0)._first || Gh(this), this.parent && m !== this.timeline.totalDuration() && lh(this, this._dur * this.timeline._tDur / m, 0, 1), this;
    }
    var _ = this._targets, T = d ? Ss(d) : _, S = this._ptLookup, C = this._pt, z, B, I, F, E, L, x;
    if ((!u || u === "all") && ny(_, T))
      return u === "all" && (this._pt = 0), Gh(this);
    for (z = this._op = this._op || [], u !== "all" && (Yn(u) && (E = {}, Br(u, function(M) {
      return E[M] = 1;
    }), u = E), u = Ay(_, u)), x = _.length; x--; )
      if (~T.indexOf(_[x])) {
        B = S[x], u === "all" ? (z[x] = u, F = B, I = {}) : (I = z[x] = z[x] || {}, F = u);
        for (E in F)
          L = B && B[E], L && ((!("kill" in L.d) || L.d.kill(E) === !0) && qu(this, L, "_pt"), delete B[E]), I !== "all" && (I[E] = 1);
      }
    return this._initted && !this._pt && C && Gh(this), this;
  }, l.to = function(d, u) {
    return new l(d, u, arguments[2]);
  }, l.from = function(d, u) {
    return Wh(1, arguments);
  }, l.delayedCall = function(d, u, m, _) {
    return new l(u, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: d,
      onComplete: u,
      onReverseComplete: u,
      onCompleteParams: m,
      onReverseCompleteParams: m,
      callbackScope: _
    });
  }, l.fromTo = function(d, u, m) {
    return Wh(2, arguments);
  }, l.set = function(d, u) {
    return u.duration = 0, u.repeatDelay || (u.repeat = 0), new l(d, u);
  }, l.killTweensOf = function(d, u, m) {
    return _n.killTweensOf(d, u, m);
  }, l;
}(Jh);
Es(kn.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
Br("staggerTo,staggerFrom,staggerFromTo", function(w) {
  kn[w] = function() {
    var l = new Tr(), o = Wc.call(arguments, 0);
    return o.splice(w === "staggerFromTo" ? 5 : 4, 0, 0), l[w].apply(l, o);
  };
});
var df = function(l, o, p) {
  return l[o] = p;
}, wd = function(l, o, p) {
  return l[o](p);
}, Py = function(l, o, p, d) {
  return l[o](d.fp, p);
}, Ly = function(l, o, p) {
  return l.setAttribute(o, p);
}, mf = function(l, o) {
  return Cn(l[o]) ? wd : sf(l[o]) && l.setAttribute ? Ly : df;
}, Td = function(l, o) {
  return o.set(o.t, o.p, Math.round((o.s + o.c * l) * 1e6) / 1e6, o);
}, Ry = function(l, o) {
  return o.set(o.t, o.p, !!(o.s + o.c * l), o);
}, Md = function(l, o) {
  var p = o._pt, d = "";
  if (!l && o.b)
    d = o.b;
  else if (l === 1 && o.e)
    d = o.e;
  else {
    for (; p; )
      d = p.p + (p.m ? p.m(p.s + p.c * l) : Math.round((p.s + p.c * l) * 1e4) / 1e4) + d, p = p._next;
    d += o.c;
  }
  o.set(o.t, o.p, d, o);
}, gf = function(l, o) {
  for (var p = o._pt; p; )
    p.r(l, p.d), p = p._next;
}, Oy = function(l, o, p, d) {
  for (var u = this._pt, m; u; )
    m = u._next, u.p === d && u.modifier(l, o, p), u = m;
}, Iy = function(l) {
  for (var o = this._pt, p, d; o; )
    d = o._next, o.p === l && !o.op || o.op === l ? qu(this, o, "_pt") : o.dep || (p = 1), o = d;
  return !p;
}, Dy = function(l, o, p, d) {
  d.mSet(l, o, d.m.call(d.tween, p, d.mt), d);
}, Sd = function(l) {
  for (var o = l._pt, p, d, u, m; o; ) {
    for (p = o._next, d = u; d && d.pr > o.pr; )
      d = d._next;
    (o._prev = d ? d._prev : m) ? o._prev._next = o : u = o, (o._next = d) ? d._prev = o : m = o, o = p;
  }
  l._pt = u;
}, Nr = /* @__PURE__ */ function() {
  function w(o, p, d, u, m, _, T, S, C) {
    this.t = p, this.s = u, this.c = m, this.p = d, this.r = _ || Td, this.d = T || this, this.set = S || df, this.pr = C || 0, this._next = o, o && (o._prev = this);
  }
  var l = w.prototype;
  return l.modifier = function(p, d, u) {
    this.mSet = this.mSet || this.set, this.set = Dy, this.m = p, this.mt = u, this.tween = d;
  }, w;
}();
Br(uf + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(w) {
  return hf[w] = 1;
});
es.TweenMax = es.TweenLite = kn;
es.TimelineLite = es.TimelineMax = Tr;
_n = new Tr({
  sortChildren: !1,
  defaults: oh,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
ts.stringFilter = pd;
var Tl = [], zu = {}, zy = [], Mp = 0, ky = 0, Oc = function(l) {
  return (zu[l] || zy).map(function(o) {
    return o();
  });
}, Yc = function() {
  var l = Date.now(), o = [];
  l - Mp > 2 && (Oc("matchMediaInit"), Tl.forEach(function(p) {
    var d = p.queries, u = p.conditions, m, _, T, S;
    for (_ in d)
      m = ro.matchMedia(d[_]).matches, m && (T = 1), m !== u[_] && (u[_] = m, S = 1);
    S && (p.revert(), T && o.push(p));
  }), Oc("matchMediaRevert"), o.forEach(function(p) {
    return p.onMatch(p, function(d) {
      return p.add(null, d);
    });
  }), Mp = l, Oc("matchMedia"));
}, Ed = /* @__PURE__ */ function() {
  function w(o, p) {
    this.selector = p && jc(p), this.data = [], this._r = [], this.isReverted = !1, this.id = ky++, o && this.add(o);
  }
  var l = w.prototype;
  return l.add = function(p, d, u) {
    Cn(p) && (u = d, d = p, p = Cn);
    var m = this, _ = function() {
      var S = un, C = m.selector, z;
      return S && S !== m && S.data.push(m), u && (m.selector = jc(u)), un = m, z = d.apply(m, arguments), Cn(z) && m._r.push(z), un = S, m.selector = C, m.isReverted = !1, z;
    };
    return m.last = _, p === Cn ? _(m, function(T) {
      return m.add(null, T);
    }) : p ? m[p] = _ : _;
  }, l.ignore = function(p) {
    var d = un;
    un = null, p(this), un = d;
  }, l.getTweens = function() {
    var p = [];
    return this.data.forEach(function(d) {
      return d instanceof w ? p.push.apply(p, d.getTweens()) : d instanceof kn && !(d.parent && d.parent.data === "nested") && p.push(d);
    }), p;
  }, l.clear = function() {
    this._r.length = this.data.length = 0;
  }, l.kill = function(p, d) {
    var u = this;
    if (p ? function() {
      for (var _ = u.getTweens(), T = u.data.length, S; T--; )
        S = u.data[T], S.data === "isFlip" && (S.revert(), S.getChildren(!0, !0, !1).forEach(function(C) {
          return _.splice(_.indexOf(C), 1);
        }));
      for (_.map(function(C) {
        return {
          g: C._dur || C._delay || C._sat && !C._sat.vars.immediateRender ? C.globalTime(0) : -1 / 0,
          t: C
        };
      }).sort(function(C, z) {
        return z.g - C.g || -1 / 0;
      }).forEach(function(C) {
        return C.t.revert(p);
      }), T = u.data.length; T--; )
        S = u.data[T], S instanceof Tr ? S.data !== "nested" && (S.scrollTrigger && S.scrollTrigger.revert(), S.kill()) : !(S instanceof kn) && S.revert && S.revert(p);
      u._r.forEach(function(C) {
        return C(p, u);
      }), u.isReverted = !0;
    }() : this.data.forEach(function(_) {
      return _.kill && _.kill();
    }), this.clear(), d)
      for (var m = Tl.length; m--; )
        Tl[m].id === this.id && Tl.splice(m, 1);
  }, l.revert = function(p) {
    this.kill(p || {});
  }, w;
}(), By = /* @__PURE__ */ function() {
  function w(o) {
    this.contexts = [], this.scope = o, un && un.data.push(this);
  }
  var l = w.prototype;
  return l.add = function(p, d, u) {
    lo(p) || (p = {
      matches: p
    });
    var m = new Ed(0, u || this.scope), _ = m.conditions = {}, T, S, C;
    un && !m.selector && (m.selector = un.selector), this.contexts.push(m), d = m.add("onMatch", d), m.queries = p;
    for (S in p)
      S === "all" ? C = 1 : (T = ro.matchMedia(p[S]), T && (Tl.indexOf(m) < 0 && Tl.push(m), (_[S] = T.matches) && (C = 1), T.addListener ? T.addListener(Yc) : T.addEventListener("change", Yc)));
    return C && d(m, function(z) {
      return m.add(null, z);
    }), this;
  }, l.revert = function(p) {
    this.kill(p || {});
  }, l.kill = function(p) {
    this.contexts.forEach(function(d) {
      return d.kill(p, !0);
    });
  }, w;
}(), Hu = {
  registerPlugin: function() {
    for (var l = arguments.length, o = new Array(l), p = 0; p < l; p++)
      o[p] = arguments[p];
    o.forEach(function(d) {
      return ud(d);
    });
  },
  timeline: function(l) {
    return new Tr(l);
  },
  getTweensOf: function(l, o) {
    return _n.getTweensOf(l, o);
  },
  getProperty: function(l, o, p, d) {
    Yn(l) && (l = Ss(l)[0]);
    var u = yl(l || {}).get, m = p ? $p : Jp;
    return p === "native" && (p = ""), l && (o ? m(($r[o] && $r[o].get || u)(l, o, p, d)) : function(_, T, S) {
      return m(($r[_] && $r[_].get || u)(l, _, T, S));
    });
  },
  quickSetter: function(l, o, p) {
    if (l = Ss(l), l.length > 1) {
      var d = l.map(function(C) {
        return Ur.quickSetter(C, o, p);
      }), u = d.length;
      return function(C) {
        for (var z = u; z--; )
          d[z](C);
      };
    }
    l = l[0] || {};
    var m = $r[o], _ = yl(l), T = _.harness && (_.harness.aliases || {})[o] || o, S = m ? function(C) {
      var z = new m();
      ih._pt = 0, z.init(l, p ? C + p : C, ih, 0, [l]), z.render(1, z), ih._pt && gf(1, ih);
    } : _.set(l, T);
    return m ? S : function(C) {
      return S(l, T, p ? C + p : C, _, 1);
    };
  },
  quickTo: function(l, o, p) {
    var d, u = Ur.to(l, Ml((d = {}, d[o] = "+=0.1", d.paused = !0, d), p || {})), m = function(T, S, C) {
      return u.resetTo(o, T, S, C);
    };
    return m.tween = u, m;
  },
  isTweening: function(l) {
    return _n.getTweensOf(l, !0).length > 0;
  },
  defaults: function(l) {
    return l && l.ease && (l.ease = wl(l.ease, oh.ease)), _p(oh, l || {});
  },
  config: function(l) {
    return _p(ts, l || {});
  },
  registerEffect: function(l) {
    var o = l.name, p = l.effect, d = l.plugins, u = l.defaults, m = l.extendTimeline;
    (d || "").split(",").forEach(function(_) {
      return _ && !$r[_] && !es[_] && Xh(o + " effect requires " + _ + " plugin.");
    }), Cc[o] = function(_, T, S) {
      return p(Ss(_), Es(T || {}, u), S);
    }, m && (Tr.prototype[o] = function(_, T, S) {
      return this.add(Cc[o](_, lo(T) ? T : (S = T) && {}, this), S);
    });
  },
  registerEase: function(l, o) {
    Bi[l] = wl(o);
  },
  parseEase: function(l, o) {
    return arguments.length ? wl(l, o) : Bi;
  },
  getById: function(l) {
    return _n.getById(l);
  },
  exportRoot: function(l, o) {
    l === void 0 && (l = {});
    var p = new Tr(l), d, u;
    for (p.smoothChildTiming = kr(l.smoothChildTiming), _n.remove(p), p._dp = 0, p._time = p._tTime = _n._time, d = _n._first; d; )
      u = d._next, (o || !(!d._dur && d instanceof kn && d.vars.onComplete === d._targets[0])) && so(p, d, d._start - d._delay), d = u;
    return so(_n, p, 0), p;
  },
  context: function(l, o) {
    return l ? new Ed(l, o) : un;
  },
  matchMedia: function(l) {
    return new By(l);
  },
  matchMediaRefresh: function() {
    return Tl.forEach(function(l) {
      var o = l.conditions, p, d;
      for (d in o)
        o[d] && (o[d] = !1, p = 1);
      p && l.revert();
    }) || Yc();
  },
  addEventListener: function(l, o) {
    var p = zu[l] || (zu[l] = []);
    ~p.indexOf(o) || p.push(o);
  },
  removeEventListener: function(l, o) {
    var p = zu[l], d = p && p.indexOf(o);
    d >= 0 && p.splice(d, 1);
  },
  utils: {
    wrap: my,
    wrapYoyo: gy,
    distribute: rd,
    random: od,
    snap: sd,
    normalize: dy,
    getUnit: cr,
    clamp: uy,
    splitColor: cd,
    toArray: Ss,
    selector: jc,
    mapRange: ld,
    pipe: fy,
    unitize: py,
    interpolate: vy,
    shuffle: nd
  },
  install: jp,
  effects: Cc,
  ticker: Kr,
  updateRoot: Tr.updateRoot,
  plugins: $r,
  globalTimeline: _n,
  core: {
    PropTween: Nr,
    globals: Xp,
    Tween: kn,
    Timeline: Tr,
    Animation: Jh,
    getCache: yl,
    _removeLinkedListItem: qu,
    reverting: function() {
      return fr;
    },
    context: function(l) {
      return l && un && (un.data.push(l), l._ctx = un), un;
    },
    suppressOverwrites: function(l) {
      return rf = l;
    }
  }
};
Br("to,from,fromTo,delayedCall,set,killTweensOf", function(w) {
  return Hu[w] = kn[w];
});
Kr.add(Tr.updateRoot);
ih = Hu.to({}, {
  duration: 0
});
var Ny = function(l, o) {
  for (var p = l._pt; p && p.p !== o && p.op !== o && p.fp !== o; )
    p = p._next;
  return p;
}, Fy = function(l, o) {
  var p = l._targets, d, u, m;
  for (d in o)
    for (u = p.length; u--; )
      m = l._ptLookup[u][d], m && (m = m.d) && (m._pt && (m = Ny(m, d)), m && m.modifier && m.modifier(o[d], l, p[u], d));
}, Ic = function(l, o) {
  return {
    name: l,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(d, u, m) {
      m._onInit = function(_) {
        var T, S;
        if (Yn(u) && (T = {}, Br(u, function(C) {
          return T[C] = 1;
        }), u = T), o) {
          T = {};
          for (S in u)
            T[S] = o(u[S]);
          u = T;
        }
        Fy(_, u);
      };
    }
  };
}, Ur = Hu.registerPlugin({
  name: "attr",
  init: function(l, o, p, d, u) {
    var m, _, T;
    this.tween = p;
    for (m in o)
      T = l.getAttribute(m) || "", _ = this.add(l, "setAttribute", (T || 0) + "", o[m], d, u, 0, 0, m), _.op = m, _.b = T, this._props.push(m);
  },
  render: function(l, o) {
    for (var p = o._pt; p; )
      fr ? p.set(p.t, p.p, p.b, p) : p.r(l, p.d), p = p._next;
  }
}, {
  name: "endArray",
  init: function(l, o) {
    for (var p = o.length; p--; )
      this.add(l, p, l[p] || 0, o[p], 0, 0, 0, 0, 0, 1);
  }
}, Ic("roundProps", Xc), Ic("modifiers"), Ic("snap", sd)) || Hu;
kn.version = Tr.version = Ur.version = "3.12.5";
Wp = 1;
of() && hh();
Bi.Power0;
Bi.Power1;
Bi.Power2;
Bi.Power3;
Bi.Power4;
Bi.Linear;
Bi.Quad;
Bi.Cubic;
Bi.Quart;
Bi.Quint;
Bi.Strong;
Bi.Elastic;
Bi.Back;
Bi.SteppedEase;
Bi.Bounce;
Bi.Sine;
Bi.Expo;
Bi.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Sp, Aa, rh, vf, _l, Ep, _f, Uy = function() {
  return typeof window < "u";
}, jo = {}, vl = 180 / Math.PI, sh = Math.PI / 180, th = Math.atan2, bp = 1e8, yf = /([A-Z])/g, Gy = /(left|right|width|margin|padding|x)/i, Hy = /[\s,\(]\S/, oo = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, Zc = function(l, o) {
  return o.set(o.t, o.p, Math.round((o.s + o.c * l) * 1e4) / 1e4 + o.u, o);
}, Vy = function(l, o) {
  return o.set(o.t, o.p, l === 1 ? o.e : Math.round((o.s + o.c * l) * 1e4) / 1e4 + o.u, o);
}, Wy = function(l, o) {
  return o.set(o.t, o.p, l ? Math.round((o.s + o.c * l) * 1e4) / 1e4 + o.u : o.b, o);
}, jy = function(l, o) {
  var p = o.s + o.c * l;
  o.set(o.t, o.p, ~~(p + (p < 0 ? -0.5 : 0.5)) + o.u, o);
}, bd = function(l, o) {
  return o.set(o.t, o.p, l ? o.e : o.b, o);
}, Ad = function(l, o) {
  return o.set(o.t, o.p, l !== 1 ? o.b : o.e, o);
}, Xy = function(l, o, p) {
  return l.style[o] = p;
}, qy = function(l, o, p) {
  return l.style.setProperty(o, p);
}, Yy = function(l, o, p) {
  return l._gsap[o] = p;
}, Zy = function(l, o, p) {
  return l._gsap.scaleX = l._gsap.scaleY = p;
}, Jy = function(l, o, p, d, u) {
  var m = l._gsap;
  m.scaleX = m.scaleY = p, m.renderTransform(u, m);
}, $y = function(l, o, p, d, u) {
  var m = l._gsap;
  m[o] = p, m.renderTransform(u, m);
}, yn = "transform", Fr = yn + "Origin", Ky = function w(l, o) {
  var p = this, d = this.target, u = d.style, m = d._gsap;
  if (l in jo && u) {
    if (this.tfm = this.tfm || {}, l !== "transform")
      l = oo[l] || l, ~l.indexOf(",") ? l.split(",").forEach(function(_) {
        return p.tfm[_] = Vo(d, _);
      }) : this.tfm[l] = m.x ? m[l] : Vo(d, l), l === Fr && (this.tfm.zOrigin = m.zOrigin);
    else
      return oo.transform.split(",").forEach(function(_) {
        return w.call(p, _, o);
      });
    if (this.props.indexOf(yn) >= 0)
      return;
    m.svg && (this.svgo = d.getAttribute("data-svg-origin"), this.props.push(Fr, o, "")), l = yn;
  }
  (u || o) && this.props.push(l, o, u[l]);
}, Cd = function(l) {
  l.translate && (l.removeProperty("translate"), l.removeProperty("scale"), l.removeProperty("rotate"));
}, Qy = function() {
  var l = this.props, o = this.target, p = o.style, d = o._gsap, u, m;
  for (u = 0; u < l.length; u += 3)
    l[u + 1] ? o[l[u]] = l[u + 2] : l[u + 2] ? p[l[u]] = l[u + 2] : p.removeProperty(l[u].substr(0, 2) === "--" ? l[u] : l[u].replace(yf, "-$1").toLowerCase());
  if (this.tfm) {
    for (m in this.tfm)
      d[m] = this.tfm[m];
    d.svg && (d.renderTransform(), o.setAttribute("data-svg-origin", this.svgo || "")), u = _f(), (!u || !u.isStart) && !p[yn] && (Cd(p), d.zOrigin && p[Fr] && (p[Fr] += " " + d.zOrigin + "px", d.zOrigin = 0, d.renderTransform()), d.uncache = 1);
  }
}, Pd = function(l, o) {
  var p = {
    target: l,
    props: [],
    revert: Qy,
    save: Ky
  };
  return l._gsap || Ur.core.getCache(l), o && o.split(",").forEach(function(d) {
    return p.save(d);
  }), p;
}, Ld, Jc = function(l, o) {
  var p = Aa.createElementNS ? Aa.createElementNS((o || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), l) : Aa.createElement(l);
  return p && p.style ? p : Aa.createElement(l);
}, ao = function w(l, o, p) {
  var d = getComputedStyle(l);
  return d[o] || d.getPropertyValue(o.replace(yf, "-$1").toLowerCase()) || d.getPropertyValue(o) || !p && w(l, uh(o) || o, 1) || "";
}, Ap = "O,Moz,ms,Ms,Webkit".split(","), uh = function(l, o, p) {
  var d = o || _l, u = d.style, m = 5;
  if (l in u && !p)
    return l;
  for (l = l.charAt(0).toUpperCase() + l.substr(1); m-- && !(Ap[m] + l in u); )
    ;
  return m < 0 ? null : (m === 3 ? "ms" : m >= 0 ? Ap[m] : "") + l;
}, $c = function() {
  Uy() && window.document && (Sp = window, Aa = Sp.document, rh = Aa.documentElement, _l = Jc("div") || {
    style: {}
  }, Jc("div"), yn = uh(yn), Fr = yn + "Origin", _l.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ld = !!uh("perspective"), _f = Ur.core.reverting, vf = 1);
}, Dc = function w(l) {
  var o = Jc("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), p = this.parentNode, d = this.nextSibling, u = this.style.cssText, m;
  if (rh.appendChild(o), o.appendChild(this), this.style.display = "block", l)
    try {
      m = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = w;
    } catch {
    }
  else
    this._gsapBBox && (m = this._gsapBBox());
  return p && (d ? p.insertBefore(this, d) : p.appendChild(this)), rh.removeChild(o), this.style.cssText = u, m;
}, Cp = function(l, o) {
  for (var p = o.length; p--; )
    if (l.hasAttribute(o[p]))
      return l.getAttribute(o[p]);
}, Rd = function(l) {
  var o;
  try {
    o = l.getBBox();
  } catch {
    o = Dc.call(l, !0);
  }
  return o && (o.width || o.height) || l.getBBox === Dc || (o = Dc.call(l, !0)), o && !o.width && !o.x && !o.y ? {
    x: +Cp(l, ["x", "cx", "x1"]) || 0,
    y: +Cp(l, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : o;
}, Od = function(l) {
  return !!(l.getCTM && (!l.parentNode || l.ownerSVGElement) && Rd(l));
}, Sl = function(l, o) {
  if (o) {
    var p = l.style, d;
    o in jo && o !== Fr && (o = yn), p.removeProperty ? (d = o.substr(0, 2), (d === "ms" || o.substr(0, 6) === "webkit") && (o = "-" + o), p.removeProperty(d === "--" ? o : o.replace(yf, "-$1").toLowerCase())) : p.removeAttribute(o);
  }
}, Ca = function(l, o, p, d, u, m) {
  var _ = new Nr(l._pt, o, p, 0, 1, m ? Ad : bd);
  return l._pt = _, _.b = d, _.e = u, l._props.push(p), _;
}, Pp = {
  deg: 1,
  rad: 1,
  turn: 1
}, t1 = {
  grid: 1,
  flex: 1
}, Oa = function w(l, o, p, d) {
  var u = parseFloat(p) || 0, m = (p + "").trim().substr((u + "").length) || "px", _ = _l.style, T = Gy.test(o), S = l.tagName.toLowerCase() === "svg", C = (S ? "client" : "offset") + (T ? "Width" : "Height"), z = 100, B = d === "px", I = d === "%", F, E, L, x;
  if (d === m || !u || Pp[d] || Pp[m])
    return u;
  if (m !== "px" && !B && (u = w(l, o, p, "px")), x = l.getCTM && Od(l), (I || m === "%") && (jo[o] || ~o.indexOf("adius")))
    return F = x ? l.getBBox()[T ? "width" : "height"] : l[C], In(I ? u / F * z : u / 100 * F);
  if (_[T ? "width" : "height"] = z + (B ? m : d), E = ~o.indexOf("adius") || d === "em" && l.appendChild && !S ? l : l.parentNode, x && (E = (l.ownerSVGElement || {}).parentNode), (!E || E === Aa || !E.appendChild) && (E = Aa.body), L = E._gsap, L && I && L.width && T && L.time === Kr.time && !L.uncache)
    return In(u / L.width * z);
  if (I && (o === "height" || o === "width")) {
    var M = l.style[o];
    l.style[o] = z + d, F = l[C], M ? l.style[o] = M : Sl(l, o);
  } else
    (I || m === "%") && !t1[ao(E, "display")] && (_.position = ao(l, "position")), E === l && (_.position = "static"), E.appendChild(_l), F = _l[C], E.removeChild(_l), _.position = "absolute";
  return T && I && (L = yl(E), L.time = Kr.time, L.width = E[C]), In(B ? F * u / z : F && u ? z / F * u : 0);
}, Vo = function(l, o, p, d) {
  var u;
  return vf || $c(), o in oo && o !== "transform" && (o = oo[o], ~o.indexOf(",") && (o = o.split(",")[0])), jo[o] && o !== "transform" ? (u = Kh(l, d), u = o !== "transformOrigin" ? u[o] : u.svg ? u.origin : Wu(ao(l, Fr)) + " " + u.zOrigin + "px") : (u = l.style[o], (!u || u === "auto" || d || ~(u + "").indexOf("calc(")) && (u = Vu[o] && Vu[o](l, o, p) || ao(l, o) || Yp(l, o) || (o === "opacity" ? 1 : 0))), p && !~(u + "").trim().indexOf(" ") ? Oa(l, o, u, p) + p : u;
}, e1 = function(l, o, p, d) {
  if (!p || p === "none") {
    var u = uh(o, l, 1), m = u && ao(l, u, 1);
    m && m !== p ? (o = u, p = m) : o === "borderColor" && (p = ao(l, "borderTopColor"));
  }
  var _ = new Nr(this._pt, l.style, o, 0, 1, Md), T = 0, S = 0, C, z, B, I, F, E, L, x, M, R, b, U;
  if (_.b = p, _.e = d, p += "", d += "", d === "auto" && (E = l.style[o], l.style[o] = d, d = ao(l, o) || d, E ? l.style[o] = E : Sl(l, o)), C = [p, d], pd(C), p = C[0], d = C[1], B = p.match(eh) || [], U = d.match(eh) || [], U.length) {
    for (; z = eh.exec(d); )
      L = z[0], M = d.substring(T, z.index), F ? F = (F + 1) % 5 : (M.substr(-5) === "rgba(" || M.substr(-5) === "hsla(") && (F = 1), L !== (E = B[S++] || "") && (I = parseFloat(E) || 0, b = E.substr((I + "").length), L.charAt(1) === "=" && (L = nh(I, L) + b), x = parseFloat(L), R = L.substr((x + "").length), T = eh.lastIndex - R.length, R || (R = R || ts.units[o] || b, T === d.length && (d += R, _.e += R)), b !== R && (I = Oa(l, o, E, R) || 0), _._pt = {
        _next: _._pt,
        p: M || S === 1 ? M : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: I,
        c: x - I,
        m: F && F < 4 || o === "zIndex" ? Math.round : 0
      });
    _.c = T < d.length ? d.substring(T, d.length) : "";
  } else
    _.r = o === "display" && d === "none" ? Ad : bd;
  return Hp.test(d) && (_.e = 0), this._pt = _, _;
}, Lp = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, i1 = function(l) {
  var o = l.split(" "), p = o[0], d = o[1] || "50%";
  return (p === "top" || p === "bottom" || d === "left" || d === "right") && (l = p, p = d, d = l), o[0] = Lp[p] || p, o[1] = Lp[d] || d, o.join(" ");
}, n1 = function(l, o) {
  if (o.tween && o.tween._time === o.tween._dur) {
    var p = o.t, d = p.style, u = o.u, m = p._gsap, _, T, S;
    if (u === "all" || u === !0)
      d.cssText = "", T = 1;
    else
      for (u = u.split(","), S = u.length; --S > -1; )
        _ = u[S], jo[_] && (T = 1, _ = _ === "transformOrigin" ? Fr : yn), Sl(p, _);
    T && (Sl(p, yn), m && (m.svg && p.removeAttribute("transform"), Kh(p, 1), m.uncache = 1, Cd(d)));
  }
}, Vu = {
  clearProps: function(l, o, p, d, u) {
    if (u.data !== "isFromStart") {
      var m = l._pt = new Nr(l._pt, o, p, 0, 0, n1);
      return m.u = d, m.pr = -10, m.tween = u, l._props.push(p), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, $h = [1, 0, 0, 1, 0, 0], Id = {}, Dd = function(l) {
  return l === "matrix(1, 0, 0, 1, 0, 0)" || l === "none" || !l;
}, Rp = function(l) {
  var o = ao(l, yn);
  return Dd(o) ? $h : o.substr(7).match(Gp).map(In);
}, xf = function(l, o) {
  var p = l._gsap || yl(l), d = l.style, u = Rp(l), m, _, T, S;
  return p.svg && l.getAttribute("transform") ? (T = l.transform.baseVal.consolidate().matrix, u = [T.a, T.b, T.c, T.d, T.e, T.f], u.join(",") === "1,0,0,1,0,0" ? $h : u) : (u === $h && !l.offsetParent && l !== rh && !p.svg && (T = d.display, d.display = "block", m = l.parentNode, (!m || !l.offsetParent) && (S = 1, _ = l.nextElementSibling, rh.appendChild(l)), u = Rp(l), T ? d.display = T : Sl(l, "display"), S && (_ ? m.insertBefore(l, _) : m ? m.appendChild(l) : rh.removeChild(l))), o && u.length > 6 ? [u[0], u[1], u[4], u[5], u[12], u[13]] : u);
}, Kc = function(l, o, p, d, u, m) {
  var _ = l._gsap, T = u || xf(l, !0), S = _.xOrigin || 0, C = _.yOrigin || 0, z = _.xOffset || 0, B = _.yOffset || 0, I = T[0], F = T[1], E = T[2], L = T[3], x = T[4], M = T[5], R = o.split(" "), b = parseFloat(R[0]) || 0, U = parseFloat(R[1]) || 0, N, j, J, $;
  p ? T !== $h && (j = I * L - F * E) && (J = b * (L / j) + U * (-E / j) + (E * M - L * x) / j, $ = b * (-F / j) + U * (I / j) - (I * M - F * x) / j, b = J, U = $) : (N = Rd(l), b = N.x + (~R[0].indexOf("%") ? b / 100 * N.width : b), U = N.y + (~(R[1] || R[0]).indexOf("%") ? U / 100 * N.height : U)), d || d !== !1 && _.smooth ? (x = b - S, M = U - C, _.xOffset = z + (x * I + M * E) - x, _.yOffset = B + (x * F + M * L) - M) : _.xOffset = _.yOffset = 0, _.xOrigin = b, _.yOrigin = U, _.smooth = !!d, _.origin = o, _.originIsAbsolute = !!p, l.style[Fr] = "0px 0px", m && (Ca(m, _, "xOrigin", S, b), Ca(m, _, "yOrigin", C, U), Ca(m, _, "xOffset", z, _.xOffset), Ca(m, _, "yOffset", B, _.yOffset)), l.setAttribute("data-svg-origin", b + " " + U);
}, Kh = function(l, o) {
  var p = l._gsap || new vd(l);
  if ("x" in p && !o && !p.uncache)
    return p;
  var d = l.style, u = p.scaleX < 0, m = "px", _ = "deg", T = getComputedStyle(l), S = ao(l, Fr) || "0", C, z, B, I, F, E, L, x, M, R, b, U, N, j, J, $, ct, It, et, yt, G, Pt, Et, Ct, ce, re, Ft, Ot, Bt, ke, fe, Yt;
  return C = z = B = E = L = x = M = R = b = 0, I = F = 1, p.svg = !!(l.getCTM && Od(l)), T.translate && ((T.translate !== "none" || T.scale !== "none" || T.rotate !== "none") && (d[yn] = (T.translate !== "none" ? "translate3d(" + (T.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (T.rotate !== "none" ? "rotate(" + T.rotate + ") " : "") + (T.scale !== "none" ? "scale(" + T.scale.split(" ").join(",") + ") " : "") + (T[yn] !== "none" ? T[yn] : "")), d.scale = d.rotate = d.translate = "none"), j = xf(l, p.svg), p.svg && (p.uncache ? (ce = l.getBBox(), S = p.xOrigin - ce.x + "px " + (p.yOrigin - ce.y) + "px", Ct = "") : Ct = !o && l.getAttribute("data-svg-origin"), Kc(l, Ct || S, !!Ct || p.originIsAbsolute, p.smooth !== !1, j)), U = p.xOrigin || 0, N = p.yOrigin || 0, j !== $h && (It = j[0], et = j[1], yt = j[2], G = j[3], C = Pt = j[4], z = Et = j[5], j.length === 6 ? (I = Math.sqrt(It * It + et * et), F = Math.sqrt(G * G + yt * yt), E = It || et ? th(et, It) * vl : 0, M = yt || G ? th(yt, G) * vl + E : 0, M && (F *= Math.abs(Math.cos(M * sh))), p.svg && (C -= U - (U * It + N * yt), z -= N - (U * et + N * G))) : (Yt = j[6], ke = j[7], Ft = j[8], Ot = j[9], Bt = j[10], fe = j[11], C = j[12], z = j[13], B = j[14], J = th(Yt, Bt), L = J * vl, J && ($ = Math.cos(-J), ct = Math.sin(-J), Ct = Pt * $ + Ft * ct, ce = Et * $ + Ot * ct, re = Yt * $ + Bt * ct, Ft = Pt * -ct + Ft * $, Ot = Et * -ct + Ot * $, Bt = Yt * -ct + Bt * $, fe = ke * -ct + fe * $, Pt = Ct, Et = ce, Yt = re), J = th(-yt, Bt), x = J * vl, J && ($ = Math.cos(-J), ct = Math.sin(-J), Ct = It * $ - Ft * ct, ce = et * $ - Ot * ct, re = yt * $ - Bt * ct, fe = G * ct + fe * $, It = Ct, et = ce, yt = re), J = th(et, It), E = J * vl, J && ($ = Math.cos(J), ct = Math.sin(J), Ct = It * $ + et * ct, ce = Pt * $ + Et * ct, et = et * $ - It * ct, Et = Et * $ - Pt * ct, It = Ct, Pt = ce), L && Math.abs(L) + Math.abs(E) > 359.9 && (L = E = 0, x = 180 - x), I = In(Math.sqrt(It * It + et * et + yt * yt)), F = In(Math.sqrt(Et * Et + Yt * Yt)), J = th(Pt, Et), M = Math.abs(J) > 2e-4 ? J * vl : 0, b = fe ? 1 / (fe < 0 ? -fe : fe) : 0), p.svg && (Ct = l.getAttribute("transform"), p.forceCSS = l.setAttribute("transform", "") || !Dd(ao(l, yn)), Ct && l.setAttribute("transform", Ct))), Math.abs(M) > 90 && Math.abs(M) < 270 && (u ? (I *= -1, M += E <= 0 ? 180 : -180, E += E <= 0 ? 180 : -180) : (F *= -1, M += M <= 0 ? 180 : -180)), o = o || p.uncache, p.x = C - ((p.xPercent = C && (!o && p.xPercent || (Math.round(l.offsetWidth / 2) === Math.round(-C) ? -50 : 0))) ? l.offsetWidth * p.xPercent / 100 : 0) + m, p.y = z - ((p.yPercent = z && (!o && p.yPercent || (Math.round(l.offsetHeight / 2) === Math.round(-z) ? -50 : 0))) ? l.offsetHeight * p.yPercent / 100 : 0) + m, p.z = B + m, p.scaleX = In(I), p.scaleY = In(F), p.rotation = In(E) + _, p.rotationX = In(L) + _, p.rotationY = In(x) + _, p.skewX = M + _, p.skewY = R + _, p.transformPerspective = b + m, (p.zOrigin = parseFloat(S.split(" ")[2]) || !o && p.zOrigin || 0) && (d[Fr] = Wu(S)), p.xOffset = p.yOffset = 0, p.force3D = ts.force3D, p.renderTransform = p.svg ? s1 : Ld ? zd : r1, p.uncache = 0, p;
}, Wu = function(l) {
  return (l = l.split(" "))[0] + " " + l[1];
}, zc = function(l, o, p) {
  var d = cr(o);
  return In(parseFloat(o) + parseFloat(Oa(l, "x", p + "px", d))) + d;
}, r1 = function(l, o) {
  o.z = "0px", o.rotationY = o.rotationX = "0deg", o.force3D = 0, zd(l, o);
}, ml = "0deg", Uh = "0px", gl = ") ", zd = function(l, o) {
  var p = o || this, d = p.xPercent, u = p.yPercent, m = p.x, _ = p.y, T = p.z, S = p.rotation, C = p.rotationY, z = p.rotationX, B = p.skewX, I = p.skewY, F = p.scaleX, E = p.scaleY, L = p.transformPerspective, x = p.force3D, M = p.target, R = p.zOrigin, b = "", U = x === "auto" && l && l !== 1 || x === !0;
  if (R && (z !== ml || C !== ml)) {
    var N = parseFloat(C) * sh, j = Math.sin(N), J = Math.cos(N), $;
    N = parseFloat(z) * sh, $ = Math.cos(N), m = zc(M, m, j * $ * -R), _ = zc(M, _, -Math.sin(N) * -R), T = zc(M, T, J * $ * -R + R);
  }
  L !== Uh && (b += "perspective(" + L + gl), (d || u) && (b += "translate(" + d + "%, " + u + "%) "), (U || m !== Uh || _ !== Uh || T !== Uh) && (b += T !== Uh || U ? "translate3d(" + m + ", " + _ + ", " + T + ") " : "translate(" + m + ", " + _ + gl), S !== ml && (b += "rotate(" + S + gl), C !== ml && (b += "rotateY(" + C + gl), z !== ml && (b += "rotateX(" + z + gl), (B !== ml || I !== ml) && (b += "skew(" + B + ", " + I + gl), (F !== 1 || E !== 1) && (b += "scale(" + F + ", " + E + gl), M.style[yn] = b || "translate(0, 0)";
}, s1 = function(l, o) {
  var p = o || this, d = p.xPercent, u = p.yPercent, m = p.x, _ = p.y, T = p.rotation, S = p.skewX, C = p.skewY, z = p.scaleX, B = p.scaleY, I = p.target, F = p.xOrigin, E = p.yOrigin, L = p.xOffset, x = p.yOffset, M = p.forceCSS, R = parseFloat(m), b = parseFloat(_), U, N, j, J, $;
  T = parseFloat(T), S = parseFloat(S), C = parseFloat(C), C && (C = parseFloat(C), S += C, T += C), T || S ? (T *= sh, S *= sh, U = Math.cos(T) * z, N = Math.sin(T) * z, j = Math.sin(T - S) * -B, J = Math.cos(T - S) * B, S && (C *= sh, $ = Math.tan(S - C), $ = Math.sqrt(1 + $ * $), j *= $, J *= $, C && ($ = Math.tan(C), $ = Math.sqrt(1 + $ * $), U *= $, N *= $)), U = In(U), N = In(N), j = In(j), J = In(J)) : (U = z, J = B, N = j = 0), (R && !~(m + "").indexOf("px") || b && !~(_ + "").indexOf("px")) && (R = Oa(I, "x", m, "px"), b = Oa(I, "y", _, "px")), (F || E || L || x) && (R = In(R + F - (F * U + E * j) + L), b = In(b + E - (F * N + E * J) + x)), (d || u) && ($ = I.getBBox(), R = In(R + d / 100 * $.width), b = In(b + u / 100 * $.height)), $ = "matrix(" + U + "," + N + "," + j + "," + J + "," + R + "," + b + ")", I.setAttribute("transform", $), M && (I.style[yn] = $);
}, o1 = function(l, o, p, d, u) {
  var m = 360, _ = Yn(u), T = parseFloat(u) * (_ && ~u.indexOf("rad") ? vl : 1), S = T - d, C = d + S + "deg", z, B;
  return _ && (z = u.split("_")[1], z === "short" && (S %= m, S !== S % (m / 2) && (S += S < 0 ? m : -m)), z === "cw" && S < 0 ? S = (S + m * bp) % m - ~~(S / m) * m : z === "ccw" && S > 0 && (S = (S - m * bp) % m - ~~(S / m) * m)), l._pt = B = new Nr(l._pt, o, p, d, S, Vy), B.e = C, B.u = "deg", l._props.push(p), B;
}, Op = function(l, o) {
  for (var p in o)
    l[p] = o[p];
  return l;
}, a1 = function(l, o, p) {
  var d = Op({}, p._gsap), u = "perspective,force3D,transformOrigin,svgOrigin", m = p.style, _, T, S, C, z, B, I, F;
  d.svg ? (S = p.getAttribute("transform"), p.setAttribute("transform", ""), m[yn] = o, _ = Kh(p, 1), Sl(p, yn), p.setAttribute("transform", S)) : (S = getComputedStyle(p)[yn], m[yn] = o, _ = Kh(p, 1), m[yn] = S);
  for (T in jo)
    S = d[T], C = _[T], S !== C && u.indexOf(T) < 0 && (I = cr(S), F = cr(C), z = I !== F ? Oa(p, T, S, F) : parseFloat(S), B = parseFloat(C), l._pt = new Nr(l._pt, _, T, z, B - z, Zc), l._pt.u = F || 0, l._props.push(T));
  Op(_, d);
};
Br("padding,margin,Width,Radius", function(w, l) {
  var o = "Top", p = "Right", d = "Bottom", u = "Left", m = (l < 3 ? [o, p, d, u] : [o + u, o + p, d + p, d + u]).map(function(_) {
    return l < 2 ? w + _ : "border" + _ + w;
  });
  Vu[l > 1 ? "border" + w : w] = function(_, T, S, C, z) {
    var B, I;
    if (arguments.length < 4)
      return B = m.map(function(F) {
        return Vo(_, F, S);
      }), I = B.join(" "), I.split(B[0]).length === 5 ? B[0] : I;
    B = (C + "").split(" "), I = {}, m.forEach(function(F, E) {
      return I[F] = B[E] = B[E] || B[(E - 1) / 2 | 0];
    }), _.init(T, I, z);
  };
});
var kd = {
  name: "css",
  register: $c,
  targetTest: function(l) {
    return l.style && l.nodeType;
  },
  init: function(l, o, p, d, u) {
    var m = this._props, _ = l.style, T = p.vars.startAt, S, C, z, B, I, F, E, L, x, M, R, b, U, N, j, J;
    vf || $c(), this.styles = this.styles || Pd(l), J = this.styles.props, this.tween = p;
    for (E in o)
      if (E !== "autoRound" && (C = o[E], !($r[E] && _d(E, o, p, d, l, u)))) {
        if (I = typeof C, F = Vu[E], I === "function" && (C = C.call(p, d, l, u), I = typeof C), I === "string" && ~C.indexOf("random(") && (C = Yh(C)), F)
          F(this, l, E, C, p) && (j = 1);
        else if (E.substr(0, 2) === "--")
          S = (getComputedStyle(l).getPropertyValue(E) + "").trim(), C += "", La.lastIndex = 0, La.test(S) || (L = cr(S), x = cr(C)), x ? L !== x && (S = Oa(l, E, S, x) + x) : L && (C += L), this.add(_, "setProperty", S, C, d, u, 0, 0, E), m.push(E), J.push(E, 0, _[E]);
        else if (I !== "undefined") {
          if (T && E in T ? (S = typeof T[E] == "function" ? T[E].call(p, d, l, u) : T[E], Yn(S) && ~S.indexOf("random(") && (S = Yh(S)), cr(S + "") || S === "auto" || (S += ts.units[E] || cr(Vo(l, E)) || ""), (S + "").charAt(1) === "=" && (S = Vo(l, E))) : S = Vo(l, E), B = parseFloat(S), M = I === "string" && C.charAt(1) === "=" && C.substr(0, 2), M && (C = C.substr(2)), z = parseFloat(C), E in oo && (E === "autoAlpha" && (B === 1 && Vo(l, "visibility") === "hidden" && z && (B = 0), J.push("visibility", 0, _.visibility), Ca(this, _, "visibility", B ? "inherit" : "hidden", z ? "inherit" : "hidden", !z)), E !== "scale" && E !== "transform" && (E = oo[E], ~E.indexOf(",") && (E = E.split(",")[0]))), R = E in jo, R) {
            if (this.styles.save(E), b || (U = l._gsap, U.renderTransform && !o.parseTransform || Kh(l, o.parseTransform), N = o.smoothOrigin !== !1 && U.smooth, b = this._pt = new Nr(this._pt, _, yn, 0, 1, U.renderTransform, U, 0, -1), b.dep = 1), E === "scale")
              this._pt = new Nr(this._pt, U, "scaleY", U.scaleY, (M ? nh(U.scaleY, M + z) : z) - U.scaleY || 0, Zc), this._pt.u = 0, m.push("scaleY", E), E += "X";
            else if (E === "transformOrigin") {
              J.push(Fr, 0, _[Fr]), C = i1(C), U.svg ? Kc(l, C, 0, N, 0, this) : (x = parseFloat(C.split(" ")[2]) || 0, x !== U.zOrigin && Ca(this, U, "zOrigin", U.zOrigin, x), Ca(this, _, E, Wu(S), Wu(C)));
              continue;
            } else if (E === "svgOrigin") {
              Kc(l, C, 1, N, 0, this);
              continue;
            } else if (E in Id) {
              o1(this, U, E, B, M ? nh(B, M + C) : C);
              continue;
            } else if (E === "smoothOrigin") {
              Ca(this, U, "smooth", U.smooth, C);
              continue;
            } else if (E === "force3D") {
              U[E] = C;
              continue;
            } else if (E === "transform") {
              a1(this, C, l);
              continue;
            }
          } else
            E in _ || (E = uh(E) || E);
          if (R || (z || z === 0) && (B || B === 0) && !Hy.test(C) && E in _)
            L = (S + "").substr((B + "").length), z || (z = 0), x = cr(C) || (E in ts.units ? ts.units[E] : L), L !== x && (B = Oa(l, E, S, x)), this._pt = new Nr(this._pt, R ? U : _, E, B, (M ? nh(B, M + z) : z) - B, !R && (x === "px" || E === "zIndex") && o.autoRound !== !1 ? jy : Zc), this._pt.u = x || 0, L !== x && x !== "%" && (this._pt.b = S, this._pt.r = Wy);
          else if (E in _)
            e1.call(this, l, E, S, M ? M + C : C);
          else if (E in l)
            this.add(l, E, S || l[E], M ? M + C : C, d, u);
          else if (E !== "parseTransform") {
            lf(E, C);
            continue;
          }
          R || (E in _ ? J.push(E, 0, _[E]) : J.push(E, 1, S || l[E])), m.push(E);
        }
      }
    j && Sd(this);
  },
  render: function(l, o) {
    if (o.tween._time || !_f())
      for (var p = o._pt; p; )
        p.r(l, p.d), p = p._next;
    else
      o.styles.revert();
  },
  get: Vo,
  aliases: oo,
  getSetter: function(l, o, p) {
    var d = oo[o];
    return d && d.indexOf(",") < 0 && (o = d), o in jo && o !== Fr && (l._gsap.x || Vo(l, "x")) ? p && Ep === p ? o === "scale" ? Zy : Yy : (Ep = p || {}) && (o === "scale" ? Jy : $y) : l.style && !sf(l.style[o]) ? Xy : ~o.indexOf("-") ? qy : mf(l, o);
  },
  core: {
    _removeProperty: Sl,
    _getMatrix: xf
  }
};
Ur.utils.checkPrefix = uh;
Ur.core.getStyleSaver = Pd;
(function(w, l, o, p) {
  var d = Br(w + "," + l + "," + o, function(u) {
    jo[u] = 1;
  });
  Br(l, function(u) {
    ts.units[u] = "deg", Id[u] = 1;
  }), oo[d[13]] = w + "," + l, Br(p, function(u) {
    var m = u.split(":");
    oo[m[1]] = d[m[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Br("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(w) {
  ts.units[w] = "px";
});
Ur.registerPlugin(kd);
var Qc = Ur.registerPlugin(kd) || Ur;
Qc.core.Tween;
class _1 {
  constructor(l, o = !1) {
    window.mars3d ? (this.Cesium = window.mars3d.Cesium, this.DynamicMaskingArr = [], this.DynamicMaskingStyle = [], this.canvasClientWidth = l.viewer.canvas.clientWidth, this.canvasClientHeight = l.viewer.canvas.clientHeight, this.oldSet = /* @__PURE__ */ new Set(), this.tweenMap = /* @__PURE__ */ new Map(), this.isDynamicMasking = o) : console.error("未引入指定插件");
  }
  /**
   * 添加动态遮蔽数据
   * item 是地图对象
   * data 是数据 (地图对象隐藏的时候有些数据有问题 辅助作用)
   */
  add(l, o) {
    let p = l.options.symbol.styleOptions.label.font_size, d = l.options.vectorId, u = Number(p) * 1.4, m = Number(p) * 1.8, _ = l.options.symbol.styleOptions.label, { color: T, outlineColor: S, backgroundColor: C } = _;
    l.eachGraphic((z) => {
      z.style.label && this.DynamicMaskingArr.push({
        id: d,
        uid: z.id,
        position: z._getLablePosition(),
        label: z.name,
        width: u * z.name.length,
        height: m,
        color: T,
        outline: o.label.outline,
        outlineColor: S,
        background: o.label.background,
        backgroundColor: C,
        dynamicMaskingColor: {
          backgroundColor: this.Cesium.Color.fromCssColorString(
            o.label.backgroundColor
          ),
          color: this.Cesium.Color.fromCssColorString(o.label.color),
          outlineColor: this.Cesium.Color.fromCssColorString(
            o.label.outlineColor
          )
        }
      });
    }), this.DynamicMaskingStyle.push({
      vectorId: l.options.vectorId,
      outline: o.label.outline,
      background: o.label.background,
      color: this.Cesium.Color.fromCssColorString(o.label.color),
      backgroundColor: this.Cesium.Color.fromCssColorString(
        o.label.backgroundColor
      ),
      outlineColor: this.Cesium.Color.fromCssColorString(
        o.label.outlineColor
      )
    }), this.oldSet = /* @__PURE__ */ new Set(), this.tweenMap = /* @__PURE__ */ new Map();
  }
  /**
   * 移除动态遮蔽数据
   */
  remove(l) {
    this.DynamicMaskingArr = this.DynamicMaskingArr.filter(
      (o) => o.id !== l
    ), this.DynamicMaskingStyle = this.DynamicMaskingStyle.filter(
      (o) => o.vectorId !== l
    ), this.oldSet = /* @__PURE__ */ new Set(), this.tweenMap = /* @__PURE__ */ new Map();
  }
  /**
   * 修改数据
   * 主要就是修改
   * outline
   * background
   * color
   * outlineColor
   * backgroundColor
   * 用于渐变
   */
  modify(l, o) {
    let { label: p } = o;
    if (p) {
      let { color: d, outline: u, outlineColor: m, background: _, backgroundColor: T } = p;
      this.DynamicMaskingArr.forEach((S) => {
        S.id === l && (d != null && (S.color = this.Cesium.Color.fromCssColorString(d), S.dynamicMaskingColor.color = this.Cesium.Color.fromCssColorString(d)), u != null && (S.outline = u), m != null && (S.outlineColor = this.Cesium.Color.fromCssColorString(m), S.dynamicMaskingColor.outlineColor = this.Cesium.Color.fromCssColorString(m)), _ != null && (S.background = _), T != null && (S.backgroundColor = this.Cesium.Color.fromCssColorString(T), S.dynamicMaskingColor.backgroundColor = this.Cesium.Color.fromCssColorString(T)));
      });
    }
  }
  /**
   * 获取边界值 生成包围盒
   */
  getBoundingRectangle(l) {
    var o = this.Cesium.SceneTransforms.wgs84ToWindowCoordinates(
      window.map.viewer.scene,
      l.position
    );
    return o !== void 0 ? new this.Cesium.BoundingRectangle(
      o.x,
      o.y,
      l.width,
      l.height
    ) : new this.Cesium.BoundingRectangle(0, 0, 1, 1);
  }
  getNonIntersectingRectangles() {
    let l = [];
    for (var o = 0; o < this.DynamicMaskingArr.length; o++) {
      let d = !1, u = this.DynamicMaskingArr[o], m, _, T;
      if (_ = this.getBoundingRectangle(u), !(_.x < 0 || _.x > this.canvasClientWidth || _.y < 0 || _.y > this.canvasClientHeight))
        if (l.length === 0) {
          l.push(o);
          continue;
        } else {
          for (var p = 0; p < l.length; p++)
            if (m = this.DynamicMaskingArr[l[p]], T = this.getBoundingRectangle(m), this.Cesium.Intersect.OUTSIDE !== this.Cesium.BoundingRectangle.intersect(_, T)) {
              d = !0;
              break;
            }
          d || l.push(o);
        }
    }
    return new Set(l);
  }
  /**
   * 动态遮蔽主要逻辑
   */
  ifShow() {
    if (this.isDynamicMasking) {
      let o = {
        color: 1e-3,
        outlineColor: 1e-3,
        backgroundColor: 1e-3
      }, p = {
        color: 1,
        outlineColor: 1,
        backgroundColor: 1
      }, d = this.getNonIntersectingRectangles(), u = new Set([...this.oldSet].filter((_) => !d.has(_))), m = new Set([...d].filter((_) => !this.oldSet.has(_)));
      for (let _ of u)
        if (this.DynamicMaskingArr[_]) {
          if (this.tweenMap.has(_)) {
            var l = this.tweenMap.get(_);
            l.kill(), this.tweenMap.delete(_);
          }
          var l = Qc.to(p, {
            duration: 0.2,
            color: 0,
            outlineColor: 0,
            backgroundColor: 0,
            onUpdate: () => {
              var S, C;
              var T = this.DynamicMaskingArr[_];
              T.backgroundColor.alpha = p.backgroundColor, T.color.alpha = p.color, T.outlineColor.alpha = p.outlineColor, (C = (S = window.map.getLayer(T.id, "vectorId")) == null ? void 0 : S.getGraphicByAttr(T.uid)) == null || C.setStyle({
                label: {
                  show: !1,
                  outline: !1,
                  background: !1
                }
              });
            }
          });
          this.tweenMap.set(_, l);
        }
      for (let _ of m)
        if (this.DynamicMaskingArr[_]) {
          if (this.tweenMap.has(_)) {
            var l = this.tweenMap.get(_);
            l.kill(), this.tweenMap.delete(_);
          }
          let T = this.DynamicMaskingArr[_], { backgroundColor: S, color: C, outlineColor: z } = T.dynamicMaskingColor;
          var l = Qc.to(o, {
            duration: 0.8 + Math.random(),
            color: C.alpha,
            outlineColor: z.alpha,
            backgroundColor: S.alpha,
            onUpdate: () => {
              var I, F;
              T.backgroundColor.alpha = o.backgroundColor, T.color.alpha = o.color, T.outlineColor.alpha = o.outlineColor, (F = (I = window.map.getLayer(T.id, "vectorId")) == null ? void 0 : I.getGraphicByAttr(T.uid)) == null || F.setStyle({
                label: {
                  show: !0,
                  outline: T.outline,
                  background: T.background,
                  color: T.color,
                  outlineColor: T.outlineColor,
                  backgroundColor: T.backgroundColor
                }
              });
            }
          });
          this.tweenMap.set(_, l);
        }
      this.oldSet = d;
    }
  }
  /**
   * 切换动态避让
   * @returns { any }
   */
  switchDynamicMasking(l) {
    if (l)
      window.map.getLayers().forEach((o) => {
        var p;
        if ((p = o.options) != null && p.vectorId) {
          let { color: d, outlineColor: u, backgroundColor: m } = o.options.symbol.styleOptions.label;
          o.eachGraphic((_) => {
            _.setStyle({
              label: {
                color: d.withAlpha(0),
                outlineColor: u.withAlpha(1e-3),
                backgroundColor: m.withAlpha(1e-3),
                show: !1,
                background: !1,
                outline: !1
              }
            });
          });
        }
      });
    else if (this.DynamicMaskingStyle.length > 0) {
      let o;
      this.DynamicMaskingStyle.forEach((p) => {
        let {
          color: d,
          outline: u,
          outlineColor: m,
          background: _,
          backgroundColor: T,
          vectorId: S
        } = p;
        o = window.map.getLayer(S, "vectorId"), o && o.eachGraphic((C) => {
          C.setStyle({
            label: {
              color: d,
              outlineColor: m,
              backgroundColor: T,
              show: !0,
              background: _,
              outline: u
            }
          });
        });
      });
    }
    this.isDynamicMasking = l, window.bimVector.switchDynamicMasking(l);
  }
}
const l1 = [x_, H_], y1 = {
  continuation: null,
  mapModali: null,
  install(w) {
    if (l1.forEach((m, _) => {
      w.component(m.name, m);
    }), this.continuation) {
      w.config.globalProperties.$continuation = this.continuation;
      return;
    }
    let l = gp(R_), o = document.createElement("div"), p = document.body;
    if (p.appendChild(o), this.loading = l.mount(o), w.config.globalProperties.$loading = this.loading, window.$continuation = this.loading, this.mapModali) {
      w.config.globalProperties.$mapModali = this.mapModali;
      return;
    }
    let d = gp(z_), u = document.createElement("div");
    p.appendChild(u), this.mapModali = d.mount(u), w.config.globalProperties.$mapModali = this.mapModali, window.$mapModali = this.mapModali;
  }
};
export {
  H_ as BimBackgroundPlate,
  R_ as BimCutscenes,
  d1 as BimElevationImage,
  g1 as BimEntity,
  c1 as BimModel,
  p1 as BimTerrainProvider,
  f1 as BimVector,
  x_ as Button,
  y1 as ChbimPlugins,
  _1 as DynamicMasking,
  z_ as MapModali,
  v1 as PanoramicView,
  m1 as ViewShed
};
