var Mm = Object.defineProperty;
var Sm = (T, J, p) => J in T ? Mm(T, J, { enumerable: !0, configurable: !0, writable: !0, value: p }) : T[J] = p;
var kh = (T, J, p) => (Sm(T, typeof J != "symbol" ? J + "" : J, p), p);
import { openBlock as sh, createElementBlock as ah, normalizeClass as Fu, renderSlot as Gu, defineComponent as Gh, ref as Uh, onMounted as Hh, createElementVNode as lr, toDisplayString as Em, createApp as Uu } from "vue";
const bm = (T, J) => {
  const p = T.__vccOpts || T;
  for (const [$, G] of J)
    p[$] = G;
  return p;
}, Am = {
  name: "MukButton"
}, Cm = /* @__PURE__ */ Object.assign(Am, {
  props: {
    size: {
      type: String,
      default: "middle"
    },
    type: {
      type: String,
      default: "default"
    }
  },
  setup(T) {
    return (J, p) => (sh(), ah("button", {
      class: Fu(["muk-btn", [T.size, T.type]])
    }, [
      Gu(J.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), Pm = /* @__PURE__ */ bm(Cm, [["__scopeId", "data-v-0e6d93cd"]]);
class Lm {
  constructor() {
    this.dom = {
      mask: document.querySelector(".js-mask"),
      slices: [...document.querySelectorAll(".js-mask__slice")],
      lines: [...document.querySelectorAll(".js-mask-line")],
      logo: document.querySelector(".js-logo"),
      titles: [...document.querySelectorAll(".js-transition-title")]
    }, this.tl = null, this.state = !1, this.init();
  }
  resetScroll() {
    window.scrollTo(0, 0);
  }
  createTimeline() {
    this.tl = new TimelineMax({
      paused: !0,
      onComplete: () => {
        this.state = !1;
      }
    }), this.tl.set(this.dom.titles, {
      yPercent: 0
    }).set(this.dom.mask, {
      autoAlpha: 1
    }).staggerFromTo(
      this.dom.slices,
      1.5,
      {
        xPercent: 100
      },
      {
        xPercent: 0,
        ease: Expo.easeInOut
      },
      -0.075
    ).addCallback(this.resetScroll.bind(this)).addLabel("loaderStart").set(this.dom.titles, {
      yPercent: -100
    }).set([this.dom.lines[0], this.dom.logo], {
      autoAlpha: 1
    }).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: -100,
        rotation: 10
      },
      {
        yPercent: 0,
        rotation: 0,
        ease: Expo.easeOut
      }
    ).addLabel("intermediateFrame").staggerFromTo(
      this.dom.lines,
      0.5,
      {
        scaleX: 0
      },
      {
        scaleX: 1,
        ease: Expo.easeInOut
      },
      0.75,
      "-=1"
    ).set(this.dom.lines, {
      transformOrigin: "right"
    }).fromTo(
      this.dom.lines[0],
      1,
      {
        scaleX: 1
      },
      {
        scaleX: 0,
        ease: Expo.easeInOut
      }
    ).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: 0
      },
      {
        yPercent: 105,
        ease: Expo.easeOut
      },
      "-=1"
    ).staggerFromTo(
      this.dom.slices,
      0.5,
      {
        xPercent: 0
      },
      {
        xPercent: 100,
        ease: Expo.easeInOut
      },
      0.075
    ).set(this.dom.mask, {
      autoAlpha: 0
    }).addLabel("imagesStart", "-=0.85").staggerFromTo(
      this.dom.titles,
      1.5,
      {
        yPercent: 100
      },
      {
        yPercent: 0,
        ease: Expo.easeInOut
      },
      0.05,
      "imagesStart"
    ).addLabel("loaderEnd");
  }
  continuation() {
    this.init(), this.resetScroll(), this.tl.tweenFromTo("loaderStart", "loaderEnd");
  }
  show() {
    this.init(), this.tl.tweenFromTo("loaderStart", "intermediateFrame");
  }
  hide() {
    this.resetScroll(), this.tl.tweenFromTo("intermediateFrame", "loaderEnd");
  }
  init() {
    document.querySelector(".mask-line.js-mask-line") && document.querySelector(".mask-line.js-mask-line").removeAttribute("style"), document.querySelector(".mask-line__inner.js-mask-line") && document.querySelector(".mask-line__inner.js-mask-line").removeAttribute("style"), this.createTimeline();
  }
}
const Rm = { class: "mask js-mask" }, Im = /* @__PURE__ */ lr("div", { class: "mask__slice js-mask__slice" }, null, -1), Om = /* @__PURE__ */ lr("div", { class: "mask__slice js-mask__slice" }, null, -1), Dm = /* @__PURE__ */ lr("div", { class: "mask__slice js-mask__slice" }, null, -1), zm = { class: "mask__inner" }, Bm = { class: "logo logo--mask" }, Nm = {
  class: "js-logo",
  style: { color: "#fff" }
}, km = /* @__PURE__ */ lr("div", { class: "mask-line js-mask-line" }, [
  /* @__PURE__ */ lr("div", { class: "mask-line__inner js-mask-line" })
], -1), Um = {
  name: "BimCutscenes"
}, Fm = /* @__PURE__ */ Gh({
  ...Um,
  props: {
    text: {
      type: String,
      default: "CHBIM云平台"
    }
  },
  setup(T, { expose: J }) {
    const p = Uh(null), $ = () => {
      p.value === null && (p.value = new Lm());
    }, G = () => {
      $(), p.value.continuation();
    };
    return Hh(() => {
      $();
    }), J({
      continuation: G
    }), (m, C) => (sh(), ah("div", Rm, [
      Im,
      Om,
      Dm,
      lr("div", zm, [
        lr("figure", Bm, [
          lr("p", Nm, Em(T.text), 1)
        ]),
        km
      ])
    ]));
  }
});
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
var sn = typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window;
(sn._gsQueue || (sn._gsQueue = [])).push(function() {
  sn._gsDefine(
    "TweenMax",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(T, J, p) {
      var $ = function(b) {
        var A, d = [], g = b.length;
        for (A = 0; A !== g; d.push(b[A++]))
          ;
        return d;
      }, G = function(b, A, d) {
        var g, M, x = b.cycle;
        for (g in x)
          M = x[g], b[g] = typeof M == "function" ? M(d, A[d]) : M[d % M.length];
        delete b.cycle;
      }, m = function(b, A, d) {
        p.call(this, b, A, d), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = m.prototype.render;
      }, C = 1e-10, O = p._internals, E = O.isSelector, U = O.isArray, Y = m.prototype = p.to({}, 0.1, {}), H = [];
      m.version = "2.0.2", Y.constructor = m, Y.kill()._gc = !1, m.killTweensOf = m.killDelayedCallsTo = p.killTweensOf, m.getTweensOf = p.getTweensOf, m.lagSmoothing = p.lagSmoothing, m.ticker = p.ticker, m.render = p.render, Y.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), p.prototype.invalidate.call(this);
      }, Y.updateTo = function(b, A) {
        var d, g = this.ratio, M = this.vars.immediateRender || b.immediateRender;
        A && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
        for (d in b)
          this.vars[d] = b[d];
        if (this._initted || M) {
          if (A)
            this._initted = !1, M && this.render(0, !0, !0);
          else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && p._onPluginEvent("_onDisable", this), this._time / this._duration > 0.998) {
            var x = this._totalTime;
            this.render(0, !0, !1), this._initted = !1, this.render(x, !0, !1);
          } else if (this._initted = !1, this._init(), this._time > 0 || M)
            for (var F, z = 1 / (1 - g), V = this._firstPT; V; )
              F = V.s + V.c, V.c *= z, V.s = F - V.c, V = V._next;
        }
        return this;
      }, Y.render = function(b, A, d) {
        this._initted || this._duration === 0 && this.vars.repeat && this.invalidate();
        var g, M, x, F, z, V, ht, ft, gt, zt = this._dirty ? this.totalDuration() : this._totalDuration, lt = this._time, Et = this._totalTime, D = this._cycle, Bt = this._duration, Ct = this._rawPrevTime;
        if (b >= zt - 1e-7 && b >= 0 ? (this._totalTime = zt, this._cycle = this._repeat, this._yoyo && 1 & this._cycle ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = Bt, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (g = !0, M = "onComplete", d = d || this._timeline.autoRemoveChildren), Bt === 0 && (this._initted || !this.vars.lazy || d) && (this._startTime === this._timeline._duration && (b = 0), (0 > Ct || 0 >= b && b >= -1e-7 || Ct === C && this.data !== "isPause") && Ct !== b && (d = !0, Ct > C && (M = "onReverseComplete")), this._rawPrevTime = ft = !A || b || Ct === b ? b : C)) : 1e-7 > b ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (Et !== 0 || Bt === 0 && Ct > 0) && (M = "onReverseComplete", g = this._reversed), 0 > b && (this._active = !1, Bt === 0 && (this._initted || !this.vars.lazy || d) && (Ct >= 0 && (d = !0), this._rawPrevTime = ft = !A || b || Ct === b ? b : C)), this._initted || (d = !0)) : (this._totalTime = this._time = b, this._repeat !== 0 && (F = Bt + this._repeatDelay, this._cycle = this._totalTime / F >> 0, this._cycle !== 0 && this._cycle === this._totalTime / F && b >= Et && this._cycle--, this._time = this._totalTime - this._cycle * F, this._yoyo && 1 & this._cycle && (this._time = Bt - this._time, gt = this._yoyoEase || this.vars.yoyoEase, gt && (this._yoyoEase || (gt !== !0 || this._initted ? this._yoyoEase = gt = gt === !0 ? this._ease : gt instanceof Ease ? gt : Ease.map[gt] : (gt = this.vars.ease, this._yoyoEase = gt = gt ? gt instanceof Ease ? gt : typeof gt == "function" ? new Ease(gt, this.vars.easeParams) : Ease.map[gt] || p.defaultEase : p.defaultEase)), this.ratio = gt ? 1 - gt.getRatio((Bt - this._time) / Bt) : 0)), this._time > Bt ? this._time = Bt : this._time < 0 && (this._time = 0)), this._easeType && !gt ? (z = this._time / Bt, V = this._easeType, ht = this._easePower, (V === 1 || V === 3 && z >= 0.5) && (z = 1 - z), V === 3 && (z *= 2), ht === 1 ? z *= z : ht === 2 ? z *= z * z : ht === 3 ? z *= z * z * z : ht === 4 && (z *= z * z * z * z), V === 1 ? this.ratio = 1 - z : V === 2 ? this.ratio = z : this._time / Bt < 0.5 ? this.ratio = z / 2 : this.ratio = 1 - z / 2) : gt || (this.ratio = this._ease.getRatio(this._time / Bt))), lt === this._time && !d && D === this._cycle)
          return void (Et !== this._totalTime && this._onUpdate && (A || this._callback("onUpdate")));
        if (!this._initted) {
          if (this._init(), !this._initted || this._gc)
            return;
          if (!d && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
            return this._time = lt, this._totalTime = Et, this._rawPrevTime = Ct, this._cycle = D, O.lazyTweens.push(this), void (this._lazy = [b, A]);
          !this._time || g || gt ? g && this._ease._calcEnd && !gt && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / Bt);
        }
        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== lt && b >= 0 && (this._active = !0), Et === 0 && (this._initted === 2 && b > 0 && this._init(), this._startAt && (b >= 0 ? this._startAt.render(b, !0, d) : M || (M = "_dummyGS")), this.vars.onStart && (this._totalTime !== 0 || Bt === 0) && (A || this._callback("onStart"))), x = this._firstPT; x; )
          x.f ? x.t[x.p](x.c * this.ratio + x.s) : x.t[x.p] = x.c * this.ratio + x.s, x = x._next;
        this._onUpdate && (0 > b && this._startAt && this._startTime && this._startAt.render(b, !0, d), A || (this._totalTime !== Et || M) && this._callback("onUpdate")), this._cycle !== D && (A || this._gc || this.vars.onRepeat && this._callback("onRepeat")), M && (!this._gc || d) && (0 > b && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(b, !0, d), g && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !A && this.vars[M] && this._callback(M), Bt === 0 && this._rawPrevTime === C && ft !== C && (this._rawPrevTime = 0));
      }, m.to = function(b, A, d) {
        return new m(b, A, d);
      }, m.from = function(b, A, d) {
        return d.runBackwards = !0, d.immediateRender = d.immediateRender != 0, new m(b, A, d);
      }, m.fromTo = function(b, A, d, g) {
        return g.startAt = d, g.immediateRender = g.immediateRender != 0 && d.immediateRender != 0, new m(b, A, g);
      }, m.staggerTo = m.allTo = function(b, A, d, g, M, x, F) {
        g = g || 0;
        var z, V, ht, ft, gt = 0, zt = [], lt = function() {
          d.onComplete && d.onComplete.apply(d.onCompleteScope || this, arguments), M.apply(F || d.callbackScope || this, x || H);
        }, Et = d.cycle, D = d.startAt && d.startAt.cycle;
        for (U(b) || (typeof b == "string" && (b = p.selector(b) || b), E(b) && (b = $(b))), b = b || [], 0 > g && (b = $(b), b.reverse(), g *= -1), z = b.length - 1, ht = 0; z >= ht; ht++) {
          V = {};
          for (ft in d)
            V[ft] = d[ft];
          if (Et && (G(V, b, ht), V.duration != null && (A = V.duration, delete V.duration)), D) {
            D = V.startAt = {};
            for (ft in d.startAt)
              D[ft] = d.startAt[ft];
            G(V.startAt, b, ht);
          }
          V.delay = gt + (V.delay || 0), ht === z && M && (V.onComplete = lt), zt[ht] = new m(b[ht], A, V), gt += g;
        }
        return zt;
      }, m.staggerFrom = m.allFrom = function(b, A, d, g, M, x, F) {
        return d.runBackwards = !0, d.immediateRender = d.immediateRender != 0, m.staggerTo(b, A, d, g, M, x, F);
      }, m.staggerFromTo = m.allFromTo = function(b, A, d, g, M, x, F, z) {
        return g.startAt = d, g.immediateRender = g.immediateRender != 0 && d.immediateRender != 0, m.staggerTo(b, A, g, M, x, F, z);
      }, m.delayedCall = function(b, A, d, g, M) {
        return new m(A, 0, {
          delay: b,
          onComplete: A,
          onCompleteParams: d,
          callbackScope: g,
          onReverseComplete: A,
          onReverseCompleteParams: d,
          immediateRender: !1,
          useFrames: M,
          overwrite: 0
        });
      }, m.set = function(b, A) {
        return new m(b, 0, A);
      }, m.isTweening = function(b) {
        return p.getTweensOf(b, !0).length > 0;
      };
      var K = function(b, A) {
        for (var d = [], g = 0, M = b._first; M; )
          M instanceof p ? d[g++] = M : (A && (d[g++] = M), d = d.concat(K(M, A)), g = d.length), M = M._next;
        return d;
      }, B = m.getAllTweens = function(b) {
        return K(T._rootTimeline, b).concat(K(T._rootFramesTimeline, b));
      };
      m.killAll = function(b, A, d, g) {
        A == null && (A = !0), d == null && (d = !0);
        var M, x, F, z = B(g != 0), V = z.length, ht = A && d && g;
        for (F = 0; V > F; F++)
          x = z[F], (ht || x instanceof J || (M = x.target === x.vars.onComplete) && d || A && !M) && (b ? x.totalTime(x._reversed ? 0 : x.totalDuration()) : x._enabled(!1, !1));
      }, m.killChildTweensOf = function(b, A) {
        if (b != null) {
          var d, g, M, x, F, z = O.tweenLookup;
          if (typeof b == "string" && (b = p.selector(b) || b), E(b) && (b = $(b)), U(b))
            for (x = b.length; --x > -1; )
              m.killChildTweensOf(b[x], A);
          else {
            d = [];
            for (M in z)
              for (g = z[M].target.parentNode; g; )
                g === b && (d = d.concat(z[M].tweens)), g = g.parentNode;
            for (F = d.length, x = 0; F > x; x++)
              A && d[x].totalTime(d[x].totalDuration()), d[x]._enabled(!1, !1);
          }
        }
      };
      var q = function(b, A, d, g) {
        A = A !== !1, d = d !== !1, g = g !== !1;
        for (var M, x, F = B(g), z = A && d && g, V = F.length; --V > -1; )
          x = F[V], (z || x instanceof J || (M = x.target === x.vars.onComplete) && d || A && !M) && x.paused(b);
      };
      return m.pauseAll = function(b, A, d) {
        q(!0, b, A, d);
      }, m.resumeAll = function(b, A, d) {
        q(!1, b, A, d);
      }, m.globalTimeScale = function(b) {
        var A = T._rootTimeline, d = p.ticker.time;
        return arguments.length ? (b = b || C, A._startTime = d - (d - A._startTime) * A._timeScale / b, A = T._rootFramesTimeline, d = p.ticker.frame, A._startTime = d - (d - A._startTime) * A._timeScale / b, A._timeScale = T._rootTimeline._timeScale = b, b) : A._timeScale;
      }, Y.progress = function(b, A) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - b : b) + this._cycle * (this._duration + this._repeatDelay),
          A
        ) : this._time / this.duration();
      }, Y.totalProgress = function(b, A) {
        return arguments.length ? this.totalTime(this.totalDuration() * b, A) : this._totalTime / this.totalDuration();
      }, Y.time = function(b, A) {
        return arguments.length ? (this._dirty && this.totalDuration(), b > this._duration && (b = this._duration), this._yoyo && 1 & this._cycle ? b = this._duration - b + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (b += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(b, A)) : this._time;
      }, Y.duration = function(b) {
        return arguments.length ? T.prototype.duration.call(this, b) : this._duration;
      }, Y.totalDuration = function(b) {
        return arguments.length ? this._repeat === -1 ? this : this.duration(
          (b - this._repeat * this._repeatDelay) / (this._repeat + 1)
        ) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration);
      }, Y.repeat = function(b) {
        return arguments.length ? (this._repeat = b, this._uncache(!0)) : this._repeat;
      }, Y.repeatDelay = function(b) {
        return arguments.length ? (this._repeatDelay = b, this._uncache(!0)) : this._repeatDelay;
      }, Y.yoyo = function(b) {
        return arguments.length ? (this._yoyo = b, this) : this._yoyo;
      }, m;
    },
    !0
  ), sn._gsDefine(
    "TimelineLite",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(T, J, p) {
      var $ = function(d) {
        J.call(this, d), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
        var g, M, x = this.vars;
        for (M in x)
          g = x[M], E(g) && g.join("").indexOf("{self}") !== -1 && (x[M] = this._swapSelfInParams(g));
        E(x.tweens) && this.add(x.tweens, 0, x.align, x.stagger);
      }, G = 1e-10, m = p._internals, C = $._internals = {}, O = m.isSelector, E = m.isArray, U = m.lazyTweens, Y = m.lazyRender, H = sn._gsDefine.globals, K = function(d) {
        var g, M = {};
        for (g in d)
          M[g] = d[g];
        return M;
      }, B = function(d, g, M) {
        var x, F, z = d.cycle;
        for (x in z)
          F = z[x], d[x] = typeof F == "function" ? F(M, g[M]) : F[M % F.length];
        delete d.cycle;
      }, q = C.pauseCallback = function() {
      }, b = function(d) {
        var g, M = [], x = d.length;
        for (g = 0; g !== x; M.push(d[g++]))
          ;
        return M;
      }, A = $.prototype = new J();
      return $.version = "2.0.2", A.constructor = $, A.kill()._gc = A._forcingPlayhead = A._hasPause = !1, A.to = function(d, g, M, x) {
        var F = M.repeat && H.TweenMax || p;
        return g ? this.add(new F(d, g, M), x) : this.set(d, M, x);
      }, A.from = function(d, g, M, x) {
        return this.add((M.repeat && H.TweenMax || p).from(d, g, M), x);
      }, A.fromTo = function(d, g, M, x, F) {
        var z = x.repeat && H.TweenMax || p;
        return g ? this.add(z.fromTo(d, g, M, x), F) : this.set(d, x, F);
      }, A.staggerTo = function(d, g, M, x, F, z, V, ht) {
        var ft, gt, zt = new $({
          onComplete: z,
          onCompleteParams: V,
          callbackScope: ht,
          smoothChildTiming: this.smoothChildTiming
        }), lt = M.cycle;
        for (typeof d == "string" && (d = p.selector(d) || d), d = d || [], O(d) && (d = b(d)), x = x || 0, 0 > x && (d = b(d), d.reverse(), x *= -1), gt = 0; gt < d.length; gt++)
          ft = K(M), ft.startAt && (ft.startAt = K(ft.startAt), ft.startAt.cycle && B(ft.startAt, d, gt)), lt && (B(ft, d, gt), ft.duration != null && (g = ft.duration, delete ft.duration)), zt.to(d[gt], g, ft, gt * x);
        return this.add(zt, F);
      }, A.staggerFrom = function(d, g, M, x, F, z, V, ht) {
        return M.immediateRender = M.immediateRender != 0, M.runBackwards = !0, this.staggerTo(d, g, M, x, F, z, V, ht);
      }, A.staggerFromTo = function(d, g, M, x, F, z, V, ht, ft) {
        return x.startAt = M, x.immediateRender = x.immediateRender != 0 && M.immediateRender != 0, this.staggerTo(d, g, x, F, z, V, ht, ft);
      }, A.call = function(d, g, M, x) {
        return this.add(p.delayedCall(0, d, g, M), x);
      }, A.set = function(d, g, M) {
        return M = this._parseTimeOrLabel(M, 0, !0), g.immediateRender == null && (g.immediateRender = M === this._time && !this._paused), this.add(new p(d, 0, g), M);
      }, $.exportRoot = function(d, g) {
        d = d || {}, d.smoothChildTiming == null && (d.smoothChildTiming = !0);
        var M, x, F, z, V = new $(d), ht = V._timeline;
        for (g == null && (g = !0), ht._remove(V, !0), V._startTime = 0, V._rawPrevTime = V._time = V._totalTime = ht._time, F = ht._first; F; )
          z = F._next, g && F instanceof p && F.target === F.vars.onComplete || (x = F._startTime - F._delay, 0 > x && (M = 1), V.add(F, x)), F = z;
        return ht.add(V, 0), M && V.totalDuration(), V;
      }, A.add = function(d, g, M, x) {
        var F, z, V, ht, ft, gt;
        if (typeof g != "number" && (g = this._parseTimeOrLabel(g, 0, !0, d)), !(d instanceof T)) {
          if (d instanceof Array || d && d.push && E(d)) {
            for (M = M || "normal", x = x || 0, F = g, z = d.length, V = 0; z > V; V++)
              E(ht = d[V]) && (ht = new $({ tweens: ht })), this.add(ht, F), typeof ht != "string" && typeof ht != "function" && (M === "sequence" ? F = ht._startTime + ht.totalDuration() / ht._timeScale : M === "start" && (ht._startTime -= ht.delay())), F += x;
            return this._uncache(!0);
          }
          if (typeof d == "string")
            return this.addLabel(d, g);
          if (typeof d != "function")
            throw "Cannot add " + d + " into the timeline; it is not a tween, timeline, function, or string.";
          d = p.delayedCall(0, d);
        }
        if (J.prototype.add.call(this, d, g), d._time && (F = Math.max(
          0,
          Math.min(
            d.totalDuration(),
            (this.rawTime() - d._startTime) * d._timeScale
          )
        ), Math.abs(F - d._totalTime) > 1e-5 && d.render(F, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
          for (ft = this, gt = ft.rawTime() > d._startTime; ft._timeline; )
            gt && ft._timeline.smoothChildTiming ? ft.totalTime(ft._totalTime, !0) : ft._gc && ft._enabled(!0, !1), ft = ft._timeline;
        return this;
      }, A.remove = function(d) {
        if (d instanceof T) {
          this._remove(d, !1);
          var g = d._timeline = d.vars.useFrames ? T._rootFramesTimeline : T._rootTimeline;
          return d._startTime = (d._paused ? d._pauseTime : g._time) - (d._reversed ? d.totalDuration() - d._totalTime : d._totalTime) / d._timeScale, this;
        }
        if (d instanceof Array || d && d.push && E(d)) {
          for (var M = d.length; --M > -1; )
            this.remove(d[M]);
          return this;
        }
        return typeof d == "string" ? this.removeLabel(d) : this.kill(null, d);
      }, A._remove = function(d, g) {
        J.prototype._remove.call(this, d, g);
        var M = this._last;
        return M ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this;
      }, A.append = function(d, g) {
        return this.add(d, this._parseTimeOrLabel(null, g, !0, d));
      }, A.insert = A.insertMultiple = function(d, g, M, x) {
        return this.add(d, g || 0, M, x);
      }, A.appendMultiple = function(d, g, M, x) {
        return this.add(d, this._parseTimeOrLabel(null, g, !0, d), M, x);
      }, A.addLabel = function(d, g) {
        return this._labels[d] = this._parseTimeOrLabel(g), this;
      }, A.addPause = function(d, g, M, x) {
        var F = p.delayedCall(0, q, M, x || this);
        return F.vars.onComplete = F.vars.onReverseComplete = g, F.data = "isPause", this._hasPause = !0, this.add(F, d);
      }, A.removeLabel = function(d) {
        return delete this._labels[d], this;
      }, A.getLabelTime = function(d) {
        return this._labels[d] != null ? this._labels[d] : -1;
      }, A._parseTimeOrLabel = function(d, g, M, x) {
        var F, z;
        if (x instanceof T && x.timeline === this)
          this.remove(x);
        else if (x && (x instanceof Array || x.push && E(x)))
          for (z = x.length; --z > -1; )
            x[z] instanceof T && x[z].timeline === this && this.remove(x[z]);
        if (F = typeof d != "number" || g ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, typeof g == "string")
          return this._parseTimeOrLabel(
            g,
            M && typeof d == "number" && this._labels[g] == null ? d - F : 0,
            M
          );
        if (g = g || 0, typeof d != "string" || !isNaN(d) && this._labels[d] == null)
          d == null && (d = F);
        else {
          if (z = d.indexOf("="), z === -1)
            return this._labels[d] == null ? M ? this._labels[d] = F + g : g : this._labels[d] + g;
          g = parseInt(d.charAt(z - 1) + "1", 10) * Number(d.substr(z + 1)), d = z > 1 ? this._parseTimeOrLabel(d.substr(0, z - 1), 0, M) : F;
        }
        return Number(d) + g;
      }, A.seek = function(d, g) {
        return this.totalTime(
          typeof d == "number" ? d : this._parseTimeOrLabel(d),
          g !== !1
        );
      }, A.stop = function() {
        return this.paused(!0);
      }, A.gotoAndPlay = function(d, g) {
        return this.play(d, g);
      }, A.gotoAndStop = function(d, g) {
        return this.pause(d, g);
      }, A.render = function(d, g, M) {
        this._gc && this._enabled(!0, !1);
        var x, F, z, V, ht, ft, gt, zt = this._time, lt = this._dirty ? this.totalDuration() : this._totalDuration, Et = this._startTime, D = this._timeScale, Bt = this._paused;
        if (zt !== this._time && (d += this._time - zt), d >= lt - 1e-7 && d >= 0)
          this._totalTime = this._time = lt, this._reversed || this._hasPausedChild() || (F = !0, V = "onComplete", ht = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= d && d >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === G) && this._rawPrevTime !== d && this._first && (ht = !0, this._rawPrevTime > G && (V = "onReverseComplete"))), this._rawPrevTime = this._duration || !g || d || this._rawPrevTime === d ? d : G, d = lt + 1e-4;
        else if (1e-7 > d)
          if (this._totalTime = this._time = 0, (zt !== 0 || this._duration === 0 && this._rawPrevTime !== G && (this._rawPrevTime > 0 || 0 > d && this._rawPrevTime >= 0)) && (V = "onReverseComplete", F = this._reversed), 0 > d)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (ht = F = !0, V = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (ht = !0), this._rawPrevTime = d;
          else {
            if (this._rawPrevTime = this._duration || !g || d || this._rawPrevTime === d ? d : G, d === 0 && F)
              for (x = this._first; x && x._startTime === 0; )
                x._duration || (F = !1), x = x._next;
            d = 0, this._initted || (ht = !0);
          }
        else {
          if (this._hasPause && !this._forcingPlayhead && !g) {
            if (d >= zt)
              for (x = this._first; x && x._startTime <= d && !ft; )
                x._duration || x.data !== "isPause" || x.ratio || x._startTime === 0 && this._rawPrevTime === 0 || (ft = x), x = x._next;
            else
              for (x = this._last; x && x._startTime >= d && !ft; )
                x._duration || x.data === "isPause" && x._rawPrevTime > 0 && (ft = x), x = x._prev;
            ft && (this._time = d = ft._startTime, this._totalTime = d + this._cycle * (this._totalDuration + this._repeatDelay));
          }
          this._totalTime = this._time = this._rawPrevTime = d;
        }
        if (this._time !== zt && this._first || M || ht || ft) {
          if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== zt && d > 0 && (this._active = !0), zt === 0 && this.vars.onStart && (this._time === 0 && this._duration || g || this._callback("onStart")), gt = this._time, gt >= zt)
            for (x = this._first; x && (z = x._next, gt === this._time && (!this._paused || Bt)); )
              (x._active || x._startTime <= gt && !x._paused && !x._gc) && (ft === x && this.pause(), x._reversed ? x.render(
                (x._dirty ? x.totalDuration() : x._totalDuration) - (d - x._startTime) * x._timeScale,
                g,
                M
              ) : x.render((d - x._startTime) * x._timeScale, g, M)), x = z;
          else
            for (x = this._last; x && (z = x._prev, gt === this._time && (!this._paused || Bt)); ) {
              if (x._active || x._startTime <= zt && !x._paused && !x._gc) {
                if (ft === x) {
                  for (ft = x._prev; ft && ft.endTime() > this._time; )
                    ft.render(
                      ft._reversed ? ft.totalDuration() - (d - ft._startTime) * ft._timeScale : (d - ft._startTime) * ft._timeScale,
                      g,
                      M
                    ), ft = ft._prev;
                  ft = null, this.pause();
                }
                x._reversed ? x.render(
                  (x._dirty ? x.totalDuration() : x._totalDuration) - (d - x._startTime) * x._timeScale,
                  g,
                  M
                ) : x.render((d - x._startTime) * x._timeScale, g, M);
              }
              x = z;
            }
          this._onUpdate && (g || (U.length && Y(), this._callback("onUpdate"))), V && (this._gc || (Et === this._startTime || D !== this._timeScale) && (this._time === 0 || lt >= this.totalDuration()) && (F && (U.length && Y(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !g && this.vars[V] && this._callback(V)));
        }
      }, A._hasPausedChild = function() {
        for (var d = this._first; d; ) {
          if (d._paused || d instanceof $ && d._hasPausedChild())
            return !0;
          d = d._next;
        }
        return !1;
      }, A.getChildren = function(d, g, M, x) {
        x = x || -9999999999;
        for (var F = [], z = this._first, V = 0; z; )
          z._startTime < x || (z instanceof p ? g !== !1 && (F[V++] = z) : (M !== !1 && (F[V++] = z), d !== !1 && (F = F.concat(z.getChildren(!0, g, M)), V = F.length))), z = z._next;
        return F;
      }, A.getTweensOf = function(d, g) {
        var M, x, F = this._gc, z = [], V = 0;
        for (F && this._enabled(!0, !0), M = p.getTweensOf(d), x = M.length; --x > -1; )
          (M[x].timeline === this || g && this._contains(M[x])) && (z[V++] = M[x]);
        return F && this._enabled(!1, !0), z;
      }, A.recent = function() {
        return this._recent;
      }, A._contains = function(d) {
        for (var g = d.timeline; g; ) {
          if (g === this)
            return !0;
          g = g.timeline;
        }
        return !1;
      }, A.shiftChildren = function(d, g, M) {
        M = M || 0;
        for (var x, F = this._first, z = this._labels; F; )
          F._startTime >= M && (F._startTime += d), F = F._next;
        if (g)
          for (x in z)
            z[x] >= M && (z[x] += d);
        return this._uncache(!0);
      }, A._kill = function(d, g) {
        if (!d && !g)
          return this._enabled(!1, !1);
        for (var M = g ? this.getTweensOf(g) : this.getChildren(!0, !0, !1), x = M.length, F = !1; --x > -1; )
          M[x]._kill(d, g) && (F = !0);
        return F;
      }, A.clear = function(d) {
        var g = this.getChildren(!1, !0, !0), M = g.length;
        for (this._time = this._totalTime = 0; --M > -1; )
          g[M]._enabled(!1, !1);
        return d !== !1 && (this._labels = {}), this._uncache(!0);
      }, A.invalidate = function() {
        for (var d = this._first; d; )
          d.invalidate(), d = d._next;
        return T.prototype.invalidate.call(this);
      }, A._enabled = function(d, g) {
        if (d === this._gc)
          for (var M = this._first; M; )
            M._enabled(d, !0), M = M._next;
        return J.prototype._enabled.call(this, d, g);
      }, A.totalTime = function(d, g, M) {
        this._forcingPlayhead = !0;
        var x = T.prototype.totalTime.apply(this, arguments);
        return this._forcingPlayhead = !1, x;
      }, A.duration = function(d) {
        return arguments.length ? (this.duration() !== 0 && d !== 0 && this.timeScale(this._duration / d), this) : (this._dirty && this.totalDuration(), this._duration);
      }, A.totalDuration = function(d) {
        if (!arguments.length) {
          if (this._dirty) {
            for (var g, M, x = 0, F = this._last, z = 999999999999; F; )
              g = F._prev, F._dirty && F.totalDuration(), F._startTime > z && this._sortChildren && !F._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(F, F._startTime - F._delay), this._calculatingDuration = 0) : z = F._startTime, F._startTime < 0 && !F._paused && (x -= F._startTime, this._timeline.smoothChildTiming && (this._startTime += F._startTime / this._timeScale, this._time -= F._startTime, this._totalTime -= F._startTime, this._rawPrevTime -= F._startTime), this.shiftChildren(-F._startTime, !1, -9999999999), z = 0), M = F._startTime + F._totalDuration / F._timeScale, M > x && (x = M), F = g;
            this._duration = this._totalDuration = x, this._dirty = !1;
          }
          return this._totalDuration;
        }
        return d && this.totalDuration() ? this.timeScale(this._totalDuration / d) : this;
      }, A.paused = function(d) {
        if (!d)
          for (var g = this._first, M = this._time; g; )
            g._startTime === M && g.data === "isPause" && (g._rawPrevTime = 0), g = g._next;
        return T.prototype.paused.apply(this, arguments);
      }, A.usesFrames = function() {
        for (var d = this._timeline; d._timeline; )
          d = d._timeline;
        return d === T._rootFramesTimeline;
      }, A.rawTime = function(d) {
        return d && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(d) - this._startTime) * this._timeScale;
      }, $;
    },
    !0
  ), sn._gsDefine(
    "TimelineMax",
    ["TimelineLite", "TweenLite", "easing.Ease"],
    function(T, J, p) {
      var $ = function(H) {
        T.call(this, H), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0;
      }, G = 1e-10, m = J._internals, C = m.lazyTweens, O = m.lazyRender, E = sn._gsDefine.globals, U = new p(null, null, 1, 0), Y = $.prototype = new T();
      return Y.constructor = $, Y.kill()._gc = !1, $.version = "2.0.2", Y.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), T.prototype.invalidate.call(this);
      }, Y.addCallback = function(H, K, B, q) {
        return this.add(J.delayedCall(0, H, B, q), K);
      }, Y.removeCallback = function(H, K) {
        if (H)
          if (K == null)
            this._kill(null, H);
          else
            for (var B = this.getTweensOf(H, !1), q = B.length, b = this._parseTimeOrLabel(K); --q > -1; )
              B[q]._startTime === b && B[q]._enabled(!1, !1);
        return this;
      }, Y.removePause = function(H) {
        return this.removeCallback(T._internals.pauseCallback, H);
      }, Y.tweenTo = function(H, K) {
        K = K || {};
        var B, q, b, A = {
          ease: U,
          useFrames: this.usesFrames(),
          immediateRender: !1,
          lazy: !1
        }, d = K.repeat && E.TweenMax || J;
        for (q in K)
          A[q] = K[q];
        return A.time = this._parseTimeOrLabel(H), B = Math.abs(Number(A.time) - this._time) / this._timeScale || 1e-3, b = new d(this, B, A), A.onStart = function() {
          b.target.paused(!0), b.vars.time === b.target.time() || B !== b.duration() || b.isFromTo || b.duration(
            Math.abs(b.vars.time - b.target.time()) / b.target._timeScale
          ).render(b.time(), !0, !0), K.onStart && K.onStart.apply(
            K.onStartScope || K.callbackScope || b,
            K.onStartParams || []
          );
        }, b;
      }, Y.tweenFromTo = function(H, K, B) {
        B = B || {}, H = this._parseTimeOrLabel(H), B.startAt = {
          onComplete: this.seek,
          onCompleteParams: [H],
          callbackScope: this
        }, B.immediateRender = B.immediateRender !== !1;
        var q = this.tweenTo(K, B);
        return q.isFromTo = 1, q.duration(Math.abs(q.vars.time - H) / this._timeScale || 1e-3);
      }, Y.render = function(H, K, B) {
        this._gc && this._enabled(!0, !1);
        var q, b, A, d, g, M, x, F, z = this._time, V = this._dirty ? this.totalDuration() : this._totalDuration, ht = this._duration, ft = this._totalTime, gt = this._startTime, zt = this._timeScale, lt = this._rawPrevTime, Et = this._paused, D = this._cycle;
        if (z !== this._time && (H += this._time - z), H >= V - 1e-7 && H >= 0)
          this._locked || (this._totalTime = V, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (b = !0, d = "onComplete", g = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= H && H >= -1e-7 || 0 > lt || lt === G) && lt !== H && this._first && (g = !0, lt > G && (d = "onReverseComplete"))), this._rawPrevTime = this._duration || !K || H || this._rawPrevTime === H ? H : G, this._yoyo && 1 & this._cycle ? this._time = H = 0 : (this._time = ht, H = ht + 1e-4);
        else if (1e-7 > H)
          if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (z !== 0 || ht === 0 && lt !== G && (lt > 0 || 0 > H && lt >= 0) && !this._locked) && (d = "onReverseComplete", b = this._reversed), 0 > H)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (g = b = !0, d = "onReverseComplete") : lt >= 0 && this._first && (g = !0), this._rawPrevTime = H;
          else {
            if (this._rawPrevTime = ht || !K || H || this._rawPrevTime === H ? H : G, H === 0 && b)
              for (q = this._first; q && q._startTime === 0; )
                q._duration || (b = !1), q = q._next;
            H = 0, this._initted || (g = !0);
          }
        else if (ht === 0 && 0 > lt && (g = !0), this._time = this._rawPrevTime = H, this._locked || (this._totalTime = H, this._repeat !== 0 && (M = ht + this._repeatDelay, this._cycle = this._totalTime / M >> 0, this._cycle !== 0 && this._cycle === this._totalTime / M && H >= ft && this._cycle--, this._time = this._totalTime - this._cycle * M, this._yoyo && 1 & this._cycle && (this._time = ht - this._time), this._time > ht ? (this._time = ht, H = ht + 1e-4) : this._time < 0 ? this._time = H = 0 : H = this._time)), this._hasPause && !this._forcingPlayhead && !K) {
          if (H = this._time, H >= z || this._repeat && D !== this._cycle)
            for (q = this._first; q && q._startTime <= H && !x; )
              q._duration || q.data !== "isPause" || q.ratio || q._startTime === 0 && this._rawPrevTime === 0 || (x = q), q = q._next;
          else
            for (q = this._last; q && q._startTime >= H && !x; )
              q._duration || q.data === "isPause" && q._rawPrevTime > 0 && (x = q), q = q._prev;
          x && x._startTime < ht && (this._time = H = x._startTime, this._totalTime = H + this._cycle * (this._totalDuration + this._repeatDelay));
        }
        if (this._cycle !== D && !this._locked) {
          var Bt = this._yoyo && (1 & D) !== 0, Ct = Bt === (this._yoyo && (1 & this._cycle) !== 0), Rt = this._totalTime, ge = this._cycle, ue = this._rawPrevTime, Ft = this._time;
          if (this._totalTime = D * ht, this._cycle < D ? Bt = !Bt : this._totalTime += ht, this._time = z, this._rawPrevTime = ht === 0 ? lt - 1e-4 : lt, this._cycle = D, this._locked = !0, z = Bt ? 0 : ht, this.render(z, K, ht === 0), K || this._gc || this.vars.onRepeat && (this._cycle = ge, this._locked = !1, this._callback("onRepeat")), z !== this._time || (Ct && (this._cycle = D, this._locked = !0, z = Bt ? ht + 1e-4 : -1e-4, this.render(z, !0, !1)), this._locked = !1, this._paused && !Et))
            return;
          this._time = Ft, this._totalTime = Rt, this._cycle = ge, this._rawPrevTime = ue;
        }
        if (!(this._time !== z && this._first || B || g || x))
          return void (ft !== this._totalTime && this._onUpdate && (K || this._callback("onUpdate")));
        if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== ft && H > 0 && (this._active = !0), ft === 0 && this.vars.onStart && (this._totalTime === 0 && this._totalDuration || K || this._callback("onStart")), F = this._time, F >= z)
          for (q = this._first; q && (A = q._next, F === this._time && (!this._paused || Et)); )
            (q._active || q._startTime <= this._time && !q._paused && !q._gc) && (x === q && this.pause(), q._reversed ? q.render(
              (q._dirty ? q.totalDuration() : q._totalDuration) - (H - q._startTime) * q._timeScale,
              K,
              B
            ) : q.render((H - q._startTime) * q._timeScale, K, B)), q = A;
        else
          for (q = this._last; q && (A = q._prev, F === this._time && (!this._paused || Et)); ) {
            if (q._active || q._startTime <= z && !q._paused && !q._gc) {
              if (x === q) {
                for (x = q._prev; x && x.endTime() > this._time; )
                  x.render(
                    x._reversed ? x.totalDuration() - (H - x._startTime) * x._timeScale : (H - x._startTime) * x._timeScale,
                    K,
                    B
                  ), x = x._prev;
                x = null, this.pause();
              }
              q._reversed ? q.render(
                (q._dirty ? q.totalDuration() : q._totalDuration) - (H - q._startTime) * q._timeScale,
                K,
                B
              ) : q.render((H - q._startTime) * q._timeScale, K, B);
            }
            q = A;
          }
        this._onUpdate && (K || (C.length && O(), this._callback("onUpdate"))), d && (this._locked || this._gc || (gt === this._startTime || zt !== this._timeScale) && (this._time === 0 || V >= this.totalDuration()) && (b && (C.length && O(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !K && this.vars[d] && this._callback(d)));
      }, Y.getActive = function(H, K, B) {
        H == null && (H = !0), K == null && (K = !0), B == null && (B = !1);
        var q, b, A = [], d = this.getChildren(H, K, B), g = 0, M = d.length;
        for (q = 0; M > q; q++)
          b = d[q], b.isActive() && (A[g++] = b);
        return A;
      }, Y.getLabelAfter = function(H) {
        H || H !== 0 && (H = this._time);
        var K, B = this.getLabelsArray(), q = B.length;
        for (K = 0; q > K; K++)
          if (B[K].time > H)
            return B[K].name;
        return null;
      }, Y.getLabelBefore = function(H) {
        H == null && (H = this._time);
        for (var K = this.getLabelsArray(), B = K.length; --B > -1; )
          if (K[B].time < H)
            return K[B].name;
        return null;
      }, Y.getLabelsArray = function() {
        var H, K = [], B = 0;
        for (H in this._labels)
          K[B++] = { time: this._labels[H], name: H };
        return K.sort(function(q, b) {
          return q.time - b.time;
        }), K;
      }, Y.invalidate = function() {
        return this._locked = !1, T.prototype.invalidate.call(this);
      }, Y.progress = function(H, K) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - H : H) + this._cycle * (this._duration + this._repeatDelay),
          K
        ) : this._time / this.duration() || 0;
      }, Y.totalProgress = function(H, K) {
        return arguments.length ? this.totalTime(this.totalDuration() * H, K) : this._totalTime / this.totalDuration() || 0;
      }, Y.totalDuration = function(H) {
        return arguments.length ? this._repeat !== -1 && H ? this.timeScale(this.totalDuration() / H) : this : (this._dirty && (T.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration);
      }, Y.time = function(H, K) {
        return arguments.length ? (this._dirty && this.totalDuration(), H > this._duration && (H = this._duration), this._yoyo && 1 & this._cycle ? H = this._duration - H + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (H += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(H, K)) : this._time;
      }, Y.repeat = function(H) {
        return arguments.length ? (this._repeat = H, this._uncache(!0)) : this._repeat;
      }, Y.repeatDelay = function(H) {
        return arguments.length ? (this._repeatDelay = H, this._uncache(!0)) : this._repeatDelay;
      }, Y.yoyo = function(H) {
        return arguments.length ? (this._yoyo = H, this) : this._yoyo;
      }, Y.currentLabel = function(H) {
        return arguments.length ? this.seek(H, !0) : this.getLabelBefore(this._time + 1e-8);
      }, $;
    },
    !0
  ), function() {
    var T = 180 / Math.PI, J = [], p = [], $ = [], G = {}, m = sn._gsDefine.globals, C = function(d, g, M, x) {
      M === x && (M = x - (x - g) / 1e6), d === g && (g = d + (M - d) / 1e6), this.a = d, this.b = g, this.c = M, this.d = x, this.da = x - d, this.ca = M - d, this.ba = g - d;
    }, O = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", E = function(d, g, M, x) {
      var F = { a: d }, z = {}, V = {}, ht = { c: x }, ft = (d + g) / 2, gt = (g + M) / 2, zt = (M + x) / 2, lt = (ft + gt) / 2, Et = (gt + zt) / 2, D = (Et - lt) / 8;
      return F.b = ft + (d - ft) / 4, z.b = lt + D, F.c = z.a = (F.b + z.b) / 2, z.c = V.a = (lt + Et) / 2, V.b = Et - D, ht.b = zt + (x - zt) / 4, V.c = ht.a = (V.b + ht.b) / 2, [F, z, V, ht];
    }, U = function(d, g, M, x, F) {
      var z, V, ht, ft, gt, zt, lt, Et, D, Bt, Ct, Rt, ge, ue = d.length - 1, Ft = 0, Dt = d[0].a;
      for (z = 0; ue > z; z++)
        gt = d[Ft], V = gt.a, ht = gt.d, ft = d[Ft + 1].d, F ? (Ct = J[z], Rt = p[z], ge = (Rt + Ct) * g * 0.25 / (x ? 0.5 : $[z] || 0.5), zt = ht - (ht - V) * (x ? 0.5 * g : Ct !== 0 ? ge / Ct : 0), lt = ht + (ft - ht) * (x ? 0.5 * g : Rt !== 0 ? ge / Rt : 0), Et = ht - (zt + ((lt - zt) * (3 * Ct / (Ct + Rt) + 0.5) / 4 || 0))) : (zt = ht - (ht - V) * g * 0.5, lt = ht + (ft - ht) * g * 0.5, Et = ht - (zt + lt) / 2), zt += Et, lt += Et, gt.c = D = zt, z !== 0 ? gt.b = Dt : gt.b = Dt = gt.a + 0.6 * (gt.c - gt.a), gt.da = ht - V, gt.ca = D - V, gt.ba = Dt - V, M ? (Bt = E(V, Dt, D, ht), d.splice(Ft, 1, Bt[0], Bt[1], Bt[2], Bt[3]), Ft += 4) : Ft++, Dt = lt;
      gt = d[Ft], gt.b = Dt, gt.c = Dt + 0.4 * (gt.d - Dt), gt.da = gt.d - gt.a, gt.ca = gt.c - gt.a, gt.ba = Dt - gt.a, M && (Bt = E(gt.a, Dt, gt.c, gt.d), d.splice(Ft, 1, Bt[0], Bt[1], Bt[2], Bt[3]));
    }, Y = function(d, g, M, x) {
      var F, z, V, ht, ft, gt, zt = [];
      if (x)
        for (d = [x].concat(d), z = d.length; --z > -1; )
          typeof (gt = d[z][g]) == "string" && gt.charAt(1) === "=" && (d[z][g] = x[g] + Number(gt.charAt(0) + gt.substr(2)));
      if (F = d.length - 2, 0 > F)
        return zt[0] = new C(d[0][g], 0, 0, d[0][g]), zt;
      for (z = 0; F > z; z++)
        V = d[z][g], ht = d[z + 1][g], zt[z] = new C(V, 0, 0, ht), M && (ft = d[z + 2][g], J[z] = (J[z] || 0) + (ht - V) * (ht - V), p[z] = (p[z] || 0) + (ft - ht) * (ft - ht));
      return zt[z] = new C(d[z][g], 0, 0, d[z + 1][g]), zt;
    }, H = function(d, g, M, x, F, z) {
      var V, ht, ft, gt, zt, lt, Et, D, Bt = {}, Ct = [], Rt = z || d[0];
      F = typeof F == "string" ? "," + F + "," : O, g == null && (g = 1);
      for (ht in d[0])
        Ct.push(ht);
      if (d.length > 1) {
        for (D = d[d.length - 1], Et = !0, V = Ct.length; --V > -1; )
          if (ht = Ct[V], Math.abs(Rt[ht] - D[ht]) > 0.05) {
            Et = !1;
            break;
          }
        Et && (d = d.concat(), z && d.unshift(z), d.push(d[1]), z = d[d.length - 3]);
      }
      for (J.length = p.length = $.length = 0, V = Ct.length; --V > -1; )
        ht = Ct[V], G[ht] = F.indexOf("," + ht + ",") !== -1, Bt[ht] = Y(d, ht, G[ht], z);
      for (V = J.length; --V > -1; )
        J[V] = Math.sqrt(J[V]), p[V] = Math.sqrt(p[V]);
      if (!x) {
        for (V = Ct.length; --V > -1; )
          if (G[ht])
            for (ft = Bt[Ct[V]], lt = ft.length - 1, gt = 0; lt > gt; gt++)
              zt = ft[gt + 1].da / p[gt] + ft[gt].da / J[gt] || 0, $[gt] = ($[gt] || 0) + zt * zt;
        for (V = $.length; --V > -1; )
          $[V] = Math.sqrt($[V]);
      }
      for (V = Ct.length, gt = M ? 4 : 1; --V > -1; )
        ht = Ct[V], ft = Bt[ht], U(ft, g, M, x, G[ht]), Et && (ft.splice(0, gt), ft.splice(ft.length - gt, gt));
      return Bt;
    }, K = function(d, g, M) {
      g = g || "soft";
      var x, F, z, V, ht, ft, gt, zt, lt, Et, D, Bt = {}, Ct = g === "cubic" ? 3 : 2, Rt = g === "soft", ge = [];
      if (Rt && M && (d = [M].concat(d)), d == null || d.length < Ct + 1)
        throw "invalid Bezier data";
      for (lt in d[0])
        ge.push(lt);
      for (ft = ge.length; --ft > -1; ) {
        for (lt = ge[ft], Bt[lt] = ht = [], Et = 0, zt = d.length, gt = 0; zt > gt; gt++)
          x = M == null ? d[gt][lt] : typeof (D = d[gt][lt]) == "string" && D.charAt(1) === "=" ? M[lt] + Number(D.charAt(0) + D.substr(2)) : Number(D), Rt && gt > 1 && zt - 1 > gt && (ht[Et++] = (x + ht[Et - 2]) / 2), ht[Et++] = x;
        for (zt = Et - Ct + 1, Et = 0, gt = 0; zt > gt; gt += Ct)
          x = ht[gt], F = ht[gt + 1], z = ht[gt + 2], V = Ct === 2 ? 0 : ht[gt + 3], ht[Et++] = D = Ct === 3 ? new C(x, F, z, V) : new C(x, (2 * F + x) / 3, (2 * F + z) / 3, z);
        ht.length = Et;
      }
      return Bt;
    }, B = function(d, g, M) {
      for (var x, F, z, V, ht, ft, gt, zt, lt, Et, D, Bt = 1 / M, Ct = d.length; --Ct > -1; )
        for (Et = d[Ct], z = Et.a, V = Et.d - z, ht = Et.c - z, ft = Et.b - z, x = F = 0, zt = 1; M >= zt; zt++)
          gt = Bt * zt, lt = 1 - gt, x = F - (F = (gt * gt * V + 3 * lt * (gt * ht + lt * ft)) * gt), D = Ct * M + zt - 1, g[D] = (g[D] || 0) + x * x;
    }, q = function(d, g) {
      g = g >> 0 || 6;
      var M, x, F, z, V = [], ht = [], ft = 0, gt = 0, zt = g - 1, lt = [], Et = [];
      for (M in d)
        B(d[M], V, g);
      for (F = V.length, x = 0; F > x; x++)
        ft += Math.sqrt(V[x]), z = x % g, Et[z] = ft, z === zt && (gt += ft, z = x / g >> 0, lt[z] = Et, ht[z] = gt, ft = 0, Et = []);
      return { length: gt, lengths: ht, segments: lt };
    }, b = sn._gsDefine.plugin({
      propName: "bezier",
      priority: -1,
      version: "1.3.8",
      API: 2,
      global: !0,
      init: function(d, g, M) {
        this._target = d, g instanceof Array && (g = { values: g }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = g.timeResolution == null ? 6 : parseInt(g.timeResolution, 10);
        var x, F, z, V, ht, ft = g.values || [], gt = {}, zt = ft[0], lt = g.autoRotate || M.vars.orientToBezier;
        this._autoRotate = lt ? lt instanceof Array ? lt : [["x", "y", "rotation", lt === !0 ? 0 : Number(lt) || 0]] : null;
        for (x in zt)
          this._props.push(x);
        for (z = this._props.length; --z > -1; )
          x = this._props[z], this._overwriteProps.push(x), F = this._func[x] = typeof d[x] == "function", gt[x] = F ? d[x.indexOf("set") || typeof d["get" + x.substr(3)] != "function" ? x : "get" + x.substr(3)]() : parseFloat(d[x]), ht || gt[x] !== ft[0][x] && (ht = gt);
        if (this._beziers = g.type !== "cubic" && g.type !== "quadratic" && g.type !== "soft" ? H(
          ft,
          isNaN(g.curviness) ? 1 : g.curviness,
          !1,
          g.type === "thruBasic",
          g.correlate,
          ht
        ) : K(ft, g.type, gt), this._segCount = this._beziers[x].length, this._timeRes) {
          var Et = q(this._beziers, this._timeRes);
          this._length = Et.length, this._lengths = Et.lengths, this._segments = Et.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length;
        }
        if (lt = this._autoRotate)
          for (this._initialRotations = [], lt[0] instanceof Array || (this._autoRotate = lt = [lt]), z = lt.length; --z > -1; ) {
            for (V = 0; 3 > V; V++)
              x = lt[z][V], this._func[x] = typeof d[x] == "function" ? d[x.indexOf("set") || typeof d["get" + x.substr(3)] != "function" ? x : "get" + x.substr(3)] : !1;
            x = lt[z][2], this._initialRotations[z] = (this._func[x] ? this._func[x].call(this._target) : this._target[x]) || 0, this._overwriteProps.push(x);
          }
        return this._startRatio = M.vars.runBackwards ? 1 : 0, !0;
      },
      set: function(d) {
        var g, M, x, F, z, V, ht, ft, gt, zt, lt = this._segCount, Et = this._func, D = this._target, Bt = d !== this._startRatio;
        if (this._timeRes) {
          if (gt = this._lengths, zt = this._curSeg, d *= this._length, x = this._li, d > this._l2 && lt - 1 > x) {
            for (ft = lt - 1; ft > x && (this._l2 = gt[++x]) <= d; )
              ;
            this._l1 = gt[x - 1], this._li = x, this._curSeg = zt = this._segments[x], this._s2 = zt[this._s1 = this._si = 0];
          } else if (d < this._l1 && x > 0) {
            for (; x > 0 && (this._l1 = gt[--x]) >= d; )
              ;
            x === 0 && d < this._l1 ? this._l1 = 0 : x++, this._l2 = gt[x], this._li = x, this._curSeg = zt = this._segments[x], this._s1 = zt[(this._si = zt.length - 1) - 1] || 0, this._s2 = zt[this._si];
          }
          if (g = x, d -= this._l1, x = this._si, d > this._s2 && x < zt.length - 1) {
            for (ft = zt.length - 1; ft > x && (this._s2 = zt[++x]) <= d; )
              ;
            this._s1 = zt[x - 1], this._si = x;
          } else if (d < this._s1 && x > 0) {
            for (; x > 0 && (this._s1 = zt[--x]) >= d; )
              ;
            x === 0 && d < this._s1 ? this._s1 = 0 : x++, this._s2 = zt[x], this._si = x;
          }
          V = (x + (d - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
        } else
          g = 0 > d ? 0 : d >= 1 ? lt - 1 : lt * d >> 0, V = (d - g * (1 / lt)) * lt;
        for (M = 1 - V, x = this._props.length; --x > -1; )
          F = this._props[x], z = this._beziers[F][g], ht = (V * V * z.da + 3 * M * (V * z.ca + M * z.ba)) * V + z.a, this._mod[F] && (ht = this._mod[F](ht, D)), Et[F] ? D[F](ht) : D[F] = ht;
        if (this._autoRotate) {
          var Ct, Rt, ge, ue, Ft, Dt, kt, Fe = this._autoRotate;
          for (x = Fe.length; --x > -1; )
            F = Fe[x][2], Dt = Fe[x][3] || 0, kt = Fe[x][4] === !0 ? 1 : T, z = this._beziers[Fe[x][0]], Ct = this._beziers[Fe[x][1]], z && Ct && (z = z[g], Ct = Ct[g], Rt = z.a + (z.b - z.a) * V, ue = z.b + (z.c - z.b) * V, Rt += (ue - Rt) * V, ue += (z.c + (z.d - z.c) * V - ue) * V, ge = Ct.a + (Ct.b - Ct.a) * V, Ft = Ct.b + (Ct.c - Ct.b) * V, ge += (Ft - ge) * V, Ft += (Ct.c + (Ct.d - Ct.c) * V - Ft) * V, ht = Bt ? Math.atan2(Ft - ge, ue - Rt) * kt + Dt : this._initialRotations[x], this._mod[F] && (ht = this._mod[F](ht, D)), Et[F] ? D[F](ht) : D[F] = ht);
        }
      }
    }), A = b.prototype;
    b.bezierThrough = H, b.cubicToQuadratic = E, b._autoCSS = !0, b.quadraticToCubic = function(d, g, M) {
      return new C(d, (2 * g + d) / 3, (2 * g + M) / 3, M);
    }, b._cssRegister = function() {
      var d = m.CSSPlugin;
      if (d) {
        var g = d._internals, M = g._parseToProxy, x = g._setPluginRatio, F = g.CSSPropTween;
        g._registerComplexSpecialProp("bezier", {
          parser: function(z, V, ht, ft, gt, zt) {
            V instanceof Array && (V = { values: V }), zt = new b();
            var lt, Et, D, Bt = V.values, Ct = Bt.length - 1, Rt = [], ge = {};
            if (0 > Ct)
              return gt;
            for (lt = 0; Ct >= lt; lt++)
              D = M(z, Bt[lt], ft, gt, zt, Ct !== lt), Rt[lt] = D.end;
            for (Et in V)
              ge[Et] = V[Et];
            return ge.values = Rt, gt = new F(z, "bezier", 0, 0, D.pt, 2), gt.data = D, gt.plugin = zt, gt.setRatio = x, ge.autoRotate === 0 && (ge.autoRotate = !0), !ge.autoRotate || ge.autoRotate instanceof Array || (lt = ge.autoRotate === !0 ? 0 : Number(ge.autoRotate), ge.autoRotate = D.end.left != null ? [["left", "top", "rotation", lt, !1]] : D.end.x != null ? [["x", "y", "rotation", lt, !1]] : !1), ge.autoRotate && (ft._transform || ft._enableTransforms(!1), D.autoRotate = ft._target._gsTransform, D.proxy.rotation = D.autoRotate.rotation || 0, ft._overwriteProps.push("rotation")), zt._onInitTween(D.proxy, ge, ft._tween), gt;
          }
        });
      }
    }, A._mod = function(d) {
      for (var g, M = this._overwriteProps, x = M.length; --x > -1; )
        g = d[M[x]], g && typeof g == "function" && (this._mod[M[x]] = g);
    }, A._kill = function(d) {
      var g, M, x = this._props;
      for (g in this._beziers)
        if (g in d)
          for (delete this._beziers[g], delete this._func[g], M = x.length; --M > -1; )
            x[M] === g && x.splice(M, 1);
      if (x = this._autoRotate)
        for (M = x.length; --M > -1; )
          d[x[M][2]] && x.splice(M, 1);
      return this._super._kill.call(this, d);
    };
  }(), sn._gsDefine(
    "plugins.CSSPlugin",
    ["plugins.TweenPlugin", "TweenLite"],
    function(T, J) {
      var p, $, G, m, C = function() {
        T.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = C.prototype.setRatio;
      }, O = sn._gsDefine.globals, E = {}, U = C.prototype = new T("css");
      U.constructor = C, C.version = "2.0.2", C.API = 2, C.defaultTransformPerspective = 0, C.defaultSkewType = "compensated", C.defaultSmoothOrigin = !0, U = "px", C.suffixMap = {
        top: U,
        right: U,
        bottom: U,
        left: U,
        width: U,
        height: U,
        fontSize: U,
        padding: U,
        margin: U,
        perspective: U,
        lineHeight: ""
      };
      var Y, H, K, B, q, b, A, d, g = /(?:\-|\.|\b)(\d|\.|e\-)+/g, M = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, F = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, z = /(?:\d|\-|\+|=|#|\.)*/g, V = /opacity *= *([^)]*)/i, ht = /opacity:([^;]*)/i, ft = /alpha\(opacity *=.+?\)/i, gt = /^(rgb|hsl)/, zt = /([A-Z])/g, lt = /-([a-z])/gi, Et = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, D = function(L, Z) {
        return Z.toUpperCase();
      }, Bt = /(?:Left|Right|Width)/i, Ct = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, Rt = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, ge = /,(?=[^\)]*(?:\(|$))/gi, ue = /[\s,\(]/i, Ft = Math.PI / 180, Dt = 180 / Math.PI, kt = {}, Fe = { style: {} }, xe = sn.document || {
        createElement: function() {
          return Fe;
        }
      }, Zt = function(L, Z) {
        return xe.createElementNS ? xe.createElementNS(Z || "http://www.w3.org/1999/xhtml", L) : xe.createElement(L);
      }, ti = Zt("div"), Ni = Zt("img"), Ie = C._internals = { _specialProps: E }, Ge = (sn.navigator || {}).userAgent || "", pi = function() {
        var L = Ge.indexOf("Android"), Z = Zt("a");
        return K = Ge.indexOf("Safari") !== -1 && Ge.indexOf("Chrome") === -1 && (L === -1 || parseFloat(Ge.substr(L + 8, 2)) > 3), q = K && parseFloat(Ge.substr(Ge.indexOf("Version/") + 8, 2)) < 6, B = Ge.indexOf("Firefox") !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Ge) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Ge)) && (b = parseFloat(RegExp.$1)), Z ? (Z.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(Z.style.opacity)) : !1;
      }(), Li = function(L) {
        return V.test(
          typeof L == "string" ? L : (L.currentStyle ? L.currentStyle.filter : L.style.filter) || ""
        ) ? parseFloat(RegExp.$1) / 100 : 1;
      }, an = function(L) {
        sn.console && console.log(L);
      }, Zi = "", R = "", Jt = function(L, Z) {
        Z = Z || ti;
        var ot, rt, I = Z.style;
        if (I[L] !== void 0)
          return L;
        for (L = L.charAt(0).toUpperCase() + L.substr(1), ot = ["O", "Moz", "ms", "Ms", "Webkit"], rt = 5; --rt > -1 && I[ot[rt] + L] === void 0; )
          ;
        return rt >= 0 ? (R = rt === 3 ? "ms" : ot[rt], Zi = "-" + R.toLowerCase() + "-", R + L) : null;
      }, jt = (typeof window < "u" ? window : xe.defaultView || { getComputedStyle: function() {
      } }).getComputedStyle, ct = C.getStyle = function(L, Z, ot, rt, I) {
        var Mt;
        return pi || Z !== "opacity" ? (!rt && L.style[Z] ? Mt = L.style[Z] : (ot = ot || jt(L)) ? Mt = ot[Z] || ot.getPropertyValue(Z) || ot.getPropertyValue(Z.replace(zt, "-$1").toLowerCase()) : L.currentStyle && (Mt = L.currentStyle[Z]), I == null || Mt && Mt !== "none" && Mt !== "auto" && Mt !== "auto auto" ? Mt : I) : Li(L);
      }, pt = Ie.convertToPixels = function(L, Z, ot, rt, I) {
        if (rt === "px" || !rt && Z !== "lineHeight")
          return ot;
        if (rt === "auto" || !ot)
          return 0;
        var Mt, st, Pt, Ht = Bt.test(Z), Ot = L, Tt = ti.style, le = 0 > ot, oe = ot === 1;
        if (le && (ot = -ot), oe && (ot *= 100), Z !== "lineHeight" || rt)
          if (rt === "%" && Z.indexOf("border") !== -1)
            Mt = ot / 100 * (Ht ? L.clientWidth : L.clientHeight);
          else {
            if (Tt.cssText = "border:0 solid red;position:" + ct(L, "position") + ";line-height:0;", rt !== "%" && Ot.appendChild && rt.charAt(0) !== "v" && rt !== "rem")
              Tt[Ht ? "borderLeftWidth" : "borderTopWidth"] = ot + rt;
            else {
              if (Ot = L.parentNode || xe.body, ct(Ot, "display").indexOf("flex") !== -1 && (Tt.position = "absolute"), st = Ot._gsCache, Pt = J.ticker.frame, st && Ht && st.time === Pt)
                return st.width * ot / 100;
              Tt[Ht ? "width" : "height"] = ot + rt;
            }
            Ot.appendChild(ti), Mt = parseFloat(ti[Ht ? "offsetWidth" : "offsetHeight"]), Ot.removeChild(ti), Ht && rt === "%" && C.cacheWidths !== !1 && (st = Ot._gsCache = Ot._gsCache || {}, st.time = Pt, st.width = Mt / ot * 100), Mt !== 0 || I || (Mt = pt(L, Z, ot, rt, !0));
          }
        else
          st = jt(L).lineHeight, L.style.lineHeight = ot, Mt = parseFloat(jt(L).lineHeight), L.style.lineHeight = st;
        return oe && (Mt /= 100), le ? -Mt : Mt;
      }, Lt = Ie.calculateOffset = function(L, Z, ot) {
        if (ct(L, "position", ot) !== "absolute")
          return 0;
        var rt = Z === "left" ? "Left" : "Top", I = ct(L, "margin" + rt, ot);
        return L["offset" + rt] - (pt(L, Z, parseFloat(I), I.replace(z, "")) || 0);
      }, ie = function(L, Z) {
        var ot, rt, I, Mt = {};
        if (Z = Z || jt(L, null))
          if (ot = Z.length)
            for (; --ot > -1; )
              I = Z[ot], (I.indexOf("-transform") === -1 || ls === I) && (Mt[I.replace(lt, D)] = Z.getPropertyValue(I));
          else
            for (ot in Z)
              (ot.indexOf("Transform") === -1 || dn === ot) && (Mt[ot] = Z[ot]);
        else if (Z = L.currentStyle || L.style)
          for (ot in Z)
            typeof ot == "string" && Mt[ot] === void 0 && (Mt[ot.replace(lt, D)] = Z[ot]);
        return pi || (Mt.opacity = Li(L)), rt = Dr(L, Z, !1), Mt.rotation = rt.rotation, Mt.skewX = rt.skewX, Mt.scaleX = rt.scaleX, Mt.scaleY = rt.scaleY, Mt.x = rt.x, Mt.y = rt.y, tr && (Mt.z = rt.z, Mt.rotationX = rt.rotationX, Mt.rotationY = rt.rotationY, Mt.scaleZ = rt.scaleZ), Mt.filters && delete Mt.filters, Mt;
      }, Kt = function(L, Z, ot, rt, I) {
        var Mt, st, Pt, Ht = {}, Ot = L.style;
        for (st in ot)
          st !== "cssText" && st !== "length" && isNaN(st) && (Z[st] !== (Mt = ot[st]) || I && I[st]) && st.indexOf("Origin") === -1 && (typeof Mt == "number" || typeof Mt == "string") && (Ht[st] = Mt !== "auto" || st !== "left" && st !== "top" ? Mt !== "" && Mt !== "auto" && Mt !== "none" || typeof Z[st] != "string" || Z[st].replace(F, "") === "" ? Mt : 0 : Lt(L, st), Ot[st] !== void 0 && (Pt = new ni(Ot, st, Ot[st], Pt)));
        if (rt)
          for (st in rt)
            st !== "className" && (Ht[st] = rt[st]);
        return { difs: Ht, firstMPT: Pt };
      }, w = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, X = ["marginLeft", "marginRight", "marginTop", "marginBottom"], nt = function(L, Z, ot) {
        if ((L.nodeName + "").toLowerCase() === "svg")
          return (ot || jt(L))[Z] || 0;
        if (L.getCTM && js(L))
          return L.getBBox()[Z] || 0;
        var rt = parseFloat(Z === "width" ? L.offsetWidth : L.offsetHeight), I = w[Z], Mt = I.length;
        for (ot = ot || jt(L, null); --Mt > -1; )
          rt -= parseFloat(ct(L, "padding" + I[Mt], ot, !0)) || 0, rt -= parseFloat(ct(L, "border" + I[Mt] + "Width", ot, !0)) || 0;
        return rt;
      }, tt = function(L, Z) {
        if (L === "contain" || L === "auto" || L === "auto auto")
          return L + " ";
        (L == null || L === "") && (L = "0 0");
        var ot, rt = L.split(" "), I = L.indexOf("left") !== -1 ? "0%" : L.indexOf("right") !== -1 ? "100%" : rt[0], Mt = L.indexOf("top") !== -1 ? "0%" : L.indexOf("bottom") !== -1 ? "100%" : rt[1];
        if (rt.length > 3 && !Z) {
          for (rt = L.split(", ").join(",").split(","), L = [], ot = 0; ot < rt.length; ot++)
            L.push(tt(rt[ot]));
          return L.join(",");
        }
        return Mt == null ? Mt = I === "center" ? "50%" : "0" : Mt === "center" && (Mt = "50%"), (I === "center" || isNaN(parseFloat(I)) && (I + "").indexOf("=") === -1) && (I = "50%"), L = I + " " + Mt + (rt.length > 2 ? " " + rt[2] : ""), Z && (Z.oxp = I.indexOf("%") !== -1, Z.oyp = Mt.indexOf("%") !== -1, Z.oxr = I.charAt(1) === "=", Z.oyr = Mt.charAt(1) === "=", Z.ox = parseFloat(I.replace(F, "")), Z.oy = parseFloat(Mt.replace(F, "")), Z.v = L), Z || L;
      }, vt = function(L, Z) {
        return typeof L == "function" && (L = L(d, A)), typeof L == "string" && L.charAt(1) === "=" ? parseInt(L.charAt(0) + "1", 10) * parseFloat(L.substr(2)) : parseFloat(L) - parseFloat(Z) || 0;
      }, Gt = function(L, Z) {
        typeof L == "function" && (L = L(d, A));
        var ot = typeof L == "string" && L.charAt(1) === "=";
        return typeof L == "string" && L.charAt(L.length - 2) === "v" && (L = (ot ? L.substr(0, 2) : 0) + window["inner" + (L.substr(-2) === "vh" ? "Height" : "Width")] * (parseFloat(ot ? L.substr(2) : L) / 100)), L == null ? Z : ot ? parseInt(L.charAt(0) + "1", 10) * parseFloat(L.substr(2)) + Z : parseFloat(L) || 0;
      }, Xt = function(L, Z, ot, rt) {
        var I, Mt, st, Pt, Ht, Ot = 1e-6;
        return typeof L == "function" && (L = L(d, A)), L == null ? Pt = Z : typeof L == "number" ? Pt = L : (I = 360, Mt = L.split("_"), Ht = L.charAt(1) === "=", st = (Ht ? parseInt(L.charAt(0) + "1", 10) * parseFloat(Mt[0].substr(2)) : parseFloat(Mt[0])) * (L.indexOf("rad") === -1 ? 1 : Dt) - (Ht ? 0 : Z), Mt.length && (rt && (rt[ot] = Z + st), L.indexOf("short") !== -1 && (st %= I, st !== st % (I / 2) && (st = 0 > st ? st + I : st - I)), L.indexOf("_cw") !== -1 && 0 > st ? st = (st + 9999999999 * I) % I - (st / I | 0) * I : L.indexOf("ccw") !== -1 && st > 0 && (st = (st - 9999999999 * I) % I - (st / I | 0) * I)), Pt = Z + st), Ot > Pt && Pt > -Ot && (Pt = 0), Pt;
      }, Vt = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      }, Ne = function(L, Z, ot) {
        return L = 0 > L ? L + 1 : L > 1 ? L - 1 : L, 255 * (1 > 6 * L ? Z + (ot - Z) * L * 6 : 0.5 > L ? ot : 2 > 3 * L ? Z + (ot - Z) * (2 / 3 - L) * 6 : Z) + 0.5 | 0;
      }, Re = C.parseColor = function(L, Z) {
        var ot, rt, I, Mt, st, Pt, Ht, Ot, Tt, le, oe;
        if (L)
          if (typeof L == "number")
            ot = [L >> 16, L >> 8 & 255, 255 & L];
          else {
            if (L.charAt(L.length - 1) === "," && (L = L.substr(0, L.length - 1)), Vt[L])
              ot = Vt[L];
            else if (L.charAt(0) === "#")
              L.length === 4 && (rt = L.charAt(1), I = L.charAt(2), Mt = L.charAt(3), L = "#" + rt + rt + I + I + Mt + Mt), L = parseInt(L.substr(1), 16), ot = [L >> 16, L >> 8 & 255, 255 & L];
            else if (L.substr(0, 3) === "hsl")
              if (ot = oe = L.match(g), Z) {
                if (L.indexOf("=") !== -1)
                  return L.match(M);
              } else
                st = Number(ot[0]) % 360 / 360, Pt = Number(ot[1]) / 100, Ht = Number(ot[2]) / 100, I = 0.5 >= Ht ? Ht * (Pt + 1) : Ht + Pt - Ht * Pt, rt = 2 * Ht - I, ot.length > 3 && (ot[3] = Number(ot[3])), ot[0] = Ne(st + 1 / 3, rt, I), ot[1] = Ne(st, rt, I), ot[2] = Ne(st - 1 / 3, rt, I);
            else
              ot = L.match(g) || Vt.transparent;
            ot[0] = Number(ot[0]), ot[1] = Number(ot[1]), ot[2] = Number(ot[2]), ot.length > 3 && (ot[3] = Number(ot[3]));
          }
        else
          ot = Vt.black;
        return Z && !oe && (rt = ot[0] / 255, I = ot[1] / 255, Mt = ot[2] / 255, Ot = Math.max(rt, I, Mt), Tt = Math.min(rt, I, Mt), Ht = (Ot + Tt) / 2, Ot === Tt ? st = Pt = 0 : (le = Ot - Tt, Pt = Ht > 0.5 ? le / (2 - Ot - Tt) : le / (Ot + Tt), st = Ot === rt ? (I - Mt) / le + (Mt > I ? 6 : 0) : Ot === I ? (Mt - rt) / le + 2 : (rt - I) / le + 4, st *= 60), ot[0] = st + 0.5 | 0, ot[1] = 100 * Pt + 0.5 | 0, ot[2] = 100 * Ht + 0.5 | 0), ot;
      }, de = function(L, Z) {
        var ot, rt, I, Mt = L.match(we) || [], st = 0, Pt = "";
        if (!Mt.length)
          return L;
        for (ot = 0; ot < Mt.length; ot++)
          rt = Mt[ot], I = L.substr(st, L.indexOf(rt, st) - st), st += I.length + rt.length, rt = Re(rt, Z), rt.length === 3 && rt.push(1), Pt += I + (Z ? "hsla(" + rt[0] + "," + rt[1] + "%," + rt[2] + "%," + rt[3] : "rgba(" + rt.join(",")) + ")";
        return Pt + L.substr(st);
      }, we = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
      for (U in Vt)
        we += "|" + U + "\\b";
      we = new RegExp(we + ")", "gi"), C.colorStringFilter = function(L) {
        var Z, ot = L[0] + " " + L[1];
        we.test(ot) && (Z = ot.indexOf("hsl(") !== -1 || ot.indexOf("hsla(") !== -1, L[0] = de(L[0], Z), L[1] = de(L[1], Z)), we.lastIndex = 0;
      }, J.defaultStringFilter || (J.defaultStringFilter = C.colorStringFilter);
      var vi = function(L, Z, ot, rt) {
        if (L == null)
          return function(oe) {
            return oe;
          };
        var I, Mt = Z ? (L.match(we) || [""])[0] : "", st = L.split(Mt).join("").match(x) || [], Pt = L.substr(0, L.indexOf(st[0])), Ht = L.charAt(L.length - 1) === ")" ? ")" : "", Ot = L.indexOf(" ") !== -1 ? " " : ",", Tt = st.length, le = Tt > 0 ? st[0].replace(g, "") : "";
        return Tt ? I = Z ? function(oe) {
          var te, ve, he, Ve;
          if (typeof oe == "number")
            oe += le;
          else if (rt && ge.test(oe)) {
            for (Ve = oe.replace(ge, "|").split("|"), he = 0; he < Ve.length; he++)
              Ve[he] = I(Ve[he]);
            return Ve.join(",");
          }
          if (te = (oe.match(we) || [Mt])[0], ve = oe.split(te).join("").match(x) || [], he = ve.length, Tt > he--)
            for (; ++he < Tt; )
              ve[he] = ot ? ve[(he - 1) / 2 | 0] : st[he];
          return Pt + ve.join(Ot) + Ot + te + Ht + (oe.indexOf("inset") !== -1 ? " inset" : "");
        } : function(oe) {
          var te, ve, he;
          if (typeof oe == "number")
            oe += le;
          else if (rt && ge.test(oe)) {
            for (ve = oe.replace(ge, "|").split("|"), he = 0; he < ve.length; he++)
              ve[he] = I(ve[he]);
            return ve.join(",");
          }
          if (te = oe.match(x) || [], he = te.length, Tt > he--)
            for (; ++he < Tt; )
              te[he] = ot ? te[(he - 1) / 2 | 0] : st[he];
          return Pt + te.join(Ot) + Ht;
        } : function(oe) {
          return oe;
        };
      }, Mi = function(L) {
        return L = L.split(","), function(Z, ot, rt, I, Mt, st, Pt) {
          var Ht, Ot = (ot + "").split(" ");
          for (Pt = {}, Ht = 0; 4 > Ht; Ht++)
            Pt[L[Ht]] = Ot[Ht] = Ot[Ht] || Ot[(Ht - 1) / 2 >> 0];
          return I.parse(Z, Pt, Mt, st);
        };
      }, ni = (Ie._setPluginRatio = function(L) {
        this.plugin.setRatio(L);
        for (var Z, ot, rt, I, Mt, st = this.data, Pt = st.proxy, Ht = st.firstMPT, Ot = 1e-6; Ht; )
          Z = Pt[Ht.v], Ht.r ? Z = Ht.r(Z) : Ot > Z && Z > -Ot && (Z = 0), Ht.t[Ht.p] = Z, Ht = Ht._next;
        if (st.autoRotate && (st.autoRotate.rotation = st.mod ? st.mod.call(this._tween, Pt.rotation, this.t, this._tween) : Pt.rotation), L === 1 || L === 0)
          for (Ht = st.firstMPT, Mt = L === 1 ? "e" : "b"; Ht; ) {
            if (ot = Ht.t, ot.type) {
              if (ot.type === 1) {
                for (I = ot.xs0 + ot.s + ot.xs1, rt = 1; rt < ot.l; rt++)
                  I += ot["xn" + rt] + ot["xs" + (rt + 1)];
                ot[Mt] = I;
              }
            } else
              ot[Mt] = ot.s + ot.xs0;
            Ht = Ht._next;
          }
      }, function(L, Z, ot, rt, I) {
        this.t = L, this.p = Z, this.v = ot, this.r = I, rt && (rt._prev = this, this._next = rt);
      }), Si = (Ie._parseToProxy = function(L, Z, ot, rt, I, Mt) {
        var st, Pt, Ht, Ot, Tt, le = rt, oe = {}, te = {}, ve = ot._transform, he = kt;
        for (ot._transform = null, kt = Z, rt = Tt = ot.parse(L, Z, rt, I), kt = he, Mt && (ot._transform = ve, le && (le._prev = null, le._prev && (le._prev._next = null))); rt && rt !== le; ) {
          if (rt.type <= 1 && (Pt = rt.p, te[Pt] = rt.s + rt.c, oe[Pt] = rt.s, Mt || (Ot = new ni(rt, "s", Pt, Ot, rt.r), rt.c = 0), rt.type === 1))
            for (st = rt.l; --st > 0; )
              Ht = "xn" + st, Pt = rt.p + "_" + Ht, te[Pt] = rt.data[Ht], oe[Pt] = rt[Ht], Mt || (Ot = new ni(rt, Ht, Pt, Ot, rt.rxp[Ht]));
          rt = rt._next;
        }
        return { proxy: oe, end: te, firstMPT: Ot, pt: Tt };
      }, Ie.CSSPropTween = function(L, Z, ot, rt, I, Mt, st, Pt, Ht, Ot, Tt) {
        this.t = L, this.p = Z, this.s = ot, this.c = rt, this.n = st || Z, L instanceof Si || m.push(this.n), this.r = Pt && (typeof Pt == "function" ? Pt : Math.round), this.type = Mt || 0, Ht && (this.pr = Ht, p = !0), this.b = Ot === void 0 ? ot : Ot, this.e = Tt === void 0 ? ot + rt : Tt, I && (this._next = I, I._prev = this);
      }), wr = function(L, Z, ot, rt, I, Mt) {
        var st = new Si(L, Z, ot, rt - ot, I, -1, Mt);
        return st.b = ot, st.e = st.xs0 = rt, st;
      }, jn = C.parseComplex = function(L, Z, ot, rt, I, Mt, st, Pt, Ht, Ot) {
        ot = ot || Mt || "", typeof rt == "function" && (rt = rt(d, A)), st = new Si(L, Z, 0, 0, st, Ot ? 2 : 1, null, !1, Pt, ot, rt), rt += "", I && we.test(rt + ot) && (rt = [ot, rt], C.colorStringFilter(rt), ot = rt[0], rt = rt[1]);
        var Tt, le, oe, te, ve, he, Ve, He, ui, Be, ye, ke, ce, di = ot.split(", ").join(",").split(" "), Pe = rt.split(", ").join(",").split(" "), _e = di.length, Le = Y !== !1;
        for ((rt.indexOf(",") !== -1 || ot.indexOf(",") !== -1) && ((rt + ot).indexOf("rgb") !== -1 || (rt + ot).indexOf("hsl") !== -1 ? (di = di.join(" ").replace(ge, ", ").split(" "), Pe = Pe.join(" ").replace(ge, ", ").split(" ")) : (di = di.join(" ").split(",").join(", ").split(" "), Pe = Pe.join(" ").split(",").join(", ").split(" ")), _e = di.length), _e !== Pe.length && (di = (Mt || "").split(" "), _e = di.length), st.plugin = Ht, st.setRatio = Ot, we.lastIndex = 0, Tt = 0; _e > Tt; Tt++)
          if (te = di[Tt], ve = Pe[Tt] + "", He = parseFloat(te), He || He === 0)
            st.appendXtra(
              "",
              He,
              vt(ve, He),
              ve.replace(M, ""),
              Le && ve.indexOf("px") !== -1 ? Math.round : !1,
              !0
            );
          else if (I && we.test(te))
            ke = ve.indexOf(")") + 1, ke = ")" + (ke ? ve.substr(ke) : ""), ce = ve.indexOf("hsl") !== -1 && pi, Be = ve, te = Re(te, ce), ve = Re(ve, ce), ui = te.length + ve.length > 6, ui && !pi && ve[3] === 0 ? (st["xs" + st.l] += st.l ? " transparent" : "transparent", st.e = st.e.split(Pe[Tt]).join("transparent")) : (pi || (ui = !1), ce ? st.appendXtra(
              Be.substr(0, Be.indexOf("hsl")) + (ui ? "hsla(" : "hsl("),
              te[0],
              vt(ve[0], te[0]),
              ",",
              !1,
              !0
            ).appendXtra("", te[1], vt(ve[1], te[1]), "%,", !1).appendXtra(
              "",
              te[2],
              vt(ve[2], te[2]),
              ui ? "%," : "%" + ke,
              !1
            ) : st.appendXtra(
              Be.substr(0, Be.indexOf("rgb")) + (ui ? "rgba(" : "rgb("),
              te[0],
              ve[0] - te[0],
              ",",
              Math.round,
              !0
            ).appendXtra("", te[1], ve[1] - te[1], ",", Math.round).appendXtra(
              "",
              te[2],
              ve[2] - te[2],
              ui ? "," : ke,
              Math.round
            ), ui && (te = te.length < 4 ? 1 : te[3], st.appendXtra(
              "",
              te,
              (ve.length < 4 ? 1 : ve[3]) - te,
              ke,
              !1
            ))), we.lastIndex = 0;
          else if (he = te.match(g)) {
            if (Ve = ve.match(M), !Ve || Ve.length !== he.length)
              return st;
            for (oe = 0, le = 0; le < he.length; le++)
              ye = he[le], Be = te.indexOf(ye, oe), st.appendXtra(
                te.substr(oe, Be - oe),
                Number(ye),
                vt(Ve[le], ye),
                "",
                Le && te.substr(Be + ye.length, 2) === "px" ? Math.round : !1,
                le === 0
              ), oe = Be + ye.length;
            st["xs" + st.l] += te.substr(oe);
          } else
            st["xs" + st.l] += st.l || st["xs" + st.l] ? " " + ve : ve;
        if (rt.indexOf("=") !== -1 && st.data) {
          for (ke = st.xs0 + st.data.s, Tt = 1; Tt < st.l; Tt++)
            ke += st["xs" + Tt] + st.data["xn" + Tt];
          st.e = ke + st["xs" + Tt];
        }
        return st.l || (st.type = -1, st.xs0 = st.e), st.xfirst || st;
      }, tn = 9;
      for (U = Si.prototype, U.l = U.pr = 0; --tn > 0; )
        U["xn" + tn] = 0, U["xs" + tn] = "";
      U.xs0 = "", U._next = U._prev = U.xfirst = U.data = U.plugin = U.setRatio = U.rxp = null, U.appendXtra = function(L, Z, ot, rt, I, Mt) {
        var st = this, Pt = st.l;
        return st["xs" + Pt] += Mt && (Pt || st["xs" + Pt]) ? " " + L : L || "", ot || Pt === 0 || st.plugin ? (st.l++, st.type = st.setRatio ? 2 : 1, st["xs" + st.l] = rt || "", Pt > 0 ? (st.data["xn" + Pt] = Z + ot, st.rxp["xn" + Pt] = I, st["xn" + Pt] = Z, st.plugin || (st.xfirst = new Si(
          st,
          "xn" + Pt,
          Z,
          ot,
          st.xfirst || st,
          0,
          st.n,
          I,
          st.pr
        ), st.xfirst.xs0 = 0), st) : (st.data = { s: Z + ot }, st.rxp = {}, st.s = Z, st.c = ot, st.r = I, st)) : (st["xs" + Pt] += Z + (rt || ""), st);
      };
      var $r = function(L, Z) {
        Z = Z || {}, this.p = Z.prefix && Jt(L) || L, E[L] = E[this.p] = this, this.format = Z.formatter || vi(Z.defaultValue, Z.color, Z.collapsible, Z.multi), Z.parser && (this.parse = Z.parser), this.clrs = Z.color, this.multi = Z.multi, this.keyword = Z.keyword, this.dflt = Z.defaultValue, this.pr = Z.priority || 0;
      }, Ri = Ie._registerComplexSpecialProp = function(L, Z, ot) {
        typeof Z != "object" && (Z = { parser: ot });
        var rt, I = L.split(","), Mt = Z.defaultValue;
        for (ot = ot || [Mt], rt = 0; rt < I.length; rt++)
          Z.prefix = rt === 0 && Z.prefix, Z.defaultValue = ot[rt] || Mt, new $r(I[rt], Z);
      }, co = Ie._registerPluginProp = function(L) {
        if (!E[L]) {
          var Z = L.charAt(0).toUpperCase() + L.substr(1) + "Plugin";
          Ri(L, {
            parser: function(ot, rt, I, Mt, st, Pt, Ht) {
              var Ot = O.com.greensock.plugins[Z];
              return Ot ? (Ot._cssRegister(), E[I].parse(ot, rt, I, Mt, st, Pt, Ht)) : (an("Error: " + Z + " js file not loaded."), st);
            }
          });
        }
      };
      U = $r.prototype, U.parseComplex = function(L, Z, ot, rt, I, Mt) {
        var st, Pt, Ht, Ot, Tt, le, oe = this.keyword;
        if (this.multi && (ge.test(ot) || ge.test(Z) ? (Pt = Z.replace(ge, "|").split("|"), Ht = ot.replace(ge, "|").split("|")) : oe && (Pt = [Z], Ht = [ot])), Ht) {
          for (Ot = Ht.length > Pt.length ? Ht.length : Pt.length, st = 0; Ot > st; st++)
            Z = Pt[st] = Pt[st] || this.dflt, ot = Ht[st] = Ht[st] || this.dflt, oe && (Tt = Z.indexOf(oe), le = ot.indexOf(oe), Tt !== le && (le === -1 ? Pt[st] = Pt[st].split(oe).join("") : Tt === -1 && (Pt[st] += " " + oe)));
          Z = Pt.join(", "), ot = Ht.join(", ");
        }
        return jn(L, this.p, Z, ot, this.clrs, this.dflt, rt, this.pr, I, Mt);
      }, U.parse = function(L, Z, ot, rt, I, Mt, st) {
        return this.parseComplex(
          L.style,
          this.format(ct(L, this.p, G, !1, this.dflt)),
          this.format(Z),
          I,
          Mt
        );
      }, C.registerSpecialProp = function(L, Z, ot) {
        Ri(L, {
          parser: function(rt, I, Mt, st, Pt, Ht, Ot) {
            var Tt = new Si(rt, Mt, 0, 0, Pt, 2, Mt, !1, ot);
            return Tt.plugin = Ht, Tt.setRatio = Z(rt, I, st._tween, Mt), Tt;
          },
          priority: ot
        });
      }, C.useSVGTransformAttr = !0;
      var Rr, Ma = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(
        ","
      ), dn = Jt("transform"), ls = Zi + "transform", Lo = Jt("transformOrigin"), tr = Jt("perspective") !== null, hs = Ie.Transform = function() {
        this.perspective = parseFloat(C.defaultTransformPerspective) || 0, this.force3D = C.defaultForce3D !== !1 && tr ? C.defaultForce3D || "auto" : !1;
      }, Hs = sn.SVGElement, Sa = function(L, Z, ot) {
        var rt, I = xe.createElementNS("http://www.w3.org/2000/svg", L), Mt = /([a-z])([A-Z])/g;
        for (rt in ot)
          I.setAttributeNS(null, rt.replace(Mt, "$1-$2").toLowerCase(), ot[rt]);
        return Z.appendChild(I), I;
      }, Ir = xe.documentElement || {}, $a = function() {
        var L, Z, ot, rt = b || /Android/i.test(Ge) && !sn.chrome;
        return xe.createElementNS && !rt && (L = Sa("svg", Ir), Z = Sa("rect", L, { width: 100, height: 50, x: 100 }), ot = Z.getBoundingClientRect().width, Z.style[Lo] = "50% 50%", Z.style[dn] = "scaleX(0.5)", rt = ot === Z.getBoundingClientRect().width && !(B && tr), Ir.removeChild(L)), rt;
      }(), us = function(L, Z, ot, rt, I, Mt) {
        var st, Pt, Ht, Ot, Tt, le, oe, te, ve, he, Ve, He, ui, Be, ye = L._gsTransform, ke = fs(L, !0);
        ye && (ui = ye.xOrigin, Be = ye.yOrigin), (!rt || (st = rt.split(" ")).length < 2) && (oe = L.getBBox(), oe.x === 0 && oe.y === 0 && oe.width + oe.height === 0 && (oe = {
          x: parseFloat(
            L.hasAttribute("x") ? L.getAttribute("x") : L.hasAttribute("cx") ? L.getAttribute("cx") : 0
          ) || 0,
          y: parseFloat(
            L.hasAttribute("y") ? L.getAttribute("y") : L.hasAttribute("cy") ? L.getAttribute("cy") : 0
          ) || 0,
          width: 0,
          height: 0
        }), Z = tt(Z).split(" "), st = [
          (Z[0].indexOf("%") !== -1 ? parseFloat(Z[0]) / 100 * oe.width : parseFloat(Z[0])) + oe.x,
          (Z[1].indexOf("%") !== -1 ? parseFloat(Z[1]) / 100 * oe.height : parseFloat(Z[1])) + oe.y
        ]), ot.xOrigin = Ot = parseFloat(st[0]), ot.yOrigin = Tt = parseFloat(st[1]), rt && ke !== cs && (le = ke[0], oe = ke[1], te = ke[2], ve = ke[3], he = ke[4], Ve = ke[5], He = le * ve - oe * te, He && (Pt = Ot * (ve / He) + Tt * (-te / He) + (te * Ve - ve * he) / He, Ht = Ot * (-oe / He) + Tt * (le / He) - (le * Ve - oe * he) / He, Ot = ot.xOrigin = st[0] = Pt, Tt = ot.yOrigin = st[1] = Ht)), ye && (Mt && (ot.xOffset = ye.xOffset, ot.yOffset = ye.yOffset, ye = ot), I || I !== !1 && C.defaultSmoothOrigin !== !1 ? (Pt = Ot - ui, Ht = Tt - Be, ye.xOffset += Pt * ke[0] + Ht * ke[2] - Pt, ye.yOffset += Pt * ke[1] + Ht * ke[3] - Ht) : ye.xOffset = ye.yOffset = 0), Mt || L.setAttribute("data-svg-origin", st.join(" "));
      }, Ws = function(L) {
        var Z, ot = Zt(
          "svg",
          this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"
        ), rt = this.parentNode, I = this.nextSibling, Mt = this.style.cssText;
        if (Ir.appendChild(ot), ot.appendChild(this), this.style.display = "block", L)
          try {
            Z = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ws;
          } catch {
          }
        else
          this._originalGetBBox && (Z = this._originalGetBBox());
        return I ? rt.insertBefore(this, I) : rt.appendChild(this), Ir.removeChild(ot), this.style.cssText = Mt, Z;
      }, Or = function(L) {
        try {
          return L.getBBox();
        } catch {
          return Ws.call(L, !0);
        }
      }, js = function(L) {
        return !(!Hs || !L.getCTM || L.parentNode && !L.ownerSVGElement || !Or(L));
      }, cs = [1, 0, 0, 1, 0, 0], fs = function(L, Z) {
        var ot, rt, I, Mt, st, Pt, Ht = L._gsTransform || new hs(), Ot = 1e5, Tt = L.style;
        if (dn ? rt = ct(L, ls, null, !0) : L.currentStyle && (rt = L.currentStyle.filter.match(Ct), rt = rt && rt.length === 4 ? [
          rt[0].substr(4),
          Number(rt[2].substr(4)),
          Number(rt[1].substr(4)),
          rt[3].substr(4),
          Ht.x || 0,
          Ht.y || 0
        ].join(",") : ""), ot = !rt || rt === "none" || rt === "matrix(1, 0, 0, 1, 0, 0)", !dn || !(Pt = !jt(L) || jt(L).display === "none") && L.parentNode || (Pt && (Mt = Tt.display, Tt.display = "block"), L.parentNode || (st = 1, Ir.appendChild(L)), rt = ct(L, ls, null, !0), ot = !rt || rt === "none" || rt === "matrix(1, 0, 0, 1, 0, 0)", Mt ? Tt.display = Mt : Pt && Ro(Tt, "display"), st && Ir.removeChild(L)), (Ht.svg || L.getCTM && js(L)) && (ot && (Tt[dn] + "").indexOf("matrix") !== -1 && (rt = Tt[dn], ot = 0), I = L.getAttribute("transform"), ot && I && (I = L.transform.baseVal.consolidate().matrix, rt = "matrix(" + I.a + "," + I.b + "," + I.c + "," + I.d + "," + I.e + "," + I.f + ")", ot = 0)), ot)
          return cs;
        for (I = (rt || "").match(g) || [], tn = I.length; --tn > -1; )
          Mt = Number(I[tn]), I[tn] = (st = Mt - (Mt |= 0)) ? (st * Ot + (0 > st ? -0.5 : 0.5) | 0) / Ot + Mt : Mt;
        return Z && I.length > 6 ? [I[0], I[1], I[4], I[5], I[12], I[13]] : I;
      }, Dr = Ie.getTransform = function(L, Z, ot, rt) {
        if (L._gsTransform && ot && !rt)
          return L._gsTransform;
        var I, Mt, st, Pt, Ht, Ot, Tt = ot ? L._gsTransform || new hs() : new hs(), le = Tt.scaleX < 0, oe = 2e-5, te = 1e5, ve = tr && (parseFloat(ct(L, Lo, Z, !1, "0 0 0").split(" ")[2]) || Tt.zOrigin) || 0, he = parseFloat(C.defaultTransformPerspective) || 0;
        if (Tt.svg = !(!L.getCTM || !js(L)), Tt.svg && (us(
          L,
          ct(L, Lo, Z, !1, "50% 50%") + "",
          Tt,
          L.getAttribute("data-svg-origin")
        ), Rr = C.useSVGTransformAttr || $a), I = fs(L), I !== cs) {
          if (I.length === 16) {
            var Ve, He, ui, Be, ye, ke = I[0], ce = I[1], di = I[2], Pe = I[3], _e = I[4], Le = I[5], mn = I[6], On = I[7], Ii = I[8], Oi = I[9], Ui = I[10], $i = I[12], Ki = I[13], nn = I[14], rn = I[11], ki = Math.atan2(mn, Ui);
            Tt.zOrigin && (nn = -Tt.zOrigin, $i = Ii * nn - I[12], Ki = Oi * nn - I[13], nn = Ui * nn + Tt.zOrigin - I[14]), Tt.rotationX = ki * Dt, ki && (Be = Math.cos(-ki), ye = Math.sin(-ki), Ve = _e * Be + Ii * ye, He = Le * Be + Oi * ye, ui = mn * Be + Ui * ye, Ii = _e * -ye + Ii * Be, Oi = Le * -ye + Oi * Be, Ui = mn * -ye + Ui * Be, rn = On * -ye + rn * Be, _e = Ve, Le = He, mn = ui), ki = Math.atan2(-di, Ui), Tt.rotationY = ki * Dt, ki && (Be = Math.cos(-ki), ye = Math.sin(-ki), Ve = ke * Be - Ii * ye, He = ce * Be - Oi * ye, ui = di * Be - Ui * ye, Oi = ce * ye + Oi * Be, Ui = di * ye + Ui * Be, rn = Pe * ye + rn * Be, ke = Ve, ce = He, di = ui), ki = Math.atan2(ce, ke), Tt.rotation = ki * Dt, ki && (Be = Math.cos(ki), ye = Math.sin(ki), Ve = ke * Be + ce * ye, He = _e * Be + Le * ye, ui = Ii * Be + Oi * ye, ce = ce * Be - ke * ye, Le = Le * Be - _e * ye, Oi = Oi * Be - Ii * ye, ke = Ve, _e = He, Ii = ui), Tt.rotationX && Math.abs(Tt.rotationX) + Math.abs(Tt.rotation) > 359.9 && (Tt.rotationX = Tt.rotation = 0, Tt.rotationY = 180 - Tt.rotationY), ki = Math.atan2(_e, Le), Tt.scaleX = (Math.sqrt(ke * ke + ce * ce + di * di) * te + 0.5 | 0) / te, Tt.scaleY = (Math.sqrt(Le * Le + mn * mn) * te + 0.5 | 0) / te, Tt.scaleZ = (Math.sqrt(Ii * Ii + Oi * Oi + Ui * Ui) * te + 0.5 | 0) / te, ke /= Tt.scaleX, _e /= Tt.scaleY, ce /= Tt.scaleX, Le /= Tt.scaleY, Math.abs(ki) > oe ? (Tt.skewX = ki * Dt, _e = 0, Tt.skewType !== "simple" && (Tt.scaleY *= 1 / Math.cos(ki))) : Tt.skewX = 0, Tt.perspective = rn ? 1 / (0 > rn ? -rn : rn) : 0, Tt.x = $i, Tt.y = Ki, Tt.z = nn, Tt.svg && (Tt.x -= Tt.xOrigin - (Tt.xOrigin * ke - Tt.yOrigin * _e), Tt.y -= Tt.yOrigin - (Tt.yOrigin * ce - Tt.xOrigin * Le));
          } else if (!tr || rt || !I.length || Tt.x !== I[4] || Tt.y !== I[5] || !Tt.rotationX && !Tt.rotationY) {
            var Di = I.length >= 6, Hi = Di ? I[0] : 1, mi = I[1] || 0, zr = I[2] || 0, Cn = Di ? I[3] : 1;
            Tt.x = I[4] || 0, Tt.y = I[5] || 0, st = Math.sqrt(Hi * Hi + mi * mi), Pt = Math.sqrt(Cn * Cn + zr * zr), Ht = Hi || mi ? Math.atan2(mi, Hi) * Dt : Tt.rotation || 0, Ot = zr || Cn ? Math.atan2(zr, Cn) * Dt + Ht : Tt.skewX || 0, Tt.scaleX = st, Tt.scaleY = Pt, Tt.rotation = Ht, Tt.skewX = Ot, tr && (Tt.rotationX = Tt.rotationY = Tt.z = 0, Tt.perspective = he, Tt.scaleZ = 1), Tt.svg && (Tt.x -= Tt.xOrigin - (Tt.xOrigin * Hi + Tt.yOrigin * zr), Tt.y -= Tt.yOrigin - (Tt.xOrigin * mi + Tt.yOrigin * Cn));
          }
          Math.abs(Tt.skewX) > 90 && Math.abs(Tt.skewX) < 270 && (le ? (Tt.scaleX *= -1, Tt.skewX += Tt.rotation <= 0 ? 180 : -180, Tt.rotation += Tt.rotation <= 0 ? 180 : -180) : (Tt.scaleY *= -1, Tt.skewX += Tt.skewX <= 0 ? 180 : -180)), Tt.zOrigin = ve;
          for (Mt in Tt)
            Tt[Mt] < oe && Tt[Mt] > -oe && (Tt[Mt] = 0);
        }
        return ot && (L._gsTransform = Tt, Tt.svg && (Rr && L.style[dn] ? J.delayedCall(1e-3, function() {
          Ro(L.style, dn);
        }) : !Rr && L.getAttribute("transform") && J.delayedCall(1e-3, function() {
          L.removeAttribute("transform");
        }))), Tt;
      }, Ea = function(L) {
        var Z, ot, rt = this.data, I = -rt.rotation * Ft, Mt = I + rt.skewX * Ft, st = 1e5, Pt = (Math.cos(I) * rt.scaleX * st | 0) / st, Ht = (Math.sin(I) * rt.scaleX * st | 0) / st, Ot = (Math.sin(Mt) * -rt.scaleY * st | 0) / st, Tt = (Math.cos(Mt) * rt.scaleY * st | 0) / st, le = this.t.style, oe = this.t.currentStyle;
        if (oe) {
          ot = Ht, Ht = -Ot, Ot = -ot, Z = oe.filter, le.filter = "";
          var te, ve, he = this.t.offsetWidth, Ve = this.t.offsetHeight, He = oe.position !== "absolute", ui = "progid:DXImageTransform.Microsoft.Matrix(M11=" + Pt + ", M12=" + Ht + ", M21=" + Ot + ", M22=" + Tt, Be = rt.x + he * rt.xPercent / 100, ye = rt.y + Ve * rt.yPercent / 100;
          if (rt.ox != null && (te = (rt.oxp ? he * rt.ox * 0.01 : rt.ox) - he / 2, ve = (rt.oyp ? Ve * rt.oy * 0.01 : rt.oy) - Ve / 2, Be += te - (te * Pt + ve * Ht), ye += ve - (te * Ot + ve * Tt)), He ? (te = he / 2, ve = Ve / 2, ui += ", Dx=" + (te - (te * Pt + ve * Ht) + Be) + ", Dy=" + (ve - (te * Ot + ve * Tt) + ye) + ")") : ui += ", sizingMethod='auto expand')", Z.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? le.filter = Z.replace(Rt, ui) : le.filter = ui + " " + Z, (L === 0 || L === 1) && Pt === 1 && Ht === 0 && Ot === 0 && Tt === 1 && (He && ui.indexOf("Dx=0, Dy=0") === -1 || V.test(Z) && parseFloat(RegExp.$1) !== 100 || Z.indexOf(Z.indexOf("Alpha")) === -1 && le.removeAttribute("filter")), !He) {
            var ke, ce, di, Pe = 8 > b ? 1 : -1;
            for (te = rt.ieOffsetX || 0, ve = rt.ieOffsetY || 0, rt.ieOffsetX = Math.round(
              (he - ((0 > Pt ? -Pt : Pt) * he + (0 > Ht ? -Ht : Ht) * Ve)) / 2 + Be
            ), rt.ieOffsetY = Math.round(
              (Ve - ((0 > Tt ? -Tt : Tt) * Ve + (0 > Ot ? -Ot : Ot) * he)) / 2 + ye
            ), tn = 0; 4 > tn; tn++)
              ce = X[tn], ke = oe[ce], ot = ke.indexOf("px") !== -1 ? parseFloat(ke) : pt(this.t, ce, parseFloat(ke), ke.replace(z, "")) || 0, di = ot !== rt[ce] ? 2 > tn ? -rt.ieOffsetX : -rt.ieOffsetY : 2 > tn ? te - rt.ieOffsetX : ve - rt.ieOffsetY, le[ce] = (rt[ce] = Math.round(
                ot - di * (tn === 0 || tn === 2 ? 1 : Pe)
              )) + "px";
          }
        }
      }, Ka = Ie.set3DTransformRatio = Ie.setTransformRatio = function(L) {
        var Z, ot, rt, I, Mt, st, Pt, Ht, Ot, Tt, le, oe, te, ve, he, Ve, He, ui, Be, ye, ke, ce, di, Pe = this.data, _e = this.t.style, Le = Pe.rotation, mn = Pe.rotationX, On = Pe.rotationY, Ii = Pe.scaleX, Oi = Pe.scaleY, Ui = Pe.scaleZ, $i = Pe.x, Ki = Pe.y, nn = Pe.z, rn = Pe.svg, ki = Pe.perspective, Di = Pe.force3D, Hi = Pe.skewY, mi = Pe.skewX;
        if (Hi && (mi += Hi, Le += Hi), ((L === 1 || L === 0) && Di === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !Di) && !nn && !ki && !On && !mn && Ui === 1 || Rr && rn || !tr)
          return void (Le || mi || rn ? (Le *= Ft, ce = mi * Ft, di = 1e5, ot = Math.cos(Le) * Ii, Mt = Math.sin(Le) * Ii, rt = Math.sin(Le - ce) * -Oi, st = Math.cos(Le - ce) * Oi, ce && Pe.skewType === "simple" && (Z = Math.tan(ce - Hi * Ft), Z = Math.sqrt(1 + Z * Z), rt *= Z, st *= Z, Hi && (Z = Math.tan(Hi * Ft), Z = Math.sqrt(1 + Z * Z), ot *= Z, Mt *= Z)), rn && ($i += Pe.xOrigin - (Pe.xOrigin * ot + Pe.yOrigin * rt) + Pe.xOffset, Ki += Pe.yOrigin - (Pe.xOrigin * Mt + Pe.yOrigin * st) + Pe.yOffset, Rr && (Pe.xPercent || Pe.yPercent) && (he = this.t.getBBox(), $i += 0.01 * Pe.xPercent * he.width, Ki += 0.01 * Pe.yPercent * he.height), he = 1e-6, he > $i && $i > -he && ($i = 0), he > Ki && Ki > -he && (Ki = 0)), Be = (ot * di | 0) / di + "," + (Mt * di | 0) / di + "," + (rt * di | 0) / di + "," + (st * di | 0) / di + "," + $i + "," + Ki + ")", rn && Rr ? this.t.setAttribute("transform", "matrix(" + Be) : _e[dn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix(" : "matrix(") + Be) : _e[dn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix(" : "matrix(") + Ii + ",0,0," + Oi + "," + $i + "," + Ki + ")");
        if (B && (he = 1e-4, he > Ii && Ii > -he && (Ii = Ui = 2e-5), he > Oi && Oi > -he && (Oi = Ui = 2e-5), !ki || Pe.z || Pe.rotationX || Pe.rotationY || (ki = 0)), Le || mi)
          Le *= Ft, Ve = ot = Math.cos(Le), He = Mt = Math.sin(Le), mi && (Le -= mi * Ft, Ve = Math.cos(Le), He = Math.sin(Le), Pe.skewType === "simple" && (Z = Math.tan((mi - Hi) * Ft), Z = Math.sqrt(1 + Z * Z), Ve *= Z, He *= Z, Pe.skewY && (Z = Math.tan(Hi * Ft), Z = Math.sqrt(1 + Z * Z), ot *= Z, Mt *= Z))), rt = -He, st = Ve;
        else {
          if (!(On || mn || Ui !== 1 || ki || rn))
            return void (_e[dn] = (Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) translate3d(" : "translate3d(") + $i + "px," + Ki + "px," + nn + "px)" + (Ii !== 1 || Oi !== 1 ? " scale(" + Ii + "," + Oi + ")" : ""));
          ot = st = 1, rt = Mt = 0;
        }
        Tt = 1, I = Pt = Ht = Ot = le = oe = 0, te = ki ? -1 / ki : 0, ve = Pe.zOrigin, he = 1e-6, ye = ",", ke = "0", Le = On * Ft, Le && (Ve = Math.cos(Le), He = Math.sin(Le), Ht = -He, le = te * -He, I = ot * He, Pt = Mt * He, Tt = Ve, te *= Ve, ot *= Ve, Mt *= Ve), Le = mn * Ft, Le && (Ve = Math.cos(Le), He = Math.sin(Le), Z = rt * Ve + I * He, ui = st * Ve + Pt * He, Ot = Tt * He, oe = te * He, I = rt * -He + I * Ve, Pt = st * -He + Pt * Ve, Tt *= Ve, te *= Ve, rt = Z, st = ui), Ui !== 1 && (I *= Ui, Pt *= Ui, Tt *= Ui, te *= Ui), Oi !== 1 && (rt *= Oi, st *= Oi, Ot *= Oi, oe *= Oi), Ii !== 1 && (ot *= Ii, Mt *= Ii, Ht *= Ii, le *= Ii), (ve || rn) && (ve && ($i += I * -ve, Ki += Pt * -ve, nn += Tt * -ve + ve), rn && ($i += Pe.xOrigin - (Pe.xOrigin * ot + Pe.yOrigin * rt) + Pe.xOffset, Ki += Pe.yOrigin - (Pe.xOrigin * Mt + Pe.yOrigin * st) + Pe.yOffset), he > $i && $i > -he && ($i = ke), he > Ki && Ki > -he && (Ki = ke), he > nn && nn > -he && (nn = 0)), Be = Pe.xPercent || Pe.yPercent ? "translate(" + Pe.xPercent + "%," + Pe.yPercent + "%) matrix3d(" : "matrix3d(", Be += (he > ot && ot > -he ? ke : ot) + ye + (he > Mt && Mt > -he ? ke : Mt) + ye + (he > Ht && Ht > -he ? ke : Ht), Be += ye + (he > le && le > -he ? ke : le) + ye + (he > rt && rt > -he ? ke : rt) + ye + (he > st && st > -he ? ke : st), mn || On || Ui !== 1 ? (Be += ye + (he > Ot && Ot > -he ? ke : Ot) + ye + (he > oe && oe > -he ? ke : oe) + ye + (he > I && I > -he ? ke : I), Be += ye + (he > Pt && Pt > -he ? ke : Pt) + ye + (he > Tt && Tt > -he ? ke : Tt) + ye + (he > te && te > -he ? ke : te) + ye) : Be += ",0,0,0,0,1,0,", Be += $i + ye + Ki + ye + nn + ye + (ki ? 1 + -nn / ki : 1) + ")", _e[dn] = Be;
      };
      U = hs.prototype, U.x = U.y = U.z = U.skewX = U.skewY = U.rotation = U.rotationX = U.rotationY = U.zOrigin = U.xPercent = U.yPercent = U.xOffset = U.yOffset = 0, U.scaleX = U.scaleY = U.scaleZ = 1, Ri(
        "transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",
        {
          parser: function(L, Z, ot, rt, I, Mt, st) {
            if (rt._lastParsedTransform === st)
              return I;
            rt._lastParsedTransform = st;
            var Pt, Ht = st.scale && typeof st.scale == "function" ? st.scale : 0;
            typeof st[ot] == "function" && (Pt = st[ot], st[ot] = Z), Ht && (st.scale = Ht(d, L));
            var Ot, Tt, le, oe, te, ve, he, Ve, He, ui = L._gsTransform, Be = L.style, ye = 1e-6, ke = Ma.length, ce = st, di = {}, Pe = "transformOrigin", _e = Dr(L, G, !0, ce.parseTransform), Le = ce.transform && (typeof ce.transform == "function" ? ce.transform(d, A) : ce.transform);
            if (_e.skewType = ce.skewType || _e.skewType || C.defaultSkewType, rt._transform = _e, "rotationZ" in ce && (ce.rotation = ce.rotationZ), Le && typeof Le == "string" && dn)
              Tt = ti.style, Tt[dn] = Le, Tt.display = "block", Tt.position = "absolute", Le.indexOf("%") !== -1 && (Tt.width = ct(L, "width"), Tt.height = ct(L, "height")), xe.body.appendChild(ti), Ot = Dr(ti, null, !1), _e.skewType === "simple" && (Ot.scaleY *= Math.cos(Ot.skewX * Ft)), _e.svg && (ve = _e.xOrigin, he = _e.yOrigin, Ot.x -= _e.xOffset, Ot.y -= _e.yOffset, (ce.transformOrigin || ce.svgOrigin) && (Le = {}, us(
                L,
                tt(ce.transformOrigin),
                Le,
                ce.svgOrigin,
                ce.smoothOrigin,
                !0
              ), ve = Le.xOrigin, he = Le.yOrigin, Ot.x -= Le.xOffset - _e.xOffset, Ot.y -= Le.yOffset - _e.yOffset), (ve || he) && (Ve = fs(ti, !0), Ot.x -= ve - (ve * Ve[0] + he * Ve[2]), Ot.y -= he - (ve * Ve[1] + he * Ve[3]))), xe.body.removeChild(ti), Ot.perspective || (Ot.perspective = _e.perspective), ce.xPercent != null && (Ot.xPercent = Gt(ce.xPercent, _e.xPercent)), ce.yPercent != null && (Ot.yPercent = Gt(ce.yPercent, _e.yPercent));
            else if (typeof ce == "object") {
              if (Ot = {
                scaleX: Gt(
                  ce.scaleX != null ? ce.scaleX : ce.scale,
                  _e.scaleX
                ),
                scaleY: Gt(
                  ce.scaleY != null ? ce.scaleY : ce.scale,
                  _e.scaleY
                ),
                scaleZ: Gt(ce.scaleZ, _e.scaleZ),
                x: Gt(ce.x, _e.x),
                y: Gt(ce.y, _e.y),
                z: Gt(ce.z, _e.z),
                xPercent: Gt(ce.xPercent, _e.xPercent),
                yPercent: Gt(ce.yPercent, _e.yPercent),
                perspective: Gt(ce.transformPerspective, _e.perspective)
              }, te = ce.directionalRotation, te != null)
                if (typeof te == "object")
                  for (Tt in te)
                    ce[Tt] = te[Tt];
                else
                  ce.rotation = te;
              typeof ce.x == "string" && ce.x.indexOf("%") !== -1 && (Ot.x = 0, Ot.xPercent = Gt(ce.x, _e.xPercent)), typeof ce.y == "string" && ce.y.indexOf("%") !== -1 && (Ot.y = 0, Ot.yPercent = Gt(ce.y, _e.yPercent)), Ot.rotation = Xt(
                "rotation" in ce ? ce.rotation : "shortRotation" in ce ? ce.shortRotation + "_short" : _e.rotation,
                _e.rotation,
                "rotation",
                di
              ), tr && (Ot.rotationX = Xt(
                "rotationX" in ce ? ce.rotationX : "shortRotationX" in ce ? ce.shortRotationX + "_short" : _e.rotationX || 0,
                _e.rotationX,
                "rotationX",
                di
              ), Ot.rotationY = Xt(
                "rotationY" in ce ? ce.rotationY : "shortRotationY" in ce ? ce.shortRotationY + "_short" : _e.rotationY || 0,
                _e.rotationY,
                "rotationY",
                di
              )), Ot.skewX = Xt(ce.skewX, _e.skewX), Ot.skewY = Xt(ce.skewY, _e.skewY);
            }
            for (tr && ce.force3D != null && (_e.force3D = ce.force3D, oe = !0), le = _e.force3D || _e.z || _e.rotationX || _e.rotationY || Ot.z || Ot.rotationX || Ot.rotationY || Ot.perspective, le || ce.scale == null || (Ot.scaleZ = 1); --ke > -1; )
              He = Ma[ke], Le = Ot[He] - _e[He], (Le > ye || -ye > Le || ce[He] != null || kt[He] != null) && (oe = !0, I = new Si(_e, He, _e[He], Le, I), He in di && (I.e = di[He]), I.xs0 = 0, I.plugin = Mt, rt._overwriteProps.push(I.n));
            return Le = ce.transformOrigin, _e.svg && (Le || ce.svgOrigin) && (ve = _e.xOffset, he = _e.yOffset, us(L, tt(Le), Ot, ce.svgOrigin, ce.smoothOrigin), I = wr(
              _e,
              "xOrigin",
              (ui ? _e : Ot).xOrigin,
              Ot.xOrigin,
              I,
              Pe
            ), I = wr(
              _e,
              "yOrigin",
              (ui ? _e : Ot).yOrigin,
              Ot.yOrigin,
              I,
              Pe
            ), (ve !== _e.xOffset || he !== _e.yOffset) && (I = wr(
              _e,
              "xOffset",
              ui ? ve : _e.xOffset,
              _e.xOffset,
              I,
              Pe
            ), I = wr(
              _e,
              "yOffset",
              ui ? he : _e.yOffset,
              _e.yOffset,
              I,
              Pe
            )), Le = "0px 0px"), (Le || tr && le && _e.zOrigin) && (dn ? (oe = !0, He = Lo, Le = (Le || ct(L, He, G, !1, "50% 50%")) + "", I = new Si(Be, He, 0, 0, I, -1, Pe), I.b = Be[He], I.plugin = Mt, tr ? (Tt = _e.zOrigin, Le = Le.split(" "), _e.zOrigin = (Le.length > 2 && (Tt === 0 || Le[2] !== "0px") ? parseFloat(Le[2]) : Tt) || 0, I.xs0 = I.e = Le[0] + " " + (Le[1] || "50%") + " 0px", I = new Si(_e, "zOrigin", 0, 0, I, -1, I.n), I.b = Tt, I.xs0 = I.e = _e.zOrigin) : I.xs0 = I.e = Le) : tt(Le + "", _e)), oe && (rt._transformType = _e.svg && Rr || !le && this._transformType !== 3 ? 2 : 3), Pt && (st[ot] = Pt), Ht && (st.scale = Ht), I;
          },
          prefix: !0
        }
      ), Ri("boxShadow", {
        defaultValue: "0px 0px 0px 0px #999",
        prefix: !0,
        color: !0,
        multi: !0,
        keyword: "inset"
      }), Ri("borderRadius", {
        defaultValue: "0px",
        parser: function(L, Z, ot, rt, I, Mt) {
          Z = this.format(Z);
          var st, Pt, Ht, Ot, Tt, le, oe, te, ve, he, Ve, He, ui, Be, ye, ke, ce = [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomRightRadius",
            "borderBottomLeftRadius"
          ], di = L.style;
          for (ve = parseFloat(L.offsetWidth), he = parseFloat(L.offsetHeight), st = Z.split(" "), Pt = 0; Pt < ce.length; Pt++)
            this.p.indexOf("border") && (ce[Pt] = Jt(ce[Pt])), Tt = Ot = ct(L, ce[Pt], G, !1, "0px"), Tt.indexOf(" ") !== -1 && (Ot = Tt.split(" "), Tt = Ot[0], Ot = Ot[1]), le = Ht = st[Pt], oe = parseFloat(Tt), He = Tt.substr((oe + "").length), ui = le.charAt(1) === "=", ui ? (te = parseInt(le.charAt(0) + "1", 10), le = le.substr(2), te *= parseFloat(le), Ve = le.substr((te + "").length - (0 > te ? 1 : 0)) || "") : (te = parseFloat(le), Ve = le.substr((te + "").length)), Ve === "" && (Ve = $[ot] || He), Ve !== He && (Be = pt(L, "borderLeft", oe, He), ye = pt(L, "borderTop", oe, He), Ve === "%" ? (Tt = Be / ve * 100 + "%", Ot = ye / he * 100 + "%") : Ve === "em" ? (ke = pt(L, "borderLeft", 1, "em"), Tt = Be / ke + "em", Ot = ye / ke + "em") : (Tt = Be + "px", Ot = ye + "px"), ui && (le = parseFloat(Tt) + te + Ve, Ht = parseFloat(Ot) + te + Ve)), I = jn(di, ce[Pt], Tt + " " + Ot, le + " " + Ht, !1, "0px", I);
          return I;
        },
        prefix: !0,
        formatter: vi("0px 0px 0px 0px", !1, !0)
      }), Ri(
        "borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius",
        {
          defaultValue: "0px",
          parser: function(L, Z, ot, rt, I, Mt) {
            return jn(
              L.style,
              ot,
              this.format(ct(L, ot, G, !1, "0px 0px")),
              this.format(Z),
              !1,
              "0px",
              I
            );
          },
          prefix: !0,
          formatter: vi("0px 0px", !1, !0)
        }
      ), Ri("backgroundPosition", {
        defaultValue: "0 0",
        parser: function(L, Z, ot, rt, I, Mt) {
          var st, Pt, Ht, Ot, Tt, le, oe = "background-position", te = G || jt(L, null), ve = this.format(
            (te ? b ? te.getPropertyValue(oe + "-x") + " " + te.getPropertyValue(oe + "-y") : te.getPropertyValue(oe) : L.currentStyle.backgroundPositionX + " " + L.currentStyle.backgroundPositionY) || "0 0"
          ), he = this.format(Z);
          if (ve.indexOf("%") !== -1 != (he.indexOf("%") !== -1) && he.split(",").length < 2 && (le = ct(L, "backgroundImage").replace(Et, ""), le && le !== "none")) {
            for (st = ve.split(" "), Pt = he.split(" "), Ni.setAttribute("src", le), Ht = 2; --Ht > -1; )
              ve = st[Ht], Ot = ve.indexOf("%") !== -1, Ot !== (Pt[Ht].indexOf("%") !== -1) && (Tt = Ht === 0 ? L.offsetWidth - Ni.width : L.offsetHeight - Ni.height, st[Ht] = Ot ? parseFloat(ve) / 100 * Tt + "px" : parseFloat(ve) / Tt * 100 + "%");
            ve = st.join(" ");
          }
          return this.parseComplex(L.style, ve, he, I, Mt);
        },
        formatter: tt
      }), Ri("backgroundSize", {
        defaultValue: "0 0",
        formatter: function(L) {
          return L += "", L.substr(0, 2) === "co" ? L : tt(L.indexOf(" ") === -1 ? L + " " + L : L);
        }
      }), Ri("perspective", { defaultValue: "0px", prefix: !0 }), Ri("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), Ri("transformStyle", { prefix: !0 }), Ri("backfaceVisibility", { prefix: !0 }), Ri("userSelect", { prefix: !0 }), Ri("margin", {
        parser: Mi("marginTop,marginRight,marginBottom,marginLeft")
      }), Ri("padding", {
        parser: Mi("paddingTop,paddingRight,paddingBottom,paddingLeft")
      }), Ri("clip", {
        defaultValue: "rect(0px,0px,0px,0px)",
        parser: function(L, Z, ot, rt, I, Mt) {
          var st, Pt, Ht;
          return 9 > b ? (Pt = L.currentStyle, Ht = 8 > b ? " " : ",", st = "rect(" + Pt.clipTop + Ht + Pt.clipRight + Ht + Pt.clipBottom + Ht + Pt.clipLeft + ")", Z = this.format(Z).split(",").join(Ht)) : (st = this.format(ct(L, this.p, G, !1, this.dflt)), Z = this.format(Z)), this.parseComplex(L.style, st, Z, I, Mt);
        }
      }), Ri("textShadow", {
        defaultValue: "0px 0px 0px #999",
        color: !0,
        multi: !0
      }), Ri("autoRound,strictUnits", {
        parser: function(L, Z, ot, rt, I) {
          return I;
        }
      }), Ri("border", {
        defaultValue: "0px solid #000",
        parser: function(L, Z, ot, rt, I, Mt) {
          var st = ct(L, "borderTopWidth", G, !1, "0px"), Pt = this.format(Z).split(" "), Ht = Pt[0].replace(z, "");
          return Ht !== "px" && (st = parseFloat(st) / pt(L, "borderTopWidth", 1, Ht) + Ht), this.parseComplex(
            L.style,
            this.format(
              st + " " + ct(L, "borderTopStyle", G, !1, "solid") + " " + ct(L, "borderTopColor", G, !1, "#000")
            ),
            Pt.join(" "),
            I,
            Mt
          );
        },
        color: !0,
        formatter: function(L) {
          var Z = L.split(" ");
          return Z[0] + " " + (Z[1] || "solid") + " " + (L.match(we) || ["#000"])[0];
        }
      }), Ri("borderWidth", {
        parser: Mi(
          "borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth"
        )
      }), Ri("float,cssFloat,styleFloat", {
        parser: function(L, Z, ot, rt, I, Mt) {
          var st = L.style, Pt = "cssFloat" in st ? "cssFloat" : "styleFloat";
          return new Si(st, Pt, 0, 0, I, -1, ot, !1, 0, st[Pt], Z);
        }
      });
      var Qa = function(L) {
        var Z, ot = this.t, rt = ot.filter || ct(this.data, "filter") || "", I = this.s + this.c * L | 0;
        I === 100 && (rt.indexOf("atrix(") === -1 && rt.indexOf("radient(") === -1 && rt.indexOf("oader(") === -1 ? (ot.removeAttribute("filter"), Z = !ct(this.data, "filter")) : (ot.filter = rt.replace(ft, ""), Z = !0)), Z || (this.xn1 && (ot.filter = rt = rt || "alpha(opacity=" + I + ")"), rt.indexOf("pacity") === -1 ? I === 0 && this.xn1 || (ot.filter = rt + " alpha(opacity=" + I + ")") : ot.filter = rt.replace(V, "opacity=" + I));
      };
      Ri("opacity,alpha,autoAlpha", {
        defaultValue: "1",
        parser: function(L, Z, ot, rt, I, Mt) {
          var st = parseFloat(ct(L, "opacity", G, !1, "1")), Pt = L.style, Ht = ot === "autoAlpha";
          return typeof Z == "string" && Z.charAt(1) === "=" && (Z = (Z.charAt(0) === "-" ? -1 : 1) * parseFloat(Z.substr(2)) + st), Ht && st === 1 && ct(L, "visibility", G) === "hidden" && Z !== 0 && (st = 0), pi ? I = new Si(Pt, "opacity", st, Z - st, I) : (I = new Si(Pt, "opacity", 100 * st, 100 * (Z - st), I), I.xn1 = Ht ? 1 : 0, Pt.zoom = 1, I.type = 2, I.b = "alpha(opacity=" + I.s + ")", I.e = "alpha(opacity=" + (I.s + I.c) + ")", I.data = L, I.plugin = Mt, I.setRatio = Qa), Ht && (I = new Si(
            Pt,
            "visibility",
            0,
            0,
            I,
            -1,
            null,
            !1,
            0,
            st !== 0 ? "inherit" : "hidden",
            Z === 0 ? "hidden" : "inherit"
          ), I.xs0 = "inherit", rt._overwriteProps.push(I.n), rt._overwriteProps.push(ot)), I;
        }
      });
      var Ro = function(L, Z) {
        Z && (L.removeProperty ? ((Z.substr(0, 2) === "ms" || Z.substr(0, 6) === "webkit") && (Z = "-" + Z), L.removeProperty(Z.replace(zt, "-$1").toLowerCase())) : L.removeAttribute(Z));
      }, Io = function(L) {
        if (this.t._gsClassPT = this, L === 1 || L === 0) {
          this.t.setAttribute("class", L === 0 ? this.b : this.e);
          for (var Z = this.data, ot = this.t.style; Z; )
            Z.v ? ot[Z.p] = Z.v : Ro(ot, Z.p), Z = Z._next;
          L === 1 && this.t._gsClassPT === this && (this.t._gsClassPT = null);
        } else
          this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
      };
      Ri("className", {
        parser: function(L, Z, ot, rt, I, Mt, st) {
          var Pt, Ht, Ot, Tt, le, oe = L.getAttribute("class") || "", te = L.style.cssText;
          if (I = rt._classNamePT = new Si(L, ot, 0, 0, I, 2), I.setRatio = Io, I.pr = -11, p = !0, I.b = oe, Ht = ie(L, G), Ot = L._gsClassPT) {
            for (Tt = {}, le = Ot.data; le; )
              Tt[le.p] = 1, le = le._next;
            Ot.setRatio(1);
          }
          return L._gsClassPT = I, I.e = Z.charAt(1) !== "=" ? Z : oe.replace(
            new RegExp("(?:\\s|^)" + Z.substr(2) + "(?![\\w-])"),
            ""
          ) + (Z.charAt(0) === "+" ? " " + Z.substr(2) : ""), L.setAttribute("class", I.e), Pt = Kt(L, Ht, ie(L), st, Tt), L.setAttribute("class", oe), I.data = Pt.firstMPT, L.style.cssText = te, I = I.xfirst = rt.parse(L, Pt.difs, I, Mt);
        }
      });
      var ba = function(L) {
        if ((L === 1 || L === 0) && this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
          var Z, ot, rt, I, Mt, st = this.t.style, Pt = E.transform.parse;
          if (this.e === "all")
            st.cssText = "", I = !0;
          else
            for (Z = this.e.split(" ").join("").split(","), rt = Z.length; --rt > -1; )
              ot = Z[rt], E[ot] && (E[ot].parse === Pt ? I = !0 : ot = ot === "transformOrigin" ? Lo : E[ot].p), Ro(st, ot);
          I && (Ro(st, dn), Mt = this.t._gsTransform, Mt && (Mt.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform));
        }
      };
      for (Ri("clearProps", {
        parser: function(L, Z, ot, rt, I) {
          return I = new Si(L, ot, 0, 0, I, 2), I.setRatio = ba, I.e = Z, I.pr = -10, I.data = rt._tween, p = !0, I;
        }
      }), U = "bezier,throwProps,physicsProps,physics2D".split(","), tn = U.length; tn--; )
        co(U[tn]);
      U = C.prototype, U._firstPT = U._lastParsedTransform = U._transform = null, U._onInitTween = function(L, Z, ot, rt) {
        if (!L.nodeType)
          return !1;
        this._target = A = L, this._tween = ot, this._vars = Z, d = rt, Y = Z.autoRound, p = !1, $ = Z.suffixMap || C.suffixMap, G = jt(L, ""), m = this._overwriteProps;
        var I, Mt, st, Pt, Ht, Ot, Tt, le, oe, te = L.style;
        if (H && te.zIndex === "" && (I = ct(L, "zIndex", G), (I === "auto" || I === "") && this._addLazySet(te, "zIndex", 0)), typeof Z == "string" && (Pt = te.cssText, I = ie(L, G), te.cssText = Pt + ";" + Z, I = Kt(L, I, ie(L)).difs, !pi && ht.test(Z) && (I.opacity = parseFloat(RegExp.$1)), Z = I, te.cssText = Pt), Z.className ? this._firstPT = Mt = E.className.parse(
          L,
          Z.className,
          "className",
          this,
          null,
          null,
          Z
        ) : this._firstPT = Mt = this.parse(L, Z, null), this._transformType) {
          for (oe = this._transformType === 3, dn ? K && (H = !0, te.zIndex === "" && (Tt = ct(L, "zIndex", G), (Tt === "auto" || Tt === "") && this._addLazySet(te, "zIndex", 0)), q && this._addLazySet(
            te,
            "WebkitBackfaceVisibility",
            this._vars.WebkitBackfaceVisibility || (oe ? "visible" : "hidden")
          )) : te.zoom = 1, st = Mt; st && st._next; )
            st = st._next;
          le = new Si(L, "transform", 0, 0, null, 2), this._linkCSSP(le, null, st), le.setRatio = dn ? Ka : Ea, le.data = this._transform || Dr(L, G, !0), le.tween = ot, le.pr = -1, m.pop();
        }
        if (p) {
          for (; Mt; ) {
            for (Ot = Mt._next, st = Pt; st && st.pr > Mt.pr; )
              st = st._next;
            (Mt._prev = st ? st._prev : Ht) ? Mt._prev._next = Mt : Pt = Mt, (Mt._next = st) ? st._prev = Mt : Ht = Mt, Mt = Ot;
          }
          this._firstPT = Pt;
        }
        return !0;
      }, U.parse = function(L, Z, ot, rt) {
        var I, Mt, st, Pt, Ht, Ot, Tt, le, oe, te, ve = L.style;
        for (I in Z) {
          if (Ot = Z[I], typeof Ot == "function" && (Ot = Ot(d, A)), Mt = E[I])
            ot = Mt.parse(L, Ot, I, this, ot, rt, Z);
          else {
            if (I.substr(0, 2) === "--") {
              this._tween._propLookup[I] = this._addTween.call(
                this._tween,
                L.style,
                "setProperty",
                jt(L).getPropertyValue(I) + "",
                Ot + "",
                I,
                !1,
                I
              );
              continue;
            }
            Ht = ct(L, I, G) + "", oe = typeof Ot == "string", I === "color" || I === "fill" || I === "stroke" || I.indexOf("Color") !== -1 || oe && gt.test(Ot) ? (oe || (Ot = Re(Ot), Ot = (Ot.length > 3 ? "rgba(" : "rgb(") + Ot.join(",") + ")"), ot = jn(ve, I, Ht, Ot, !0, "transparent", ot, 0, rt)) : oe && ue.test(Ot) ? ot = jn(ve, I, Ht, Ot, !0, null, ot, 0, rt) : (st = parseFloat(Ht), Tt = st || st === 0 ? Ht.substr((st + "").length) : "", (Ht === "" || Ht === "auto") && (I === "width" || I === "height" ? (st = nt(L, I, G), Tt = "px") : I === "left" || I === "top" ? (st = Lt(L, I, G), Tt = "px") : (st = I !== "opacity" ? 0 : 1, Tt = "")), te = oe && Ot.charAt(1) === "=", te ? (Pt = parseInt(Ot.charAt(0) + "1", 10), Ot = Ot.substr(2), Pt *= parseFloat(Ot), le = Ot.replace(z, "")) : (Pt = parseFloat(Ot), le = oe ? Ot.replace(z, "") : ""), le === "" && (le = I in $ ? $[I] : Tt), Ot = Pt || Pt === 0 ? (te ? Pt + st : Pt) + le : Z[I], Tt !== le && (le !== "" || I === "lineHeight") && (Pt || Pt === 0) && st && (st = pt(L, I, st, Tt), le === "%" ? (st /= pt(L, I, 100, "%") / 100, Z.strictUnits !== !0 && (Ht = st + "%")) : le === "em" || le === "rem" || le === "vw" || le === "vh" ? st /= pt(L, I, 1, le) : le !== "px" && (Pt = pt(L, I, Pt, le), le = "px"), te && (Pt || Pt === 0) && (Ot = Pt + st + le)), te && (Pt += st), !st && st !== 0 || !Pt && Pt !== 0 ? ve[I] !== void 0 && (Ot || Ot + "" != "NaN" && Ot != null) ? (ot = new Si(
              ve,
              I,
              Pt || st || 0,
              0,
              ot,
              -1,
              I,
              !1,
              0,
              Ht,
              Ot
            ), ot.xs0 = Ot !== "none" || I !== "display" && I.indexOf("Style") === -1 ? Ot : Ht) : an("invalid " + I + " tween value: " + Z[I]) : (ot = new Si(
              ve,
              I,
              st,
              Pt - st,
              ot,
              0,
              I,
              Y !== !1 && (le === "px" || I === "zIndex"),
              0,
              Ht,
              Ot
            ), ot.xs0 = le));
          }
          rt && ot && !ot.plugin && (ot.plugin = rt);
        }
        return ot;
      }, U.setRatio = function(L) {
        var Z, ot, rt, I = this._firstPT, Mt = 1e-6;
        if (L !== 1 || this._tween._time !== this._tween._duration && this._tween._time !== 0)
          if (L || this._tween._time !== this._tween._duration && this._tween._time !== 0 || this._tween._rawPrevTime === -1e-6)
            for (; I; ) {
              if (Z = I.c * L + I.s, I.r ? Z = I.r(Z) : Mt > Z && Z > -Mt && (Z = 0), I.type)
                if (I.type === 1)
                  if (rt = I.l, rt === 2)
                    I.t[I.p] = I.xs0 + Z + I.xs1 + I.xn1 + I.xs2;
                  else if (rt === 3)
                    I.t[I.p] = I.xs0 + Z + I.xs1 + I.xn1 + I.xs2 + I.xn2 + I.xs3;
                  else if (rt === 4)
                    I.t[I.p] = I.xs0 + Z + I.xs1 + I.xn1 + I.xs2 + I.xn2 + I.xs3 + I.xn3 + I.xs4;
                  else if (rt === 5)
                    I.t[I.p] = I.xs0 + Z + I.xs1 + I.xn1 + I.xs2 + I.xn2 + I.xs3 + I.xn3 + I.xs4 + I.xn4 + I.xs5;
                  else {
                    for (ot = I.xs0 + Z + I.xs1, rt = 1; rt < I.l; rt++)
                      ot += I["xn" + rt] + I["xs" + (rt + 1)];
                    I.t[I.p] = ot;
                  }
                else
                  I.type === -1 ? I.t[I.p] = I.xs0 : I.setRatio && I.setRatio(L);
              else
                I.t[I.p] = Z + I.xs0;
              I = I._next;
            }
          else
            for (; I; )
              I.type !== 2 ? I.t[I.p] = I.b : I.setRatio(L), I = I._next;
        else
          for (; I; ) {
            if (I.type !== 2)
              if (I.r && I.type !== -1)
                if (Z = I.r(I.s + I.c), I.type) {
                  if (I.type === 1) {
                    for (rt = I.l, ot = I.xs0 + Z + I.xs1, rt = 1; rt < I.l; rt++)
                      ot += I["xn" + rt] + I["xs" + (rt + 1)];
                    I.t[I.p] = ot;
                  }
                } else
                  I.t[I.p] = Z + I.xs0;
              else
                I.t[I.p] = I.e;
            else
              I.setRatio(L);
            I = I._next;
          }
      }, U._enableTransforms = function(L) {
        this._transform = this._transform || Dr(this._target, G, !0), this._transformType = this._transform.svg && Rr || !L && this._transformType !== 3 ? 2 : 3;
      };
      var Aa = function(L) {
        this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
      };
      U._addLazySet = function(L, Z, ot) {
        var rt = this._firstPT = new Si(L, Z, 0, 0, this._firstPT, 2);
        rt.e = ot, rt.setRatio = Aa, rt.data = this;
      }, U._linkCSSP = function(L, Z, ot, rt) {
        return L && (Z && (Z._prev = L), L._next && (L._next._prev = L._prev), L._prev ? L._prev._next = L._next : this._firstPT === L && (this._firstPT = L._next, rt = !0), ot ? ot._next = L : rt || this._firstPT !== null || (this._firstPT = L), L._next = Z, L._prev = ot), L;
      }, U._mod = function(L) {
        for (var Z = this._firstPT; Z; )
          typeof L[Z.p] == "function" && (Z.r = L[Z.p]), Z = Z._next;
      }, U._kill = function(L) {
        var Z, ot, rt, I = L;
        if (L.autoAlpha || L.alpha) {
          I = {};
          for (ot in L)
            I[ot] = L[ot];
          I.opacity = 1, I.autoAlpha && (I.visibility = 1);
        }
        for (L.className && (Z = this._classNamePT) && (rt = Z.xfirst, rt && rt._prev ? this._linkCSSP(rt._prev, Z._next, rt._prev._prev) : rt === this._firstPT && (this._firstPT = Z._next), Z._next && this._linkCSSP(Z._next, Z._next._next, rt._prev), this._classNamePT = null), Z = this._firstPT; Z; )
          Z.plugin && Z.plugin !== ot && Z.plugin._kill && (Z.plugin._kill(L), ot = Z.plugin), Z = Z._next;
        return T.prototype._kill.call(this, I);
      };
      var Tr = function(L, Z, ot) {
        var rt, I, Mt, st;
        if (L.slice)
          for (I = L.length; --I > -1; )
            Tr(L[I], Z, ot);
        else
          for (rt = L.childNodes, I = rt.length; --I > -1; )
            Mt = rt[I], st = Mt.type, Mt.style && (Z.push(ie(Mt)), ot && ot.push(Mt)), st !== 1 && st !== 9 && st !== 11 || !Mt.childNodes.length || Tr(Mt, Z, ot);
      };
      return C.cascadeTo = function(L, Z, ot) {
        var rt, I, Mt, st, Pt = J.to(L, Z, ot), Ht = [Pt], Ot = [], Tt = [], le = [], oe = J._internals.reservedProps;
        for (L = Pt._targets || Pt.target, Tr(L, Ot, le), Pt.render(Z, !0, !0), Tr(L, Tt), Pt.render(0, !0, !0), Pt._enabled(!0), rt = le.length; --rt > -1; )
          if (I = Kt(le[rt], Ot[rt], Tt[rt]), I.firstMPT) {
            I = I.difs;
            for (Mt in ot)
              oe[Mt] && (I[Mt] = ot[Mt]);
            st = {};
            for (Mt in I)
              st[Mt] = Ot[rt][Mt];
            Ht.push(J.fromTo(le[rt], Z, st, I));
          }
        return Ht;
      }, T.activate([C]), C;
    },
    !0
  ), function() {
    var T = sn._gsDefine.plugin({
      propName: "roundProps",
      version: "1.7.0",
      priority: -1,
      API: 2,
      init: function(G, m, C) {
        return this._tween = C, !0;
      }
    }), J = function(G) {
      var m = 1 > G ? Math.pow(10, (G + "").length - 2) : 1;
      return function(C) {
        return (Math.round(C / G) * G * m | 0) / m;
      };
    }, p = function(G, m) {
      for (; G; )
        G.f || G.blob || (G.m = m || Math.round), G = G._next;
    }, $ = T.prototype;
    $._onInitAllProps = function() {
      var G, m, C, O, E = this._tween, U = E.vars.roundProps, Y = {}, H = E._propLookup.roundProps;
      if (typeof U != "object" || U.push)
        for (typeof U == "string" && (U = U.split(",")), C = U.length; --C > -1; )
          Y[U[C]] = Math.round;
      else
        for (O in U)
          Y[O] = J(U[O]);
      for (O in Y)
        for (G = E._firstPT; G; )
          m = G._next, G.pg ? G.t._mod(Y) : G.n === O && (G.f === 2 && G.t ? p(G.t._firstPT, Y[O]) : (this._add(G.t, O, G.s, G.c, Y[O]), m && (m._prev = G._prev), G._prev ? G._prev._next = m : E._firstPT === G && (E._firstPT = m), G._next = G._prev = null, E._propLookup[O] = H)), G = m;
      return !1;
    }, $._add = function(G, m, C, O, E) {
      this._addTween(G, m, C, C + O, m, E || Math.round), this._overwriteProps.push(m);
    };
  }(), function() {
    sn._gsDefine.plugin({
      propName: "attr",
      API: 2,
      version: "0.6.1",
      init: function(T, J, p, $) {
        var G, m;
        if (typeof T.setAttribute != "function")
          return !1;
        for (G in J)
          m = J[G], typeof m == "function" && (m = m($, T)), this._addTween(
            T,
            "setAttribute",
            T.getAttribute(G) + "",
            m + "",
            G,
            !1,
            G
          ), this._overwriteProps.push(G);
        return !0;
      }
    });
  }(), sn._gsDefine.plugin({
    propName: "directionalRotation",
    version: "0.3.1",
    API: 2,
    init: function(T, J, p, $) {
      typeof J != "object" && (J = { rotation: J }), this.finals = {};
      var G, m, C, O, E, U, Y = J.useRadians === !0 ? 2 * Math.PI : 360, H = 1e-6;
      for (G in J)
        G !== "useRadians" && (O = J[G], typeof O == "function" && (O = O($, T)), U = (O + "").split("_"), m = U[0], C = parseFloat(
          typeof T[G] != "function" ? T[G] : T[G.indexOf("set") || typeof T["get" + G.substr(3)] != "function" ? G : "get" + G.substr(3)]()
        ), O = this.finals[G] = typeof m == "string" && m.charAt(1) === "=" ? C + parseInt(m.charAt(0) + "1", 10) * Number(m.substr(2)) : Number(m) || 0, E = O - C, U.length && (m = U.join("_"), m.indexOf("short") !== -1 && (E %= Y, E !== E % (Y / 2) && (E = 0 > E ? E + Y : E - Y)), m.indexOf("_cw") !== -1 && 0 > E ? E = (E + 9999999999 * Y) % Y - (E / Y | 0) * Y : m.indexOf("ccw") !== -1 && E > 0 && (E = (E - 9999999999 * Y) % Y - (E / Y | 0) * Y)), (E > H || -H > E) && (this._addTween(T, G, C, C + E, G), this._overwriteProps.push(G)));
      return !0;
    },
    set: function(T) {
      var J;
      if (T !== 1)
        this._super.setRatio.call(this, T);
      else
        for (J = this._firstPT; J; )
          J.f ? J.t[J.p](this.finals[J.p]) : J.t[J.p] = this.finals[J.p], J = J._next;
    }
  })._autoCSS = !0, sn._gsDefine(
    "easing.Back",
    ["easing.Ease"],
    function(T) {
      var J, p, $, G, m = sn.GreenSockGlobals || sn, C = m.com.greensock, O = 2 * Math.PI, E = Math.PI / 2, U = C._class, Y = function(g, M) {
        var x = U("easing." + g, function() {
        }, !0), F = x.prototype = new T();
        return F.constructor = x, F.getRatio = M, x;
      }, H = T.register || function() {
      }, K = function(g, M, x, F, z) {
        var V = U(
          "easing." + g,
          { easeOut: new M(), easeIn: new x(), easeInOut: new F() },
          !0
        );
        return H(V, g), V;
      }, B = function(g, M, x) {
        this.t = g, this.v = M, x && (this.next = x, x.prev = this, this.c = x.v - M, this.gap = x.t - g);
      }, q = function(g, M) {
        var x = U(
          "easing." + g,
          function(z) {
            this._p1 = z || z === 0 ? z : 1.70158, this._p2 = 1.525 * this._p1;
          },
          !0
        ), F = x.prototype = new T();
        return F.constructor = x, F.getRatio = M, F.config = function(z) {
          return new x(z);
        }, x;
      }, b = K(
        "Back",
        q("BackOut", function(g) {
          return (g -= 1) * g * ((this._p1 + 1) * g + this._p1) + 1;
        }),
        q("BackIn", function(g) {
          return g * g * ((this._p1 + 1) * g - this._p1);
        }),
        q("BackInOut", function(g) {
          return (g *= 2) < 1 ? 0.5 * g * g * ((this._p2 + 1) * g - this._p2) : 0.5 * ((g -= 2) * g * ((this._p2 + 1) * g + this._p2) + 2);
        })
      ), A = U(
        "easing.SlowMo",
        function(g, M, x) {
          M = M || M === 0 ? M : 0.7, g == null ? g = 0.7 : g > 1 && (g = 1), this._p = g !== 1 ? M : 0, this._p1 = (1 - g) / 2, this._p2 = g, this._p3 = this._p1 + this._p2, this._calcEnd = x === !0;
        },
        !0
      ), d = A.prototype = new T();
      return d.constructor = A, d.getRatio = function(g) {
        var M = g + (0.5 - g) * this._p;
        return g < this._p1 ? this._calcEnd ? 1 - (g = 1 - g / this._p1) * g : M - (g = 1 - g / this._p1) * g * g * g * M : g > this._p3 ? this._calcEnd ? g === 1 ? 0 : 1 - (g = (g - this._p3) / this._p1) * g : M + (g - M) * (g = (g - this._p3) / this._p1) * g * g * g : this._calcEnd ? 1 : M;
      }, A.ease = new A(0.7, 0.7), d.config = A.config = function(g, M, x) {
        return new A(g, M, x);
      }, J = U(
        "easing.SteppedEase",
        function(g, M) {
          g = g || 1, this._p1 = 1 / g, this._p2 = g + (M ? 0 : 1), this._p3 = M ? 1 : 0;
        },
        !0
      ), d = J.prototype = new T(), d.constructor = J, d.getRatio = function(g) {
        return 0 > g ? g = 0 : g >= 1 && (g = 0.999999999), ((this._p2 * g | 0) + this._p3) * this._p1;
      }, d.config = J.config = function(g, M) {
        return new J(g, M);
      }, p = U(
        "easing.ExpoScaleEase",
        function(g, M, x) {
          this._p1 = Math.log(M / g), this._p2 = M - g, this._p3 = g, this._ease = x;
        },
        !0
      ), d = p.prototype = new T(), d.constructor = p, d.getRatio = function(g) {
        return this._ease && (g = this._ease.getRatio(g)), (this._p3 * Math.exp(this._p1 * g) - this._p3) / this._p2;
      }, d.config = p.config = function(g, M, x) {
        return new p(g, M, x);
      }, $ = U(
        "easing.RoughEase",
        function(g) {
          g = g || {};
          for (var M, x, F, z, V, ht, ft = g.taper || "none", gt = [], zt = 0, lt = 0 | (g.points || 20), Et = lt, D = g.randomize !== !1, Bt = g.clamp === !0, Ct = g.template instanceof T ? g.template : null, Rt = typeof g.strength == "number" ? 0.4 * g.strength : 0.4; --Et > -1; )
            M = D ? Math.random() : 1 / lt * Et, x = Ct ? Ct.getRatio(M) : M, ft === "none" ? F = Rt : ft === "out" ? (z = 1 - M, F = z * z * Rt) : ft === "in" ? F = M * M * Rt : 0.5 > M ? (z = 2 * M, F = z * z * 0.5 * Rt) : (z = 2 * (1 - M), F = z * z * 0.5 * Rt), D ? x += Math.random() * F - 0.5 * F : Et % 2 ? x += 0.5 * F : x -= 0.5 * F, Bt && (x > 1 ? x = 1 : 0 > x && (x = 0)), gt[zt++] = { x: M, y: x };
          for (gt.sort(function(ge, ue) {
            return ge.x - ue.x;
          }), ht = new B(1, 1, null), Et = lt; --Et > -1; )
            V = gt[Et], ht = new B(V.x, V.y, ht);
          this._prev = new B(0, 0, ht.t !== 0 ? ht : ht.next);
        },
        !0
      ), d = $.prototype = new T(), d.constructor = $, d.getRatio = function(g) {
        var M = this._prev;
        if (g > M.t) {
          for (; M.next && g >= M.t; )
            M = M.next;
          M = M.prev;
        } else
          for (; M.prev && g <= M.t; )
            M = M.prev;
        return this._prev = M, M.v + (g - M.t) / M.gap * M.c;
      }, d.config = function(g) {
        return new $(g);
      }, $.ease = new $(), K(
        "Bounce",
        Y("BounceOut", function(g) {
          return 1 / 2.75 > g ? 7.5625 * g * g : 2 / 2.75 > g ? 7.5625 * (g -= 1.5 / 2.75) * g + 0.75 : 2.5 / 2.75 > g ? 7.5625 * (g -= 2.25 / 2.75) * g + 0.9375 : 7.5625 * (g -= 2.625 / 2.75) * g + 0.984375;
        }),
        Y("BounceIn", function(g) {
          return (g = 1 - g) < 1 / 2.75 ? 1 - 7.5625 * g * g : 2 / 2.75 > g ? 1 - (7.5625 * (g -= 1.5 / 2.75) * g + 0.75) : 2.5 / 2.75 > g ? 1 - (7.5625 * (g -= 2.25 / 2.75) * g + 0.9375) : 1 - (7.5625 * (g -= 2.625 / 2.75) * g + 0.984375);
        }),
        Y("BounceInOut", function(g) {
          var M = 0.5 > g;
          return g = M ? 1 - 2 * g : 2 * g - 1, g = 1 / 2.75 > g ? 7.5625 * g * g : 2 / 2.75 > g ? 7.5625 * (g -= 1.5 / 2.75) * g + 0.75 : 2.5 / 2.75 > g ? 7.5625 * (g -= 2.25 / 2.75) * g + 0.9375 : 7.5625 * (g -= 2.625 / 2.75) * g + 0.984375, M ? 0.5 * (1 - g) : 0.5 * g + 0.5;
        })
      ), K(
        "Circ",
        Y("CircOut", function(g) {
          return Math.sqrt(1 - (g -= 1) * g);
        }),
        Y("CircIn", function(g) {
          return -(Math.sqrt(1 - g * g) - 1);
        }),
        Y("CircInOut", function(g) {
          return (g *= 2) < 1 ? -0.5 * (Math.sqrt(1 - g * g) - 1) : 0.5 * (Math.sqrt(1 - (g -= 2) * g) + 1);
        })
      ), G = function(g, M, x) {
        var F = U(
          "easing." + g,
          function(V, ht) {
            this._p1 = V >= 1 ? V : 1, this._p2 = (ht || x) / (1 > V ? V : 1), this._p3 = this._p2 / O * (Math.asin(1 / this._p1) || 0), this._p2 = O / this._p2;
          },
          !0
        ), z = F.prototype = new T();
        return z.constructor = F, z.getRatio = M, z.config = function(V, ht) {
          return new F(V, ht);
        }, F;
      }, K(
        "Elastic",
        G(
          "ElasticOut",
          function(g) {
            return this._p1 * Math.pow(2, -10 * g) * Math.sin((g - this._p3) * this._p2) + 1;
          },
          0.3
        ),
        G(
          "ElasticIn",
          function(g) {
            return -(this._p1 * Math.pow(2, 10 * (g -= 1)) * Math.sin((g - this._p3) * this._p2));
          },
          0.3
        ),
        G(
          "ElasticInOut",
          function(g) {
            return (g *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (g -= 1)) * Math.sin((g - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (g -= 1)) * Math.sin((g - this._p3) * this._p2) * 0.5 + 1;
          },
          0.45
        )
      ), K(
        "Expo",
        Y("ExpoOut", function(g) {
          return 1 - Math.pow(2, -10 * g);
        }),
        Y("ExpoIn", function(g) {
          return Math.pow(2, 10 * (g - 1)) - 1e-3;
        }),
        Y("ExpoInOut", function(g) {
          return (g *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (g - 1)) : 0.5 * (2 - Math.pow(2, -10 * (g - 1)));
        })
      ), K(
        "Sine",
        Y("SineOut", function(g) {
          return Math.sin(g * E);
        }),
        Y("SineIn", function(g) {
          return -Math.cos(g * E) + 1;
        }),
        Y("SineInOut", function(g) {
          return -0.5 * (Math.cos(Math.PI * g) - 1);
        })
      ), U(
        "easing.EaseLookup",
        {
          find: function(g) {
            return T.map[g];
          }
        },
        !0
      ), H(m.SlowMo, "SlowMo", "ease,"), H($, "RoughEase", "ease,"), H(J, "SteppedEase", "ease,"), b;
    },
    !0
  );
}), sn._gsDefine && sn._gsQueue.pop()(), function(T, J) {
  var p = {}, $ = T.document, G = T.GreenSockGlobals = T.GreenSockGlobals || T, m = G[J];
  if (m)
    return typeof module < "u" && module.exports && (module.exports = m), m;
  var C, O, E, U, Y, H = function(w) {
    var X, nt = w.split("."), tt = G;
    for (X = 0; X < nt.length; X++)
      tt[nt[X]] = tt = tt[nt[X]] || {};
    return tt;
  }, K = H("com.greensock"), B = 1e-10, q = function(w) {
    var X, nt = [], tt = w.length;
    for (X = 0; X !== tt; nt.push(w[X++]))
      ;
    return nt;
  }, b = function() {
  }, A = function() {
    var w = Object.prototype.toString, X = w.call([]);
    return function(nt) {
      return nt != null && (nt instanceof Array || typeof nt == "object" && !!nt.push && w.call(nt) === X);
    };
  }(), d = {}, g = function(w, X, nt, tt) {
    this.sc = d[w] ? d[w].sc : [], d[w] = this, this.gsClass = null, this.func = nt;
    var vt = [];
    this.check = function(Gt) {
      for (var Xt, Vt, Ne, Re, de = X.length, we = de; --de > -1; )
        (Xt = d[X[de]] || new g(X[de], [])).gsClass ? (vt[de] = Xt.gsClass, we--) : Gt && Xt.sc.push(this);
      if (we === 0 && nt) {
        if (Vt = ("com.greensock." + w).split("."), Ne = Vt.pop(), Re = H(Vt.join("."))[Ne] = this.gsClass = nt.apply(nt, vt), tt)
          if (G[Ne] = p[Ne] = Re, typeof module < "u" && module.exports)
            if (w === J) {
              module.exports = p[J] = Re;
              for (de in p)
                Re[de] = p[de];
            } else
              p[J] && (p[J][Ne] = Re);
          else
            typeof define == "function" && define.amd && define(
              (T.GreenSockAMDPath ? T.GreenSockAMDPath + "/" : "") + w.split(".").pop(),
              [],
              function() {
                return Re;
              }
            );
        for (de = 0; de < this.sc.length; de++)
          this.sc[de].check();
      }
    }, this.check(!0);
  }, M = T._gsDefine = function(w, X, nt, tt) {
    return new g(w, X, nt, tt);
  }, x = K._class = function(w, X, nt) {
    return X = X || function() {
    }, M(
      w,
      [],
      function() {
        return X;
      },
      nt
    ), X;
  };
  M.globals = G;
  var F = [0, 0, 1, 1], z = x(
    "easing.Ease",
    function(w, X, nt, tt) {
      this._func = w, this._type = nt || 0, this._power = tt || 0, this._params = X ? F.concat(X) : F;
    },
    !0
  ), V = z.map = {}, ht = z.register = function(w, X, nt, tt) {
    for (var vt, Gt, Xt, Vt, Ne = X.split(","), Re = Ne.length, de = (nt || "easeIn,easeOut,easeInOut").split(","); --Re > -1; )
      for (Gt = Ne[Re], vt = tt ? x("easing." + Gt, null, !0) : K.easing[Gt] || {}, Xt = de.length; --Xt > -1; )
        Vt = de[Xt], V[Gt + "." + Vt] = V[Vt + Gt] = vt[Vt] = w.getRatio ? w : w[Vt] || new w();
  };
  for (E = z.prototype, E._calcEnd = !1, E.getRatio = function(w) {
    if (this._func)
      return this._params[0] = w, this._func.apply(null, this._params);
    var X = this._type, nt = this._power, tt = X === 1 ? 1 - w : X === 2 ? w : 0.5 > w ? 2 * w : 2 * (1 - w);
    return nt === 1 ? tt *= tt : nt === 2 ? tt *= tt * tt : nt === 3 ? tt *= tt * tt * tt : nt === 4 && (tt *= tt * tt * tt * tt), X === 1 ? 1 - tt : X === 2 ? tt : 0.5 > w ? tt / 2 : 1 - tt / 2;
  }, C = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], O = C.length; --O > -1; )
    E = C[O] + ",Power" + O, ht(new z(null, null, 1, O), E, "easeOut", !0), ht(new z(null, null, 2, O), E, "easeIn" + (O === 0 ? ",easeNone" : "")), ht(new z(null, null, 3, O), E, "easeInOut");
  V.linear = K.easing.Linear.easeIn, V.swing = K.easing.Quad.easeInOut;
  var ft = x("events.EventDispatcher", function(w) {
    this._listeners = {}, this._eventTarget = w || this;
  });
  E = ft.prototype, E.addEventListener = function(w, X, nt, tt, vt) {
    vt = vt || 0;
    var Gt, Xt, Vt = this._listeners[w], Ne = 0;
    for (this !== U || Y || U.wake(), Vt == null && (this._listeners[w] = Vt = []), Xt = Vt.length; --Xt > -1; )
      Gt = Vt[Xt], Gt.c === X && Gt.s === nt ? Vt.splice(Xt, 1) : Ne === 0 && Gt.pr < vt && (Ne = Xt + 1);
    Vt.splice(Ne, 0, { c: X, s: nt, up: tt, pr: vt });
  }, E.removeEventListener = function(w, X) {
    var nt, tt = this._listeners[w];
    if (tt) {
      for (nt = tt.length; --nt > -1; )
        if (tt[nt].c === X)
          return void tt.splice(nt, 1);
    }
  }, E.dispatchEvent = function(w) {
    var X, nt, tt, vt = this._listeners[w];
    if (vt)
      for (X = vt.length, X > 1 && (vt = vt.slice(0)), nt = this._eventTarget; --X > -1; )
        tt = vt[X], tt && (tt.up ? tt.c.call(tt.s || nt, { type: w, target: nt }) : tt.c.call(tt.s || nt));
  };
  var gt = T.requestAnimationFrame, zt = T.cancelAnimationFrame, lt = Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  }, Et = lt();
  for (C = ["ms", "moz", "webkit", "o"], O = C.length; --O > -1 && !gt; )
    gt = T[C[O] + "RequestAnimationFrame"], zt = T[C[O] + "CancelAnimationFrame"] || T[C[O] + "CancelRequestAnimationFrame"];
  x("Ticker", function(w, X) {
    var nt, tt, vt, Gt, Xt, Vt = this, Ne = lt(), Re = X !== !1 && gt ? "auto" : !1, de = 500, we = 33, vi = "tick", Mi = function(ni) {
      var Si, wr, jn = lt() - Et;
      jn > de && (Ne += jn - we), Et += jn, Vt.time = (Et - Ne) / 1e3, Si = Vt.time - Xt, (!nt || Si > 0 || ni === !0) && (Vt.frame++, Xt += Si + (Si >= Gt ? 4e-3 : Gt - Si), wr = !0), ni !== !0 && (vt = tt(Mi)), wr && Vt.dispatchEvent(vi);
    };
    ft.call(Vt), Vt.time = Vt.frame = 0, Vt.tick = function() {
      Mi(!0);
    }, Vt.lagSmoothing = function(ni, Si) {
      return arguments.length ? (de = ni || 1 / B, void (we = Math.min(Si, de, 0))) : 1 / B > de;
    }, Vt.sleep = function() {
      vt != null && (Re && zt ? zt(vt) : clearTimeout(vt), tt = b, vt = null, Vt === U && (Y = !1));
    }, Vt.wake = function(ni) {
      vt !== null ? Vt.sleep() : ni ? Ne += -Et + (Et = lt()) : Vt.frame > 10 && (Et = lt() - de + 5), tt = nt === 0 ? b : Re && gt ? gt : function(Si) {
        return setTimeout(Si, 1e3 * (Xt - Vt.time) + 1 | 0);
      }, Vt === U && (Y = !0), Mi(2);
    }, Vt.fps = function(ni) {
      return arguments.length ? (nt = ni, Gt = 1 / (nt || 60), Xt = this.time + Gt, void Vt.wake()) : nt;
    }, Vt.useRAF = function(ni) {
      return arguments.length ? (Vt.sleep(), Re = ni, void Vt.fps(nt)) : Re;
    }, Vt.fps(w), setTimeout(function() {
      Re === "auto" && Vt.frame < 5 && ($ || {}).visibilityState !== "hidden" && Vt.useRAF(!1);
    }, 1500);
  }), E = K.Ticker.prototype = new K.events.EventDispatcher(), E.constructor = K.Ticker;
  var D = x("core.Animation", function(w, X) {
    if (this.vars = X = X || {}, this._duration = this._totalDuration = w || 0, this._delay = Number(X.delay) || 0, this._timeScale = 1, this._active = X.immediateRender === !0, this.data = X.data, this._reversed = X.reversed === !0, R) {
      Y || U.wake();
      var nt = this.vars.useFrames ? Zi : R;
      nt.add(this, nt._time), this.vars.paused && this.paused(!0);
    }
  });
  U = D.ticker = new K.Ticker(), E = D.prototype, E._dirty = E._gc = E._initted = E._paused = !1, E._totalTime = E._time = 0, E._rawPrevTime = -1, E._next = E._last = E._onUpdate = E._timeline = E.timeline = null, E._paused = !1;
  var Bt = function() {
    Y && lt() - Et > 2e3 && (($ || {}).visibilityState !== "hidden" || !U.lagSmoothing()) && U.wake();
    var w = setTimeout(Bt, 2e3);
    w.unref && w.unref();
  };
  Bt(), E.play = function(w, X) {
    return w != null && this.seek(w, X), this.reversed(!1).paused(!1);
  }, E.pause = function(w, X) {
    return w != null && this.seek(w, X), this.paused(!0);
  }, E.resume = function(w, X) {
    return w != null && this.seek(w, X), this.paused(!1);
  }, E.seek = function(w, X) {
    return this.totalTime(Number(w), X !== !1);
  }, E.restart = function(w, X) {
    return this.reversed(!1).paused(!1).totalTime(w ? -this._delay : 0, X !== !1, !0);
  }, E.reverse = function(w, X) {
    return w != null && this.seek(w || this.totalDuration(), X), this.reversed(!0).paused(!1);
  }, E.render = function(w, X, nt) {
  }, E.invalidate = function() {
    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this;
  }, E.isActive = function() {
    var w, X = this._timeline, nt = this._startTime;
    return !X || !this._gc && !this._paused && X.isActive() && (w = X.rawTime(!0)) >= nt && w < nt + this.totalDuration() / this._timeScale - 1e-7;
  }, E._enabled = function(w, X) {
    return Y || U.wake(), this._gc = !w, this._active = this.isActive(), X !== !0 && (w && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !w && this.timeline && this._timeline._remove(this, !0)), !1;
  }, E._kill = function(w, X) {
    return this._enabled(!1, !1);
  }, E.kill = function(w, X) {
    return this._kill(w, X), this;
  }, E._uncache = function(w) {
    for (var X = w ? this : this.timeline; X; )
      X._dirty = !0, X = X.timeline;
    return this;
  }, E._swapSelfInParams = function(w) {
    for (var X = w.length, nt = w.concat(); --X > -1; )
      w[X] === "{self}" && (nt[X] = this);
    return nt;
  }, E._callback = function(w) {
    var X = this.vars, nt = X[w], tt = X[w + "Params"], vt = X[w + "Scope"] || X.callbackScope || this, Gt = tt ? tt.length : 0;
    switch (Gt) {
      case 0:
        nt.call(vt);
        break;
      case 1:
        nt.call(vt, tt[0]);
        break;
      case 2:
        nt.call(vt, tt[0], tt[1]);
        break;
      default:
        nt.apply(vt, tt);
    }
  }, E.eventCallback = function(w, X, nt, tt) {
    if ((w || "").substr(0, 2) === "on") {
      var vt = this.vars;
      if (arguments.length === 1)
        return vt[w];
      X == null ? delete vt[w] : (vt[w] = X, vt[w + "Params"] = A(nt) && nt.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(nt) : nt, vt[w + "Scope"] = tt), w === "onUpdate" && (this._onUpdate = X);
    }
    return this;
  }, E.delay = function(w) {
    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + w - this._delay), this._delay = w, this) : this._delay;
  }, E.duration = function(w) {
    return arguments.length ? (this._duration = this._totalDuration = w, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && w !== 0 && this.totalTime(this._totalTime * (w / this._duration), !0), this) : (this._dirty = !1, this._duration);
  }, E.totalDuration = function(w) {
    return this._dirty = !1, arguments.length ? this.duration(w) : this._totalDuration;
  }, E.time = function(w, X) {
    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(w > this._duration ? this._duration : w, X)) : this._time;
  }, E.totalTime = function(w, X, nt) {
    if (Y || U.wake(), !arguments.length)
      return this._totalTime;
    if (this._timeline) {
      if (0 > w && !nt && (w += this.totalDuration()), this._timeline.smoothChildTiming) {
        this._dirty && this.totalDuration();
        var tt = this._totalDuration, vt = this._timeline;
        if (w > tt && !nt && (w = tt), this._startTime = (this._paused ? this._pauseTime : vt._time) - (this._reversed ? tt - w : w) / this._timeScale, vt._dirty || this._uncache(!1), vt._timeline)
          for (; vt._timeline; )
            vt._timeline._time !== (vt._startTime + vt._totalTime) / vt._timeScale && vt.totalTime(vt._totalTime, !0), vt = vt._timeline;
      }
      this._gc && this._enabled(!0, !1), (this._totalTime !== w || this._duration === 0) && (Ft.length && jt(), this.render(w, X, !1), Ft.length && jt());
    }
    return this;
  }, E.progress = E.totalProgress = function(w, X) {
    var nt = this.duration();
    return arguments.length ? this.totalTime(nt * w, X) : nt ? this._time / nt : this.ratio;
  }, E.startTime = function(w) {
    return arguments.length ? (w !== this._startTime && (this._startTime = w, this.timeline && this.timeline._sortChildren && this.timeline.add(this, w - this._delay)), this) : this._startTime;
  }, E.endTime = function(w) {
    return this._startTime + (w != 0 ? this.totalDuration() : this.duration()) / this._timeScale;
  }, E.timeScale = function(w) {
    if (!arguments.length)
      return this._timeScale;
    var X, nt;
    for (w = w || B, this._timeline && this._timeline.smoothChildTiming && (X = this._pauseTime, nt = X || X === 0 ? X : this._timeline.totalTime(), this._startTime = nt - (nt - this._startTime) * this._timeScale / w), this._timeScale = w, nt = this.timeline; nt && nt.timeline; )
      nt._dirty = !0, nt.totalDuration(), nt = nt.timeline;
    return this;
  }, E.reversed = function(w) {
    return arguments.length ? (w != this._reversed && (this._reversed = w, this.totalTime(
      this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime,
      !0
    )), this) : this._reversed;
  }, E.paused = function(w) {
    if (!arguments.length)
      return this._paused;
    var X, nt, tt = this._timeline;
    return w != this._paused && tt && (Y || w || U.wake(), X = tt.rawTime(), nt = X - this._pauseTime, !w && tt.smoothChildTiming && (this._startTime += nt, this._uncache(!1)), this._pauseTime = w ? X : null, this._paused = w, this._active = this.isActive(), !w && nt !== 0 && this._initted && this.duration() && (X = tt.smoothChildTiming ? this._totalTime : (X - this._startTime) / this._timeScale, this.render(X, X === this._totalTime, !0))), this._gc && !w && this._enabled(!0, !1), this;
  };
  var Ct = x("core.SimpleTimeline", function(w) {
    D.call(this, 0, w), this.autoRemoveChildren = this.smoothChildTiming = !0;
  });
  E = Ct.prototype = new D(), E.constructor = Ct, E.kill()._gc = !1, E._first = E._last = E._recent = null, E._sortChildren = !1, E.add = E.insert = function(w, X, nt, tt) {
    var vt, Gt;
    if (w._startTime = Number(X || 0) + w._delay, w._paused && this !== w._timeline && (w._pauseTime = this.rawTime() - (w._timeline.rawTime() - w._pauseTime)), w.timeline && w.timeline._remove(w, !0), w.timeline = w._timeline = this, w._gc && w._enabled(!0, !0), vt = this._last, this._sortChildren)
      for (Gt = w._startTime; vt && vt._startTime > Gt; )
        vt = vt._prev;
    return vt ? (w._next = vt._next, vt._next = w) : (w._next = this._first, this._first = w), w._next ? w._next._prev = w : this._last = w, w._prev = vt, this._recent = w, this._timeline && this._uncache(!0), this;
  }, E._remove = function(w, X) {
    return w.timeline === this && (X || w._enabled(!1, !0), w._prev ? w._prev._next = w._next : this._first === w && (this._first = w._next), w._next ? w._next._prev = w._prev : this._last === w && (this._last = w._prev), w._next = w._prev = w.timeline = null, w === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this;
  }, E.render = function(w, X, nt) {
    var tt, vt = this._first;
    for (this._totalTime = this._time = this._rawPrevTime = w; vt; )
      tt = vt._next, (vt._active || w >= vt._startTime && !vt._paused && !vt._gc) && (vt._reversed ? vt.render(
        (vt._dirty ? vt.totalDuration() : vt._totalDuration) - (w - vt._startTime) * vt._timeScale,
        X,
        nt
      ) : vt.render((w - vt._startTime) * vt._timeScale, X, nt)), vt = tt;
  }, E.rawTime = function() {
    return Y || U.wake(), this._totalTime;
  };
  var Rt = x(
    "TweenLite",
    function(w, X, nt) {
      if (D.call(this, X, nt), this.render = Rt.prototype.render, w == null)
        throw "Cannot tween a null target.";
      this.target = w = typeof w != "string" ? w : Rt.selector(w) || w;
      var tt, vt, Gt, Xt = w.jquery || w.length && w !== T && w[0] && (w[0] === T || w[0].nodeType && w[0].style && !w.nodeType), Vt = this.vars.overwrite;
      if (this._overwrite = Vt = Vt == null ? an[Rt.defaultOverwrite] : typeof Vt == "number" ? Vt >> 0 : an[Vt], (Xt || w instanceof Array || w.push && A(w)) && typeof w[0] != "number")
        for (this._targets = Gt = q(w), this._propLookup = [], this._siblings = [], tt = 0; tt < Gt.length; tt++)
          vt = Gt[tt], vt ? typeof vt != "string" ? vt.length && vt !== T && vt[0] && (vt[0] === T || vt[0].nodeType && vt[0].style && !vt.nodeType) ? (Gt.splice(tt--, 1), this._targets = Gt = Gt.concat(q(vt))) : (this._siblings[tt] = ct(vt, this, !1), Vt === 1 && this._siblings[tt].length > 1 && Lt(vt, this, null, 1, this._siblings[tt])) : (vt = Gt[tt--] = Rt.selector(vt), typeof vt == "string" && Gt.splice(tt + 1, 1)) : Gt.splice(tt--, 1);
      else
        this._propLookup = {}, this._siblings = ct(w, this, !1), Vt === 1 && this._siblings.length > 1 && Lt(w, this, null, 1, this._siblings);
      (this.vars.immediateRender || X === 0 && this._delay === 0 && this.vars.immediateRender !== !1) && (this._time = -B, this.render(Math.min(0, -this._delay)));
    },
    !0
  ), ge = function(w) {
    return w && w.length && w !== T && w[0] && (w[0] === T || w[0].nodeType && w[0].style && !w.nodeType);
  }, ue = function(w, X) {
    var nt, tt = {};
    for (nt in w)
      Li[nt] || nt in X && nt !== "transform" && nt !== "x" && nt !== "y" && nt !== "width" && nt !== "height" && nt !== "className" && nt !== "border" || !(!Ie[nt] || Ie[nt] && Ie[nt]._autoCSS) || (tt[nt] = w[nt], delete w[nt]);
    w.css = tt;
  };
  E = Rt.prototype = new D(), E.constructor = Rt, E.kill()._gc = !1, E.ratio = 0, E._firstPT = E._targets = E._overwrittenProps = E._startAt = null, E._notifyPluginsOfEnabled = E._lazy = !1, Rt.version = "2.0.2", Rt.defaultEase = E._ease = new z(null, null, 1, 1), Rt.defaultOverwrite = "auto", Rt.ticker = U, Rt.autoSleep = 120, Rt.lagSmoothing = function(w, X) {
    U.lagSmoothing(w, X);
  }, Rt.selector = T.$ || T.jQuery || function(w) {
    var X = T.$ || T.jQuery;
    return X ? (Rt.selector = X, X(w)) : ($ || ($ = T.document), $ ? $.querySelectorAll ? $.querySelectorAll(w) : $.getElementById(w.charAt(0) === "#" ? w.substr(1) : w) : w);
  };
  var Ft = [], Dt = {}, kt = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, Fe = /[\+-]=-?[\.\d]/, xe = function(w) {
    for (var X, nt = this._firstPT, tt = 1e-6; nt; )
      X = nt.blob ? w === 1 && this.end != null ? this.end : w ? this.join("") : this.start : nt.c * w + nt.s, nt.m ? X = nt.m.call(this._tween, X, this._target || nt.t, this._tween) : tt > X && X > -tt && !nt.blob && (X = 0), nt.f ? nt.fp ? nt.t[nt.p](nt.fp, X) : nt.t[nt.p](X) : nt.t[nt.p] = X, nt = nt._next;
  }, Zt = function(w, X, nt, tt) {
    var vt, Gt, Xt, Vt, Ne, Re, de, we = [], vi = 0, Mi = "", ni = 0;
    for (we.start = w, we.end = X, w = we[0] = w + "", X = we[1] = X + "", nt && (nt(we), w = we[0], X = we[1]), we.length = 0, vt = w.match(kt) || [], Gt = X.match(kt) || [], tt && (tt._next = null, tt.blob = 1, we._firstPT = we._applyPT = tt), Ne = Gt.length, Vt = 0; Ne > Vt; Vt++)
      de = Gt[Vt], Re = X.substr(vi, X.indexOf(de, vi) - vi), Mi += Re || !Vt ? Re : ",", vi += Re.length, ni ? ni = (ni + 1) % 5 : Re.substr(-5) === "rgba(" && (ni = 1), de === vt[Vt] || vt.length <= Vt ? Mi += de : (Mi && (we.push(Mi), Mi = ""), Xt = parseFloat(vt[Vt]), we.push(Xt), we._firstPT = {
        _next: we._firstPT,
        t: we,
        p: we.length - 1,
        s: Xt,
        c: (de.charAt(1) === "=" ? parseInt(de.charAt(0) + "1", 10) * parseFloat(de.substr(2)) : parseFloat(de) - Xt) || 0,
        f: 0,
        m: ni && 4 > ni ? Math.round : 0
      }), vi += de.length;
    return Mi += X.substr(vi), Mi && we.push(Mi), we.setRatio = xe, Fe.test(X) && (we.end = null), we;
  }, ti = function(w, X, nt, tt, vt, Gt, Xt, Vt, Ne) {
    typeof tt == "function" && (tt = tt(Ne || 0, w));
    var Re, de = typeof w[X], we = de !== "function" ? "" : X.indexOf("set") || typeof w["get" + X.substr(3)] != "function" ? X : "get" + X.substr(3), vi = nt !== "get" ? nt : we ? Xt ? w[we](Xt) : w[we]() : w[X], Mi = typeof tt == "string" && tt.charAt(1) === "=", ni = {
      t: w,
      p: X,
      s: vi,
      f: de === "function",
      pg: 0,
      n: vt || X,
      m: Gt ? typeof Gt == "function" ? Gt : Math.round : 0,
      pr: 0,
      c: Mi ? parseInt(tt.charAt(0) + "1", 10) * parseFloat(tt.substr(2)) : parseFloat(tt) - vi || 0
    };
    return (typeof vi != "number" || typeof tt != "number" && !Mi) && (Xt || isNaN(vi) || !Mi && isNaN(tt) || typeof vi == "boolean" || typeof tt == "boolean" ? (ni.fp = Xt, Re = Zt(
      vi,
      Mi ? parseFloat(ni.s) + ni.c + (ni.s + "").replace(/[0-9\-\.]/g, "") : tt,
      Vt || Rt.defaultStringFilter,
      ni
    ), ni = {
      t: Re,
      p: "setRatio",
      s: 0,
      c: 1,
      f: 2,
      pg: 0,
      n: vt || X,
      pr: 0,
      m: 0
    }) : (ni.s = parseFloat(vi), Mi || (ni.c = parseFloat(tt) - ni.s || 0))), ni.c ? ((ni._next = this._firstPT) && (ni._next._prev = ni), this._firstPT = ni, ni) : void 0;
  }, Ni = Rt._internals = {
    isArray: A,
    isSelector: ge,
    lazyTweens: Ft,
    blobDif: Zt
  }, Ie = Rt._plugins = {}, Ge = Ni.tweenLookup = {}, pi = 0, Li = Ni.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1
  }, an = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    true: 1,
    false: 0
  }, Zi = D._rootFramesTimeline = new Ct(), R = D._rootTimeline = new Ct(), Jt = 30, jt = Ni.lazyRender = function() {
    var w, X = Ft.length;
    for (Dt = {}; --X > -1; )
      w = Ft[X], w && w._lazy !== !1 && (w.render(w._lazy[0], w._lazy[1], !0), w._lazy = !1);
    Ft.length = 0;
  };
  R._startTime = U.time, Zi._startTime = U.frame, R._active = Zi._active = !0, setTimeout(jt, 1), D._updateRoot = Rt.render = function() {
    var w, X, nt;
    if (Ft.length && jt(), R.render((U.time - R._startTime) * R._timeScale, !1, !1), Zi.render((U.frame - Zi._startTime) * Zi._timeScale, !1, !1), Ft.length && jt(), U.frame >= Jt) {
      Jt = U.frame + (parseInt(Rt.autoSleep, 10) || 120);
      for (nt in Ge) {
        for (X = Ge[nt].tweens, w = X.length; --w > -1; )
          X[w]._gc && X.splice(w, 1);
        X.length === 0 && delete Ge[nt];
      }
      if (nt = R._first, (!nt || nt._paused) && Rt.autoSleep && !Zi._first && U._listeners.tick.length === 1) {
        for (; nt && nt._paused; )
          nt = nt._next;
        nt || U.sleep();
      }
    }
  }, U.addEventListener("tick", D._updateRoot);
  var ct = function(w, X, nt) {
    var tt, vt, Gt = w._gsTweenID;
    if (Ge[Gt || (w._gsTweenID = Gt = "t" + pi++)] || (Ge[Gt] = { target: w, tweens: [] }), X && (tt = Ge[Gt].tweens, tt[vt = tt.length] = X, nt))
      for (; --vt > -1; )
        tt[vt] === X && tt.splice(vt, 1);
    return Ge[Gt].tweens;
  }, pt = function(w, X, nt, tt) {
    var vt, Gt, Xt = w.vars.onOverwrite;
    return Xt && (vt = Xt(w, X, nt, tt)), Xt = Rt.onOverwrite, Xt && (Gt = Xt(w, X, nt, tt)), vt !== !1 && Gt !== !1;
  }, Lt = function(w, X, nt, tt, vt) {
    var Gt, Xt, Vt, Ne;
    if (tt === 1 || tt >= 4) {
      for (Ne = vt.length, Gt = 0; Ne > Gt; Gt++)
        if ((Vt = vt[Gt]) !== X)
          Vt._gc || Vt._kill(null, w, X) && (Xt = !0);
        else if (tt === 5)
          break;
      return Xt;
    }
    var Re, de = X._startTime + B, we = [], vi = 0, Mi = X._duration === 0;
    for (Gt = vt.length; --Gt > -1; )
      (Vt = vt[Gt]) === X || Vt._gc || Vt._paused || (Vt._timeline !== X._timeline ? (Re = Re || ie(X, 0, Mi), ie(Vt, Re, Mi) === 0 && (we[vi++] = Vt)) : Vt._startTime <= de && Vt._startTime + Vt.totalDuration() / Vt._timeScale > de && ((Mi || !Vt._initted) && de - Vt._startTime <= 2e-10 || (we[vi++] = Vt)));
    for (Gt = vi; --Gt > -1; )
      if (Vt = we[Gt], Ne = Vt._firstPT, tt === 2 && Vt._kill(nt, w, X) && (Xt = !0), tt !== 2 || !Vt._firstPT && Vt._initted && Ne) {
        if (tt !== 2 && !pt(Vt, X))
          continue;
        Vt._enabled(!1, !1) && (Xt = !0);
      }
    return Xt;
  }, ie = function(w, X, nt) {
    for (var tt = w._timeline, vt = tt._timeScale, Gt = w._startTime; tt._timeline; ) {
      if (Gt += tt._startTime, vt *= tt._timeScale, tt._paused)
        return -100;
      tt = tt._timeline;
    }
    return Gt /= vt, Gt > X ? Gt - X : nt && Gt === X || !w._initted && 2 * B > Gt - X ? B : (Gt += w.totalDuration() / w._timeScale / vt) > X + B ? 0 : Gt - X - B;
  };
  E._init = function() {
    var w, X, nt, tt, vt, Gt, Xt = this.vars, Vt = this._overwrittenProps, Ne = this._duration, Re = !!Xt.immediateRender, de = Xt.ease;
    if (Xt.startAt) {
      this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), vt = {};
      for (tt in Xt.startAt)
        vt[tt] = Xt.startAt[tt];
      if (vt.data = "isStart", vt.overwrite = !1, vt.immediateRender = !0, vt.lazy = Re && Xt.lazy !== !1, vt.startAt = vt.delay = null, vt.onUpdate = Xt.onUpdate, vt.onUpdateParams = Xt.onUpdateParams, vt.onUpdateScope = Xt.onUpdateScope || Xt.callbackScope || this, this._startAt = Rt.to(this.target || {}, 0, vt), Re) {
        if (this._time > 0)
          this._startAt = null;
        else if (Ne !== 0)
          return;
      }
    } else if (Xt.runBackwards && Ne !== 0)
      if (this._startAt)
        this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
      else {
        this._time !== 0 && (Re = !1), nt = {};
        for (tt in Xt)
          Li[tt] && tt !== "autoCSS" || (nt[tt] = Xt[tt]);
        if (nt.overwrite = 0, nt.data = "isFromStart", nt.lazy = Re && Xt.lazy !== !1, nt.immediateRender = Re, this._startAt = Rt.to(this.target, 0, nt), Re) {
          if (this._time === 0)
            return;
        } else
          this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null);
      }
    if (this._ease = de = de ? de instanceof z ? de : typeof de == "function" ? new z(de, Xt.easeParams) : V[de] || Rt.defaultEase : Rt.defaultEase, Xt.easeParams instanceof Array && de.config && (this._ease = de.config.apply(de, Xt.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
      for (Gt = this._targets.length, w = 0; Gt > w; w++)
        this._initProps(
          this._targets[w],
          this._propLookup[w] = {},
          this._siblings[w],
          Vt ? Vt[w] : null,
          w
        ) && (X = !0);
    else
      X = this._initProps(
        this.target,
        this._propLookup,
        this._siblings,
        Vt,
        0
      );
    if (X && Rt._onPluginEvent("_onInitAllProps", this), Vt && (this._firstPT || typeof this.target != "function" && this._enabled(!1, !1)), Xt.runBackwards)
      for (nt = this._firstPT; nt; )
        nt.s += nt.c, nt.c = -nt.c, nt = nt._next;
    this._onUpdate = Xt.onUpdate, this._initted = !0;
  }, E._initProps = function(w, X, nt, tt, vt) {
    var Gt, Xt, Vt, Ne, Re, de;
    if (w == null)
      return !1;
    Dt[w._gsTweenID] && jt(), this.vars.css || w.style && w !== T && w.nodeType && Ie.css && this.vars.autoCSS !== !1 && ue(this.vars, w);
    for (Gt in this.vars)
      if (de = this.vars[Gt], Li[Gt])
        de && (de instanceof Array || de.push && A(de)) && de.join("").indexOf("{self}") !== -1 && (this.vars[Gt] = de = this._swapSelfInParams(de, this));
      else if (Ie[Gt] && (Ne = new Ie[Gt]())._onInitTween(w, this.vars[Gt], this, vt)) {
        for (this._firstPT = Re = {
          _next: this._firstPT,
          t: Ne,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: Gt,
          pg: 1,
          pr: Ne._priority,
          m: 0
        }, Xt = Ne._overwriteProps.length; --Xt > -1; )
          X[Ne._overwriteProps[Xt]] = this._firstPT;
        (Ne._priority || Ne._onInitAllProps) && (Vt = !0), (Ne._onDisable || Ne._onEnable) && (this._notifyPluginsOfEnabled = !0), Re._next && (Re._next._prev = Re);
      } else
        X[Gt] = ti.call(
          this,
          w,
          Gt,
          "get",
          de,
          Gt,
          0,
          null,
          this.vars.stringFilter,
          vt
        );
    return tt && this._kill(tt, w) ? this._initProps(w, X, nt, tt, vt) : this._overwrite > 1 && this._firstPT && nt.length > 1 && Lt(w, this, X, this._overwrite, nt) ? (this._kill(X, w), this._initProps(w, X, nt, tt, vt)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (Dt[w._gsTweenID] = !0), Vt);
  }, E.render = function(w, X, nt) {
    var tt, vt, Gt, Xt, Vt = this._time, Ne = this._duration, Re = this._rawPrevTime;
    if (w >= Ne - 1e-7 && w >= 0)
      this._totalTime = this._time = Ne, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (tt = !0, vt = "onComplete", nt = nt || this._timeline.autoRemoveChildren), Ne === 0 && (this._initted || !this.vars.lazy || nt) && (this._startTime === this._timeline._duration && (w = 0), (0 > Re || 0 >= w && w >= -1e-7 || Re === B && this.data !== "isPause") && Re !== w && (nt = !0, Re > B && (vt = "onReverseComplete")), this._rawPrevTime = Xt = !X || w || Re === w ? w : B);
    else if (1e-7 > w)
      this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (Vt !== 0 || Ne === 0 && Re > 0) && (vt = "onReverseComplete", tt = this._reversed), 0 > w && (this._active = !1, Ne === 0 && (this._initted || !this.vars.lazy || nt) && (Re >= 0 && (Re !== B || this.data !== "isPause") && (nt = !0), this._rawPrevTime = Xt = !X || w || Re === w ? w : B)), (!this._initted || this._startAt && this._startAt.progress()) && (nt = !0);
    else if (this._totalTime = this._time = w, this._easeType) {
      var de = w / Ne, we = this._easeType, vi = this._easePower;
      (we === 1 || we === 3 && de >= 0.5) && (de = 1 - de), we === 3 && (de *= 2), vi === 1 ? de *= de : vi === 2 ? de *= de * de : vi === 3 ? de *= de * de * de : vi === 4 && (de *= de * de * de * de), we === 1 ? this.ratio = 1 - de : we === 2 ? this.ratio = de : 0.5 > w / Ne ? this.ratio = de / 2 : this.ratio = 1 - de / 2;
    } else
      this.ratio = this._ease.getRatio(w / Ne);
    if (this._time !== Vt || nt) {
      if (!this._initted) {
        if (this._init(), !this._initted || this._gc)
          return;
        if (!nt && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
          return this._time = this._totalTime = Vt, this._rawPrevTime = Re, Ft.push(this), void (this._lazy = [w, X]);
        this._time && !tt ? this.ratio = this._ease.getRatio(this._time / Ne) : tt && this._ease._calcEnd && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1));
      }
      for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== Vt && w >= 0 && (this._active = !0), Vt === 0 && (this._startAt && (w >= 0 ? this._startAt.render(w, !0, nt) : vt || (vt = "_dummyGS")), this.vars.onStart && (this._time !== 0 || Ne === 0) && (X || this._callback("onStart"))), Gt = this._firstPT; Gt; )
        Gt.f ? Gt.t[Gt.p](Gt.c * this.ratio + Gt.s) : Gt.t[Gt.p] = Gt.c * this.ratio + Gt.s, Gt = Gt._next;
      this._onUpdate && (0 > w && this._startAt && w !== -1e-4 && this._startAt.render(w, !0, nt), X || (this._time !== Vt || tt || nt) && this._callback("onUpdate")), vt && (!this._gc || nt) && (0 > w && this._startAt && !this._onUpdate && w !== -1e-4 && this._startAt.render(w, !0, nt), tt && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !X && this.vars[vt] && this._callback(vt), Ne === 0 && this._rawPrevTime === B && Xt !== B && (this._rawPrevTime = 0));
    }
  }, E._kill = function(w, X, nt) {
    if (w === "all" && (w = null), w == null && (X == null || X === this.target))
      return this._lazy = !1, this._enabled(!1, !1);
    X = typeof X != "string" ? X || this._targets || this.target : Rt.selector(X) || X;
    var tt, vt, Gt, Xt, Vt, Ne, Re, de, we, vi = nt && this._time && nt._startTime === this._startTime && this._timeline === nt._timeline, Mi = this._firstPT;
    if ((A(X) || ge(X)) && typeof X[0] != "number")
      for (tt = X.length; --tt > -1; )
        this._kill(w, X[tt], nt) && (Ne = !0);
    else {
      if (this._targets) {
        for (tt = this._targets.length; --tt > -1; )
          if (X === this._targets[tt]) {
            Vt = this._propLookup[tt] || {}, this._overwrittenProps = this._overwrittenProps || [], vt = this._overwrittenProps[tt] = w ? this._overwrittenProps[tt] || {} : "all";
            break;
          }
      } else {
        if (X !== this.target)
          return !1;
        Vt = this._propLookup, vt = this._overwrittenProps = w ? this._overwrittenProps || {} : "all";
      }
      if (Vt) {
        if (Re = w || Vt, de = w !== vt && vt !== "all" && w !== Vt && (typeof w != "object" || !w._tempKill), nt && (Rt.onOverwrite || this.vars.onOverwrite)) {
          for (Gt in Re)
            Vt[Gt] && (we || (we = []), we.push(Gt));
          if ((we || !w) && !pt(this, nt, X, we))
            return !1;
        }
        for (Gt in Re)
          (Xt = Vt[Gt]) && (vi && (Xt.f ? Xt.t[Xt.p](Xt.s) : Xt.t[Xt.p] = Xt.s, Ne = !0), Xt.pg && Xt.t._kill(Re) && (Ne = !0), Xt.pg && Xt.t._overwriteProps.length !== 0 || (Xt._prev ? Xt._prev._next = Xt._next : Xt === this._firstPT && (this._firstPT = Xt._next), Xt._next && (Xt._next._prev = Xt._prev), Xt._next = Xt._prev = null), delete Vt[Gt]), de && (vt[Gt] = 1);
        !this._firstPT && this._initted && Mi && this._enabled(!1, !1);
      }
    }
    return Ne;
  }, E.invalidate = function() {
    return this._notifyPluginsOfEnabled && Rt._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], D.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -B, this.render(Math.min(0, -this._delay))), this;
  }, E._enabled = function(w, X) {
    if (Y || U.wake(), w && this._gc) {
      var nt, tt = this._targets;
      if (tt)
        for (nt = tt.length; --nt > -1; )
          this._siblings[nt] = ct(tt[nt], this, !0);
      else
        this._siblings = ct(this.target, this, !0);
    }
    return D.prototype._enabled.call(this, w, X), this._notifyPluginsOfEnabled && this._firstPT ? Rt._onPluginEvent(w ? "_onEnable" : "_onDisable", this) : !1;
  }, Rt.to = function(w, X, nt) {
    return new Rt(w, X, nt);
  }, Rt.from = function(w, X, nt) {
    return nt.runBackwards = !0, nt.immediateRender = nt.immediateRender != 0, new Rt(w, X, nt);
  }, Rt.fromTo = function(w, X, nt, tt) {
    return tt.startAt = nt, tt.immediateRender = tt.immediateRender != 0 && nt.immediateRender != 0, new Rt(w, X, tt);
  }, Rt.delayedCall = function(w, X, nt, tt, vt) {
    return new Rt(X, 0, {
      delay: w,
      onComplete: X,
      onCompleteParams: nt,
      callbackScope: tt,
      onReverseComplete: X,
      onReverseCompleteParams: nt,
      immediateRender: !1,
      lazy: !1,
      useFrames: vt,
      overwrite: 0
    });
  }, Rt.set = function(w, X) {
    return new Rt(w, 0, X);
  }, Rt.getTweensOf = function(w, X) {
    if (w == null)
      return [];
    w = typeof w != "string" ? w : Rt.selector(w) || w;
    var nt, tt, vt, Gt;
    if ((A(w) || ge(w)) && typeof w[0] != "number") {
      for (nt = w.length, tt = []; --nt > -1; )
        tt = tt.concat(Rt.getTweensOf(w[nt], X));
      for (nt = tt.length; --nt > -1; )
        for (Gt = tt[nt], vt = nt; --vt > -1; )
          Gt === tt[vt] && tt.splice(nt, 1);
    } else if (w._gsTweenID)
      for (tt = ct(w).concat(), nt = tt.length; --nt > -1; )
        (tt[nt]._gc || X && !tt[nt].isActive()) && tt.splice(nt, 1);
    return tt || [];
  }, Rt.killTweensOf = Rt.killDelayedCallsTo = function(w, X, nt) {
    typeof X == "object" && (nt = X, X = !1);
    for (var tt = Rt.getTweensOf(w, X), vt = tt.length; --vt > -1; )
      tt[vt]._kill(nt, w);
  };
  var Kt = x(
    "plugins.TweenPlugin",
    function(w, X) {
      this._overwriteProps = (w || "").split(","), this._propName = this._overwriteProps[0], this._priority = X || 0, this._super = Kt.prototype;
    },
    !0
  );
  if (E = Kt.prototype, Kt.version = "1.19.0", Kt.API = 2, E._firstPT = null, E._addTween = ti, E.setRatio = xe, E._kill = function(w) {
    var X, nt = this._overwriteProps, tt = this._firstPT;
    if (w[this._propName] != null)
      this._overwriteProps = [];
    else
      for (X = nt.length; --X > -1; )
        w[nt[X]] != null && nt.splice(X, 1);
    for (; tt; )
      w[tt.n] != null && (tt._next && (tt._next._prev = tt._prev), tt._prev ? (tt._prev._next = tt._next, tt._prev = null) : this._firstPT === tt && (this._firstPT = tt._next)), tt = tt._next;
    return !1;
  }, E._mod = E._roundProps = function(w) {
    for (var X, nt = this._firstPT; nt; )
      X = w[this._propName] || nt.n != null && w[nt.n.split(this._propName + "_").join("")], X && typeof X == "function" && (nt.f === 2 ? nt.t._applyPT.m = X : nt.m = X), nt = nt._next;
  }, Rt._onPluginEvent = function(w, X) {
    var nt, tt, vt, Gt, Xt, Vt = X._firstPT;
    if (w === "_onInitAllProps") {
      for (; Vt; ) {
        for (Xt = Vt._next, tt = vt; tt && tt.pr > Vt.pr; )
          tt = tt._next;
        (Vt._prev = tt ? tt._prev : Gt) ? Vt._prev._next = Vt : vt = Vt, (Vt._next = tt) ? tt._prev = Vt : Gt = Vt, Vt = Xt;
      }
      Vt = X._firstPT = vt;
    }
    for (; Vt; )
      Vt.pg && typeof Vt.t[w] == "function" && Vt.t[w]() && (nt = !0), Vt = Vt._next;
    return nt;
  }, Kt.activate = function(w) {
    for (var X = w.length; --X > -1; )
      w[X].API === Kt.API && (Ie[new w[X]()._propName] = w[X]);
    return !0;
  }, M.plugin = function(w) {
    if (!(w && w.propName && w.init && w.API))
      throw "illegal plugin definition.";
    var X, nt = w.propName, tt = w.priority || 0, vt = w.overwriteProps, Gt = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    }, Xt = x(
      "plugins." + nt.charAt(0).toUpperCase() + nt.substr(1) + "Plugin",
      function() {
        Kt.call(this, nt, tt), this._overwriteProps = vt || [];
      },
      w.global === !0
    ), Vt = Xt.prototype = new Kt(nt);
    Vt.constructor = Xt, Xt.API = w.API;
    for (X in Gt)
      typeof w[X] == "function" && (Vt[Gt[X]] = w[X]);
    return Xt.version = w.version, Kt.activate([Xt]), Xt;
  }, C = T._gsQueue) {
    for (O = 0; O < C.length; O++)
      C[O]();
    for (E in d)
      d[E].func || T.console.log("GSAP encountered missing dependency: " + E);
  }
  Y = !1;
}(
  typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window,
  "TweenMax"
);
const Gm = { class: "modal-background" }, Hm = ["innerHTML"], Wm = {
  name: "MapModali"
}, jm = /* @__PURE__ */ Gh({
  ...Wm,
  props: {
    // text: {
    //   type: String,
    //   default: "CHBIM云平台",
    // },
  },
  setup(T, { expose: J }) {
    const p = Uh(""), $ = Uh(""), G = (C) => {
      $.value = C, p.value = "five";
    }, m = () => {
      p.value = p.value + " out";
    };
    return Hh(() => {
    }), J({
      text: $,
      show: G,
      hide: m
    }), (C, O) => (sh(), ah("div", {
      id: "modal-container",
      class: Fu(p.value),
      onClick: m
    }, [
      lr("div", Gm, [
        lr("div", {
          class: "modal",
          onClick: O[0] || (O[0] = (E) => {
            E.stopPropagation();
          })
        }, [
          lr("p", {
            style: { "white-space": "pre-line", "line-height": "1", margin: "0", color: "#fff" },
            innerHTML: $.value
          }, null, 8, Hm)
        ])
      ])
    ], 2));
  }
});
const Vm = { class: "bim_background_plate" }, Xm = { class: "content" }, qm = /* @__PURE__ */ lr("canvas", { class: "landscape" }, null, -1), Ym = { class: "content__title" }, Zm = /* @__PURE__ */ lr("div", { class: "overlay" }, null, -1), Jm = {
  name: "BimBackgroundPlate"
}, $m = /* @__PURE__ */ Gh({
  ...Jm,
  setup(T) {
    const J = () => {
      let G = `
          vec3 mod289(vec3 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 mod289(vec4 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 permute(vec4 x)
          {
          	return mod289(((x*34.0)+1.0)*x);
          }

          vec4 taylorInvSqrt(vec4 r)
          {
          	return 1.79284291400159 - 0.85373472095314 * r;
          }

          vec3 fade(vec3 t) {
          	return t*t*t*(t*(t*6.0-15.0)+10.0);
          }

          // Classic Perlin noise
          float cnoise(vec3 P)
          {
          	vec3 Pi0 = floor(P); // Integer part for indexing
          	vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          // Classic Perlin noise, periodic variant
          float pnoise(vec3 P, vec3 rep)
          {
          	vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
          	vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          #define PI 3.1415926535897932384626433832795

          uniform float time;
          uniform float scroll;
          uniform float maxHeight;
          uniform float speed;
          uniform float distortCenter;
          uniform float roadWidth;
          varying float vDisplace;

          varying float fogDepth;

          void main(){

          	float t = time * speed;
          	float wRoad = distortCenter;
          	float wRoad2 = wRoad * 0.5;

          	float angleCenter = uv.y * PI*4.0;
          	angleCenter += t * 0.9;

          	float centerOff = (
          		sin(angleCenter) +
          		sin(angleCenter*0.5)
          	) * wRoad;


          	vec3 noiseIn = vec3(uv, 1.0)*10.0;
          	float noise = cnoise(vec3(noiseIn.x, noiseIn.y + scroll, noiseIn.z));
          	noise += 1.0;
          	float h = noise;
          	float angle = (uv.x - centerOff) * PI;
          	float f = abs(cos(angle));
          	h *= pow(f, 1.5 + roadWidth);


          	vDisplace = h;


          	h*=maxHeight;

          	vec3 transformed = vec3( position.x, position.y, position.z + h );


          	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
          	gl_Position = projectionMatrix * mvPosition;

          	fogDepth = -mvPosition.z;

          }
`, m = `
   uniform float time;
          uniform vec3 color;
          uniform sampler2D pallete;
          varying float vDisplace;

          uniform vec3 fogColor;
          uniform float fogNear;
          uniform float fogFar;
          varying float fogDepth;

          void main(){

          	vec2 stripPos = vec2( 0.0, vDisplace * (sin(time)*0.5+0.7) );
          	vec4 stripColor = texture2D( pallete, stripPos );
          	stripColor *= pow(1.0-vDisplace, 1.0);

          	gl_FragColor = stripColor;

          	#ifdef USE_FOG
          		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
          		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
          	#endif
          }`;
      var C = document.querySelector(".landscape"), O = window.innerWidth, E = window.innerHeight, U, Y, H, K, B = { x: 0, y: 0, xDamped: 0, yDamped: 0 }, q = typeof window.orientation < "u";
      b();
      function b() {
        A(), d(), g(), z(), q ? window.addEventListener("touchmove", F, { passive: !1 }) : window.addEventListener("mousemove", F), window.addEventListener("resize", x), x();
      }
      function A() {
        U = new THREE.Scene();
        var ft = new THREE.Color(3355443);
        U.background = ft, U.fog = new THREE.Fog(ft, 0, 400), M(), H = new THREE.PerspectiveCamera(60, O / E, 0.1, 1e4), H.position.y = 8, H.position.z = 4;
        let gt = new THREE.AmbientLight(16777215, 1);
        U.add(gt), Y = new THREE.WebGLRenderer({
          canvas: C,
          antialias: !0
        }), Y.setPixelRatio = devicePixelRatio, Y.setSize(O, E);
      }
      function d() {
        var ft = new THREE.PlaneBufferGeometry(100, 400, 400, 400), gt = {
          time: { type: "f", value: 0 },
          scroll: { type: "f", value: 0 },
          distortCenter: { type: "f", value: 0.1 },
          roadWidth: { type: "f", value: 0.5 },
          pallete: { type: "t", value: null },
          speed: { type: "f", value: 3 },
          maxHeight: { type: "f", value: 10 },
          color: new THREE.Color(1, 1, 1)
        }, zt = new THREE.ShaderMaterial({
          uniforms: THREE.UniformsUtils.merge([
            THREE.ShaderLib.basic.uniforms,
            gt
          ]),
          vertexShader: G,
          fragmentShader: m,
          wireframe: !1,
          fog: !0
        });
        K = new THREE.Mesh(ft, zt), K.position.z = -180, K.rotation.x = -Math.PI / 2, U.add(K);
      }
      function g() {
        new THREE.TextureLoader().load("", function(ft) {
          K.material.uniforms.pallete.value = ft, K.material.needsUpdate = !0;
        });
      }
      function M() {
        M = new THREE.Sky(), M.scale.setScalar(45e4), M.material.uniforms.turbidity.value = 13, M.material.uniforms.rayleigh.value = 1.2, M.material.uniforms.luminance.value = 1, M.material.uniforms.mieCoefficient.value = 0.1, M.material.uniforms.mieDirectionalG.value = 0.58, U.add(M);
        let ft = new THREE.Mesh(
          new THREE.SphereBufferGeometry(2e4, 16, 8),
          new THREE.MeshBasicMaterial({ color: 16777215 })
        );
        ft.visible = !1, U.add(ft);
        var gt = Math.PI * -2e-3, zt = 2 * Math.PI * -0.25;
        ft.position.x = 4e5 * Math.cos(zt), ft.position.y = 4e5 * Math.sin(zt) * Math.sin(gt), ft.position.z = 4e5 * Math.sin(zt) * Math.cos(gt), M.material.uniforms.sunPosition.value.copy(ft.position);
      }
      function x() {
        O = window.innerWidth, E = window.innerHeight, H.aspect = O / E, H.updateProjectionMatrix(), Y.setSize(O, E);
      }
      function F(ft) {
        ft.preventDefault();
        var gt, zt;
        ft.type == "mousemove" ? (gt = ft.clientX, zt = ft.clientY) : (gt = ft.changedTouches[0].clientX, zt = ft.changedTouches[0].clientY), B.x = gt, B.y = zt;
      }
      function z() {
        requestAnimationFrame(z), B.xDamped = ht(B.xDamped, B.x, 0.1), B.yDamped = ht(B.yDamped, B.y, 0.1);
        var ft = performance.now() * 1e-3;
        K.material.uniforms.time.value = ft, K.material.uniforms.scroll.value = ft + V(B.yDamped, 0, E, 0, 4), K.material.uniforms.distortCenter.value = Math.sin(ft) * 0.1, K.material.uniforms.roadWidth.value = V(
          B.xDamped,
          0,
          O,
          1,
          4.5
        ), H.position.y = V(B.yDamped, 0, E, 4, 11), Y.render(U, H);
      }
      function V(ft, gt, zt, lt, Et) {
        return lt + (Et - lt) * ((ft - gt) / (zt - gt));
      }
      function ht(ft, gt, zt) {
        return (1 - zt) * ft + zt * gt;
      }
    }, p = () => {
      const G = document.querySelector(".overlay"), m = document.querySelector(".content__title");
      charming(m);
      const C = Array.from(m.querySelectorAll("span"));
      TweenMax.to(G, 2, {
        ease: Quad.easeOut,
        opacity: 0
      }), TweenMax.set(C, { opacity: 0 }), TweenMax.staggerTo(
        C,
        1.5,
        {
          ease: Expo.easeOut,
          startAt: { rotationX: -100, z: -1e3 },
          opacity: 1,
          rotationX: 0,
          z: 0
        },
        0.1
      );
    }, $ = () => {
      J(), p();
    };
    return Hh(() => {
      $();
    }), (G, m) => (sh(), ah("div", Vm, [
      lr("div", Xm, [
        qm,
        lr("h2", Ym, [
          Gu(G.$slots, "default")
        ])
      ]),
      Zm
    ]));
  }
});
(function(T, J) {
  typeof exports == "object" && typeof module < "u" ? J(exports) : typeof define == "function" && define.amd ? define(["exports"], J) : J(T.THREE = {});
})(window, function(T) {
  function J() {
  }
  function p(t, e) {
    this.x = t || 0, this.y = e || 0;
  }
  function $() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function G(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = n !== void 0 ? n : 1;
  }
  function m(t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0;
  }
  function C() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function O(t, e, i, n, o, s, l, h, c, f) {
    Object.defineProperty(this, "id", { value: Qo++ }), this.uuid = fi.generateUUID(), this.name = "", this.image = t !== void 0 ? t : O.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = e !== void 0 ? e : O.DEFAULT_MAPPING, this.wrapS = i !== void 0 ? i : 1001, this.wrapT = n !== void 0 ? n : 1001, this.magFilter = o !== void 0 ? o : 1006, this.minFilter = s !== void 0 ? s : 1008, this.anisotropy = c !== void 0 ? c : 1, this.format = l !== void 0 ? l : 1023, this.type = h !== void 0 ? h : 1009, this.offset = new p(0, 0), this.repeat = new p(1, 1), this.center = new p(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new C(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = f !== void 0 ? f : 3e3, this.version = 0, this.onUpdate = null;
  }
  function E(t, e, i, n) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n !== void 0 ? n : 1;
  }
  function U(t, e, i) {
    this.width = t, this.height = e, this.scissor = new E(0, 0, t, e), this.scissorTest = !1, this.viewport = new E(0, 0, t, e), i = i || {}, i.minFilter === void 0 && (i.minFilter = 1006), this.texture = new O(
      void 0,
      void 0,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    ), this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !0, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !0, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null;
  }
  function Y(t, e, i) {
    U.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0;
  }
  function H(t, e, i, n, o, s, l, h, c, f, v, y) {
    O.call(this, null, s, l, h, c, f, n, o, v, y), this.image = { data: t, width: e, height: i }, this.magFilter = c !== void 0 ? c : 1003, this.minFilter = f !== void 0 ? f : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1;
  }
  function K(t, e) {
    this.min = t !== void 0 ? t : new m(1 / 0, 1 / 0, 1 / 0), this.max = e !== void 0 ? e : new m(-1 / 0, -1 / 0, -1 / 0);
  }
  function B(t, e) {
    this.center = t !== void 0 ? t : new m(), this.radius = e !== void 0 ? e : 0;
  }
  function q(t, e) {
    this.normal = t !== void 0 ? t : new m(1, 0, 0), this.constant = e !== void 0 ? e : 0;
  }
  function b(t, e, i, n, o, s) {
    this.planes = [
      t !== void 0 ? t : new q(),
      e !== void 0 ? e : new q(),
      i !== void 0 ? i : new q(),
      n !== void 0 ? n : new q(),
      o !== void 0 ? o : new q(),
      s !== void 0 ? s : new q()
    ];
  }
  function A(t, e, i) {
    return e === void 0 && i === void 0 ? this.set(t) : this.setRGB(t, e, i);
  }
  function d() {
    function t(o, s) {
      i !== !1 && (n(o, s), e.requestAnimationFrame(t));
    }
    var e = null, i = !1, n = null;
    return {
      start: function() {
        i !== !0 && n !== null && (e.requestAnimationFrame(t), i = !0);
      },
      stop: function() {
        i = !1;
      },
      setAnimationLoop: function(o) {
        n = o;
      },
      setContext: function(o) {
        e = o;
      }
    };
  }
  function g(t) {
    function e(n, o) {
      var s = n.array, l = n.dynamic ? 35048 : 35044, h = t.createBuffer();
      return t.bindBuffer(o, h), t.bufferData(o, s, l), n.onUploadCallback(), o = 5126, s instanceof Float32Array ? o = 5126 : s instanceof Float64Array ? console.warn(
        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
      ) : s instanceof Uint16Array ? o = 5123 : s instanceof Int16Array ? o = 5122 : s instanceof Uint32Array ? o = 5125 : s instanceof Int32Array ? o = 5124 : s instanceof Int8Array ? o = 5120 : s instanceof Uint8Array && (o = 5121), {
        buffer: h,
        type: o,
        bytesPerElement: s.BYTES_PER_ELEMENT,
        version: n.version
      };
    }
    var i = /* @__PURE__ */ new WeakMap();
    return {
      get: function(n) {
        return n.isInterleavedBufferAttribute && (n = n.data), i.get(n);
      },
      remove: function(n) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var o = i.get(n);
        o && (t.deleteBuffer(o.buffer), i.delete(n));
      },
      update: function(n, o) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var s = i.get(n);
        if (s === void 0)
          i.set(n, e(n, o));
        else if (s.version < n.version) {
          var l = n, h = l.array, c = l.updateRange;
          t.bindBuffer(o, s.buffer), l.dynamic === !1 ? t.bufferData(o, h, 35044) : c.count === -1 ? t.bufferSubData(o, 0, h) : c.count === 0 ? console.error(
            "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
          ) : (t.bufferSubData(
            o,
            c.offset * h.BYTES_PER_ELEMENT,
            h.subarray(c.offset, c.offset + c.count)
          ), c.count = -1), s.version = n.version;
        }
      }
    };
  }
  function M(t, e, i, n, o, s) {
    this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new m(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new A(), this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = s !== void 0 ? s : 0;
  }
  function x(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || x.DefaultOrder;
  }
  function F() {
    this.mask = 1;
  }
  function z() {
    Object.defineProperty(this, "id", { value: uh++ }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = z.DefaultUp.clone();
    var t = new m(), e = new x(), i = new G(), n = new m(1, 1, 1);
    e.onChange(function() {
      i.setFromEuler(e, !1);
    }), i.onChange(function() {
      e.setFromQuaternion(i, void 0, !1);
    }), Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: t },
      rotation: { configurable: !0, enumerable: !0, value: e },
      quaternion: { configurable: !0, enumerable: !0, value: i },
      scale: { configurable: !0, enumerable: !0, value: n },
      modelViewMatrix: { value: new $() },
      normalMatrix: { value: new C() }
    }), this.matrix = new $(), this.matrixWorld = new $(), this.matrixAutoUpdate = z.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new F(), this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
  }
  function V() {
    Object.defineProperty(this, "id", { value: ch += 2 }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function ht(t, e, i) {
    if (Array.isArray(t))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i === !0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function ft(t, e, i) {
    ht.call(this, new Int8Array(t), e, i);
  }
  function gt(t, e, i) {
    ht.call(this, new Uint8Array(t), e, i);
  }
  function zt(t, e, i) {
    ht.call(this, new Uint8ClampedArray(t), e, i);
  }
  function lt(t, e, i) {
    ht.call(this, new Int16Array(t), e, i);
  }
  function Et(t, e, i) {
    ht.call(this, new Uint16Array(t), e, i);
  }
  function D(t, e, i) {
    ht.call(this, new Int32Array(t), e, i);
  }
  function Bt(t, e, i) {
    ht.call(this, new Uint32Array(t), e, i);
  }
  function Ct(t, e, i) {
    ht.call(this, new Float32Array(t), e, i);
  }
  function Rt(t, e, i) {
    ht.call(this, new Float64Array(t), e, i);
  }
  function ge() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function ue(t) {
    if (t.length === 0)
      return -1 / 0;
    for (var e = t[0], i = 1, n = t.length; i < n; ++i)
      t[i] > e && (e = t[i]);
    return e;
  }
  function Ft() {
    Object.defineProperty(this, "id", { value: fh += 2 }), this.uuid = fi.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  function Dt(t, e, i, n, o, s) {
    V.call(this), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: o,
      depthSegments: s
    }, this.fromBufferGeometry(new kt(t, e, i, n, o, s)), this.mergeVertices();
  }
  function kt(t, e, i, n, o, s) {
    function l(N, j, et, _t, mt, bt, xt, Wt, W, it, It) {
      var ee = bt / W, $t = xt / it, qt = bt / 2, Te = xt / 2, pe = Wt / 2;
      xt = W + 1;
      var Oe = it + 1, be = bt = 0, se, je, Ke = new m();
      for (je = 0; je < Oe; je++) {
        var ci = je * $t - Te;
        for (se = 0; se < xt; se++)
          Ke[N] = (se * ee - qt) * _t, Ke[j] = ci * mt, Ke[et] = pe, f.push(Ke.x, Ke.y, Ke.z), Ke[N] = 0, Ke[j] = 0, Ke[et] = 0 < Wt ? 1 : -1, v.push(Ke.x, Ke.y, Ke.z), y.push(se / W), y.push(1 - je / it), bt += 1;
      }
      for (je = 0; je < it; je++)
        for (se = 0; se < W; se++)
          N = S + se + xt * (je + 1), j = S + (se + 1) + xt * (je + 1), et = S + (se + 1) + xt * je, c.push(S + se + xt * je, N, et), c.push(N, j, et), be += 6;
      h.addGroup(P, be, It), P += be, S += bt;
    }
    Ft.call(this), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: o,
      depthSegments: s
    };
    var h = this;
    t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, s = Math.floor(s) || 1;
    var c = [], f = [], v = [], y = [], S = 0, P = 0;
    l("z", "y", "x", -1, -1, i, e, t, s, o, 0), l("z", "y", "x", 1, -1, i, e, -t, s, o, 1), l("x", "z", "y", 1, 1, t, i, e, n, s, 2), l("x", "z", "y", 1, -1, t, i, -e, n, s, 3), l("x", "y", "z", 1, -1, t, e, i, n, o, 4), l("x", "y", "z", -1, -1, t, e, -i, n, o, 5), this.setIndex(c), this.addAttribute("position", new Ct(f, 3)), this.addAttribute("normal", new Ct(v, 3)), this.addAttribute("uv", new Ct(y, 2));
  }
  function Fe(t, e, i, n) {
    V.call(this), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, this.fromBufferGeometry(new xe(t, e, i, n)), this.mergeVertices();
  }
  function xe(t, e, i, n) {
    Ft.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, t = t || 1, e = e || 1;
    var o = t / 2, s = e / 2;
    i = Math.floor(i) || 1, n = Math.floor(n) || 1;
    var l = i + 1, h = n + 1, c = t / i, f = e / n, v = [], y = [], S = [], P = [];
    for (t = 0; t < h; t++) {
      var N = t * f - s;
      for (e = 0; e < l; e++)
        y.push(e * c - o, -N, 0), S.push(0, 0, 1), P.push(e / i), P.push(1 - t / n);
    }
    for (t = 0; t < n; t++)
      for (e = 0; e < i; e++)
        o = e + l * (t + 1), s = e + 1 + l * (t + 1), h = e + 1 + l * t, v.push(e + l * t, o, h), v.push(o, s, h);
    this.setIndex(v), this.addAttribute("position", new Ct(y, 3)), this.addAttribute("normal", new Ct(S, 3)), this.addAttribute("uv", new Ct(P, 2));
  }
  function Zt() {
    Object.defineProperty(this, "id", { value: Nl++ }), this.uuid = fi.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0;
  }
  function ti(t) {
    Zt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, t !== void 0 && (t.attributes !== void 0 && console.error(
      "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
    ), this.setValues(t));
  }
  function Ni(t, e) {
    this.origin = t !== void 0 ? t : new m(), this.direction = e !== void 0 ? e : new m();
  }
  function Ie(t, e, i) {
    this.a = t !== void 0 ? t : new m(), this.b = e !== void 0 ? e : new m(), this.c = i !== void 0 ? i : new m();
  }
  function Ge(t) {
    Zt.call(this), this.type = "MeshBasicMaterial", this.color = new A(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function pi(t, e) {
    z.call(this), this.type = "Mesh", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Ge({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets();
  }
  function Li(t, e, i, n) {
    function o(f, v) {
      e.buffers.color.setClear(f.r, f.g, f.b, v, n);
    }
    var s = new A(0), l = 0, h, c;
    return {
      getClearColor: function() {
        return s;
      },
      setClearColor: function(f, v) {
        s.set(f), l = v !== void 0 ? v : 1, o(s, l);
      },
      getClearAlpha: function() {
        return l;
      },
      setClearAlpha: function(f) {
        l = f, o(s, l);
      },
      render: function(f, v, y, S) {
        v = v.background, v === null ? o(s, l) : v && v.isColor && (o(v, 1), S = !0), (t.autoClear || S) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), v && (v.isCubeTexture || v.isWebGLRenderTargetCube) ? (c === void 0 && (c = new pi(
          new kt(1, 1, 1),
          new ti({
            type: "BackgroundCubeMaterial",
            uniforms: bn.clone(jr.cube.uniforms),
            vertexShader: jr.cube.vertexShader,
            fragmentShader: jr.cube.fragmentShader,
            side: 1,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), c.geometry.removeAttribute("normal"), c.geometry.removeAttribute("uv"), c.onBeforeRender = function(P, N, j) {
          this.matrixWorld.copyPosition(j.matrixWorld);
        }, i.update(c)), c.material.uniforms.tCube.value = v.isWebGLRenderTargetCube ? v.texture : v, c.material.uniforms.tFlip.value = v.isWebGLRenderTargetCube ? 1 : -1, f.push(c, c.geometry, c.material, 0, null)) : v && v.isTexture && (h === void 0 && (h = new pi(
          new xe(2, 2),
          new ti({
            type: "BackgroundMaterial",
            uniforms: bn.clone(jr.background.uniforms),
            vertexShader: jr.background.vertexShader,
            fragmentShader: jr.background.fragmentShader,
            side: 0,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), h.geometry.removeAttribute("normal"), i.update(h)), h.material.uniforms.t2D.value = v, v.matrixAutoUpdate === !0 && v.updateMatrix(), h.material.uniforms.uvTransform.value.copy(v.matrix), f.push(h, h.geometry, h.material, 0, null));
      }
    };
  }
  function an(t, e, i, n) {
    var o;
    this.setMode = function(s) {
      o = s;
    }, this.render = function(s, l) {
      t.drawArrays(o, s, l), i.update(l, o);
    }, this.renderInstances = function(s, l, h) {
      if (n.isWebGL2)
        var c = t;
      else if (c = e.get("ANGLE_instanced_arrays"), c === null) {
        console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](
        o,
        l,
        h,
        s.maxInstancedCount
      ), i.update(h, o, s.maxInstancedCount);
    };
  }
  function Zi(t, e, i) {
    function n(_t) {
      if (_t === "highp") {
        if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision)
          return "highp";
        _t = "mediump";
      }
      return _t === "mediump" && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var o, s = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext, l = i.precision !== void 0 ? i.precision : "highp", h = n(l);
    h !== l && (console.warn(
      "THREE.WebGLRenderer:",
      l,
      "not supported, using",
      h,
      "instead."
    ), l = h), i = i.logarithmicDepthBuffer === !0, h = t.getParameter(34930);
    var c = t.getParameter(35660), f = t.getParameter(3379), v = t.getParameter(34076), y = t.getParameter(34921), S = t.getParameter(36347), P = t.getParameter(36348), N = t.getParameter(36349), j = 0 < c, et = s || !!e.get("OES_texture_float");
    return {
      isWebGL2: s,
      getMaxAnisotropy: function() {
        if (o !== void 0)
          return o;
        var _t = e.get("EXT_texture_filter_anisotropic");
        return o = _t !== null ? t.getParameter(_t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      },
      getMaxPrecision: n,
      precision: l,
      logarithmicDepthBuffer: i,
      maxTextures: h,
      maxVertexTextures: c,
      maxTextureSize: f,
      maxCubemapSize: v,
      maxAttributes: y,
      maxVertexUniforms: S,
      maxVaryings: P,
      maxFragmentUniforms: N,
      vertexTextures: j,
      floatFragmentTextures: et,
      floatVertexTextures: j && et
    };
  }
  function R() {
    function t() {
      f.value !== n && (f.value = n, f.needsUpdate = 0 < o), i.numPlanes = o, i.numIntersection = 0;
    }
    function e(v, y, S, P) {
      var N = v !== null ? v.length : 0, j = null;
      if (N !== 0) {
        if (j = f.value, P !== !0 || j === null)
          for (P = S + 4 * N, y = y.matrixWorldInverse, c.getNormalMatrix(y), (j === null || j.length < P) && (j = new Float32Array(P)), P = 0; P !== N; ++P, S += 4)
            h.copy(v[P]).applyMatrix4(y, c), h.normal.toArray(j, S), j[S + 3] = h.constant;
        f.value = j, f.needsUpdate = !0;
      }
      return i.numPlanes = N, j;
    }
    var i = this, n = null, o = 0, s = !1, l = !1, h = new q(), c = new C(), f = { value: null, needsUpdate: !1 };
    this.uniform = f, this.numIntersection = this.numPlanes = 0, this.init = function(v, y, S) {
      var P = v.length !== 0 || y || o !== 0 || s;
      return s = y, n = e(v, S, 0), o = v.length, P;
    }, this.beginShadows = function() {
      l = !0, e(null);
    }, this.endShadows = function() {
      l = !1, t();
    }, this.setState = function(v, y, S, P, N, j) {
      if (!s || v === null || v.length === 0 || l && !S)
        l ? e(null) : t();
      else {
        S = l ? 0 : o;
        var et = 4 * S, _t = N.clippingState || null;
        for (f.value = _t, _t = e(v, P, et, j), v = 0; v !== et; ++v)
          _t[v] = n[v];
        N.clippingState = _t, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += S;
      }
    };
  }
  function Jt(t) {
    var e = {};
    return {
      get: function(i) {
        if (e[i] !== void 0)
          return e[i];
        switch (i) {
          case "WEBGL_depth_texture":
            var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = t.getExtension(i);
        }
        return n === null && console.warn(
          "THREE.WebGLRenderer: " + i + " extension not supported."
        ), e[i] = n;
      }
    };
  }
  function jt(t, e, i) {
    function n(l) {
      var h = l.target;
      l = o[h.id], l.index !== null && e.remove(l.index);
      for (var c in l.attributes)
        e.remove(l.attributes[c]);
      h.removeEventListener("dispose", n), delete o[h.id], (c = s[l.id]) && (e.remove(c), delete s[l.id]), i.memory.geometries--;
    }
    var o = {}, s = {};
    return {
      get: function(l, h) {
        var c = o[h.id];
        return c || (h.addEventListener("dispose", n), h.isBufferGeometry ? c = h : h.isGeometry && (h._bufferGeometry === void 0 && (h._bufferGeometry = new Ft().setFromObject(l)), c = h._bufferGeometry), o[h.id] = c, i.memory.geometries++, c);
      },
      update: function(l) {
        var h = l.index, c = l.attributes;
        h !== null && e.update(h, 34963);
        for (var f in c)
          e.update(c[f], 34962);
        l = l.morphAttributes;
        for (f in l) {
          h = l[f], c = 0;
          for (var v = h.length; c < v; c++)
            e.update(h[c], 34962);
        }
      },
      getWireframeAttribute: function(l) {
        var h = s[l.id];
        if (h)
          return h;
        h = [];
        var c = l.index, f = l.attributes;
        if (c !== null) {
          c = c.array, f = 0;
          for (var v = c.length; f < v; f += 3) {
            var y = c[f + 0], S = c[f + 1], P = c[f + 2];
            h.push(y, S, S, P, P, y);
          }
        } else
          for (c = f.position.array, f = 0, v = c.length / 3 - 1; f < v; f += 3)
            y = f + 0, S = f + 1, P = f + 2, h.push(y, S, S, P, P, y);
        return h = new (65535 < ue(h) ? Bt : Et)(h, 1), e.update(h, 34963), s[l.id] = h;
      }
    };
  }
  function ct(t, e, i, n) {
    var o, s, l;
    this.setMode = function(h) {
      o = h;
    }, this.setIndex = function(h) {
      s = h.type, l = h.bytesPerElement;
    }, this.render = function(h, c) {
      t.drawElements(o, c, s, h * l), i.update(c, o);
    }, this.renderInstances = function(h, c, f) {
      if (n.isWebGL2)
        var v = t;
      else if (v = e.get("ANGLE_instanced_arrays"), v === null) {
        console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      v[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](
        o,
        f,
        s,
        c * l,
        h.maxInstancedCount
      ), i.update(f, o, h.maxInstancedCount);
    };
  }
  function pt(t) {
    var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function() {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      },
      update: function(i, n, o) {
        switch (o = o || 1, e.calls++, n) {
          case 4:
            e.triangles += i / 3 * o;
            break;
          case 5:
          case 6:
            e.triangles += o * (i - 2);
            break;
          case 1:
            e.lines += i / 2 * o;
            break;
          case 3:
            e.lines += o * (i - 1);
            break;
          case 2:
            e.lines += o * i;
            break;
          case 0:
            e.points += o * i;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      }
    };
  }
  function Lt(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function ie(t) {
    var e = {}, i = new Float32Array(8);
    return {
      update: function(n, o, s, l) {
        var h = n.morphTargetInfluences, c = h.length;
        if (n = e[o.id], n === void 0) {
          n = [];
          for (var f = 0; f < c; f++)
            n[f] = [f, 0];
          e[o.id] = n;
        }
        var v = s.morphTargets && o.morphAttributes.position;
        for (s = s.morphNormals && o.morphAttributes.normal, f = 0; f < c; f++) {
          var y = n[f];
          y[1] !== 0 && (v && o.removeAttribute("morphTarget" + f), s && o.removeAttribute("morphNormal" + f));
        }
        for (f = 0; f < c; f++)
          y = n[f], y[0] = f, y[1] = h[f];
        for (n.sort(Lt), f = 0; 8 > f; f++) {
          if ((y = n[f]) && (h = y[0], c = y[1])) {
            v && o.addAttribute("morphTarget" + f, v[h]), s && o.addAttribute("morphNormal" + f, s[h]), i[f] = c;
            continue;
          }
          i[f] = 0;
        }
        l.getUniforms().setValue(t, "morphTargetInfluences", i);
      }
    };
  }
  function Kt(t, e) {
    var i = {};
    return {
      update: function(n) {
        var o = e.render.frame, s = n.geometry, l = t.get(n, s);
        return i[l.id] !== o && (s.isGeometry && l.updateFromObject(n), t.update(l), i[l.id] = o), l;
      },
      dispose: function() {
        i = {};
      }
    };
  }
  function w(t, e, i, n, o, s, l, h, c, f) {
    t = t !== void 0 ? t : [], O.call(this, t, e !== void 0 ? e : 301, i, n, o, s, l, h, c, f), this.flipY = !1;
  }
  function X(t, e, i, n) {
    O.call(this, null), this.image = { data: t, width: e, height: i, depth: n }, this.minFilter = this.magFilter = 1003, this.flipY = this.generateMipmaps = !1;
  }
  function nt(t, e, i) {
    var n = t[0];
    if (0 >= n || 0 < n)
      return t;
    var o = e * i, s = Ga[o];
    if (s === void 0 && (s = new Float32Array(o), Ga[o] = s), e !== 0)
      for (n.toArray(s, 0), n = 1, o = 0; n !== e; ++n)
        o += i, t[n].toArray(s, o);
    return s;
  }
  function tt(t, e) {
    if (t.length !== e.length)
      return !1;
    for (var i = 0, n = t.length; i < n; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  function vt(t, e) {
    for (var i = 0, n = e.length; i < n; i++)
      t[i] = e[i];
  }
  function Gt(t, e) {
    var i = zs[e];
    i === void 0 && (i = new Int32Array(e), zs[e] = i);
    for (var n = 0; n !== e; ++n)
      i[n] = t.allocTextureUnit();
    return i;
  }
  function Xt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e);
  }
  function Vt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e);
  }
  function Ne(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : tt(i, e) || (t.uniform2fv(this.addr, e), vt(i, e));
  }
  function Re(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : e.r !== void 0 ? (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : tt(i, e) || (t.uniform3fv(this.addr, e), vt(i, e));
  }
  function de(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : tt(i, e) || (t.uniform4fv(this.addr, e), vt(i, e));
  }
  function we(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? tt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), vt(i, e)) : tt(i, n) || (pl.set(n), t.uniformMatrix2fv(this.addr, !1, pl), vt(i, n));
  }
  function vi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? tt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), vt(i, e)) : tt(i, n) || (Ul.set(n), t.uniformMatrix3fv(this.addr, !1, Ul), vt(i, n));
  }
  function Mi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? tt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), vt(i, e)) : tt(i, n) || (ma.set(n), t.uniformMatrix4fv(this.addr, !1, ma), vt(i, n));
  }
  function ni(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTexture2D(e || fl, o);
  }
  function Si(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTexture3D(e || ph, o);
  }
  function wr(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTextureCube(e || kl, o);
  }
  function jn(t, e) {
    var i = this.cache;
    tt(i, e) || (t.uniform2iv(this.addr, e), vt(i, e));
  }
  function tn(t, e) {
    var i = this.cache;
    tt(i, e) || (t.uniform3iv(this.addr, e), vt(i, e));
  }
  function $r(t, e) {
    var i = this.cache;
    tt(i, e) || (t.uniform4iv(this.addr, e), vt(i, e));
  }
  function Ri(t) {
    switch (t) {
      case 5126:
        return Xt;
      case 35664:
        return Ne;
      case 35665:
        return Re;
      case 35666:
        return de;
      case 35674:
        return we;
      case 35675:
        return vi;
      case 35676:
        return Mi;
      case 35678:
      case 36198:
        return ni;
      case 35679:
        return Si;
      case 35680:
        return wr;
      case 5124:
      case 35670:
        return Vt;
      case 35667:
      case 35671:
        return jn;
      case 35668:
      case 35672:
        return tn;
      case 35669:
      case 35673:
        return $r;
    }
  }
  function co(t, e) {
    var i = this.cache;
    tt(i, e) || (t.uniform1fv(this.addr, e), vt(i, e));
  }
  function Rr(t, e) {
    var i = this.cache;
    tt(i, e) || (t.uniform1iv(this.addr, e), vt(i, e));
  }
  function Ma(t, e) {
    var i = this.cache;
    e = nt(e, this.size, 2), tt(i, e) || (t.uniform2fv(this.addr, e), this.updateCache(e));
  }
  function dn(t, e) {
    var i = this.cache;
    e = nt(e, this.size, 3), tt(i, e) || (t.uniform3fv(this.addr, e), this.updateCache(e));
  }
  function ls(t, e) {
    var i = this.cache;
    e = nt(e, this.size, 4), tt(i, e) || (t.uniform4fv(this.addr, e), this.updateCache(e));
  }
  function Lo(t, e) {
    var i = this.cache;
    e = nt(e, this.size, 4), tt(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), this.updateCache(e));
  }
  function tr(t, e) {
    var i = this.cache;
    e = nt(e, this.size, 9), tt(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), this.updateCache(e));
  }
  function hs(t, e) {
    var i = this.cache;
    e = nt(e, this.size, 16), tt(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), this.updateCache(e));
  }
  function Hs(t, e, i) {
    var n = this.cache, o = e.length, s = Gt(i, o);
    for (tt(n, s) === !1 && (t.uniform1iv(this.addr, s), vt(n, s)), t = 0; t !== o; ++t)
      i.setTexture2D(e[t] || fl, s[t]);
  }
  function Sa(t, e, i) {
    var n = this.cache, o = e.length, s = Gt(i, o);
    for (tt(n, s) === !1 && (t.uniform1iv(this.addr, s), vt(n, s)), t = 0; t !== o; ++t)
      i.setTextureCube(e[t] || kl, s[t]);
  }
  function Ir(t) {
    switch (t) {
      case 5126:
        return co;
      case 35664:
        return Ma;
      case 35665:
        return dn;
      case 35666:
        return ls;
      case 35674:
        return Lo;
      case 35675:
        return tr;
      case 35676:
        return hs;
      case 35678:
        return Hs;
      case 35680:
        return Sa;
      case 5124:
      case 35670:
        return Rr;
      case 35667:
      case 35671:
        return jn;
      case 35668:
      case 35672:
        return tn;
      case 35669:
      case 35673:
        return $r;
    }
  }
  function $a(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.setValue = Ri(e.type);
  }
  function us(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = Ir(e.type);
  }
  function Ws(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  function Or(t, e, i) {
    this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, 35718);
    for (var n = 0; n < i; ++n) {
      var o = t.getActiveUniform(e, n), s = t.getUniformLocation(e, o.name), l = this, h = o.name, c = h.length;
      for (dl.lastIndex = 0; ; ) {
        var f = dl.exec(h), v = dl.lastIndex, y = f[1], S = f[3];
        if (f[2] === "]" && (y |= 0), S === void 0 || S === "[" && v + 2 === c) {
          h = l, o = S === void 0 ? new $a(y, o, s) : new us(y, o, s), h.seq.push(o), h.map[o.id] = o;
          break;
        } else
          S = l.map[y], S === void 0 && (S = new Ws(y), y = l, l = S, y.seq.push(l), y.map[l.id] = l), l = S;
      }
    }
  }
  function js(t) {
    t = t.split(`
`);
    for (var e = 0; e < t.length; e++)
      t[e] = e + 1 + ": " + t[e];
    return t.join(`
`);
  }
  function cs(t, e, i) {
    var n = t.createShader(e);
    return t.shaderSource(n, i), t.compileShader(n), t.getShaderParameter(n, 35713) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), t.getShaderInfoLog(n) !== "" && console.warn(
      "THREE.WebGLShader: gl.getShaderInfoLog()",
      e === 35633 ? "vertex" : "fragment",
      t.getShaderInfoLog(n),
      js(i)
    ), n;
  }
  function fs(t) {
    switch (t) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw Error("unsupported encoding: " + t);
    }
  }
  function Dr(t, e) {
    return e = fs(e), "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }";
  }
  function Ea(t, e) {
    return e = fs(e), "vec4 " + t + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
  }
  function Ka(t, e) {
    switch (e) {
      case 1:
        e = "Linear";
        break;
      case 2:
        e = "Reinhard";
        break;
      case 3:
        e = "Uncharted2";
        break;
      case 4:
        e = "OptimizedCineon";
        break;
      default:
        throw Error("unsupported toneMapping: " + e);
    }
    return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
  }
  function Qa(t, e, i) {
    return t = t || {}, [
      t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
      (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
      t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
      (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ].filter(Io).join(`
`);
  }
  function Ro(t) {
    var e = [], i;
    for (i in t) {
      var n = t[i];
      n !== !1 && e.push("#define " + i + " " + n);
    }
    return e.join(`
`);
  }
  function Io(t) {
    return t !== "";
  }
  function ba(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
  }
  function Aa(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
  }
  function Tr(t) {
    return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, i) {
      if (e = Ei[i], e === void 0)
        throw Error("Can not resolve #include <" + i + ">");
      return Tr(e);
    });
  }
  function L(t) {
    return t.replace(
      /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      function(e, i, n, o) {
        for (e = "", i = parseInt(i); i < parseInt(n); i++)
          e += o.replace(/\[ i \]/g, "[ " + i + " ]");
        return e;
      }
    );
  }
  function Z(t, e, i, n, o, s, l) {
    var h = t.context, c = n.defines, f = o.vertexShader, v = o.fragmentShader, y = "SHADOWMAP_TYPE_BASIC";
    s.shadowMapType === 1 ? y = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === 2 && (y = "SHADOWMAP_TYPE_PCF_SOFT");
    var S = "ENVMAP_TYPE_CUBE", P = "ENVMAP_MODE_REFLECTION", N = "ENVMAP_BLENDING_MULTIPLY";
    if (s.envMap) {
      switch (n.envMap.mapping) {
        case 301:
        case 302:
          S = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          S = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          S = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          S = "ENVMAP_TYPE_SPHERE";
      }
      switch (n.envMap.mapping) {
        case 302:
        case 304:
          P = "ENVMAP_MODE_REFRACTION";
      }
      switch (n.combine) {
        case 0:
          N = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          N = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          N = "ENVMAP_BLENDING_ADD";
      }
    }
    var j = 0 < t.gammaFactor ? t.gammaFactor : 1, et = l.isWebGL2 ? "" : Qa(n.extensions, s, e), _t = Ro(c), mt = h.createProgram();
    n.isRawShaderMaterial ? (c = [_t].filter(Io).join(`
`), 0 < c.length && (c += `
`), e = [et, _t].filter(Io).join(`
`), 0 < e.length && (e += `
`)) : (c = [
      "precision " + s.precision + " float;",
      "precision " + s.precision + " int;",
      "#define SHADER_NAME " + o.name,
      _t,
      s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + j,
      "#define MAX_BONES " + s.maxBones,
      s.useFog && s.fog ? "#define USE_FOG" : "",
      s.useFog && s.fogExp ? "#define FOG_EXP2" : "",
      s.map ? "#define USE_MAP" : "",
      s.envMap ? "#define USE_ENVMAP" : "",
      s.envMap ? "#define " + P : "",
      s.lightMap ? "#define USE_LIGHTMAP" : "",
      s.aoMap ? "#define USE_AOMAP" : "",
      s.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      s.bumpMap ? "#define USE_BUMPMAP" : "",
      s.normalMap ? "#define USE_NORMALMAP" : "",
      s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      s.specularMap ? "#define USE_SPECULARMAP" : "",
      s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      s.metalnessMap ? "#define USE_METALNESSMAP" : "",
      s.alphaMap ? "#define USE_ALPHAMAP" : "",
      s.vertexColors ? "#define USE_COLOR" : "",
      s.flatShading ? "#define FLAT_SHADED" : "",
      s.skinning ? "#define USE_SKINNING" : "",
      s.useVertexTexture ? "#define BONE_TEXTURE" : "",
      s.morphTargets ? "#define USE_MORPHTARGETS" : "",
      s.morphNormals && s.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
      s.doubleSided ? "#define DOUBLE_SIDED" : "",
      s.flipSided ? "#define FLIP_SIDED" : "",
      s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      s.shadowMapEnabled ? "#define " + y : "",
      s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      s.logarithmicDepthBuffer && (l.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(Io).join(`
`), e = [
      et,
      "precision " + s.precision + " float;",
      "precision " + s.precision + " int;",
      "#define SHADER_NAME " + o.name,
      _t,
      s.alphaTest ? "#define ALPHATEST " + s.alphaTest + (s.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + j,
      s.useFog && s.fog ? "#define USE_FOG" : "",
      s.useFog && s.fogExp ? "#define FOG_EXP2" : "",
      s.map ? "#define USE_MAP" : "",
      s.envMap ? "#define USE_ENVMAP" : "",
      s.envMap ? "#define " + S : "",
      s.envMap ? "#define " + P : "",
      s.envMap ? "#define " + N : "",
      s.lightMap ? "#define USE_LIGHTMAP" : "",
      s.aoMap ? "#define USE_AOMAP" : "",
      s.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      s.bumpMap ? "#define USE_BUMPMAP" : "",
      s.normalMap ? "#define USE_NORMALMAP" : "",
      s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      s.specularMap ? "#define USE_SPECULARMAP" : "",
      s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      s.metalnessMap ? "#define USE_METALNESSMAP" : "",
      s.alphaMap ? "#define USE_ALPHAMAP" : "",
      s.vertexColors ? "#define USE_COLOR" : "",
      s.gradientMap ? "#define USE_GRADIENTMAP" : "",
      s.flatShading ? "#define FLAT_SHADED" : "",
      s.doubleSided ? "#define DOUBLE_SIDED" : "",
      s.flipSided ? "#define FLIP_SIDED" : "",
      s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      s.shadowMapEnabled ? "#define " + y : "",
      s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      s.logarithmicDepthBuffer && (l.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      s.envMap && (l.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      s.toneMapping !== 0 ? "#define TONE_MAPPING" : "",
      s.toneMapping !== 0 ? Ei.tonemapping_pars_fragment : "",
      s.toneMapping !== 0 ? Ka("toneMapping", s.toneMapping) : "",
      s.dithering ? "#define DITHERING" : "",
      s.outputEncoding || s.mapEncoding || s.matcapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? Ei.encodings_pars_fragment : "",
      s.mapEncoding ? Dr("mapTexelToLinear", s.mapEncoding) : "",
      s.matcapEncoding ? Dr("matcapTexelToLinear", s.matcapEncoding) : "",
      s.envMapEncoding ? Dr("envMapTexelToLinear", s.envMapEncoding) : "",
      s.emissiveMapEncoding ? Dr("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "",
      s.outputEncoding ? Ea("linearToOutputTexel", s.outputEncoding) : "",
      s.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
      `
`
    ].filter(Io).join(`
`)), f = Tr(f), f = ba(f, s), f = Aa(f, s), v = Tr(v), v = ba(v, s), v = Aa(v, s), f = L(f), v = L(v), l.isWebGL2 && !n.isRawShaderMaterial && (l = !1, y = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && f.match(y) !== null && v.match(y) !== null && (l = !0, f = f.replace(y, ""), v = v.replace(y, "")), c = `#version 300 es

#define attribute in
#define varying out
#define texture2D texture
` + c, e = [
      `#version 300 es

#define varying in`,
      l ? "" : "out highp vec4 pc_fragColor;",
      l ? "" : "#define gl_FragColor pc_fragColor",
      `#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad`
    ].join(`
`) + `
` + e), v = e + v, f = cs(h, 35633, c + f), v = cs(h, 35632, v), h.attachShader(mt, f), h.attachShader(mt, v), n.index0AttributeName !== void 0 ? h.bindAttribLocation(mt, 0, n.index0AttributeName) : s.morphTargets === !0 && h.bindAttribLocation(mt, 0, "position"), h.linkProgram(mt), s = h.getProgramInfoLog(mt).trim(), l = h.getShaderInfoLog(f).trim(), y = h.getShaderInfoLog(v).trim(), P = S = !0, h.getProgramParameter(mt, 35714) === !1 ? (S = !1, console.error(
      "THREE.WebGLProgram: shader error: ",
      h.getError(),
      "35715",
      h.getProgramParameter(mt, 35715),
      "gl.getProgramInfoLog",
      s,
      l,
      y
    )) : s !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", s) : (l === "" || y === "") && (P = !1), P && (this.diagnostics = {
      runnable: S,
      material: n,
      programLog: s,
      vertexShader: { log: l, prefix: c },
      fragmentShader: { log: y, prefix: e }
    }), h.deleteShader(f), h.deleteShader(v);
    var bt;
    this.getUniforms = function() {
      return bt === void 0 && (bt = new Or(h, mt, t)), bt;
    };
    var xt;
    return this.getAttributes = function() {
      if (xt === void 0) {
        for (var Wt = {}, W = h.getProgramParameter(mt, 35721), it = 0; it < W; it++) {
          var It = h.getActiveAttrib(mt, it).name;
          Wt[It] = h.getAttribLocation(mt, It);
        }
        xt = Wt;
      }
      return xt;
    }, this.destroy = function() {
      h.deleteProgram(mt), this.program = void 0;
    }, Object.defineProperties(this, {
      uniforms: {
        get: function() {
          return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
        }
      },
      attributes: {
        get: function() {
          return console.warn(
            "THREE.WebGLProgram: .attributes is now .getAttributes()."
          ), this.getAttributes();
        }
      }
    }), this.name = o.name, this.id = so++, this.code = i, this.usedTimes = 1, this.program = mt, this.vertexShader = f, this.fragmentShader = v, this;
  }
  function ot(t, e, i) {
    function n(h, c) {
      if (h)
        h.isTexture ? f = h.encoding : h.isWebGLRenderTarget && (console.warn(
          "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
        ), f = h.texture.encoding);
      else
        var f = 3e3;
      return f === 3e3 && c && (f = 3007), f;
    }
    var o = [], s = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "phong",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    }, l = "precision supportsVertexTextures map mapEncoding matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(
      " "
    );
    this.getParameters = function(h, c, f, v, y, S, P) {
      var N = s[h.type];
      if (P.isSkinnedMesh) {
        var j = P.skeleton.bones;
        if (i.floatVertexTextures)
          j = 1024;
        else {
          var et = Math.min(
            Math.floor((i.maxVertexUniforms - 20) / 4),
            j.length
          );
          et < j.length ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " + j.length + " bones. This GPU supports " + et + "."
          ), j = 0) : j = et;
        }
      } else
        j = 0;
      et = i.precision, h.precision !== null && (et = i.getMaxPrecision(h.precision), et !== h.precision && console.warn(
        "THREE.WebGLProgram.getParameters:",
        h.precision,
        "not supported, using",
        et,
        "instead."
      ));
      var _t = t.getRenderTarget();
      return {
        shaderID: N,
        precision: et,
        supportsVertexTextures: i.vertexTextures,
        outputEncoding: n(_t ? _t.texture : null, t.gammaOutput),
        map: !!h.map,
        mapEncoding: n(h.map, t.gammaInput),
        matcap: !!h.matcap,
        matcapEncoding: n(h.matcap, t.gammaInput),
        envMap: !!h.envMap,
        envMapMode: h.envMap && h.envMap.mapping,
        envMapEncoding: n(h.envMap, t.gammaInput),
        envMapCubeUV: !!h.envMap && (h.envMap.mapping === 306 || h.envMap.mapping === 307),
        lightMap: !!h.lightMap,
        aoMap: !!h.aoMap,
        emissiveMap: !!h.emissiveMap,
        emissiveMapEncoding: n(h.emissiveMap, t.gammaInput),
        bumpMap: !!h.bumpMap,
        normalMap: !!h.normalMap,
        objectSpaceNormalMap: h.normalMapType === 1,
        displacementMap: !!h.displacementMap,
        roughnessMap: !!h.roughnessMap,
        metalnessMap: !!h.metalnessMap,
        specularMap: !!h.specularMap,
        alphaMap: !!h.alphaMap,
        gradientMap: !!h.gradientMap,
        combine: h.combine,
        vertexColors: h.vertexColors,
        fog: !!v,
        useFog: h.fog,
        fogExp: v && v.isFogExp2,
        flatShading: h.flatShading,
        sizeAttenuation: h.sizeAttenuation,
        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
        skinning: h.skinning && 0 < j,
        maxBones: j,
        useVertexTexture: i.floatVertexTextures,
        morphTargets: h.morphTargets,
        morphNormals: h.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: c.directional.length,
        numPointLights: c.point.length,
        numSpotLights: c.spot.length,
        numRectAreaLights: c.rectArea.length,
        numHemiLights: c.hemi.length,
        numClippingPlanes: y,
        numClipIntersection: S,
        dithering: h.dithering,
        shadowMapEnabled: t.shadowMap.enabled && P.receiveShadow && 0 < f.length,
        shadowMapType: t.shadowMap.type,
        toneMapping: t.toneMapping,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: h.premultipliedAlpha,
        alphaTest: h.alphaTest,
        doubleSided: h.side === 2,
        flipSided: h.side === 1,
        depthPacking: h.depthPacking !== void 0 ? h.depthPacking : !1
      };
    }, this.getProgramCode = function(h, c) {
      var f = [];
      if (c.shaderID ? f.push(c.shaderID) : (f.push(h.fragmentShader), f.push(h.vertexShader)), h.defines !== void 0)
        for (var v in h.defines)
          f.push(v), f.push(h.defines[v]);
      for (v = 0; v < l.length; v++)
        f.push(c[l[v]]);
      return f.push(h.onBeforeCompile.toString()), f.push(t.gammaOutput), f.push(t.gammaFactor), f.join();
    }, this.acquireProgram = function(h, c, f, v) {
      for (var y, S = 0, P = o.length; S < P; S++) {
        var N = o[S];
        if (N.code === v) {
          y = N, ++y.usedTimes;
          break;
        }
      }
      return y === void 0 && (y = new Z(t, e, v, h, c, f, i), o.push(y)), y;
    }, this.releaseProgram = function(h) {
      if (--h.usedTimes === 0) {
        var c = o.indexOf(h);
        o[c] = o[o.length - 1], o.pop(), h.destroy();
      }
    }, this.programs = o;
  }
  function rt() {
    var t = /* @__PURE__ */ new WeakMap();
    return {
      get: function(e) {
        var i = t.get(e);
        return i === void 0 && (i = {}, t.set(e, i)), i;
      },
      remove: function(e) {
        t.delete(e);
      },
      update: function(e, i, n) {
        t.get(e)[i] = n;
      },
      dispose: function() {
        t = /* @__PURE__ */ new WeakMap();
      }
    };
  }
  function I(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
  }
  function Mt(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
  }
  function st() {
    var t = [], e = 0, i = [], n = [];
    return {
      opaque: i,
      transparent: n,
      init: function() {
        e = 0, i.length = 0, n.length = 0;
      },
      push: function(o, s, l, h, c) {
        var f = t[e];
        f === void 0 ? (f = {
          id: o.id,
          object: o,
          geometry: s,
          material: l,
          program: l.program,
          renderOrder: o.renderOrder,
          z: h,
          group: c
        }, t[e] = f) : (f.id = o.id, f.object = o, f.geometry = s, f.material = l, f.program = l.program, f.renderOrder = o.renderOrder, f.z = h, f.group = c), (l.transparent === !0 ? n : i).push(f), e++;
      },
      sort: function() {
        1 < i.length && i.sort(I), 1 < n.length && n.sort(Mt);
      }
    };
  }
  function Pt() {
    var t = {};
    return {
      get: function(e, i) {
        return e = e.id + "," + i.id, i = t[e], i === void 0 && (i = new st(), t[e] = i), i;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function Ht() {
    var t = {};
    return {
      get: function(e) {
        if (t[e.id] !== void 0)
          return t[e.id];
        switch (e.type) {
          case "DirectionalLight":
            var i = {
              direction: new m(),
              color: new A(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new p()
            };
            break;
          case "SpotLight":
            i = {
              position: new m(),
              direction: new m(),
              color: new A(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new p()
            };
            break;
          case "PointLight":
            i = {
              position: new m(),
              color: new A(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new p(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case "HemisphereLight":
            i = { direction: new m(), skyColor: new A(), groundColor: new A() };
            break;
          case "RectAreaLight":
            i = {
              color: new A(),
              position: new m(),
              halfWidth: new m(),
              halfHeight: new m()
            };
        }
        return t[e.id] = i;
      }
    };
  }
  function Ot() {
    var t = new Ht(), e = {
      id: ml++,
      hash: {
        stateID: -1,
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        shadowsLength: -1
      },
      ambient: [0, 0, 0],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    }, i = new m(), n = new $(), o = new $();
    return {
      setup: function(s, l, h) {
        var c = 0, f = 0, v = 0, y = 0, S = 0, P = 0, N = 0, j = 0;
        h = h.matrixWorldInverse;
        for (var et = 0, _t = s.length; et < _t; et++) {
          var mt = s[et], bt = mt.color, xt = mt.intensity, Wt = mt.distance, W = mt.shadow && mt.shadow.map ? mt.shadow.map.texture : null;
          if (mt.isAmbientLight)
            c += bt.r * xt, f += bt.g * xt, v += bt.b * xt;
          else if (mt.isDirectionalLight) {
            var it = t.get(mt);
            it.color.copy(mt.color).multiplyScalar(mt.intensity), it.direction.setFromMatrixPosition(mt.matrixWorld), i.setFromMatrixPosition(mt.target.matrixWorld), it.direction.sub(i), it.direction.transformDirection(h), (it.shadow = mt.castShadow) && (bt = mt.shadow, it.shadowBias = bt.bias, it.shadowRadius = bt.radius, it.shadowMapSize = bt.mapSize), e.directionalShadowMap[y] = W, e.directionalShadowMatrix[y] = mt.shadow.matrix, e.directional[y] = it, y++;
          } else
            mt.isSpotLight ? (it = t.get(mt), it.position.setFromMatrixPosition(mt.matrixWorld), it.position.applyMatrix4(h), it.color.copy(bt).multiplyScalar(xt), it.distance = Wt, it.direction.setFromMatrixPosition(mt.matrixWorld), i.setFromMatrixPosition(mt.target.matrixWorld), it.direction.sub(i), it.direction.transformDirection(h), it.coneCos = Math.cos(mt.angle), it.penumbraCos = Math.cos(mt.angle * (1 - mt.penumbra)), it.decay = mt.decay, (it.shadow = mt.castShadow) && (bt = mt.shadow, it.shadowBias = bt.bias, it.shadowRadius = bt.radius, it.shadowMapSize = bt.mapSize), e.spotShadowMap[P] = W, e.spotShadowMatrix[P] = mt.shadow.matrix, e.spot[P] = it, P++) : mt.isRectAreaLight ? (it = t.get(mt), it.color.copy(bt).multiplyScalar(xt), it.position.setFromMatrixPosition(mt.matrixWorld), it.position.applyMatrix4(h), o.identity(), n.copy(mt.matrixWorld), n.premultiply(h), o.extractRotation(n), it.halfWidth.set(0.5 * mt.width, 0, 0), it.halfHeight.set(0, 0.5 * mt.height, 0), it.halfWidth.applyMatrix4(o), it.halfHeight.applyMatrix4(o), e.rectArea[N] = it, N++) : mt.isPointLight ? (it = t.get(mt), it.position.setFromMatrixPosition(mt.matrixWorld), it.position.applyMatrix4(h), it.color.copy(mt.color).multiplyScalar(mt.intensity), it.distance = mt.distance, it.decay = mt.decay, (it.shadow = mt.castShadow) && (bt = mt.shadow, it.shadowBias = bt.bias, it.shadowRadius = bt.radius, it.shadowMapSize = bt.mapSize, it.shadowCameraNear = bt.camera.near, it.shadowCameraFar = bt.camera.far), e.pointShadowMap[S] = W, e.pointShadowMatrix[S] = mt.shadow.matrix, e.point[S] = it, S++) : mt.isHemisphereLight && (it = t.get(mt), it.direction.setFromMatrixPosition(mt.matrixWorld), it.direction.transformDirection(h), it.direction.normalize(), it.skyColor.copy(mt.color).multiplyScalar(xt), it.groundColor.copy(mt.groundColor).multiplyScalar(xt), e.hemi[j] = it, j++);
        }
        e.ambient[0] = c, e.ambient[1] = f, e.ambient[2] = v, e.directional.length = y, e.spot.length = P, e.rectArea.length = N, e.point.length = S, e.hemi.length = j, e.hash.stateID = e.id, e.hash.directionalLength = y, e.hash.pointLength = S, e.hash.spotLength = P, e.hash.rectAreaLength = N, e.hash.hemiLength = j, e.hash.shadowsLength = l.length;
      },
      state: e
    };
  }
  function Tt() {
    var t = new Ot(), e = [], i = [];
    return {
      init: function() {
        e.length = 0, i.length = 0;
      },
      state: { lightsArray: e, shadowsArray: i, lights: t },
      setupLights: function(n) {
        t.setup(e, i, n);
      },
      pushLight: function(n) {
        e.push(n);
      },
      pushShadow: function(n) {
        i.push(n);
      }
    };
  }
  function le() {
    var t = {};
    return {
      get: function(e, i) {
        if (t[e.id] === void 0) {
          var n = new Tt();
          t[e.id] = {}, t[e.id][i.id] = n;
        } else
          t[e.id][i.id] === void 0 ? (n = new Tt(), t[e.id][i.id] = n) : n = t[e.id][i.id];
        return n;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function oe(t) {
    Zt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t);
  }
  function te(t) {
    Zt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new m(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t);
  }
  function ve(t, e, i) {
    function n(W, it, It, ee, $t, qt) {
      var Te = W.geometry, pe = y, Oe = W.customDepthMaterial;
      return It && (pe = S, Oe = W.customDistanceMaterial), Oe ? pe = Oe : (Oe = !1, it.morphTargets && (Te && Te.isBufferGeometry ? Oe = Te.morphAttributes && Te.morphAttributes.position && 0 < Te.morphAttributes.position.length : Te && Te.isGeometry && (Oe = Te.morphTargets && 0 < Te.morphTargets.length)), W.isSkinnedMesh && it.skinning === !1 && console.warn(
        "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
        W
      ), W = W.isSkinnedMesh && it.skinning, Te = 0, Oe && (Te |= 1), W && (Te |= 2), pe = pe[Te]), t.localClippingEnabled && it.clipShadows === !0 && it.clippingPlanes.length !== 0 && (Te = pe.uuid, Oe = it.uuid, W = P[Te], W === void 0 && (W = {}, P[Te] = W), Te = W[Oe], Te === void 0 && (Te = pe.clone(), W[Oe] = Te), pe = Te), pe.visible = it.visible, pe.wireframe = it.wireframe, pe.side = it.shadowSide != null ? it.shadowSide : N[it.side], pe.clipShadows = it.clipShadows, pe.clippingPlanes = it.clippingPlanes, pe.clipIntersection = it.clipIntersection, pe.wireframeLinewidth = it.wireframeLinewidth, pe.linewidth = it.linewidth, It && pe.isMeshDistanceMaterial && (pe.referencePosition.copy(ee), pe.nearDistance = $t, pe.farDistance = qt), pe;
    }
    function o(W, it, It, ee) {
      if (W.visible !== !1) {
        if (W.layers.test(it.layers) && (W.isMesh || W.isLine || W.isPoints) && W.castShadow && (!W.frustumCulled || s.intersectsObject(W))) {
          W.modelViewMatrix.multiplyMatrices(
            It.matrixWorldInverse,
            W.matrixWorld
          );
          var $t = e.update(W), qt = W.material;
          if (Array.isArray(qt))
            for (var Te = $t.groups, pe = 0, Oe = Te.length; pe < Oe; pe++) {
              var be = Te[pe], se = qt[be.materialIndex];
              se && se.visible && (se = n(W, se, ee, v, It.near, It.far), t.renderBufferDirect(It, null, $t, se, W, be));
            }
          else
            qt.visible && (se = n(W, qt, ee, v, It.near, It.far), t.renderBufferDirect(It, null, $t, se, W, null));
        }
        for (W = W.children, $t = 0, qt = W.length; $t < qt; $t++)
          o(W[$t], it, It, ee);
      }
    }
    var s = new b(), l = new $(), h = new p(), c = new p(i, i), f = new m(), v = new m(), y = Array(4), S = Array(4), P = {}, N = { 0: 1, 1: 0, 2: 2 }, j = [
      new m(1, 0, 0),
      new m(-1, 0, 0),
      new m(0, 0, 1),
      new m(0, 0, -1),
      new m(0, 1, 0),
      new m(0, -1, 0)
    ], et = [
      new m(0, 1, 0),
      new m(0, 1, 0),
      new m(0, 1, 0),
      new m(0, 1, 0),
      new m(0, 0, 1),
      new m(0, 0, -1)
    ], _t = [new E(), new E(), new E(), new E(), new E(), new E()];
    for (i = 0; i !== 4; ++i) {
      var mt = (i & 1) !== 0, bt = (i & 2) !== 0, xt = new oe({ depthPacking: 3201, morphTargets: mt, skinning: bt });
      y[i] = xt, mt = new te({ morphTargets: mt, skinning: bt }), S[i] = mt;
    }
    var Wt = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(W, it, It) {
      if (Wt.enabled !== !1 && (Wt.autoUpdate !== !1 || Wt.needsUpdate !== !1) && W.length !== 0) {
        var ee = t.state;
        ee.disable(3042), ee.buffers.color.setClear(1, 1, 1, 1), ee.buffers.depth.setTest(!0), ee.setScissorTest(!1);
        for (var $t, qt = 0, Te = W.length; qt < Te; qt++) {
          var pe = W[qt];
          $t = pe.shadow;
          var Oe = pe && pe.isPointLight;
          if ($t === void 0)
            console.warn("THREE.WebGLShadowMap:", pe, "has no shadow.");
          else {
            var be = $t.camera;
            if (h.copy($t.mapSize), h.min(c), Oe) {
              var se = h.x, je = h.y;
              _t[0].set(2 * se, je, se, je), _t[1].set(0, je, se, je), _t[2].set(3 * se, je, se, je), _t[3].set(se, je, se, je), _t[4].set(3 * se, 0, se, je), _t[5].set(se, 0, se, je), h.x *= 4, h.y *= 2;
            }
            for ($t.map === null && ($t.map = new U(h.x, h.y, {
              minFilter: 1003,
              magFilter: 1003,
              format: 1023
            }), $t.map.texture.name = pe.name + ".shadowMap", be.updateProjectionMatrix()), $t.isSpotLightShadow && $t.update(pe), se = $t.map, je = $t.matrix, v.setFromMatrixPosition(pe.matrixWorld), be.position.copy(v), Oe ? ($t = 6, je.makeTranslation(-v.x, -v.y, -v.z)) : ($t = 1, f.setFromMatrixPosition(pe.target.matrixWorld), be.lookAt(f), be.updateMatrixWorld(), je.set(
              0.5,
              0,
              0,
              0.5,
              0,
              0.5,
              0,
              0.5,
              0,
              0,
              0.5,
              0.5,
              0,
              0,
              0,
              1
            ), je.multiply(be.projectionMatrix), je.multiply(be.matrixWorldInverse)), t.setRenderTarget(se), t.clear(), pe = 0; pe < $t; pe++)
              Oe && (f.copy(be.position), f.add(j[pe]), be.up.copy(et[pe]), be.lookAt(f), be.updateMatrixWorld(), ee.viewport(_t[pe])), l.multiplyMatrices(be.projectionMatrix, be.matrixWorldInverse), s.setFromMatrix(l), o(it, It, be, Oe);
          }
        }
        Wt.needsUpdate = !1;
      }
    };
  }
  function he(t, e, i, n) {
    function o(Ut, Ye, ei) {
      var Gi = new Uint8Array(4), Ce = t.createTexture();
      for (t.bindTexture(Ut, Ce), t.texParameteri(Ut, 10241, 9728), t.texParameteri(Ut, 10240, 9728), Ut = 0; Ut < ei; Ut++)
        t.texImage2D(Ye + Ut, 0, 6408, 1, 1, 0, 6408, 5121, Gi);
      return Ce;
    }
    function s(Ut, Ye) {
      _t[Ut] = 1, mt[Ut] === 0 && (t.enableVertexAttribArray(Ut), mt[Ut] = 1), bt[Ut] !== Ye && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](Ut, Ye), bt[Ut] = Ye);
    }
    function l(Ut) {
      xt[Ut] !== !0 && (t.enable(Ut), xt[Ut] = !0);
    }
    function h(Ut) {
      xt[Ut] !== !1 && (t.disable(Ut), xt[Ut] = !1);
    }
    function c(Ut, Ye, ei, Gi, Ce, Xe, ri, Ai) {
      if (Ut === 0)
        it && (h(3042), it = !1);
      else if (it || (l(3042), it = !0), Ut !== 5) {
        if (Ut !== It || Ai !== be) {
          if ((ee !== 100 || Te !== 100) && (t.blendEquation(32774), Te = ee = 100), Ai)
            switch (Ut) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Ut);
            }
          else
            switch (Ut) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Ut);
            }
          Oe = pe = qt = $t = null, It = Ut, be = Ai;
        }
      } else
        Ce = Ce || Ye, Xe = Xe || ei, ri = ri || Gi, (Ye !== ee || Ce !== Te) && (t.blendEquationSeparate(i.convert(Ye), i.convert(Ce)), ee = Ye, Te = Ce), (ei !== $t || Gi !== qt || Xe !== pe || ri !== Oe) && (t.blendFuncSeparate(
          i.convert(ei),
          i.convert(Gi),
          i.convert(Xe),
          i.convert(ri)
        ), $t = ei, qt = Gi, pe = Xe, Oe = ri), It = Ut, be = null;
    }
    function f(Ut) {
      se !== Ut && (Ut ? t.frontFace(2304) : t.frontFace(2305), se = Ut);
    }
    function v(Ut) {
      Ut !== 0 ? (l(2884), Ut !== je && (Ut === 1 ? t.cullFace(1029) : Ut === 2 ? t.cullFace(1028) : t.cullFace(1032))) : h(2884), je = Ut;
    }
    function y(Ut, Ye, ei) {
      Ut ? (l(32823), (ci !== Ye || yn !== ei) && (t.polygonOffset(Ye, ei), ci = Ye, yn = ei)) : h(32823);
    }
    function S(Ut) {
      Ut === void 0 && (Ut = 33984 + cn - 1), Fi !== Ut && (t.activeTexture(Ut), Fi = Ut);
    }
    var P = new function() {
      var Ut = !1, Ye = new E(), ei = null, Gi = new E(0, 0, 0, 0);
      return {
        setMask: function(Ce) {
          ei === Ce || Ut || (t.colorMask(Ce, Ce, Ce, Ce), ei = Ce);
        },
        setLocked: function(Ce) {
          Ut = Ce;
        },
        setClear: function(Ce, Xe, ri, Ai, bi) {
          bi === !0 && (Ce *= Ai, Xe *= Ai, ri *= Ai), Ye.set(Ce, Xe, ri, Ai), Gi.equals(Ye) === !1 && (t.clearColor(Ce, Xe, ri, Ai), Gi.copy(Ye));
        },
        reset: function() {
          Ut = !1, ei = null, Gi.set(-1, 0, 0, 0);
        }
      };
    }(), N = new function() {
      var Ut = !1, Ye = null, ei = null, Gi = null;
      return {
        setTest: function(Ce) {
          Ce ? l(2929) : h(2929);
        },
        setMask: function(Ce) {
          Ye === Ce || Ut || (t.depthMask(Ce), Ye = Ce);
        },
        setFunc: function(Ce) {
          if (ei !== Ce) {
            if (Ce)
              switch (Ce) {
                case 0:
                  t.depthFunc(512);
                  break;
                case 1:
                  t.depthFunc(519);
                  break;
                case 2:
                  t.depthFunc(513);
                  break;
                case 3:
                  t.depthFunc(515);
                  break;
                case 4:
                  t.depthFunc(514);
                  break;
                case 5:
                  t.depthFunc(518);
                  break;
                case 6:
                  t.depthFunc(516);
                  break;
                case 7:
                  t.depthFunc(517);
                  break;
                default:
                  t.depthFunc(515);
              }
            else
              t.depthFunc(515);
            ei = Ce;
          }
        },
        setLocked: function(Ce) {
          Ut = Ce;
        },
        setClear: function(Ce) {
          Gi !== Ce && (t.clearDepth(Ce), Gi = Ce);
        },
        reset: function() {
          Ut = !1, Gi = ei = Ye = null;
        }
      };
    }(), j = new function() {
      var Ut = !1, Ye = null, ei = null, Gi = null, Ce = null, Xe = null, ri = null, Ai = null, bi = null;
      return {
        setTest: function(ne) {
          ne ? l(2960) : h(2960);
        },
        setMask: function(ne) {
          Ye === ne || Ut || (t.stencilMask(ne), Ye = ne);
        },
        setFunc: function(ne, ii, Ze) {
          (ei !== ne || Gi !== ii || Ce !== Ze) && (t.stencilFunc(ne, ii, Ze), ei = ne, Gi = ii, Ce = Ze);
        },
        setOp: function(ne, ii, Ze) {
          (Xe !== ne || ri !== ii || Ai !== Ze) && (t.stencilOp(ne, ii, Ze), Xe = ne, ri = ii, Ai = Ze);
        },
        setLocked: function(ne) {
          Ut = ne;
        },
        setClear: function(ne) {
          bi !== ne && (t.clearStencil(ne), bi = ne);
        },
        reset: function() {
          Ut = !1, bi = Ai = ri = Xe = Ce = Gi = ei = Ye = null;
        }
      };
    }(), et = t.getParameter(34921), _t = new Uint8Array(et), mt = new Uint8Array(et), bt = new Uint8Array(et), xt = {}, Wt = null, W = null, it = null, It = null, ee = null, $t = null, qt = null, Te = null, pe = null, Oe = null, be = !1, se = null, je = null, Ke = null, ci = null, yn = null, cn = t.getParameter(35661), ji = !1;
    et = 0, et = t.getParameter(7938), et.indexOf("WebGL") !== -1 ? (et = parseFloat(/^WebGL ([0-9])/.exec(et)[1]), ji = 1 <= et) : et.indexOf("OpenGL ES") !== -1 && (et = parseFloat(/^OpenGL ES ([0-9])/.exec(et)[1]), ji = 2 <= et);
    var Fi = null, Qi = {}, _n = new E(), Ae = new E(), Qe = {};
    return Qe[3553] = o(3553, 3553, 1), Qe[34067] = o(34067, 34069, 6), P.setClear(0, 0, 0, 1), N.setClear(1), j.setClear(0), l(2929), N.setFunc(3), f(!1), v(1), l(2884), c(0), {
      buffers: { color: P, depth: N, stencil: j },
      initAttributes: function() {
        for (var Ut = 0, Ye = _t.length; Ut < Ye; Ut++)
          _t[Ut] = 0;
      },
      enableAttribute: function(Ut) {
        s(Ut, 0);
      },
      enableAttributeAndDivisor: s,
      disableUnusedAttributes: function() {
        for (var Ut = 0, Ye = mt.length; Ut !== Ye; ++Ut)
          mt[Ut] !== _t[Ut] && (t.disableVertexAttribArray(Ut), mt[Ut] = 0);
      },
      enable: l,
      disable: h,
      getCompressedTextureFormats: function() {
        if (Wt === null && (Wt = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
          for (var Ut = t.getParameter(34467), Ye = 0; Ye < Ut.length; Ye++)
            Wt.push(Ut[Ye]);
        return Wt;
      },
      useProgram: function(Ut) {
        return W !== Ut ? (t.useProgram(Ut), W = Ut, !0) : !1;
      },
      setBlending: c,
      setMaterial: function(Ut, Ye) {
        Ut.side === 2 ? h(2884) : l(2884);
        var ei = Ut.side === 1;
        Ye && (ei = !ei), f(ei), Ut.blending === 1 && Ut.transparent === !1 ? c(0) : c(
          Ut.blending,
          Ut.blendEquation,
          Ut.blendSrc,
          Ut.blendDst,
          Ut.blendEquationAlpha,
          Ut.blendSrcAlpha,
          Ut.blendDstAlpha,
          Ut.premultipliedAlpha
        ), N.setFunc(Ut.depthFunc), N.setTest(Ut.depthTest), N.setMask(Ut.depthWrite), P.setMask(Ut.colorWrite), y(Ut.polygonOffset, Ut.polygonOffsetFactor, Ut.polygonOffsetUnits);
      },
      setFlipSided: f,
      setCullFace: v,
      setLineWidth: function(Ut) {
        Ut !== Ke && (ji && t.lineWidth(Ut), Ke = Ut);
      },
      setPolygonOffset: y,
      setScissorTest: function(Ut) {
        Ut ? l(3089) : h(3089);
      },
      activeTexture: S,
      bindTexture: function(Ut, Ye) {
        Fi === null && S();
        var ei = Qi[Fi];
        ei === void 0 && (ei = { type: void 0, texture: void 0 }, Qi[Fi] = ei), (ei.type !== Ut || ei.texture !== Ye) && (t.bindTexture(Ut, Ye || Qe[Ut]), ei.type = Ut, ei.texture = Ye);
      },
      compressedTexImage2D: function() {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      texImage2D: function() {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      texImage3D: function() {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (Ut) {
          console.error("THREE.WebGLState:", Ut);
        }
      },
      scissor: function(Ut) {
        _n.equals(Ut) === !1 && (t.scissor(Ut.x, Ut.y, Ut.z, Ut.w), _n.copy(Ut));
      },
      viewport: function(Ut) {
        Ae.equals(Ut) === !1 && (t.viewport(Ut.x, Ut.y, Ut.z, Ut.w), Ae.copy(Ut));
      },
      reset: function() {
        for (var Ut = 0; Ut < mt.length; Ut++)
          mt[Ut] === 1 && (t.disableVertexAttribArray(Ut), mt[Ut] = 0);
        xt = {}, Fi = Wt = null, Qi = {}, je = se = It = W = null, P.reset(), N.reset(), j.reset();
      }
    };
  }
  function Ve(t, e, i, n, o, s, l) {
    function h(W, it) {
      if (W.width > it || W.height > it) {
        if ("data" in W) {
          console.warn(
            "THREE.WebGLRenderer: image in DataTexture is too big (" + W.width + "x" + W.height + ")."
          );
          return;
        }
        it /= Math.max(W.width, W.height);
        var It = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return It.width = Math.floor(W.width * it), It.height = Math.floor(W.height * it), It.getContext("2d").drawImage(
          W,
          0,
          0,
          W.width,
          W.height,
          0,
          0,
          It.width,
          It.height
        ), console.warn(
          "THREE.WebGLRenderer: image is too big (" + W.width + "x" + W.height + "). Resized to " + It.width + "x" + It.height
        ), It;
      }
      return W;
    }
    function c(W) {
      return fi.isPowerOfTwo(W.width) && fi.isPowerOfTwo(W.height);
    }
    function f(W, it) {
      return W.generateMipmaps && it && W.minFilter !== 1003 && W.minFilter !== 1006;
    }
    function v(W, it, It, ee) {
      t.generateMipmap(W), n.get(it).__maxMipLevel = Math.log(Math.max(It, ee)) * Math.LOG2E;
    }
    function y(W, it) {
      if (!o.isWebGL2)
        return W;
      if (W === 6403) {
        if (it === 5126)
          return 33326;
        if (it === 5131)
          return 33325;
        if (it === 5121)
          return 33321;
      }
      if (W === 6407) {
        if (it === 5126)
          return 34837;
        if (it === 5131)
          return 34843;
        if (it === 5121)
          return 32849;
      }
      if (W === 6408) {
        if (it === 5126)
          return 34836;
        if (it === 5131)
          return 34842;
        if (it === 5121)
          return 32856;
      }
      return W;
    }
    function S(W) {
      return W === 1003 || W === 1004 || W === 1005 ? 9728 : 9729;
    }
    function P(W) {
      W = W.target, W.removeEventListener("dispose", P);
      t: {
        var it = n.get(W);
        if (W.image && it.__image__webglTextureCube)
          t.deleteTexture(it.__image__webglTextureCube);
        else {
          if (it.__webglInit === void 0)
            break t;
          t.deleteTexture(it.__webglTexture);
        }
        n.remove(W);
      }
      W.isVideoTexture && delete xt[W.id], l.memory.textures--;
    }
    function N(W) {
      W = W.target, W.removeEventListener("dispose", N);
      var it = n.get(W), It = n.get(W.texture);
      if (W) {
        if (It.__webglTexture !== void 0 && t.deleteTexture(It.__webglTexture), W.depthTexture && W.depthTexture.dispose(), W.isWebGLRenderTargetCube)
          for (It = 0; 6 > It; It++)
            t.deleteFramebuffer(it.__webglFramebuffer[It]), it.__webglDepthbuffer && t.deleteRenderbuffer(it.__webglDepthbuffer[It]);
        else
          t.deleteFramebuffer(it.__webglFramebuffer), it.__webglDepthbuffer && t.deleteRenderbuffer(it.__webglDepthbuffer);
        n.remove(W.texture), n.remove(W);
      }
      l.memory.textures--;
    }
    function j(W, it) {
      var It = n.get(W);
      if (W.isVideoTexture) {
        var ee = W.id, $t = l.render.frame;
        xt[ee] !== $t && (xt[ee] = $t, W.update());
      }
      if (0 < W.version && It.__version !== W.version)
        if (ee = W.image, ee === void 0)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined"
          );
        else if (ee.complete === !1)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        else {
          _t(It, W, it);
          return;
        }
      i.activeTexture(33984 + it), i.bindTexture(3553, It.__webglTexture);
    }
    function et(W, it, It) {
      It ? (t.texParameteri(W, 10242, s.convert(it.wrapS)), t.texParameteri(W, 10243, s.convert(it.wrapT)), t.texParameteri(W, 10240, s.convert(it.magFilter)), t.texParameteri(W, 10241, s.convert(it.minFilter))) : (t.texParameteri(W, 10242, 33071), t.texParameteri(W, 10243, 33071), it.wrapS === 1001 && it.wrapT === 1001 || console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
      ), t.texParameteri(W, 10240, S(it.magFilter)), t.texParameteri(W, 10241, S(it.minFilter)), it.minFilter !== 1003 && it.minFilter !== 1006 && console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
      )), !(It = e.get("EXT_texture_filter_anisotropic")) || it.type === 1015 && e.get("OES_texture_float_linear") === null || it.type === 1016 && (o.isWebGL2 || e.get("OES_texture_half_float_linear")) === null || !(1 < it.anisotropy || n.get(it).__currentAnisotropy) || (t.texParameterf(
        W,
        It.TEXTURE_MAX_ANISOTROPY_EXT,
        Math.min(it.anisotropy, o.getMaxAnisotropy())
      ), n.get(it).__currentAnisotropy = it.anisotropy);
    }
    function _t(W, it, It) {
      var ee = it.isDataTexture3D ? 32879 : 3553;
      W.__webglInit === void 0 && (W.__webglInit = !0, it.addEventListener("dispose", P), W.__webglTexture = t.createTexture(), l.memory.textures++), i.activeTexture(33984 + It), i.bindTexture(ee, W.__webglTexture), t.pixelStorei(37440, it.flipY), t.pixelStorei(37441, it.premultiplyAlpha), t.pixelStorei(3317, it.unpackAlignment), It = h(it.image, o.maxTextureSize);
      var $t = o.isWebGL2 ? !1 : it.wrapS !== 1001 || it.wrapT !== 1001 || it.minFilter !== 1003 && it.minFilter !== 1006;
      $t && c(It) === !1 && (It instanceof HTMLImageElement || It instanceof HTMLCanvasElement || It instanceof ImageBitmap) && (Wt === void 0 && (Wt = document.createElementNS(
        "http://www.w3.org/1999/xhtml",
        "canvas"
      )), Wt.width = fi.floorPowerOfTwo(It.width), Wt.height = fi.floorPowerOfTwo(It.height), Wt.getContext("2d").drawImage(It, 0, 0, Wt.width, Wt.height), console.warn(
        "THREE.WebGLRenderer: image is not power of two (" + It.width + "x" + It.height + "). Resized to " + Wt.width + "x" + Wt.height
      ), It = Wt), $t = c(It);
      var qt = s.convert(it.format), Te = s.convert(it.type), pe = y(qt, Te);
      et(ee, it, $t);
      var Oe = it.mipmaps;
      if (it.isDepthTexture) {
        if (pe = 6402, it.type === 1015) {
          if (!o.isWebGL2)
            throw Error("Float Depth Texture only supported in WebGL2.0");
          pe = 36012;
        } else
          o.isWebGL2 && (pe = 33189);
        it.format === 1026 && pe === 6402 && it.type !== 1012 && it.type !== 1014 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
        ), it.type = 1012, Te = s.convert(it.type)), it.format === 1027 && (pe = 34041, it.type !== 1020 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
        ), it.type = 1020, Te = s.convert(it.type))), i.texImage2D(3553, 0, pe, It.width, It.height, 0, qt, Te, null);
      } else if (it.isDataTexture)
        if (0 < Oe.length && $t) {
          for (var be = 0, se = Oe.length; be < se; be++)
            ee = Oe[be], i.texImage2D(3553, be, pe, ee.width, ee.height, 0, qt, Te, ee.data);
          it.generateMipmaps = !1, W.__maxMipLevel = Oe.length - 1;
        } else
          i.texImage2D(3553, 0, pe, It.width, It.height, 0, qt, Te, It.data), W.__maxMipLevel = 0;
      else if (it.isCompressedTexture) {
        for (be = 0, se = Oe.length; be < se; be++)
          ee = Oe[be], it.format !== 1023 && it.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(qt) ? i.compressedTexImage2D(
            3553,
            be,
            pe,
            ee.width,
            ee.height,
            0,
            ee.data
          ) : console.warn(
            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
          ) : i.texImage2D(3553, be, pe, ee.width, ee.height, 0, qt, Te, ee.data);
        W.__maxMipLevel = Oe.length - 1;
      } else if (it.isDataTexture3D)
        i.texImage3D(32879, 0, pe, It.width, It.height, It.depth, 0, qt, Te, It.data), W.__maxMipLevel = 0;
      else if (0 < Oe.length && $t) {
        for (be = 0, se = Oe.length; be < se; be++)
          ee = Oe[be], i.texImage2D(3553, be, pe, qt, Te, ee);
        it.generateMipmaps = !1, W.__maxMipLevel = Oe.length - 1;
      } else
        i.texImage2D(3553, 0, pe, qt, Te, It), W.__maxMipLevel = 0;
      f(it, $t) && v(3553, it, It.width, It.height), W.__version = it.version, it.onUpdate && it.onUpdate(it);
    }
    function mt(W, it, It, ee) {
      var $t = s.convert(it.texture.format), qt = s.convert(it.texture.type), Te = y($t, qt);
      i.texImage2D(ee, 0, Te, it.width, it.height, 0, $t, qt, null), t.bindFramebuffer(36160, W), t.framebufferTexture2D(36160, It, ee, n.get(it.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }
    function bt(W, it) {
      t.bindRenderbuffer(36161, W), it.depthBuffer && !it.stencilBuffer ? (t.renderbufferStorage(36161, 33189, it.width, it.height), t.framebufferRenderbuffer(36160, 36096, 36161, W)) : it.depthBuffer && it.stencilBuffer ? (t.renderbufferStorage(36161, 34041, it.width, it.height), t.framebufferRenderbuffer(36160, 33306, 36161, W)) : t.renderbufferStorage(36161, 32854, it.width, it.height), t.bindRenderbuffer(36161, null);
    }
    var xt = {}, Wt;
    this.setTexture2D = j, this.setTexture3D = function(W, it) {
      var It = n.get(W);
      0 < W.version && It.__version !== W.version ? _t(It, W, it) : (i.activeTexture(33984 + it), i.bindTexture(32879, It.__webglTexture));
    }, this.setTextureCube = function(W, it) {
      var It = n.get(W);
      if (W.image.length === 6)
        if (0 < W.version && It.__version !== W.version) {
          It.__image__webglTextureCube || (W.addEventListener("dispose", P), It.__image__webglTextureCube = t.createTexture(), l.memory.textures++), i.activeTexture(33984 + it), i.bindTexture(34067, It.__image__webglTextureCube), t.pixelStorei(37440, W.flipY), it = W && W.isCompressedTexture;
          for (var ee = W.image[0] && W.image[0].isDataTexture, $t = [], qt = 0; 6 > qt; qt++)
            $t[qt] = it || ee ? ee ? W.image[qt].image : W.image[qt] : h(W.image[qt], o.maxCubemapSize);
          var Te = $t[0], pe = c(Te), Oe = s.convert(W.format), be = s.convert(W.type), se = y(Oe, be);
          for (et(34067, W, pe), qt = 0; 6 > qt; qt++)
            if (it)
              for (var je, Ke = $t[qt].mipmaps, ci = 0, yn = Ke.length; ci < yn; ci++)
                je = Ke[ci], W.format !== 1023 && W.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(Oe) ? i.compressedTexImage2D(
                  34069 + qt,
                  ci,
                  se,
                  je.width,
                  je.height,
                  0,
                  je.data
                ) : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                ) : i.texImage2D(
                  34069 + qt,
                  ci,
                  se,
                  je.width,
                  je.height,
                  0,
                  Oe,
                  be,
                  je.data
                );
            else
              ee ? i.texImage2D(
                34069 + qt,
                0,
                se,
                $t[qt].width,
                $t[qt].height,
                0,
                Oe,
                be,
                $t[qt].data
              ) : i.texImage2D(34069 + qt, 0, se, Oe, be, $t[qt]);
          It.__maxMipLevel = it ? Ke.length - 1 : 0, f(W, pe) && v(34067, W, Te.width, Te.height), It.__version = W.version, W.onUpdate && W.onUpdate(W);
        } else
          i.activeTexture(33984 + it), i.bindTexture(34067, It.__image__webglTextureCube);
    }, this.setTextureCubeDynamic = function(W, it) {
      i.activeTexture(33984 + it), i.bindTexture(34067, n.get(W).__webglTexture);
    }, this.setupRenderTarget = function(W) {
      var it = n.get(W), It = n.get(W.texture);
      W.addEventListener("dispose", N), It.__webglTexture = t.createTexture(), l.memory.textures++;
      var ee = W.isWebGLRenderTargetCube === !0, $t = c(W);
      if (ee) {
        it.__webglFramebuffer = [];
        for (var qt = 0; 6 > qt; qt++)
          it.__webglFramebuffer[qt] = t.createFramebuffer();
      } else
        it.__webglFramebuffer = t.createFramebuffer();
      if (ee) {
        for (i.bindTexture(34067, It.__webglTexture), et(34067, W.texture, $t), qt = 0; 6 > qt; qt++)
          mt(it.__webglFramebuffer[qt], W, 36064, 34069 + qt);
        f(W.texture, $t) && v(34067, W.texture, W.width, W.height), i.bindTexture(34067, null);
      } else
        i.bindTexture(3553, It.__webglTexture), et(3553, W.texture, $t), mt(it.__webglFramebuffer, W, 36064, 3553), f(W.texture, $t) && v(3553, W.texture, W.width, W.height), i.bindTexture(3553, null);
      if (W.depthBuffer) {
        if (it = n.get(W), It = W.isWebGLRenderTargetCube === !0, W.depthTexture) {
          if (It)
            throw Error(
              "target.depthTexture not supported in Cube render targets"
            );
          if (W && W.isWebGLRenderTargetCube)
            throw Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (t.bindFramebuffer(36160, it.__webglFramebuffer), !W.depthTexture || !W.depthTexture.isDepthTexture)
            throw Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          if (n.get(W.depthTexture).__webglTexture && W.depthTexture.image.width === W.width && W.depthTexture.image.height === W.height || (W.depthTexture.image.width = W.width, W.depthTexture.image.height = W.height, W.depthTexture.needsUpdate = !0), j(W.depthTexture, 0), it = n.get(W.depthTexture).__webglTexture, W.depthTexture.format === 1026)
            t.framebufferTexture2D(36160, 36096, 3553, it, 0);
          else if (W.depthTexture.format === 1027)
            t.framebufferTexture2D(36160, 33306, 3553, it, 0);
          else
            throw Error("Unknown depthTexture format");
        } else if (It)
          for (it.__webglDepthbuffer = [], It = 0; 6 > It; It++)
            t.bindFramebuffer(36160, it.__webglFramebuffer[It]), it.__webglDepthbuffer[It] = t.createRenderbuffer(), bt(it.__webglDepthbuffer[It], W);
        else
          t.bindFramebuffer(36160, it.__webglFramebuffer), it.__webglDepthbuffer = t.createRenderbuffer(), bt(it.__webglDepthbuffer, W);
        t.bindFramebuffer(36160, null);
      }
    }, this.updateRenderTargetMipmap = function(W) {
      var it = W.texture, It = c(W);
      if (f(it, It)) {
        It = W.isWebGLRenderTargetCube ? 34067 : 3553;
        var ee = n.get(it).__webglTexture;
        i.bindTexture(It, ee), v(It, it, W.width, W.height), i.bindTexture(It, null);
      }
    };
  }
  function He(t, e, i) {
    return {
      convert: function(n) {
        if (n === 1e3)
          return 10497;
        if (n === 1001)
          return 33071;
        if (n === 1002)
          return 33648;
        if (n === 1003)
          return 9728;
        if (n === 1004)
          return 9984;
        if (n === 1005)
          return 9986;
        if (n === 1006)
          return 9729;
        if (n === 1007)
          return 9985;
        if (n === 1008)
          return 9987;
        if (n === 1009)
          return 5121;
        if (n === 1017)
          return 32819;
        if (n === 1018)
          return 32820;
        if (n === 1019)
          return 33635;
        if (n === 1010)
          return 5120;
        if (n === 1011)
          return 5122;
        if (n === 1012)
          return 5123;
        if (n === 1013)
          return 5124;
        if (n === 1014)
          return 5125;
        if (n === 1015)
          return 5126;
        if (n === 1016) {
          if (i.isWebGL2)
            return 5131;
          var o = e.get("OES_texture_half_float");
          if (o !== null)
            return o.HALF_FLOAT_OES;
        }
        if (n === 1021)
          return 6406;
        if (n === 1022)
          return 6407;
        if (n === 1023)
          return 6408;
        if (n === 1024)
          return 6409;
        if (n === 1025)
          return 6410;
        if (n === 1026)
          return 6402;
        if (n === 1027)
          return 34041;
        if (n === 1028)
          return 6403;
        if (n === 100)
          return 32774;
        if (n === 101)
          return 32778;
        if (n === 102)
          return 32779;
        if (n === 200)
          return 0;
        if (n === 201)
          return 1;
        if (n === 202)
          return 768;
        if (n === 203)
          return 769;
        if (n === 204)
          return 770;
        if (n === 205)
          return 771;
        if (n === 206)
          return 772;
        if (n === 207)
          return 773;
        if (n === 208)
          return 774;
        if (n === 209)
          return 775;
        if (n === 210)
          return 776;
        if ((n === 33776 || n === 33777 || n === 33778 || n === 33779) && (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null)) {
          if (n === 33776)
            return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (n === 33777)
            return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (n === 33778)
            return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (n === 33779)
            return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if ((n === 35840 || n === 35841 || n === 35842 || n === 35843) && (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null)) {
          if (n === 35840)
            return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (n === 35841)
            return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (n === 35842)
            return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (n === 35843)
            return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (n === 36196 && (o = e.get("WEBGL_compressed_texture_etc1"), o !== null))
          return o.COMPRESSED_RGB_ETC1_WEBGL;
        if ((n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821) && (o = e.get("WEBGL_compressed_texture_astc"), o !== null))
          return n;
        if (n === 103 || n === 104) {
          if (i.isWebGL2) {
            if (n === 103)
              return 32775;
            if (n === 104)
              return 32776;
          }
          if (o = e.get("EXT_blend_minmax"), o !== null) {
            if (n === 103)
              return o.MIN_EXT;
            if (n === 104)
              return o.MAX_EXT;
          }
        }
        if (n === 1020) {
          if (i.isWebGL2)
            return 34042;
          if (o = e.get("WEBGL_depth_texture"), o !== null)
            return o.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      }
    };
  }
  function ui() {
    z.call(this), this.type = "Group";
  }
  function Be() {
    z.call(this), this.type = "Camera", this.matrixWorldInverse = new $(), this.projectionMatrix = new $(), this.projectionMatrixInverse = new $();
  }
  function ye(t, e, i, n) {
    Be.call(this), this.type = "PerspectiveCamera", this.fov = t !== void 0 ? t : 50, this.zoom = 1, this.near = i !== void 0 ? i : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = e !== void 0 ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  function ke(t) {
    ye.call(this), this.cameras = t || [];
  }
  function ce(t, e, i) {
    bo.setFromMatrixPosition(e.matrixWorld), rr.setFromMatrixPosition(i.matrixWorld);
    var n = bo.distanceTo(rr), o = e.projectionMatrix.elements, s = i.projectionMatrix.elements, l = o[14] / (o[10] - 1);
    i = o[14] / (o[10] + 1);
    var h = (o[9] + 1) / o[5], c = (o[9] - 1) / o[5], f = (o[8] - 1) / o[0], v = (s[8] + 1) / s[0];
    o = l * f, s = l * v, v = n / (-f + v), f = v * -f, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(v), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = l + v, l = i + v, t.projectionMatrix.makePerspective(
      o - f,
      s + (n - f),
      h * i / l * e,
      c * i / l * e,
      e,
      l
    );
  }
  function di(t) {
    function e() {
      return o !== null && o.isPresenting === !0;
    }
    function i() {
      if (e()) {
        var W = o.getEyeParameters("left"), it = W.renderWidth * v;
        W = W.renderHeight * v, bt = t.getPixelRatio(), mt = t.getSize(), t.setDrawingBufferSize(2 * it, W, 1), Wt.start();
      } else
        n.enabled && t.setDrawingBufferSize(mt.width, mt.height, bt), Wt.stop();
    }
    var n = this, o = null, s = null, l = null, h = [], c = new $(), f = new $(), v = 1, y = "stage";
    typeof window < "u" && "VRFrameData" in window && (s = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", i, !1));
    var S = new $(), P = new G(), N = new m(), j = new ye();
    j.bounds = new E(0, 0, 0.5, 1), j.layers.enable(1);
    var et = new ye();
    et.bounds = new E(0.5, 0, 0.5, 1), et.layers.enable(2);
    var _t = new ke([j, et]);
    _t.layers.enable(1), _t.layers.enable(2);
    var mt, bt, xt = [];
    this.enabled = !1, this.getController = function(W) {
      var it = h[W];
      return it === void 0 && (it = new ui(), it.matrixAutoUpdate = !1, it.visible = !1, h[W] = it), it;
    }, this.getDevice = function() {
      return o;
    }, this.setDevice = function(W) {
      W !== void 0 && (o = W), Wt.setContext(W);
    }, this.setFramebufferScaleFactor = function(W) {
      v = W;
    }, this.setFrameOfReferenceType = function(W) {
      y = W;
    }, this.setPoseTarget = function(W) {
      W !== void 0 && (l = W);
    }, this.getCamera = function(W) {
      var it = y === "stage" ? 1.6 : 0;
      if (o === null)
        return W.position.set(0, it, 0), W;
      if (o.depthNear = W.near, o.depthFar = W.far, o.getFrameData(s), y === "stage") {
        var It = o.stageParameters;
        It ? c.fromArray(It.sittingToStandingTransform) : c.makeTranslation(0, it, 0);
      }
      if (it = s.pose, It = l !== null ? l : W, It.matrix.copy(c), It.matrix.decompose(It.position, It.quaternion, It.scale), it.orientation !== null && (P.fromArray(it.orientation), It.quaternion.multiply(P)), it.position !== null && (P.setFromRotationMatrix(c), N.fromArray(it.position), N.applyQuaternion(P), It.position.add(N)), It.updateMatrixWorld(), o.isPresenting === !1)
        return W;
      j.near = W.near, et.near = W.near, j.far = W.far, et.far = W.far, j.matrixWorldInverse.fromArray(s.leftViewMatrix), et.matrixWorldInverse.fromArray(s.rightViewMatrix), f.getInverse(c), y === "stage" && (j.matrixWorldInverse.multiply(f), et.matrixWorldInverse.multiply(f)), W = It.parent, W !== null && (S.getInverse(W.matrixWorld), j.matrixWorldInverse.multiply(S), et.matrixWorldInverse.multiply(S)), j.matrixWorld.getInverse(j.matrixWorldInverse), et.matrixWorld.getInverse(et.matrixWorldInverse), j.projectionMatrix.fromArray(s.leftProjectionMatrix), et.projectionMatrix.fromArray(s.rightProjectionMatrix), ce(_t, j, et), W = o.getLayers(), W.length && (W = W[0], W.leftBounds !== null && W.leftBounds.length === 4 && j.bounds.fromArray(W.leftBounds), W.rightBounds !== null && W.rightBounds.length === 4 && et.bounds.fromArray(W.rightBounds));
      t:
        for (W = 0; W < h.length; W++) {
          it = h[W];
          e: {
            It = W;
            for (var ee = navigator.getGamepads && navigator.getGamepads(), $t = 0, qt = 0, Te = ee.length; $t < Te; $t++) {
              var pe = ee[$t];
              if (pe && (pe.id === "Daydream Controller" || pe.id === "Gear VR Controller" || pe.id === "Oculus Go Controller" || pe.id === "OpenVR Gamepad" || pe.id.startsWith("Oculus Touch") || pe.id.startsWith("Spatial Controller"))) {
                if (qt === It) {
                  It = pe;
                  break e;
                }
                qt++;
              }
            }
            It = void 0;
          }
          if (It !== void 0 && It.pose !== void 0) {
            if (It.pose === null)
              break t;
            ee = It.pose, ee.hasPosition === !1 && it.position.set(0.2, -0.6, -0.05), ee.position !== null && it.position.fromArray(ee.position), ee.orientation !== null && it.quaternion.fromArray(ee.orientation), it.matrix.compose(it.position, it.quaternion, it.scale), it.matrix.premultiply(c), it.matrix.decompose(it.position, it.quaternion, it.scale), it.matrixWorldNeedsUpdate = !0, it.visible = !0, ee = It.id === "Daydream Controller" ? 0 : 1, xt[W] !== It.buttons[ee].pressed && (xt[W] = It.buttons[ee].pressed, xt[W] === !0 ? it.dispatchEvent({ type: "selectstart" }) : (it.dispatchEvent({ type: "selectend" }), it.dispatchEvent({ type: "select" })));
          } else
            it.visible = !1;
        }
      return _t;
    }, this.getStandingMatrix = function() {
      return c;
    }, this.isPresenting = e;
    var Wt = new d();
    this.setAnimationLoop = function(W) {
      Wt.setAnimationLoop(W);
    }, this.submitFrame = function() {
      e() && o.submitFrame();
    }, this.dispose = function() {
      typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", i);
    };
  }
  function Pe(t) {
    function e() {
      return h !== null && f !== null;
    }
    function i(bt) {
      var xt = S[P.indexOf(bt.inputSource)];
      xt && xt.dispatchEvent({ type: bt.type });
    }
    function n() {
      t.setFramebuffer(null), mt.stop();
    }
    function o(bt, xt) {
      xt === null ? bt.matrixWorld.copy(bt.matrix) : bt.matrixWorld.multiplyMatrices(xt.matrixWorld, bt.matrix), bt.matrixWorldInverse.getInverse(bt.matrixWorld);
    }
    var s = t.context, l = null, h = null, c = 1, f = null, v = "stage", y = null, S = [], P = [], N = new ye();
    N.layers.enable(1), N.viewport = new E();
    var j = new ye();
    j.layers.enable(2), j.viewport = new E();
    var et = new ke([N, j]);
    et.layers.enable(1), et.layers.enable(2), this.enabled = !1, this.getController = function(bt) {
      var xt = S[bt];
      return xt === void 0 && (xt = new ui(), xt.matrixAutoUpdate = !1, xt.visible = !1, S[bt] = xt), xt;
    }, this.getDevice = function() {
      return l;
    }, this.setDevice = function(bt) {
      bt !== void 0 && (l = bt), bt instanceof XRDevice && s.setCompatibleXRDevice(bt);
    }, this.setFramebufferScaleFactor = function(bt) {
      c = bt;
    }, this.setFrameOfReferenceType = function(bt) {
      v = bt;
    }, this.setSession = function(bt) {
      h = bt, h !== null && (h.addEventListener("select", i), h.addEventListener("selectstart", i), h.addEventListener("selectend", i), h.addEventListener("end", n), h.baseLayer = new XRWebGLLayer(h, s, { framebufferScaleFactor: c }), h.requestFrameOfReference(v).then(function(xt) {
        f = xt, t.setFramebuffer(h.baseLayer.framebuffer), mt.setContext(h), mt.start();
      }), P = h.getInputSources(), h.addEventListener("inputsourceschange", function() {
        P = h.getInputSources(), console.log(P);
        for (var xt = 0; xt < S.length; xt++)
          S[xt].userData.inputSource = P[xt];
      }));
    }, this.getCamera = function(bt) {
      if (e()) {
        var xt = bt.parent, Wt = et.cameras;
        o(et, xt);
        for (var W = 0; W < Wt.length; W++)
          o(Wt[W], xt);
        for (bt.matrixWorld.copy(et.matrixWorld), bt = bt.children, W = 0, xt = bt.length; W < xt; W++)
          bt[W].updateMatrixWorld(!0);
        return ce(et, N, j), et;
      }
      return bt;
    }, this.isPresenting = e;
    var _t = null, mt = new d();
    mt.setAnimationLoop(function(bt, xt) {
      if (y = xt.getDevicePose(f), y !== null)
        for (var Wt = h.baseLayer, W = xt.views, it = 0; it < W.length; it++) {
          var It = W[it], ee = Wt.getViewport(It), $t = y.getViewMatrix(It), qt = et.cameras[it];
          qt.matrix.fromArray($t).getInverse(qt.matrix), qt.projectionMatrix.fromArray(It.projectionMatrix), qt.viewport.set(ee.x, ee.y, ee.width, ee.height), it === 0 && et.matrix.copy(qt.matrix);
        }
      for (it = 0; it < S.length; it++) {
        if (Wt = S[it], (W = P[it]) && (W = xt.getInputPose(W, f), W !== null)) {
          "targetRay" in W ? Wt.matrix.elements = W.targetRay.transformMatrix : "pointerMatrix" in W && (Wt.matrix.elements = W.pointerMatrix), Wt.matrix.decompose(Wt.position, Wt.rotation, Wt.scale), Wt.visible = !0;
          continue;
        }
        Wt.visible = !1;
      }
      _t && _t(bt);
    }), this.setAnimationLoop = function(bt) {
      _t = bt;
    }, this.dispose = function() {
    }, this.getStandingMatrix = function() {
      return console.warn(
        "THREE.WebXRManager: getStandingMatrix() is no longer needed."
      ), new THREE.Matrix4();
    }, this.submitFrame = function() {
    };
  }
  function _e(t) {
    var e;
    function i() {
      ii = new Jt(ne), Ze = new Zi(ne, ii, t), Ze.isWebGL2 || (ii.get("WEBGL_depth_texture"), ii.get("OES_texture_float"), ii.get("OES_texture_half_float"), ii.get("OES_texture_half_float_linear"), ii.get("OES_standard_derivatives"), ii.get("OES_element_index_uint"), ii.get("ANGLE_instanced_arrays")), ii.get("OES_texture_float_linear"), Mn = new He(ne, ii, Ze), ai = new he(ne, ii, Mn, Ze), ai.scissor(ji.copy(Ye).multiplyScalar(Qe)), ai.viewport(cn.copy(Ut).multiplyScalar(Qe)), fn = new pt(), xn = new rt(), ao = new Ve(ne, ii, ai, xn, Ze, Mn, fn), Ns = new g(ne), vl = new jt(ne, Ns, fn), ks = new Kt(vl, fn), yl = new ie(ne), es = new ot(qt, ii, Ze), _a = new Pt(), is = new le(), Co = new Li(qt, ai, ks, W), _l = new an(ne, ii, fn, Ze), Hn = new ct(ne, ii, fn, Ze), fn.programs = es.programs, qt.context = ne, qt.capabilities = Ze, qt.extensions = ii, qt.properties = xn, qt.renderLists = _a, qt.state = ai, qt.info = fn;
    }
    function n(ut) {
      ut.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), Te = !0;
    }
    function o() {
      console.log("THREE.WebGLRenderer: Context Restored."), Te = !1, i();
    }
    function s(ut) {
      ut = ut.target, ut.removeEventListener("dispose", s), l(ut), xn.remove(ut);
    }
    function l(ut) {
      var wt = xn.get(ut).program;
      ut.program = void 0, wt !== void 0 && es.releaseProgram(wt);
    }
    function h(ut, wt) {
      ut.render(function(dt) {
        qt.renderBufferImmediate(dt, wt);
      });
    }
    function c(ut, wt, dt) {
      if (ut.visible !== !1) {
        if (ut.layers.test(wt.layers)) {
          if (ut.isLight)
            $t.pushLight(ut), ut.castShadow && $t.pushShadow(ut);
          else if (ut.isSprite) {
            if (!ut.frustumCulled || Gi.intersectsSprite(ut)) {
              dt && bi.setFromMatrixPosition(ut.matrixWorld).applyMatrix4(Ai);
              var Me = ks.update(ut), De = ut.material;
              ee.push(ut, Me, De, bi.z, null);
            }
          } else if (ut.isImmediateRenderObject)
            dt && bi.setFromMatrixPosition(ut.matrixWorld).applyMatrix4(Ai), ee.push(ut, null, ut.material, bi.z, null);
          else if ((ut.isMesh || ut.isLine || ut.isPoints) && (ut.isSkinnedMesh && ut.skeleton.update(), !ut.frustumCulled || Gi.intersectsObject(ut)))
            if (dt && bi.setFromMatrixPosition(ut.matrixWorld).applyMatrix4(Ai), Me = ks.update(ut), De = ut.material, Array.isArray(De))
              for (var We = Me.groups, Se = 0, $e = We.length; Se < $e; Se++) {
                var Pi = We[Se], Yi = De[Pi.materialIndex];
                Yi && Yi.visible && ee.push(ut, Me, Yi, bi.z, Pi);
              }
            else
              De.visible && ee.push(ut, Me, De, bi.z, null);
        }
        for (ut = ut.children, Se = 0, $e = ut.length; Se < $e; Se++)
          c(ut[Se], wt, dt);
      }
    }
    function f(ut, wt, dt, Me) {
      for (var De = 0, We = ut.length; De < We; De++) {
        var Se = ut[De], $e = Se.object, Pi = Se.geometry, Yi = Me === void 0 ? Se.material : Me;
        if (Se = Se.group, dt.isArrayCamera) {
          yn = dt;
          for (var me = dt.cameras, or = 0, An = me.length; or < An; or++) {
            var en = me[or];
            if ($e.layers.test(en.layers)) {
              if ("viewport" in en)
                ai.viewport(cn.copy(en.viewport));
              else {
                var Kn = en.bounds;
                ai.viewport(
                  cn.set(Kn.x * _n, Kn.y * Ae, Kn.z * _n, Kn.w * Ae).multiplyScalar(Qe)
                );
              }
              $t.setupLights(en), v($e, wt, en, Pi, Yi, Se);
            }
          }
        } else
          yn = null, v($e, wt, dt, Pi, Yi, Se);
      }
    }
    function v(ut, wt, dt, Me, De, We) {
      if (ut.onBeforeRender(qt, wt, dt, Me, De, We), $t = is.get(wt, yn || dt), ut.modelViewMatrix.multiplyMatrices(dt.matrixWorldInverse, ut.matrixWorld), ut.normalMatrix.getNormalMatrix(ut.modelViewMatrix), ut.isImmediateRenderObject) {
        ai.setMaterial(De);
        var Se = S(dt, wt.fog, De, ut);
        je = e = null, Ke = !1, h(ut, Se);
      } else
        qt.renderBufferDirect(dt, wt.fog, Me, De, ut, We);
      ut.onAfterRender(qt, wt, dt, Me, De, We), $t = is.get(wt, yn || dt);
    }
    function y(ut, wt, dt) {
      var Me = xn.get(ut), De = $t.state.lights, We = Me.lightsHash, Se = De.state.hash;
      dt = es.getParameters(
        ut,
        De.state,
        $t.state.shadowsArray,
        wt,
        Ce.numPlanes,
        Ce.numIntersection,
        dt
      );
      var $e = es.getProgramCode(ut, dt), Pi = Me.program, Yi = !0;
      if (Pi === void 0)
        ut.addEventListener("dispose", s);
      else if (Pi.code !== $e)
        l(ut);
      else {
        if (We.stateID !== Se.stateID || We.directionalLength !== Se.directionalLength || We.pointLength !== Se.pointLength || We.spotLength !== Se.spotLength || We.rectAreaLength !== Se.rectAreaLength || We.hemiLength !== Se.hemiLength || We.shadowsLength !== Se.shadowsLength)
          We.stateID = Se.stateID, We.directionalLength = Se.directionalLength, We.pointLength = Se.pointLength, We.spotLength = Se.spotLength, We.rectAreaLength = Se.rectAreaLength, We.hemiLength = Se.hemiLength, We.shadowsLength = Se.shadowsLength;
        else if (dt.shaderID !== void 0)
          return;
        Yi = !1;
      }
      if (Yi && (dt.shaderID ? ($e = jr[dt.shaderID], Me.shader = {
        name: ut.type,
        uniforms: bn.clone($e.uniforms),
        vertexShader: $e.vertexShader,
        fragmentShader: $e.fragmentShader
      }) : Me.shader = {
        name: ut.type,
        uniforms: ut.uniforms,
        vertexShader: ut.vertexShader,
        fragmentShader: ut.fragmentShader
      }, ut.onBeforeCompile(Me.shader, qt), $e = es.getProgramCode(ut, dt), Pi = es.acquireProgram(ut, Me.shader, dt, $e), Me.program = Pi, ut.program = Pi), dt = Pi.getAttributes(), ut.morphTargets)
        for ($e = ut.numSupportedMorphTargets = 0; $e < qt.maxMorphTargets; $e++)
          0 <= dt["morphTarget" + $e] && ut.numSupportedMorphTargets++;
      if (ut.morphNormals)
        for ($e = ut.numSupportedMorphNormals = 0; $e < qt.maxMorphNormals; $e++)
          0 <= dt["morphNormal" + $e] && ut.numSupportedMorphNormals++;
      dt = Me.shader.uniforms, (!ut.isShaderMaterial && !ut.isRawShaderMaterial || ut.clipping === !0) && (Me.numClippingPlanes = Ce.numPlanes, Me.numIntersection = Ce.numIntersection, dt.clippingPlanes = Ce.uniform), Me.fog = wt, We === void 0 && (Me.lightsHash = We = {}), We.stateID = Se.stateID, We.directionalLength = Se.directionalLength, We.pointLength = Se.pointLength, We.spotLength = Se.spotLength, We.rectAreaLength = Se.rectAreaLength, We.hemiLength = Se.hemiLength, We.shadowsLength = Se.shadowsLength, ut.lights && (dt.ambientLightColor.value = De.state.ambient, dt.directionalLights.value = De.state.directional, dt.spotLights.value = De.state.spot, dt.rectAreaLights.value = De.state.rectArea, dt.pointLights.value = De.state.point, dt.hemisphereLights.value = De.state.hemi, dt.directionalShadowMap.value = De.state.directionalShadowMap, dt.directionalShadowMatrix.value = De.state.directionalShadowMatrix, dt.spotShadowMap.value = De.state.spotShadowMap, dt.spotShadowMatrix.value = De.state.spotShadowMatrix, dt.pointShadowMap.value = De.state.pointShadowMap, dt.pointShadowMatrix.value = De.state.pointShadowMatrix), ut = Me.program.getUniforms(), ut = Or.seqWithValue(ut.seq, dt), Me.uniformsList = ut;
    }
    function S(ut, wt, dt, Me) {
      Qi = 0;
      var De = xn.get(dt), We = De.lightsHash, Se = $t.state.lights.state.hash;
      Xe && (ri || ut !== ci) && Ce.setState(
        dt.clippingPlanes,
        dt.clipIntersection,
        dt.clipShadows,
        ut,
        De,
        ut === ci && dt.id === se
      ), dt.needsUpdate === !1 && (De.program === void 0 || dt.fog && De.fog !== wt ? dt.needsUpdate = !0 : (!dt.lights || We.stateID === Se.stateID && We.directionalLength === Se.directionalLength && We.pointLength === Se.pointLength && We.spotLength === Se.spotLength && We.rectAreaLength === Se.rectAreaLength && We.hemiLength === Se.hemiLength && We.shadowsLength === Se.shadowsLength) && (De.numClippingPlanes === void 0 || De.numClippingPlanes === Ce.numPlanes && De.numIntersection === Ce.numIntersection) || (dt.needsUpdate = !0)), dt.needsUpdate && (y(dt, wt, Me), dt.needsUpdate = !1);
      var $e = !1, Pi = !1, Yi = !1;
      We = De.program, Se = We.getUniforms();
      var me = De.shader.uniforms;
      if (ai.useProgram(We.program) && (Yi = Pi = $e = !0), dt.id !== se && (se = dt.id, Pi = !0), ($e || ci !== ut) && (Se.setValue(ne, "projectionMatrix", ut.projectionMatrix), Ze.logarithmicDepthBuffer && Se.setValue(ne, "logDepthBufFC", 2 / (Math.log(ut.far + 1) / Math.LN2)), ci !== ut && (ci = ut, Yi = Pi = !0), (dt.isShaderMaterial || dt.isMeshPhongMaterial || dt.isMeshStandardMaterial || dt.envMap) && ($e = Se.map.cameraPosition, $e !== void 0 && $e.setValue(ne, bi.setFromMatrixPosition(ut.matrixWorld))), (dt.isMeshPhongMaterial || dt.isMeshLambertMaterial || dt.isMeshBasicMaterial || dt.isMeshStandardMaterial || dt.isShaderMaterial || dt.skinning) && Se.setValue(ne, "viewMatrix", ut.matrixWorldInverse)), dt.skinning && (Se.setOptional(ne, Me, "bindMatrix"), Se.setOptional(ne, Me, "bindMatrixInverse"), ut = Me.skeleton))
        if ($e = ut.bones, Ze.floatVertexTextures) {
          if (ut.boneTexture === void 0) {
            $e = Math.sqrt(4 * $e.length), $e = fi.ceilPowerOfTwo($e), $e = Math.max($e, 4);
            var or = new Float32Array($e * $e * 4);
            or.set(ut.boneMatrices);
            var An = new H(or, $e, $e, 1023, 1015);
            An.needsUpdate = !0, ut.boneMatrices = or, ut.boneTexture = An, ut.boneTextureSize = $e;
          }
          Se.setValue(ne, "boneTexture", ut.boneTexture), Se.setValue(ne, "boneTextureSize", ut.boneTextureSize);
        } else
          Se.setOptional(ne, ut, "boneMatrices");
      return Pi && (Se.setValue(ne, "toneMappingExposure", qt.toneMappingExposure), Se.setValue(ne, "toneMappingWhitePoint", qt.toneMappingWhitePoint), dt.lights && (Pi = Yi, me.ambientLightColor.needsUpdate = Pi, me.directionalLights.needsUpdate = Pi, me.pointLights.needsUpdate = Pi, me.spotLights.needsUpdate = Pi, me.rectAreaLights.needsUpdate = Pi, me.hemisphereLights.needsUpdate = Pi), wt && dt.fog && (me.fogColor.value = wt.color, wt.isFog ? (me.fogNear.value = wt.near, me.fogFar.value = wt.far) : wt.isFogExp2 && (me.fogDensity.value = wt.density)), dt.isMeshBasicMaterial ? P(me, dt) : dt.isMeshLambertMaterial ? (P(me, dt), dt.emissiveMap && (me.emissiveMap.value = dt.emissiveMap)) : dt.isMeshPhongMaterial ? (P(me, dt), dt.isMeshToonMaterial ? (N(me, dt), dt.gradientMap && (me.gradientMap.value = dt.gradientMap)) : N(me, dt)) : dt.isMeshStandardMaterial ? (P(me, dt), dt.isMeshPhysicalMaterial ? (j(me, dt), me.reflectivity.value = dt.reflectivity, me.clearCoat.value = dt.clearCoat, me.clearCoatRoughness.value = dt.clearCoatRoughness) : j(me, dt)) : dt.isMeshMatcapMaterial ? (P(me, dt), dt.matcap && (me.matcap.value = dt.matcap), dt.bumpMap && (me.bumpMap.value = dt.bumpMap, me.bumpScale.value = dt.bumpScale, dt.side === 1 && (me.bumpScale.value *= -1)), dt.normalMap && (me.normalMap.value = dt.normalMap, me.normalScale.value.copy(dt.normalScale), dt.side === 1 && me.normalScale.value.negate()), dt.displacementMap && (me.displacementMap.value = dt.displacementMap, me.displacementScale.value = dt.displacementScale, me.displacementBias.value = dt.displacementBias)) : dt.isMeshDepthMaterial ? (P(me, dt), dt.displacementMap && (me.displacementMap.value = dt.displacementMap, me.displacementScale.value = dt.displacementScale, me.displacementBias.value = dt.displacementBias)) : dt.isMeshDistanceMaterial ? (P(me, dt), dt.displacementMap && (me.displacementMap.value = dt.displacementMap, me.displacementScale.value = dt.displacementScale, me.displacementBias.value = dt.displacementBias), me.referencePosition.value.copy(dt.referencePosition), me.nearDistance.value = dt.nearDistance, me.farDistance.value = dt.farDistance) : dt.isMeshNormalMaterial ? (P(me, dt), dt.bumpMap && (me.bumpMap.value = dt.bumpMap, me.bumpScale.value = dt.bumpScale, dt.side === 1 && (me.bumpScale.value *= -1)), dt.normalMap && (me.normalMap.value = dt.normalMap, me.normalScale.value.copy(dt.normalScale), dt.side === 1 && me.normalScale.value.negate()), dt.displacementMap && (me.displacementMap.value = dt.displacementMap, me.displacementScale.value = dt.displacementScale, me.displacementBias.value = dt.displacementBias)) : dt.isLineBasicMaterial ? (me.diffuse.value = dt.color, me.opacity.value = dt.opacity, dt.isLineDashedMaterial && (me.dashSize.value = dt.dashSize, me.totalSize.value = dt.dashSize + dt.gapSize, me.scale.value = dt.scale)) : dt.isPointsMaterial ? (me.diffuse.value = dt.color, me.opacity.value = dt.opacity, me.size.value = dt.size * Qe, me.scale.value = 0.5 * Ae, me.map.value = dt.map, dt.map !== null && (dt.map.matrixAutoUpdate === !0 && dt.map.updateMatrix(), me.uvTransform.value.copy(dt.map.matrix))) : dt.isSpriteMaterial ? (me.diffuse.value = dt.color, me.opacity.value = dt.opacity, me.rotation.value = dt.rotation, me.map.value = dt.map, dt.map !== null && (dt.map.matrixAutoUpdate === !0 && dt.map.updateMatrix(), me.uvTransform.value.copy(dt.map.matrix))) : dt.isShadowMaterial && (me.color.value = dt.color, me.opacity.value = dt.opacity), me.ltc_1 !== void 0 && (me.ltc_1.value = qe.LTC_1), me.ltc_2 !== void 0 && (me.ltc_2.value = qe.LTC_2), Or.upload(ne, De.uniformsList, me, qt)), dt.isShaderMaterial && dt.uniformsNeedUpdate === !0 && (Or.upload(ne, De.uniformsList, me, qt), dt.uniformsNeedUpdate = !1), dt.isSpriteMaterial && Se.setValue(ne, "center", Me.center), Se.setValue(ne, "modelViewMatrix", Me.modelViewMatrix), Se.setValue(ne, "normalMatrix", Me.normalMatrix), Se.setValue(ne, "modelMatrix", Me.matrixWorld), We;
    }
    function P(ut, wt) {
      if (ut.opacity.value = wt.opacity, wt.color && (ut.diffuse.value = wt.color), wt.emissive && ut.emissive.value.copy(wt.emissive).multiplyScalar(wt.emissiveIntensity), wt.map && (ut.map.value = wt.map), wt.alphaMap && (ut.alphaMap.value = wt.alphaMap), wt.specularMap && (ut.specularMap.value = wt.specularMap), wt.envMap && (ut.envMap.value = wt.envMap, ut.flipEnvMap.value = wt.envMap && wt.envMap.isCubeTexture ? -1 : 1, ut.reflectivity.value = wt.reflectivity, ut.refractionRatio.value = wt.refractionRatio, ut.maxMipLevel.value = xn.get(wt.envMap).__maxMipLevel), wt.lightMap && (ut.lightMap.value = wt.lightMap, ut.lightMapIntensity.value = wt.lightMapIntensity), wt.aoMap && (ut.aoMap.value = wt.aoMap, ut.aoMapIntensity.value = wt.aoMapIntensity), wt.map)
        var dt = wt.map;
      else
        wt.specularMap ? dt = wt.specularMap : wt.displacementMap ? dt = wt.displacementMap : wt.normalMap ? dt = wt.normalMap : wt.bumpMap ? dt = wt.bumpMap : wt.roughnessMap ? dt = wt.roughnessMap : wt.metalnessMap ? dt = wt.metalnessMap : wt.alphaMap ? dt = wt.alphaMap : wt.emissiveMap && (dt = wt.emissiveMap);
      dt !== void 0 && (dt.isWebGLRenderTarget && (dt = dt.texture), dt.matrixAutoUpdate === !0 && dt.updateMatrix(), ut.uvTransform.value.copy(dt.matrix));
    }
    function N(ut, wt) {
      ut.specular.value = wt.specular, ut.shininess.value = Math.max(wt.shininess, 1e-4), wt.emissiveMap && (ut.emissiveMap.value = wt.emissiveMap), wt.bumpMap && (ut.bumpMap.value = wt.bumpMap, ut.bumpScale.value = wt.bumpScale, wt.side === 1 && (ut.bumpScale.value *= -1)), wt.normalMap && (ut.normalMap.value = wt.normalMap, ut.normalScale.value.copy(wt.normalScale), wt.side === 1 && ut.normalScale.value.negate()), wt.displacementMap && (ut.displacementMap.value = wt.displacementMap, ut.displacementScale.value = wt.displacementScale, ut.displacementBias.value = wt.displacementBias);
    }
    function j(ut, wt) {
      ut.roughness.value = wt.roughness, ut.metalness.value = wt.metalness, wt.roughnessMap && (ut.roughnessMap.value = wt.roughnessMap), wt.metalnessMap && (ut.metalnessMap.value = wt.metalnessMap), wt.emissiveMap && (ut.emissiveMap.value = wt.emissiveMap), wt.bumpMap && (ut.bumpMap.value = wt.bumpMap, ut.bumpScale.value = wt.bumpScale, wt.side === 1 && (ut.bumpScale.value *= -1)), wt.normalMap && (ut.normalMap.value = wt.normalMap, ut.normalScale.value.copy(wt.normalScale), wt.side === 1 && ut.normalScale.value.negate()), wt.displacementMap && (ut.displacementMap.value = wt.displacementMap, ut.displacementScale.value = wt.displacementScale, ut.displacementBias.value = wt.displacementBias), wt.envMap && (ut.envMapIntensity.value = wt.envMapIntensity);
    }
    console.log("THREE.WebGLRenderer", "98"), t = t || {};
    var et = t.canvas !== void 0 ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _t = t.context !== void 0 ? t.context : null, mt = t.alpha !== void 0 ? t.alpha : !1, bt = t.depth !== void 0 ? t.depth : !0, xt = t.stencil !== void 0 ? t.stencil : !0, Wt = t.antialias !== void 0 ? t.antialias : !1, W = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, it = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, It = t.powerPreference !== void 0 ? t.powerPreference : "default", ee = null, $t = null;
    this.domElement = et, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
    var qt = this, Te = !1, pe = null, Oe = null, be = null, se = -1, je = e = null, Ke = !1, ci = null, yn = null, cn = new E(), ji = new E(), Fi = null, Qi = 0, _n = et.width, Ae = et.height, Qe = 1, Ut = new E(0, 0, _n, Ae), Ye = new E(0, 0, _n, Ae), ei = !1, Gi = new b(), Ce = new R(), Xe = !1, ri = !1, Ai = new $(), bi = new m();
    try {
      mt = {
        alpha: mt,
        depth: bt,
        stencil: xt,
        antialias: Wt,
        premultipliedAlpha: W,
        preserveDrawingBuffer: it,
        powerPreference: It
      }, et.addEventListener("webglcontextlost", n, !1), et.addEventListener("webglcontextrestored", o, !1);
      var ne = _t || et.getContext("webgl", mt) || et.getContext("experimental-webgl", mt);
      if (ne === null)
        throw et.getContext("webgl") !== null ? Error(
          "Error creating WebGL context with your selected attributes."
        ) : Error("Error creating WebGL context.");
      ne.getShaderPrecisionFormat === void 0 && (ne.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (ut) {
      console.error("THREE.WebGLRenderer: " + ut.message);
    }
    var ii, Ze, ai, fn, xn, ao, Ns, vl, ks, es, _a, is, Co, yl, _l, Hn, Mn;
    i();
    var qr = null;
    typeof navigator < "u" && (qr = "xr" in navigator ? new Pe(qt) : new di(qt)), this.vr = qr;
    var Wl = new ve(qt, ks, Ze.maxTextureSize);
    this.shadowMap = Wl, this.getContext = function() {
      return ne;
    }, this.getContextAttributes = function() {
      return ne.getContextAttributes();
    }, this.forceContextLoss = function() {
      var ut = ii.get("WEBGL_lose_context");
      ut && ut.loseContext();
    }, this.forceContextRestore = function() {
      var ut = ii.get("WEBGL_lose_context");
      ut && ut.restoreContext();
    }, this.getPixelRatio = function() {
      return Qe;
    }, this.setPixelRatio = function(ut) {
      ut !== void 0 && (Qe = ut, this.setSize(_n, Ae, !1));
    }, this.getSize = function() {
      return { width: _n, height: Ae };
    }, this.setSize = function(ut, wt, dt) {
      qr.isPresenting() ? console.warn(
        "THREE.WebGLRenderer: Can't change size while VR device is presenting."
      ) : (_n = ut, Ae = wt, et.width = ut * Qe, et.height = wt * Qe, dt !== !1 && (et.style.width = ut + "px", et.style.height = wt + "px"), this.setViewport(0, 0, ut, wt));
    }, this.getDrawingBufferSize = function() {
      return { width: _n * Qe, height: Ae * Qe };
    }, this.setDrawingBufferSize = function(ut, wt, dt) {
      _n = ut, Ae = wt, Qe = dt, et.width = ut * dt, et.height = wt * dt, this.setViewport(0, 0, ut, wt);
    }, this.getCurrentViewport = function() {
      return cn;
    }, this.setViewport = function(ut, wt, dt, Me) {
      Ut.set(ut, Ae - wt - Me, dt, Me), ai.viewport(cn.copy(Ut).multiplyScalar(Qe));
    }, this.setScissor = function(ut, wt, dt, Me) {
      Ye.set(ut, Ae - wt - Me, dt, Me), ai.scissor(ji.copy(Ye).multiplyScalar(Qe));
    }, this.setScissorTest = function(ut) {
      ai.setScissorTest(ei = ut);
    }, this.getClearColor = function() {
      return Co.getClearColor();
    }, this.setClearColor = function() {
      Co.setClearColor.apply(Co, arguments);
    }, this.getClearAlpha = function() {
      return Co.getClearAlpha();
    }, this.setClearAlpha = function() {
      Co.setClearAlpha.apply(Co, arguments);
    }, this.clear = function(ut, wt, dt) {
      var Me = 0;
      (ut === void 0 || ut) && (Me |= 16384), (wt === void 0 || wt) && (Me |= 256), (dt === void 0 || dt) && (Me |= 1024), ne.clear(Me);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      et.removeEventListener("webglcontextlost", n, !1), et.removeEventListener("webglcontextrestored", o, !1), _a.dispose(), is.dispose(), xn.dispose(), ks.dispose(), qr.dispose(), lo.stop();
    }, this.renderBufferImmediate = function(ut, wt) {
      ai.initAttributes();
      var dt = xn.get(ut);
      ut.hasPositions && !dt.position && (dt.position = ne.createBuffer()), ut.hasNormals && !dt.normal && (dt.normal = ne.createBuffer()), ut.hasUvs && !dt.uv && (dt.uv = ne.createBuffer()), ut.hasColors && !dt.color && (dt.color = ne.createBuffer()), wt = wt.getAttributes(), ut.hasPositions && (ne.bindBuffer(34962, dt.position), ne.bufferData(34962, ut.positionArray, 35048), ai.enableAttribute(wt.position), ne.vertexAttribPointer(wt.position, 3, 5126, !1, 0, 0)), ut.hasNormals && (ne.bindBuffer(34962, dt.normal), ne.bufferData(34962, ut.normalArray, 35048), ai.enableAttribute(wt.normal), ne.vertexAttribPointer(wt.normal, 3, 5126, !1, 0, 0)), ut.hasUvs && (ne.bindBuffer(34962, dt.uv), ne.bufferData(34962, ut.uvArray, 35048), ai.enableAttribute(wt.uv), ne.vertexAttribPointer(wt.uv, 2, 5126, !1, 0, 0)), ut.hasColors && (ne.bindBuffer(34962, dt.color), ne.bufferData(34962, ut.colorArray, 35048), ai.enableAttribute(wt.color), ne.vertexAttribPointer(wt.color, 3, 5126, !1, 0, 0)), ai.disableUnusedAttributes(), ne.drawArrays(4, 0, ut.count), ut.count = 0;
    }, this.renderBufferDirect = function(ut, wt, dt, Me, De, We) {
      var Se = De.isMesh && 0 > De.normalMatrix.determinant();
      ai.setMaterial(Me, Se);
      var $e = S(ut, wt, Me, De), Pi = !1;
      (e !== dt.id || je !== $e.id || Ke !== (Me.wireframe === !0)) && (e = dt.id, je = $e.id, Ke = Me.wireframe === !0, Pi = !0), De.morphTargetInfluences && (yl.update(De, dt, Me, $e), Pi = !0), Se = dt.index;
      var Yi = dt.attributes.position;
      if (wt = 1, Me.wireframe === !0 && (Se = vl.getWireframeAttribute(dt), wt = 2), ut = _l, Se !== null) {
        var me = Ns.get(Se);
        ut = Hn, ut.setIndex(me);
      }
      if (Pi) {
        if (dt && dt.isInstancedBufferGeometry & !Ze.isWebGL2 && ii.get("ANGLE_instanced_arrays") === null)
          console.error(
            "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        else {
          ai.initAttributes(), Pi = dt.attributes, $e = $e.getAttributes();
          var or = Me.defaultAttributeValues;
          for (Wn in $e) {
            var An = $e[Wn];
            if (0 <= An) {
              var en = Pi[Wn];
              if (en !== void 0) {
                var Kn = en.normalized, xl = en.itemSize, Yr = Ns.get(en);
                if (Yr !== void 0) {
                  var wl = Yr.buffer, qa = Yr.type;
                  if (Yr = Yr.bytesPerElement, en.isInterleavedBufferAttribute) {
                    var Fs = en.data, jl = Fs.stride;
                    en = en.offset, Fs && Fs.isInstancedInterleavedBuffer ? (ai.enableAttributeAndDivisor(An, Fs.meshPerAttribute), dt.maxInstancedCount === void 0 && (dt.maxInstancedCount = Fs.meshPerAttribute * Fs.count)) : ai.enableAttribute(An), ne.bindBuffer(34962, wl), ne.vertexAttribPointer(An, xl, qa, Kn, jl * Yr, en * Yr);
                  } else
                    en.isInstancedBufferAttribute ? (ai.enableAttributeAndDivisor(An, en.meshPerAttribute), dt.maxInstancedCount === void 0 && (dt.maxInstancedCount = en.meshPerAttribute * en.count)) : ai.enableAttribute(An), ne.bindBuffer(34962, wl), ne.vertexAttribPointer(An, xl, qa, Kn, 0, 0);
                }
              } else if (or !== void 0 && (Kn = or[Wn], Kn !== void 0))
                switch (Kn.length) {
                  case 2:
                    ne.vertexAttrib2fv(An, Kn);
                    break;
                  case 3:
                    ne.vertexAttrib3fv(An, Kn);
                    break;
                  case 4:
                    ne.vertexAttrib4fv(An, Kn);
                    break;
                  default:
                    ne.vertexAttrib1fv(An, Kn);
                }
            }
          }
          ai.disableUnusedAttributes();
        }
        Se !== null && ne.bindBuffer(34963, me.buffer);
      }
      me = 1 / 0, Se !== null ? me = Se.count : Yi !== void 0 && (me = Yi.count), Se = dt.drawRange.start * wt, Yi = We !== null ? We.start * wt : 0;
      var Wn = Math.max(Se, Yi);
      if (We = Math.max(
        0,
        Math.min(
          me,
          Se + dt.drawRange.count * wt,
          Yi + (We !== null ? We.count * wt : 1 / 0)
        ) - 1 - Wn + 1
      ), We !== 0) {
        if (De.isMesh)
          if (Me.wireframe === !0)
            ai.setLineWidth(Me.wireframeLinewidth * (Oe === null ? Qe : 1)), ut.setMode(1);
          else
            switch (De.drawMode) {
              case 0:
                ut.setMode(4);
                break;
              case 1:
                ut.setMode(5);
                break;
              case 2:
                ut.setMode(6);
            }
        else
          De.isLine ? (Me = Me.linewidth, Me === void 0 && (Me = 1), ai.setLineWidth(Me * (Oe === null ? Qe : 1)), De.isLineSegments ? ut.setMode(1) : De.isLineLoop ? ut.setMode(2) : ut.setMode(3)) : De.isPoints ? ut.setMode(0) : De.isSprite && ut.setMode(4);
        dt && dt.isInstancedBufferGeometry ? 0 < dt.maxInstancedCount && ut.renderInstances(dt, Wn, We) : ut.render(Wn, We);
      }
    }, this.compile = function(ut, wt) {
      $t = is.get(ut, wt), $t.init(), ut.traverse(function(dt) {
        dt.isLight && ($t.pushLight(dt), dt.castShadow && $t.pushShadow(dt));
      }), $t.setupLights(wt), ut.traverse(function(dt) {
        if (dt.material)
          if (Array.isArray(dt.material))
            for (var Me = 0; Me < dt.material.length; Me++)
              y(dt.material[Me], ut.fog, dt);
          else
            y(dt.material, ut.fog, dt);
      });
    };
    var Us = null, lo = new d();
    lo.setAnimationLoop(function(ut) {
      qr.isPresenting() || Us && Us(ut);
    }), typeof window < "u" && lo.setContext(window), this.setAnimationLoop = function(ut) {
      Us = ut, qr.setAnimationLoop(ut), lo.start();
    }, this.render = function(ut, wt, dt, Me) {
      if (!wt || !wt.isCamera)
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
      else if (!Te) {
        je = e = null, Ke = !1, se = -1, ci = null, ut.autoUpdate === !0 && ut.updateMatrixWorld(), wt.parent === null && wt.updateMatrixWorld(), qr.enabled && (wt = qr.getCamera(wt)), $t = is.get(ut, wt), $t.init(), ut.onBeforeRender(qt, ut, wt, dt), Ai.multiplyMatrices(wt.projectionMatrix, wt.matrixWorldInverse), Gi.setFromMatrix(Ai), ri = this.localClippingEnabled, Xe = Ce.init(this.clippingPlanes, ri, wt), ee = _a.get(ut, wt), ee.init(), c(ut, wt, qt.sortObjects), qt.sortObjects === !0 && ee.sort(), Xe && Ce.beginShadows(), Wl.render($t.state.shadowsArray, ut, wt), $t.setupLights(wt), Xe && Ce.endShadows(), this.info.autoReset && this.info.reset(), dt === void 0 && (dt = null), this.setRenderTarget(dt), Co.render(ee, ut, wt, Me), Me = ee.opaque;
        var De = ee.transparent;
        if (ut.overrideMaterial) {
          var We = ut.overrideMaterial;
          Me.length && f(Me, ut, wt, We), De.length && f(De, ut, wt, We);
        } else
          Me.length && f(Me, ut, wt), De.length && f(De, ut, wt);
        dt && ao.updateRenderTargetMipmap(dt), ai.buffers.depth.setTest(!0), ai.buffers.depth.setMask(!0), ai.buffers.color.setMask(!0), ai.setPolygonOffset(!1), ut.onAfterRender(qt, ut, wt), qr.enabled && qr.submitFrame(), $t = ee = null;
      }
    }, this.allocTextureUnit = function() {
      var ut = Qi;
      return ut >= Ze.maxTextures && console.warn(
        "THREE.WebGLRenderer: Trying to use " + ut + " texture units while this GPU supports only " + Ze.maxTextures
      ), Qi += 1, ut;
    }, this.setTexture2D = function() {
      var ut = !1;
      return function(wt, dt) {
        wt && wt.isWebGLRenderTarget && (ut || (console.warn(
          "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
        ), ut = !0), wt = wt.texture), ao.setTexture2D(wt, dt);
      };
    }(), this.setTexture3D = function() {
      return function(ut, wt) {
        ao.setTexture3D(ut, wt);
      };
    }(), this.setTexture = function() {
      var ut = !1;
      return function(wt, dt) {
        ut || (console.warn(
          "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
        ), ut = !0), ao.setTexture2D(wt, dt);
      };
    }(), this.setTextureCube = function() {
      var ut = !1;
      return function(wt, dt) {
        wt && wt.isWebGLRenderTargetCube && (ut || (console.warn(
          "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ), ut = !0), wt = wt.texture), wt && wt.isCubeTexture || Array.isArray(wt.image) && wt.image.length === 6 ? ao.setTextureCube(wt, dt) : ao.setTextureCubeDynamic(wt, dt);
      };
    }(), this.setFramebuffer = function(ut) {
      pe = ut;
    }, this.getRenderTarget = function() {
      return Oe;
    }, this.setRenderTarget = function(ut) {
      (Oe = ut) && xn.get(ut).__webglFramebuffer === void 0 && ao.setupRenderTarget(ut);
      var wt = pe, dt = !1;
      ut ? (wt = xn.get(ut).__webglFramebuffer, ut.isWebGLRenderTargetCube && (wt = wt[ut.activeCubeFace], dt = !0), cn.copy(ut.viewport), ji.copy(ut.scissor), Fi = ut.scissorTest) : (cn.copy(Ut).multiplyScalar(Qe), ji.copy(Ye).multiplyScalar(Qe), Fi = ei), be !== wt && (ne.bindFramebuffer(36160, wt), be = wt), ai.viewport(cn), ai.scissor(ji), ai.setScissorTest(Fi), dt && (dt = xn.get(ut.texture), ne.framebufferTexture2D(
        36160,
        36064,
        34069 + ut.activeCubeFace,
        dt.__webglTexture,
        ut.activeMipMapLevel
      ));
    }, this.readRenderTargetPixels = function(ut, wt, dt, Me, De, We) {
      if (ut && ut.isWebGLRenderTarget) {
        var Se = xn.get(ut).__webglFramebuffer;
        if (Se) {
          var $e = !1;
          Se !== be && (ne.bindFramebuffer(36160, Se), $e = !0);
          try {
            var Pi = ut.texture, Yi = Pi.format, me = Pi.type;
            Yi !== 1023 && Mn.convert(Yi) !== ne.getParameter(35739) ? console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            ) : me === 1009 || Mn.convert(me) === ne.getParameter(35738) || me === 1015 && (Ze.isWebGL2 || ii.get("OES_texture_float") || ii.get("WEBGL_color_buffer_float")) || me === 1016 && (Ze.isWebGL2 ? ii.get("EXT_color_buffer_float") : ii.get("EXT_color_buffer_half_float")) ? ne.checkFramebufferStatus(36160) === 36053 ? 0 <= wt && wt <= ut.width - Me && 0 <= dt && dt <= ut.height - De && ne.readPixels(wt, dt, Me, De, Mn.convert(Yi), Mn.convert(me), We) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
            ) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          } finally {
            $e && ne.bindFramebuffer(36160, be);
          }
        }
      } else
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
    }, this.copyFramebufferToTexture = function(ut, wt, dt) {
      var Me = wt.image.width, De = wt.image.height, We = Mn.convert(wt.format);
      this.setTexture2D(wt, 0), ne.copyTexImage2D(3553, dt || 0, We, ut.x, ut.y, Me, De, 0);
    }, this.copyTextureToTexture = function(ut, wt, dt, Me) {
      var De = wt.image.width, We = wt.image.height, Se = Mn.convert(dt.format), $e = Mn.convert(dt.type);
      this.setTexture2D(dt, 0), wt.isDataTexture ? ne.texSubImage2D(3553, Me || 0, ut.x, ut.y, De, We, Se, $e, wt.image.data) : ne.texSubImage2D(3553, Me || 0, ut.x, ut.y, Se, $e, wt.image);
    };
  }
  function Le(t, e) {
    this.name = "", this.color = new A(t), this.density = e !== void 0 ? e : 25e-5;
  }
  function mn(t, e, i) {
    this.name = "", this.color = new A(t), this.near = e !== void 0 ? e : 1, this.far = i !== void 0 ? i : 1e3;
  }
  function On() {
    z.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0;
  }
  function Ii(t, e) {
    this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function Oi(t, e, i, n) {
    this.data = t, this.itemSize = e, this.offset = i, this.normalized = n === !0;
  }
  function Ui(t) {
    Zt.call(this), this.type = "SpriteMaterial", this.color = new A(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t);
  }
  function $i(t) {
    if (z.call(this), this.type = "Sprite", Bs === void 0) {
      Bs = new Ft();
      var e = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      e = new Ii(e, 5), Bs.setIndex([0, 1, 2, 0, 2, 3]), Bs.addAttribute("position", new Oi(e, 3, 0, !1)), Bs.addAttribute("uv", new Oi(e, 2, 3, !1));
    }
    this.geometry = Bs, this.material = t !== void 0 ? t : new Ui(), this.center = new p(0.5, 0.5);
  }
  function Ki() {
    z.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
  }
  function nn(t, e) {
    if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), e === void 0)
      this.calculateInverses();
    else if (this.bones.length === e.length)
      this.boneInverses = e.slice(0);
    else
      for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++)
        this.boneInverses.push(new $());
  }
  function rn() {
    z.call(this), this.type = "Bone";
  }
  function ki(t, e) {
    pi.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new $(), this.bindMatrixInverse = new $(), t = this.initBones(), t = new nn(t), this.bind(t, this.matrixWorld), this.normalizeSkinWeights();
  }
  function Di(t) {
    Zt.call(this), this.type = "LineBasicMaterial", this.color = new A(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t);
  }
  function Hi(t, e, i) {
    i === 1 && console.error(
      "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
    ), z.call(this), this.type = "Line", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Di({ color: 16777215 * Math.random() });
  }
  function mi(t, e) {
    Hi.call(this, t, e), this.type = "LineSegments";
  }
  function zr(t, e) {
    Hi.call(this, t, e), this.type = "LineLoop";
  }
  function Cn(t) {
    Zt.call(this), this.type = "PointsMaterial", this.color = new A(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(t);
  }
  function ps(t, e) {
    z.call(this), this.type = "Points", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new Cn({ color: 16777215 * Math.random() });
  }
  function tl(t, e, i, n, o, s, l, h, c) {
    O.call(this, t, e, i, n, o, s, l, h, c), this.generateMipmaps = !1;
  }
  function fo(t, e, i, n, o, s, l, h, c, f, v, y) {
    O.call(this, null, s, l, h, c, f, n, o, v, y), this.image = { width: e, height: i }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1;
  }
  function Vs(t, e, i, n, o, s, l, h, c) {
    O.call(this, t, e, i, n, o, s, l, h, c), this.needsUpdate = !0;
  }
  function Xs(t, e, i, n, o, s, l, h, c, f) {
    if (f = f !== void 0 ? f : 1026, f !== 1026 && f !== 1027)
      throw Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && f === 1026 && (i = 1012), i === void 0 && f === 1027 && (i = 1020), O.call(this, null, n, o, s, l, h, f, i, c), this.image = { width: t, height: e }, this.magFilter = l !== void 0 ? l : 1003, this.minFilter = h !== void 0 ? h : 1003, this.generateMipmaps = this.flipY = !1;
  }
  function ds(t) {
    Ft.call(this), this.type = "WireframeGeometry";
    var e = [], i, n, o, s = [0, 0], l = {}, h = ["a", "b", "c"];
    if (t && t.isGeometry) {
      var c = t.faces, f = 0;
      for (n = c.length; f < n; f++) {
        var v = c[f];
        for (i = 0; 3 > i; i++) {
          var y = v[h[i]], S = v[h[(i + 1) % 3]];
          s[0] = Math.min(y, S), s[1] = Math.max(y, S), y = s[0] + "," + s[1], l[y] === void 0 && (l[y] = { index1: s[0], index2: s[1] });
        }
      }
      for (y in l)
        f = l[y], h = t.vertices[f.index1], e.push(h.x, h.y, h.z), h = t.vertices[f.index2], e.push(h.x, h.y, h.z);
    } else if (t && t.isBufferGeometry)
      if (h = new m(), t.index !== null) {
        c = t.attributes.position, v = t.index;
        var P = t.groups;
        for (P.length === 0 && (P = [{ start: 0, count: v.count, materialIndex: 0 }]), t = 0, o = P.length; t < o; ++t)
          for (f = P[t], i = f.start, n = f.count, f = i, n = i + n; f < n; f += 3)
            for (i = 0; 3 > i; i++)
              y = v.getX(f + i), S = v.getX(f + (i + 1) % 3), s[0] = Math.min(y, S), s[1] = Math.max(y, S), y = s[0] + "," + s[1], l[y] === void 0 && (l[y] = { index1: s[0], index2: s[1] });
        for (y in l)
          f = l[y], h.fromBufferAttribute(c, f.index1), e.push(h.x, h.y, h.z), h.fromBufferAttribute(c, f.index2), e.push(h.x, h.y, h.z);
      } else
        for (c = t.attributes.position, f = 0, n = c.count / 3; f < n; f++)
          for (i = 0; 3 > i; i++)
            l = 3 * f + i, h.fromBufferAttribute(c, l), e.push(h.x, h.y, h.z), l = 3 * f + (i + 1) % 3, h.fromBufferAttribute(c, l), e.push(h.x, h.y, h.z);
    this.addAttribute("position", new Ct(e, 3));
  }
  function qs(t, e, i) {
    V.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: i }, this.fromBufferGeometry(new ms(t, e, i)), this.mergeVertices();
  }
  function ms(t, e, i) {
    Ft.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: i };
    var n = [], o = [], s = [], l = [], h = new m(), c = new m(), f = new m(), v = new m(), y = new m(), S, P;
    3 > t.length && console.error(
      "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
    );
    var N = e + 1;
    for (S = 0; S <= i; S++) {
      var j = S / i;
      for (P = 0; P <= e; P++) {
        var et = P / e;
        t(et, j, c), o.push(c.x, c.y, c.z), 0 <= et - 1e-5 ? (t(et - 1e-5, j, f), v.subVectors(c, f)) : (t(et + 1e-5, j, f), v.subVectors(f, c)), 0 <= j - 1e-5 ? (t(et, j - 1e-5, f), y.subVectors(c, f)) : (t(et, j + 1e-5, f), y.subVectors(f, c)), h.crossVectors(v, y).normalize(), s.push(h.x, h.y, h.z), l.push(et, j);
      }
    }
    for (S = 0; S < i; S++)
      for (P = 0; P < e; P++)
        t = S * N + P + 1, h = (S + 1) * N + P + 1, c = (S + 1) * N + P, n.push(S * N + P, t, c), n.push(t, h, c);
    this.setIndex(n), this.addAttribute("position", new Ct(o, 3)), this.addAttribute("normal", new Ct(s, 3)), this.addAttribute("uv", new Ct(l, 2));
  }
  function Wi(t, e, i, n) {
    V.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, this.fromBufferGeometry(new _i(t, e, i, n)), this.mergeVertices();
  }
  function _i(t, e, i, n) {
    function o(f) {
      h.push(f.x, f.y, f.z);
    }
    function s(f, v) {
      f *= 3, v.x = t[f + 0], v.y = t[f + 1], v.z = t[f + 2];
    }
    function l(f, v, y, S) {
      0 > S && f.x === 1 && (c[v] = f.x - 1), y.x === 0 && y.z === 0 && (c[v] = S / 2 / Math.PI + 0.5);
    }
    Ft.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, i = i || 1, n = n || 0;
    var h = [], c = [];
    (function(f) {
      for (var v = new m(), y = new m(), S = new m(), P = 0; P < e.length; P += 3) {
        s(e[P + 0], v), s(e[P + 1], y), s(e[P + 2], S);
        var N, j, et = v, _t = y, mt = S, bt = Math.pow(2, f), xt = [];
        for (j = 0; j <= bt; j++) {
          xt[j] = [];
          var Wt = et.clone().lerp(mt, j / bt), W = _t.clone().lerp(mt, j / bt), it = bt - j;
          for (N = 0; N <= it; N++)
            xt[j][N] = N === 0 && j === bt ? Wt : Wt.clone().lerp(W, N / it);
        }
        for (j = 0; j < bt; j++)
          for (N = 0; N < 2 * (bt - j) - 1; N++)
            et = Math.floor(N / 2), N % 2 === 0 ? (o(xt[j][et + 1]), o(xt[j + 1][et]), o(xt[j][et])) : (o(xt[j][et + 1]), o(xt[j + 1][et + 1]), o(xt[j + 1][et]));
      }
    })(n), function(f) {
      for (var v = new m(), y = 0; y < h.length; y += 3)
        v.x = h[y + 0], v.y = h[y + 1], v.z = h[y + 2], v.normalize().multiplyScalar(f), h[y + 0] = v.x, h[y + 1] = v.y, h[y + 2] = v.z;
    }(i), function() {
      for (var f = new m(), v = 0; v < h.length; v += 3)
        f.x = h[v + 0], f.y = h[v + 1], f.z = h[v + 2], c.push(
          Math.atan2(f.z, -f.x) / 2 / Math.PI + 0.5,
          1 - (Math.atan2(-f.y, Math.sqrt(f.x * f.x + f.z * f.z)) / Math.PI + 0.5)
        );
      f = new m(), v = new m();
      for (var y = new m(), S = new m(), P = new p(), N = new p(), j = new p(), et = 0, _t = 0; et < h.length; et += 9, _t += 6) {
        f.set(h[et + 0], h[et + 1], h[et + 2]), v.set(h[et + 3], h[et + 4], h[et + 5]), y.set(h[et + 6], h[et + 7], h[et + 8]), P.set(c[_t + 0], c[_t + 1]), N.set(c[_t + 2], c[_t + 3]), j.set(c[_t + 4], c[_t + 5]), S.copy(f).add(v).add(y).divideScalar(3);
        var mt = Math.atan2(S.z, -S.x);
        l(P, _t + 0, f, mt), l(N, _t + 2, v, mt), l(j, _t + 4, y, mt);
      }
      for (f = 0; f < c.length; f += 6)
        v = c[f + 0], y = c[f + 2], S = c[f + 4], P = Math.min(v, y, S), 0.9 < Math.max(v, y, S) && 0.1 > P && (0.2 > v && (c[f + 0] += 1), 0.2 > y && (c[f + 2] += 1), 0.2 > S && (c[f + 4] += 1));
    }(), this.addAttribute("position", new Ct(h, 3)), this.addAttribute("normal", new Ct(h.slice(), 3)), this.addAttribute("uv", new Ct(c, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Ys(t, e) {
    V.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new gs(t, e)), this.mergeVertices();
  }
  function gs(t, e) {
    _i.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Zs(t, e) {
    V.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Oo(t, e)), this.mergeVertices();
  }
  function Oo(t, e) {
    _i.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Js(t, e) {
    V.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new vs(t, e)), this.mergeVertices();
  }
  function vs(t, e) {
    var i = (1 + Math.sqrt(5)) / 2;
    _i.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1
      ],
      [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ],
      t,
      e
    ), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function ys(t, e) {
    V.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new _s(t, e)), this.mergeVertices();
  }
  function _s(t, e) {
    var i = (1 + Math.sqrt(5)) / 2, n = 1 / i;
    _i.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n
      ],
      [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ],
      t,
      e
    ), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function ln(t, e, i, n, o, s) {
    V.call(this), this.type = "TubeGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: o
    }, s !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed."), t = new po(t, e, i, n, o), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices();
  }
  function po(t, e, i, n, o) {
    function s(_t) {
      v = t.getPointAt(_t / e, v);
      var mt = l.normals[_t];
      for (_t = l.binormals[_t], S = 0; S <= n; S++) {
        var bt = S / n * Math.PI * 2, xt = Math.sin(bt);
        bt = -Math.cos(bt), c.x = bt * mt.x + xt * _t.x, c.y = bt * mt.y + xt * _t.y, c.z = bt * mt.z + xt * _t.z, c.normalize(), N.push(c.x, c.y, c.z), h.x = v.x + i * c.x, h.y = v.y + i * c.y, h.z = v.z + i * c.z, P.push(h.x, h.y, h.z);
      }
    }
    Ft.call(this), this.type = "TubeBufferGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: o
    }, e = e || 64, i = i || 1, n = n || 8, o = o || !1;
    var l = t.computeFrenetFrames(e, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    var h = new m(), c = new m(), f = new p(), v = new m(), y, S, P = [], N = [], j = [], et = [];
    for (y = 0; y < e; y++)
      s(y);
    for (s(o === !1 ? e : 0), y = 0; y <= e; y++)
      for (S = 0; S <= n; S++)
        f.x = y / e, f.y = S / n, j.push(f.x, f.y);
    (function() {
      for (S = 1; S <= e; S++)
        for (y = 1; y <= n; y++) {
          var _t = (n + 1) * S + (y - 1), mt = (n + 1) * S + y, bt = (n + 1) * (S - 1) + y;
          et.push((n + 1) * (S - 1) + (y - 1), _t, bt), et.push(_t, mt, bt);
        }
    })(), this.setIndex(et), this.addAttribute("position", new Ct(P, 3)), this.addAttribute("normal", new Ct(N, 3)), this.addAttribute("uv", new Ct(j, 2));
  }
  function Mr(t, e, i, n, o, s, l) {
    V.call(this), this.type = "TorusKnotGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: o,
      q: s
    }, l !== void 0 && console.warn(
      "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
    ), this.fromBufferGeometry(new Do(t, e, i, n, o, s)), this.mergeVertices();
  }
  function Do(t, e, i, n, o, s) {
    function l(W, it, It, ee, $t) {
      var qt = Math.sin(W);
      it = It / it * W, It = Math.cos(it), $t.x = ee * (2 + It) * 0.5 * Math.cos(W), $t.y = ee * (2 + It) * qt * 0.5, $t.z = ee * Math.sin(it) * 0.5;
    }
    Ft.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: o,
      q: s
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, s = s || 3;
    var h = [], c = [], f = [], v = [], y, S = new m(), P = new m(), N = new m(), j = new m(), et = new m(), _t = new m(), mt = new m();
    for (y = 0; y <= i; ++y) {
      var bt = y / i * o * Math.PI * 2;
      for (l(bt, o, s, t, N), l(bt + 0.01, o, s, t, j), _t.subVectors(j, N), mt.addVectors(j, N), et.crossVectors(_t, mt), mt.crossVectors(et, _t), et.normalize(), mt.normalize(), bt = 0; bt <= n; ++bt) {
        var xt = bt / n * Math.PI * 2, Wt = -e * Math.cos(xt);
        xt = e * Math.sin(xt), S.x = N.x + (Wt * mt.x + xt * et.x), S.y = N.y + (Wt * mt.y + xt * et.y), S.z = N.z + (Wt * mt.z + xt * et.z), c.push(S.x, S.y, S.z), P.subVectors(S, N).normalize(), f.push(P.x, P.y, P.z), v.push(y / i), v.push(bt / n);
      }
    }
    for (bt = 1; bt <= i; bt++)
      for (y = 1; y <= n; y++)
        t = (n + 1) * bt + (y - 1), e = (n + 1) * bt + y, o = (n + 1) * (bt - 1) + y, h.push((n + 1) * (bt - 1) + (y - 1), t, o), h.push(t, e, o);
    this.setIndex(h), this.addAttribute("position", new Ct(c, 3)), this.addAttribute("normal", new Ct(f, 3)), this.addAttribute("uv", new Ct(v, 2));
  }
  function zo(t, e, i, n, o) {
    V.call(this), this.type = "TorusGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: o
    }, this.fromBufferGeometry(new Pn(t, e, i, n, o)), this.mergeVertices();
  }
  function Pn(t, e, i, n, o) {
    Ft.call(this), this.type = "TorusBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: o
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
    var s = [], l = [], h = [], c = [], f = new m(), v = new m(), y = new m(), S, P;
    for (S = 0; S <= i; S++)
      for (P = 0; P <= n; P++) {
        var N = P / n * o, j = S / i * Math.PI * 2;
        v.x = (t + e * Math.cos(j)) * Math.cos(N), v.y = (t + e * Math.cos(j)) * Math.sin(N), v.z = e * Math.sin(j), l.push(v.x, v.y, v.z), f.x = t * Math.cos(N), f.y = t * Math.sin(N), y.subVectors(v, f).normalize(), h.push(y.x, y.y, y.z), c.push(P / n), c.push(S / i);
      }
    for (S = 1; S <= i; S++)
      for (P = 1; P <= n; P++)
        t = (n + 1) * (S - 1) + P - 1, e = (n + 1) * (S - 1) + P, o = (n + 1) * S + P, s.push((n + 1) * S + P - 1, t, o), s.push(t, e, o);
    this.setIndex(s), this.addAttribute("position", new Ct(l, 3)), this.addAttribute("normal", new Ct(h, 3)), this.addAttribute("uv", new Ct(c, 2));
  }
  function el(t, e, i, n, o) {
    for (var s, l = 0, h = e, c = i - n; h < i; h += n)
      l += (t[c] - t[h]) * (t[h + 1] + t[c + 1]), c = h;
    if (o === 0 < l)
      for (o = e; o < i; o += n)
        s = La(o, t[o], t[o + 1], s);
    else
      for (o = i - n; o >= e; o -= n)
        s = La(o, t[o], t[o + 1], s);
    return s && Bo(s, s.next) && (Vi(s), s = s.next), s;
  }
  function xs(t, e) {
    if (!t)
      return t;
    e || (e = t);
    do {
      var i = !1;
      if (t.steiner || !Bo(t, t.next) && qi(t.prev, t, t.next) !== 0)
        t = t.next;
      else {
        if (Vi(t), t = e = t.prev, t === t.next)
          break;
        i = !0;
      }
    } while (i || t !== e);
    return e;
  }
  function ws(t, e, i, n, o, s, l) {
    if (t) {
      if (!l && s) {
        var h = t, c = h;
        do
          c.z === null && (c.z = Ca(c.x, c.y, n, o, s)), c.prevZ = c.prev, c = c.nextZ = c.next;
        while (c !== h);
        c.prevZ.nextZ = null, c.prevZ = null, h = c;
        var f, v, y, S, P = 1;
        do {
          c = h;
          var N = h = null;
          for (v = 0; c; ) {
            v++;
            var j = c;
            for (f = y = 0; f < P && (y++, j = j.nextZ, j); f++)
              ;
            for (S = P; 0 < y || 0 < S && j; )
              y !== 0 && (S === 0 || !j || c.z <= j.z) ? (f = c, c = c.nextZ, y--) : (f = j, j = j.nextZ, S--), N ? N.nextZ = f : h = f, f.prevZ = N, N = f;
            c = j;
          }
          N.nextZ = null, P *= 2;
        } while (1 < v);
      }
      for (h = t; t.prev !== t.next; ) {
        if (c = t.prev, j = t.next, s)
          t: {
            N = t, S = n;
            var et = o, _t = s;
            if (v = N.prev, y = N, P = N.next, 0 <= qi(v, y, P))
              N = !1;
            else {
              var mt = v.x > y.x ? v.x > P.x ? v.x : P.x : y.x > P.x ? y.x : P.x, bt = v.y > y.y ? v.y > P.y ? v.y : P.y : y.y > P.y ? y.y : P.y;
              for (f = Ca(
                v.x < y.x ? v.x < P.x ? v.x : P.x : y.x < P.x ? y.x : P.x,
                v.y < y.y ? v.y < P.y ? v.y : P.y : y.y < P.y ? y.y : P.y,
                S,
                et,
                _t
              ), S = Ca(mt, bt, S, et, _t), et = N.nextZ; et && et.z <= S; ) {
                if (et !== N.prev && et !== N.next && Pa(v.x, v.y, y.x, y.y, P.x, P.y, et.x, et.y) && 0 <= qi(et.prev, et, et.next)) {
                  N = !1;
                  break t;
                }
                et = et.nextZ;
              }
              for (et = N.prevZ; et && et.z >= f; ) {
                if (et !== N.prev && et !== N.next && Pa(v.x, v.y, y.x, y.y, P.x, P.y, et.x, et.y) && 0 <= qi(et.prev, et, et.next)) {
                  N = !1;
                  break t;
                }
                et = et.prevZ;
              }
              N = !0;
            }
          }
        else
          t:
            if (N = t, v = N.prev, y = N, P = N.next, 0 <= qi(v, y, P))
              N = !1;
            else {
              for (f = N.next.next; f !== N.prev; ) {
                if (Pa(v.x, v.y, y.x, y.y, P.x, P.y, f.x, f.y) && 0 <= qi(f.prev, f, f.next)) {
                  N = !1;
                  break t;
                }
                f = f.next;
              }
              N = !0;
            }
        if (N)
          e.push(c.i / i), e.push(t.i / i), e.push(j.i / i), Vi(t), h = t = j.next;
        else if (t = j, t === h) {
          if (!l)
            ws(xs(t), e, i, n, o, s, 1);
          else if (l === 1) {
            l = e, h = i, c = t;
            do
              j = c.prev, N = c.next.next, !Bo(j, N) && il(j, c, c.next, N) && hr(j, N) && hr(N, j) && (l.push(j.i / h), l.push(c.i / h), l.push(N.i / h), Vi(c), Vi(c.next), c = t = N), c = c.next;
            while (c !== t);
            t = c, ws(t, e, i, n, o, s, 2);
          } else if (l === 2)
            t: {
              l = t;
              do {
                for (h = l.next.next; h !== l.prev; ) {
                  if (c = l.i !== h.i) {
                    if (c = l, j = h, N = c.next.i !== j.i && c.prev.i !== j.i) {
                      e: {
                        N = c;
                        do {
                          if (N.i !== c.i && N.next.i !== c.i && N.i !== j.i && N.next.i !== j.i && il(N, N.next, c, j)) {
                            N = !0;
                            break e;
                          }
                          N = N.next;
                        } while (N !== c);
                        N = !1;
                      }
                      N = !N;
                    }
                    if (N = N && hr(c, j) && hr(j, c)) {
                      N = c, v = !1, y = (c.x + j.x) / 2, j = (c.y + j.y) / 2;
                      do
                        N.y > j != N.next.y > j && N.next.y !== N.y && y < (N.next.x - N.x) * (j - N.y) / (N.next.y - N.y) + N.x && (v = !v), N = N.next;
                      while (N !== c);
                      N = v;
                    }
                    c = N;
                  }
                  if (c) {
                    t = $s(l, h), l = xs(l, l.next), t = xs(t, t.next), ws(l, e, i, n, o, s), ws(t, e, i, n, o, s);
                    break t;
                  }
                  h = h.next;
                }
                l = l.next;
              } while (l !== t);
            }
          break;
        }
      }
    }
  }
  function bl(t, e) {
    return t.x - e.x;
  }
  function Al(t, e) {
    var i = e, n = t.x, o = t.y, s = -1 / 0;
    do {
      if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
        var l = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
        if (l <= n && l > s) {
          if (s = l, l === n) {
            if (o === i.y)
              return i;
            if (o === i.next.y)
              return i.next;
          }
          var h = i.x < i.next.x ? i : i.next;
        }
      }
      i = i.next;
    } while (i !== e);
    if (!h)
      return null;
    if (n === s)
      return h.prev;
    e = h, l = h.x;
    var c = h.y, f = 1 / 0;
    for (i = h.next; i !== e; ) {
      if (n >= i.x && i.x >= l && n !== i.x && Pa(o < c ? n : s, o, l, c, o < c ? s : n, o, i.x, i.y)) {
        var v = Math.abs(o - i.y) / (n - i.x);
        (v < f || v === f && i.x > h.x) && hr(i, t) && (h = i, f = v);
      }
      i = i.next;
    }
    return h;
  }
  function Ca(t, e, i, n, o) {
    return t = 32767 * (t - i) * o, e = 32767 * (e - n) * o, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, (t | t << 1) & 1431655765 | ((e | e << 1) & 1431655765) << 1;
  }
  function er(t) {
    var e = t, i = t;
    do
      e.x < i.x && (i = e), e = e.next;
    while (e !== t);
    return i;
  }
  function Pa(t, e, i, n, o, s, l, h) {
    return 0 <= (o - l) * (e - h) - (t - l) * (s - h) && 0 <= (t - l) * (n - h) - (i - l) * (e - h) && 0 <= (i - l) * (s - h) - (o - l) * (n - h);
  }
  function qi(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function Bo(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function il(t, e, i, n) {
    return Bo(t, e) && Bo(i, n) || Bo(t, n) && Bo(i, e) ? !0 : 0 < qi(t, e, i) != 0 < qi(t, e, n) && 0 < qi(i, n, t) != 0 < qi(i, n, e);
  }
  function hr(t, e) {
    return 0 > qi(t.prev, t, t.next) ? 0 <= qi(t, e, t.next) && 0 <= qi(t, t.prev, e) : 0 > qi(t, e, t.prev) || 0 > qi(t, t.next, e);
  }
  function $s(t, e) {
    var i = new Br(t.i, t.x, t.y), n = new Br(e.i, e.x, e.y), o = t.next, s = e.prev;
    return t.next = e, e.prev = t, i.next = o, o.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n;
  }
  function La(t, e, i, n) {
    return t = new Br(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t;
  }
  function Vi(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function Br(t, e, i) {
    this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1;
  }
  function Ra(t) {
    var e = t.length;
    2 < e && t[e - 1].equals(t[0]) && t.pop();
  }
  function Cl(t, e) {
    for (var i = 0; i < e.length; i++)
      t.push(e[i].x), t.push(e[i].y);
  }
  function Kr(t, e) {
    V.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new Nr(t, e)), this.mergeVertices();
  }
  function Nr(t, e) {
    function i(c) {
      function f(Xe, ri, Ai) {
        return ri || console.error("THREE.ExtrudeGeometry: vec does not exist"), ri.clone().multiplyScalar(Ai).add(Xe);
      }
      function v(Xe, ri, Ai) {
        var bi = Xe.x - ri.x, ne = Xe.y - ri.y, ii = Ai.x - Xe.x, Ze = Ai.y - Xe.y, ai = bi * bi + ne * ne;
        if (Math.abs(bi * Ze - ne * ii) > Number.EPSILON) {
          var fn = Math.sqrt(ai), xn = Math.sqrt(ii * ii + Ze * Ze);
          if (ai = ri.x - ne / fn, ri = ri.y + bi / fn, Ze = ((Ai.x - Ze / xn - ai) * Ze - (Ai.y + ii / xn - ri) * ii) / (bi * Ze - ne * ii), ii = ai + bi * Ze - Xe.x, bi = ri + ne * Ze - Xe.y, ne = ii * ii + bi * bi, 2 >= ne)
            return new p(ii, bi);
          ne = Math.sqrt(ne / 2);
        } else
          Xe = !1, bi > Number.EPSILON ? ii > Number.EPSILON && (Xe = !0) : bi < -Number.EPSILON ? ii < -Number.EPSILON && (Xe = !0) : Math.sign(ne) === Math.sign(Ze) && (Xe = !0), Xe ? (ii = -ne, ne = Math.sqrt(ai)) : (ii = bi, bi = ne, ne = Math.sqrt(ai / 2));
        return new p(ii / ne, bi / ne);
      }
      function y(Xe, ri) {
        for (Ae = Xe.length; 0 <= --Ae; ) {
          var Ai = Ae, bi = Ae - 1;
          0 > bi && (bi = Xe.length - 1);
          var ne, ii = mt + 2 * it;
          for (ne = 0; ne < ii; ne++) {
            var Ze = Fi * ne, ai = Fi * (ne + 1), fn = ri + bi + Ze, xn = ri + bi + ai;
            ai = ri + Ai + ai, N(ri + Ai + Ze), N(fn), N(ai), N(fn), N(xn), N(ai), Ze = o.length / 3, Ze = ee.generateSideWallUV(n, o, Ze - 6, Ze - 3, Ze - 2, Ze - 1), j(Ze[0]), j(Ze[1]), j(Ze[3]), j(Ze[1]), j(Ze[2]), j(Ze[3]);
          }
        }
      }
      function S(Xe, ri, Ai) {
        et.push(Xe), et.push(ri), et.push(Ai);
      }
      function P(Xe, ri, Ai) {
        N(Xe), N(ri), N(Ai), Xe = o.length / 3, Xe = ee.generateTopUV(n, o, Xe - 3, Xe - 2, Xe - 1), j(Xe[0]), j(Xe[1]), j(Xe[2]);
      }
      function N(Xe) {
        o.push(et[3 * Xe]), o.push(et[3 * Xe + 1]), o.push(et[3 * Xe + 2]);
      }
      function j(Xe) {
        s.push(Xe.x), s.push(Xe.y);
      }
      var et = [], _t = e.curveSegments !== void 0 ? e.curveSegments : 12, mt = e.steps !== void 0 ? e.steps : 1, bt = e.depth !== void 0 ? e.depth : 100, xt = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, Wt = e.bevelThickness !== void 0 ? e.bevelThickness : 6, W = e.bevelSize !== void 0 ? e.bevelSize : Wt - 2, it = e.bevelSegments !== void 0 ? e.bevelSegments : 3, It = e.extrudePath, ee = e.UVGenerator !== void 0 ? e.UVGenerator : ga;
      e.amount !== void 0 && (console.warn(
        "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
      ), bt = e.amount);
      var $t = !1;
      if (It) {
        var qt = It.getSpacedPoints(mt);
        $t = !0, xt = !1;
        var Te = It.computeFrenetFrames(mt, !1), pe = new m(), Oe = new m(), be = new m();
      }
      xt || (W = Wt = it = 0);
      var se;
      _t = c.extractPoints(_t), c = _t.shape;
      var je = _t.holes;
      if (!Vr.isClockWise(c)) {
        c = c.reverse();
        var Ke = 0;
        for (se = je.length; Ke < se; Ke++) {
          var ci = je[Ke];
          Vr.isClockWise(ci) && (je[Ke] = ci.reverse());
        }
      }
      var yn = Vr.triangulateShape(c, je), cn = c;
      for (Ke = 0, se = je.length; Ke < se; Ke++)
        ci = je[Ke], c = c.concat(ci);
      var ji, Fi = c.length, Qi, _n = yn.length;
      _t = [];
      var Ae = 0, Qe = cn.length, Ut = Qe - 1;
      for (ji = Ae + 1; Ae < Qe; Ae++, Ut++, ji++)
        Ut === Qe && (Ut = 0), ji === Qe && (ji = 0), _t[Ae] = v(cn[Ae], cn[Ut], cn[ji]);
      It = [];
      var Ye = _t.concat();
      for (Ke = 0, se = je.length; Ke < se; Ke++) {
        ci = je[Ke];
        var ei = [];
        for (Ae = 0, Qe = ci.length, Ut = Qe - 1, ji = Ae + 1; Ae < Qe; Ae++, Ut++, ji++)
          Ut === Qe && (Ut = 0), ji === Qe && (ji = 0), ei[Ae] = v(ci[Ae], ci[Ut], ci[ji]);
        It.push(ei), Ye = Ye.concat(ei);
      }
      for (Ut = 0; Ut < it; Ut++) {
        Qe = Ut / it;
        var Gi = Wt * Math.cos(Qe * Math.PI / 2);
        for (ji = W * Math.sin(Qe * Math.PI / 2), Ae = 0, Qe = cn.length; Ae < Qe; Ae++) {
          var Ce = f(cn[Ae], _t[Ae], ji);
          S(Ce.x, Ce.y, -Gi);
        }
        for (Ke = 0, se = je.length; Ke < se; Ke++)
          for (ci = je[Ke], ei = It[Ke], Ae = 0, Qe = ci.length; Ae < Qe; Ae++)
            Ce = f(ci[Ae], ei[Ae], ji), S(Ce.x, Ce.y, -Gi);
      }
      for (ji = W, Ae = 0; Ae < Fi; Ae++)
        Ce = xt ? f(c[Ae], Ye[Ae], ji) : c[Ae], $t ? (Oe.copy(Te.normals[0]).multiplyScalar(Ce.x), pe.copy(Te.binormals[0]).multiplyScalar(Ce.y), be.copy(qt[0]).add(Oe).add(pe), S(be.x, be.y, be.z)) : S(Ce.x, Ce.y, 0);
      for (Qe = 1; Qe <= mt; Qe++)
        for (Ae = 0; Ae < Fi; Ae++)
          Ce = xt ? f(c[Ae], Ye[Ae], ji) : c[Ae], $t ? (Oe.copy(Te.normals[Qe]).multiplyScalar(Ce.x), pe.copy(Te.binormals[Qe]).multiplyScalar(Ce.y), be.copy(qt[Qe]).add(Oe).add(pe), S(be.x, be.y, be.z)) : S(Ce.x, Ce.y, bt / mt * Qe);
      for (Ut = it - 1; 0 <= Ut; Ut--) {
        for (Qe = Ut / it, Gi = Wt * Math.cos(Qe * Math.PI / 2), ji = W * Math.sin(Qe * Math.PI / 2), Ae = 0, Qe = cn.length; Ae < Qe; Ae++)
          Ce = f(cn[Ae], _t[Ae], ji), S(Ce.x, Ce.y, bt + Gi);
        for (Ke = 0, se = je.length; Ke < se; Ke++)
          for (ci = je[Ke], ei = It[Ke], Ae = 0, Qe = ci.length; Ae < Qe; Ae++)
            Ce = f(ci[Ae], ei[Ae], ji), $t ? S(Ce.x, Ce.y + qt[mt - 1].y, qt[mt - 1].x + Gi) : S(Ce.x, Ce.y, bt + Gi);
      }
      (function() {
        var Xe = o.length / 3;
        if (xt) {
          var ri = 0 * Fi;
          for (Ae = 0; Ae < _n; Ae++)
            Qi = yn[Ae], P(Qi[2] + ri, Qi[1] + ri, Qi[0] + ri);
          for (ri = Fi * (mt + 2 * it), Ae = 0; Ae < _n; Ae++)
            Qi = yn[Ae], P(Qi[0] + ri, Qi[1] + ri, Qi[2] + ri);
        } else {
          for (Ae = 0; Ae < _n; Ae++)
            Qi = yn[Ae], P(Qi[2], Qi[1], Qi[0]);
          for (Ae = 0; Ae < _n; Ae++)
            Qi = yn[Ae], P(Qi[0] + Fi * mt, Qi[1] + Fi * mt, Qi[2] + Fi * mt);
        }
        n.addGroup(Xe, o.length / 3 - Xe, 0);
      })(), function() {
        var Xe = o.length / 3, ri = 0;
        for (y(cn, ri), ri += cn.length, Ke = 0, se = je.length; Ke < se; Ke++)
          ci = je[Ke], y(ci, ri), ri += ci.length;
        n.addGroup(Xe, o.length / 3 - Xe, 1);
      }();
    }
    Ft.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
    for (var n = this, o = [], s = [], l = 0, h = t.length; l < h; l++)
      i(t[l]);
    this.addAttribute("position", new Ct(o, 3)), this.addAttribute("uv", new Ct(s, 2)), this.computeVertexNormals();
  }
  function Pl(t, e, i) {
    if (i.shapes = [], Array.isArray(t))
      for (var n = 0, o = t.length; n < o; n++)
        i.shapes.push(t[n].uuid);
    else
      i.shapes.push(t.uuid);
    return e.extrudePath !== void 0 && (i.options.extrudePath = e.extrudePath.toJSON()), i;
  }
  function Ks(t, e) {
    V.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new No(t, e)), this.mergeVertices();
  }
  function No(t, e) {
    e = e || {};
    var i = e.font;
    if (!i || !i.isFont)
      return console.error(
        "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
      ), new V();
    t = i.generateShapes(t, e.size), e.depth = e.height !== void 0 ? e.height : 50, e.bevelThickness === void 0 && (e.bevelThickness = 10), e.bevelSize === void 0 && (e.bevelSize = 8), e.bevelEnabled === void 0 && (e.bevelEnabled = !1), Nr.call(this, t, e), this.type = "TextBufferGeometry";
  }
  function mo(t, e, i, n, o, s, l) {
    V.call(this), this.type = "SphereGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: o,
      thetaStart: s,
      thetaLength: l
    }, this.fromBufferGeometry(new ur(t, e, i, n, o, s, l)), this.mergeVertices();
  }
  function ur(t, e, i, n, o, s, l) {
    Ft.call(this), this.type = "SphereBufferGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: o,
      thetaStart: s,
      thetaLength: l
    }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = n !== void 0 ? n : 0, o = o !== void 0 ? o : 2 * Math.PI, s = s !== void 0 ? s : 0, l = l !== void 0 ? l : Math.PI;
    var h = s + l, c, f, v = 0, y = [], S = new m(), P = new m(), N = [], j = [], et = [], _t = [];
    for (f = 0; f <= i; f++) {
      var mt = [], bt = f / i;
      for (c = 0; c <= e; c++) {
        var xt = c / e;
        S.x = -t * Math.cos(n + xt * o) * Math.sin(s + bt * l), S.y = t * Math.cos(s + bt * l), S.z = t * Math.sin(n + xt * o) * Math.sin(s + bt * l), j.push(S.x, S.y, S.z), P.set(S.x, S.y, S.z).normalize(), et.push(P.x, P.y, P.z), _t.push(xt, 1 - bt), mt.push(v++);
      }
      y.push(mt);
    }
    for (f = 0; f < i; f++)
      for (c = 0; c < e; c++)
        t = y[f][c + 1], n = y[f][c], o = y[f + 1][c], l = y[f + 1][c + 1], (f !== 0 || 0 < s) && N.push(t, n, l), (f !== i - 1 || h < Math.PI) && N.push(n, o, l);
    this.setIndex(N), this.addAttribute("position", new Ct(j, 3)), this.addAttribute("normal", new Ct(et, 3)), this.addAttribute("uv", new Ct(_t, 2));
  }
  function Qs(t, e, i, n, o, s) {
    V.call(this), this.type = "RingGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: o,
      thetaLength: s
    }, this.fromBufferGeometry(new ko(t, e, i, n, o, s)), this.mergeVertices();
  }
  function ko(t, e, i, n, o, s) {
    Ft.call(this), this.type = "RingBufferGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: o,
      thetaLength: s
    }, t = t || 0.5, e = e || 1, o = o !== void 0 ? o : 0, s = s !== void 0 ? s : 2 * Math.PI, i = i !== void 0 ? Math.max(3, i) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
    var l = [], h = [], c = [], f = [], v = t, y = (e - t) / n, S = new m(), P = new p(), N, j;
    for (N = 0; N <= n; N++) {
      for (j = 0; j <= i; j++)
        t = o + j / i * s, S.x = v * Math.cos(t), S.y = v * Math.sin(t), h.push(S.x, S.y, S.z), c.push(0, 0, 1), P.x = (S.x / e + 1) / 2, P.y = (S.y / e + 1) / 2, f.push(P.x, P.y);
      v += y;
    }
    for (N = 0; N < n; N++)
      for (e = N * (i + 1), j = 0; j < i; j++)
        t = j + e, o = t + i + 1, s = t + i + 2, v = t + 1, l.push(t, o, v), l.push(o, s, v);
    this.setIndex(l), this.addAttribute("position", new Ct(h, 3)), this.addAttribute("normal", new Ct(c, 3)), this.addAttribute("uv", new Ct(f, 2));
  }
  function Ts(t, e, i, n) {
    V.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, this.fromBufferGeometry(new go(t, e, i, n)), this.mergeVertices();
  }
  function go(t, e, i, n) {
    Ft.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = fi.clamp(n, 0, 2 * Math.PI);
    var o = [], s = [], l = [], h = 1 / e, c = new m(), f = new p(), v;
    for (v = 0; v <= e; v++) {
      var y = i + v * h * n, S = Math.sin(y), P = Math.cos(y);
      for (y = 0; y <= t.length - 1; y++)
        c.x = t[y].x * S, c.y = t[y].y, c.z = t[y].x * P, s.push(c.x, c.y, c.z), f.x = v / e, f.y = y / (t.length - 1), l.push(f.x, f.y);
    }
    for (v = 0; v < e; v++)
      for (y = 0; y < t.length - 1; y++)
        i = y + v * t.length, h = i + t.length, c = i + t.length + 1, f = i + 1, o.push(i, h, f), o.push(h, c, f);
    if (this.setIndex(o), this.addAttribute("position", new Ct(s, 3)), this.addAttribute("uv", new Ct(l, 2)), this.computeVertexNormals(), n === 2 * Math.PI)
      for (n = this.attributes.normal.array, o = new m(), s = new m(), l = new m(), i = e * t.length * 3, y = v = 0; v < t.length; v++, y += 3)
        o.x = n[y + 0], o.y = n[y + 1], o.z = n[y + 2], s.x = n[i + y + 0], s.y = n[i + y + 1], s.z = n[i + y + 2], l.addVectors(o, s).normalize(), n[y + 0] = n[i + y + 0] = l.x, n[y + 1] = n[i + y + 1] = l.y, n[y + 2] = n[i + y + 2] = l.z;
  }
  function Qr(t, e) {
    V.call(this), this.type = "ShapeGeometry", typeof e == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new vo(t, e)), this.mergeVertices();
  }
  function vo(t, e) {
    function i(v) {
      var y, S = o.length / 3;
      v = v.extractPoints(e);
      var P = v.shape, N = v.holes;
      if (Vr.isClockWise(P) === !1)
        for (P = P.reverse(), v = 0, y = N.length; v < y; v++) {
          var j = N[v];
          Vr.isClockWise(j) === !0 && (N[v] = j.reverse());
        }
      var et = Vr.triangulateShape(P, N);
      for (v = 0, y = N.length; v < y; v++)
        j = N[v], P = P.concat(j);
      for (v = 0, y = P.length; v < y; v++)
        j = P[v], o.push(j.x, j.y, 0), s.push(0, 0, 1), l.push(j.x, j.y);
      for (v = 0, y = et.length; v < y; v++)
        P = et[v], n.push(P[0] + S, P[1] + S, P[2] + S), c += 3;
    }
    Ft.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12;
    var n = [], o = [], s = [], l = [], h = 0, c = 0;
    if (Array.isArray(t) === !1)
      i(t);
    else
      for (var f = 0; f < t.length; f++)
        i(t[f]), this.addGroup(h, c, f), h += c, c = 0;
    this.setIndex(n), this.addAttribute("position", new Ct(o, 3)), this.addAttribute("normal", new Ct(s, 3)), this.addAttribute("uv", new Ct(l, 2));
  }
  function Ll(t, e) {
    if (e.shapes = [], Array.isArray(t))
      for (var i = 0, n = t.length; i < n; i++)
        e.shapes.push(t[i].uuid);
    else
      e.shapes.push(t.uuid);
    return e;
  }
  function yo(t, e) {
    Ft.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e };
    var i = [];
    e = Math.cos(fi.DEG2RAD * (e !== void 0 ? e : 1));
    var n = [0, 0], o = {}, s = ["a", "b", "c"];
    if (t.isBufferGeometry) {
      var l = new V();
      l.fromBufferGeometry(t);
    } else
      l = t.clone();
    l.mergeVertices(), l.computeFaceNormals(), t = l.vertices, l = l.faces;
    for (var h = 0, c = l.length; h < c; h++)
      for (var f = l[h], v = 0; 3 > v; v++) {
        var y = f[s[v]], S = f[s[(v + 1) % 3]];
        n[0] = Math.min(y, S), n[1] = Math.max(y, S), y = n[0] + "," + n[1], o[y] === void 0 ? o[y] = { index1: n[0], index2: n[1], face1: h, face2: void 0 } : o[y].face2 = h;
      }
    for (y in o)
      n = o[y], (n.face2 === void 0 || l[n.face1].normal.dot(l[n.face2].normal) <= e) && (s = t[n.index1], i.push(s.x, s.y, s.z), s = t[n.index2], i.push(s.x, s.y, s.z));
    this.addAttribute("position", new Ct(i, 3));
  }
  function to(t, e, i, n, o, s, l, h) {
    V.call(this), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: o,
      openEnded: s,
      thetaStart: l,
      thetaLength: h
    }, this.fromBufferGeometry(new eo(t, e, i, n, o, s, l, h)), this.mergeVertices();
  }
  function eo(t, e, i, n, o, s, l, h) {
    function c(mt) {
      var bt, xt = new p(), Wt = new m(), W = 0, it = mt === !0 ? t : e, It = mt === !0 ? 1 : -1, ee = N;
      for (bt = 1; bt <= n; bt++)
        y.push(0, et * It, 0), S.push(0, It, 0), P.push(0.5, 0.5), N++;
      var $t = N;
      for (bt = 0; bt <= n; bt++) {
        var qt = bt / n * h + l, Te = Math.cos(qt);
        qt = Math.sin(qt), Wt.x = it * qt, Wt.y = et * It, Wt.z = it * Te, y.push(Wt.x, Wt.y, Wt.z), S.push(0, It, 0), xt.x = 0.5 * Te + 0.5, xt.y = 0.5 * qt * It + 0.5, P.push(xt.x, xt.y), N++;
      }
      for (bt = 0; bt < n; bt++)
        xt = ee + bt, Wt = $t + bt, mt === !0 ? v.push(Wt, Wt + 1, xt) : v.push(Wt + 1, Wt, xt), W += 3;
      f.addGroup(_t, W, mt === !0 ? 1 : 2), _t += W;
    }
    Ft.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: o,
      openEnded: s,
      thetaStart: l,
      thetaLength: h
    };
    var f = this;
    t = t !== void 0 ? t : 1, e = e !== void 0 ? e : 1, i = i || 1, n = Math.floor(n) || 8, o = Math.floor(o) || 1, s = s !== void 0 ? s : !1, l = l !== void 0 ? l : 0, h = h !== void 0 ? h : 2 * Math.PI;
    var v = [], y = [], S = [], P = [], N = 0, j = [], et = i / 2, _t = 0;
    (function() {
      var mt, bt, xt = new m(), Wt = new m(), W = 0, it = (e - t) / i;
      for (bt = 0; bt <= o; bt++) {
        var It = [], ee = bt / o, $t = ee * (e - t) + t;
        for (mt = 0; mt <= n; mt++) {
          var qt = mt / n, Te = qt * h + l, pe = Math.sin(Te);
          Te = Math.cos(Te), Wt.x = $t * pe, Wt.y = -ee * i + et, Wt.z = $t * Te, y.push(Wt.x, Wt.y, Wt.z), xt.set(pe, it, Te).normalize(), S.push(xt.x, xt.y, xt.z), P.push(qt, 1 - ee), It.push(N++);
        }
        j.push(It);
      }
      for (mt = 0; mt < n; mt++)
        for (bt = 0; bt < o; bt++)
          xt = j[bt + 1][mt], Wt = j[bt + 1][mt + 1], it = j[bt][mt + 1], v.push(j[bt][mt], xt, it), v.push(xt, Wt, it), W += 6;
      f.addGroup(_t, W, 0), _t += W;
    })(), s === !1 && (0 < t && c(!0), 0 < e && c(!1)), this.setIndex(v), this.addAttribute("position", new Ct(y, 3)), this.addAttribute("normal", new Ct(S, 3)), this.addAttribute("uv", new Ct(P, 2));
  }
  function Ms(t, e, i, n, o, s, l) {
    to.call(this, 0, t, e, i, n, o, s, l), this.type = "ConeGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: o,
      thetaStart: s,
      thetaLength: l
    };
  }
  function Ln(t, e, i, n, o, s, l) {
    eo.call(this, 0, t, e, i, n, o, s, l), this.type = "ConeBufferGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: o,
      thetaStart: s,
      thetaLength: l
    };
  }
  function Uo(t, e, i, n) {
    V.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new kr(t, e, i, n)), this.mergeVertices();
  }
  function kr(t, e, i, n) {
    Ft.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, t = t || 1, e = e !== void 0 ? Math.max(3, e) : 8, i = i !== void 0 ? i : 0, n = n !== void 0 ? n : 2 * Math.PI;
    var o = [], s = [], l = [], h = [], c, f = new m(), v = new p();
    s.push(0, 0, 0), l.push(0, 0, 1), h.push(0.5, 0.5);
    var y = 0;
    for (c = 3; y <= e; y++, c += 3) {
      var S = i + y / e * n;
      f.x = t * Math.cos(S), f.y = t * Math.sin(S), s.push(f.x, f.y, f.z), l.push(0, 0, 1), v.x = (s[c] / t + 1) / 2, v.y = (s[c + 1] / t + 1) / 2, h.push(v.x, v.y);
    }
    for (c = 1; c <= e; c++)
      o.push(c, c + 1, 0);
    this.setIndex(o), this.addAttribute("position", new Ct(s, 3)), this.addAttribute("normal", new Ct(l, 3)), this.addAttribute("uv", new Ct(h, 2));
  }
  function _o(t) {
    Zt.call(this), this.type = "ShadowMaterial", this.color = new A(0), this.transparent = !0, this.setValues(t);
  }
  function Fo(t) {
    ti.call(this, t), this.type = "RawShaderMaterial";
  }
  function Ur(t) {
    Zt.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new A(16777215), this.metalness = this.roughness = 0.5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new p(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Go(t) {
    Ur.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t);
  }
  function Sr(t) {
    Zt.call(this), this.type = "MeshPhongMaterial", this.color = new A(16777215), this.specular = new A(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new p(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Ho(t) {
    Sr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t);
  }
  function Wo(t) {
    Zt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new p(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t);
  }
  function cr(t) {
    Zt.call(this), this.type = "MeshLambertMaterial", this.color = new A(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function jo(t) {
    if (Zt.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new A(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new p(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t), this.matcap === null) {
      t = document.createElement("canvas"), t.width = 1, t.height = 1;
      var e = t.getContext("2d");
      e.fillStyle = "#fff", e.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t);
    }
  }
  function Vo(t) {
    Di.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
  }
  function kn(t, e, i, n) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i;
  }
  function ta(t, e, i, n) {
    kn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function fr(t, e, i, n) {
    kn.call(this, t, e, i, n);
  }
  function Xo(t, e, i, n) {
    kn.call(this, t, e, i, n);
  }
  function Rn(t, e, i, n) {
    if (t === void 0)
      throw Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = zn.convertArray(e, this.TimeBufferType), this.values = zn.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  function Ia(t, e, i) {
    Rn.call(this, t, e, i);
  }
  function Oa(t, e, i, n) {
    Rn.call(this, t, e, i, n);
  }
  function Er(t, e, i, n) {
    Rn.call(this, t, e, i, n);
  }
  function Vn(t, e, i, n) {
    kn.call(this, t, e, i, n);
  }
  function Ss(t, e, i, n) {
    Rn.call(this, t, e, i, n);
  }
  function Da(t, e, i, n) {
    Rn.call(this, t, e, i, n);
  }
  function Es(t, e, i, n) {
    Rn.call(this, t, e, i, n);
  }
  function ir(t, e, i) {
    this.name = t, this.tracks = i, this.duration = e !== void 0 ? e : -1, this.uuid = fi.generateUUID(), 0 > this.duration && this.resetDuration();
  }
  function lh(t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Er;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Es;
      case "color":
        return Oa;
      case "quaternion":
        return Ss;
      case "bool":
      case "boolean":
        return Ia;
      case "string":
        return Da;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }
  function hh(t) {
    if (t.type === void 0)
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var e = lh(t.type);
    if (t.times === void 0) {
      var i = [], n = [];
      zn.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n;
    }
    return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
  }
  function xo(t, e, i) {
    var n = this, o = !1, s = 0, l = 0, h = void 0;
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(c) {
      l++, o === !1 && n.onStart !== void 0 && n.onStart(c, s, l), o = !0;
    }, this.itemEnd = function(c) {
      s++, n.onProgress !== void 0 && n.onProgress(c, s, l), s === l && (o = !1, n.onLoad !== void 0) && n.onLoad();
    }, this.itemError = function(c) {
      n.onError !== void 0 && n.onError(c);
    }, this.resolveURL = function(c) {
      return h ? h(c) : c;
    }, this.setURLModifier = function(c) {
      return h = c, this;
    };
  }
  function At(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function Qt(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function Yt(t) {
    this.manager = t !== void 0 ? t : Gn, this._parser = null;
  }
  function Ue(t) {
    this.manager = t !== void 0 ? t : Gn, this._parser = null;
  }
  function si(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function zi(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function on(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function Ee() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  function Un(t, e, i, n, o, s, l, h) {
    Ee.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = o || 0, this.aEndAngle = s || 2 * Math.PI, this.aClockwise = l || !1, this.aRotation = h || 0;
  }
  function bs(t, e, i, n, o, s) {
    Un.call(this, t, e, i, i, n, o, s), this.type = "ArcCurve";
  }
  function Xn() {
    var t = 0, e = 0, i = 0, n = 0;
    return {
      initCatmullRom: function(o, s, l, h, c) {
        o = c * (l - o), h = c * (h - s), t = s, e = o, i = -3 * s + 3 * l - 2 * o - h, n = 2 * s - 2 * l + o + h;
      },
      initNonuniformCatmullRom: function(o, s, l, h, c, f, v) {
        o = ((s - o) / c - (l - o) / (c + f) + (l - s) / f) * f, h = ((l - s) / f - (h - s) / (f + v) + (h - l) / v) * f, t = s, e = o, i = -3 * s + 3 * l - 2 * o - h, n = 2 * s - 2 * l + o + h;
      },
      calc: function(o) {
        var s = o * o;
        return t + e * o + i * s + n * s * o;
      }
    };
  }
  function Tn(t, e, i, n) {
    Ee.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || 0.5;
  }
  function Rl(t, e, i, n, o) {
    e = 0.5 * (n - e), o = 0.5 * (o - i);
    var s = t * t;
    return (2 * i - 2 * n + e + o) * t * s + (-3 * i + 3 * n - 2 * e - o) * s + e * t + i;
  }
  function Fr(t, e, i, n) {
    var o = 1 - t;
    return o * o * e + 2 * (1 - t) * t * i + t * t * n;
  }
  function wo(t, e, i, n, o) {
    var s = 1 - t, l = 1 - t;
    return s * s * s * e + 3 * l * l * t * i + 3 * (1 - t) * t * t * n + t * t * t * o;
  }
  function qn(t, e, i, n) {
    Ee.call(this), this.type = "CubicBezierCurve", this.v0 = t || new p(), this.v1 = e || new p(), this.v2 = i || new p(), this.v3 = n || new p();
  }
  function wi(t, e, i, n) {
    Ee.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new m(), this.v1 = e || new m(), this.v2 = i || new m(), this.v3 = n || new m();
  }
  function Yn(t, e) {
    Ee.call(this), this.type = "LineCurve", this.v1 = t || new p(), this.v2 = e || new p();
  }
  function pr(t, e) {
    Ee.call(this), this.type = "LineCurve3", this.v1 = t || new m(), this.v2 = e || new m();
  }
  function Zn(t, e, i) {
    Ee.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new p(), this.v1 = e || new p(), this.v2 = i || new p();
  }
  function Gr(t, e, i) {
    Ee.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new m(), this.v1 = e || new m(), this.v2 = i || new m();
  }
  function br(t) {
    Ee.call(this), this.type = "SplineCurve", this.points = t || [];
  }
  function io() {
    Ee.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  function Jn(t) {
    io.call(this), this.type = "Path", this.currentPoint = new p(), t && this.setFromPoints(t);
  }
  function Fn(t) {
    Jn.call(this, t), this.uuid = fi.generateUUID(), this.type = "Shape", this.holes = [];
  }
  function Ji(t, e) {
    z.call(this), this.type = "Light", this.color = new A(t), this.intensity = e !== void 0 ? e : 1, this.receiveShadow = void 0;
  }
  function ea(t, e, i) {
    Ji.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(z.DefaultUp), this.updateMatrix(), this.groundColor = new A(e);
  }
  function Hr(t) {
    this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new p(512, 512), this.map = null, this.matrix = new $();
  }
  function ia() {
    Hr.call(this, new ye(50, 1, 0.5, 500));
  }
  function na(t, e, i, n, o, s) {
    Ji.call(this, t, e), this.type = "SpotLight", this.position.copy(z.DefaultUp), this.updateMatrix(), this.target = new z(), Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(l) {
        this.intensity = l / Math.PI;
      }
    }), this.distance = i !== void 0 ? i : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = o !== void 0 ? o : 0, this.decay = s !== void 0 ? s : 1, this.shadow = new ia();
  }
  function qo(t, e, i, n) {
    Ji.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
      get: function() {
        return 4 * this.intensity * Math.PI;
      },
      set: function(o) {
        this.intensity = o / (4 * Math.PI);
      }
    }), this.distance = i !== void 0 ? i : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new Hr(new ye(90, 1, 0.5, 500));
  }
  function As(t, e, i, n, o, s) {
    Be.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t !== void 0 ? t : -1, this.right = e !== void 0 ? e : 1, this.top = i !== void 0 ? i : 1, this.bottom = n !== void 0 ? n : -1, this.near = o !== void 0 ? o : 0.1, this.far = s !== void 0 ? s : 2e3, this.updateProjectionMatrix();
  }
  function To() {
    Hr.call(this, new As(-5, 5, 5, -5, 0.5, 500));
  }
  function Wr(t, e) {
    Ji.call(this, t, e), this.type = "DirectionalLight", this.position.copy(z.DefaultUp), this.updateMatrix(), this.target = new z(), this.shadow = new To();
  }
  function Yo(t, e) {
    Ji.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0;
  }
  function za(t, e, i, n) {
    Ji.call(this, t, e), this.type = "RectAreaLight", this.width = i !== void 0 ? i : 10, this.height = n !== void 0 ? n : 10;
  }
  function Ba(t) {
    this.manager = t !== void 0 ? t : Gn, this.textures = {};
  }
  function nl(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function no() {
  }
  function Zo(t) {
    typeof t == "boolean" && (console.warn(
      "THREE.JSONLoader: showStatus parameter has been removed from constructor."
    ), t = void 0), this.manager = t !== void 0 ? t : Gn, this.withCredentials = !1;
  }
  function ra(t) {
    this.manager = t !== void 0 ? t : Gn, this.resourcePath = "";
  }
  function rl(t) {
    typeof createImageBitmap > "u" && console.warn(
      "THREE.ImageBitmapLoader: createImageBitmap() not supported."
    ), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = t !== void 0 ? t : Gn, this.options = void 0;
  }
  function Na() {
    this.type = "ShapePath", this.color = new A(), this.subPaths = [], this.currentPath = null;
  }
  function ol(t) {
    this.type = "Font", this.data = t;
  }
  function Il(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function hn(t) {
    this.manager = t !== void 0 ? t : Gn;
  }
  function In() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ye(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ye(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
  }
  function oa(t, e, i, n) {
    z.call(this), this.type = "CubeCamera";
    var o = new ye(90, 1, t, e);
    o.up.set(0, -1, 0), o.lookAt(new m(1, 0, 0)), this.add(o);
    var s = new ye(90, 1, t, e);
    s.up.set(0, -1, 0), s.lookAt(new m(-1, 0, 0)), this.add(s);
    var l = new ye(90, 1, t, e);
    l.up.set(0, 0, 1), l.lookAt(new m(0, 1, 0)), this.add(l);
    var h = new ye(90, 1, t, e);
    h.up.set(0, 0, -1), h.lookAt(new m(0, -1, 0)), this.add(h);
    var c = new ye(90, 1, t, e);
    c.up.set(0, -1, 0), c.lookAt(new m(0, 0, 1)), this.add(c);
    var f = new ye(90, 1, t, e);
    f.up.set(0, -1, 0), f.lookAt(new m(0, 0, -1)), this.add(f), n = n || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new Y(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(v, y) {
      this.parent === null && this.updateMatrixWorld();
      var S = this.renderTarget, P = S.texture.generateMipmaps;
      S.texture.generateMipmaps = !1, S.activeCubeFace = 0, v.render(y, o, S), S.activeCubeFace = 1, v.render(y, s, S), S.activeCubeFace = 2, v.render(y, l, S), S.activeCubeFace = 3, v.render(y, h, S), S.activeCubeFace = 4, v.render(y, c, S), S.texture.generateMipmaps = P, S.activeCubeFace = 5, v.render(y, f, S), v.setRenderTarget(null);
    }, this.clear = function(v, y, S, P) {
      for (var N = this.renderTarget, j = 0; 6 > j; j++)
        N.activeCubeFace = j, v.setRenderTarget(N), v.clear(y, S, P);
      v.setRenderTarget(null);
    };
  }
  function sl(t) {
    this.autoStart = t !== void 0 ? t : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1;
  }
  function ka() {
    z.call(this), this.type = "AudioListener", this.context = gl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0;
  }
  function Cs(t) {
    z.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
  }
  function sa(t) {
    Cs.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
  }
  function Jo(t, e) {
    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e !== void 0 ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
  }
  function aa(t, e, i) {
    switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
      case "quaternion":
        e = this._slerp;
        break;
      case "string":
      case "bool":
        t = Array, e = this._select;
        break;
      default:
        e = this._lerp;
    }
    this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function $o(t, e, i) {
    i = i || gn.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }
  function gn(t, e, i) {
    this.path = e, this.parsedPath = i || gn.parseTrackName(e), this.node = gn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
  }
  function Ps() {
    this.uuid = fi.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var e = 0, i = arguments.length; e !== i; ++e)
      t[arguments[e].uuid] = e;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  function la(t, e, i) {
    this._mixer = t, this._clip = e, this._localRoot = i || null, t = e.tracks, e = t.length, i = Array(e);
    for (var n = { endingStart: 2400, endingEnd: 2400 }, o = 0; o !== e; ++o) {
      var s = t[o].createInterpolant(null);
      i[o] = s, s.settings = n;
    }
    this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function Mo(t) {
    this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
  }
  function Ua(t, e) {
    typeof t == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t;
  }
  function al() {
    Ft.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
  }
  function ll(t, e, i) {
    Ii.call(this, t, e), this.meshPerAttribute = i || 1;
  }
  function hl(t, e, i, n) {
    typeof i == "number" && (n = i, i = !1, console.error(
      "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
    )), ht.call(this, t, e, i), this.meshPerAttribute = n || 1;
  }
  function Ol(t, e, i, n) {
    this.ray = new Ni(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    }, Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          return console.warn(
            "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
          ), this.Points;
        }
      }
    });
  }
  function ha(t, e) {
    return t.distance - e.distance;
  }
  function Ko(t, e, i, n) {
    if (t.visible !== !1 && (t.raycast(e, i), n === !0)) {
      t = t.children, n = 0;
      for (var o = t.length; n < o; n++)
        Ko(t[n], e, i, !0);
    }
  }
  function ul(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.phi = e !== void 0 ? e : 0, this.theta = i !== void 0 ? i : 0, this;
  }
  function Q(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.theta = e !== void 0 ? e : 0, this.y = i !== void 0 ? i : 0, this;
  }
  function So(t, e) {
    this.min = t !== void 0 ? t : new p(1 / 0, 1 / 0), this.max = e !== void 0 ? e : new p(-1 / 0, -1 / 0);
  }
  function Ls(t, e) {
    this.start = t !== void 0 ? t : new m(), this.end = e !== void 0 ? e : new m();
  }
  function Dn(t) {
    z.call(this), this.material = t, this.render = function() {
    };
  }
  function yi(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16711680, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new Ft(), e = new Ct(6 * e, 3), i.addAttribute("position", e), mi.call(this, i, new Di({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function Rs(t, e) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new Ft(), e = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (var i = 0, n = 1; 32 > i; i++, n++) {
      var o = i / 32 * Math.PI * 2, s = n / 32 * Math.PI * 2;
      e.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
    }
    t.addAttribute("position", new Ct(e, 3)), e = new Di({ fog: !1 }), this.cone = new mi(t, e), this.add(this.cone), this.update();
  }
  function Dl(t) {
    var e = [];
    t && t.isBone && e.push(t);
    for (var i = 0; i < t.children.length; i++)
      e.push.apply(e, Dl(t.children[i]));
    return e;
  }
  function Is(t) {
    for (var e = Dl(t), i = new Ft(), n = [], o = [], s = new A(0, 0, 1), l = new A(0, 1, 0), h = 0; h < e.length; h++) {
      var c = e[h];
      c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(l.r, l.g, l.b));
    }
    i.addAttribute("position", new Ct(n, 3)), i.addAttribute("color", new Ct(o, 3)), n = new Di({
      vertexColors: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), mi.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
  }
  function dr(t, e, i) {
    this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new ur(e, 4, 2), e = new Ge({ wireframe: !0, fog: !1 }), pi.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  function Os(t, e) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new Di({ fog: !1 }), e = new Ft(), e.addAttribute("position", new ht(new Float32Array(15), 3)), this.line = new Hi(e, t), this.add(this.line), this.update();
  }
  function Ds(t, e, i) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t = new Oo(e), t.rotateY(0.5 * Math.PI), this.material = new Ge({ wireframe: !0, fog: !1 }), this.color === void 0 && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new ht(e, 3)), this.add(new pi(t, this.material)), this.update();
  }
  function ua(t, e, i, n) {
    t = t || 10, e = e || 10, i = new A(i !== void 0 ? i : 4473924), n = new A(n !== void 0 ? n : 8947848);
    var o = e / 2, s = t / e, l = t / 2;
    t = [];
    for (var h = [], c = 0, f = 0, v = -l; c <= e; c++, v += s) {
      t.push(-l, 0, v, l, 0, v), t.push(v, 0, -l, v, 0, l);
      var y = c === o ? i : n;
      y.toArray(h, f), f += 3, y.toArray(h, f), f += 3, y.toArray(h, f), f += 3, y.toArray(h, f), f += 3;
    }
    e = new Ft(), e.addAttribute("position", new Ct(t, 3)), e.addAttribute("color", new Ct(h, 3)), i = new Di({ vertexColors: 2 }), mi.call(this, e, i);
  }
  function Fa(t, e, i, n, o, s) {
    t = t || 10, e = e || 16, i = i || 8, n = n || 64, o = new A(o !== void 0 ? o : 4473924), s = new A(s !== void 0 ? s : 8947848);
    var l = [], h = [], c;
    for (c = 0; c <= e; c++) {
      var f = c / e * 2 * Math.PI, v = Math.sin(f) * t;
      f = Math.cos(f) * t, l.push(0, 0, 0), l.push(v, 0, f);
      var y = c & 1 ? o : s;
      h.push(y.r, y.g, y.b), h.push(y.r, y.g, y.b);
    }
    for (c = 0; c <= i; c++) {
      y = c & 1 ? o : s;
      var S = t - t / i * c;
      for (e = 0; e < n; e++)
        f = e / n * 2 * Math.PI, v = Math.sin(f) * S, f = Math.cos(f) * S, l.push(v, 0, f), h.push(y.r, y.g, y.b), f = (e + 1) / n * 2 * Math.PI, v = Math.sin(f) * S, f = Math.cos(f) * S, l.push(v, 0, f), h.push(y.r, y.g, y.b);
    }
    t = new Ft(), t.addAttribute("position", new Ct(l, 3)), t.addAttribute("color", new Ct(h, 3)), l = new Di({ vertexColors: 2 }), mi.call(this, t, l);
  }
  function ca(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16776960, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn(
      "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
    ), i = new Ft(), e = new Ct(6 * e, 3), i.addAttribute("position", e), mi.call(this, i, new Di({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function $n(t, e, i) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, e === void 0 && (e = 1), t = new Ft(), t.addAttribute(
      "position",
      new Ct([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    ), e = new Di({ fog: !1 }), this.lightPlane = new Hi(t, e), this.add(this.lightPlane), t = new Ft(), t.addAttribute("position", new Ct([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Hi(t, e), this.add(this.targetLine), this.update();
  }
  function fa(t) {
    function e(P, N, j) {
      i(P, j), i(N, j);
    }
    function i(P, N) {
      s.push(0, 0, 0), l.push(N.r, N.g, N.b), h[P] === void 0 && (h[P] = []), h[P].push(s.length / 3 - 1);
    }
    var n = new Ft(), o = new Di({ color: 16777215, vertexColors: 1 }), s = [], l = [], h = {}, c = new A(16755200), f = new A(16711680), v = new A(43775), y = new A(16777215), S = new A(3355443);
    e("n1", "n2", c), e("n2", "n4", c), e("n4", "n3", c), e("n3", "n1", c), e("f1", "f2", c), e("f2", "f4", c), e("f4", "f3", c), e("f3", "f1", c), e("n1", "f1", c), e("n2", "f2", c), e("n3", "f3", c), e("n4", "f4", c), e("p", "n1", f), e("p", "n2", f), e("p", "n3", f), e("p", "n4", f), e("u1", "u2", v), e("u2", "u3", v), e("u3", "u1", v), e("c", "t", y), e("p", "c", S), e("cn1", "cn2", S), e("cn3", "cn4", S), e("cf1", "cf2", S), e("cf3", "cf4", S), n.addAttribute("position", new Ct(s, 3)), n.addAttribute("color", new Ct(l, 3)), mi.call(this, n, o), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = h, this.update();
  }
  function ro(t, e) {
    this.object = t, e === void 0 && (e = 16776960), t = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Float32Array(24), n = new Ft();
    n.setIndex(new ht(t, 1)), n.addAttribute("position", new ht(i, 3)), mi.call(this, n, new Di({ color: e })), this.matrixAutoUpdate = !1, this.update();
  }
  function pa(t, e) {
    this.type = "Box3Helper", this.box = t, t = e !== void 0 ? e : 16776960, e = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Ft();
    i.setIndex(new ht(e, 1)), i.addAttribute(
      "position",
      new Ct(
        [
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          -1
        ],
        3
      )
    ), mi.call(this, i, new Di({ color: t })), this.geometry.computeBoundingSphere();
  }
  function da(t, e, i) {
    this.type = "PlaneHelper", this.plane = t, this.size = e === void 0 ? 1 : e, t = i !== void 0 ? i : 16776960, e = new Ft(), e.addAttribute(
      "position",
      new Ct(
        [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        3
      )
    ), e.computeBoundingSphere(), Hi.call(this, e, new Di({ color: t })), e = new Ft(), e.addAttribute(
      "position",
      new Ct([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    ), e.computeBoundingSphere(), this.add(
      new pi(
        e,
        new Ge({ color: t, opacity: 0.2, transparent: !0, depthWrite: !1 })
      )
    );
  }
  function oo(t, e, i, n, o, s) {
    z.call(this), t === void 0 && (t = new THREE.Vector3(0, 0, 1)), e === void 0 && (e = new THREE.Vector3(0, 0, 0)), i === void 0 && (i = 1), n === void 0 && (n = 16776960), o === void 0 && (o = 0.2 * i), s === void 0 && (s = 0.2 * o), Xa === void 0 && (Xa = new Ft(), Xa.addAttribute("position", new Ct([0, 0, 0, 0, 1, 0], 3)), ya = new eo(0, 0.5, 1, 5, 1), ya.translate(0, -0.5, 0)), this.position.copy(e), this.line = new Hi(Xa, new Di({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new pi(ya, new Ge({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, o, s);
  }
  function nr(t) {
    t = t || 1;
    var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
    t = new Ft(), t.addAttribute("position", new Ct(e, 3)), t.addAttribute(
      "color",
      new Ct([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
    ), e = new Di({ vertexColors: 2 }), mi.call(this, t, e);
  }
  function zl(t) {
    console.warn(
      "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), Tn.call(this, t), this.type = "catmullrom", this.closed = !0;
  }
  function Bl(t) {
    console.warn(
      "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), Tn.call(this, t), this.type = "catmullrom";
  }
  function cl(t) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
    ), Tn.call(this, t), this.type = "catmullrom";
  }
  Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52)), Number.isInteger === void 0 && (Number.isInteger = function(t) {
    return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
  }), Math.sign === void 0 && (Math.sign = function(t) {
    return 0 > t ? -1 : 0 < t ? 1 : +t;
  }), !("name" in Function.prototype) && Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  }), Object.assign === void 0 && function() {
    Object.assign = function(t) {
      if (t == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var e = Object(t), i = 1; i < arguments.length; i++) {
        var n = arguments[i];
        if (n != null)
          for (var o in n)
            Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    };
  }(), Object.assign(J.prototype, {
    addEventListener: function(t, e) {
      this._listeners === void 0 && (this._listeners = {});
      var i = this._listeners;
      i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
    },
    hasEventListener: function(t, e) {
      if (this._listeners === void 0)
        return !1;
      var i = this._listeners;
      return i[t] !== void 0 && i[t].indexOf(e) !== -1;
    },
    removeEventListener: function(t, e) {
      this._listeners !== void 0 && (t = this._listeners[t], t !== void 0 && (e = t.indexOf(e), e !== -1 && t.splice(e, 1)));
    },
    dispatchEvent: function(t) {
      if (this._listeners !== void 0) {
        var e = this._listeners[t.type];
        if (e !== void 0) {
          t.target = this, e = e.slice(0);
          for (var i = 0, n = e.length; i < n; i++)
            e[i].call(this, t);
        }
      }
    }
  });
  var fi = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      for (var t = [], e = 0; 256 > e; e++)
        t[e] = (16 > e ? "0" : "") + e.toString(16);
      return function() {
        var i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, o = 4294967295 * Math.random() | 0, s = 4294967295 * Math.random() | 0;
        return (t[i & 255] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255] + "-" + t[n & 255] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[o & 63 | 128] + t[o >> 8 & 255] + "-" + t[o >> 16 & 255] + t[o >> 24 & 255] + t[s & 255] + t[s >> 8 & 255] + t[s >> 16 & 255] + t[s >> 24 & 255]).toUpperCase();
      };
    }(),
    clamp: function(t, e, i) {
      return Math.max(e, Math.min(i, t));
    },
    euclideanModulo: function(t, e) {
      return (t % e + e) % e;
    },
    mapLinear: function(t, e, i, n, o) {
      return n + (t - e) * (o - n) / (i - e);
    },
    lerp: function(t, e, i) {
      return (1 - i) * t + i * e;
    },
    smoothstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * (3 - 2 * t));
    },
    smootherstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * t * (t * (6 * t - 15) + 10));
    },
    randInt: function(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function(t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function(t) {
      return t * (0.5 - Math.random());
    },
    degToRad: function(t) {
      return t * fi.DEG2RAD;
    },
    radToDeg: function(t) {
      return t * fi.RAD2DEG;
    },
    isPowerOfTwo: function(t) {
      return (t & t - 1) === 0 && t !== 0;
    },
    ceilPowerOfTwo: function(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    },
    floorPowerOfTwo: function(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }
  };
  Object.defineProperties(p.prototype, {
    width: {
      get: function() {
        return this.x;
      },
      set: function(t) {
        this.x = t;
      }
    },
    height: {
      get: function() {
        return this.y;
      },
      set: function(t) {
        this.y = t;
      }
    }
  }), Object.assign(p.prototype, {
    isVector2: !0,
    set: function(t, e) {
      return this.x = t, this.y = e, this;
    },
    setScalar: function(t) {
      return this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    },
    multiply: function(t) {
      return this.x *= t.x, this.y *= t.y, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this;
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    applyMatrix3: function(t) {
      var e = this.x, i = this.y;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this;
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    },
    clampScalar: function() {
      var t = new p(), e = new p();
      return function(i, n) {
        return t.set(i, i), e.set(n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y;
    },
    cross: function(t) {
      return this.x * t.y - this.y * t.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var t = Math.atan2(this.y, this.x);
      return 0 > t && (t += 2 * Math.PI), t;
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x;
      return t = this.y - t.y, e * e + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this;
    },
    rotateAround: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = this.x - t.x, o = this.y - t.y;
      return this.x = n * i - o * e + t.x, this.y = n * e + o * i + t.y, this;
    }
  }), Object.assign($.prototype, {
    isMatrix4: !0,
    set: function(t, e, i, n, o, s, l, h, c, f, v, y, S, P, N, j) {
      var et = this.elements;
      return et[0] = t, et[4] = e, et[8] = i, et[12] = n, et[1] = o, et[5] = s, et[9] = l, et[13] = h, et[2] = c, et[6] = f, et[10] = v, et[14] = y, et[3] = S, et[7] = P, et[11] = N, et[15] = j, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new $().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this;
    },
    copyPosition: function(t) {
      var e = this.elements;
      return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this;
    },
    extractBasis: function(t, e, i) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
    },
    makeBasis: function(t, e, i) {
      return this.set(
        t.x,
        e.x,
        i.x,
        0,
        t.y,
        e.y,
        i.y,
        0,
        t.z,
        e.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    extractRotation: function() {
      var t = new m();
      return function(e) {
        var i = this.elements, n = e.elements, o = 1 / t.setFromMatrixColumn(e, 0).length(), s = 1 / t.setFromMatrixColumn(e, 1).length();
        return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * o, i[1] = n[1] * o, i[2] = n[2] * o, i[3] = 0, i[4] = n[4] * s, i[5] = n[5] * s, i[6] = n[6] * s, i[7] = 0, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
      };
    }(),
    makeRotationFromEuler: function(t) {
      t && t.isEuler || console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
      var e = this.elements, i = t.x, n = t.y, o = t.z, s = Math.cos(i);
      i = Math.sin(i);
      var l = Math.cos(n);
      n = Math.sin(n);
      var h = Math.cos(o);
      if (o = Math.sin(o), t.order === "XYZ") {
        t = s * h;
        var c = s * o, f = i * h, v = i * o;
        e[0] = l * h, e[4] = -l * o, e[8] = n, e[1] = c + f * n, e[5] = t - v * n, e[9] = -i * l, e[2] = v - t * n, e[6] = f + c * n, e[10] = s * l;
      } else
        t.order === "YXZ" ? (t = l * h, c = l * o, f = n * h, v = n * o, e[0] = t + v * i, e[4] = f * i - c, e[8] = s * n, e[1] = s * o, e[5] = s * h, e[9] = -i, e[2] = c * i - f, e[6] = v + t * i, e[10] = s * l) : t.order === "ZXY" ? (t = l * h, c = l * o, f = n * h, v = n * o, e[0] = t - v * i, e[4] = -s * o, e[8] = f + c * i, e[1] = c + f * i, e[5] = s * h, e[9] = v - t * i, e[2] = -s * n, e[6] = i, e[10] = s * l) : t.order === "ZYX" ? (t = s * h, c = s * o, f = i * h, v = i * o, e[0] = l * h, e[4] = f * n - c, e[8] = t * n + v, e[1] = l * o, e[5] = v * n + t, e[9] = c * n - f, e[2] = -n, e[6] = i * l, e[10] = s * l) : t.order === "YZX" ? (t = s * l, c = s * n, f = i * l, v = i * n, e[0] = l * h, e[4] = v - t * o, e[8] = f * o + c, e[1] = o, e[5] = s * h, e[9] = -i * h, e[2] = -n * h, e[6] = c * o + f, e[10] = t - v * o) : t.order === "XZY" && (t = s * l, c = s * n, f = i * l, v = i * n, e[0] = l * h, e[4] = -o, e[8] = n * h, e[1] = t * o + v, e[5] = s * h, e[9] = c * o - f, e[2] = f * o - c, e[6] = i * h, e[10] = v * o + t);
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    },
    makeRotationFromQuaternion: function() {
      var t = new m(0, 0, 0), e = new m(1, 1, 1);
      return function(i) {
        return this.compose(t, i, e);
      };
    }(),
    lookAt: function() {
      var t = new m(), e = new m(), i = new m();
      return function(n, o, s) {
        var l = this.elements;
        return i.subVectors(n, o), i.lengthSq() === 0 && (i.z = 1), i.normalize(), t.crossVectors(s, i), t.lengthSq() === 0 && (Math.abs(s.z) === 1 ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(s, i)), t.normalize(), e.crossVectors(i, t), l[0] = t.x, l[4] = e.x, l[8] = i.x, l[1] = t.y, l[5] = e.y, l[9] = i.y, l[2] = t.z, l[6] = e.z, l[10] = i.z, this;
      };
    }(),
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
      ), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var o = i[4], s = i[8], l = i[12], h = i[1], c = i[5], f = i[9], v = i[13], y = i[2], S = i[6], P = i[10], N = i[14], j = i[3], et = i[7], _t = i[11];
      i = i[15];
      var mt = n[0], bt = n[4], xt = n[8], Wt = n[12], W = n[1], it = n[5], It = n[9], ee = n[13], $t = n[2], qt = n[6], Te = n[10], pe = n[14], Oe = n[3], be = n[7], se = n[11];
      return n = n[15], e[0] = t * mt + o * W + s * $t + l * Oe, e[4] = t * bt + o * it + s * qt + l * be, e[8] = t * xt + o * It + s * Te + l * se, e[12] = t * Wt + o * ee + s * pe + l * n, e[1] = h * mt + c * W + f * $t + v * Oe, e[5] = h * bt + c * it + f * qt + v * be, e[9] = h * xt + c * It + f * Te + v * se, e[13] = h * Wt + c * ee + f * pe + v * n, e[2] = y * mt + S * W + P * $t + N * Oe, e[6] = y * bt + S * it + P * qt + N * be, e[10] = y * xt + S * It + P * Te + N * se, e[14] = y * Wt + S * ee + P * pe + N * n, e[3] = j * mt + et * W + _t * $t + i * Oe, e[7] = j * bt + et * it + _t * qt + i * be, e[11] = j * xt + et * It + _t * Te + i * se, e[15] = j * Wt + et * ee + _t * pe + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    },
    applyToBufferAttribute: function() {
      var t = new m();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    determinant: function() {
      var t = this.elements, e = t[0], i = t[4], n = t[8], o = t[12], s = t[1], l = t[5], h = t[9], c = t[13], f = t[2], v = t[6], y = t[10], S = t[14];
      return t[3] * (+o * h * v - n * c * v - o * l * y + i * c * y + n * l * S - i * h * S) + t[7] * (+e * h * S - e * c * y + o * s * y - n * s * S + n * c * f - o * h * f) + t[11] * (+e * c * v - e * l * S - o * s * v + i * s * S + o * l * f - i * c * f) + t[15] * (-n * l * f - e * h * v + e * l * y + n * s * v - i * s * y + i * h * f);
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    },
    setPosition: function(t) {
      var e = this.elements;
      return e[12] = t.x, e[13] = t.y, e[14] = t.z, this;
    },
    getInverse: function(t, e) {
      var i = this.elements, n = t.elements;
      t = n[0];
      var o = n[1], s = n[2], l = n[3], h = n[4], c = n[5], f = n[6], v = n[7], y = n[8], S = n[9], P = n[10], N = n[11], j = n[12], et = n[13], _t = n[14];
      n = n[15];
      var mt = S * _t * v - et * P * v + et * f * N - c * _t * N - S * f * n + c * P * n, bt = j * P * v - y * _t * v - j * f * N + h * _t * N + y * f * n - h * P * n, xt = y * et * v - j * S * v + j * c * N - h * et * N - y * c * n + h * S * n, Wt = j * S * f - y * et * f - j * c * P + h * et * P + y * c * _t - h * S * _t, W = t * mt + o * bt + s * xt + l * Wt;
      if (W === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / W, i[0] = mt * e, i[1] = (et * P * l - S * _t * l - et * s * N + o * _t * N + S * s * n - o * P * n) * e, i[2] = (c * _t * l - et * f * l + et * s * v - o * _t * v - c * s * n + o * f * n) * e, i[3] = (S * f * l - c * P * l - S * s * v + o * P * v + c * s * N - o * f * N) * e, i[4] = bt * e, i[5] = (y * _t * l - j * P * l + j * s * N - t * _t * N - y * s * n + t * P * n) * e, i[6] = (j * f * l - h * _t * l - j * s * v + t * _t * v + h * s * n - t * f * n) * e, i[7] = (h * P * l - y * f * l + y * s * v - t * P * v - h * s * N + t * f * N) * e, i[8] = xt * e, i[9] = (j * S * l - y * et * l - j * o * N + t * et * N + y * o * n - t * S * n) * e, i[10] = (h * et * l - j * c * l + j * o * v - t * et * v - h * o * n + t * c * n) * e, i[11] = (y * c * l - h * S * l - y * o * v + t * S * v + h * o * N - t * c * N) * e, i[12] = Wt * e, i[13] = (y * et * s - j * S * s + j * o * P - t * et * P - y * o * _t + t * S * _t) * e, i[14] = (j * c * s - h * et * s - j * o * f + t * et * f + h * o * _t - t * c * _t) * e, i[15] = (h * S * s - y * c * s + y * o * f - t * S * f - h * o * P + t * c * P) * e, this;
    },
    scale: function(t) {
      var e = this.elements, i = t.x, n = t.y;
      return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this;
    },
    getMaxScaleOnAxis: function() {
      var t = this.elements;
      return Math.sqrt(
        Math.max(
          t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
        )
      );
    },
    makeTranslation: function(t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
    },
    makeRotationX: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = 1 - i, o = t.x, s = t.y;
      t = t.z;
      var l = n * o, h = n * s;
      return this.set(
        l * o + i,
        l * s - e * t,
        l * t + e * s,
        0,
        l * s + e * t,
        h * s + i,
        h * t - e * o,
        0,
        l * t - e * s,
        h * t + e * o,
        n * t * t + i,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    makeScale: function(t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    },
    makeShear: function(t, e, i) {
      return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    },
    compose: function(t, e, i) {
      var n = this.elements, o = e._x, s = e._y, l = e._z, h = e._w, c = o + o, f = s + s, v = l + l;
      e = o * c;
      var y = o * f;
      o *= v;
      var S = s * f;
      s *= v, l *= v, c *= h, f *= h, h *= v, v = i.x;
      var P = i.y;
      return i = i.z, n[0] = (1 - (S + l)) * v, n[1] = (y + h) * v, n[2] = (o - f) * v, n[3] = 0, n[4] = (y - h) * P, n[5] = (1 - (e + l)) * P, n[6] = (s + c) * P, n[7] = 0, n[8] = (o + f) * i, n[9] = (s - c) * i, n[10] = (1 - (e + S)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
    },
    decompose: function() {
      var t = new m(), e = new $();
      return function(i, n, o) {
        var s = this.elements, l = t.set(s[0], s[1], s[2]).length(), h = t.set(s[4], s[5], s[6]).length(), c = t.set(s[8], s[9], s[10]).length();
        0 > this.determinant() && (l = -l), i.x = s[12], i.y = s[13], i.z = s[14], e.copy(this), i = 1 / l, s = 1 / h;
        var f = 1 / c;
        return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= s, e.elements[5] *= s, e.elements[6] *= s, e.elements[8] *= f, e.elements[9] *= f, e.elements[10] *= f, n.setFromRotationMatrix(e), o.x = l, o.y = h, o.z = c, this;
      };
    }(),
    makePerspective: function(t, e, i, n, o, s) {
      s === void 0 && console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
      var l = this.elements;
      return l[0] = 2 * o / (e - t), l[4] = 0, l[8] = (e + t) / (e - t), l[12] = 0, l[1] = 0, l[5] = 2 * o / (i - n), l[9] = (i + n) / (i - n), l[13] = 0, l[2] = 0, l[6] = 0, l[10] = -(s + o) / (s - o), l[14] = -2 * s * o / (s - o), l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
    },
    makeOrthographic: function(t, e, i, n, o, s) {
      var l = this.elements, h = 1 / (e - t), c = 1 / (i - n), f = 1 / (s - o);
      return l[0] = 2 * h, l[4] = 0, l[8] = 0, l[12] = -((e + t) * h), l[1] = 0, l[5] = 2 * c, l[9] = 0, l[13] = -((i + n) * c), l[2] = 0, l[6] = 0, l[10] = -2 * f, l[14] = -((s + o) * f), l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 16 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 16 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
    }
  }), Object.assign(G, {
    slerp: function(t, e, i, n) {
      return i.copy(t).slerp(e, n);
    },
    slerpFlat: function(t, e, i, n, o, s, l) {
      var h = i[n + 0], c = i[n + 1], f = i[n + 2];
      i = i[n + 3], n = o[s + 0];
      var v = o[s + 1], y = o[s + 2];
      if (o = o[s + 3], i !== o || h !== n || c !== v || f !== y) {
        s = 1 - l;
        var S = h * n + c * v + f * y + i * o, P = 0 <= S ? 1 : -1, N = 1 - S * S;
        N > Number.EPSILON && (N = Math.sqrt(N), S = Math.atan2(N, S * P), s = Math.sin(s * S) / N, l = Math.sin(l * S) / N), P *= l, h = h * s + n * P, c = c * s + v * P, f = f * s + y * P, i = i * s + o * P, s === 1 - l && (l = 1 / Math.sqrt(h * h + c * c + f * f + i * i), h *= l, c *= l, f *= l, i *= l);
      }
      t[e] = h, t[e + 1] = c, t[e + 2] = f, t[e + 3] = i;
    }
  }), Object.defineProperties(G.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(t) {
        this._w = t, this.onChangeCallback();
      }
    }
  }), Object.assign(G.prototype, {
    isQuaternion: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this;
    },
    setFromEuler: function(t, e) {
      if (!t || !t.isEuler)
        throw Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      var i = t._x, n = t._y, o = t._z;
      t = t.order;
      var s = Math.cos, l = Math.sin, h = s(i / 2), c = s(n / 2);
      return s = s(o / 2), i = l(i / 2), n = l(n / 2), o = l(o / 2), t === "XYZ" ? (this._x = i * c * s + h * n * o, this._y = h * n * s - i * c * o, this._z = h * c * o + i * n * s, this._w = h * c * s - i * n * o) : t === "YXZ" ? (this._x = i * c * s + h * n * o, this._y = h * n * s - i * c * o, this._z = h * c * o - i * n * s, this._w = h * c * s + i * n * o) : t === "ZXY" ? (this._x = i * c * s - h * n * o, this._y = h * n * s + i * c * o, this._z = h * c * o + i * n * s, this._w = h * c * s - i * n * o) : t === "ZYX" ? (this._x = i * c * s - h * n * o, this._y = h * n * s + i * c * o, this._z = h * c * o - i * n * s, this._w = h * c * s + i * n * o) : t === "YZX" ? (this._x = i * c * s + h * n * o, this._y = h * n * s + i * c * o, this._z = h * c * o - i * n * s, this._w = h * c * s - i * n * o) : t === "XZY" && (this._x = i * c * s - h * n * o, this._y = h * n * s - i * c * o, this._z = h * c * o + i * n * s, this._w = h * c * s + i * n * o), e !== !1 && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(t, e) {
      e /= 2;
      var i = Math.sin(e);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t) {
      var e = t.elements, i = e[0];
      t = e[4];
      var n = e[8], o = e[1], s = e[5], l = e[9], h = e[2], c = e[6];
      e = e[10];
      var f = i + s + e;
      return 0 < f ? (i = 0.5 / Math.sqrt(f + 1), this._w = 0.25 / i, this._x = (c - l) * i, this._y = (n - h) * i, this._z = (o - t) * i) : i > s && i > e ? (i = 2 * Math.sqrt(1 + i - s - e), this._w = (c - l) / i, this._x = 0.25 * i, this._y = (t + o) / i, this._z = (n + h) / i) : s > e ? (i = 2 * Math.sqrt(1 + s - i - e), this._w = (n - h) / i, this._x = (t + o) / i, this._y = 0.25 * i, this._z = (l + c) / i) : (i = 2 * Math.sqrt(1 + e - i - s), this._w = (o - t) / i, this._x = (n + h) / i, this._y = (l + c) / i, this._z = 0.25 * i), this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
      var t = new m(), e;
      return function(i, n) {
        return t === void 0 && (t = new m()), e = i.dot(n) + 1, 1e-6 > e ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize();
      };
    }(),
    angleTo: function(t) {
      return 2 * Math.acos(Math.abs(fi.clamp(this.dot(t), -1, 1)));
    },
    rotateTowards: function(t, e) {
      var i = this.angleTo(t);
      return i === 0 ? this : (this.slerp(t, Math.min(1, e / i)), this);
    },
    inverse: function() {
      return this.conjugate();
    },
    conjugate: function() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    },
    lengthSq: function() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
      return Math.sqrt(
        this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      );
    },
    normalize: function() {
      var t = this.length();
      return t === 0 ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
      ), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    },
    premultiply: function(t) {
      return this.multiplyQuaternions(t, this);
    },
    multiplyQuaternions: function(t, e) {
      var i = t._x, n = t._y, o = t._z;
      t = t._w;
      var s = e._x, l = e._y, h = e._z;
      return e = e._w, this._x = i * e + t * s + n * h - o * l, this._y = n * e + t * l + o * s - i * h, this._z = o * e + t * h + i * l - n * s, this._w = t * e - i * s - n * l - o * h, this.onChangeCallback(), this;
    },
    slerp: function(t, e) {
      if (e === 0)
        return this;
      if (e === 1)
        return this.copy(t);
      var i = this._x, n = this._y, o = this._z, s = this._w, l = s * t._w + i * t._x + n * t._y + o * t._z;
      if (0 > l ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, l = -l) : this.copy(t), 1 <= l)
        return this._w = s, this._x = i, this._y = n, this._z = o, this;
      if (t = 1 - l * l, t <= Number.EPSILON)
        return l = 1 - e, this._w = l * s + e * this._w, this._x = l * i + e * this._x, this._y = l * n + e * this._y, this._z = l * o + e * this._z, this.normalize();
      t = Math.sqrt(t);
      var h = Math.atan2(t, l);
      return l = Math.sin((1 - e) * h) / t, e = Math.sin(e * h) / t, this._w = s * l + this._w * e, this._x = i * l + this._x * e, this._y = n * l + this._y * e, this._z = o * l + this._z * e, this.onChangeCallback(), this;
    },
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(m.prototype, {
    isVector3: !0,
    set: function(t, e, i) {
      return this.x = t, this.y = e, this.z = i, this;
    },
    setScalar: function(t) {
      return this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
      ), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    },
    multiplyVectors: function(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    },
    applyEuler: function() {
      var t = new G();
      return function(e) {
        return e && e.isEuler || console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ), this.applyQuaternion(t.setFromEuler(e));
      };
    }(),
    applyAxisAngle: function() {
      var t = new G();
      return function(e, i) {
        return this.applyQuaternion(t.setFromAxisAngle(e, i));
      };
    }(),
    applyMatrix3: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z;
      t = t.elements;
      var o = 1 / (t[3] * e + t[7] * i + t[11] * n + t[15]);
      return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * o, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * o, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * o, this;
    },
    applyQuaternion: function(t) {
      var e = this.x, i = this.y, n = this.z, o = t.x, s = t.y, l = t.z;
      t = t.w;
      var h = t * e + s * n - l * i, c = t * i + l * e - o * n, f = t * n + o * i - s * e;
      return e = -o * e - s * i - l * n, this.x = h * t + e * -o + c * -l - f * -s, this.y = c * t + e * -s + f * -o - h * -l, this.z = f * t + e * -l + h * -s - c * -o, this;
    },
    project: function(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    },
    unproject: function() {
      var t = new $();
      return function(e) {
        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(
          e.matrixWorld
        );
      };
    }(),
    transformDirection: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize();
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    },
    clampScalar: function() {
      var t = new m(), e = new m();
      return function(i, n) {
        return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    cross: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
      ), this.crossVectors(t, e)) : this.crossVectors(this, t);
    },
    crossVectors: function(t, e) {
      var i = t.x, n = t.y;
      t = t.z;
      var o = e.x, s = e.y;
      return e = e.z, this.x = n * e - t * s, this.y = t * o - i * e, this.z = i * s - n * o, this;
    },
    projectOnVector: function(t) {
      var e = t.dot(this) / t.lengthSq();
      return this.copy(t).multiplyScalar(e);
    },
    projectOnPlane: function() {
      var t = new m();
      return function(e) {
        return t.copy(this).projectOnVector(e), this.sub(t);
      };
    }(),
    reflect: function() {
      var t = new m();
      return function(e) {
        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
      };
    }(),
    angleTo: function(t) {
      return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(fi.clamp(t, -1, 1));
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x, i = this.y - t.y;
      return t = this.z - t.z, e * e + i * i + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    },
    setFromSpherical: function(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    },
    setFromSphericalCoords: function(t, e, i) {
      var n = Math.sin(e) * t;
      return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
    },
    setFromCylindrical: function(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    },
    setFromCylindricalCoords: function(t, e, i) {
      return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
    },
    setFromMatrixPosition: function(t) {
      return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this;
    },
    setFromMatrixScale: function(t) {
      var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length();
      return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this;
    },
    setFromMatrixColumn: function(t, e) {
      return this.fromArray(t.elements, 4 * e);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
  }), Object.assign(C.prototype, {
    isMatrix3: !0,
    set: function(t, e, i, n, o, s, l, h, c) {
      var f = this.elements;
      return f[0] = t, f[1] = n, f[2] = l, f[3] = e, f[4] = o, f[5] = h, f[6] = i, f[7] = s, f[8] = c, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this;
    },
    setFromMatrix4: function(t) {
      return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    },
    applyToBufferAttribute: function() {
      var t = new m();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    multiply: function(t) {
      return this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var o = i[3], s = i[6], l = i[1], h = i[4], c = i[7], f = i[2], v = i[5];
      i = i[8];
      var y = n[0], S = n[3], P = n[6], N = n[1], j = n[4], et = n[7], _t = n[2], mt = n[5];
      return n = n[8], e[0] = t * y + o * N + s * _t, e[3] = t * S + o * j + s * mt, e[6] = t * P + o * et + s * n, e[1] = l * y + h * N + c * _t, e[4] = l * S + h * j + c * mt, e[7] = l * P + h * et + c * n, e[2] = f * y + v * N + i * _t, e[5] = f * S + v * j + i * mt, e[8] = f * P + v * et + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    },
    determinant: function() {
      var t = this.elements, e = t[0], i = t[1], n = t[2], o = t[3], s = t[4], l = t[5], h = t[6], c = t[7];
      return t = t[8], e * s * t - e * l * c - i * o * t + i * l * h + n * o * c - n * s * h;
    },
    getInverse: function(t, e) {
      t && t.isMatrix4 && console.error(
        "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
      );
      var i = t.elements;
      t = this.elements;
      var n = i[0], o = i[1], s = i[2], l = i[3], h = i[4], c = i[5], f = i[6], v = i[7];
      i = i[8];
      var y = i * h - c * v, S = c * f - i * l, P = v * l - h * f, N = n * y + o * S + s * P;
      if (N === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / N, t[0] = y * e, t[1] = (s * v - i * o) * e, t[2] = (c * o - s * h) * e, t[3] = S * e, t[4] = (i * n - s * f) * e, t[5] = (s * l - c * n) * e, t[6] = P * e, t[7] = (o * f - v * n) * e, t[8] = (h * n - o * l) * e, this;
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    },
    getNormalMatrix: function(t) {
      return this.setFromMatrix4(t).getInverse(this).transpose();
    },
    transposeIntoArray: function(t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    },
    setUvTransform: function(t, e, i, n, o, s, l) {
      var h = Math.cos(o);
      o = Math.sin(o), this.set(
        i * h,
        i * o,
        -i * (h * s + o * l) + s + t,
        -n * o,
        n * h,
        -n * (-o * s + h * l) + l + e,
        0,
        0,
        1
      );
    },
    scale: function(t, e) {
      var i = this.elements;
      return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this;
    },
    rotate: function(t) {
      var e = Math.cos(t);
      t = Math.sin(t);
      var i = this.elements, n = i[0], o = i[3], s = i[6], l = i[1], h = i[4], c = i[7];
      return i[0] = e * n + t * l, i[3] = e * o + t * h, i[6] = e * s + t * c, i[1] = -t * n + e * l, i[4] = -t * o + e * h, i[7] = -t * s + e * c, this;
    },
    translate: function(t, e) {
      var i = this.elements;
      return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 9 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 9 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
    }
  });
  var Eo = {
    getDataURL: function(t) {
      if (typeof HTMLCanvasElement > "u")
        return t.src;
      if (t instanceof HTMLCanvasElement)
        var e = t;
      else {
        e = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        ), e.width = t.width, e.height = t.height;
        var i = e.getContext("2d");
        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height);
      }
      return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
    }
  }, Qo = 0;
  O.DEFAULT_IMAGE = void 0, O.DEFAULT_MAPPING = 300, O.prototype = Object.assign(Object.create(J.prototype), {
    constructor: O,
    isTexture: !0,
    updateMatrix: function() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
    },
    toJSON: function(t) {
      var e = t === void 0 || typeof t == "string";
      if (!e && t.textures[this.uuid] !== void 0)
        return t.textures[this.uuid];
      var i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY
      };
      if (this.image !== void 0) {
        var n = this.image;
        if (n.uuid === void 0 && (n.uuid = fi.generateUUID()), !e && t.images[n.uuid] === void 0) {
          if (Array.isArray(n))
            for (var o = [], s = 0, l = n.length; s < l; s++)
              o.push(Eo.getDataURL(n[s]));
          else
            o = Eo.getDataURL(n);
          t.images[n.uuid] = { uuid: n.uuid, url: o };
        }
        i.image = n.uuid;
      }
      return e || (t.textures[this.uuid] = i), i;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function(t) {
      if (this.mapping !== 300)
        return t;
      if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x)
        switch (this.wrapS) {
          case 1e3:
            t.x -= Math.floor(t.x);
            break;
          case 1001:
            t.x = 0 > t.x ? 0 : 1;
            break;
          case 1002:
            t.x = Math.abs(Math.floor(t.x) % 2) === 1 ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x);
        }
      if (0 > t.y || 1 < t.y)
        switch (this.wrapT) {
          case 1e3:
            t.y -= Math.floor(t.y);
            break;
          case 1001:
            t.y = 0 > t.y ? 0 : 1;
            break;
          case 1002:
            t.y = Math.abs(Math.floor(t.y) % 2) === 1 ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y);
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
  }), Object.defineProperty(O.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(E.prototype, {
    isVector4: !0,
    set: function(t, e, i, n) {
      return this.x = t, this.y = e, this.z = i, this.w = n, this;
    },
    setScalar: function(t) {
      return this.w = this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setW: function(t) {
      return this.w = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z, o = this.w;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * o, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * o, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * o, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * o, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    setAxisAngleFromQuaternion: function(t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    },
    setAxisAngleFromRotationMatrix: function(t) {
      t = t.elements;
      var e = t[0], i = t[4], n = t[8], o = t[1], s = t[5], l = t[9], h = t[2], c = t[6], f = t[10];
      return 0.01 > Math.abs(i - o) && 0.01 > Math.abs(n - h) && 0.01 > Math.abs(l - c) ? 0.1 > Math.abs(i + o) && 0.1 > Math.abs(n + h) && 0.1 > Math.abs(l + c) && 0.1 > Math.abs(e + s + f - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, e = (e + 1) / 2, s = (s + 1) / 2, f = (f + 1) / 2, i = (i + o) / 4, n = (n + h) / 4, l = (l + c) / 4, e > s && e > f ? 0.01 > e ? (c = 0, i = h = 0.707106781) : (c = Math.sqrt(e), h = i / c, i = n / c) : s > f ? 0.01 > s ? (c = 0.707106781, h = 0, i = 0.707106781) : (h = Math.sqrt(s), c = i / h, i = l / h) : 0.01 > f ? (h = c = 0.707106781, i = 0) : (i = Math.sqrt(f), c = n / i, h = l / i), this.set(c, h, i, t), this) : (t = Math.sqrt((c - l) * (c - l) + (n - h) * (n - h) + (o - i) * (o - i)), 1e-3 > Math.abs(t) && (t = 1), this.x = (c - l) / t, this.y = (n - h) / t, this.z = (o - i) / t, this.w = Math.acos((e + s + f - 1) / 2), this);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    },
    clampScalar: function() {
      var t, e;
      return function(i, n) {
        return t === void 0 && (t = new E(), e = new E()), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
  }), U.prototype = Object.assign(Object.create(J.prototype), {
    constructor: U,
    isWebGLRenderTarget: !0,
    setSize: function(t, e) {
      (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Y.prototype = Object.create(U.prototype), Y.prototype.constructor = Y, Y.prototype.isWebGLRenderTargetCube = !0, H.prototype = Object.create(O.prototype), H.prototype.constructor = H, H.prototype.isDataTexture = !0, Object.assign(K.prototype, {
    isBox3: !0,
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromArray: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0, h = 0, c = t.length; h < c; h += 3) {
        var f = t[h], v = t[h + 1], y = t[h + 2];
        f < e && (e = f), v < i && (i = v), y < n && (n = y), f > o && (o = f), v > s && (s = v), y > l && (l = y);
      }
      return this.min.set(e, i, n), this.max.set(o, s, l), this;
    },
    setFromBufferAttribute: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0, h = 0, c = t.count; h < c; h++) {
        var f = t.getX(h), v = t.getY(h), y = t.getZ(h);
        f < e && (e = f), v < i && (i = v), y < n && (n = y), f > o && (o = f), v > s && (s = v), y > l && (l = y);
      }
      return this.min.set(e, i, n), this.max.set(o, s, l), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new m();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    setFromObject: function(t) {
      return this.makeEmpty(), this.expandByObject(t);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new m()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), t = new m()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    expandByObject: function() {
      function t(s) {
        var l = s.geometry;
        if (l !== void 0) {
          if (l.isGeometry)
            for (l = l.vertices, i = 0, n = l.length; i < n; i++)
              o.copy(l[i]), o.applyMatrix4(s.matrixWorld), e.expandByPoint(o);
          else if (l.isBufferGeometry && (l = l.attributes.position, l !== void 0))
            for (i = 0, n = l.count; i < n; i++)
              o.fromBufferAttribute(l, i).applyMatrix4(s.matrixWorld), e.expandByPoint(o);
        }
      }
      var e, i, n, o = new m();
      return function(s) {
        return e = this, s.updateMatrixWorld(!0), s.traverse(t), this;
      };
    }(),
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new m()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    },
    intersectsSphere: function() {
      var t = new m();
      return function(e) {
        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius;
      };
    }(),
    intersectsPlane: function(t) {
      if (0 < t.normal.x)
        var e = t.normal.x * this.min.x, i = t.normal.x * this.max.x;
      else
        e = t.normal.x * this.max.x, i = t.normal.x * this.min.x;
      return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
    },
    intersectsTriangle: function() {
      function t(y) {
        var S, P = 0;
        for (S = y.length - 3; P <= S; P += 3) {
          h.fromArray(y, P);
          var N = f.x * Math.abs(h.x) + f.y * Math.abs(h.y) + f.z * Math.abs(h.z), j = e.dot(h), et = i.dot(h), _t = n.dot(h);
          if (Math.max(-Math.max(j, et, _t), Math.min(j, et, _t)) > N)
            return !1;
        }
        return !0;
      }
      var e = new m(), i = new m(), n = new m(), o = new m(), s = new m(), l = new m(), h = new m(), c = new m(), f = new m(), v = new m();
      return function(y) {
        return this.isEmpty() || (this.getCenter(c), f.subVectors(this.max, c), e.subVectors(y.a, c), i.subVectors(y.b, c), n.subVectors(y.c, c), o.subVectors(i, e), s.subVectors(n, i), l.subVectors(e, n), y = [
          0,
          -o.z,
          o.y,
          0,
          -s.z,
          s.y,
          0,
          -l.z,
          l.y,
          o.z,
          0,
          -o.x,
          s.z,
          0,
          -s.x,
          l.z,
          0,
          -l.x,
          -o.y,
          o.x,
          0,
          -s.y,
          s.x,
          0,
          -l.y,
          l.x,
          0
        ], !t(y)) || (y = [1, 0, 0, 0, 1, 0, 0, 0, 1], !t(y)) ? !1 : (v.crossVectors(o, s), y = [v.x, v.y, v.z], t(y));
      };
    }(),
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new m()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new m();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    getBoundingSphere: function() {
      var t = new m();
      return function(e) {
        return e === void 0 && (console.warn(
          "THREE.Box3: .getBoundingSphere() target is now required"
        ), e = new B()), this.getCenter(e.center), e.radius = 0.5 * this.getSize(t).length(), e;
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    applyMatrix4: function() {
      var t = [
        new m(),
        new m(),
        new m(),
        new m(),
        new m(),
        new m(),
        new m(),
        new m()
      ];
      return function(e) {
        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this);
      };
    }(),
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(B.prototype, {
    set: function(t, e) {
      return this.center.copy(t), this.radius = e, this;
    },
    setFromPoints: function() {
      var t = new K();
      return function(e, i) {
        var n = this.center;
        i !== void 0 ? n.copy(i) : t.setFromPoints(e).getCenter(n);
        for (var o = i = 0, s = e.length; o < s; o++)
          i = Math.max(i, n.distanceToSquared(e[o]));
        return this.radius = Math.sqrt(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    },
    empty: function() {
      return 0 >= this.radius;
    },
    containsPoint: function(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(t) {
      return t.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    },
    intersectsBox: function(t) {
      return t.intersectsSphere(this);
    },
    intersectsPlane: function(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(t, e) {
      var i = this.center.distanceToSquared(t);
      return e === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new m()), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    },
    getBoundingBox: function(t) {
      return t === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new K()), t.set(this.center, this.center), t.expandByScalar(this.radius), t;
    },
    applyMatrix4: function(t) {
      return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this;
    },
    translate: function(t) {
      return this.center.add(t), this;
    },
    equals: function(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
  }), Object.assign(q.prototype, {
    set: function(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    },
    setComponents: function(t, e, i, n) {
      return this.normal.set(t, e, i), this.constant = n, this;
    },
    setFromNormalAndCoplanarPoint: function(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
      var t = new m(), e = new m();
      return function(i, n, o) {
        return n = t.subVectors(o, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    },
    normalize: function() {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    },
    negate: function() {
      return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(t) {
      return this.normal.dot(t) + this.constant;
    },
    distanceToSphere: function(t) {
      return this.distanceToPoint(t.center) - t.radius;
    },
    projectPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new m()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    },
    intersectLine: function() {
      var t = new m();
      return function(e, i) {
        i === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new m());
        var n = e.delta(t), o = this.normal.dot(n);
        if (o === 0) {
          if (this.distanceToPoint(e.start) === 0)
            return i.copy(e.start);
        } else if (o = -(e.start.dot(this.normal) + this.constant) / o, !(0 > o || 1 < o))
          return i.copy(n).multiplyScalar(o).add(e.start);
      };
    }(),
    intersectsLine: function(t) {
      var e = this.distanceToPoint(t.start);
      return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e;
    },
    intersectsBox: function(t) {
      return t.intersectsPlane(this);
    },
    intersectsSphere: function(t) {
      return t.intersectsPlane(this);
    },
    coplanarPoint: function(t) {
      return t === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new m()), t.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
      var t = new m(), e = new C();
      return function(i, n) {
        return n = n || e.getNormalMatrix(i), i = this.coplanarPoint(t).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this;
      };
    }(),
    translate: function(t) {
      return this.constant -= t.dot(this.normal), this;
    },
    equals: function(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
  }), Object.assign(b.prototype, {
    set: function(t, e, i, n, o, s) {
      var l = this.planes;
      return l[0].copy(t), l[1].copy(e), l[2].copy(i), l[3].copy(n), l[4].copy(o), l[5].copy(s), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        e[i].copy(t.planes[i]);
      return this;
    },
    setFromMatrix: function(t) {
      var e = this.planes, i = t.elements;
      t = i[0];
      var n = i[1], o = i[2], s = i[3], l = i[4], h = i[5], c = i[6], f = i[7], v = i[8], y = i[9], S = i[10], P = i[11], N = i[12], j = i[13], et = i[14];
      return i = i[15], e[0].setComponents(s - t, f - l, P - v, i - N).normalize(), e[1].setComponents(s + t, f + l, P + v, i + N).normalize(), e[2].setComponents(s + n, f + h, P + y, i + j).normalize(), e[3].setComponents(s - n, f - h, P - y, i - j).normalize(), e[4].setComponents(s - o, f - c, P - S, i - et).normalize(), e[5].setComponents(s + o, f + c, P + S, i + et).normalize(), this;
    },
    intersectsObject: function() {
      var t = new B();
      return function(e) {
        var i = e.geometry;
        return i.boundingSphere === null && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSprite: function() {
      var t = new B();
      return function(e) {
        return t.center.set(0, 0, 0), t.radius = 0.7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSphere: function(t) {
      var e = this.planes, i = t.center;
      t = -t.radius;
      for (var n = 0; 6 > n; n++)
        if (e[n].distanceToPoint(i) < t)
          return !1;
      return !0;
    },
    intersectsBox: function() {
      var t = new m();
      return function(e) {
        for (var i = this.planes, n = 0; 6 > n; n++) {
          var o = i[n];
          if (t.x = 0 < o.normal.x ? e.max.x : e.min.x, t.y = 0 < o.normal.y ? e.max.y : e.min.y, t.z = 0 < o.normal.z ? e.max.z : e.min.z, 0 > o.distanceToPoint(t))
            return !1;
        }
        return !0;
      };
    }(),
    containsPoint: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        if (0 > e[i].distanceToPoint(t))
          return !1;
      return !0;
    }
  });
  var Ei = {
    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif
`,
    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
`,
    alphatest_fragment: `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif
`,
    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif
`,
    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    begin_vertex: `
vec3 transformed = vec3( position );
`,
    beginnormal_vertex: `
vec3 objectNormal = vec3( normal );
`,
    bsdfs: `float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`,
    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif
`,
    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
	}
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;
		}
		if ( clipped ) discard;
	#endif
#endif
`,
    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
		varying vec3 vViewPosition;
	#endif
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif
`,
    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	varying vec3 vViewPosition;
#endif
`,
    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	vViewPosition = - mvPosition.xyz;
#endif
`,
    color_fragment: `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,
    color_pars_fragment: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif
`,
    color_pars_vertex: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,
    color_vertex: `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`,
    common: `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
`,
    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_textureSize (1024.0)
int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}
#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;
	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	float powScale = exp2_packed.x * exp2_packed.y;
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;
	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);
	float rcpPowScale = 1.0 / powScale;
	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}
#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
vec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;
	level0 += min( floor( s + 0.5 ), 5.0 );
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
	vec4 result = mix(color10, color20, t);
	return vec4(result.rgb, 1.0);
}
#endif
`,
    defaultnormal_vertex: `vec3 transformedNormal = normalMatrix * objectNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
`,
    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif
`,
    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
#endif
`,
    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif
`,
    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif
`,
    encodings_fragment: `  gl_FragColor = linearToOutputTexel( gl_FragColor );
`,
    encodings_pars_fragment: `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`,
    envmap_fragment: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToVertex, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		vec2 sampleUV;
		reflectVec = normalize( reflectVec );
		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	envColor = envMapTexelToLinear( envColor );
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif
`,
    envmap_pars_fragment: `#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif
#ifdef USE_ENVMAP
	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif
`,
    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif
`,
    envmap_physical_pars_fragment: `#if defined( USE_ENVMAP ) && defined( PHYSICAL )
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
		#else
			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif
`,
    envmap_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif
`,
    fog_vertex: `#ifdef USE_FOG
	fogDepth = -mvPosition.z;
#endif
`,
    fog_pars_vertex: `#ifdef USE_FOG
	varying float fogDepth;
#endif
`,
    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`,
    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
`,
    gradientmap_pars_fragment: `#ifdef TOON
	uniform sampler2D gradientMap;
	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
		#ifdef USE_GRADIENTMAP
			return texture2D( gradientMap, coord ).rgb;
		#else
			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
		#endif
	}
#endif
`,
    lightmap_fragment: `#ifdef USE_LIGHTMAP
	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
#endif
`,
    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    lights_lambert_vertex: `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
#endif
`,
    lights_pars_begin: `uniform vec3 ambientLightColor;
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif
`,
    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,
    lights_phong_pars_fragment: `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	#ifdef TOON
		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#else
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;
	#endif
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
`,
    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`,
    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	#ifndef STANDARD
		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
	#ifndef STANDARD
		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}
`,
    lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
#endif
#if defined( RE_IndirectDiffuse )
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );
#endif
`,
    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif
#endif
`,
    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
#endif
`,
    logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
#endif
`,
    logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#else
		uniform float logDepthBufFC;
	#endif
#endif
`,
    logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
	#else
		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
		gl_Position.z *= gl_Position.w;
	#endif
#endif
`,
    map_fragment: `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif
`,
    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif
`,
    map_particle_fragment: `#ifdef USE_MAP
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
`,
    map_particle_pars_fragment: `#ifdef USE_MAP
	uniform mat3 uvTransform;
	uniform sampler2D map;
#endif
`,
    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif
`,
    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif
`,
    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
	#endif
#endif
`,
    normal_fragment_begin: `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
#endif
`,
    normal_fragment_maps: `#ifdef USE_NORMALMAP
	#ifdef OBJECTSPACE_NORMALMAP
		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
		#ifdef FLIP_SIDED
			normal = - normal;
		#endif
		#ifdef DOUBLE_SIDED
			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		normal = normalize( normalMatrix * normal );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif
`,
    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	#ifdef OBJECTSPACE_NORMALMAP
		uniform mat3 normalMatrix;
	#else
		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
			vec2 st0 = dFdx( vUv.st );
			vec2 st1 = dFdy( vUv.st );
			float scale = sign( st1.t * st0.s - st0.t * st1.s );
			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
			vec3 N = normalize( surf_norm );
			mat3 tsn = mat3( S, T, N );
			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
			mapN.xy *= normalScale;
			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			return normalize( tsn * mapN );
		}
	#endif
#endif
`,
    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,
    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
`,
    project_vertex: `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
gl_Position = projectionMatrix * mvPosition;
`,
    dithering_fragment: `#if defined( DITHERING )
  gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif
`,
    dithering_pars_fragment: `#if defined( DITHERING )
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif
`,
    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif
`,
    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    shadowmap_pars_fragment: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
		const vec2 offset = vec2( 0.0, 1.0 );
		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
		vec2 f = fract( uv * size + 0.5 );
		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );
		return c;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif
`,
    shadowmap_pars_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
#endif
`,
    shadowmap_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#endif
#endif
`,
    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#endif
	#endif
	return shadow;
}
`,
    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif
`,
    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif
`,
    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif
`,
    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    tonemapping_fragment: `#if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif
`,
    tonemapping_pars_fragment: `#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
`,
    uv_pars_fragment: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
#endif`,
    uv_pars_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
`,
    uv_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
#endif`,
    uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = uv2;
#endif`,
    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
#endif
`,
    background_frag: `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
}
`,
    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position, 1.0 );
	gl_Position.z = 1.0;
}
`,
    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor.a *= opacity;
}
`,
    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}
`,
    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
	#endif
}
`,
    depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
`,
    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}
`,
    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}
`,
    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV;
	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;
	gl_FragColor = texture2D( tEquirect, sampleUV );
}
`,
    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}
`,
    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	vLineDistance = scale * lineDistance;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`,
    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`,
    meshlambert_frag: `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshlambert_vert: `#define LAMBERT
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	vec4 matcapColor = texture2D( matcap, uv );
	matcapColor = matcapTexelToLinear( matcapColor );
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}
`,
    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshphysical_frag: `#define PHYSICAL
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphysical_vert: `#define PHYSICAL
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    normal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}
`,
    normal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	vViewPosition = - mvPosition.xyz;
#endif
}
`,
    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}
`,
    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <fog_fragment>
}
`,
    shadow_vert: `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`
  }, bn = {
    merge: function(t) {
      for (var e = {}, i = 0; i < t.length; i++) {
        var n = this.clone(t[i]), o;
        for (o in n)
          e[o] = n[o];
      }
      return e;
    },
    clone: function(t) {
      var e = {}, i;
      for (i in t) {
        e[i] = {};
        for (var n in t[i]) {
          var o = t[i][n];
          o && (o.isColor || o.isMatrix3 || o.isMatrix4 || o.isVector2 || o.isVector3 || o.isVector4 || o.isTexture) ? e[i][n] = o.clone() : Array.isArray(o) ? e[i][n] = o.slice() : e[i][n] = o;
        }
      }
      return e;
    }
  }, Ar = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Object.assign(A.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function(t) {
      return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this;
    },
    setScalar: function(t) {
      return this.b = this.g = this.r = t, this;
    },
    setHex: function(t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, this;
    },
    setRGB: function(t, e, i) {
      return this.r = t, this.g = e, this.b = i, this;
    },
    setHSL: function() {
      function t(e, i, n) {
        return 0 > n && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (i - e) * n : 0.5 > n ? i : n < 2 / 3 ? e + 6 * (i - e) * (2 / 3 - n) : e;
      }
      return function(e, i, n) {
        return e = fi.euclideanModulo(e, 1), i = fi.clamp(i, 0, 1), n = fi.clamp(n, 0, 1), i === 0 ? this.r = this.g = this.b = n : (i = 0.5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this;
      };
    }(),
    setStyle: function(t) {
      function e(l) {
        l !== void 0 && 1 > parseFloat(l) && console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
      }
      var i;
      if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
        var n = i[2];
        switch (i[1]) {
          case "rgb":
          case "rgba":
            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
            if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
            break;
          case "hsl":
          case "hsla":
            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            )) {
              n = parseFloat(i[1]) / 360;
              var o = parseInt(i[2], 10) / 100, s = parseInt(i[3], 10) / 100;
              return e(i[5]), this.setHSL(n, o, s);
            }
        }
      } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
        if (i = i[1], n = i.length, n === 3)
          return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
        if (n === 6)
          return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this;
      }
      return t && 0 < t.length && (i = Ar[t], i !== void 0 ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    },
    copyGammaToLinear: function(t, e) {
      return e === void 0 && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    copyLinearToGamma: function(t, e) {
      return e === void 0 && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    convertGammaToLinear: function(t) {
      return this.copyGammaToLinear(this, t), this;
    },
    convertLinearToGamma: function(t) {
      return this.copyLinearToGamma(this, t), this;
    },
    copySRGBToLinear: function() {
      function t(e) {
        return 0.04045 > e ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    copyLinearToSRGB: function() {
      function t(e) {
        return 31308e-7 > e ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    convertSRGBToLinear: function() {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function() {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(t) {
      t === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });
      var e = this.r, i = this.g, n = this.b, o = Math.max(e, i, n), s = Math.min(e, i, n), l, h = (s + o) / 2;
      if (s === o)
        s = l = 0;
      else {
        var c = o - s;
        switch (s = 0.5 >= h ? c / (o + s) : c / (2 - o - s), o) {
          case e:
            l = (i - n) / c + (i < n ? 6 : 0);
            break;
          case i:
            l = (n - e) / c + 2;
            break;
          case n:
            l = (e - i) / c + 4;
        }
        l /= 6;
      }
      return t.h = l, t.s = s, t.l = h, t;
    },
    getStyle: function() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function() {
      var t = {};
      return function(e, i, n) {
        return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this;
      };
    }(),
    add: function(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    },
    addColors: function(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    },
    addScalar: function(t) {
      return this.r += t, this.g += t, this.b += t, this;
    },
    sub: function(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    },
    multiply: function(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    },
    multiplyScalar: function(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    },
    lerp: function(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    },
    lerpHSL: function() {
      var t = { h: 0, s: 0, l: 0 }, e = { h: 0, s: 0, l: 0 };
      return function(i, n) {
        this.getHSL(t), i.getHSL(e), i = fi.lerp(t.h, e.h, n);
        var o = fi.lerp(t.s, e.s, n);
        return n = fi.lerp(t.l, e.l, n), this.setHSL(i, o, n), this;
      };
    }(),
    equals: function(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  var qe = {
    common: {
      diffuse: { value: new A(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new C() },
      alphaMap: { value: null }
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new p(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new A(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} }
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} }
      }
    },
    points: {
      diffuse: { value: new A(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      uvTransform: { value: new C() }
    },
    sprite: {
      diffuse: { value: new A(15658734) },
      opacity: { value: 1 },
      center: { value: new p(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      uvTransform: { value: new C() }
    }
  }, jr = {
    basic: {
      uniforms: bn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.fog
      ]),
      vertexShader: Ei.meshbasic_vert,
      fragmentShader: Ei.meshbasic_frag
    },
    lambert: {
      uniforms: bn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.fog,
        qe.lights,
        { emissive: { value: new A(0) } }
      ]),
      vertexShader: Ei.meshlambert_vert,
      fragmentShader: Ei.meshlambert_frag
    },
    phong: {
      uniforms: bn.merge([
        qe.common,
        qe.specularmap,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.gradientmap,
        qe.fog,
        qe.lights,
        {
          emissive: { value: new A(0) },
          specular: { value: new A(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: Ei.meshphong_vert,
      fragmentShader: Ei.meshphong_frag
    },
    standard: {
      uniforms: bn.merge([
        qe.common,
        qe.envmap,
        qe.aomap,
        qe.lightmap,
        qe.emissivemap,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.roughnessmap,
        qe.metalnessmap,
        qe.fog,
        qe.lights,
        {
          emissive: { value: new A(0) },
          roughness: { value: 0.5 },
          metalness: { value: 0.5 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: Ei.meshphysical_vert,
      fragmentShader: Ei.meshphysical_frag
    },
    matcap: {
      uniforms: bn.merge([
        qe.common,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        qe.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: Ei.meshmatcap_vert,
      fragmentShader: Ei.meshmatcap_frag
    },
    points: {
      uniforms: bn.merge([qe.points, qe.fog]),
      vertexShader: Ei.points_vert,
      fragmentShader: Ei.points_frag
    },
    dashed: {
      uniforms: bn.merge([
        qe.common,
        qe.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: Ei.linedashed_vert,
      fragmentShader: Ei.linedashed_frag
    },
    depth: {
      uniforms: bn.merge([qe.common, qe.displacementmap]),
      vertexShader: Ei.depth_vert,
      fragmentShader: Ei.depth_frag
    },
    normal: {
      uniforms: bn.merge([
        qe.common,
        qe.bumpmap,
        qe.normalmap,
        qe.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: Ei.normal_vert,
      fragmentShader: Ei.normal_frag
    },
    sprite: {
      uniforms: bn.merge([qe.sprite, qe.fog]),
      vertexShader: Ei.sprite_vert,
      fragmentShader: Ei.sprite_frag
    },
    background: {
      uniforms: { uvTransform: { value: new C() }, t2D: { value: null } },
      vertexShader: Ei.background_vert,
      fragmentShader: Ei.background_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: Ei.cube_vert,
      fragmentShader: Ei.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ei.equirect_vert,
      fragmentShader: Ei.equirect_frag
    },
    distanceRGBA: {
      uniforms: bn.merge([
        qe.common,
        qe.displacementmap,
        {
          referencePosition: { value: new m() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: Ei.distanceRGBA_vert,
      fragmentShader: Ei.distanceRGBA_frag
    },
    shadow: {
      uniforms: bn.merge([
        qe.lights,
        qe.fog,
        { color: { value: new A(0) }, opacity: { value: 1 } }
      ]),
      vertexShader: Ei.shadow_vert,
      fragmentShader: Ei.shadow_frag
    }
  };
  jr.physical = {
    uniforms: bn.merge([
      jr.standard.uniforms,
      { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }
    ]),
    vertexShader: Ei.meshphysical_vert,
    fragmentShader: Ei.meshphysical_frag
  }, Object.assign(M.prototype, {
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
      for (var e = 0, i = t.vertexNormals.length; e < i; e++)
        this.vertexNormals[e] = t.vertexNormals[e].clone();
      for (e = 0, i = t.vertexColors.length; e < i; e++)
        this.vertexColors[e] = t.vertexColors[e].clone();
      return this;
    }
  }), x.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), x.DefaultOrder = "XYZ", Object.defineProperties(x.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(t) {
        this._order = t, this.onChangeCallback();
      }
    }
  }), Object.assign(x.prototype, {
    isEuler: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t, e, i) {
      var n = fi.clamp, o = t.elements;
      t = o[0];
      var s = o[4], l = o[8], h = o[1], c = o[5], f = o[9], v = o[2], y = o[6];
      return o = o[10], e = e || this._order, e === "XYZ" ? (this._y = Math.asin(n(l, -1, 1)), 0.99999 > Math.abs(l) ? (this._x = Math.atan2(-f, o), this._z = Math.atan2(-s, t)) : (this._x = Math.atan2(y, c), this._z = 0)) : e === "YXZ" ? (this._x = Math.asin(-n(f, -1, 1)), 0.99999 > Math.abs(f) ? (this._y = Math.atan2(l, o), this._z = Math.atan2(h, c)) : (this._y = Math.atan2(-v, t), this._z = 0)) : e === "ZXY" ? (this._x = Math.asin(n(y, -1, 1)), 0.99999 > Math.abs(y) ? (this._y = Math.atan2(-v, o), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(h, t))) : e === "ZYX" ? (this._y = Math.asin(-n(v, -1, 1)), 0.99999 > Math.abs(v) ? (this._x = Math.atan2(y, o), this._z = Math.atan2(h, t)) : (this._x = 0, this._z = Math.atan2(-s, c))) : e === "YZX" ? (this._z = Math.asin(n(h, -1, 1)), 0.99999 > Math.abs(h) ? (this._x = Math.atan2(-f, c), this._y = Math.atan2(-v, t)) : (this._x = 0, this._y = Math.atan2(l, o))) : e === "XZY" ? (this._z = Math.asin(-n(s, -1, 1)), 0.99999 > Math.abs(s) ? (this._x = Math.atan2(y, c), this._y = Math.atan2(l, t)) : (this._x = Math.atan2(-f, o), this._y = 0)) : console.warn(
        "THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e
      ), this._order = e, i !== !1 && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
      var t = new $();
      return function(e, i, n) {
        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n);
      };
    }(),
    setFromVector3: function(t, e) {
      return this.set(t.x, t.y, t.z, e || this._order);
    },
    reorder: function() {
      var t = new G();
      return function(e) {
        return t.setFromEuler(this), this.setFromQuaternion(t, e);
      };
    }(),
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    },
    fromArray: function(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    },
    toVector3: function(t) {
      return t ? t.set(this._x, this._y, this._z) : new m(this._x, this._y, this._z);
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(F.prototype, {
    set: function(t) {
      this.mask = 1 << t | 0;
    },
    enable: function(t) {
      this.mask = this.mask | 1 << t | 0;
    },
    toggle: function(t) {
      this.mask ^= 1 << t | 0;
    },
    disable: function(t) {
      this.mask &= ~(1 << t | 0);
    },
    test: function(t) {
      return (this.mask & t.mask) !== 0;
    }
  });
  var uh = 0;
  z.DefaultUp = new m(0, 1, 0), z.DefaultMatrixAutoUpdate = !0, z.prototype = Object.assign(Object.create(J.prototype), {
    constructor: z,
    isObject3D: !0,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix: function(t) {
      this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(t) {
      return this.quaternion.premultiply(t), this;
    },
    setRotationFromAxisAngle: function(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    },
    setRotationFromEuler: function(t) {
      this.quaternion.setFromEuler(t, !0);
    },
    setRotationFromMatrix: function(t) {
      this.quaternion.setFromRotationMatrix(t);
    },
    setRotationFromQuaternion: function(t) {
      this.quaternion.copy(t);
    },
    rotateOnAxis: function() {
      var t = new G();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this;
      };
    }(),
    rotateOnWorldAxis: function() {
      var t = new G();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this;
      };
    }(),
    rotateX: function() {
      var t = new m(1, 0, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateY: function() {
      var t = new m(0, 1, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateZ: function() {
      var t = new m(0, 0, 1);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    translateOnAxis: function() {
      var t = new m();
      return function(e, i) {
        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this;
      };
    }(),
    translateX: function() {
      var t = new m(1, 0, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateY: function() {
      var t = new m(0, 1, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateZ: function() {
      var t = new m(0, 0, 1);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    localToWorld: function(t) {
      return t.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
      var t = new $();
      return function(e) {
        return e.applyMatrix4(t.getInverse(this.matrixWorld));
      };
    }(),
    lookAt: function() {
      var t = new G(), e = new $(), i = new m(), n = new m();
      return function(o, s, l) {
        o.isVector3 ? i.copy(o) : i.set(o, s, l), o = this.parent, this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), o && (e.extractRotation(o.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()));
      };
    }(),
    add: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.add(arguments[e]);
        return this;
      }
      return t === this ? (console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        t
      ), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error(
        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
        t
      ), this);
    },
    remove: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.remove(arguments[e]);
        return this;
      }
      return e = this.children.indexOf(t), e !== -1 && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(e, 1)), this;
    },
    getObjectById: function(t) {
      return this.getObjectByProperty("id", t);
    },
    getObjectByName: function(t) {
      return this.getObjectByProperty("name", t);
    },
    getObjectByProperty: function(t, e) {
      if (this[t] === e)
        return this;
      for (var i = 0, n = this.children.length; i < n; i++) {
        var o = this.children[i].getObjectByProperty(t, e);
        if (o !== void 0)
          return o;
      }
    },
    getWorldPosition: function(t) {
      return t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldPosition() target is now required"
      ), t = new m()), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
      var t = new m(), e = new m();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldQuaternion() target is now required"
        ), i = new G()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i;
      };
    }(),
    getWorldScale: function() {
      var t = new m(), e = new G();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldScale() target is now required"
        ), i = new m()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i;
      };
    }(),
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldDirection() target is now required"
      ), t = new m()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(t) {
      t(this);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].traverse(t);
    },
    traverseVisible: function(t) {
      if (this.visible !== !1) {
        t(this);
        for (var e = this.children, i = 0, n = e.length; i < n; i++)
          e[i].traverseVisible(t);
      }
    },
    traverseAncestors: function(t) {
      var e = this.parent;
      e !== null && (t(e), e.traverseAncestors(t));
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), this.matrixWorldNeedsUpdate = !1, t = !0);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].updateMatrixWorld(t);
    },
    updateWorldMatrix: function(t, e) {
      var i = this.parent;
      if (t === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), e === !0)
        for (t = this.children, e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0);
    },
    toJSON: function(t) {
      function e(v, y) {
        return v[y.uuid] === void 0 && (v[y.uuid] = y.toJSON(t)), y.uuid;
      }
      function i(v) {
        var y = [], S;
        for (S in v) {
          var P = v[S];
          delete P.metadata, y.push(P);
        }
        return y;
      }
      var n = t === void 0 || typeof t == "string", o = {};
      n && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      }, o.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var s = {};
      if (s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
        s.geometry = e(t.geometries, this.geometry);
        var l = this.geometry.parameters;
        if (l !== void 0 && l.shapes !== void 0)
          if (l = l.shapes, Array.isArray(l))
            for (var h = 0, c = l.length; h < c; h++)
              e(t.shapes, l[h]);
          else
            e(t.shapes, l);
      }
      if (this.material !== void 0)
        if (Array.isArray(this.material)) {
          for (l = [], h = 0, c = this.material.length; h < c; h++)
            l.push(e(t.materials, this.material[h]));
          s.material = l;
        } else
          s.material = e(t.materials, this.material);
      if (0 < this.children.length)
        for (s.children = [], h = 0; h < this.children.length; h++)
          s.children.push(this.children[h].toJSON(t).object);
      if (n) {
        n = i(t.geometries), h = i(t.materials), c = i(t.textures);
        var f = i(t.images);
        l = i(t.shapes), 0 < n.length && (o.geometries = n), 0 < h.length && (o.materials = h), 0 < c.length && (o.textures = c), 0 < f.length && (o.images = f), 0 < l.length && (o.shapes = l);
      }
      return o.object = s, o;
    },
    clone: function(t) {
      return new this.constructor().copy(this, t);
    },
    copy: function(t, e) {
      if (e === void 0 && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
        for (e = 0; e < t.children.length; e++)
          this.add(t.children[e].clone());
      return this;
    }
  });
  var ch = 0;
  V.prototype = Object.assign(Object.create(J.prototype), {
    constructor: V,
    isGeometry: !0,
    applyMatrix: function(t) {
      for (var e = new C().getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++)
        this.vertices[i].applyMatrix4(t);
      for (i = 0, n = this.faces.length; i < n; i++) {
        t = this.faces[i], t.normal.applyMatrix3(e).normalize();
        for (var o = 0, s = t.vertexNormals.length; o < s; o++)
          t.vertexNormals[o].applyMatrix3(e).normalize();
      }
      return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
    },
    rotateX: function() {
      var t = new $();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new $();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new $();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new $();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new $();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new z();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    fromBufferGeometry: function(t) {
      function e(N, j, et, _t) {
        var mt = h === void 0 ? [] : [i.colors[N].clone(), i.colors[j].clone(), i.colors[et].clone()], bt = l === void 0 ? [] : [
          new m().fromArray(l, 3 * N),
          new m().fromArray(l, 3 * j),
          new m().fromArray(l, 3 * et)
        ];
        _t = new M(N, j, et, bt, mt, _t), i.faces.push(_t), c !== void 0 && i.faceVertexUvs[0].push([
          new p().fromArray(c, 2 * N),
          new p().fromArray(c, 2 * j),
          new p().fromArray(c, 2 * et)
        ]), f !== void 0 && i.faceVertexUvs[1].push([
          new p().fromArray(f, 2 * N),
          new p().fromArray(f, 2 * j),
          new p().fromArray(f, 2 * et)
        ]);
      }
      var i = this, n = t.index !== null ? t.index.array : void 0, o = t.attributes, s = o.position.array, l = o.normal !== void 0 ? o.normal.array : void 0, h = o.color !== void 0 ? o.color.array : void 0, c = o.uv !== void 0 ? o.uv.array : void 0, f = o.uv2 !== void 0 ? o.uv2.array : void 0;
      f !== void 0 && (this.faceVertexUvs[1] = []);
      for (var v = o = 0; o < s.length; o += 3, v += 2)
        i.vertices.push(new m().fromArray(s, o)), h !== void 0 && i.colors.push(new A().fromArray(h, o));
      var y = t.groups;
      if (0 < y.length)
        for (o = 0; o < y.length; o++) {
          s = y[o];
          var S = s.start, P = s.count;
          for (v = S, S += P; v < S; v += 3)
            n !== void 0 ? e(n[v], n[v + 1], n[v + 2], s.materialIndex) : e(v, v + 1, v + 2, s.materialIndex);
        }
      else if (n !== void 0)
        for (o = 0; o < n.length; o += 3)
          e(n[o], n[o + 1], n[o + 2]);
      else
        for (o = 0; o < s.length / 3; o += 3)
          e(o, o + 1, o + 2);
      return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
    },
    center: function() {
      var t = new m();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    normalize: function() {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center, e = this.boundingSphere.radius;
      e = e === 0 ? 1 : 1 / e;
      var i = new $();
      return i.set(
        e,
        0,
        0,
        -e * t.x,
        0,
        e,
        0,
        -e * t.y,
        0,
        0,
        e,
        -e * t.z,
        0,
        0,
        0,
        1
      ), this.applyMatrix(i), this;
    },
    computeFaceNormals: function() {
      for (var t = new m(), e = new m(), i = 0, n = this.faces.length; i < n; i++) {
        var o = this.faces[i], s = this.vertices[o.a], l = this.vertices[o.b];
        t.subVectors(this.vertices[o.c], l), e.subVectors(s, l), t.cross(e), t.normalize(), o.normal.copy(t);
      }
    },
    computeVertexNormals: function(t) {
      t === void 0 && (t = !0);
      var e, i = Array(this.vertices.length), n = 0;
      for (e = this.vertices.length; n < e; n++)
        i[n] = new m();
      if (t) {
        var o = new m(), s = new m();
        for (t = 0, n = this.faces.length; t < n; t++) {
          e = this.faces[t];
          var l = this.vertices[e.a], h = this.vertices[e.b], c = this.vertices[e.c];
          o.subVectors(c, h), s.subVectors(l, h), o.cross(s), i[e.a].add(o), i[e.b].add(o), i[e.c].add(o);
        }
      } else
        for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++)
          e = this.faces[t], i[e.a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal);
      for (n = 0, e = this.vertices.length; n < e; n++)
        i[n].normalize();
      for (t = 0, n = this.faces.length; t < n; t++)
        e = this.faces[t], l = e.vertexNormals, l.length === 3 ? (l[0].copy(i[e.a]), l[1].copy(i[e.b]), l[2].copy(i[e.c])) : (l[0] = i[e.a].clone(), l[1] = i[e.b].clone(), l[2] = i[e.c].clone());
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function() {
      var t;
      this.computeFaceNormals();
      var e = 0;
      for (t = this.faces.length; e < t; e++) {
        var i = this.faces[e], n = i.vertexNormals;
        n.length === 3 ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone());
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function() {
      var t, e, i = 0;
      for (e = this.faces.length; i < e; i++) {
        var n = this.faces[i];
        n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
        var o = 0;
        for (t = n.vertexNormals.length; o < t; o++)
          n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone();
      }
      var s = new V();
      for (s.faces = this.faces, o = 0, t = this.morphTargets.length; o < t; o++) {
        if (!this.morphNormals[o]) {
          this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
          var l = this.morphNormals[o].vertexNormals;
          for (i = 0, e = this.faces.length; i < e; i++) {
            var h = new m(), c = { a: new m(), b: new m(), c: new m() };
            n.push(h), l.push(c);
          }
        }
        for (l = this.morphNormals[o], s.vertices = this.morphTargets[o].vertices, s.computeFaceNormals(), s.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++)
          n = this.faces[i], h = l.faceNormals[i], c = l.vertexNormals[i], h.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2]);
      }
      for (i = 0, e = this.faces.length; i < e; i++)
        n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new K()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      this.boundingSphere === null && (this.boundingSphere = new B()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(t, e, i) {
      if (t && t.isGeometry) {
        var n, o = this.vertices.length, s = this.vertices, l = t.vertices, h = this.faces, c = t.faces, f = this.faceVertexUvs[0], v = t.faceVertexUvs[0], y = this.colors, S = t.colors;
        i === void 0 && (i = 0), e !== void 0 && (n = new C().getNormalMatrix(e)), t = 0;
        for (var P = l.length; t < P; t++) {
          var N = l[t].clone();
          e !== void 0 && N.applyMatrix4(e), s.push(N);
        }
        for (t = 0, P = S.length; t < P; t++)
          y.push(S[t].clone());
        for (t = 0, P = c.length; t < P; t++) {
          l = c[t];
          var j = l.vertexNormals;
          for (S = l.vertexColors, y = new M(l.a + o, l.b + o, l.c + o), y.normal.copy(l.normal), n !== void 0 && y.normal.applyMatrix3(n).normalize(), e = 0, s = j.length; e < s; e++)
            N = j[e].clone(), n !== void 0 && N.applyMatrix3(n).normalize(), y.vertexNormals.push(N);
          for (y.color.copy(l.color), e = 0, s = S.length; e < s; e++)
            N = S[e], y.vertexColors.push(N.clone());
          y.materialIndex = l.materialIndex + i, h.push(y);
        }
        for (t = 0, P = v.length; t < P; t++)
          if (i = v[t], n = [], i !== void 0) {
            for (e = 0, s = i.length; e < s; e++)
              n.push(i[e].clone());
            f.push(n);
          }
      } else
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          t
        );
    },
    mergeMesh: function(t) {
      t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error(
        "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
        t
      );
    },
    mergeVertices: function() {
      var t = {}, e = [], i = [], n = Math.pow(10, 4), o, s = 0;
      for (o = this.vertices.length; s < o; s++) {
        var l = this.vertices[s];
        l = Math.round(l.x * n) + "_" + Math.round(l.y * n) + "_" + Math.round(l.z * n), t[l] === void 0 ? (t[l] = s, e.push(this.vertices[s]), i[s] = e.length - 1) : i[s] = i[t[l]];
      }
      for (t = [], s = 0, o = this.faces.length; s < o; s++)
        for (n = this.faces[s], n.a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], l = 0; 3 > l; l++)
          if (n[l] === n[(l + 1) % 3]) {
            t.push(s);
            break;
          }
      for (s = t.length - 1; 0 <= s; s--)
        for (n = t[s], this.faces.splice(n, 1), i = 0, o = this.faceVertexUvs.length; i < o; i++)
          this.faceVertexUvs[i].splice(n, 1);
      return s = this.vertices.length - e.length, this.vertices = e, s;
    },
    setFromPoints: function(t) {
      this.vertices = [];
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.vertices.push(new m(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++)
        t[i]._id = i;
      t.sort(function(c, f) {
        return c.materialIndex - f.materialIndex;
      });
      var n = this.faceVertexUvs[0], o = this.faceVertexUvs[1], s, l;
      for (n && n.length === e && (s = []), o && o.length === e && (l = []), i = 0; i < e; i++) {
        var h = t[i]._id;
        s && s.push(n[h]), l && l.push(o[h]);
      }
      s && (this.faceVertexUvs[0] = s), l && (this.faceVertexUvs[1] = l);
    },
    toJSON: function() {
      function t(Wt, W, it) {
        return it ? Wt | 1 << W : Wt & ~(1 << W);
      }
      function e(Wt) {
        var W = Wt.x.toString() + Wt.y.toString() + Wt.z.toString();
        return f[W] !== void 0 || (f[W] = c.length / 3, c.push(Wt.x, Wt.y, Wt.z)), f[W];
      }
      function i(Wt) {
        var W = Wt.r.toString() + Wt.g.toString() + Wt.b.toString();
        return y[W] !== void 0 || (y[W] = v.length, v.push(Wt.getHex())), y[W];
      }
      function n(Wt) {
        var W = Wt.x.toString() + Wt.y.toString();
        return P[W] !== void 0 || (P[W] = S.length / 2, S.push(Wt.x, Wt.y)), P[W];
      }
      var o = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      if (o.uuid = this.uuid, o.type = this.type, this.name !== "" && (o.name = this.name), this.parameters !== void 0) {
        var s = this.parameters, l;
        for (l in s)
          s[l] !== void 0 && (o[l] = s[l]);
        return o;
      }
      for (s = [], l = 0; l < this.vertices.length; l++) {
        var h = this.vertices[l];
        s.push(h.x, h.y, h.z);
      }
      h = [];
      var c = [], f = {}, v = [], y = {}, S = [], P = {};
      for (l = 0; l < this.faces.length; l++) {
        var N = this.faces[l], j = this.faceVertexUvs[0][l] !== void 0, et = 0 < N.normal.length(), _t = 0 < N.vertexNormals.length, mt = N.color.r !== 1 || N.color.g !== 1 || N.color.b !== 1, bt = 0 < N.vertexColors.length, xt = 0;
        xt = t(xt, 0, 0), xt = t(xt, 1, !0), xt = t(xt, 2, !1), xt = t(xt, 3, j), xt = t(xt, 4, et), xt = t(xt, 5, _t), xt = t(xt, 6, mt), xt = t(xt, 7, bt), h.push(xt), h.push(N.a, N.b, N.c), h.push(N.materialIndex), j && (j = this.faceVertexUvs[0][l], h.push(n(j[0]), n(j[1]), n(j[2]))), et && h.push(e(N.normal)), _t && (et = N.vertexNormals, h.push(e(et[0]), e(et[1]), e(et[2]))), mt && h.push(i(N.color)), bt && (N = N.vertexColors, h.push(i(N[0]), i(N[1]), i(N[2])));
      }
      return o.data = {}, o.data.vertices = s, o.data.normals = c, 0 < v.length && (o.data.colors = v), 0 < S.length && (o.data.uvs = [S]), o.data.faces = h, o;
    },
    clone: function() {
      return new V().copy(this);
    },
    copy: function(t) {
      var e, i, n;
      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var o = t.vertices, s = 0;
      for (e = o.length; s < e; s++)
        this.vertices.push(o[s].clone());
      for (o = t.colors, s = 0, e = o.length; s < e; s++)
        this.colors.push(o[s].clone());
      for (o = t.faces, s = 0, e = o.length; s < e; s++)
        this.faces.push(o[s].clone());
      for (s = 0, e = t.faceVertexUvs.length; s < e; s++) {
        var l = t.faceVertexUvs[s];
        for (this.faceVertexUvs[s] === void 0 && (this.faceVertexUvs[s] = []), o = 0, i = l.length; o < i; o++) {
          var h = l[o], c = [], f = 0;
          for (n = h.length; f < n; f++)
            c.push(h[f].clone());
          this.faceVertexUvs[s].push(c);
        }
      }
      for (f = t.morphTargets, s = 0, e = f.length; s < e; s++) {
        if (n = {}, n.name = f[s].name, f[s].vertices !== void 0)
          for (n.vertices = [], o = 0, i = f[s].vertices.length; o < i; o++)
            n.vertices.push(f[s].vertices[o].clone());
        if (f[s].normals !== void 0)
          for (n.normals = [], o = 0, i = f[s].normals.length; o < i; o++)
            n.normals.push(f[s].normals[o].clone());
        this.morphTargets.push(n);
      }
      for (f = t.morphNormals, s = 0, e = f.length; s < e; s++) {
        if (n = {}, f[s].vertexNormals !== void 0)
          for (n.vertexNormals = [], o = 0, i = f[s].vertexNormals.length; o < i; o++)
            l = f[s].vertexNormals[o], h = {}, h.a = l.a.clone(), h.b = l.b.clone(), h.c = l.c.clone(), n.vertexNormals.push(h);
        if (f[s].faceNormals !== void 0)
          for (n.faceNormals = [], o = 0, i = f[s].faceNormals.length; o < i; o++)
            n.faceNormals.push(f[s].faceNormals[o].clone());
        this.morphNormals.push(n);
      }
      for (o = t.skinWeights, s = 0, e = o.length; s < e; s++)
        this.skinWeights.push(o[s].clone());
      for (o = t.skinIndices, s = 0, e = o.length; s < e; s++)
        this.skinIndices.push(o[s].clone());
      for (o = t.lineDistances, s = 0, e = o.length; s < e; s++)
        this.lineDistances.push(o[s]);
      return s = t.boundingBox, s !== null && (this.boundingBox = s.clone()), s = t.boundingSphere, s !== null && (this.boundingSphere = s.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Object.defineProperty(ht.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(ht.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.itemSize : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.itemSize, i *= e.itemSize;
      for (var n = 0, o = this.itemSize; n < o; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    copyArray: function(t) {
      return this.array.set(t), this;
    },
    copyColorsArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          n
        ), s = new A()), e[i++] = s.r, e[i++] = s.g, e[i++] = s.b;
      }
      return this;
    },
    copyVector2sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          n
        ), s = new p()), e[i++] = s.x, e[i++] = s.y;
      }
      return this;
    },
    copyVector3sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          n
        ), s = new m()), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z;
      }
      return this;
    },
    copyVector4sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          n
        ), s = new E()), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z, e[i++] = s.w;
      }
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    getX: function(t) {
      return this.array[t * this.itemSize];
    },
    setX: function(t, e) {
      return this.array[t * this.itemSize] = e, this;
    },
    getY: function(t) {
      return this.array[t * this.itemSize + 1];
    },
    setY: function(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    },
    getZ: function(t) {
      return this.array[t * this.itemSize + 2];
    },
    setZ: function(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    },
    getW: function(t) {
      return this.array[t * this.itemSize + 3];
    },
    setW: function(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    },
    setXY: function(t, e, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, o) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = o, this;
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }), ft.prototype = Object.create(ht.prototype), ft.prototype.constructor = ft, gt.prototype = Object.create(ht.prototype), gt.prototype.constructor = gt, zt.prototype = Object.create(ht.prototype), zt.prototype.constructor = zt, lt.prototype = Object.create(ht.prototype), lt.prototype.constructor = lt, Et.prototype = Object.create(ht.prototype), Et.prototype.constructor = Et, D.prototype = Object.create(ht.prototype), D.prototype.constructor = D, Bt.prototype = Object.create(ht.prototype), Bt.prototype.constructor = Bt, Ct.prototype = Object.create(ht.prototype), Ct.prototype.constructor = Ct, Rt.prototype = Object.create(ht.prototype), Rt.prototype.constructor = Rt, Object.assign(ge.prototype, {
    computeGroups: function(t) {
      var e = [], i = void 0;
      t = t.faces;
      for (var n = 0; n < t.length; n++) {
        var o = t[n];
        if (o.materialIndex !== i) {
          i = o.materialIndex, s !== void 0 && (s.count = 3 * n - s.start, e.push(s));
          var s = { start: 3 * n, materialIndex: i };
        }
      }
      s !== void 0 && (s.count = 3 * n - s.start, e.push(s)), this.groups = e;
    },
    fromGeometry: function(t) {
      var e = t.faces, i = t.vertices, n = t.faceVertexUvs, o = n[0] && 0 < n[0].length, s = n[1] && 0 < n[1].length, l = t.morphTargets, h = l.length;
      if (0 < h) {
        for (var c = [], f = 0; f < h; f++)
          c[f] = { name: l[f].name, data: [] };
        this.morphTargets.position = c;
      }
      var v = t.morphNormals, y = v.length;
      if (0 < y) {
        var S = [];
        for (f = 0; f < y; f++)
          S[f] = { name: v[f].name, data: [] };
        this.morphTargets.normal = S;
      }
      var P = t.skinIndices, N = t.skinWeights, j = P.length === i.length, et = N.length === i.length;
      for (0 < i.length && e.length === 0 && console.error(
        "THREE.DirectGeometry: Faceless geometries are not supported."
      ), f = 0; f < e.length; f++) {
        var _t = e[f];
        this.vertices.push(i[_t.a], i[_t.b], i[_t.c]);
        var mt = _t.vertexNormals;
        for (mt.length === 3 ? this.normals.push(mt[0], mt[1], mt[2]) : (mt = _t.normal, this.normals.push(mt, mt, mt)), mt = _t.vertexColors, mt.length === 3 ? this.colors.push(mt[0], mt[1], mt[2]) : (mt = _t.color, this.colors.push(mt, mt, mt)), o === !0 && (mt = n[0][f], mt !== void 0 ? this.uvs.push(mt[0], mt[1], mt[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
          f
        ), this.uvs.push(new p(), new p(), new p()))), s === !0 && (mt = n[1][f], mt !== void 0 ? this.uvs2.push(mt[0], mt[1], mt[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
          f
        ), this.uvs2.push(new p(), new p(), new p()))), mt = 0; mt < h; mt++) {
          var bt = l[mt].vertices;
          c[mt].data.push(bt[_t.a], bt[_t.b], bt[_t.c]);
        }
        for (mt = 0; mt < y; mt++)
          bt = v[mt].vertexNormals[f], S[mt].data.push(bt.a, bt.b, bt.c);
        j && this.skinIndices.push(P[_t.a], P[_t.b], P[_t.c]), et && this.skinWeights.push(N[_t.a], N[_t.b], N[_t.c]);
      }
      return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    }
  });
  var fh = 1;
  Ft.prototype = Object.assign(Object.create(J.prototype), {
    constructor: Ft,
    isBufferGeometry: !0,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(t) {
      Array.isArray(t) ? this.index = new (65535 < ue(t) ? Bt : Et)(t, 1) : this.index = t;
    },
    addAttribute: function(t, e, i) {
      return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? t === "index" ? (console.warn(
        "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
      ), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn(
        "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
      ), this.addAttribute(t, new ht(e, i)));
    },
    getAttribute: function(t) {
      return this.attributes[t];
    },
    removeAttribute: function(t) {
      return delete this.attributes[t], this;
    },
    addGroup: function(t, e, i) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: i !== void 0 ? i : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    },
    applyMatrix: function(t) {
      var e = this.attributes.position;
      return e !== void 0 && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, e !== void 0 && (new C().getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    },
    rotateX: function() {
      var t = new $();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new $();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new $();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new $();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new $();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new z();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    center: function() {
      var t = new m();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    setFromObject: function(t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        t = new Ct(3 * e.vertices.length, 3);
        var i = new Ct(3 * e.colors.length, 3);
        this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new Ct(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
      } else
        t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function(t) {
      for (var e = [], i = 0, n = t.length; i < n; i++) {
        var o = t[i];
        e.push(o.x, o.y, o.z || 0);
      }
      return this.addAttribute("position", new Ct(e, 3)), this;
    },
    updateFromObject: function(t) {
      var e = t.geometry;
      if (t.isMesh) {
        var i = e.__directGeometry;
        if (e.elementsNeedUpdate === !0 && (i = void 0, e.elementsNeedUpdate = !1), i === void 0)
          return this.fromGeometry(e);
        i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i;
      }
      return e.verticesNeedUpdate === !0 && (i = this.attributes.position, i !== void 0 && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), e.normalsNeedUpdate === !0 && (i = this.attributes.normal, i !== void 0 && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), e.colorsNeedUpdate === !0 && (i = this.attributes.color, i !== void 0 && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, i !== void 0 && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, i !== void 0 && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
    },
    fromGeometry: function(t) {
      return t.__directGeometry = new ge().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
    },
    fromDirectGeometry: function(t) {
      var e = new Float32Array(3 * t.vertices.length);
      this.addAttribute("position", new ht(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new ht(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new ht(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new ht(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new ht(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups;
      for (var i in t.morphTargets) {
        e = [];
        for (var n = t.morphTargets[i], o = 0, s = n.length; o < s; o++) {
          var l = n[o], h = new Ct(3 * l.data.length, 3);
          h.name = l.name, e.push(h.copyVector3sArray(l.data));
        }
        this.morphAttributes[i] = e;
      }
      return 0 < t.skinIndices.length && (i = new Ct(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new Ct(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new K());
      var t = this.attributes.position;
      t !== void 0 ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error(
        'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
    },
    computeBoundingSphere: function() {
      var t = new K(), e = new m();
      return function() {
        this.boundingSphere === null && (this.boundingSphere = new B());
        var i = this.attributes.position;
        if (i) {
          var n = this.boundingSphere.center;
          t.setFromBufferAttribute(i), t.getCenter(n);
          for (var o = 0, s = 0, l = i.count; s < l; s++)
            e.x = i.getX(s), e.y = i.getY(s), e.z = i.getZ(s), o = Math.max(o, n.distanceToSquared(e));
          this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
        }
      };
    }(),
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
      var t = this.index, e = this.attributes;
      if (e.position) {
        var i = e.position.array;
        if (e.normal === void 0)
          this.addAttribute("normal", new ht(new Float32Array(i.length), 3));
        else
          for (var n = e.normal.array, o = 0, s = n.length; o < s; o++)
            n[o] = 0;
        n = e.normal.array;
        var l = new m(), h = new m(), c = new m(), f = new m(), v = new m();
        if (t) {
          var y = t.array;
          for (o = 0, s = t.count; o < s; o += 3) {
            t = 3 * y[o + 0];
            var S = 3 * y[o + 1], P = 3 * y[o + 2];
            l.fromArray(i, t), h.fromArray(i, S), c.fromArray(i, P), f.subVectors(c, h), v.subVectors(l, h), f.cross(v), n[t] += f.x, n[t + 1] += f.y, n[t + 2] += f.z, n[S] += f.x, n[S + 1] += f.y, n[S + 2] += f.z, n[P] += f.x, n[P + 1] += f.y, n[P + 2] += f.z;
          }
        } else
          for (o = 0, s = i.length; o < s; o += 9)
            l.fromArray(i, o), h.fromArray(i, o + 3), c.fromArray(i, o + 6), f.subVectors(c, h), v.subVectors(l, h), f.cross(v), n[o] = f.x, n[o + 1] = f.y, n[o + 2] = f.z, n[o + 3] = f.x, n[o + 4] = f.y, n[o + 5] = f.z, n[o + 6] = f.x, n[o + 7] = f.y, n[o + 8] = f.z;
        this.normalizeNormals(), e.normal.needsUpdate = !0;
      }
    },
    merge: function(t, e) {
      if (t && t.isBufferGeometry) {
        e === void 0 && (e = 0, console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
        var i = this.attributes, n;
        for (n in i)
          if (t.attributes[n] !== void 0) {
            var o = i[n].array, s = t.attributes[n], l = s.array, h = 0;
            for (s = s.itemSize * e; h < l.length; h++, s++)
              o[s] = l[h];
          }
        return this;
      }
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
    },
    normalizeNormals: function() {
      var t = new m();
      return function() {
        for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z);
      };
    }(),
    toNonIndexed: function() {
      if (this.index === null)
        return console.warn(
          "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
        ), this;
      var t = new Ft(), e = this.index.array, i = this.attributes, n;
      for (n in i) {
        var o = i[n], s = o.array, l = o.itemSize, h = new s.constructor(e.length * l), c = 0;
        o = 0;
        for (var f = e.length; o < f; o++)
          for (var v = e[o] * l, y = 0; y < l; y++)
            h[c++] = s[v++];
        t.addAttribute(n, new ht(h, l));
      }
      for (e = this.groups, o = 0, f = e.length; o < f; o++)
        i = e[o], t.addGroup(i.start, i.count, i.materialIndex);
      return t;
    },
    toJSON: function() {
      var t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), this.parameters !== void 0) {
        var e = this.parameters;
        for (o in e)
          e[o] !== void 0 && (t[o] = e[o]);
        return t;
      }
      t.data = { attributes: {} };
      var i = this.index;
      i !== null && (e = Array.prototype.slice.call(i.array), t.data.index = { type: i.array.constructor.name, array: e }), i = this.attributes;
      for (o in i) {
        var n = i[o];
        e = Array.prototype.slice.call(n.array), t.data.attributes[o] = {
          itemSize: n.itemSize,
          type: n.array.constructor.name,
          array: e,
          normalized: n.normalized
        };
      }
      var o = this.groups;
      return 0 < o.length && (t.data.groups = JSON.parse(JSON.stringify(o))), o = this.boundingSphere, o !== null && (t.data.boundingSphere = {
        center: o.center.toArray(),
        radius: o.radius
      }), t;
    },
    clone: function() {
      return new Ft().copy(this);
    },
    copy: function(t) {
      var e;
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var i = t.index;
      i !== null && this.setIndex(i.clone()), i = t.attributes;
      for (l in i)
        this.addAttribute(l, i[l].clone());
      var n = t.morphAttributes;
      for (l in n) {
        var o = [], s = n[l];
        for (i = 0, e = s.length; i < e; i++)
          o.push(s[i].clone());
        this.morphAttributes[l] = o;
      }
      var l = t.groups;
      for (i = 0, e = l.length; i < e; i++)
        n = l[i], this.addGroup(n.start, n.count, n.materialIndex);
      return l = t.boundingBox, l !== null && (this.boundingBox = l.clone()), l = t.boundingSphere, l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Dt.prototype = Object.create(V.prototype), Dt.prototype.constructor = Dt, kt.prototype = Object.create(Ft.prototype), kt.prototype.constructor = kt, Fe.prototype = Object.create(V.prototype), Fe.prototype.constructor = Fe, xe.prototype = Object.create(Ft.prototype), xe.prototype.constructor = xe;
  var Nl = 0;
  Zt.prototype = Object.assign(Object.create(J.prototype), {
    constructor: Zt,
    isMaterial: !0,
    onBeforeCompile: function() {
    },
    setValues: function(t) {
      if (t !== void 0)
        for (var e in t) {
          var i = t[e];
          if (i === void 0)
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          else if (e === "shading")
            console.warn(
              "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
            ), this.flatShading = i === 1;
          else {
            var n = this[e];
            n === void 0 ? console.warn(
              "THREE." + this.type + ": '" + e + "' is not a property of this material."
            ) : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
          }
        }
    },
    toJSON: function(t) {
      function e(o) {
        var s = [], l;
        for (l in o) {
          var h = o[l];
          delete h.metadata, s.push(h);
        }
        return s;
      }
      var i = t === void 0 || typeof t == "string";
      i && (t = { textures: {}, images: {} });
      var n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      return n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearCoat !== void 0 && (n.clearCoat = this.clearCoat), this.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== 0 && (n.side = this.side), this.vertexColors !== 0 && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
      var e = t.clippingPlanes, i = null;
      if (e !== null) {
        var n = e.length;
        i = Array(n);
        for (var o = 0; o !== n; ++o)
          i[o] = e[o].clone();
      }
      return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), ti.prototype = Object.create(Zt.prototype), ti.prototype.constructor = ti, ti.prototype.isShaderMaterial = !0, ti.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = bn.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this;
  }, ti.prototype.toJSON = function(t) {
    var e = Zt.prototype.toJSON.call(this, t);
    e.uniforms = {};
    for (var i in this.uniforms) {
      var n = this.uniforms[i].value;
      e.uniforms[i] = n.isTexture ? { type: "t", value: n.toJSON(t).uuid } : n.isColor ? { type: "c", value: n.getHex() } : n.isVector2 ? { type: "v2", value: n.toArray() } : n.isVector3 ? { type: "v3", value: n.toArray() } : n.isVector4 ? { type: "v4", value: n.toArray() } : n.isMatrix4 ? { type: "m4", value: n.toArray() } : { value: n };
    }
    return 0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e;
  }, Object.assign(Ni.prototype, {
    set: function(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Ray: .at() target is now required"), e = new m()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    },
    recast: function() {
      var t = new m();
      return function(e) {
        return this.origin.copy(this.at(e, t)), this;
      };
    }(),
    closestPointToPoint: function(t, e) {
      return e === void 0 && (console.warn(
        "THREE.Ray: .closestPointToPoint() target is now required"
      ), e = new m()), e.subVectors(t, this.origin), t = e.dot(this.direction), 0 > t ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    distanceToPoint: function(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    },
    distanceSqToPoint: function() {
      var t = new m();
      return function(e) {
        var i = t.subVectors(e, this.origin).dot(this.direction);
        return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e));
      };
    }(),
    distanceSqToSegment: function() {
      var t = new m(), e = new m(), i = new m();
      return function(n, o, s, l) {
        t.copy(n).add(o).multiplyScalar(0.5), e.copy(o).sub(n).normalize(), i.copy(this.origin).sub(t);
        var h = 0.5 * n.distanceTo(o), c = -this.direction.dot(e), f = i.dot(this.direction), v = -i.dot(e), y = i.lengthSq(), S = Math.abs(1 - c * c);
        if (0 < S) {
          n = c * v - f, o = c * f - v;
          var P = h * S;
          0 <= n ? o >= -P ? o <= P ? (h = 1 / S, n *= h, o *= h, c = n * (n + c * o + 2 * f) + o * (c * n + o + 2 * v) + y) : (o = h, n = Math.max(0, -(c * o + f)), c = -n * n + o * (o + 2 * v) + y) : (o = -h, n = Math.max(0, -(c * o + f)), c = -n * n + o * (o + 2 * v) + y) : o <= -P ? (n = Math.max(0, -(-c * h + f)), o = 0 < n ? -h : Math.min(Math.max(-h, -v), h), c = -n * n + o * (o + 2 * v) + y) : o <= P ? (n = 0, o = Math.min(Math.max(-h, -v), h), c = o * (o + 2 * v) + y) : (n = Math.max(0, -(c * h + f)), o = 0 < n ? h : Math.min(Math.max(-h, -v), h), c = -n * n + o * (o + 2 * v) + y);
        } else
          o = 0 < c ? -h : h, n = Math.max(0, -(c * o + f)), c = -n * n + o * (o + 2 * v) + y;
        return s && s.copy(this.direction).multiplyScalar(n).add(this.origin), l && l.copy(e).multiplyScalar(o).add(t), c;
      };
    }(),
    intersectSphere: function() {
      var t = new m();
      return function(e, i) {
        t.subVectors(e.center, this.origin);
        var n = t.dot(this.direction), o = t.dot(t) - n * n;
        return e = e.radius * e.radius, o > e ? null : (e = Math.sqrt(e - o), o = n - e, n += e, 0 > o && 0 > n ? null : 0 > o ? this.at(n, i) : this.at(o, i));
      };
    }(),
    intersectsSphere: function(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    },
    distanceToPlane: function(t) {
      var e = t.normal.dot(this.direction);
      return e === 0 ? t.distanceToPoint(this.origin) === 0 ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, 0 <= t ? t : null);
    },
    intersectPlane: function(t, e) {
      return t = this.distanceToPlane(t), t === null ? null : this.at(t, e);
    },
    intersectsPlane: function(t) {
      var e = t.distanceToPoint(this.origin);
      return e === 0 || 0 > t.normal.dot(this.direction) * e;
    },
    intersectBox: function(t, e) {
      var i = 1 / this.direction.x, n = 1 / this.direction.y, o = 1 / this.direction.z, s = this.origin;
      if (0 <= i) {
        var l = (t.min.x - s.x) * i;
        i *= t.max.x - s.x;
      } else
        l = (t.max.x - s.x) * i, i *= t.min.x - s.x;
      if (0 <= n) {
        var h = (t.min.y - s.y) * n;
        n *= t.max.y - s.y;
      } else
        h = (t.max.y - s.y) * n, n *= t.min.y - s.y;
      return l > n || h > i || ((h > l || l !== l) && (l = h), (n < i || i !== i) && (i = n), 0 <= o ? (h = (t.min.z - s.z) * o, t = (t.max.z - s.z) * o) : (h = (t.max.z - s.z) * o, t = (t.min.z - s.z) * o), l > t || h > i) ? null : ((h > l || l !== l) && (l = h), (t < i || i !== i) && (i = t), 0 > i ? null : this.at(0 <= l ? l : i, e));
    },
    intersectsBox: function() {
      var t = new m();
      return function(e) {
        return this.intersectBox(e, t) !== null;
      };
    }(),
    intersectTriangle: function() {
      var t = new m(), e = new m(), i = new m(), n = new m();
      return function(o, s, l, h, c) {
        if (e.subVectors(s, o), i.subVectors(l, o), n.crossVectors(e, i), s = this.direction.dot(n), 0 < s) {
          if (h)
            return null;
          h = 1;
        } else if (0 > s)
          h = -1, s = -s;
        else
          return null;
        return t.subVectors(this.origin, o), o = h * this.direction.dot(i.crossVectors(t, i)), 0 > o || (l = h * this.direction.dot(e.cross(t)), 0 > l || o + l > s) ? null : (o = -h * t.dot(n), 0 > o ? null : this.at(o / s, c));
      };
    }(),
    applyMatrix4: function(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    },
    equals: function(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
  }), Object.assign(Ie, {
    getNormal: function() {
      var t = new m();
      return function(e, i, n, o) {
        return o === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new m()), o.subVectors(n, i), t.subVectors(e, i), o.cross(t), e = o.lengthSq(), 0 < e ? o.multiplyScalar(1 / Math.sqrt(e)) : o.set(0, 0, 0);
      };
    }(),
    getBarycoord: function() {
      var t = new m(), e = new m(), i = new m();
      return function(n, o, s, l, h) {
        t.subVectors(l, o), e.subVectors(s, o), i.subVectors(n, o), n = t.dot(t), o = t.dot(e), s = t.dot(i);
        var c = e.dot(e);
        l = e.dot(i);
        var f = n * c - o * o;
        return h === void 0 && (console.warn(
          "THREE.Triangle: .getBarycoord() target is now required"
        ), h = new m()), f === 0 ? h.set(-2, -1, -1) : (f = 1 / f, c = (c * s - o * l) * f, n = (n * l - o * s) * f, h.set(1 - c - n, n, c));
      };
    }(),
    containsPoint: function() {
      var t = new m();
      return function(e, i, n, o) {
        return Ie.getBarycoord(e, i, n, o, t), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y;
      };
    }(),
    getUV: function() {
      var t = new m();
      return function(e, i, n, o, s, l, h, c) {
        return this.getBarycoord(e, i, n, o, t), c.set(0, 0), c.addScaledVector(s, t.x), c.addScaledVector(l, t.y), c.addScaledVector(h, t.z), c;
      };
    }()
  }), Object.assign(Ie.prototype, {
    set: function(t, e, i) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
    },
    setFromPointsAndIndices: function(t, e, i, n) {
      return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    },
    getArea: function() {
      var t = new m(), e = new m();
      return function() {
        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), 0.5 * t.cross(e).length();
      };
    }(),
    getMidpoint: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new m()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(t) {
      return Ie.getNormal(this.a, this.b, this.c, t);
    },
    getPlane: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new m()), t.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(t, e) {
      return Ie.getBarycoord(t, this.a, this.b, this.c, e);
    },
    containsPoint: function(t) {
      return Ie.containsPoint(t, this.a, this.b, this.c);
    },
    getUV: function(t, e, i, n, o) {
      return Ie.getUV(t, this.a, this.b, this.c, e, i, n, o);
    },
    intersectsBox: function(t) {
      return t.intersectsTriangle(this);
    },
    closestPointToPoint: function() {
      var t = new m(), e = new m(), i = new m(), n = new m(), o = new m(), s = new m();
      return function(l, h) {
        h === void 0 && (console.warn(
          "THREE.Triangle: .closestPointToPoint() target is now required"
        ), h = new m());
        var c = this.a, f = this.b, v = this.c;
        t.subVectors(f, c), e.subVectors(v, c), n.subVectors(l, c);
        var y = t.dot(n), S = e.dot(n);
        if (0 >= y && 0 >= S)
          return h.copy(c);
        o.subVectors(l, f);
        var P = t.dot(o), N = e.dot(o);
        if (0 <= P && N <= P)
          return h.copy(f);
        var j = y * N - P * S;
        if (0 >= j && 0 <= y && 0 >= P)
          return f = y / (y - P), h.copy(c).addScaledVector(t, f);
        s.subVectors(l, v), l = t.dot(s);
        var et = e.dot(s);
        return 0 <= et && l <= et ? h.copy(v) : (y = l * S - y * et, 0 >= y && 0 <= S && 0 >= et ? (j = S / (S - et), h.copy(c).addScaledVector(e, j)) : (S = P * et - l * N, 0 >= S && 0 <= N - P && 0 <= l - et ? (i.subVectors(v, f), j = (N - P) / (N - P + (l - et)), h.copy(f).addScaledVector(i, j)) : (v = 1 / (S + y + j), f = y * v, j *= v, h.copy(c).addScaledVector(t, f).addScaledVector(e, j))));
      };
    }(),
    equals: function(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }), Ge.prototype = Object.create(Zt.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isMeshBasicMaterial = !0, Ge.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
  }, pi.prototype = Object.assign(Object.create(z.prototype), {
    constructor: pi,
    isMesh: !0,
    setDrawMode: function(t) {
      this.drawMode = t;
    },
    copy: function(t) {
      return z.prototype.copy.call(this, t), this.drawMode = t.drawMode, t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign(
        {},
        t.morphTargetDictionary
      )), this;
    },
    updateMorphTargets: function() {
      var t = this.geometry;
      if (t.isBufferGeometry) {
        t = t.morphAttributes;
        var e = Object.keys(t);
        if (0 < e.length) {
          var i = t[e[0]];
          if (i !== void 0)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
              var n = i[t].name || String(t);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
            }
        }
      } else if (i = t.morphTargets, i !== void 0 && 0 < i.length)
        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++)
          n = i[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
    },
    raycast: function() {
      function t(et, _t, mt, bt, xt, Wt, W, it) {
        return (_t.side === 1 ? bt.intersectTriangle(W, Wt, xt, !0, it) : bt.intersectTriangle(xt, Wt, W, _t.side !== 2, it)) === null ? null : (j.copy(it), j.applyMatrix4(et.matrixWorld), _t = mt.ray.origin.distanceTo(j), _t < mt.near || _t > mt.far ? null : { distance: _t, point: j.clone(), object: et });
      }
      function e(et, _t, mt, bt, xt, Wt, W, it, It) {
        return s.fromBufferAttribute(xt, W), l.fromBufferAttribute(xt, it), h.fromBufferAttribute(xt, It), (et = t(et, _t, mt, bt, s, l, h, N)) && (Wt && (y.fromBufferAttribute(Wt, W), S.fromBufferAttribute(Wt, it), P.fromBufferAttribute(Wt, It), et.uv = Ie.getUV(N, s, l, h, y, S, P, new p())), Wt = new M(W, it, It), Ie.getNormal(s, l, h, Wt.normal), et.face = Wt), et;
      }
      var i = new $(), n = new Ni(), o = new B(), s = new m(), l = new m(), h = new m(), c = new m(), f = new m(), v = new m(), y = new p(), S = new p(), P = new p(), N = new m(), j = new m();
      return function(et, _t) {
        var mt = this.geometry, bt = this.material, xt = this.matrixWorld;
        if (bt !== void 0 && (mt.boundingSphere === null && mt.computeBoundingSphere(), o.copy(mt.boundingSphere), o.applyMatrix4(xt), et.ray.intersectsSphere(o) !== !1 && (i.getInverse(xt), n.copy(et.ray).applyMatrix4(i), mt.boundingBox === null || n.intersectsBox(mt.boundingBox) !== !1))) {
          if (mt.isBufferGeometry) {
            var Wt = mt.index, W = mt.attributes.position, it = mt.attributes.uv, It = mt.groups;
            mt = mt.drawRange;
            var ee;
            if (Wt !== null)
              if (Array.isArray(bt)) {
                var $t = 0;
                for (ee = It.length; $t < ee; $t++) {
                  var qt = It[$t], Te = bt[qt.materialIndex];
                  xt = Math.max(qt.start, mt.start);
                  var pe = Math.min(qt.start + qt.count, mt.start + mt.count);
                  for (qt = xt; qt < pe; qt += 3) {
                    xt = Wt.getX(qt);
                    var Oe = Wt.getX(qt + 1), be = Wt.getX(qt + 2);
                    (xt = e(this, Te, et, n, W, it, xt, Oe, be)) && (xt.faceIndex = Math.floor(qt / 3), _t.push(xt));
                  }
                }
              } else
                for (xt = Math.max(0, mt.start), pe = Math.min(Wt.count, mt.start + mt.count), $t = xt, ee = pe; $t < ee; $t += 3)
                  xt = Wt.getX($t), Oe = Wt.getX($t + 1), be = Wt.getX($t + 2), (xt = e(this, bt, et, n, W, it, xt, Oe, be)) && (xt.faceIndex = Math.floor($t / 3), _t.push(xt));
            else if (W !== void 0)
              if (Array.isArray(bt))
                for ($t = 0, ee = It.length; $t < ee; $t++)
                  for (qt = It[$t], Te = bt[qt.materialIndex], xt = Math.max(qt.start, mt.start), pe = Math.min(qt.start + qt.count, mt.start + mt.count), qt = xt; qt < pe; qt += 3)
                    xt = qt, Oe = qt + 1, be = qt + 2, (xt = e(this, Te, et, n, W, it, xt, Oe, be)) && (xt.faceIndex = Math.floor(qt / 3), _t.push(xt));
              else
                for (xt = Math.max(0, mt.start), pe = Math.min(W.count, mt.start + mt.count), $t = xt, ee = pe; $t < ee; $t += 3)
                  xt = $t, Oe = $t + 1, be = $t + 2, (xt = e(this, bt, et, n, W, it, xt, Oe, be)) && (xt.faceIndex = Math.floor($t / 3), _t.push(xt));
          } else if (mt.isGeometry) {
            for (W = Array.isArray(bt), it = mt.vertices, It = mt.faces, xt = mt.faceVertexUvs[0], 0 < xt.length && (Wt = xt), qt = 0, pe = It.length; qt < pe; qt++)
              if (Oe = It[qt], xt = W ? bt[Oe.materialIndex] : bt, xt !== void 0) {
                if ($t = it[Oe.a], ee = it[Oe.b], Te = it[Oe.c], xt.morphTargets === !0) {
                  be = mt.morphTargets;
                  var se = this.morphTargetInfluences;
                  s.set(0, 0, 0), l.set(0, 0, 0), h.set(0, 0, 0);
                  for (var je = 0, Ke = be.length; je < Ke; je++) {
                    var ci = se[je];
                    if (ci !== 0) {
                      var yn = be[je].vertices;
                      s.addScaledVector(c.subVectors(yn[Oe.a], $t), ci), l.addScaledVector(f.subVectors(yn[Oe.b], ee), ci), h.addScaledVector(v.subVectors(yn[Oe.c], Te), ci);
                    }
                  }
                  s.add($t), l.add(ee), h.add(Te), $t = s, ee = l, Te = h;
                }
                (xt = t(this, xt, et, n, $t, ee, Te, N)) && (Wt && Wt[qt] && (be = Wt[qt], y.copy(be[0]), S.copy(be[1]), P.copy(be[2]), xt.uv = Ie.getUV(N, $t, ee, Te, y, S, P, new p())), xt.face = Oe, xt.faceIndex = qt, _t.push(xt));
              }
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), w.prototype = Object.create(O.prototype), w.prototype.constructor = w, w.prototype.isCubeTexture = !0, Object.defineProperty(w.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(t) {
      this.image = t;
    }
  }), X.prototype = Object.create(O.prototype), X.prototype.constructor = X, X.prototype.isDataTexture3D = !0;
  var fl = new O(), ph = new X(), kl = new w(), Ga = [], zs = [], ma = new Float32Array(16), Ul = new Float32Array(9), pl = new Float32Array(4);
  us.prototype.updateCache = function(t) {
    var e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), vt(e, t);
  }, Ws.prototype.setValue = function(t, e, i) {
    for (var n = this.seq, o = 0, s = n.length; o !== s; ++o) {
      var l = n[o];
      l.setValue(t, e[l.id], i);
    }
  };
  var dl = /([\w\d_]+)(\])?(\[|\.)?/g;
  Or.prototype.setValue = function(t, e, i) {
    e = this.map[e], e !== void 0 && e.setValue(t, i, this.renderer);
  }, Or.prototype.setOptional = function(t, e, i) {
    e = e[i], e !== void 0 && this.setValue(t, i, e);
  }, Or.upload = function(t, e, i, n) {
    for (var o = 0, s = e.length; o !== s; ++o) {
      var l = e[o], h = i[l.id];
      h.needsUpdate !== !1 && l.setValue(t, h.value, n);
    }
  }, Or.seqWithValue = function(t, e) {
    for (var i = [], n = 0, o = t.length; n !== o; ++n) {
      var s = t[n];
      s.id in e && i.push(s);
    }
    return i;
  };
  var so = 0, ml = 0;
  oe.prototype = Object.create(Zt.prototype), oe.prototype.constructor = oe, oe.prototype.isMeshDepthMaterial = !0, oe.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }, te.prototype = Object.create(Zt.prototype), te.prototype.constructor = te, te.prototype.isMeshDistanceMaterial = !0, te.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }, ui.prototype = Object.assign(Object.create(z.prototype), {
    constructor: ui,
    isGroup: !0
  }), Be.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Be,
    isCamera: !0,
    copy: function(t, e) {
      return z.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    },
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Camera: .getWorldDirection() target is now required"
      ), t = new m()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(t) {
      z.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), ye.prototype = Object.assign(Object.create(Be.prototype), {
    constructor: ye,
    isPerspectiveCamera: !0,
    copy: function(t, e) {
      return Be.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    },
    setFocalLength: function(t) {
      t = 0.5 * this.getFilmHeight() / t, this.fov = 2 * fi.RAD2DEG * Math.atan(t), this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      var t = Math.tan(0.5 * fi.DEG2RAD * this.fov);
      return 0.5 * this.getFilmHeight() / t;
    },
    getEffectiveFOV: function() {
      return 2 * fi.RAD2DEG * Math.atan(Math.tan(0.5 * fi.DEG2RAD * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(t, e, i, n, o, s) {
      this.aspect = t / e, this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = o, this.view.height = s, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = this.near, e = t * Math.tan(0.5 * fi.DEG2RAD * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, o = -0.5 * n, s = this.view;
      if (this.view !== null && this.view.enabled) {
        var l = s.fullWidth, h = s.fullHeight;
        o += s.offsetX * n / l, e -= s.offsetY * i / h, n *= s.width / l, i *= s.height / h;
      }
      s = this.filmOffset, s !== 0 && (o += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = z.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }), ke.prototype = Object.assign(Object.create(ye.prototype), {
    constructor: ke,
    isArrayCamera: !0
  });
  var bo = new m(), rr = new m();
  Le.prototype.isFogExp2 = !0, Le.prototype.clone = function() {
    return new Le(this.color, this.density);
  }, Le.prototype.toJSON = function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }, mn.prototype.isFog = !0, mn.prototype.clone = function() {
    return new mn(this.color, this.near, this.far);
  }, mn.prototype.toJSON = function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }, On.prototype = Object.assign(Object.create(z.prototype), {
    constructor: On,
    copy: function(t, e) {
      return z.prototype.copy.call(this, t, e), t.background !== null && (this.background = t.background.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    },
    toJSON: function(t) {
      var e = z.prototype.toJSON.call(this, t);
      return this.background !== null && (e.object.background = this.background.toJSON(t)), this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
    }
  }), Object.defineProperty(Ii.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(Ii.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.stride : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.stride, i *= e.stride;
      for (var n = 0, o = this.stride; n < o; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    }
  }), Object.defineProperties(Oi.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    }
  }), Object.assign(Oi.prototype, {
    isInterleavedBufferAttribute: !0,
    setX: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    },
    setY: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    },
    setZ: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    },
    setW: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    },
    getX: function(t) {
      return this.data.array[t * this.data.stride + this.offset];
    },
    getY: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    },
    getZ: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    },
    getW: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    },
    setXY: function(t, e, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, o) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = o, this;
    }
  }), Ui.prototype = Object.create(Zt.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isSpriteMaterial = !0, Ui.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
  };
  var Bs;
  $i.prototype = Object.assign(Object.create(z.prototype), {
    constructor: $i,
    isSprite: !0,
    raycast: function() {
      function t(P, N, j, et, _t, mt) {
        o.subVectors(P, j).addScalar(0.5).multiply(et), _t !== void 0 ? (s.x = mt * o.x - _t * o.y, s.y = _t * o.x + mt * o.y) : s.copy(o), P.copy(N), P.x += s.x, P.y += s.y, P.applyMatrix4(l);
      }
      var e = new m(), i = new m(), n = new m(), o = new p(), s = new p(), l = new $(), h = new m(), c = new m(), f = new m(), v = new p(), y = new p(), S = new p();
      return function(P, N) {
        i.setFromMatrixScale(this.matrixWorld), l.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
        var j = this.material.rotation;
        if (j !== 0)
          var et = Math.cos(j), _t = Math.sin(j);
        j = this.center, t(h.set(-0.5, -0.5, 0), n, j, i, _t, et), t(c.set(0.5, -0.5, 0), n, j, i, _t, et), t(f.set(0.5, 0.5, 0), n, j, i, _t, et), v.set(0, 0), y.set(1, 0), S.set(1, 1);
        var mt = P.ray.intersectTriangle(h, c, f, !1, e);
        mt === null && (t(c.set(-0.5, 0.5, 0), n, j, i, _t, et), y.set(0, 1), mt = P.ray.intersectTriangle(h, f, c, !1, e), mt === null) || (_t = P.ray.origin.distanceTo(e), _t < P.near || _t > P.far || N.push({
          distance: _t,
          point: e.clone(),
          uv: Ie.getUV(e, h, c, f, v, y, S, new p()),
          face: null,
          object: this
        }));
      };
    }(),
    clone: function() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function(t) {
      return z.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this;
    }
  }), Ki.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Ki,
    copy: function(t) {
      z.prototype.copy.call(this, t, !1), t = t.levels;
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.addLevel(n.object.clone(), n.distance);
      }
      return this;
    },
    addLevel: function(t, e) {
      e === void 0 && (e = 0), e = Math.abs(e);
      for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++)
        ;
      i.splice(n, 0, { distance: e, object: t }), this.add(t);
    },
    getObjectForDistance: function(t) {
      for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
        ;
      return e[i - 1].object;
    },
    raycast: function() {
      var t = new m();
      return function(e, i) {
        t.setFromMatrixPosition(this.matrixWorld);
        var n = e.ray.origin.distanceTo(t);
        this.getObjectForDistance(n).raycast(e, i);
      };
    }(),
    update: function() {
      var t = new m(), e = new m();
      return function(i) {
        var n = this.levels;
        if (1 < n.length) {
          t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0;
          for (var o = 1, s = n.length; o < s && i >= n[o].distance; o++)
            n[o - 1].object.visible = !1, n[o].object.visible = !0;
          for (; o < s; o++)
            n[o].object.visible = !1;
        }
      };
    }(),
    toJSON: function(t) {
      t = z.prototype.toJSON.call(this, t), t.object.levels = [];
      for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
        var o = e[i];
        t.object.levels.push({ object: o.object.uuid, distance: o.distance });
      }
      return t;
    }
  }), Object.assign(nn.prototype, {
    calculateInverses: function() {
      this.boneInverses = [];
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var i = new $();
        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i);
      }
    },
    pose: function() {
      var t, e, i = 0;
      for (e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
      for (i = 0, e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
    },
    update: function() {
      var t = new $(), e = new $();
      return function() {
        for (var i = this.bones, n = this.boneInverses, o = this.boneMatrices, s = this.boneTexture, l = 0, h = i.length; l < h; l++)
          t.multiplyMatrices(i[l] ? i[l].matrixWorld : e, n[l]), t.toArray(o, 16 * l);
        s !== void 0 && (s.needsUpdate = !0);
      };
    }(),
    clone: function() {
      return new nn(this.bones, this.boneInverses);
    },
    getBoneByName: function(t) {
      for (var e = 0, i = this.bones.length; e < i; e++) {
        var n = this.bones[e];
        if (n.name === t)
          return n;
      }
    }
  }), rn.prototype = Object.assign(Object.create(z.prototype), {
    constructor: rn,
    isBone: !0
  }), ki.prototype = Object.assign(Object.create(pi.prototype), {
    constructor: ki,
    isSkinnedMesh: !0,
    initBones: function() {
      var t = [], e;
      if (this.geometry && this.geometry.bones !== void 0) {
        var i = 0;
        for (e = this.geometry.bones.length; i < e; i++) {
          var n = this.geometry.bones[i], o = new rn();
          t.push(o), o.name = n.name, o.position.fromArray(n.pos), o.quaternion.fromArray(n.rotq), n.scl !== void 0 && o.scale.fromArray(n.scl);
        }
        for (i = 0, e = this.geometry.bones.length; i < e; i++)
          n = this.geometry.bones[i], n.parent !== -1 && n.parent !== null && t[n.parent] !== void 0 ? t[n.parent].add(t[i]) : this.add(t[i]);
      }
      return this.updateMatrixWorld(!0), t;
    },
    bind: function(t, e) {
      this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      var t;
      if (this.geometry && this.geometry.isGeometry)
        for (t = 0; t < this.geometry.skinWeights.length; t++) {
          var e = this.geometry.skinWeights[t], i = 1 / e.manhattanLength();
          i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0);
        }
      else if (this.geometry && this.geometry.isBufferGeometry) {
        e = new E();
        var n = this.geometry.attributes.skinWeight;
        for (t = 0; t < n.count; t++)
          e.x = n.getX(t), e.y = n.getY(t), e.z = n.getZ(t), e.w = n.getW(t), i = 1 / e.manhattanLength(), i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), n.setXYZW(t, e.x, e.y, e.z, e.w);
      }
    },
    updateMatrixWorld: function(t) {
      pi.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn(
        "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
      );
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), Di.prototype = Object.create(Zt.prototype), Di.prototype.constructor = Di, Di.prototype.isLineBasicMaterial = !0, Di.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
  }, Hi.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Hi,
    isLine: !0,
    computeLineDistances: function() {
      var t = new m(), e = new m();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, o = [0], s = 1, l = n.count; s < l; s++)
              t.fromBufferAttribute(n, s - 1), e.fromBufferAttribute(n, s), o[s] = o[s - 1], o[s] += t.distanceTo(e);
            i.addAttribute("lineDistance", new Ct(o, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, o = i.lineDistances, o[0] = 0, s = 1, l = n.length; s < l; s++)
            o[s] = o[s - 1], o[s] += n[s - 1].distanceTo(n[s]);
        return this;
      };
    }(),
    raycast: function() {
      var t = new $(), e = new Ni(), i = new B();
      return function(n, o) {
        var s = n.linePrecision, l = this.geometry, h = this.matrixWorld;
        if (l.boundingSphere === null && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(h), i.radius += s, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(h), e.copy(n.ray).applyMatrix4(t), s /= (this.scale.x + this.scale.y + this.scale.z) / 3, s *= s;
          var c = new m(), f = new m();
          h = new m();
          var v = new m(), y = this && this.isLineSegments ? 2 : 1;
          if (l.isBufferGeometry) {
            var S = l.index, P = l.attributes.position.array;
            if (S !== null) {
              S = S.array, l = 0;
              for (var N = S.length - 1; l < N; l += y) {
                var j = S[l + 1];
                c.fromArray(P, 3 * S[l]), f.fromArray(P, 3 * j), j = e.distanceSqToSegment(c, f, v, h), j > s || (v.applyMatrix4(this.matrixWorld), j = n.ray.origin.distanceTo(v), j < n.near || j > n.far || o.push({
                  distance: j,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: l,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
              }
            } else
              for (l = 0, N = P.length / 3 - 1; l < N; l += y)
                c.fromArray(P, 3 * l), f.fromArray(P, 3 * l + 3), j = e.distanceSqToSegment(c, f, v, h), j > s || (v.applyMatrix4(this.matrixWorld), j = n.ray.origin.distanceTo(v), j < n.near || j > n.far || o.push({
                  distance: j,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: l,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
          } else if (l.isGeometry)
            for (c = l.vertices, f = c.length, l = 0; l < f - 1; l += y)
              j = e.distanceSqToSegment(c[l], c[l + 1], v, h), j > s || (v.applyMatrix4(this.matrixWorld), j = n.ray.origin.distanceTo(v), j < n.near || j > n.far || o.push({
                distance: j,
                point: h.clone().applyMatrix4(this.matrixWorld),
                index: l,
                face: null,
                faceIndex: null,
                object: this
              }));
        }
      };
    }(),
    copy: function(t) {
      return z.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), mi.prototype = Object.assign(Object.create(Hi.prototype), {
    constructor: mi,
    isLineSegments: !0,
    computeLineDistances: function() {
      var t = new m(), e = new m();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, o = [], s = 0, l = n.count; s < l; s += 2)
              t.fromBufferAttribute(n, s), e.fromBufferAttribute(n, s + 1), o[s] = s === 0 ? 0 : o[s - 1], o[s + 1] = o[s] + t.distanceTo(e);
            i.addAttribute("lineDistance", new Ct(o, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, o = i.lineDistances, s = 0, l = n.length; s < l; s += 2)
            t.copy(n[s]), e.copy(n[s + 1]), o[s] = s === 0 ? 0 : o[s - 1], o[s + 1] = o[s] + t.distanceTo(e);
        return this;
      };
    }()
  }), zr.prototype = Object.assign(Object.create(Hi.prototype), {
    constructor: zr,
    isLineLoop: !0
  }), Cn.prototype = Object.create(Zt.prototype), Cn.prototype.constructor = Cn, Cn.prototype.isPointsMaterial = !0, Cn.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
  }, ps.prototype = Object.assign(Object.create(z.prototype), {
    constructor: ps,
    isPoints: !0,
    raycast: function() {
      var t = new $(), e = new Ni(), i = new B();
      return function(n, o) {
        function s(et, _t) {
          var mt = e.distanceSqToPoint(et);
          mt < v && (e.closestPointToPoint(et, y), y.applyMatrix4(c), et = n.ray.origin.distanceTo(y), et < n.near || et > n.far || o.push({
            distance: et,
            distanceToRay: Math.sqrt(mt),
            point: y.clone(),
            index: _t,
            face: null,
            object: l
          }));
        }
        var l = this, h = this.geometry, c = this.matrixWorld, f = n.params.Points.threshold;
        if (h.boundingSphere === null && h.computeBoundingSphere(), i.copy(h.boundingSphere), i.applyMatrix4(c), i.radius += f, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(c), e.copy(n.ray).applyMatrix4(t), f /= (this.scale.x + this.scale.y + this.scale.z) / 3;
          var v = f * f;
          f = new m();
          var y = new m();
          if (h.isBufferGeometry) {
            var S = h.index;
            if (h = h.attributes.position.array, S !== null) {
              var P = S.array;
              S = 0;
              for (var N = P.length; S < N; S++) {
                var j = P[S];
                f.fromArray(h, 3 * j), s(f, j);
              }
            } else
              for (S = 0, P = h.length / 3; S < P; S++)
                f.fromArray(h, 3 * S), s(f, S);
          } else
            for (f = h.vertices, S = 0, P = f.length; S < P; S++)
              s(f[S], S);
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), tl.prototype = Object.assign(Object.create(O.prototype), {
    constructor: tl,
    isVideoTexture: !0,
    update: function() {
      var t = this.image;
      t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  }), fo.prototype = Object.create(O.prototype), fo.prototype.constructor = fo, fo.prototype.isCompressedTexture = !0, Vs.prototype = Object.create(O.prototype), Vs.prototype.constructor = Vs, Vs.prototype.isCanvasTexture = !0, Xs.prototype = Object.create(O.prototype), Xs.prototype.constructor = Xs, Xs.prototype.isDepthTexture = !0, ds.prototype = Object.create(Ft.prototype), ds.prototype.constructor = ds, qs.prototype = Object.create(V.prototype), qs.prototype.constructor = qs, ms.prototype = Object.create(Ft.prototype), ms.prototype.constructor = ms, Wi.prototype = Object.create(V.prototype), Wi.prototype.constructor = Wi, _i.prototype = Object.create(Ft.prototype), _i.prototype.constructor = _i, Ys.prototype = Object.create(V.prototype), Ys.prototype.constructor = Ys, gs.prototype = Object.create(_i.prototype), gs.prototype.constructor = gs, Zs.prototype = Object.create(V.prototype), Zs.prototype.constructor = Zs, Oo.prototype = Object.create(_i.prototype), Oo.prototype.constructor = Oo, Js.prototype = Object.create(V.prototype), Js.prototype.constructor = Js, vs.prototype = Object.create(_i.prototype), vs.prototype.constructor = vs, ys.prototype = Object.create(V.prototype), ys.prototype.constructor = ys, _s.prototype = Object.create(_i.prototype), _s.prototype.constructor = _s, ln.prototype = Object.create(V.prototype), ln.prototype.constructor = ln, po.prototype = Object.create(Ft.prototype), po.prototype.constructor = po, Mr.prototype = Object.create(V.prototype), Mr.prototype.constructor = Mr, Do.prototype = Object.create(Ft.prototype), Do.prototype.constructor = Do, zo.prototype = Object.create(V.prototype), zo.prototype.constructor = zo, Pn.prototype = Object.create(Ft.prototype), Pn.prototype.constructor = Pn;
  var Fl = {
    triangulate: function(t, e, i) {
      i = i || 2;
      var n = e && e.length, o = n ? e[0] * i : t.length, s = el(t, 0, o, i, !0), l = [];
      if (!s)
        return l;
      var h;
      if (n) {
        var c = i;
        n = [];
        var f, v = 0;
        for (f = e.length; v < f; v++) {
          var y = e[v] * c, S = v < f - 1 ? e[v + 1] * c : t.length;
          y = el(t, y, S, c, !1), y === y.next && (y.steiner = !0), n.push(er(y));
        }
        for (n.sort(bl), v = 0; v < n.length; v++)
          e = n[v], c = s, (c = Al(e, c)) && (e = $s(c, e), xs(e, e.next)), s = xs(s, s.next);
      }
      if (t.length > 80 * i) {
        var P = h = t[0], N = n = t[1];
        for (c = i; c < o; c += i)
          v = t[c], e = t[c + 1], v < P && (P = v), e < N && (N = e), v > h && (h = v), e > n && (n = e);
        h = Math.max(h - P, n - N), h = h !== 0 ? 1 / h : 0;
      }
      return ws(s, l, i, P, N, h), l;
    }
  }, Vr = {
    area: function(t) {
      for (var e = t.length, i = 0, n = e - 1, o = 0; o < e; n = o++)
        i += t[n].x * t[o].y - t[o].x * t[n].y;
      return 0.5 * i;
    },
    isClockWise: function(t) {
      return 0 > Vr.area(t);
    },
    triangulateShape: function(t, e) {
      var i = [], n = [], o = [];
      Ra(t), Cl(i, t);
      var s = t.length;
      for (e.forEach(Ra), t = 0; t < e.length; t++)
        n.push(s), s += e[t].length, Cl(i, e[t]);
      for (e = Fl.triangulate(i, n), t = 0; t < e.length; t += 3)
        o.push(e.slice(t, t + 3));
      return o;
    }
  };
  Kr.prototype = Object.create(V.prototype), Kr.prototype.constructor = Kr, Kr.prototype.toJSON = function() {
    var t = V.prototype.toJSON.call(this);
    return Pl(this.parameters.shapes, this.parameters.options, t);
  }, Nr.prototype = Object.create(Ft.prototype), Nr.prototype.constructor = Nr, Nr.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return Pl(this.parameters.shapes, this.parameters.options, t);
  };
  var ga = {
    generateTopUV: function(t, e, i, n, o) {
      t = e[3 * n], n = e[3 * n + 1];
      var s = e[3 * o];
      return o = e[3 * o + 1], [new p(e[3 * i], e[3 * i + 1]), new p(t, n), new p(s, o)];
    },
    generateSideWallUV: function(t, e, i, n, o, s) {
      t = e[3 * i];
      var l = e[3 * i + 1];
      i = e[3 * i + 2];
      var h = e[3 * n], c = e[3 * n + 1];
      n = e[3 * n + 2];
      var f = e[3 * o], v = e[3 * o + 1];
      o = e[3 * o + 2];
      var y = e[3 * s], S = e[3 * s + 1];
      return e = e[3 * s + 2], 0.01 > Math.abs(l - c) ? [new p(t, 1 - i), new p(h, 1 - n), new p(f, 1 - o), new p(y, 1 - e)] : [new p(l, 1 - i), new p(c, 1 - n), new p(v, 1 - o), new p(S, 1 - e)];
    }
  };
  Ks.prototype = Object.create(V.prototype), Ks.prototype.constructor = Ks, No.prototype = Object.create(Nr.prototype), No.prototype.constructor = No, mo.prototype = Object.create(V.prototype), mo.prototype.constructor = mo, ur.prototype = Object.create(Ft.prototype), ur.prototype.constructor = ur, Qs.prototype = Object.create(V.prototype), Qs.prototype.constructor = Qs, ko.prototype = Object.create(Ft.prototype), ko.prototype.constructor = ko, Ts.prototype = Object.create(V.prototype), Ts.prototype.constructor = Ts, go.prototype = Object.create(Ft.prototype), go.prototype.constructor = go, Qr.prototype = Object.create(V.prototype), Qr.prototype.constructor = Qr, Qr.prototype.toJSON = function() {
    var t = V.prototype.toJSON.call(this);
    return Ll(this.parameters.shapes, t);
  }, vo.prototype = Object.create(Ft.prototype), vo.prototype.constructor = vo, vo.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return Ll(this.parameters.shapes, t);
  }, yo.prototype = Object.create(Ft.prototype), yo.prototype.constructor = yo, to.prototype = Object.create(V.prototype), to.prototype.constructor = to, eo.prototype = Object.create(Ft.prototype), eo.prototype.constructor = eo, Ms.prototype = Object.create(to.prototype), Ms.prototype.constructor = Ms, Ln.prototype = Object.create(eo.prototype), Ln.prototype.constructor = Ln, Uo.prototype = Object.create(V.prototype), Uo.prototype.constructor = Uo, kr.prototype = Object.create(Ft.prototype), kr.prototype.constructor = kr;
  var un = Object.freeze({
    WireframeGeometry: ds,
    ParametricGeometry: qs,
    ParametricBufferGeometry: ms,
    TetrahedronGeometry: Ys,
    TetrahedronBufferGeometry: gs,
    OctahedronGeometry: Zs,
    OctahedronBufferGeometry: Oo,
    IcosahedronGeometry: Js,
    IcosahedronBufferGeometry: vs,
    DodecahedronGeometry: ys,
    DodecahedronBufferGeometry: _s,
    PolyhedronGeometry: Wi,
    PolyhedronBufferGeometry: _i,
    TubeGeometry: ln,
    TubeBufferGeometry: po,
    TorusKnotGeometry: Mr,
    TorusKnotBufferGeometry: Do,
    TorusGeometry: zo,
    TorusBufferGeometry: Pn,
    TextGeometry: Ks,
    TextBufferGeometry: No,
    SphereGeometry: mo,
    SphereBufferGeometry: ur,
    RingGeometry: Qs,
    RingBufferGeometry: ko,
    PlaneGeometry: Fe,
    PlaneBufferGeometry: xe,
    LatheGeometry: Ts,
    LatheBufferGeometry: go,
    ShapeGeometry: Qr,
    ShapeBufferGeometry: vo,
    ExtrudeGeometry: Kr,
    ExtrudeBufferGeometry: Nr,
    EdgesGeometry: yo,
    ConeGeometry: Ms,
    ConeBufferGeometry: Ln,
    CylinderGeometry: to,
    CylinderBufferGeometry: eo,
    CircleGeometry: Uo,
    CircleBufferGeometry: kr,
    BoxGeometry: Dt,
    BoxBufferGeometry: kt
  });
  _o.prototype = Object.create(Zt.prototype), _o.prototype.constructor = _o, _o.prototype.isShadowMaterial = !0, _o.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this;
  }, Fo.prototype = Object.create(ti.prototype), Fo.prototype.constructor = Fo, Fo.prototype.isRawShaderMaterial = !0, Ur.prototype = Object.create(Zt.prototype), Ur.prototype.constructor = Ur, Ur.prototype.isMeshStandardMaterial = !0, Ur.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Go.prototype = Object.create(Ur.prototype), Go.prototype.constructor = Go, Go.prototype.isMeshPhysicalMaterial = !0, Go.prototype.copy = function(t) {
    return Ur.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this;
  }, Sr.prototype = Object.create(Zt.prototype), Sr.prototype.constructor = Sr, Sr.prototype.isMeshPhongMaterial = !0, Sr.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Ho.prototype = Object.create(Sr.prototype), Ho.prototype.constructor = Ho, Ho.prototype.isMeshToonMaterial = !0, Ho.prototype.copy = function(t) {
    return Sr.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this;
  }, Wo.prototype = Object.create(Zt.prototype), Wo.prototype.constructor = Wo, Wo.prototype.isMeshNormalMaterial = !0, Wo.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, cr.prototype = Object.create(Zt.prototype), cr.prototype.constructor = cr, cr.prototype.isMeshLambertMaterial = !0, cr.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, jo.prototype = Object.create(Zt.prototype), jo.prototype.constructor = jo, jo.prototype.isMeshMatcapMaterial = !0, jo.prototype.copy = function(t) {
    return Zt.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Vo.prototype = Object.create(Di.prototype), Vo.prototype.constructor = Vo, Vo.prototype.isLineDashedMaterial = !0, Vo.prototype.copy = function(t) {
    return Di.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
  };
  var Gl = Object.freeze({
    ShadowMaterial: _o,
    SpriteMaterial: Ui,
    RawShaderMaterial: Fo,
    ShaderMaterial: ti,
    PointsMaterial: Cn,
    MeshPhysicalMaterial: Go,
    MeshStandardMaterial: Ur,
    MeshPhongMaterial: Sr,
    MeshToonMaterial: Ho,
    MeshNormalMaterial: Wo,
    MeshLambertMaterial: cr,
    MeshDepthMaterial: oe,
    MeshDistanceMaterial: te,
    MeshBasicMaterial: Ge,
    MeshMatcapMaterial: jo,
    LineDashedMaterial: Vo,
    LineBasicMaterial: Di,
    Material: Zt
  }), zn = {
    arraySlice: function(t, e, i) {
      return zn.isTypedArray(t) ? new t.constructor(t.subarray(e, i !== void 0 ? i : t.length)) : t.slice(e, i);
    },
    convertArray: function(t, e, i) {
      return !t || !i && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
    },
    isTypedArray: function(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function(t) {
      for (var e = t.length, i = Array(e), n = 0; n !== e; ++n)
        i[n] = n;
      return i.sort(function(o, s) {
        return t[o] - t[s];
      }), i;
    },
    sortedArray: function(t, e, i) {
      for (var n = t.length, o = new t.constructor(n), s = 0, l = 0; l !== n; ++s)
        for (var h = i[s] * e, c = 0; c !== e; ++c)
          o[l++] = t[h + c];
      return o;
    },
    flattenJSON: function(t, e, i, n) {
      for (var o = 1, s = t[0]; s !== void 0 && s[n] === void 0; )
        s = t[o++];
      if (s !== void 0) {
        var l = s[n];
        if (l !== void 0)
          if (Array.isArray(l))
            do
              l = s[n], l !== void 0 && (e.push(s.time), i.push.apply(i, l)), s = t[o++];
            while (s !== void 0);
          else if (l.toArray !== void 0)
            do
              l = s[n], l !== void 0 && (e.push(s.time), l.toArray(i, i.length)), s = t[o++];
            while (s !== void 0);
          else
            do
              l = s[n], l !== void 0 && (e.push(s.time), i.push(l)), s = t[o++];
            while (s !== void 0);
      }
    }
  };
  Object.assign(kn.prototype, {
    evaluate: function(t) {
      var e = this.parameterPositions, i = this._cachedIndex, n = e[i], o = e[i - 1];
      t: {
        e: {
          i: {
            n:
              if (!(t < n)) {
                for (var s = i + 2; ; ) {
                  if (n === void 0) {
                    if (t < o)
                      break n;
                    return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, o);
                  }
                  if (i === s)
                    break;
                  if (o = n, n = e[++i], t < n)
                    break e;
                }
                n = e.length;
                break i;
              }
            if (t >= o)
              break t;
            for (s = e[1], t < s && (i = 2, o = s), s = i - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, n);
              if (i === s)
                break;
              if (n = o, o = e[--i - 1], t >= o)
                break e;
            }
            n = i, i = 0;
          }
          for (; i < n; )
            o = i + n >>> 1, t < e[o] ? n = o : i = o + 1;
          if (n = e[i], o = e[i - 1], o === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t, n);
          if (n === void 0)
            return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, o, t);
        }
        this._cachedIndex = i, this.intervalChanged_(i, o, n);
      }
      return this.interpolate_(i, o, t, n);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(t) {
      var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize;
      t *= n;
      for (var o = 0; o !== n; ++o)
        e[o] = i[t + o];
      return e;
    },
    interpolate_: function() {
      throw Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  }), Object.assign(kn.prototype, {
    beforeStart_: kn.prototype.copySampleValue_,
    afterEnd_: kn.prototype.copySampleValue_
  }), ta.prototype = Object.assign(Object.create(kn.prototype), {
    constructor: ta,
    DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
    intervalChanged_: function(t, e, i) {
      var n = this.parameterPositions, o = t - 2, s = t + 1, l = n[o], h = n[s];
      if (l === void 0)
        switch (this.getSettings_().endingStart) {
          case 2401:
            o = t, l = 2 * e - i;
            break;
          case 2402:
            o = n.length - 2, l = e + n[o] - n[o + 1];
            break;
          default:
            o = t, l = i;
        }
      if (h === void 0)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            s = t, h = 2 * i - e;
            break;
          case 2402:
            s = 1, h = i + n[1] - n[0];
            break;
          default:
            s = t - 1, h = e;
        }
      t = 0.5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - l), this._weightNext = t / (h - i), this._offsetPrev = o * n, this._offsetNext = s * n;
    },
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, s = this.sampleValues, l = this.valueSize;
      t *= l;
      var h = t - l, c = this._offsetPrev, f = this._offsetNext, v = this._weightPrev, y = this._weightNext, S = (i - e) / (n - e);
      for (i = S * S, n = i * S, e = -v * n + 2 * v * i - v * S, v = (1 + v) * n + (-1.5 - 2 * v) * i + (-0.5 + v) * S + 1, S = (-1 - y) * n + (1.5 + y) * i + 0.5 * S, y = y * n - y * i, i = 0; i !== l; ++i)
        o[i] = e * s[c + i] + v * s[h + i] + S * s[t + i] + y * s[f + i];
      return o;
    }
  }), fr.prototype = Object.assign(Object.create(kn.prototype), {
    constructor: fr,
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, s = this.sampleValues, l = this.valueSize;
      t *= l;
      var h = t - l;
      for (e = (i - e) / (n - e), i = 1 - e, n = 0; n !== l; ++n)
        o[n] = s[h + n] * i + s[t + n] * e;
      return o;
    }
  }), Xo.prototype = Object.assign(Object.create(kn.prototype), {
    constructor: Xo,
    interpolate_: function(t) {
      return this.copySampleValue_(t - 1);
    }
  }), Object.assign(Rn, {
    toJSON: function(t) {
      var e = t.constructor;
      if (e.toJSON !== void 0)
        e = e.toJSON(t);
      else {
        e = {
          name: t.name,
          times: zn.convertArray(t.times, Array),
          values: zn.convertArray(t.values, Array)
        };
        var i = t.getInterpolation();
        i !== t.DefaultInterpolation && (e.interpolation = i);
      }
      return e.type = t.ValueTypeName, e;
    }
  }), Object.assign(Rn.prototype, {
    constructor: Rn,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function(t) {
      return new Xo(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodLinear: function(t) {
      return new fr(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: function(t) {
      return new ta(this.times, this.values, this.getValueSize(), t);
    },
    setInterpolation: function(t) {
      switch (t) {
        case 2300:
          var e = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (e === void 0) {
        if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, this.createInterpolant === void 0)
          if (t !== this.DefaultInterpolation)
            this.setInterpolation(this.DefaultInterpolation);
          else
            throw Error(e);
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return this.createInterpolant = e, this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(t) {
      if (t !== 0)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] += t;
      return this;
    },
    scale: function(t) {
      if (t !== 1)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] *= t;
      return this;
    },
    trim: function(t, e) {
      for (var i = this.times, n = i.length, o = 0, s = n - 1; o !== n && i[o] < t; )
        ++o;
      for (; s !== -1 && i[s] > e; )
        --s;
      return ++s, (o !== 0 || s !== n) && (o >= s && (s = Math.max(s, 1), o = s - 1), t = this.getValueSize(), this.times = zn.arraySlice(i, o, s), this.values = zn.arraySlice(this.values, o * t, s * t)), this;
    },
    validate: function() {
      var t = !0, e = this.getValueSize();
      e - Math.floor(e) !== 0 && (console.error(
        "THREE.KeyframeTrack: Invalid value size in track.",
        this
      ), t = !1);
      var i = this.times;
      e = this.values;
      var n = i.length;
      n === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      for (var o = null, s = 0; s !== n; s++) {
        var l = i[s];
        if (typeof l == "number" && isNaN(l)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            s,
            l
          ), t = !1;
          break;
        }
        if (o !== null && o > l) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            s,
            l,
            o
          ), t = !1;
          break;
        }
        o = l;
      }
      if (e !== void 0 && zn.isTypedArray(e)) {
        for (s = 0, i = e.length; s !== i; ++s)
          if (n = e[s], isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              s,
              n
            ), t = !1;
            break;
          }
      }
      return t;
    },
    optimize: function() {
      for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === 2302, o = 1, s = t.length - 1, l = 1; l < s; ++l) {
        var h = !1, c = t[l];
        if (c !== t[l + 1] && (l !== 1 || c !== c[0]))
          if (n)
            h = !0;
          else {
            var f = l * i, v = f - i, y = f + i;
            for (c = 0; c !== i; ++c) {
              var S = e[f + c];
              if (S !== e[v + c] || S !== e[y + c]) {
                h = !0;
                break;
              }
            }
          }
        if (h) {
          if (l !== o)
            for (t[o] = t[l], h = l * i, f = o * i, c = 0; c !== i; ++c)
              e[f + c] = e[h + c];
          ++o;
        }
      }
      if (0 < s) {
        for (t[o] = t[s], h = s * i, f = o * i, c = 0; c !== i; ++c)
          e[f + c] = e[h + c];
        ++o;
      }
      return o !== t.length && (this.times = zn.arraySlice(t, 0, o), this.values = zn.arraySlice(e, 0, o * i)), this;
    }
  }), Ia.prototype = Object.assign(Object.create(Rn.prototype), {
    constructor: Ia,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), Oa.prototype = Object.assign(Object.create(Rn.prototype), {
    constructor: Oa,
    ValueTypeName: "color"
  }), Er.prototype = Object.assign(Object.create(Rn.prototype), {
    constructor: Er,
    ValueTypeName: "number"
  }), Vn.prototype = Object.assign(Object.create(kn.prototype), {
    constructor: Vn,
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, s = this.sampleValues, l = this.valueSize;
      for (t *= l, e = (i - e) / (n - e), i = t + l; t !== i; t += 4)
        G.slerpFlat(o, 0, s, t - l, s, t, e);
      return o;
    }
  }), Ss.prototype = Object.assign(Object.create(Rn.prototype), {
    constructor: Ss,
    ValueTypeName: "quaternion",
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodLinear: function(t) {
      return new Vn(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: void 0
  }), Da.prototype = Object.assign(Object.create(Rn.prototype), {
    constructor: Da,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), Es.prototype = Object.assign(Object.create(Rn.prototype), {
    constructor: Es,
    ValueTypeName: "vector"
  }), Object.assign(ir, {
    parse: function(t) {
      for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), o = 0, s = i.length; o !== s; ++o)
        e.push(hh(i[o]).scale(n));
      return new ir(t.name, t.duration, e);
    },
    toJSON: function(t) {
      var e = [], i = t.tracks;
      t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid };
      for (var n = 0, o = i.length; n !== o; ++n)
        e.push(Rn.toJSON(i[n]));
      return t;
    },
    CreateFromMorphTargetSequence: function(t, e, i, n) {
      for (var o = e.length, s = [], l = 0; l < o; l++) {
        var h = [], c = [];
        h.push((l + o - 1) % o, l, (l + 1) % o), c.push(0, 1, 0);
        var f = zn.getKeyframeOrder(h);
        h = zn.sortedArray(h, 1, f), c = zn.sortedArray(c, 1, f), n || h[0] !== 0 || (h.push(o), c.push(c[0])), s.push(
          new Er(".morphTargetInfluences[" + e[l].name + "]", h, c).scale(1 / i)
        );
      }
      return new ir(t, -1, s);
    },
    findByName: function(t, e) {
      var i = t;
      for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)
        if (i[t].name === e)
          return i[t];
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(t, e, i) {
      for (var n = {}, o = /^([\w-]*?)([\d]+)$/, s = 0, l = t.length; s < l; s++) {
        var h = t[s], c = h.name.match(o);
        if (c && 1 < c.length) {
          var f = c[1];
          (c = n[f]) || (n[f] = c = []), c.push(h);
        }
      }
      t = [];
      for (f in n)
        t.push(ir.CreateFromMorphTargetSequence(f, n[f], e, i));
      return t;
    },
    parseAnimation: function(t, e) {
      if (!t)
        return console.error(
          "THREE.AnimationClip: No animation in JSONLoader data."
        ), null;
      var i = function(j, et, _t, mt, bt) {
        if (_t.length !== 0) {
          var xt = [], Wt = [];
          zn.flattenJSON(_t, xt, Wt, mt), xt.length !== 0 && bt.push(new j(et, xt, Wt));
        }
      }, n = [], o = t.name || "default", s = t.length || -1, l = t.fps || 30;
      t = t.hierarchy || [];
      for (var h = 0; h < t.length; h++) {
        var c = t[h].keys;
        if (c && c.length !== 0)
          if (c[0].morphTargets) {
            s = {};
            for (var f = 0; f < c.length; f++)
              if (c[f].morphTargets)
                for (var v = 0; v < c[f].morphTargets.length; v++)
                  s[c[f].morphTargets[v]] = -1;
            for (var y in s) {
              var S = [], P = [];
              for (v = 0; v !== c[f].morphTargets.length; ++v) {
                var N = c[f];
                S.push(N.time), P.push(N.morphTarget === y ? 1 : 0);
              }
              n.push(new Er(".morphTargetInfluence[" + y + "]", S, P));
            }
            s = s.length * (l || 1);
          } else
            f = ".bones[" + e[h].name + "]", i(Es, f + ".position", c, "pos", n), i(Ss, f + ".quaternion", c, "rot", n), i(Es, f + ".scale", c, "scl", n);
      }
      return n.length === 0 ? null : new ir(o, s, n);
    }
  }), Object.assign(ir.prototype, {
    resetDuration: function() {
      for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
        var n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return this.duration = t, this;
    },
    trim: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    },
    validate: function() {
      for (var t = !0, e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    },
    optimize: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].optimize();
      return this;
    }
  });
  var Xr = {
    enabled: !1,
    files: {},
    add: function(t, e) {
      this.enabled !== !1 && (this.files[t] = e);
    },
    get: function(t) {
      if (this.enabled !== !1)
        return this.files[t];
    },
    remove: function(t) {
      delete this.files[t];
    },
    clear: function() {
      this.files = {};
    }
  }, Gn = new xo(), mr = {};
  Object.assign(At.prototype, {
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var o = this, s = Xr.get(t);
      if (s !== void 0)
        return o.manager.itemStart(t), setTimeout(function() {
          e && e(s), o.manager.itemEnd(t);
        }, 0), s;
      if (mr[t] !== void 0)
        mr[t].push({ onLoad: e, onProgress: i, onError: n });
      else {
        var l = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (l) {
          i = l[1];
          var h = !!l[2];
          l = l[3], l = decodeURIComponent(l), h && (l = atob(l));
          try {
            var c = (this.responseType || "").toLowerCase();
            switch (c) {
              case "arraybuffer":
              case "blob":
                var f = new Uint8Array(l.length);
                for (h = 0; h < l.length; h++)
                  f[h] = l.charCodeAt(h);
                var v = c === "blob" ? new Blob([f.buffer], { type: i }) : f.buffer;
                break;
              case "document":
                v = new DOMParser().parseFromString(l, i);
                break;
              case "json":
                v = JSON.parse(l);
                break;
              default:
                v = l;
            }
            setTimeout(function() {
              e && e(v), o.manager.itemEnd(t);
            }, 0);
          } catch (S) {
            setTimeout(function() {
              n && n(S), o.manager.itemError(t), o.manager.itemEnd(t);
            }, 0);
          }
        } else {
          mr[t] = [], mr[t].push({ onLoad: e, onProgress: i, onError: n });
          var y = new XMLHttpRequest();
          y.open("GET", t, !0), y.addEventListener(
            "load",
            function(S) {
              var P = this.response;
              Xr.add(t, P);
              var N = mr[t];
              if (delete mr[t], this.status === 200 || this.status === 0) {
                this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var j = 0, et = N.length; j < et; j++) {
                  var _t = N[j];
                  _t.onLoad && _t.onLoad(P);
                }
              } else {
                for (j = 0, et = N.length; j < et; j++)
                  _t = N[j], _t.onError && _t.onError(S);
                o.manager.itemError(t);
              }
              o.manager.itemEnd(t);
            },
            !1
          ), y.addEventListener(
            "progress",
            function(S) {
              for (var P = mr[t], N = 0, j = P.length; N < j; N++) {
                var et = P[N];
                et.onProgress && et.onProgress(S);
              }
            },
            !1
          ), y.addEventListener(
            "error",
            function(S) {
              var P = mr[t];
              delete mr[t];
              for (var N = 0, j = P.length; N < j; N++) {
                var et = P[N];
                et.onError && et.onError(S);
              }
              o.manager.itemError(t), o.manager.itemEnd(t);
            },
            !1
          ), y.addEventListener(
            "abort",
            function(S) {
              var P = mr[t];
              delete mr[t];
              for (var N = 0, j = P.length; N < j; N++) {
                var et = P[N];
                et.onError && et.onError(S);
              }
              o.manager.itemError(t), o.manager.itemEnd(t);
            },
            !1
          ), this.responseType !== void 0 && (y.responseType = this.responseType), this.withCredentials !== void 0 && (y.withCredentials = this.withCredentials), y.overrideMimeType && y.overrideMimeType(
            this.mimeType !== void 0 ? this.mimeType : "text/plain"
          );
          for (h in this.requestHeader)
            y.setRequestHeader(h, this.requestHeader[h]);
          y.send(null);
        }
        return o.manager.itemStart(t), y;
      }
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResponseType: function(t) {
      return this.responseType = t, this;
    },
    setWithCredentials: function(t) {
      return this.withCredentials = t, this;
    },
    setMimeType: function(t) {
      return this.mimeType = t, this;
    },
    setRequestHeader: function(t) {
      return this.requestHeader = t, this;
    }
  }), Object.assign(Qt.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new At(o.manager);
      s.setPath(o.path), s.load(
        t,
        function(l) {
          e(o.parse(JSON.parse(l)));
        },
        i,
        n
      );
    },
    parse: function(t, e) {
      for (var i = [], n = 0; n < t.length; n++) {
        var o = ir.parse(t[n]);
        i.push(o);
      }
      e(i);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Yt.prototype, {
    load: function(t, e, i, n) {
      function o(S) {
        c.load(
          t[S],
          function(P) {
            P = s._parser(P, !0), l[S] = {
              width: P.width,
              height: P.height,
              format: P.format,
              mipmaps: P.mipmaps
            }, f += 1, f === 6 && (P.mipmapCount === 1 && (h.minFilter = 1006), h.format = P.format, h.needsUpdate = !0, e && e(h));
          },
          i,
          n
        );
      }
      var s = this, l = [], h = new fo();
      h.image = l;
      var c = new At(this.manager);
      if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(t))
        for (var f = 0, v = 0, y = t.length; v < y; ++v)
          o(v);
      else
        c.load(
          t,
          function(S) {
            if (S = s._parser(S, !0), S.isCubemap)
              for (var P = S.mipmaps.length / S.mipmapCount, N = 0; N < P; N++) {
                l[N] = { mipmaps: [] };
                for (var j = 0; j < S.mipmapCount; j++)
                  l[N].mipmaps.push(S.mipmaps[N * S.mipmapCount + j]), l[N].format = S.format, l[N].width = S.width, l[N].height = S.height;
              }
            else
              h.image.width = S.width, h.image.height = S.height, h.mipmaps = S.mipmaps;
            S.mipmapCount === 1 && (h.minFilter = 1006), h.format = S.format, h.needsUpdate = !0, e && e(h);
          },
          i,
          n
        );
      return h;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ue.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new H(), l = new At(this.manager);
      return l.setResponseType("arraybuffer"), l.setPath(this.path), l.load(
        t,
        function(h) {
          (h = o._parser(h)) && (h.image !== void 0 ? s.image = h.image : h.data !== void 0 && (s.image.width = h.width, s.image.height = h.height, s.image.data = h.data), s.wrapS = h.wrapS !== void 0 ? h.wrapS : 1001, s.wrapT = h.wrapT !== void 0 ? h.wrapT : 1001, s.magFilter = h.magFilter !== void 0 ? h.magFilter : 1006, s.minFilter = h.minFilter !== void 0 ? h.minFilter : 1008, s.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1, h.format !== void 0 && (s.format = h.format), h.type !== void 0 && (s.type = h.type), h.mipmaps !== void 0 && (s.mipmaps = h.mipmaps), h.mipmapCount === 1 && (s.minFilter = 1006), s.needsUpdate = !0, e && e(s, h));
        },
        i,
        n
      ), s;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(si.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function o() {
        c.removeEventListener("load", o, !1), c.removeEventListener("error", s, !1), Xr.add(t, this), e && e(this), l.manager.itemEnd(t);
      }
      function s(f) {
        c.removeEventListener("load", o, !1), c.removeEventListener("error", s, !1), n && n(f), l.manager.itemError(t), l.manager.itemEnd(t);
      }
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var l = this, h = Xr.get(t);
      if (h !== void 0)
        return l.manager.itemStart(t), setTimeout(function() {
          e && e(h), l.manager.itemEnd(t);
        }, 0), h;
      var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      return c.addEventListener("load", o, !1), c.addEventListener("error", s, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (c.crossOrigin = this.crossOrigin), l.manager.itemStart(t), c.src = t, c;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(zi.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function o(c) {
        l.load(
          t[c],
          function(f) {
            s.images[c] = f, h++, h === 6 && (s.needsUpdate = !0, e && e(s));
          },
          void 0,
          n
        );
      }
      var s = new w(), l = new si(this.manager);
      l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
      var h = 0;
      for (i = 0; i < t.length; ++i)
        o(i);
      return s;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(on.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = new O(), s = new si(this.manager);
      return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(
        t,
        function(l) {
          o.image = l, l = 0 < t.search(/\.jpe?g$/i) || t.search(/^data:image\/jpeg/) === 0, o.format = l ? 1022 : 1023, o.needsUpdate = !0, e !== void 0 && e(o);
        },
        i,
        n
      ), o;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ee.prototype, {
    getPoint: function() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    },
    getPointAt: function(t, e) {
      return t = this.getUtoTmapping(t), this.getPoint(t, e);
    },
    getPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return e;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPointAt(i / t));
      return e;
    },
    getLength: function() {
      var t = this.getLengths();
      return t[t.length - 1];
    },
    getLengths: function(t) {
      if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      var e = [], i = this.getPoint(0), n, o = 0;
      for (e.push(0), n = 1; n <= t; n++) {
        var s = this.getPoint(n / t);
        o += s.distanceTo(i), e.push(o), i = s;
      }
      return this.cacheArcLengths = e;
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.getLengths();
    },
    getUtoTmapping: function(t, e) {
      var i = this.getLengths(), n = i.length;
      e = e || t * i[n - 1];
      for (var o = 0, s = n - 1, l; o <= s; )
        if (t = Math.floor(o + (s - o) / 2), l = i[t] - e, 0 > l)
          o = t + 1;
        else if (0 < l)
          s = t - 1;
        else {
          s = t;
          break;
        }
      return t = s, i[t] === e ? t / (n - 1) : (o = i[t], (t + (e - o) / (i[t + 1] - o)) / (n - 1));
    },
    getTangent: function(t) {
      var e = t - 1e-4;
      return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize();
    },
    getTangentAt: function(t) {
      return t = this.getUtoTmapping(t), this.getTangent(t);
    },
    computeFrenetFrames: function(t, e) {
      var i = new m(), n = [], o = [], s = [], l = new m(), h = new $(), c;
      for (c = 0; c <= t; c++) {
        var f = c / t;
        n[c] = this.getTangentAt(f), n[c].normalize();
      }
      o[0] = new m(), s[0] = new m(), c = Number.MAX_VALUE, f = Math.abs(n[0].x);
      var v = Math.abs(n[0].y), y = Math.abs(n[0].z);
      for (f <= c && (c = f, i.set(1, 0, 0)), v <= c && (c = v, i.set(0, 1, 0)), y <= c && i.set(0, 0, 1), l.crossVectors(n[0], i).normalize(), o[0].crossVectors(n[0], l), s[0].crossVectors(n[0], o[0]), c = 1; c <= t; c++)
        o[c] = o[c - 1].clone(), s[c] = s[c - 1].clone(), l.crossVectors(n[c - 1], n[c]), l.length() > Number.EPSILON && (l.normalize(), i = Math.acos(fi.clamp(n[c - 1].dot(n[c]), -1, 1)), o[c].applyMatrix4(h.makeRotationAxis(l, i))), s[c].crossVectors(n[c], o[c]);
      if (e === !0)
        for (i = Math.acos(fi.clamp(o[0].dot(o[t]), -1, 1)), i /= t, 0 < n[0].dot(l.crossVectors(o[0], o[t])) && (i = -i), c = 1; c <= t; c++)
          o[c].applyMatrix4(h.makeRotationAxis(n[c], i * c)), s[c].crossVectors(n[c], o[c]);
      return { tangents: n, normals: o, binormals: s };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    },
    toJSON: function() {
      var t = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" }
      };
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    },
    fromJSON: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  }), Un.prototype = Object.create(Ee.prototype), Un.prototype.constructor = Un, Un.prototype.isEllipseCurve = !0, Un.prototype.getPoint = function(t, e) {
    e = e || new p();
    for (var i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, o = Math.abs(n) < Number.EPSILON; 0 > n; )
      n += i;
    for (; n > i; )
      n -= i;
    n < Number.EPSILON && (n = o ? 0 : i), this.aClockwise !== !0 || o || (n = n === i ? -i : n - i), i = this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(i);
    var s = this.aY + this.yRadius * Math.sin(i);
    return this.aRotation !== 0 && (i = Math.cos(this.aRotation), n = Math.sin(this.aRotation), o = t - this.aX, s -= this.aY, t = o * i - s * n + this.aX, s = o * n + s * i + this.aY), e.set(t, s);
  }, Un.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, Un.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }, Un.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, bs.prototype = Object.create(Un.prototype), bs.prototype.constructor = bs, bs.prototype.isArcCurve = !0;
  var vn = new m(), va = new Xn(), Ha = new Xn(), gr = new Xn();
  Tn.prototype = Object.create(Ee.prototype), Tn.prototype.constructor = Tn, Tn.prototype.isCatmullRomCurve3 = !0, Tn.prototype.getPoint = function(t, e) {
    e = e || new m();
    var i = this.points, n = i.length;
    t *= n - (this.closed ? 0 : 1);
    var o = Math.floor(t);
    if (t -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : t === 0 && o === n - 1 && (o = n - 2, t = 1), this.closed || 0 < o)
      var s = i[(o - 1) % n];
    else
      vn.subVectors(i[0], i[1]).add(i[0]), s = vn;
    var l = i[o % n], h = i[(o + 1) % n];
    if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (vn.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = vn), this.curveType === "centripetal" || this.curveType === "chordal") {
      var c = this.curveType === "chordal" ? 0.5 : 0.25;
      n = Math.pow(s.distanceToSquared(l), c), o = Math.pow(l.distanceToSquared(h), c), c = Math.pow(h.distanceToSquared(i), c), 1e-4 > o && (o = 1), 1e-4 > n && (n = o), 1e-4 > c && (c = o), va.initNonuniformCatmullRom(s.x, l.x, h.x, i.x, n, o, c), Ha.initNonuniformCatmullRom(s.y, l.y, h.y, i.y, n, o, c), gr.initNonuniformCatmullRom(s.z, l.z, h.z, i.z, n, o, c);
    } else
      this.curveType === "catmullrom" && (va.initCatmullRom(s.x, l.x, h.x, i.x, this.tension), Ha.initCatmullRom(s.y, l.y, h.y, i.y, this.tension), gr.initCatmullRom(s.z, l.z, h.z, i.z, this.tension));
    return e.set(va.calc(t), Ha.calc(t), gr.calc(t)), e;
  }, Tn.prototype.copy = function(t) {
    Ee.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, Tn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }, Tn.prototype.fromJSON = function(t) {
    Ee.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new m().fromArray(n));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, qn.prototype = Object.create(Ee.prototype), qn.prototype.constructor = qn, qn.prototype.isCubicBezierCurve = !0, qn.prototype.getPoint = function(t, e) {
    e = e || new p();
    var i = this.v0, n = this.v1, o = this.v2, s = this.v3;
    return e.set(wo(t, i.x, n.x, o.x, s.x), wo(t, i.y, n.y, o.y, s.y)), e;
  }, qn.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, qn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, qn.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, wi.prototype = Object.create(Ee.prototype), wi.prototype.constructor = wi, wi.prototype.isCubicBezierCurve3 = !0, wi.prototype.getPoint = function(t, e) {
    e = e || new m();
    var i = this.v0, n = this.v1, o = this.v2, s = this.v3;
    return e.set(
      wo(t, i.x, n.x, o.x, s.x),
      wo(t, i.y, n.y, o.y, s.y),
      wo(t, i.z, n.z, o.z, s.z)
    ), e;
  }, wi.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, wi.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, wi.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, Yn.prototype = Object.create(Ee.prototype), Yn.prototype.constructor = Yn, Yn.prototype.isLineCurve = !0, Yn.prototype.getPoint = function(t, e) {
    return e = e || new p(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, Yn.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, Yn.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
  }, Yn.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Yn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Yn.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, pr.prototype = Object.create(Ee.prototype), pr.prototype.constructor = pr, pr.prototype.isLineCurve3 = !0, pr.prototype.getPoint = function(t, e) {
    return e = e || new m(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, pr.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, pr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, pr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, pr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Zn.prototype = Object.create(Ee.prototype), Zn.prototype.constructor = Zn, Zn.prototype.isQuadraticBezierCurve = !0, Zn.prototype.getPoint = function(t, e) {
    e = e || new p();
    var i = this.v0, n = this.v1, o = this.v2;
    return e.set(Fr(t, i.x, n.x, o.x), Fr(t, i.y, n.y, o.y)), e;
  }, Zn.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Zn.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Zn.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Gr.prototype = Object.create(Ee.prototype), Gr.prototype.constructor = Gr, Gr.prototype.isQuadraticBezierCurve3 = !0, Gr.prototype.getPoint = function(t, e) {
    e = e || new m();
    var i = this.v0, n = this.v1, o = this.v2;
    return e.set(Fr(t, i.x, n.x, o.x), Fr(t, i.y, n.y, o.y), Fr(t, i.z, n.z, o.z)), e;
  }, Gr.prototype.copy = function(t) {
    return Ee.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Gr.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Gr.prototype.fromJSON = function(t) {
    return Ee.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, br.prototype = Object.create(Ee.prototype), br.prototype.constructor = br, br.prototype.isSplineCurve = !0, br.prototype.getPoint = function(t, e) {
    e = e || new p();
    var i = this.points, n = (i.length - 1) * t;
    t = Math.floor(n), n -= t;
    var o = i[t === 0 ? t : t - 1], s = i[t], l = i[t > i.length - 2 ? i.length - 1 : t + 1];
    return i = i[t > i.length - 3 ? i.length - 1 : t + 2], e.set(Rl(n, o.x, s.x, l.x, i.x), Rl(n, o.y, s.y, l.y, i.y)), e;
  }, br.prototype.copy = function(t) {
    Ee.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this;
  }, br.prototype.toJSON = function() {
    var t = Ee.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t;
  }, br.prototype.fromJSON = function(t) {
    Ee.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new p().fromArray(n));
    }
    return this;
  };
  var Wa = Object.freeze({
    ArcCurve: bs,
    CatmullRomCurve3: Tn,
    CubicBezierCurve: qn,
    CubicBezierCurve3: wi,
    EllipseCurve: Un,
    LineCurve: Yn,
    LineCurve3: pr,
    QuadraticBezierCurve: Zn,
    QuadraticBezierCurve3: Gr,
    SplineCurve: br
  });
  io.prototype = Object.assign(Object.create(Ee.prototype), {
    constructor: io,
    add: function(t) {
      this.curves.push(t);
    },
    closePath: function() {
      var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Yn(e, t));
    },
    getPoint: function(t) {
      var e = t * this.getLength(), i = this.getCurveLengths();
      for (t = 0; t < i.length; ) {
        if (i[t] >= e)
          return e = i[t] - e, t = this.curves[t], i = t.getLength(), t.getPointAt(i === 0 ? 0 : 1 - e / i);
        t++;
      }
      return null;
    },
    getLength: function() {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
        e += this.curves[i].getLength(), t.push(e);
      return this.cacheLengths = t;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 40);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]), e;
    },
    getPoints: function(t) {
      t = t || 12;
      for (var e = [], i, n = 0, o = this.curves; n < o.length; n++) {
        var s = o[n];
        s = s.getPoints(
          s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
        );
        for (var l = 0; l < s.length; l++) {
          var h = s[l];
          i && i.equals(h) || (e.push(h), i = h);
        }
      }
      return this.autoClose && 1 < e.length && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
    },
    copy: function(t) {
      Ee.prototype.copy.call(this, t), this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++)
        this.curves.push(t.curves[e].clone());
      return this.autoClose = t.autoClose, this;
    },
    toJSON: function() {
      var t = Ee.prototype.toJSON.call(this);
      t.autoClose = this.autoClose, t.curves = [];
      for (var e = 0, i = this.curves.length; e < i; e++)
        t.curves.push(this.curves[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      Ee.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var n = t.curves[e];
        this.curves.push(new Wa[n.type]().fromJSON(n));
      }
      return this;
    }
  }), Jn.prototype = Object.assign(Object.create(io.prototype), {
    constructor: Jn,
    setFromPoints: function(t) {
      this.moveTo(t[0].x, t[0].y);
      for (var e = 1, i = t.length; e < i; e++)
        this.lineTo(t[e].x, t[e].y);
    },
    moveTo: function(t, e) {
      this.currentPoint.set(t, e);
    },
    lineTo: function(t, e) {
      var i = new Yn(this.currentPoint.clone(), new p(t, e));
      this.curves.push(i), this.currentPoint.set(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      t = new Zn(this.currentPoint.clone(), new p(t, e), new p(i, n)), this.curves.push(t), this.currentPoint.set(i, n);
    },
    bezierCurveTo: function(t, e, i, n, o, s) {
      t = new qn(
        this.currentPoint.clone(),
        new p(t, e),
        new p(i, n),
        new p(o, s)
      ), this.curves.push(t), this.currentPoint.set(o, s);
    },
    splineThru: function(t) {
      var e = [this.currentPoint.clone()].concat(t);
      e = new br(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
    },
    arc: function(t, e, i, n, o, s) {
      this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, o, s);
    },
    absarc: function(t, e, i, n, o, s) {
      this.absellipse(t, e, i, i, n, o, s);
    },
    ellipse: function(t, e, i, n, o, s, l, h) {
      this.absellipse(
        t + this.currentPoint.x,
        e + this.currentPoint.y,
        i,
        n,
        o,
        s,
        l,
        h
      );
    },
    absellipse: function(t, e, i, n, o, s, l, h) {
      t = new Un(t, e, i, n, o, s, l, h), 0 < this.curves.length && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t);
    },
    copy: function(t) {
      return io.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
    },
    toJSON: function() {
      var t = io.prototype.toJSON.call(this);
      return t.currentPoint = this.currentPoint.toArray(), t;
    },
    fromJSON: function(t) {
      return io.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
    }
  }), Fn.prototype = Object.assign(Object.create(Jn.prototype), {
    constructor: Fn,
    getPointsHoles: function(t) {
      for (var e = [], i = 0, n = this.holes.length; i < n; i++)
        e[i] = this.holes[i].getPoints(t);
      return e;
    },
    extractPoints: function(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    },
    copy: function(t) {
      Jn.prototype.copy.call(this, t), this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++)
        this.holes.push(t.holes[e].clone());
      return this;
    },
    toJSON: function() {
      var t = Jn.prototype.toJSON.call(this);
      t.uuid = this.uuid, t.holes = [];
      for (var e = 0, i = this.holes.length; e < i; e++)
        t.holes.push(this.holes[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      Jn.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++) {
        var n = t.holes[e];
        this.holes.push(new Jn().fromJSON(n));
      }
      return this;
    }
  }), Ji.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Ji,
    isLight: !0,
    copy: function(t) {
      return z.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
    },
    toJSON: function(t) {
      return t = z.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
  }), ea.prototype = Object.assign(Object.create(Ji.prototype), {
    constructor: ea,
    isHemisphereLight: !0,
    copy: function(t) {
      return Ji.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    }
  }), Object.assign(Hr.prototype, {
    copy: function(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var t = {};
      return this.bias !== 0 && (t.bias = this.bias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
  }), ia.prototype = Object.assign(Object.create(Hr.prototype), {
    constructor: ia,
    isSpotLightShadow: !0,
    update: function(t) {
      var e = this.camera, i = 2 * fi.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height;
      t = t.distance || e.far, (i !== e.fov || n !== e.aspect || t !== e.far) && (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix());
    }
  }), na.prototype = Object.assign(Object.create(Ji.prototype), {
    constructor: na,
    isSpotLight: !0,
    copy: function(t) {
      return Ji.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), qo.prototype = Object.assign(Object.create(Ji.prototype), {
    constructor: qo,
    isPointLight: !0,
    copy: function(t) {
      return Ji.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }), As.prototype = Object.assign(Object.create(Be.prototype), {
    constructor: As,
    isOrthographicCamera: !0,
    copy: function(t, e) {
      return Be.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
    },
    setViewOffset: function(t, e, i, n, o, s) {
      this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = o, this.view.height = s, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, o = i - t;
      if (i += t, t = n + e, e = n - e, this.view !== null && this.view.enabled) {
        i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight);
        var s = (this.right - this.left) / this.view.width;
        n = (this.top - this.bottom) / this.view.height, o += this.view.offsetX / i * s, i = o + this.view.width / i * s, t -= this.view.offsetY / e * n, e = t - this.view.height / e * n;
      }
      this.projectionMatrix.makeOrthographic(o, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = z.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }), To.prototype = Object.assign(Object.create(Hr.prototype), {
    constructor: To
  }), Wr.prototype = Object.assign(Object.create(Ji.prototype), {
    constructor: Wr,
    isDirectionalLight: !0,
    copy: function(t) {
      return Ji.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), Yo.prototype = Object.assign(Object.create(Ji.prototype), {
    constructor: Yo,
    isAmbientLight: !0
  }), za.prototype = Object.assign(Object.create(Ji.prototype), {
    constructor: za,
    isRectAreaLight: !0,
    copy: function(t) {
      return Ji.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
    },
    toJSON: function(t) {
      return t = Ji.prototype.toJSON.call(this, t), t.object.width = this.width, t.object.height = this.height, t;
    }
  }), Object.assign(Ba.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new At(o.manager);
      s.setPath(o.path), s.load(
        t,
        function(l) {
          e(o.parse(JSON.parse(l)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      function e(l) {
        return i[l] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", l), i[l];
      }
      var i = this.textures, n = new Gl[t.type]();
      if (t.uuid !== void 0 && (n.uuid = t.uuid), t.name !== void 0 && (n.name = t.name), t.color !== void 0 && n.color.setHex(t.color), t.roughness !== void 0 && (n.roughness = t.roughness), t.metalness !== void 0 && (n.metalness = t.metalness), t.emissive !== void 0 && n.emissive.setHex(t.emissive), t.specular !== void 0 && n.specular.setHex(t.specular), t.shininess !== void 0 && (n.shininess = t.shininess), t.clearCoat !== void 0 && (n.clearCoat = t.clearCoat), t.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = t.clearCoatRoughness), t.vertexColors !== void 0 && (n.vertexColors = t.vertexColors), t.fog !== void 0 && (n.fog = t.fog), t.flatShading !== void 0 && (n.flatShading = t.flatShading), t.blending !== void 0 && (n.blending = t.blending), t.combine !== void 0 && (n.combine = t.combine), t.side !== void 0 && (n.side = t.side), t.opacity !== void 0 && (n.opacity = t.opacity), t.transparent !== void 0 && (n.transparent = t.transparent), t.alphaTest !== void 0 && (n.alphaTest = t.alphaTest), t.depthTest !== void 0 && (n.depthTest = t.depthTest), t.depthWrite !== void 0 && (n.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (n.colorWrite = t.colorWrite), t.wireframe !== void 0 && (n.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (n.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (n.rotation = t.rotation), t.linewidth !== 1 && (n.linewidth = t.linewidth), t.dashSize !== void 0 && (n.dashSize = t.dashSize), t.gapSize !== void 0 && (n.gapSize = t.gapSize), t.scale !== void 0 && (n.scale = t.scale), t.polygonOffset !== void 0 && (n.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (n.skinning = t.skinning), t.morphTargets !== void 0 && (n.morphTargets = t.morphTargets), t.dithering !== void 0 && (n.dithering = t.dithering), t.visible !== void 0 && (n.visible = t.visible), t.userData !== void 0 && (n.userData = t.userData), t.uniforms !== void 0)
        for (var o in t.uniforms) {
          var s = t.uniforms[o];
          switch (n.uniforms[o] = {}, s.type) {
            case "t":
              n.uniforms[o].value = e(s.value);
              break;
            case "c":
              n.uniforms[o].value = new A().setHex(s.value);
              break;
            case "v2":
              n.uniforms[o].value = new p().fromArray(s.value);
              break;
            case "v3":
              n.uniforms[o].value = new m().fromArray(s.value);
              break;
            case "v4":
              n.uniforms[o].value = new E().fromArray(s.value);
              break;
            case "m4":
              n.uniforms[o].value = new $().fromArray(s.value);
              break;
            default:
              n.uniforms[o].value = s.value;
          }
        }
      return t.defines !== void 0 && (n.defines = t.defines), t.vertexShader !== void 0 && (n.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (n.fragmentShader = t.fragmentShader), t.shading !== void 0 && (n.flatShading = t.shading === 1), t.size !== void 0 && (n.size = t.size), t.sizeAttenuation !== void 0 && (n.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (n.map = e(t.map)), t.alphaMap !== void 0 && (n.alphaMap = e(t.alphaMap), n.transparent = !0), t.bumpMap !== void 0 && (n.bumpMap = e(t.bumpMap)), t.bumpScale !== void 0 && (n.bumpScale = t.bumpScale), t.normalMap !== void 0 && (n.normalMap = e(t.normalMap)), t.normalMapType !== void 0 && (n.normalMapType = t.normalMapType), t.normalScale !== void 0 && (o = t.normalScale, Array.isArray(o) === !1 && (o = [o, o]), n.normalScale = new p().fromArray(o)), t.displacementMap !== void 0 && (n.displacementMap = e(t.displacementMap)), t.displacementScale !== void 0 && (n.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (n.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (n.roughnessMap = e(t.roughnessMap)), t.metalnessMap !== void 0 && (n.metalnessMap = e(t.metalnessMap)), t.emissiveMap !== void 0 && (n.emissiveMap = e(t.emissiveMap)), t.emissiveIntensity !== void 0 && (n.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (n.specularMap = e(t.specularMap)), t.envMap !== void 0 && (n.envMap = e(t.envMap)), t.envMapIntensity !== void 0 && (n.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (n.reflectivity = t.reflectivity), t.lightMap !== void 0 && (n.lightMap = e(t.lightMap)), t.lightMapIntensity !== void 0 && (n.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (n.aoMap = e(t.aoMap)), t.aoMapIntensity !== void 0 && (n.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (n.gradientMap = e(t.gradientMap)), n;
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setTextures: function(t) {
      return this.textures = t, this;
    }
  });
  var ts = {
    decodeText: function(t) {
      if (typeof TextDecoder < "u")
        return new TextDecoder().decode(t);
      for (var e = "", i = 0, n = t.length; i < n; i++)
        e += String.fromCharCode(t[i]);
      return decodeURIComponent(escape(e));
    },
    extractUrlBase: function(t) {
      var e = t.lastIndexOf("/");
      return e === -1 ? "./" : t.substr(0, e + 1);
    }
  };
  Object.assign(nl.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new At(o.manager);
      s.setPath(o.path), s.load(
        t,
        function(l) {
          e(o.parse(JSON.parse(l)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      var e = new Ft(), i = t.data.index;
      i !== void 0 && (i = new Ao[i.type](i.array), e.setIndex(new ht(i, 1)));
      var n = t.data.attributes;
      for (s in n) {
        var o = n[s];
        i = new Ao[o.type](o.array), e.addAttribute(s, new ht(i, o.itemSize, o.normalized));
      }
      var s = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (s !== void 0)
        for (i = 0, n = s.length; i !== n; ++i)
          o = s[i], e.addGroup(o.start, o.count, o.materialIndex);
      return t = t.data.boundingSphere, t !== void 0 && (s = new m(), t.center !== void 0 && s.fromArray(t.center), e.boundingSphere = new B(s, t.radius)), e;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var Ao = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  no.Handlers = {
    handlers: [],
    add: function(t, e) {
      this.handlers.push(t, e);
    },
    get: function(t) {
      for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
        var o = e[i + 1];
        if (e[i].test(t))
          return o;
      }
      return null;
    }
  }, Object.assign(no.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {
    },
    onLoadProgress: function() {
    },
    onLoadComplete: function() {
    },
    initMaterials: function(t, e, i) {
      for (var n = [], o = 0; o < t.length; ++o)
        n[o] = this.createMaterial(t[o], e, i);
      return n;
    },
    createMaterial: function() {
      var t = {
        NoBlending: 0,
        NormalBlending: 1,
        AdditiveBlending: 2,
        SubtractiveBlending: 3,
        MultiplyBlending: 4,
        CustomBlending: 5
      }, e = new A(), i = new on(), n = new Ba();
      return function(o, s, l) {
        function h(S, P, N, j, et) {
          S = s + S;
          var _t = no.Handlers.get(S);
          return _t !== null ? S = _t.load(S) : (i.setCrossOrigin(l), S = i.load(S)), P !== void 0 && (S.repeat.fromArray(P), P[0] !== 1 && (S.wrapS = 1e3), P[1] !== 1 && (S.wrapT = 1e3)), N !== void 0 && S.offset.fromArray(N), j !== void 0 && (j[0] === "repeat" && (S.wrapS = 1e3), j[0] === "mirror" && (S.wrapS = 1002), j[1] === "repeat" && (S.wrapT = 1e3), j[1] === "mirror" && (S.wrapT = 1002)), et !== void 0 && (S.anisotropy = et), P = fi.generateUUID(), c[P] = S, P;
        }
        var c = {}, f = { uuid: fi.generateUUID(), type: "MeshLambertMaterial" }, v;
        for (v in o) {
          var y = o[v];
          switch (v) {
            case "DbgColor":
            case "DbgIndex":
            case "opticalDensity":
            case "illumination":
              break;
            case "DbgName":
              f.name = y;
              break;
            case "blending":
              f.blending = t[y];
              break;
            case "colorAmbient":
            case "mapAmbient":
              console.warn(
                "THREE.Loader.createMaterial:",
                v,
                "is no longer supported."
              );
              break;
            case "colorDiffuse":
              f.color = e.fromArray(y).getHex();
              break;
            case "colorSpecular":
              f.specular = e.fromArray(y).getHex();
              break;
            case "colorEmissive":
              f.emissive = e.fromArray(y).getHex();
              break;
            case "specularCoef":
              f.shininess = y;
              break;
            case "shading":
              y.toLowerCase() === "basic" && (f.type = "MeshBasicMaterial"), y.toLowerCase() === "phong" && (f.type = "MeshPhongMaterial"), y.toLowerCase() === "standard" && (f.type = "MeshStandardMaterial");
              break;
            case "mapDiffuse":
              f.map = h(
                y,
                o.mapDiffuseRepeat,
                o.mapDiffuseOffset,
                o.mapDiffuseWrap,
                o.mapDiffuseAnisotropy
              );
              break;
            case "mapDiffuseRepeat":
            case "mapDiffuseOffset":
            case "mapDiffuseWrap":
            case "mapDiffuseAnisotropy":
              break;
            case "mapEmissive":
              f.emissiveMap = h(
                y,
                o.mapEmissiveRepeat,
                o.mapEmissiveOffset,
                o.mapEmissiveWrap,
                o.mapEmissiveAnisotropy
              );
              break;
            case "mapEmissiveRepeat":
            case "mapEmissiveOffset":
            case "mapEmissiveWrap":
            case "mapEmissiveAnisotropy":
              break;
            case "mapLight":
              f.lightMap = h(
                y,
                o.mapLightRepeat,
                o.mapLightOffset,
                o.mapLightWrap,
                o.mapLightAnisotropy
              );
              break;
            case "mapLightRepeat":
            case "mapLightOffset":
            case "mapLightWrap":
            case "mapLightAnisotropy":
              break;
            case "mapAO":
              f.aoMap = h(
                y,
                o.mapAORepeat,
                o.mapAOOffset,
                o.mapAOWrap,
                o.mapAOAnisotropy
              );
              break;
            case "mapAORepeat":
            case "mapAOOffset":
            case "mapAOWrap":
            case "mapAOAnisotropy":
              break;
            case "mapBump":
              f.bumpMap = h(
                y,
                o.mapBumpRepeat,
                o.mapBumpOffset,
                o.mapBumpWrap,
                o.mapBumpAnisotropy
              );
              break;
            case "mapBumpScale":
              f.bumpScale = y;
              break;
            case "mapBumpRepeat":
            case "mapBumpOffset":
            case "mapBumpWrap":
            case "mapBumpAnisotropy":
              break;
            case "mapNormal":
              f.normalMap = h(
                y,
                o.mapNormalRepeat,
                o.mapNormalOffset,
                o.mapNormalWrap,
                o.mapNormalAnisotropy
              );
              break;
            case "mapNormalFactor":
              f.normalScale = y;
              break;
            case "mapNormalRepeat":
            case "mapNormalOffset":
            case "mapNormalWrap":
            case "mapNormalAnisotropy":
              break;
            case "mapSpecular":
              f.specularMap = h(
                y,
                o.mapSpecularRepeat,
                o.mapSpecularOffset,
                o.mapSpecularWrap,
                o.mapSpecularAnisotropy
              );
              break;
            case "mapSpecularRepeat":
            case "mapSpecularOffset":
            case "mapSpecularWrap":
            case "mapSpecularAnisotropy":
              break;
            case "mapMetalness":
              f.metalnessMap = h(
                y,
                o.mapMetalnessRepeat,
                o.mapMetalnessOffset,
                o.mapMetalnessWrap,
                o.mapMetalnessAnisotropy
              );
              break;
            case "mapMetalnessRepeat":
            case "mapMetalnessOffset":
            case "mapMetalnessWrap":
            case "mapMetalnessAnisotropy":
              break;
            case "mapRoughness":
              f.roughnessMap = h(
                y,
                o.mapRoughnessRepeat,
                o.mapRoughnessOffset,
                o.mapRoughnessWrap,
                o.mapRoughnessAnisotropy
              );
              break;
            case "mapRoughnessRepeat":
            case "mapRoughnessOffset":
            case "mapRoughnessWrap":
            case "mapRoughnessAnisotropy":
              break;
            case "mapAlpha":
              f.alphaMap = h(
                y,
                o.mapAlphaRepeat,
                o.mapAlphaOffset,
                o.mapAlphaWrap,
                o.mapAlphaAnisotropy
              );
              break;
            case "mapAlphaRepeat":
            case "mapAlphaOffset":
            case "mapAlphaWrap":
            case "mapAlphaAnisotropy":
              break;
            case "flipSided":
              f.side = 1;
              break;
            case "doubleSided":
              f.side = 2;
              break;
            case "transparency":
              console.warn(
                "THREE.Loader.createMaterial: transparency has been renamed to opacity"
              ), f.opacity = y;
              break;
            case "depthTest":
            case "depthWrite":
            case "colorWrite":
            case "opacity":
            case "reflectivity":
            case "transparent":
            case "visible":
            case "wireframe":
              f[v] = y;
              break;
            case "vertexColors":
              y === !0 && (f.vertexColors = 2), y === "face" && (f.vertexColors = 1);
              break;
            default:
              console.error("THREE.Loader.createMaterial: Unsupported", v, y);
          }
        }
        return f.type === "MeshBasicMaterial" && delete f.emissive, f.type !== "MeshPhongMaterial" && delete f.specular, 1 > f.opacity && (f.transparent = !0), n.setTextures(c), n.parse(f);
      };
    }()
  }), Object.assign(Zo.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = this, s = this.path === void 0 ? ts.extractUrlBase(t) : this.path, l = new At(this.manager);
      l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
        t,
        function(h) {
          h = JSON.parse(h);
          var c = h.metadata;
          if (c !== void 0 && (c = c.type, c !== void 0 && c.toLowerCase() === "object")) {
            console.error(
              "THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead."
            );
            return;
          }
          h = o.parse(h, s), e(h.geometry, h.materials);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function() {
      return function(t, e) {
        t.data !== void 0 && (t = t.data), t.scale = t.scale !== void 0 ? 1 / t.scale : 1;
        var i = new V(), n = t, o, s, l, h = n.faces, c = n.vertices, f = n.normals, v = n.colors, y = n.scale, S = 0;
        if (n.uvs !== void 0) {
          for (o = 0; o < n.uvs.length; o++)
            n.uvs[o].length && S++;
          for (o = 0; o < S; o++)
            i.faceVertexUvs[o] = [];
        }
        var P = 0;
        for (l = c.length; P < l; )
          o = new m(), o.x = c[P++] * y, o.y = c[P++] * y, o.z = c[P++] * y, i.vertices.push(o);
        for (P = 0, l = h.length; P < l; ) {
          c = h[P++];
          var N = c & 1, j = c & 2;
          o = c & 8;
          var et = c & 16, _t = c & 32;
          if (y = c & 64, c &= 128, N) {
            N = new M(), N.a = h[P], N.b = h[P + 1], N.c = h[P + 3];
            var mt = new M();
            if (mt.a = h[P + 1], mt.b = h[P + 2], mt.c = h[P + 3], P += 4, j && (j = h[P++], N.materialIndex = j, mt.materialIndex = j), j = i.faces.length, o)
              for (o = 0; o < S; o++) {
                var bt = n.uvs[o];
                for (i.faceVertexUvs[o][j] = [], i.faceVertexUvs[o][j + 1] = [], s = 0; 4 > s; s++) {
                  var xt = h[P++], Wt = bt[2 * xt];
                  xt = bt[2 * xt + 1], Wt = new p(Wt, xt), s !== 2 && i.faceVertexUvs[o][j].push(Wt), s !== 0 && i.faceVertexUvs[o][j + 1].push(Wt);
                }
              }
            if (et && (et = 3 * h[P++], N.normal.set(f[et++], f[et++], f[et]), mt.normal.copy(N.normal)), _t)
              for (o = 0; 4 > o; o++)
                et = 3 * h[P++], _t = new m(f[et++], f[et++], f[et]), o !== 2 && N.vertexNormals.push(_t), o !== 0 && mt.vertexNormals.push(_t);
            if (y && (y = h[P++], y = v[y], N.color.setHex(y), mt.color.setHex(y)), c)
              for (o = 0; 4 > o; o++)
                y = h[P++], y = v[y], o !== 2 && N.vertexColors.push(new A(y)), o !== 0 && mt.vertexColors.push(new A(y));
            i.faces.push(N), i.faces.push(mt);
          } else {
            if (N = new M(), N.a = h[P++], N.b = h[P++], N.c = h[P++], j && (j = h[P++], N.materialIndex = j), j = i.faces.length, o)
              for (o = 0; o < S; o++)
                for (bt = n.uvs[o], i.faceVertexUvs[o][j] = [], s = 0; 3 > s; s++)
                  xt = h[P++], Wt = bt[2 * xt], xt = bt[2 * xt + 1], Wt = new p(Wt, xt), i.faceVertexUvs[o][j].push(Wt);
            if (et && (et = 3 * h[P++], N.normal.set(f[et++], f[et++], f[et])), _t)
              for (o = 0; 3 > o; o++)
                et = 3 * h[P++], _t = new m(f[et++], f[et++], f[et]), N.vertexNormals.push(_t);
            if (y && (y = h[P++], N.color.setHex(v[y])), c)
              for (o = 0; 3 > o; o++)
                y = h[P++], N.vertexColors.push(new A(v[y]));
            i.faces.push(N);
          }
        }
        if (n = t, P = n.influencesPerVertex !== void 0 ? n.influencesPerVertex : 2, n.skinWeights)
          for (l = 0, h = n.skinWeights.length; l < h; l += P)
            i.skinWeights.push(
              new E(
                n.skinWeights[l],
                1 < P ? n.skinWeights[l + 1] : 0,
                2 < P ? n.skinWeights[l + 2] : 0,
                3 < P ? n.skinWeights[l + 3] : 0
              )
            );
        if (n.skinIndices)
          for (l = 0, h = n.skinIndices.length; l < h; l += P)
            i.skinIndices.push(
              new E(
                n.skinIndices[l],
                1 < P ? n.skinIndices[l + 1] : 0,
                2 < P ? n.skinIndices[l + 2] : 0,
                3 < P ? n.skinIndices[l + 3] : 0
              )
            );
        if (i.bones = n.bones, i.bones && 0 < i.bones.length && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && console.warn(
          "When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match."
        ), l = t, h = l.scale, l.morphTargets !== void 0)
          for (n = 0, P = l.morphTargets.length; n < P; n++)
            for (i.morphTargets[n] = {}, i.morphTargets[n].name = l.morphTargets[n].name, i.morphTargets[n].vertices = [], f = i.morphTargets[n].vertices, v = l.morphTargets[n].vertices, S = 0, c = v.length; S < c; S += 3)
              y = new m(), y.x = v[S] * h, y.y = v[S + 1] * h, y.z = v[S + 2] * h, f.push(y);
        if (l.morphColors !== void 0 && 0 < l.morphColors.length)
          for (console.warn(
            'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
          ), h = i.faces, l = l.morphColors[0].colors, n = 0, P = h.length; n < P; n++)
            h[n].color.fromArray(l, 3 * n);
        for (l = t, n = [], P = [], l.animation !== void 0 && P.push(l.animation), l.animations !== void 0 && (l.animations.length ? P = P.concat(l.animations) : P.push(l.animations)), l = 0; l < P.length; l++)
          (h = ir.parseAnimation(P[l], i.bones)) && n.push(h);
        return i.morphTargets && (P = ir.CreateClipsFromMorphTargetSequences(i.morphTargets, 10), n = n.concat(P)), 0 < n.length && (i.animations = n), i.computeFaceNormals(), i.computeBoundingSphere(), t.materials === void 0 || t.materials.length === 0 ? { geometry: i } : (t = no.prototype.initMaterials(
          t.materials,
          this.resourcePath || e,
          this.crossOrigin
        ), { geometry: i, materials: t });
      };
    }()
  }), Object.assign(ra.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = this, s = this.path === void 0 ? ts.extractUrlBase(t) : this.path;
      this.resourcePath = this.resourcePath || s, s = new At(o.manager), s.setPath(this.path), s.load(
        t,
        function(l) {
          var h = null;
          try {
            h = JSON.parse(l);
          } catch (c) {
            n !== void 0 && n(c), console.error(
              "THREE:ObjectLoader: Can't parse " + t + ".",
              c.message
            );
            return;
          }
          l = h.metadata, l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry" ? console.error(
            "THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead."
          ) : o.parse(h, e);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function(t, e) {
      var i = this.parseShape(t.shapes);
      i = this.parseGeometries(t.geometries, i);
      var n = this.parseImages(t.images, function() {
        e !== void 0 && e(o);
      });
      n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n);
      var o = this.parseObject(t.object, i, n);
      return t.animations && (o.animations = this.parseAnimations(t.animations)), t.images !== void 0 && t.images.length !== 0 || e === void 0 || e(o), o;
    },
    parseShape: function(t) {
      var e = {};
      if (t !== void 0)
        for (var i = 0, n = t.length; i < n; i++) {
          var o = new Fn().fromJSON(t[i]);
          e[o.uuid] = o;
        }
      return e;
    },
    parseGeometries: function(t, e) {
      var i = {};
      if (t !== void 0)
        for (var n = new Zo(), o = new nl(), s = 0, l = t.length; s < l; s++) {
          var h = t[s];
          switch (h.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              var c = new un[h.type](
                h.width,
                h.height,
                h.widthSegments,
                h.heightSegments
              );
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
              c = new un[h.type](
                h.width,
                h.height,
                h.depth,
                h.widthSegments,
                h.heightSegments,
                h.depthSegments
              );
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              c = new un[h.type](
                h.radius,
                h.segments,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              c = new un[h.type](
                h.radiusTop,
                h.radiusBottom,
                h.height,
                h.radialSegments,
                h.heightSegments,
                h.openEnded,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              c = new un[h.type](
                h.radius,
                h.height,
                h.radialSegments,
                h.heightSegments,
                h.openEnded,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              c = new un[h.type](
                h.radius,
                h.widthSegments,
                h.heightSegments,
                h.phiStart,
                h.phiLength,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              c = new un[h.type](h.radius, h.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              c = new un[h.type](
                h.innerRadius,
                h.outerRadius,
                h.thetaSegments,
                h.phiSegments,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              c = new un[h.type](
                h.radius,
                h.tube,
                h.radialSegments,
                h.tubularSegments,
                h.arc
              );
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              c = new un[h.type](
                h.radius,
                h.tube,
                h.tubularSegments,
                h.radialSegments,
                h.p,
                h.q
              );
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              c = new un[h.type](h.points, h.segments, h.phiStart, h.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              c = new un[h.type](h.vertices, h.indices, h.radius, h.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              c = [];
              for (var f = 0, v = h.shapes.length; f < v; f++) {
                var y = e[h.shapes[f]];
                c.push(y);
              }
              c = new un[h.type](c, h.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              for (c = [], f = 0, v = h.shapes.length; f < v; f++)
                y = e[h.shapes[f]], c.push(y);
              f = h.options.extrudePath, f !== void 0 && (h.options.extrudePath = new Wa[f.type]().fromJSON(f)), c = new un[h.type](c, h.options);
              break;
            case "BufferGeometry":
              c = o.parse(h);
              break;
            case "Geometry":
              c = n.parse(h, this.resourcePath).geometry;
              break;
            default:
              console.warn(
                'THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"'
              );
              continue;
          }
          c.uuid = h.uuid, h.name !== void 0 && (c.name = h.name), c.isBufferGeometry === !0 && h.userData !== void 0 && (c.userData = h.userData), i[h.uuid] = c;
        }
      return i;
    },
    parseMaterials: function(t, e) {
      var i = {}, n = {};
      if (t !== void 0) {
        var o = new Ba();
        o.setTextures(e), e = 0;
        for (var s = t.length; e < s; e++) {
          var l = t[e];
          if (l.type === "MultiMaterial") {
            for (var h = [], c = 0; c < l.materials.length; c++) {
              var f = l.materials[c];
              i[f.uuid] === void 0 && (i[f.uuid] = o.parse(f)), h.push(i[f.uuid]);
            }
            n[l.uuid] = h;
          } else
            n[l.uuid] = o.parse(l), i[l.uuid] = n[l.uuid];
        }
      }
      return n;
    },
    parseAnimations: function(t) {
      for (var e = [], i = 0; i < t.length; i++) {
        var n = t[i], o = ir.parse(n);
        n.uuid !== void 0 && (o.uuid = n.uuid), e.push(o);
      }
      return e;
    },
    parseImages: function(t, e) {
      function i(S) {
        return n.manager.itemStart(S), s.load(
          S,
          function() {
            n.manager.itemEnd(S);
          },
          void 0,
          function() {
            n.manager.itemError(S), n.manager.itemEnd(S);
          }
        );
      }
      var n = this, o = {};
      if (t !== void 0 && 0 < t.length) {
        e = new xo(e);
        var s = new si(e);
        s.setCrossOrigin(this.crossOrigin), e = 0;
        for (var l = t.length; e < l; e++) {
          var h = t[e], c = h.url;
          if (Array.isArray(c)) {
            o[h.uuid] = [];
            for (var f = 0, v = c.length; f < v; f++) {
              var y = c[f];
              y = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(y) ? y : n.resourcePath + y, o[h.uuid].push(i(y));
            }
          } else
            y = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : n.resourcePath + h.url, o[h.uuid] = i(y);
        }
      }
      return o;
    },
    parseTextures: function(t, e) {
      function i(c, f) {
        return typeof c == "number" ? c : (console.warn(
          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
          c
        ), f[c]);
      }
      var n = {};
      if (t !== void 0)
        for (var o = 0, s = t.length; o < s; o++) {
          var l = t[o];
          l.image === void 0 && console.warn(
            'THREE.ObjectLoader: No "image" specified for',
            l.uuid
          ), e[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
          var h = Array.isArray(e[l.image]) ? new w(e[l.image]) : new O(e[l.image]);
          h.needsUpdate = !0, h.uuid = l.uuid, l.name !== void 0 && (h.name = l.name), l.mapping !== void 0 && (h.mapping = i(l.mapping, Hl)), l.offset !== void 0 && h.offset.fromArray(l.offset), l.repeat !== void 0 && h.repeat.fromArray(l.repeat), l.center !== void 0 && h.center.fromArray(l.center), l.rotation !== void 0 && (h.rotation = l.rotation), l.wrap !== void 0 && (h.wrapS = i(l.wrap[0], Bn), h.wrapT = i(l.wrap[1], Bn)), l.format !== void 0 && (h.format = l.format), l.minFilter !== void 0 && (h.minFilter = i(l.minFilter, ja)), l.magFilter !== void 0 && (h.magFilter = i(l.magFilter, ja)), l.anisotropy !== void 0 && (h.anisotropy = l.anisotropy), l.flipY !== void 0 && (h.flipY = l.flipY), n[l.uuid] = h;
        }
      return n;
    },
    parseObject: function(t, e, i) {
      function n(f) {
        return e[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", f), e[f];
      }
      function o(f) {
        if (f !== void 0) {
          if (Array.isArray(f)) {
            for (var v = [], y = 0, S = f.length; y < S; y++) {
              var P = f[y];
              i[P] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", P), v.push(i[P]);
            }
            return v;
          }
          return i[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", f), i[f];
        }
      }
      switch (t.type) {
        case "Scene":
          var s = new On();
          t.background !== void 0 && Number.isInteger(t.background) && (s.background = new A(t.background)), t.fog !== void 0 && (t.fog.type === "Fog" ? s.fog = new mn(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (s.fog = new Le(t.fog.color, t.fog.density)));
          break;
        case "PerspectiveCamera":
          s = new ye(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (s.focus = t.focus), t.zoom !== void 0 && (s.zoom = t.zoom), t.filmGauge !== void 0 && (s.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (s.filmOffset = t.filmOffset), t.view !== void 0 && (s.view = Object.assign({}, t.view));
          break;
        case "OrthographicCamera":
          s = new As(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (s.zoom = t.zoom), t.view !== void 0 && (s.view = Object.assign({}, t.view));
          break;
        case "AmbientLight":
          s = new Yo(t.color, t.intensity);
          break;
        case "DirectionalLight":
          s = new Wr(t.color, t.intensity);
          break;
        case "PointLight":
          s = new qo(t.color, t.intensity, t.distance, t.decay);
          break;
        case "RectAreaLight":
          s = new za(t.color, t.intensity, t.width, t.height);
          break;
        case "SpotLight":
          s = new na(
            t.color,
            t.intensity,
            t.distance,
            t.angle,
            t.penumbra,
            t.decay
          );
          break;
        case "HemisphereLight":
          s = new ea(t.color, t.groundColor, t.intensity);
          break;
        case "SkinnedMesh":
          console.warn(
            "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
          );
        case "Mesh":
          s = n(t.geometry);
          var l = o(t.material);
          s = s.bones && 0 < s.bones.length ? new ki(s, l) : new pi(s, l);
          break;
        case "LOD":
          s = new Ki();
          break;
        case "Line":
          s = new Hi(n(t.geometry), o(t.material), t.mode);
          break;
        case "LineLoop":
          s = new zr(n(t.geometry), o(t.material));
          break;
        case "LineSegments":
          s = new mi(n(t.geometry), o(t.material));
          break;
        case "PointCloud":
        case "Points":
          s = new ps(n(t.geometry), o(t.material));
          break;
        case "Sprite":
          s = new $i(o(t.material));
          break;
        case "Group":
          s = new ui();
          break;
        default:
          s = new z();
      }
      if (s.uuid = t.uuid, t.name !== void 0 && (s.name = t.name), t.matrix !== void 0 ? (s.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (t.position !== void 0 && s.position.fromArray(t.position), t.rotation !== void 0 && s.rotation.fromArray(t.rotation), t.quaternion !== void 0 && s.quaternion.fromArray(t.quaternion), t.scale !== void 0 && s.scale.fromArray(t.scale)), t.castShadow !== void 0 && (s.castShadow = t.castShadow), t.receiveShadow !== void 0 && (s.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (s.shadow.bias = t.shadow.bias), t.shadow.radius !== void 0 && (s.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (s.visible = t.visible), t.frustumCulled !== void 0 && (s.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (s.renderOrder = t.renderOrder), t.userData !== void 0 && (s.userData = t.userData), t.layers !== void 0 && (s.layers.mask = t.layers), t.children !== void 0) {
        l = t.children;
        for (var h = 0; h < l.length; h++)
          s.add(this.parseObject(l[h], e, i));
      }
      if (t.type === "LOD")
        for (t = t.levels, l = 0; l < t.length; l++) {
          h = t[l];
          var c = s.getObjectByProperty("uuid", h.object);
          c !== void 0 && s.addLevel(c, h.distance);
        }
      return s;
    }
  });
  var Hl = {
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307
  }, Bn = {
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002
  }, ja = {
    NearestFilter: 1003,
    NearestMipMapNearestFilter: 1004,
    NearestMipMapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipMapNearestFilter: 1007,
    LinearMipMapLinearFilter: 1008
  };
  rl.prototype = {
    constructor: rl,
    setOptions: function(t) {
      return this.options = t, this;
    },
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var o = this, s = Xr.get(t);
      if (s !== void 0)
        return o.manager.itemStart(t), setTimeout(function() {
          e && e(s), o.manager.itemEnd(t);
        }, 0), s;
      fetch(t).then(function(l) {
        return l.blob();
      }).then(function(l) {
        return createImageBitmap(l, o.options);
      }).then(function(l) {
        Xr.add(t, l), e && e(l), o.manager.itemEnd(t);
      }).catch(function(l) {
        n && n(l), o.manager.itemError(t), o.manager.itemEnd(t);
      });
    },
    setCrossOrigin: function() {
      return this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }, Object.assign(Na.prototype, {
    moveTo: function(t, e) {
      this.currentPath = new Jn(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e);
    },
    lineTo: function(t, e) {
      this.currentPath.lineTo(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      this.currentPath.quadraticCurveTo(t, e, i, n);
    },
    bezierCurveTo: function(t, e, i, n, o, s) {
      this.currentPath.bezierCurveTo(t, e, i, n, o, s);
    },
    splineThru: function(t) {
      this.currentPath.splineThru(t);
    },
    toShapes: function(t, e) {
      function i(et) {
        for (var _t = [], mt = 0, bt = et.length; mt < bt; mt++) {
          var xt = et[mt], Wt = new Fn();
          Wt.curves = xt.curves, _t.push(Wt);
        }
        return _t;
      }
      function n(et, _t) {
        for (var mt = _t.length, bt = !1, xt = mt - 1, Wt = 0; Wt < mt; xt = Wt++) {
          var W = _t[xt], it = _t[Wt], It = it.x - W.x, ee = it.y - W.y;
          if (Math.abs(ee) > Number.EPSILON) {
            if (0 > ee && (W = _t[Wt], It = -It, it = _t[xt], ee = -ee), !(et.y < W.y || et.y > it.y))
              if (et.y === W.y) {
                if (et.x === W.x)
                  return !0;
              } else {
                if (xt = ee * (et.x - W.x) - It * (et.y - W.y), xt === 0)
                  return !0;
                0 > xt || (bt = !bt);
              }
          } else if (et.y === W.y && (it.x <= et.x && et.x <= W.x || W.x <= et.x && et.x <= it.x))
            return !0;
        }
        return bt;
      }
      var o = Vr.isClockWise, s = this.subPaths;
      if (s.length === 0)
        return [];
      if (e === !0)
        return i(s);
      if (e = [], s.length === 1) {
        var l = s[0], h = new Fn();
        return h.curves = l.curves, e.push(h), e;
      }
      var c = !o(s[0].getPoints());
      c = t ? !c : c, h = [];
      var f = [], v = [], y = 0;
      f[y] = void 0, v[y] = [];
      for (var S = 0, P = s.length; S < P; S++) {
        l = s[S];
        var N = l.getPoints(), j = o(N);
        (j = t ? !j : j) ? (!c && f[y] && y++, f[y] = { s: new Fn(), p: N }, f[y].s.curves = l.curves, c && y++, v[y] = []) : v[y].push({ h: l, p: N[0] });
      }
      if (!f[0])
        return i(s);
      if (1 < f.length) {
        for (S = !1, t = [], o = 0, s = f.length; o < s; o++)
          h[o] = [];
        for (o = 0, s = f.length; o < s; o++)
          for (l = v[o], j = 0; j < l.length; j++) {
            for (c = l[j], y = !0, N = 0; N < f.length; N++)
              n(c.p, f[N].p) && (o !== N && t.push({ froms: o, tos: N, hole: j }), y ? (y = !1, h[N].push(c)) : S = !0);
            y && h[o].push(c);
          }
        0 < t.length && (S || (v = h));
      }
      for (S = 0, o = f.length; S < o; S++)
        for (h = f[S].s, e.push(h), t = v[S], s = 0, l = t.length; s < l; s++)
          h.holes.push(t[s].h);
      return e;
    }
  }), Object.assign(ol.prototype, {
    isFont: !0,
    generateShapes: function(t, e) {
      e === void 0 && (e = 100);
      var i = [], n = e;
      e = this.data;
      var o = Array.from ? Array.from(t) : String(t).split("");
      n /= e.resolution;
      var s = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
      t = [];
      for (var l = 0, h = 0, c = 0; c < o.length; c++) {
        var f = o[c];
        if (f === `
`)
          l = 0, h -= s;
        else {
          var v = n, y = l, S = h;
          if (f = e.glyphs[f] || e.glyphs["?"]) {
            var P = new Na();
            if (f.o)
              for (var N = f._cachedOutline || (f._cachedOutline = f.o.split(" ")), j = 0, et = N.length; j < et; )
                switch (N[j++]) {
                  case "m":
                    var _t = N[j++] * v + y, mt = N[j++] * v + S;
                    P.moveTo(_t, mt);
                    break;
                  case "l":
                    _t = N[j++] * v + y, mt = N[j++] * v + S, P.lineTo(_t, mt);
                    break;
                  case "q":
                    var bt = N[j++] * v + y, xt = N[j++] * v + S, Wt = N[j++] * v + y, W = N[j++] * v + S;
                    P.quadraticCurveTo(Wt, W, bt, xt);
                    break;
                  case "b":
                    bt = N[j++] * v + y, xt = N[j++] * v + S, Wt = N[j++] * v + y, W = N[j++] * v + S, _t = N[j++] * v + y, mt = N[j++] * v + S, P.bezierCurveTo(Wt, W, _t, mt, bt, xt);
                }
            v = { offsetX: f.ha * v, path: P };
          } else
            v = void 0;
          l += v.offsetX, t.push(v.path);
        }
      }
      for (e = 0, o = t.length; e < o; e++)
        Array.prototype.push.apply(i, t[e].toShapes());
      return i;
    }
  }), Object.assign(Il.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new At(this.manager);
      s.setPath(this.path), s.load(
        t,
        function(l) {
          try {
            var h = JSON.parse(l);
          } catch {
            console.warn(
              "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
            ), h = JSON.parse(l.substring(65, l.length - 2));
          }
          l = o.parse(h), e && e(l);
        },
        i,
        n
      );
    },
    parse: function(t) {
      return new ol(t);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var Va, gl = {
    getContext: function() {
      return Va === void 0 && (Va = new (window.AudioContext || window.webkitAudioContext)()), Va;
    },
    setContext: function(t) {
      Va = t;
    }
  };
  Object.assign(hn.prototype, {
    load: function(t, e, i, n) {
      var o = new At(this.manager);
      o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(
        t,
        function(s) {
          s = s.slice(0), gl.getContext().decodeAudioData(s, function(l) {
            e(l);
          });
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(In.prototype, {
    update: function() {
      var t, e, i, n, o, s, l, h, c = new $(), f = new $();
      return function(v) {
        if (t !== this || e !== v.focus || i !== v.fov || n !== v.aspect * this.aspect || o !== v.near || s !== v.far || l !== v.zoom || h !== this.eyeSep) {
          t = this, e = v.focus, i = v.fov, n = v.aspect * this.aspect, o = v.near, s = v.far, l = v.zoom;
          var y = v.projectionMatrix.clone();
          h = this.eyeSep / 2;
          var S = h * o / e, P = o * Math.tan(fi.DEG2RAD * i * 0.5) / l;
          f.elements[12] = -h, c.elements[12] = h;
          var N = -P * n + S, j = P * n + S;
          y.elements[0] = 2 * o / (j - N), y.elements[8] = (j + N) / (j - N), this.cameraL.projectionMatrix.copy(y), N = -P * n - S, j = P * n - S, y.elements[0] = 2 * o / (j - N), y.elements[8] = (j + N) / (j - N), this.cameraR.projectionMatrix.copy(y);
        }
        this.cameraL.matrixWorld.copy(v.matrixWorld).multiply(f), this.cameraR.matrixWorld.copy(v.matrixWorld).multiply(c);
      };
    }()
  }), oa.prototype = Object.create(z.prototype), oa.prototype.constructor = oa, Object.assign(sl.prototype, {
    start: function() {
      this.oldTime = this.startTime = (typeof performance > "u" ? Date : performance).now(), this.elapsedTime = 0, this.running = !0;
    },
    stop: function() {
      this.getElapsedTime(), this.autoStart = this.running = !1;
    },
    getElapsedTime: function() {
      return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
      var t = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        var e = (typeof performance > "u" ? Date : performance).now();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }
      return t;
    }
  }), ka.prototype = Object.assign(Object.create(z.prototype), {
    constructor: ka,
    getInput: function() {
      return this.gain;
    },
    removeFilter: function() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    },
    getFilter: function() {
      return this.filter;
    },
    setFilter: function(t) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    },
    getMasterVolume: function() {
      return this.gain.gain.value;
    },
    setMasterVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    },
    updateMatrixWorld: function() {
      var t = new m(), e = new G(), i = new m(), n = new m(), o = new sl();
      return function(s) {
        z.prototype.updateMatrixWorld.call(this, s), s = this.context.listener;
        var l = this.up;
        if (this.timeDelta = o.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), s.positionX) {
          var h = this.context.currentTime + this.timeDelta;
          s.positionX.linearRampToValueAtTime(t.x, h), s.positionY.linearRampToValueAtTime(t.y, h), s.positionZ.linearRampToValueAtTime(t.z, h), s.forwardX.linearRampToValueAtTime(n.x, h), s.forwardY.linearRampToValueAtTime(n.y, h), s.forwardZ.linearRampToValueAtTime(n.z, h), s.upX.linearRampToValueAtTime(l.x, h), s.upY.linearRampToValueAtTime(l.y, h), s.upZ.linearRampToValueAtTime(l.z, h);
        } else
          s.setPosition(t.x, t.y, t.z), s.setOrientation(n.x, n.y, n.z, l.x, l.y, l.z);
      };
    }()
  }), Cs.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Cs,
    getOutput: function() {
      return this.gain;
    },
    setNodeSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    },
    setMediaElementSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    },
    setBuffer: function(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    },
    play: function() {
      if (this.isPlaying === !0)
        console.warn("THREE.Audio: Audio is already playing.");
      else if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else {
        var t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect();
      }
    },
    pause: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.isPlaying === !0 && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
    },
    stop: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
    },
    connect: function() {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this;
    },
    disconnect: function() {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this;
    },
    getFilters: function() {
      return this.filters;
    },
    setFilters: function(t) {
      return t || (t = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this;
    },
    getFilter: function() {
      return this.getFilters()[0];
    },
    setFilter: function(t) {
      return this.setFilters(t ? [t] : []);
    },
    setPlaybackRate: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(
          this.playbackRate,
          this.context.currentTime
        ), this;
    },
    getPlaybackRate: function() {
      return this.playbackRate;
    },
    onEnded: function() {
      this.isPlaying = !1;
    },
    getLoop: function() {
      return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    },
    setLoop: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    },
    getVolume: function() {
      return this.gain.gain.value;
    },
    setVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    }
  }), sa.prototype = Object.assign(Object.create(Cs.prototype), {
    constructor: sa,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(t) {
      return this.panner.refDistance = t, this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(t) {
      return this.panner.rolloffFactor = t, this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(t) {
      return this.panner.distanceModel = t, this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(t) {
      return this.panner.maxDistance = t, this;
    },
    setDirectionalCone: function(t, e, i) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this;
    },
    updateMatrixWorld: function() {
      var t = new m(), e = new G(), i = new m(), n = new m();
      return function(o) {
        if (z.prototype.updateMatrixWorld.call(this, o), o = this.panner, this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), o.positionX) {
          var s = this.context.currentTime + this.listener.timeDelta;
          o.positionX.linearRampToValueAtTime(t.x, s), o.positionY.linearRampToValueAtTime(t.y, s), o.positionZ.linearRampToValueAtTime(t.z, s), o.orientationX.linearRampToValueAtTime(n.x, s), o.orientationY.linearRampToValueAtTime(n.y, s), o.orientationZ.linearRampToValueAtTime(n.z, s);
        } else
          o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z);
      };
    }()
  }), Object.assign(Jo.prototype, {
    getFrequencyData: function() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    },
    getAverageFrequency: function() {
      for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)
        t += e[i];
      return t / e.length;
    }
  }), Object.assign(aa.prototype, {
    accumulate: function(t, e) {
      var i = this.buffer, n = this.valueSize;
      t = t * n + n;
      var o = this.cumulativeWeight;
      if (o === 0) {
        for (o = 0; o !== n; ++o)
          i[t + o] = i[o];
        o = e;
      } else
        o += e, this._mixBufferRegion(i, t, 0, e / o, n);
      this.cumulativeWeight = o;
    },
    apply: function(t) {
      var e = this.valueSize, i = this.buffer;
      t = t * e + e;
      var n = this.cumulativeWeight, o = this.binding;
      this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e;
      for (var s = e + e; n !== s; ++n)
        if (i[n] !== i[n + e]) {
          o.setValue(i, t);
          break;
        }
    },
    saveOriginalState: function() {
      var t = this.buffer, e = this.valueSize, i = 3 * e;
      this.binding.getValue(t, i);
      for (var n = e; n !== i; ++n)
        t[n] = t[i + n % e];
      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
      this.binding.setValue(this.buffer, 3 * this.valueSize);
    },
    _select: function(t, e, i, n, o) {
      if (0.5 <= n)
        for (n = 0; n !== o; ++n)
          t[e + n] = t[i + n];
    },
    _slerp: function(t, e, i, n) {
      G.slerpFlat(t, e, t, e, t, i, n);
    },
    _lerp: function(t, e, i, n, o) {
      for (var s = 1 - n, l = 0; l !== o; ++l) {
        var h = e + l;
        t[h] = t[h] * s + t[i + l] * n;
      }
    }
  }), Object.assign($o.prototype, {
    getValue: function(t, e) {
      this.bind();
      var i = this._bindings[this._targetGroup.nCachedObjects_];
      i !== void 0 && i.getValue(t, e);
    },
    setValue: function(t, e) {
      for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, o = i.length; n !== o; ++n)
        i[n].setValue(t, e);
    },
    bind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].bind();
    },
    unbind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].unbind();
    }
  }), Object.assign(gn, {
    Composite: $o,
    create: function(t, e, i) {
      return t && t.isAnimationObjectGroup ? new gn.Composite(t, e, i) : new gn(t, e, i);
    },
    sanitizeNodeName: function() {
      var t = /[\[\]\.:\/]/g;
      return function(e) {
        return e.replace(/\s/g, "_").replace(t, "");
      };
    }(),
    parseTrackName: function() {
      var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
      t = /(WCOD+)?/.source.replace("WCOD", t);
      var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
        "WC",
        "[^\\[\\]\\.:\\/]"
      ), n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), o = new RegExp("^" + e + t + i + n + "$"), s = ["material", "materials", "bones"];
      return function(l) {
        var h = o.exec(l);
        if (!h)
          throw Error("PropertyBinding: Cannot parse trackName: " + l);
        h = {
          nodeName: h[2],
          objectName: h[3],
          objectIndex: h[4],
          propertyName: h[5],
          propertyIndex: h[6]
        };
        var c = h.nodeName && h.nodeName.lastIndexOf(".");
        if (c !== void 0 && c !== -1) {
          var f = h.nodeName.substring(c + 1);
          s.indexOf(f) !== -1 && (h.nodeName = h.nodeName.substring(0, c), h.objectName = f);
        }
        if (h.propertyName === null || h.propertyName.length === 0)
          throw Error(
            "PropertyBinding: can not parse propertyName from trackName: " + l
          );
        return h;
      };
    }(),
    findNode: function(t, e) {
      if (!e || e === "" || e === "root" || e === "." || e === -1 || e === t.name || e === t.uuid)
        return t;
      if (t.skeleton) {
        var i = t.skeleton.getBoneByName(e);
        if (i !== void 0)
          return i;
      }
      if (t.children) {
        var n = function(o) {
          for (var s = 0; s < o.length; s++) {
            var l = o[s];
            if (l.name === e || l.uuid === e || (l = n(l.children)))
              return l;
          }
          return null;
        };
        if (t = n(t.children))
          return t;
      }
      return null;
    }
  }), Object.assign(gn.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
    GetterByBindingType: [
      function(t, e) {
        t[e] = this.node[this.propertyName];
      },
      function(t, e) {
        for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
          t[e++] = i[n];
      },
      function(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      },
      function(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function(t, e) {
          this.targetObject[this.propertyName] = t[e];
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
          this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty.fromArray(t, e);
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ]
    ],
    getValue: function(t, e) {
      this.bind(), this.getValue(t, e);
    },
    setValue: function(t, e) {
      this.bind(), this.setValue(t, e);
    },
    bind: function() {
      var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, o = e.propertyIndex;
      if (t || (this.node = t = gn.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
        if (i) {
          var s = e.objectIndex;
          switch (i) {
            case "materials":
              if (!t.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!t.material.materials) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
                return;
              }
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
                return;
              }
              for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                if (t[i].name === s) {
                  s = i;
                  break;
                }
              break;
            default:
              if (t[i] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
                return;
              }
              t = t[i];
          }
          if (s !== void 0) {
            if (t[s] === void 0) {
              console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                t
              );
              return;
            }
            t = t[s];
          }
        }
        if (s = t[n], s === void 0)
          console.error(
            "THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.",
            t
          );
        else {
          if (e = this.Versioning.None, this.targetObject = t, t.needsUpdate !== void 0 ? e = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, o !== void 0) {
            if (n === "morphTargetInfluences") {
              if (!t.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (t.geometry.isBufferGeometry) {
                if (!t.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                  if (t.geometry.morphAttributes.position[i].name === o) {
                    o = i;
                    break;
                  }
              } else {
                if (!t.geometry.morphTargets) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                  if (t.geometry.morphTargets[i].name === o) {
                    o = i;
                    break;
                  }
              }
            }
            i = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = o;
          } else
            s.fromArray !== void 0 && s.toArray !== void 0 ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (i = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e];
        }
      } else
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."
        );
    },
    unbind: function() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }), Object.assign(gn.prototype, {
    _getValue_unbound: gn.prototype.getValue,
    _setValue_unbound: gn.prototype.setValue
  }), Object.assign(Ps.prototype, {
    isAnimationObjectGroup: !0,
    add: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._paths, s = this._parsedPaths, l = this._bindings, h = l.length, c = void 0, f = 0, v = arguments.length; f !== v; ++f) {
        var y = arguments[f], S = y.uuid, P = n[S];
        if (P === void 0) {
          P = e++, n[S] = P, t.push(y), S = 0;
          for (var N = h; S !== N; ++S)
            l[S].push(new gn(y, o[S], s[S]));
        } else if (P < i) {
          c = t[P];
          var j = --i;
          for (N = t[j], n[N.uuid] = P, t[P] = N, n[S] = j, t[j] = y, S = 0, N = h; S !== N; ++S) {
            var et = l[S], _t = et[P];
            et[P] = et[j], _t === void 0 && (_t = new gn(y, o[S], s[S])), et[j] = _t;
          }
        } else
          t[P] !== c && console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
      }
      this.nCachedObjects_ = i;
    },
    remove: function() {
      for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, o = n.length, s = 0, l = arguments.length; s !== l; ++s) {
        var h = arguments[s], c = h.uuid, f = i[c];
        if (f !== void 0 && f >= e) {
          var v = e++, y = t[v];
          for (i[y.uuid] = f, t[f] = y, i[c] = v, t[v] = h, h = 0, c = o; h !== c; ++h) {
            y = n[h];
            var S = y[f];
            y[f] = y[v], y[v] = S;
          }
        }
      }
      this.nCachedObjects_ = e;
    },
    uncache: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._bindings, s = o.length, l = 0, h = arguments.length; l !== h; ++l) {
        var c = arguments[l].uuid, f = n[c];
        if (f !== void 0)
          if (delete n[c], f < i) {
            c = --i;
            var v = t[c], y = --e, S = t[y];
            for (n[v.uuid] = f, t[f] = v, n[S.uuid] = c, t[c] = S, t.pop(), v = 0, S = s; v !== S; ++v) {
              var P = o[v], N = P[y];
              P[f] = P[c], P[c] = N, P.pop();
            }
          } else
            for (y = --e, S = t[y], n[S.uuid] = f, t[f] = S, t.pop(), v = 0, S = s; v !== S; ++v)
              P = o[v], P[f] = P[y], P.pop();
      }
      this.nCachedObjects_ = i;
    },
    subscribe_: function(t, e) {
      var i = this._bindingsIndicesByPath, n = i[t], o = this._bindings;
      if (n !== void 0)
        return o[n];
      var s = this._paths, l = this._parsedPaths, h = this._objects, c = this.nCachedObjects_, f = Array(h.length);
      for (n = o.length, i[t] = n, s.push(t), l.push(e), o.push(f), i = c, n = h.length; i !== n; ++i)
        f[i] = new gn(h[i], t, e);
      return f;
    },
    unsubscribe_: function(t) {
      var e = this._bindingsIndicesByPath, i = e[t];
      if (i !== void 0) {
        var n = this._paths, o = this._parsedPaths, s = this._bindings, l = s.length - 1, h = s[l];
        e[t[l]] = i, s[i] = h, s.pop(), o[i] = o[l], o.pop(), n[i] = n[l], n.pop();
      }
    }
  }), Object.assign(la.prototype, {
    play: function() {
      return this._mixer._activateAction(this), this;
    },
    stop: function() {
      return this._mixer._deactivateAction(this), this.reset();
    },
    reset: function() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    },
    isRunning: function() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(t) {
      return this._startTime = t, this;
    },
    setLoop: function(t, e) {
      return this.loop = t, this.repetitions = e, this;
    },
    setEffectiveWeight: function(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(t) {
      return this._scheduleFading(t, 0, 1);
    },
    fadeOut: function(t) {
      return this._scheduleFading(t, 1, 0);
    },
    crossFadeFrom: function(t, e, i) {
      if (t.fadeOut(e), this.fadeIn(e), i) {
        i = this._clip.duration;
        var n = t._clip.duration, o = i / n;
        t.warp(1, n / i, e), this.warp(o, 1, e);
      }
      return this;
    },
    crossFadeTo: function(t, e, i) {
      return t.crossFadeFrom(this, e, i);
    },
    stopFading: function() {
      var t = this._weightInterpolant;
      return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    setEffectiveTimeScale: function(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    },
    syncWith: function(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    },
    halt: function(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    },
    warp: function(t, e, i) {
      var n = this._mixer, o = n.time, s = this._timeScaleInterpolant, l = this.timeScale;
      return s === null && (this._timeScaleInterpolant = s = n._lendControlInterpolant()), n = s.parameterPositions, s = s.sampleValues, n[0] = o, n[1] = o + i, s[0] = t / l, s[1] = e / l, this;
    },
    stopWarping: function() {
      var t = this._timeScaleInterpolant;
      return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(t, e, i, n) {
      if (this.enabled) {
        var o = this._startTime;
        if (o !== null) {
          if (e = (t - o) * i, 0 > e || i === 0)
            return;
          this._startTime = null, e *= i;
        }
        if (e *= this._updateTimeScale(t), i = this._updateTime(e), t = this._updateWeight(t), 0 < t) {
          e = this._interpolants, o = this._propertyBindings;
          for (var s = 0, l = e.length; s !== l; ++s)
            e[s].evaluate(i), o[s].accumulate(n, t);
        }
      } else
        this._updateWeight(t);
    },
    _updateWeight: function(t) {
      var e = 0;
      if (this.enabled) {
        e = this.weight;
        var i = this._weightInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
        }
      }
      return this._effectiveWeight = e;
    },
    _updateTimeScale: function(t) {
      var e = 0;
      if (!this.paused) {
        e = this.timeScale;
        var i = this._timeScaleInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
        }
      }
      return this._effectiveTimeScale = e;
    },
    _updateTime: function(t) {
      var e = this.time + t, i = this._clip.duration, n = this.loop, o = this._loopCount, s = n === 2202;
      if (t === 0)
        return o === -1 ? e : s && (o & 1) === 1 ? i - e : e;
      if (n === 2200)
        t: {
          if (o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i)
            e = i;
          else if (0 > e)
            e = 0;
          else
            break t;
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 > t ? -1 : 1
          });
        }
      else {
        if (o === -1 && (0 <= t ? (o = 0, this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)), e >= i || 0 > e) {
          n = Math.floor(e / i), e -= i * n, o += Math.abs(n);
          var l = this.repetitions - o;
          0 >= l ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 < t ? 1 : -1
          })) : (l === 1 ? (t = 0 > t, this._setEndings(t, !t, s)) : this._setEndings(!1, !1, s), this._loopCount = o, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: n
          }));
        }
        if (s && (o & 1) === 1)
          return this.time = e, i - e;
      }
      return this.time = e;
    },
    _setEndings: function(t, e, i) {
      var n = this._interpolantSettings;
      i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    },
    _scheduleFading: function(t, e, i) {
      var n = this._mixer, o = n.time, s = this._weightInterpolant;
      return s === null && (this._weightInterpolant = s = n._lendControlInterpolant()), n = s.parameterPositions, s = s.sampleValues, n[0] = o, s[0] = e, n[1] = o + t, s[1] = i, this;
    }
  }), Mo.prototype = Object.assign(Object.create(J.prototype), {
    constructor: Mo,
    _bindAction: function(t, e) {
      var i = t._localRoot || this._root, n = t._clip.tracks, o = n.length, s = t._propertyBindings;
      t = t._interpolants;
      var l = i.uuid, h = this._bindingsByRootAndName, c = h[l];
      for (c === void 0 && (c = {}, h[l] = c), h = 0; h !== o; ++h) {
        var f = n[h], v = f.name, y = c[v];
        if (y === void 0) {
          if (y = s[h], y !== void 0) {
            y._cacheIndex === null && (++y.referenceCount, this._addInactiveBinding(y, l, v));
            continue;
          }
          y = new aa(
            gn.create(i, v, e && e._propertyBindings[h].binding.parsedPath),
            f.ValueTypeName,
            f.getValueSize()
          ), ++y.referenceCount, this._addInactiveBinding(y, l, v);
        }
        s[h] = y, t[h].resultBuffer = y.buffer;
      }
    },
    _activateAction: function(t) {
      if (!this._isActiveAction(t)) {
        if (t._cacheIndex === null) {
          var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
          this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
        }
        for (e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var o = e[i];
          o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
        }
        this._lendAction(t);
      }
    },
    _deactivateAction: function(t) {
      if (this._isActiveAction(t)) {
        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var o = e[i];
          --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
        }
        this._takeBackAction(t);
      }
    },
    _initMemoryManager: function() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },
          get inUse() {
            return t._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return t._bindings.length;
          },
          get inUse() {
            return t._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },
          get inUse() {
            return t._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(t) {
      return t = t._cacheIndex, t !== null && t < this._nActiveActions;
    },
    _addInactiveAction: function(t, e, i) {
      var n = this._actions, o = this._actionsByClip, s = o[e];
      s === void 0 ? (s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, o[e] = s) : (e = s.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t;
    },
    _removeInactiveAction: function(t) {
      var e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
      i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid, i = this._actionsByClip, n = i[e];
      var o = n.knownActions, s = o[o.length - 1], l = t._byClipCacheIndex;
      s._byClipCacheIndex = l, o[l] = s, o.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], o.length === 0 && delete i[e], this._removeInactiveBindingsForAction(t);
    },
    _removeInactiveBindingsForAction: function(t) {
      t = t._propertyBindings;
      for (var e = 0, i = t.length; e !== i; ++e) {
        var n = t[e];
        --n.referenceCount === 0 && this._removeInactiveBinding(n);
      }
    },
    _lendAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _takeBackAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _addInactiveBinding: function(t, e, i) {
      var n = this._bindingsByRootAndName, o = n[e], s = this._bindings;
      o === void 0 && (o = {}, n[e] = o), o[i] = t, t._cacheIndex = s.length, s.push(t);
    },
    _removeInactiveBinding: function(t) {
      var e = this._bindings, i = t.binding, n = i.rootNode.uuid;
      i = i.path;
      var o = this._bindingsByRootAndName, s = o[n], l = e[e.length - 1];
      t = t._cacheIndex, l._cacheIndex = t, e[t] = l, e.pop(), delete s[i];
      t: {
        for (var h in s)
          break t;
        delete o[n];
      }
    },
    _lendBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _takeBackBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _lendControlInterpolant: function() {
      var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
      return i === void 0 && (i = new fr(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      ), i.__cacheIndex = e, t[e] = i), i;
    },
    _takeBackControlInterpolant: function(t) {
      var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, o = e[n];
      t.__cacheIndex = n, e[n] = t, o.__cacheIndex = i, e[i] = o;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(t, e) {
      var i = e || this._root, n = i.uuid;
      i = typeof t == "string" ? ir.findByName(i, t) : t, t = i !== null ? i.uuid : t;
      var o = this._actionsByClip[t], s = null;
      if (o !== void 0) {
        if (s = o.actionByRoot[n], s !== void 0)
          return s;
        s = o.knownActions[0], i === null && (i = s._clip);
      }
      return i === null ? null : (e = new la(this, i, e), this._bindAction(e, s), this._addInactiveAction(e, t, n), e);
    },
    existingAction: function(t, e) {
      var i = e || this._root;
      return e = i.uuid, i = typeof t == "string" ? ir.findByName(i, t) : t, t = this._actionsByClip[i ? i.uuid : t], t !== void 0 && t.actionByRoot[e] || null;
    },
    stopAllAction: function() {
      for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, o = this._nActiveBindings = this._nActiveActions = 0; o !== e; ++o)
        t[o].reset();
      for (o = 0; o !== n; ++o)
        i[o].useCount = 0;
      return this;
    },
    update: function(t) {
      t *= this.timeScale;
      for (var e = this._actions, i = this._nActiveActions, n = this.time += t, o = Math.sign(t), s = this._accuIndex ^= 1, l = 0; l !== i; ++l)
        e[l]._update(n, t, o, s);
      for (t = this._bindings, e = this._nActiveBindings, l = 0; l !== e; ++l)
        t[l].apply(s);
      return this;
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(t) {
      var e = this._actions;
      t = t.uuid;
      var i = this._actionsByClip, n = i[t];
      if (n !== void 0) {
        n = n.knownActions;
        for (var o = 0, s = n.length; o !== s; ++o) {
          var l = n[o];
          this._deactivateAction(l);
          var h = l._cacheIndex, c = e[e.length - 1];
          l._cacheIndex = null, l._byClipCacheIndex = null, c._cacheIndex = h, e[h] = c, e.pop(), this._removeInactiveBindingsForAction(l);
        }
        delete i[t];
      }
    },
    uncacheRoot: function(t) {
      t = t.uuid;
      var e = this._actionsByClip;
      for (n in e) {
        var i = e[n].actionByRoot[t];
        i !== void 0 && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
      var n = this._bindingsByRootAndName[t];
      if (n !== void 0)
        for (var o in n)
          t = n[o], t.restoreOriginalState(), this._removeInactiveBinding(t);
    },
    uncacheAction: function(t, e) {
      t = this.existingAction(t, e), t !== null && (this._deactivateAction(t), this._removeInactiveAction(t));
    }
  }), Ua.prototype.clone = function() {
    return new Ua(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }, al.prototype = Object.assign(Object.create(Ft.prototype), {
    constructor: al,
    isInstancedBufferGeometry: !0,
    copy: function(t) {
      return Ft.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), ll.prototype = Object.assign(Object.create(Ii.prototype), {
    constructor: ll,
    isInstancedInterleavedBuffer: !0,
    copy: function(t) {
      return Ii.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), hl.prototype = Object.assign(Object.create(ht.prototype), {
    constructor: hl,
    isInstancedBufferAttribute: !0,
    copy: function(t) {
      return ht.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), Object.assign(Ol.prototype, {
    linePrecision: 1,
    set: function(t, e) {
      this.ray.set(t, e);
    },
    setFromCamera: function(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
    },
    intersectObject: function(t, e, i) {
      return i = i || [], Ko(t, this, i, e), i.sort(ha), i;
    },
    intersectObjects: function(t, e, i) {
      if (i = i || [], Array.isArray(t) === !1)
        return console.warn(
          "THREE.Raycaster.intersectObjects: objects is not an Array."
        ), i;
      for (var n = 0, o = t.length; n < o; n++)
        Ko(t[n], this, i, e);
      return i.sort(ha), i;
    }
  }), Object.assign(ul.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.phi = e, this.theta = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    },
    makeSafe: function() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + e * e + i * i), this.radius === 0 ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(fi.clamp(e / this.radius, -1, 1))), this;
    }
  }), Object.assign(Q.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.theta = e, this.y = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this;
    }
  }), Object.assign(So.prototype, {
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new p();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new p()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), t = new p()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new p()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    },
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new p()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new p();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(Ls.prototype, {
    set: function(t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new m()), t.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), t = new m()), t.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Line3: .at() target is now required"), e = new m()), this.delta(e).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
      var t = new m(), e = new m();
      return function(i, n) {
        return t.subVectors(i, this.start), e.subVectors(this.end, this.start), i = e.dot(e), i = e.dot(t) / i, n && (i = fi.clamp(i, 0, 1)), i;
      };
    }(),
    closestPointToPoint: function(t, e, i) {
      return t = this.closestPointToPointParameter(t, e), i === void 0 && (console.warn(
        "THREE.Line3: .closestPointToPoint() target is now required"
      ), i = new m()), this.delta(i).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    },
    equals: function(t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }
  }), Dn.prototype = Object.create(z.prototype), Dn.prototype.constructor = Dn, Dn.prototype.isImmediateRenderObject = !0, yi.prototype = Object.create(mi.prototype), yi.prototype.constructor = yi, yi.prototype.update = function() {
    var t = new m(), e = new m(), i = new C();
    return function() {
      var n = ["a", "b", "c"];
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var o = this.object.matrixWorld, s = this.geometry.attributes.position, l = this.object.geometry;
      if (l && l.isGeometry)
        for (var h = l.vertices, c = l.faces, f = l = 0, v = c.length; f < v; f++)
          for (var y = c[f], S = 0, P = y.vertexNormals.length; S < P; S++) {
            var N = y.vertexNormals[S];
            t.copy(h[y[n[S]]]).applyMatrix4(o), e.copy(N).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1;
          }
      else if (l && l.isBufferGeometry)
        for (n = l.attributes.position, h = l.attributes.normal, S = l = 0, P = n.count; S < P; S++)
          t.set(n.getX(S), n.getY(S), n.getZ(S)).applyMatrix4(o), e.set(h.getX(S), h.getY(S), h.getZ(S)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1;
      s.needsUpdate = !0;
    };
  }(), Rs.prototype = Object.create(z.prototype), Rs.prototype.constructor = Rs, Rs.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }, Rs.prototype.update = function() {
    var t = new m(), e = new m();
    return function() {
      this.light.updateMatrixWorld();
      var i = this.light.distance ? this.light.distance : 1e3, n = i * Math.tan(this.light.angle);
      this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    };
  }(), Is.prototype = Object.create(mi.prototype), Is.prototype.constructor = Is, Is.prototype.updateMatrixWorld = function() {
    var t = new m(), e = new $(), i = new $();
    return function(n) {
      var o = this.bones, s = this.geometry, l = s.getAttribute("position");
      i.getInverse(this.root.matrixWorld);
      for (var h = 0, c = 0; h < o.length; h++) {
        var f = o[h];
        f.parent && f.parent.isBone && (e.multiplyMatrices(i, f.matrixWorld), t.setFromMatrixPosition(e), l.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(i, f.parent.matrixWorld), t.setFromMatrixPosition(e), l.setXYZ(c + 1, t.x, t.y, t.z), c += 2);
      }
      s.getAttribute("position").needsUpdate = !0, z.prototype.updateMatrixWorld.call(this, n);
    };
  }(), dr.prototype = Object.create(pi.prototype), dr.prototype.constructor = dr, dr.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
  }, dr.prototype.update = function() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }, Os.prototype = Object.create(z.prototype), Os.prototype.constructor = Os, Os.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, Os.prototype.update = function() {
    var t = 0.5 * this.light.width, e = 0.5 * this.light.height, i = this.line.geometry.attributes.position, n = i.array;
    n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, this.color !== void 0 ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
  }, Ds.prototype = Object.create(z.prototype), Ds.prototype.constructor = Ds, Ds.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, Ds.prototype.update = function() {
    var t = new m(), e = new A(), i = new A();
    return function() {
      var n = this.children[0];
      if (this.color !== void 0)
        this.material.color.set(this.color);
      else {
        var o = n.geometry.getAttribute("color");
        e.copy(this.light.color), i.copy(this.light.groundColor);
        for (var s = 0, l = o.count; s < l; s++) {
          var h = s < l / 2 ? e : i;
          o.setXYZ(s, h.r, h.g, h.b);
        }
        o.needsUpdate = !0;
      }
      n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }(), ua.prototype = Object.create(mi.prototype), ua.prototype.constructor = ua, Fa.prototype = Object.create(mi.prototype), Fa.prototype.constructor = Fa, ca.prototype = Object.create(mi.prototype), ca.prototype.constructor = ca, ca.prototype.update = function() {
    var t = new m(), e = new m(), i = new C();
    return function() {
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var n = this.object.matrixWorld, o = this.geometry.attributes.position, s = this.object.geometry, l = s.vertices;
      s = s.faces;
      for (var h = 0, c = 0, f = s.length; c < f; c++) {
        var v = s[c], y = v.normal;
        t.copy(l[v.a]).add(l[v.b]).add(l[v.c]).divideScalar(3).applyMatrix4(n), e.copy(y).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(h, t.x, t.y, t.z), h += 1, o.setXYZ(h, e.x, e.y, e.z), h += 1;
      }
      o.needsUpdate = !0;
    };
  }(), $n.prototype = Object.create(z.prototype), $n.prototype.constructor = $n, $n.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }, $n.prototype.update = function() {
    var t = new m(), e = new m(), i = new m();
    return function() {
      t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length();
    };
  }(), fa.prototype = Object.create(mi.prototype), fa.prototype.constructor = fa, fa.prototype.update = function() {
    function t(s, l, h, c) {
      if (n.set(l, h, c).unproject(o), s = i[s], s !== void 0)
        for (l = e.getAttribute("position"), h = 0, c = s.length; h < c; h++)
          l.setXYZ(s[h], n.x, n.y, n.z);
    }
    var e, i, n = new m(), o = new Be();
    return function() {
      e = this.geometry, i = this.pointMap, o.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", 0.7, 1.1, -1), t("u2", -0.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
    };
  }(), ro.prototype = Object.create(mi.prototype), ro.prototype.constructor = ro, ro.prototype.update = function() {
    var t = new K();
    return function(e) {
      if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && t.setFromObject(this.object), !t.isEmpty()) {
        e = t.min;
        var i = t.max, n = this.geometry.attributes.position, o = n.array;
        o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = e.x, o[4] = i.y, o[5] = i.z, o[6] = e.x, o[7] = e.y, o[8] = i.z, o[9] = i.x, o[10] = e.y, o[11] = i.z, o[12] = i.x, o[13] = i.y, o[14] = e.z, o[15] = e.x, o[16] = i.y, o[17] = e.z, o[18] = e.x, o[19] = e.y, o[20] = e.z, o[21] = i.x, o[22] = e.y, o[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
      }
    };
  }(), ro.prototype.setFromObject = function(t) {
    return this.object = t, this.update(), this;
  }, ro.prototype.copy = function(t) {
    return mi.prototype.copy.call(this, t), this.object = t.object, this;
  }, ro.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, pa.prototype = Object.create(mi.prototype), pa.prototype.constructor = pa, pa.prototype.updateMatrixWorld = function(t) {
    var e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), z.prototype.updateMatrixWorld.call(this, t));
  }, da.prototype = Object.create(Hi.prototype), da.prototype.constructor = da, da.prototype.updateMatrixWorld = function(t) {
    var e = -this.plane.constant;
    1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), z.prototype.updateMatrixWorld.call(this, t);
  };
  var Xa, ya;
  oo.prototype = Object.create(z.prototype), oo.prototype.constructor = oo, oo.prototype.setDirection = function() {
    var t = new m(), e;
    return function(i) {
      0.99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e));
    };
  }(), oo.prototype.setLength = function(t, e, i) {
    e === void 0 && (e = 0.2 * t), i === void 0 && (i = 0.2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix();
  }, oo.prototype.setColor = function(t) {
    this.line.material.color.copy(t), this.cone.material.color.copy(t);
  }, oo.prototype.copy = function(t) {
    return z.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
  }, oo.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, nr.prototype = Object.create(mi.prototype), nr.prototype.constructor = nr, Ee.create = function(t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ee.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
  }, Object.assign(io.prototype, {
    createPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getPoints(t), this.createGeometry(t);
    },
    createSpacedPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getSpacedPoints(t), this.createGeometry(t);
    },
    createGeometry: function(t) {
      console.warn(
        "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      for (var e = new V(), i = 0, n = t.length; i < n; i++) {
        var o = t[i];
        e.vertices.push(new m(o.x, o.y, o.z || 0));
      }
      return e;
    }
  }), Object.assign(Jn.prototype, {
    fromPoints: function(t) {
      console.warn(
        "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
      ), this.setFromPoints(t);
    }
  }), zl.prototype = Object.create(Tn.prototype), Bl.prototype = Object.create(Tn.prototype), cl.prototype = Object.create(Tn.prototype), Object.assign(cl.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error(
        "THREE.Spline: .reparametrizeByArcLength() has been removed."
      );
    }
  }), ua.prototype.setColors = function() {
    console.error(
      "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
  }, Is.prototype.update = function() {
    console.error(
      "THREE.SkeletonHelper: update() no longer needs to be called."
    );
  }, Object.assign(no.prototype, {
    extractUrlBase: function(t) {
      return console.warn(
        "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
      ), ts.extractUrlBase(t);
    }
  }), Object.assign(Zo.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(ra.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(So.prototype, {
    center: function(t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    size: function(t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), Object.assign(K.prototype, {
    center: function(t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    },
    size: function(t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), Ls.prototype.center = function(t) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  }, Object.assign(fi, {
    random16: function() {
      return console.warn(
        "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
      ), Math.random();
    },
    nearestPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
      ), fi.floorPowerOfTwo(t);
    },
    nextPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
      ), fi.ceilPowerOfTwo(t);
    }
  }), Object.assign(C.prototype, {
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
      ), t.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  }), Object.assign($.prototype, {
    extractPosition: function(t) {
      return console.warn(
        "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
      ), this.copyPosition(t);
    },
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    getPosition: function() {
      var t;
      return function() {
        return t === void 0 && (t = new m()), console.warn(
          "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
        ), t.setFromMatrixColumn(this, 3);
      };
    }(),
    setRotationFromQuaternion: function(t) {
      return console.warn(
        "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
      ), this.makeRotationFromQuaternion(t);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector4: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(t) {
      console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
      ), t.transformDirection(this);
    },
    crossVector: function(t) {
      return console.warn(
        "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(t, e, i, n, o, s) {
      return console.warn(
        "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
      ), this.makePerspective(t, e, n, i, o, s);
    }
  }), q.prototype.isIntersectionLine = function(t) {
    return console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ), this.intersectsLine(t);
  }, G.prototype.multiplyVector3 = function(t) {
    return console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ), t.applyQuaternion(this);
  }, Object.assign(Ni.prototype, {
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionPlane: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
      ), this.intersectsPlane(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    }
  }), Object.assign(Ie.prototype, {
    area: function() {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    },
    barycoordFromPoint: function(t, e) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), this.getBarycoord(t, e);
    },
    midpoint: function(t) {
      return console.warn(
        "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
      ), this.getMidpoint(t);
    },
    normal: function(t) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), this.getNormal(t);
    },
    plane: function(t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    }
  }), Object.assign(Ie, {
    barycoordFromPoint: function(t, e, i, n, o) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), Ie.getBarycoord(t, e, i, n, o);
    },
    normal: function(t, e, i, n) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), Ie.getNormal(t, e, i, n);
    }
  }), Object.assign(Fn.prototype, {
    extractAllPoints: function(t) {
      return console.warn(
        "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
      ), this.extractPoints(t);
    },
    extrude: function(t) {
      return console.warn(
        "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
      ), new Kr(this, t);
    },
    makeGeometry: function(t) {
      return console.warn(
        "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
      ), new Qr(this, t);
    }
  }), Object.assign(p.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(m.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
      );
    },
    setEulerFromQuaternion: function() {
      console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
      );
    },
    getPositionFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
      ), this.setFromMatrixPosition(t);
    },
    getScaleFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
      ), this.setFromMatrixScale(t);
    },
    getColumnFromMatrix: function(t, e) {
      return console.warn(
        "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
      ), this.setFromMatrixColumn(e, t);
    },
    applyProjection: function(t) {
      return console.warn(
        "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
      ), this.applyMatrix4(t);
    },
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(E.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(V.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
  }), Object.assign(z.prototype, {
    getChildByName: function(t) {
      return console.warn(
        "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
      ), this.getObjectByName(t);
    },
    renderDepth: function() {
      console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
      );
    },
    translate: function(t, e) {
      return console.warn(
        "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
      ), this.translateOnAxis(e, t);
    },
    getWorldRotation: function() {
      console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
      );
    }
  }), Object.defineProperties(z.prototype, {
    eulerOrder: {
      get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      },
      set: function(t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
      set: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      }
    }
  }), Object.defineProperties(Ki.prototype, {
    objects: {
      get: function() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      }
    }
  }), Object.defineProperty(nn.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  }), Object.defineProperty(Ee.prototype, "__arcLengthDivisions", {
    get: function() {
      return console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions;
    },
    set: function(t) {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions = t;
    }
  }), ye.prototype.setLens = function(t, e) {
    console.warn(
      "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    ), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
  }, Object.defineProperties(Ji.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
        ), this.shadow.camera.fov = t;
      }
    },
    shadowCameraLeft: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
        ), this.shadow.camera.left = t;
      }
    },
    shadowCameraRight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
        ), this.shadow.camera.right = t;
      }
    },
    shadowCameraTop: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
        ), this.shadow.camera.top = t;
      }
    },
    shadowCameraBottom: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
        ), this.shadow.camera.bottom = t;
      }
    },
    shadowCameraNear: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
        ), this.shadow.camera.near = t;
      }
    },
    shadowCameraFar: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
        ), this.shadow.camera.far = t;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn(
          "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
        );
      }
    },
    shadowBias: {
      set: function(t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
        ), this.shadow.mapSize.width = t;
      }
    },
    shadowMapHeight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
        ), this.shadow.mapSize.height = t;
      }
    }
  }), Object.defineProperties(ht.prototype, {
    length: {
      get: function() {
        return console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ), this.array.length;
      }
    },
    copyIndicesArray: function() {
      console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
      );
    }
  }), Object.assign(Ft.prototype, {
    addIndex: function(t) {
      console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
      ), this.setIndex(t);
    },
    addDrawCall: function(t, e, i) {
      i !== void 0 && console.warn(
        "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
      ), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    },
    clearDrawCalls: function() {
      console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
      ), this.clearGroups();
    },
    computeTangents: function() {
      console.warn(
        "THREE.BufferGeometry: .computeTangents() has been removed."
      );
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
  }), Object.defineProperties(Ft.prototype, {
    drawcalls: {
      get: function() {
        return console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ), this.groups;
      }
    },
    offsets: {
      get: function() {
        return console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ), this.groups;
      }
    }
  }), Object.assign(Nr.prototype, {
    getArrays: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
      );
    },
    addShapeList: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
      );
    },
    addShape: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
      );
    }
  }), Object.defineProperties(Ua.prototype, {
    dynamic: {
      set: function() {
        console.warn(
          "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
        );
      }
    },
    onUpdate: {
      value: function() {
        return console.warn(
          "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
        ), this;
      }
    }
  }), Object.defineProperties(Zt.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new A();
      }
    },
    shading: {
      get: function() {
        console.error(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        );
      },
      set: function(t) {
        console.warn(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        ), this.flatShading = t === 1;
      }
    }
  }), Object.defineProperties(Sr.prototype, {
    metal: {
      get: function() {
        return console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
        ), !1;
      },
      set: function() {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
        );
      }
    }
  }), Object.defineProperties(ti.prototype, {
    derivatives: {
      get: function() {
        return console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives;
      },
      set: function(t) {
        console.warn(
          "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives = t;
      }
    }
  }), Object.assign(_e.prototype, {
    clearTarget: function(t, e, i, n) {
      console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
      ), this.setRenderTarget(t), this.clear(e, i, n);
    },
    animate: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
      ), this.setAnimationLoop(t);
    },
    getCurrentRenderTarget: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
      ), this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
      ), this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
      ), this.capabilities.precision;
    },
    resetGLState: function() {
      return console.warn(
        "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
      ), this.state.reset();
    },
    supportsFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      ), this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      ), this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      ), this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      ), this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      ), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      ), this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
      ), this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      ), this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
      ), this.setScissorTest(t);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }
  }), Object.defineProperties(_e.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
        ), this.shadowMap.enabled = t;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
        ), this.shadowMap.type = t;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(ve.prototype, {
    cullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(U.prototype, {
    wrapS: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
      }
    },
    wrapT: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
      }
    },
    magFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter = t;
      }
    },
    minFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter = t;
      }
    },
    anisotropy: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy = t;
      }
    },
    offset: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset = t;
      }
    },
    repeat: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat = t;
      }
    },
    format: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format = t;
      }
    },
    type: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
      }
    },
    generateMipmaps: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps = t;
      }
    }
  }), Object.defineProperties(di.prototype, {
    standing: {
      set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      }
    },
    userHeight: {
      set: function() {
        console.warn("THREE.WebVRManager: .userHeight has been removed.");
      }
    }
  }), Cs.prototype.load = function(t) {
    console.warn(
      "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
    );
    var e = this;
    return new hn().load(t, function(i) {
      e.setBuffer(i);
    }), this;
  }, Jo.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  }, oa.prototype.updateCubeMap = function(t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
  }, Eo.crossOrigin = void 0, Eo.loadTexture = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    var o = new on();
    return o.setCrossOrigin(this.crossOrigin), t = o.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, Eo.loadTextureCube = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    var o = new zi();
    return o.setCrossOrigin(this.crossOrigin), t = o.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, Eo.loadCompressedTexture = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
  }, Eo.loadCompressedTextureCube = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
  }, T.WebGLRenderTargetCube = Y, T.WebGLRenderTarget = U, T.WebGLRenderer = _e, T.ShaderLib = jr, T.UniformsLib = qe, T.UniformsUtils = bn, T.ShaderChunk = Ei, T.FogExp2 = Le, T.Fog = mn, T.Scene = On, T.Sprite = $i, T.LOD = Ki, T.SkinnedMesh = ki, T.Skeleton = nn, T.Bone = rn, T.Mesh = pi, T.LineSegments = mi, T.LineLoop = zr, T.Line = Hi, T.Points = ps, T.Group = ui, T.VideoTexture = tl, T.DataTexture = H, T.DataTexture3D = X, T.CompressedTexture = fo, T.CubeTexture = w, T.CanvasTexture = Vs, T.DepthTexture = Xs, T.Texture = O, T.AnimationLoader = Qt, T.CompressedTextureLoader = Yt, T.DataTextureLoader = Ue, T.CubeTextureLoader = zi, T.TextureLoader = on, T.ObjectLoader = ra, T.MaterialLoader = Ba, T.BufferGeometryLoader = nl, T.DefaultLoadingManager = Gn, T.LoadingManager = xo, T.JSONLoader = Zo, T.ImageLoader = si, T.ImageBitmapLoader = rl, T.FontLoader = Il, T.FileLoader = At, T.Loader = no, T.LoaderUtils = ts, T.Cache = Xr, T.AudioLoader = hn, T.SpotLightShadow = ia, T.SpotLight = na, T.PointLight = qo, T.RectAreaLight = za, T.HemisphereLight = ea, T.DirectionalLightShadow = To, T.DirectionalLight = Wr, T.AmbientLight = Yo, T.LightShadow = Hr, T.Light = Ji, T.StereoCamera = In, T.PerspectiveCamera = ye, T.OrthographicCamera = As, T.CubeCamera = oa, T.ArrayCamera = ke, T.Camera = Be, T.AudioListener = ka, T.PositionalAudio = sa, T.AudioContext = gl, T.AudioAnalyser = Jo, T.Audio = Cs, T.VectorKeyframeTrack = Es, T.StringKeyframeTrack = Da, T.QuaternionKeyframeTrack = Ss, T.NumberKeyframeTrack = Er, T.ColorKeyframeTrack = Oa, T.BooleanKeyframeTrack = Ia, T.PropertyMixer = aa, T.PropertyBinding = gn, T.KeyframeTrack = Rn, T.AnimationUtils = zn, T.AnimationObjectGroup = Ps, T.AnimationMixer = Mo, T.AnimationClip = ir, T.Uniform = Ua, T.InstancedBufferGeometry = al, T.BufferGeometry = Ft, T.Geometry = V, T.InterleavedBufferAttribute = Oi, T.InstancedInterleavedBuffer = ll, T.InterleavedBuffer = Ii, T.InstancedBufferAttribute = hl, T.Face3 = M, T.Object3D = z, T.Raycaster = Ol, T.Layers = F, T.EventDispatcher = J, T.Clock = sl, T.QuaternionLinearInterpolant = Vn, T.LinearInterpolant = fr, T.DiscreteInterpolant = Xo, T.CubicInterpolant = ta, T.Interpolant = kn, T.Triangle = Ie, T.Math = fi, T.Spherical = ul, T.Cylindrical = Q, T.Plane = q, T.Frustum = b, T.Sphere = B, T.Ray = Ni, T.Matrix4 = $, T.Matrix3 = C, T.Box3 = K, T.Box2 = So, T.Line3 = Ls, T.Euler = x, T.Vector4 = E, T.Vector3 = m, T.Vector2 = p, T.Quaternion = G, T.Color = A, T.ImmediateRenderObject = Dn, T.VertexNormalsHelper = yi, T.SpotLightHelper = Rs, T.SkeletonHelper = Is, T.PointLightHelper = dr, T.RectAreaLightHelper = Os, T.HemisphereLightHelper = Ds, T.GridHelper = ua, T.PolarGridHelper = Fa, T.FaceNormalsHelper = ca, T.DirectionalLightHelper = $n, T.CameraHelper = fa, T.BoxHelper = ro, T.Box3Helper = pa, T.PlaneHelper = da, T.ArrowHelper = oo, T.AxesHelper = nr, T.Shape = Fn, T.Path = Jn, T.ShapePath = Na, T.Font = ol, T.CurvePath = io, T.Curve = Ee, T.ImageUtils = Eo, T.ShapeUtils = Vr, T.WebGLUtils = He, T.WireframeGeometry = ds, T.ParametricGeometry = qs, T.ParametricBufferGeometry = ms, T.TetrahedronGeometry = Ys, T.TetrahedronBufferGeometry = gs, T.OctahedronGeometry = Zs, T.OctahedronBufferGeometry = Oo, T.IcosahedronGeometry = Js, T.IcosahedronBufferGeometry = vs, T.DodecahedronGeometry = ys, T.DodecahedronBufferGeometry = _s, T.PolyhedronGeometry = Wi, T.PolyhedronBufferGeometry = _i, T.TubeGeometry = ln, T.TubeBufferGeometry = po, T.TorusKnotGeometry = Mr, T.TorusKnotBufferGeometry = Do, T.TorusGeometry = zo, T.TorusBufferGeometry = Pn, T.TextGeometry = Ks, T.TextBufferGeometry = No, T.SphereGeometry = mo, T.SphereBufferGeometry = ur, T.RingGeometry = Qs, T.RingBufferGeometry = ko, T.PlaneGeometry = Fe, T.PlaneBufferGeometry = xe, T.LatheGeometry = Ts, T.LatheBufferGeometry = go, T.ShapeGeometry = Qr, T.ShapeBufferGeometry = vo, T.ExtrudeGeometry = Kr, T.ExtrudeBufferGeometry = Nr, T.EdgesGeometry = yo, T.ConeGeometry = Ms, T.ConeBufferGeometry = Ln, T.CylinderGeometry = to, T.CylinderBufferGeometry = eo, T.CircleGeometry = Uo, T.CircleBufferGeometry = kr, T.BoxGeometry = Dt, T.BoxBufferGeometry = kt, T.ShadowMaterial = _o, T.SpriteMaterial = Ui, T.RawShaderMaterial = Fo, T.ShaderMaterial = ti, T.PointsMaterial = Cn, T.MeshPhysicalMaterial = Go, T.MeshStandardMaterial = Ur, T.MeshPhongMaterial = Sr, T.MeshToonMaterial = Ho, T.MeshNormalMaterial = Wo, T.MeshLambertMaterial = cr, T.MeshDepthMaterial = oe, T.MeshDistanceMaterial = te, T.MeshBasicMaterial = Ge, T.MeshMatcapMaterial = jo, T.LineDashedMaterial = Vo, T.LineBasicMaterial = Di, T.Material = Zt, T.Float64BufferAttribute = Rt, T.Float32BufferAttribute = Ct, T.Uint32BufferAttribute = Bt, T.Int32BufferAttribute = D, T.Uint16BufferAttribute = Et, T.Int16BufferAttribute = lt, T.Uint8ClampedBufferAttribute = zt, T.Uint8BufferAttribute = gt, T.Int8BufferAttribute = ft, T.BufferAttribute = ht, T.ArcCurve = bs, T.CatmullRomCurve3 = Tn, T.CubicBezierCurve = qn, T.CubicBezierCurve3 = wi, T.EllipseCurve = Un, T.LineCurve = Yn, T.LineCurve3 = pr, T.QuadraticBezierCurve = Zn, T.QuadraticBezierCurve3 = Gr, T.SplineCurve = br, T.REVISION = "98", T.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, T.CullFaceNone = 0, T.CullFaceBack = 1, T.CullFaceFront = 2, T.CullFaceFrontBack = 3, T.FrontFaceDirectionCW = 0, T.FrontFaceDirectionCCW = 1, T.BasicShadowMap = 0, T.PCFShadowMap = 1, T.PCFSoftShadowMap = 2, T.FrontSide = 0, T.BackSide = 1, T.DoubleSide = 2, T.FlatShading = 1, T.SmoothShading = 2, T.NoColors = 0, T.FaceColors = 1, T.VertexColors = 2, T.NoBlending = 0, T.NormalBlending = 1, T.AdditiveBlending = 2, T.SubtractiveBlending = 3, T.MultiplyBlending = 4, T.CustomBlending = 5, T.AddEquation = 100, T.SubtractEquation = 101, T.ReverseSubtractEquation = 102, T.MinEquation = 103, T.MaxEquation = 104, T.ZeroFactor = 200, T.OneFactor = 201, T.SrcColorFactor = 202, T.OneMinusSrcColorFactor = 203, T.SrcAlphaFactor = 204, T.OneMinusSrcAlphaFactor = 205, T.DstAlphaFactor = 206, T.OneMinusDstAlphaFactor = 207, T.DstColorFactor = 208, T.OneMinusDstColorFactor = 209, T.SrcAlphaSaturateFactor = 210, T.NeverDepth = 0, T.AlwaysDepth = 1, T.LessDepth = 2, T.LessEqualDepth = 3, T.EqualDepth = 4, T.GreaterEqualDepth = 5, T.GreaterDepth = 6, T.NotEqualDepth = 7, T.MultiplyOperation = 0, T.MixOperation = 1, T.AddOperation = 2, T.NoToneMapping = 0, T.LinearToneMapping = 1, T.ReinhardToneMapping = 2, T.Uncharted2ToneMapping = 3, T.CineonToneMapping = 4, T.UVMapping = 300, T.CubeReflectionMapping = 301, T.CubeRefractionMapping = 302, T.EquirectangularReflectionMapping = 303, T.EquirectangularRefractionMapping = 304, T.SphericalReflectionMapping = 305, T.CubeUVReflectionMapping = 306, T.CubeUVRefractionMapping = 307, T.RepeatWrapping = 1e3, T.ClampToEdgeWrapping = 1001, T.MirroredRepeatWrapping = 1002, T.NearestFilter = 1003, T.NearestMipMapNearestFilter = 1004, T.NearestMipMapLinearFilter = 1005, T.LinearFilter = 1006, T.LinearMipMapNearestFilter = 1007, T.LinearMipMapLinearFilter = 1008, T.UnsignedByteType = 1009, T.ByteType = 1010, T.ShortType = 1011, T.UnsignedShortType = 1012, T.IntType = 1013, T.UnsignedIntType = 1014, T.FloatType = 1015, T.HalfFloatType = 1016, T.UnsignedShort4444Type = 1017, T.UnsignedShort5551Type = 1018, T.UnsignedShort565Type = 1019, T.UnsignedInt248Type = 1020, T.AlphaFormat = 1021, T.RGBFormat = 1022, T.RGBAFormat = 1023, T.LuminanceFormat = 1024, T.LuminanceAlphaFormat = 1025, T.RGBEFormat = 1023, T.DepthFormat = 1026, T.DepthStencilFormat = 1027, T.RedFormat = 1028, T.RGB_S3TC_DXT1_Format = 33776, T.RGBA_S3TC_DXT1_Format = 33777, T.RGBA_S3TC_DXT3_Format = 33778, T.RGBA_S3TC_DXT5_Format = 33779, T.RGB_PVRTC_4BPPV1_Format = 35840, T.RGB_PVRTC_2BPPV1_Format = 35841, T.RGBA_PVRTC_4BPPV1_Format = 35842, T.RGBA_PVRTC_2BPPV1_Format = 35843, T.RGB_ETC1_Format = 36196, T.RGBA_ASTC_4x4_Format = 37808, T.RGBA_ASTC_5x4_Format = 37809, T.RGBA_ASTC_5x5_Format = 37810, T.RGBA_ASTC_6x5_Format = 37811, T.RGBA_ASTC_6x6_Format = 37812, T.RGBA_ASTC_8x5_Format = 37813, T.RGBA_ASTC_8x6_Format = 37814, T.RGBA_ASTC_8x8_Format = 37815, T.RGBA_ASTC_10x5_Format = 37816, T.RGBA_ASTC_10x6_Format = 37817, T.RGBA_ASTC_10x8_Format = 37818, T.RGBA_ASTC_10x10_Format = 37819, T.RGBA_ASTC_12x10_Format = 37820, T.RGBA_ASTC_12x12_Format = 37821, T.LoopOnce = 2200, T.LoopRepeat = 2201, T.LoopPingPong = 2202, T.InterpolateDiscrete = 2300, T.InterpolateLinear = 2301, T.InterpolateSmooth = 2302, T.ZeroCurvatureEnding = 2400, T.ZeroSlopeEnding = 2401, T.WrapAroundEnding = 2402, T.TrianglesDrawMode = 0, T.TriangleStripDrawMode = 1, T.TriangleFanDrawMode = 2, T.LinearEncoding = 3e3, T.sRGBEncoding = 3001, T.GammaEncoding = 3007, T.RGBEEncoding = 3002, T.LogLuvEncoding = 3003, T.RGBM7Encoding = 3004, T.RGBM16Encoding = 3005, T.RGBDEncoding = 3006, T.BasicDepthPacking = 3200, T.RGBADepthPacking = 3201, T.TangentSpaceNormalMap = 0, T.ObjectSpaceNormalMap = 1, T.CubeGeometry = Dt, T.Face4 = function(t, e, i, n, o, s, l) {
    return console.warn(
      "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
    ), new M(t, e, i, o, s, l);
  }, T.LineStrip = 0, T.LinePieces = 1, T.MeshFaceMaterial = function(t) {
    return console.warn(
      "THREE.MeshFaceMaterial has been removed. Use an Array instead."
    ), t;
  }, T.MultiMaterial = function(t) {
    return t === void 0 && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
      return t.slice();
    }, t;
  }, T.PointCloud = function(t, e) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ps(t, e);
  }, T.Particle = function(t) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new $i(t);
  }, T.ParticleSystem = function(t, e) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ps(t, e);
  }, T.PointCloudMaterial = function(t) {
    return console.warn(
      "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
    ), new Cn(t);
  }, T.ParticleBasicMaterial = function(t) {
    return console.warn(
      "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
    ), new Cn(t);
  }, T.ParticleSystemMaterial = function(t) {
    return console.warn(
      "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
    ), new Cn(t);
  }, T.Vertex = function(t, e, i) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new m(t, e, i);
  }, T.DynamicBufferAttribute = function(t, e) {
    return console.warn(
      "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
    ), new ht(t, e).setDynamic(!0);
  }, T.Int8Attribute = function(t, e) {
    return console.warn(
      "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
    ), new ft(t, e);
  }, T.Uint8Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
    ), new gt(t, e);
  }, T.Uint8ClampedAttribute = function(t, e) {
    return console.warn(
      "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
    ), new zt(t, e);
  }, T.Int16Attribute = function(t, e) {
    return console.warn(
      "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
    ), new lt(t, e);
  }, T.Uint16Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
    ), new Et(t, e);
  }, T.Int32Attribute = function(t, e) {
    return console.warn(
      "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
    ), new D(t, e);
  }, T.Uint32Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
    ), new Bt(t, e);
  }, T.Float32Attribute = function(t, e) {
    return console.warn(
      "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
    ), new Ct(t, e);
  }, T.Float64Attribute = function(t, e) {
    return console.warn(
      "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
    ), new Rt(t, e);
  }, T.ClosedSplineCurve3 = zl, T.SplineCurve3 = Bl, T.Spline = cl, T.AxisHelper = function(t) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new nr(t);
  }, T.BoundingBoxHelper = function(t, e) {
    return console.warn(
      "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
    ), new ro(t, e);
  }, T.EdgesHelper = function(t, e) {
    return console.warn(
      "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
    ), new mi(
      new yo(t.geometry),
      new Di({ color: e !== void 0 ? e : 16777215 })
    );
  }, T.WireframeHelper = function(t, e) {
    return console.warn(
      "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
    ), new mi(
      new ds(t.geometry),
      new Di({ color: e !== void 0 ? e : 16777215 })
    );
  }, T.XHRLoader = function(t) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new At(t);
  }, T.BinaryTextureLoader = function(t) {
    return console.warn(
      "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
    ), new Ue(t);
  }, T.GeometryUtils = {
    merge: function(t, e, i) {
      if (console.warn(
        "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
      ), e.isMesh) {
        e.matrixAutoUpdate && e.updateMatrix();
        var n = e.matrix;
        e = e.geometry;
      }
      t.merge(e, n, i);
    },
    center: function(t) {
      return console.warn(
        "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
      ), t.center();
    }
  }, T.Projector = function() {
    console.error(
      "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
    ), this.projectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .projectVector() is now vector.project()."
      ), t.project(e);
    }, this.unprojectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .unprojectVector() is now vector.unproject()."
      ), t.unproject(e);
    }, this.pickingRay = function() {
      console.error(
        "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
      );
    };
  }, T.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  }, T.SceneUtils = {
    createMultiMaterialObject: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    detach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    attach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    }
  }, T.LensFlare = function() {
    console.error(
      "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
    );
  }, Object.defineProperty(T, "__esModule", { value: !0 });
});
THREE.Sky = function() {
  var T = THREE.Sky.SkyShader, J = new THREE.ShaderMaterial({
    fragmentShader: T.fragmentShader,
    vertexShader: T.vertexShader,
    uniforms: THREE.UniformsUtils.clone(T.uniforms),
    side: THREE.BackSide
  });
  THREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), J);
};
THREE.Sky.prototype = Object.create(THREE.Mesh.prototype);
THREE.Sky.SkyShader = {
  uniforms: {
    luminance: { value: 1 },
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new THREE.Vector3() }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    // wavelength of used primaries, according to preetham
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
    // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    // mie stuff
    // K coefficient for the primaries
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    // earth shadow hack
    // cutoffAngle = pi / 1.95;
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    // set z to camera.far
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    // extinction (absorbtion + out scattering)
    // rayleigh coefficients
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    // mie coefficients
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join(`
`),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float luminance;",
    "uniform float mieDirectionalG;",
    "const vec3 cameraPos = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    // refractive index of air
    "const float N = 2.545E25;",
    // number of molecules per unit volume for air at
    // 288.15K and 1013mb (sea level -45 celsius)
    // optical length at zenith for molecules
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // 66 arc seconds -> degrees, and the cosine of that
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    // 3.0 / ( 16.0 * pi )
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    // 1.0 / ( 4.0 * pi )
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    // Filmic ToneMapping http://filmicgames.com/archives/75
    "const float A = 0.15;",
    "const float B = 0.50;",
    "const float C = 0.10;",
    "const float D = 0.20;",
    "const float E = 0.02;",
    "const float F = 0.30;",
    "const float whiteScale = 1.0748724675633854;",
    // 1.0 / Uncharted2Tonemap(1000.0)
    "vec3 Uncharted2Tonemap( vec3 x ) {",
    "	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
    "}",
    "void main() {",
    // optical length
    // cutoff angle at 90 to avoid singularity in next formula.
    "	float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    // combined extinction factor
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    // in scattering
    "	float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    // nightsky
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    // composition + solar disc
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );",
    "	vec3 color = curr * whiteScale;",
    "	vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "}"
  ].join(`
`)
};
(function(T) {
  typeof module > "u" ? window.charming = T : module.exports = T;
})(function(T, J) {
  J = J || {};
  var p = J.tagName || "span", $ = J.classPrefix != null ? J.classPrefix : "char", G = 1, m = function(C) {
    for (var O = C.parentNode, E = C.nodeValue, U = E.length, Y = -1; ++Y < U; ) {
      var H = document.createElement(p);
      $ && (H.className = $ + G, G++), H.appendChild(document.createTextNode(E[Y])), O.insertBefore(H, C);
    }
    O.removeChild(C);
  };
  return function C(O) {
    for (var E = [].slice.call(O.childNodes), U = E.length, Y = -1; ++Y < U; )
      C(E[Y]);
    O.nodeType === Node.TEXT_NODE && m(O);
  }(T), T;
});
class sg {
  constructor(J, p = []) {
    mars3d ? (this.map = J, this.tilesetLayer, this.modelArr = p, this.bimObliquePhotographyId = [], this.editDate = {
      id: null
    }) : console.error("未引入指定插件");
  }
  /**
   * 给 modelArr 添加数据
   * @param  { Object } mode 模型数据
   */
  pushModel(J) {
    this.modelArr.push(J);
  }
  /**
   * add 模型方法
   * @param  { Object || String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  add(J, p) {
    const $ = /* @__PURE__ */ new Map([["click", mars3d.EventType.click]]);
    return new Promise((G, m) => {
      let C, O, E, U, Y, H, K, B, q;
      if (typeof J != "object") {
        let A = this.query(J);
        A || m("缺少树结构");
        let { id: d, bimModelExcavationDetails: g, bimModel: M } = A;
        C = d, O = M.modelType, E = M.tender, U = M.releasedDistance, Y = M.modelName, H = M.isDynamicReleased, K = {
          bimModelExcavationDetails: g
        }, B = A.url, q = M.modelColor;
      } else
        C = J.modelId, O = J.modelType, E = J.tender, U = J.releasedDistance, Y = J.modelTitle, H = J.permission, K = J.customize, B = J.url, q = J.color;
      let b = this.map.getLayer(J, "modelId");
      if (b)
        return G(b), !1;
      if (B.indexOf("tileset.json") < 0)
        return console.error("链接不完整", Y), G({
          tite: "【模型】" + Y + "数据地址有误",
          type: "error",
          id: C,
          url: B
        }), !1;
      new Cesium.Resource({
        url: B
      }).fetchJson().then((d) => {
        let g = null, M = { enabled: !0, precise: !1 }, x = [];
        q && (g = {
          color: { conditions: [["true", q]] }
        }), window.bimClip && window.bimClip.activeObj[C] && (Object.keys(window.bimClip.activeObj[C]).forEach((F) => {
          let { item: z } = window.bimClip.activeObj[C][F], { bimModelExcavationDetails: V } = z, { excavationDetails: ht } = V;
          x.push({
            positions: JSON.parse(ht).excavationDetails,
            id: Number(F)
          });
        }), x.length > 0 && (M.area = x)), this.tilesetLayer = new mars3d.layer.TilesetLayer({
          modelId: C,
          modelType: O,
          tender: E,
          releasedDistance: U,
          modelTitle: Y,
          permission: H,
          customize: K,
          url: encodeURI(B),
          flat: {
            precise: !1
          },
          skipLevelOfDetail: !0,
          loadSiblings: !0,
          cullRequestsWhileMoving: !0,
          cullRequestsWhileMovingMultiplier: 10,
          preferLeaves: !0,
          progressiveResolutionHeightFraction: 0.5,
          dynamicScreenSpaceError: !0,
          preloadWhenHidden: !1,
          style: g,
          clip: M,
          cacheBytes: 1073741824 * 2,
          // 1024MB = 1024*1024*1024
          maximumCacheOverflowBytes: 2147483648 * 2
          // 2048MB = 2048*1024*1024
          // 1.04版本
          // customShader: new Cesium.CustomShader({
          //   lightingModel: Cesium.LightingModel.UNLIT,
          // }),
        }), this.tilesetLayer.bindPopup((F) => {
          if (F.graphic) {
            const z = F.graphic.attr;
            let V = null, ht = null;
            return JSON.stringify(z) !== "{}" ? (z.name && (V = z.name.lastIndexOf("@")), V && V > -1 && (ht = z.name.slice(0, V)), z.name ? `&nbsp;&nbsp;<span>${ht || z.name}</span>&nbsp;&nbsp;` : `&nbsp;&nbsp;<span>${Y}</span>&nbsp;&nbsp;`) : `&nbsp;&nbsp;<span>${Y}</span>&nbsp;&nbsp;`;
          } else
            return `&nbsp;&nbsp;<span>${Y}</span>&nbsp;&nbsp;`;
        }), this.tilesetLayer.readyPromise.then((F) => {
          console.log("加载完成", this.tilesetLayer, F), G(F);
          let { modelId: z } = F.options;
          F.clip.options.area.forEach((V) => {
            window.bimClip.activeObj[z][V.id].id == null && (window.bimClip.activeObj[z][V.id].id = V.id);
          });
        }).catch((F) => {
          G();
        }), this.tilesetLayer.on("click", (F) => {
          F.layer.style == null && map.bimMapEdit == "0" && F.layer.openHighlight(
            {
              color: "rgba(255,0,0,1)"
            },
            !0
          );
        }), p && Object.keys(p).forEach((F) => {
          this.tilesetLayer.on($.get(F), (z) => {
            p[F](z);
          });
        }), O == 0 && this.bimObliquePhotographyId.push(C), this.map.addLayer(this.tilesetLayer);
      }).catch((d) => {
        console.error("数据加载失败", Y), G({
          tite: "【模型】" + Y + "数据加载失败",
          type: "error",
          id: C,
          url: B
        });
      });
    });
  }
  /**
   * 移除模型方法
   * @param  { String } id 模型id
   *
   */
  remove(J) {
    this.map.getLayer(J, "modelId") && (this.map.getLayer(J, "modelId").closeHighlight(), this.map.removeLayer(this.map.getLayer(J, "modelId")));
  }
  /**
   * 选中模型
   * @param  { String } id 模型id
   *
   */
  selected(J, p = !0) {
    return new Promise(($, G) => {
      let m = this.map.getLayer(J, "modelId");
      m ? (p && m.flyTo(), m.style == null && map.bimMapEdit == "0" && m.openHighlight(
        {
          color: "rgba(255,0,0,1)"
        },
        !0
      ), $(m)) : this.add(J).then((C) => {
        C && (p && C.flyTo(), C.style == null && map.bimMapEdit == "0" && C.openHighlight(
          {
            color: "rgba(255,0,0,1)"
          },
          !0
        ), $(C));
      });
    });
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArr = [], this.bimObliquePhotographyId = [], this.tilesetLayer = null;
  }
  /**
   * 查询动态释放模型方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(J) {
    return this.modelArr.length == 0 ? !1 : this.modelArr.find((p) => p.id == J);
  }
  /**
   * 用户操作的模型
   * @param  { String } id 模型属性
   */
  postEditDate(J) {
    this.editDate = {
      id: J
    };
  }
  /**
   * 更新模型颜色
   * @param  { String } id 模型属性
   * @param  { String | Number } newColor 需要着色的颜色
   * @param  { String } selectcontent 判断逻辑 默认是全部染色
   */
  editColor(J, p, $ = "true") {
    let G = this.map.getLayer(J, "modelId");
    if (this.postEditDate(J), p)
      G.style = {
        color: {
          conditions: [[$, p]]
        }
      };
    else {
      let m = this.query(J).modelColor;
      m ? G.style = {
        color: { conditions: [[$, m]] }
      } : G.style = null;
    }
  }
  /**
   * 更新模型透明度
   * @param  { String } id 模型属性
   * @param  { String | Number } opacity 透明度值
   */
  editOpacity(J, p) {
    this.map.getLayer(J, "modelId").opacity = p;
  }
  /**
   * 模型挖洞
   */
  addClip(J) {
    return new Promise((p, $) => {
      window.bimClip ? p(bimClip.clipModelAdd(J)) : $("挖洞工具未初始化");
    });
  }
  /**
   * 模型挖洞 移除
   */
  removeClip(J) {
    window.bimClip ? window.bimClip.clipModelremoveClip(J) : console.log("挖洞工具未初始化");
  }
  // tilesetLayer.clip.clear()
}
const ih = (T) => Object.prototype.toString.call(T) === "[object Object]";
function rh() {
  const T = Array.from(arguments);
  if (T.length < 2)
    return T[0];
  let J = T[0];
  return T.shift(), T.forEach((p) => {
    if (ih(p)) {
      ih(J) || (J = {});
      for (let $ in p)
        J[$] && ih(p[$]) ? J[$] = rh(J[$], p[$]) : J[$] = p[$];
    } else
      p instanceof Array && (J instanceof Array || (J = []), p.forEach(($, G) => {
        ih($) ? J[G] = rh(J[G]) : J[G] = $;
      }));
  }), J;
}
let El = {};
const Hu = (T, J, p) => {
  El = {};
  let { vectorStyle: $, difference: G } = T;
  if ($) {
    let { divType: m } = $, C = "";
    if (m) {
      let {
        theme_color: O,
        title: E,
        font_color: U,
        content: Y,
        scaleByDistance: H,
        scaleByDistance_far: K,
        scaleByDistance_farValue: B,
        scaleByDistance_near: q,
        scaleByDistance_nearValue: b,
        distanceDisplayCondition: A,
        distanceDisplayCondition_far: d,
        distanceDisplayCondition_near: g,
        clampToGround: M,
        divStyle: x
        // theme_color2,
        // theme_color3,
      } = $, { theme_color2: F, theme_color3: z } = x;
      switch (m) {
        case "1":
          C = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${O};--theme-font-color1:${U};">
            <div class="title">${E}</div>
          </div >`;
          break;
        case "2":
          C = `<div class="entity-div-style entity-div-style2" style="--theme-color1:${O};--theme-font-color1:${U};">
            <div class="title">${E}</div>
             <div class="mars3d-divUpLabel-line"></div>
          </div >`;
          break;
        case "3":
          C = `<div class="entity-div-style entity-div-style3" style="--theme-color1:${O};--theme-font-color1:${U};--theme-color2:${F};--theme-color3:${z}">
            <div class="image"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="infotop"><div class="title">${E}</div><div class="content overflow-auto scrollbar h-full">${Y}</div></div>
          </div >`;
          break;
        case "4":
          C = `<div class="entity-div-style entity-div-style4" style="--theme-color1:${O};--theme-font-color1:${U};">
            <div class="title">${E}</div>
          </div >`;
          break;
        case "5":
          C = `<div class="entity-div-style entity-div-style5 marsTiltPanel marsTiltPanel-theme-green" style="--theme-color1:${O};--theme-font-color1:${U};--theme-color2:${F};">
            <div class="marsTiltPanel-wrap">
              <div class="area">
                <div class="arrow-lt"></div>
                <div class="b-t"></div>
                <div class="b-r"></div>
                <div class="b-b"></div>
                <div class="b-l"></div>
                <div class="arrow-rb"></div>
                <div class="label-wrap">
                  <div class="title">${E}</div>
                  <div class="content">${Y}</div>
                </div>
              </div>
              <div class="b-t-l"></div>
              <div class="b-b-r"></div>
            </div>
            <div class="arrow"></div>
          </div >`;
          break;
        case "6":
          C = `<div class="entity-div-style entity-div-style6" style="--theme-color1:${O};--theme-font-color1:${U};--theme-color2:${F};">
            <div class="title">${E}</div>
          </div >`;
          break;
        case "7":
          C = `<div class="entity-div-style entity-div-style7" style="--theme-color1:${O};--theme-font-color1:${U};">
            <div class="title">${E}</div>
            <div class="pile-number">
              <div class="circular"></div>
              <div class="pole"></div>
            </div>
          </div >`;
          break;
      }
      El = {
        html: C,
        scaleByDistance: H,
        scaleByDistance_far: K,
        scaleByDistance_farValue: B,
        scaleByDistance_near: q,
        scaleByDistance_nearValue: b,
        distanceDisplayCondition: A,
        distanceDisplayCondition_far: d,
        distanceDisplayCondition_near: g,
        clampToGround: M
      };
    } else
      T.difference && T.difference.length > 0 && T.difference.forEach((O) => {
        rh(El, {
          [O]: $[O]
        });
      }), J && J.difference && J.difference.length > 0 && J.difference.forEach((O) => {
        rh(El, {
          label: {
            [O]: J.labelStyle[O]
          }
        });
      });
  }
  return El;
};
var xr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wh(T) {
  return T && T.__esModule && Object.prototype.hasOwnProperty.call(T, "default") ? T.default : T;
}
var oh = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
oh.exports;
(function(T, J) {
  (function() {
    var p, $ = "4.17.21", G = 200, m = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", C = "Expected a function", O = "Invalid `variable` option passed into `_.template`", E = "__lodash_hash_undefined__", U = 500, Y = "__lodash_placeholder__", H = 1, K = 2, B = 4, q = 1, b = 2, A = 1, d = 2, g = 4, M = 8, x = 16, F = 32, z = 64, V = 128, ht = 256, ft = 512, gt = 30, zt = "...", lt = 800, Et = 16, D = 1, Bt = 2, Ct = 3, Rt = 1 / 0, ge = 9007199254740991, ue = 17976931348623157e292, Ft = 0 / 0, Dt = 4294967295, kt = Dt - 1, Fe = Dt >>> 1, xe = [
      ["ary", V],
      ["bind", A],
      ["bindKey", d],
      ["curry", M],
      ["curryRight", x],
      ["flip", ft],
      ["partial", F],
      ["partialRight", z],
      ["rearg", ht]
    ], Zt = "[object Arguments]", ti = "[object Array]", Ni = "[object AsyncFunction]", Ie = "[object Boolean]", Ge = "[object Date]", pi = "[object DOMException]", Li = "[object Error]", an = "[object Function]", Zi = "[object GeneratorFunction]", R = "[object Map]", Jt = "[object Number]", jt = "[object Null]", ct = "[object Object]", pt = "[object Promise]", Lt = "[object Proxy]", ie = "[object RegExp]", Kt = "[object Set]", w = "[object String]", X = "[object Symbol]", nt = "[object Undefined]", tt = "[object WeakMap]", vt = "[object WeakSet]", Gt = "[object ArrayBuffer]", Xt = "[object DataView]", Vt = "[object Float32Array]", Ne = "[object Float64Array]", Re = "[object Int8Array]", de = "[object Int16Array]", we = "[object Int32Array]", vi = "[object Uint8Array]", Mi = "[object Uint8ClampedArray]", ni = "[object Uint16Array]", Si = "[object Uint32Array]", wr = /\b__p \+= '';/g, jn = /\b(__p \+=) '' \+/g, tn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, $r = /&(?:amp|lt|gt|quot|#39);/g, Ri = /[&<>"']/g, co = RegExp($r.source), Rr = RegExp(Ri.source), Ma = /<%-([\s\S]+?)%>/g, dn = /<%([\s\S]+?)%>/g, ls = /<%=([\s\S]+?)%>/g, Lo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, tr = /^\w*$/, hs = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Hs = /[\\^$.*+?()[\]{}|]/g, Sa = RegExp(Hs.source), Ir = /^\s+/, $a = /\s/, us = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Ws = /\{\n\/\* \[wrapped with (.+)\] \*/, Or = /,? & /, js = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, cs = /[()=,{}\[\]\/\s]/, fs = /\\(\\)?/g, Dr = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ea = /\w*$/, Ka = /^[-+]0x[0-9a-f]+$/i, Qa = /^0b[01]+$/i, Ro = /^\[object .+?Constructor\]$/, Io = /^0o[0-7]+$/i, ba = /^(?:0|[1-9]\d*)$/, Aa = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Tr = /($^)/, L = /['\n\r\u2028\u2029\\]/g, Z = "\\ud800-\\udfff", ot = "\\u0300-\\u036f", rt = "\\ufe20-\\ufe2f", I = "\\u20d0-\\u20ff", Mt = ot + rt + I, st = "\\u2700-\\u27bf", Pt = "a-z\\xdf-\\xf6\\xf8-\\xff", Ht = "\\xac\\xb1\\xd7\\xf7", Ot = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Tt = "\\u2000-\\u206f", le = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", oe = "A-Z\\xc0-\\xd6\\xd8-\\xde", te = "\\ufe0e\\ufe0f", ve = Ht + Ot + Tt + le, he = "['’]", Ve = "[" + Z + "]", He = "[" + ve + "]", ui = "[" + Mt + "]", Be = "\\d+", ye = "[" + st + "]", ke = "[" + Pt + "]", ce = "[^" + Z + ve + Be + st + Pt + oe + "]", di = "\\ud83c[\\udffb-\\udfff]", Pe = "(?:" + ui + "|" + di + ")", _e = "[^" + Z + "]", Le = "(?:\\ud83c[\\udde6-\\uddff]){2}", mn = "[\\ud800-\\udbff][\\udc00-\\udfff]", On = "[" + oe + "]", Ii = "\\u200d", Oi = "(?:" + ke + "|" + ce + ")", Ui = "(?:" + On + "|" + ce + ")", $i = "(?:" + he + "(?:d|ll|m|re|s|t|ve))?", Ki = "(?:" + he + "(?:D|LL|M|RE|S|T|VE))?", nn = Pe + "?", rn = "[" + te + "]?", ki = "(?:" + Ii + "(?:" + [_e, Le, mn].join("|") + ")" + rn + nn + ")*", Di = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Hi = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", mi = rn + nn + ki, zr = "(?:" + [ye, Le, mn].join("|") + ")" + mi, Cn = "(?:" + [_e + ui + "?", ui, Le, mn, Ve].join("|") + ")", ps = RegExp(he, "g"), tl = RegExp(ui, "g"), fo = RegExp(di + "(?=" + di + ")|" + Cn + mi, "g"), Vs = RegExp([
      On + "?" + ke + "+" + $i + "(?=" + [He, On, "$"].join("|") + ")",
      Ui + "+" + Ki + "(?=" + [He, On + Oi, "$"].join("|") + ")",
      On + "?" + Oi + "+" + $i,
      On + "+" + Ki,
      Hi,
      Di,
      Be,
      zr
    ].join("|"), "g"), Xs = RegExp("[" + Ii + Z + Mt + te + "]"), ds = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, qs = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], ms = -1, Wi = {};
    Wi[Vt] = Wi[Ne] = Wi[Re] = Wi[de] = Wi[we] = Wi[vi] = Wi[Mi] = Wi[ni] = Wi[Si] = !0, Wi[Zt] = Wi[ti] = Wi[Gt] = Wi[Ie] = Wi[Xt] = Wi[Ge] = Wi[Li] = Wi[an] = Wi[R] = Wi[Jt] = Wi[ct] = Wi[ie] = Wi[Kt] = Wi[w] = Wi[tt] = !1;
    var _i = {};
    _i[Zt] = _i[ti] = _i[Gt] = _i[Xt] = _i[Ie] = _i[Ge] = _i[Vt] = _i[Ne] = _i[Re] = _i[de] = _i[we] = _i[R] = _i[Jt] = _i[ct] = _i[ie] = _i[Kt] = _i[w] = _i[X] = _i[vi] = _i[Mi] = _i[ni] = _i[Si] = !0, _i[Li] = _i[an] = _i[tt] = !1;
    var Ys = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, gs = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Zs = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Oo = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Js = parseFloat, vs = parseInt, ys = typeof xr == "object" && xr && xr.Object === Object && xr, _s = typeof self == "object" && self && self.Object === Object && self, ln = ys || _s || Function("return this")(), po = J && !J.nodeType && J, Mr = po && !0 && T && !T.nodeType && T, Do = Mr && Mr.exports === po, zo = Do && ys.process, Pn = function() {
      try {
        var At = Mr && Mr.require && Mr.require("util").types;
        return At || zo && zo.binding && zo.binding("util");
      } catch {
      }
    }(), el = Pn && Pn.isArrayBuffer, xs = Pn && Pn.isDate, ws = Pn && Pn.isMap, bl = Pn && Pn.isRegExp, Al = Pn && Pn.isSet, Ca = Pn && Pn.isTypedArray;
    function er(At, Qt, Yt) {
      switch (Yt.length) {
        case 0:
          return At.call(Qt);
        case 1:
          return At.call(Qt, Yt[0]);
        case 2:
          return At.call(Qt, Yt[0], Yt[1]);
        case 3:
          return At.call(Qt, Yt[0], Yt[1], Yt[2]);
      }
      return At.apply(Qt, Yt);
    }
    function Pa(At, Qt, Yt, Ue) {
      for (var si = -1, zi = At == null ? 0 : At.length; ++si < zi; ) {
        var on = At[si];
        Qt(Ue, on, Yt(on), At);
      }
      return Ue;
    }
    function qi(At, Qt) {
      for (var Yt = -1, Ue = At == null ? 0 : At.length; ++Yt < Ue && Qt(At[Yt], Yt, At) !== !1; )
        ;
      return At;
    }
    function Bo(At, Qt) {
      for (var Yt = At == null ? 0 : At.length; Yt-- && Qt(At[Yt], Yt, At) !== !1; )
        ;
      return At;
    }
    function il(At, Qt) {
      for (var Yt = -1, Ue = At == null ? 0 : At.length; ++Yt < Ue; )
        if (!Qt(At[Yt], Yt, At))
          return !1;
      return !0;
    }
    function hr(At, Qt) {
      for (var Yt = -1, Ue = At == null ? 0 : At.length, si = 0, zi = []; ++Yt < Ue; ) {
        var on = At[Yt];
        Qt(on, Yt, At) && (zi[si++] = on);
      }
      return zi;
    }
    function $s(At, Qt) {
      var Yt = At == null ? 0 : At.length;
      return !!Yt && ur(At, Qt, 0) > -1;
    }
    function La(At, Qt, Yt) {
      for (var Ue = -1, si = At == null ? 0 : At.length; ++Ue < si; )
        if (Yt(Qt, At[Ue]))
          return !0;
      return !1;
    }
    function Vi(At, Qt) {
      for (var Yt = -1, Ue = At == null ? 0 : At.length, si = Array(Ue); ++Yt < Ue; )
        si[Yt] = Qt(At[Yt], Yt, At);
      return si;
    }
    function Br(At, Qt) {
      for (var Yt = -1, Ue = Qt.length, si = At.length; ++Yt < Ue; )
        At[si + Yt] = Qt[Yt];
      return At;
    }
    function Ra(At, Qt, Yt, Ue) {
      var si = -1, zi = At == null ? 0 : At.length;
      for (Ue && zi && (Yt = At[++si]); ++si < zi; )
        Yt = Qt(Yt, At[si], si, At);
      return Yt;
    }
    function Cl(At, Qt, Yt, Ue) {
      var si = At == null ? 0 : At.length;
      for (Ue && si && (Yt = At[--si]); si--; )
        Yt = Qt(Yt, At[si], si, At);
      return Yt;
    }
    function Kr(At, Qt) {
      for (var Yt = -1, Ue = At == null ? 0 : At.length; ++Yt < Ue; )
        if (Qt(At[Yt], Yt, At))
          return !0;
      return !1;
    }
    var Nr = go("length");
    function Pl(At) {
      return At.split("");
    }
    function Ks(At) {
      return At.match(js) || [];
    }
    function No(At, Qt, Yt) {
      var Ue;
      return Yt(At, function(si, zi, on) {
        if (Qt(si, zi, on))
          return Ue = zi, !1;
      }), Ue;
    }
    function mo(At, Qt, Yt, Ue) {
      for (var si = At.length, zi = Yt + (Ue ? 1 : -1); Ue ? zi-- : ++zi < si; )
        if (Qt(At[zi], zi, At))
          return zi;
      return -1;
    }
    function ur(At, Qt, Yt) {
      return Qt === Qt ? Ia(At, Qt, Yt) : mo(At, ko, Yt);
    }
    function Qs(At, Qt, Yt, Ue) {
      for (var si = Yt - 1, zi = At.length; ++si < zi; )
        if (Ue(At[si], Qt))
          return si;
      return -1;
    }
    function ko(At) {
      return At !== At;
    }
    function Ts(At, Qt) {
      var Yt = At == null ? 0 : At.length;
      return Yt ? yo(At, Qt) / Yt : Ft;
    }
    function go(At) {
      return function(Qt) {
        return Qt == null ? p : Qt[At];
      };
    }
    function Qr(At) {
      return function(Qt) {
        return At == null ? p : At[Qt];
      };
    }
    function vo(At, Qt, Yt, Ue, si) {
      return si(At, function(zi, on, Ee) {
        Yt = Ue ? (Ue = !1, zi) : Qt(Yt, zi, on, Ee);
      }), Yt;
    }
    function Ll(At, Qt) {
      var Yt = At.length;
      for (At.sort(Qt); Yt--; )
        At[Yt] = At[Yt].value;
      return At;
    }
    function yo(At, Qt) {
      for (var Yt, Ue = -1, si = At.length; ++Ue < si; ) {
        var zi = Qt(At[Ue]);
        zi !== p && (Yt = Yt === p ? zi : Yt + zi);
      }
      return Yt;
    }
    function to(At, Qt) {
      for (var Yt = -1, Ue = Array(At); ++Yt < At; )
        Ue[Yt] = Qt(Yt);
      return Ue;
    }
    function eo(At, Qt) {
      return Vi(Qt, function(Yt) {
        return [Yt, At[Yt]];
      });
    }
    function Ms(At) {
      return At && At.slice(0, Ss(At) + 1).replace(Ir, "");
    }
    function Ln(At) {
      return function(Qt) {
        return At(Qt);
      };
    }
    function Uo(At, Qt) {
      return Vi(Qt, function(Yt) {
        return At[Yt];
      });
    }
    function kr(At, Qt) {
      return At.has(Qt);
    }
    function _o(At, Qt) {
      for (var Yt = -1, Ue = At.length; ++Yt < Ue && ur(Qt, At[Yt], 0) > -1; )
        ;
      return Yt;
    }
    function Fo(At, Qt) {
      for (var Yt = At.length; Yt-- && ur(Qt, At[Yt], 0) > -1; )
        ;
      return Yt;
    }
    function Ur(At, Qt) {
      for (var Yt = At.length, Ue = 0; Yt--; )
        At[Yt] === Qt && ++Ue;
      return Ue;
    }
    var Go = Qr(Ys), Sr = Qr(gs);
    function Ho(At) {
      return "\\" + Oo[At];
    }
    function Wo(At, Qt) {
      return At == null ? p : At[Qt];
    }
    function cr(At) {
      return Xs.test(At);
    }
    function jo(At) {
      return ds.test(At);
    }
    function Vo(At) {
      for (var Qt, Yt = []; !(Qt = At.next()).done; )
        Yt.push(Qt.value);
      return Yt;
    }
    function kn(At) {
      var Qt = -1, Yt = Array(At.size);
      return At.forEach(function(Ue, si) {
        Yt[++Qt] = [si, Ue];
      }), Yt;
    }
    function ta(At, Qt) {
      return function(Yt) {
        return At(Qt(Yt));
      };
    }
    function fr(At, Qt) {
      for (var Yt = -1, Ue = At.length, si = 0, zi = []; ++Yt < Ue; ) {
        var on = At[Yt];
        (on === Qt || on === Y) && (At[Yt] = Y, zi[si++] = Yt);
      }
      return zi;
    }
    function Xo(At) {
      var Qt = -1, Yt = Array(At.size);
      return At.forEach(function(Ue) {
        Yt[++Qt] = Ue;
      }), Yt;
    }
    function Rn(At) {
      var Qt = -1, Yt = Array(At.size);
      return At.forEach(function(Ue) {
        Yt[++Qt] = [Ue, Ue];
      }), Yt;
    }
    function Ia(At, Qt, Yt) {
      for (var Ue = Yt - 1, si = At.length; ++Ue < si; )
        if (At[Ue] === Qt)
          return Ue;
      return -1;
    }
    function Oa(At, Qt, Yt) {
      for (var Ue = Yt + 1; Ue--; )
        if (At[Ue] === Qt)
          return Ue;
      return Ue;
    }
    function Er(At) {
      return cr(At) ? Es(At) : Nr(At);
    }
    function Vn(At) {
      return cr(At) ? ir(At) : Pl(At);
    }
    function Ss(At) {
      for (var Qt = At.length; Qt-- && $a.test(At.charAt(Qt)); )
        ;
      return Qt;
    }
    var Da = Qr(Zs);
    function Es(At) {
      for (var Qt = fo.lastIndex = 0; fo.test(At); )
        ++Qt;
      return Qt;
    }
    function ir(At) {
      return At.match(fo) || [];
    }
    function lh(At) {
      return At.match(Vs) || [];
    }
    var hh = function At(Qt) {
      Qt = Qt == null ? ln : xo.defaults(ln.Object(), Qt, xo.pick(ln, qs));
      var Yt = Qt.Array, Ue = Qt.Date, si = Qt.Error, zi = Qt.Function, on = Qt.Math, Ee = Qt.Object, Un = Qt.RegExp, bs = Qt.String, Xn = Qt.TypeError, Tn = Yt.prototype, Rl = zi.prototype, Fr = Ee.prototype, wo = Qt["__core-js_shared__"], qn = Rl.toString, wi = Fr.hasOwnProperty, Yn = 0, pr = function() {
        var r = /[^.]+$/.exec(wo && wo.keys && wo.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : "";
      }(), Zn = Fr.toString, Gr = qn.call(Ee), br = ln._, io = Un(
        "^" + qn.call(wi).replace(Hs, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Jn = Do ? Qt.Buffer : p, Fn = Qt.Symbol, Ji = Qt.Uint8Array, ea = Jn ? Jn.allocUnsafe : p, Hr = ta(Ee.getPrototypeOf, Ee), ia = Ee.create, na = Fr.propertyIsEnumerable, qo = Tn.splice, As = Fn ? Fn.isConcatSpreadable : p, To = Fn ? Fn.iterator : p, Wr = Fn ? Fn.toStringTag : p, Yo = function() {
        try {
          var r = xa(Ee, "defineProperty");
          return r({}, "", {}), r;
        } catch {
        }
      }(), za = Qt.clearTimeout !== ln.clearTimeout && Qt.clearTimeout, Ba = Ue && Ue.now !== ln.Date.now && Ue.now, nl = Qt.setTimeout !== ln.setTimeout && Qt.setTimeout, no = on.ceil, Zo = on.floor, ra = Ee.getOwnPropertySymbols, rl = Jn ? Jn.isBuffer : p, Na = Qt.isFinite, ol = Tn.join, Il = ta(Ee.keys, Ee), hn = on.max, In = on.min, oa = Ue.now, sl = Qt.parseInt, ka = on.random, Cs = Tn.reverse, sa = xa(Qt, "DataView"), Jo = xa(Qt, "Map"), aa = xa(Qt, "Promise"), $o = xa(Qt, "Set"), gn = xa(Qt, "WeakMap"), Ps = xa(Ee, "create"), la = gn && new gn(), Mo = {}, Ua = wa(sa), al = wa(Jo), ll = wa(aa), hl = wa($o), Ol = wa(gn), ha = Fn ? Fn.prototype : p, Ko = ha ? ha.valueOf : p, ul = ha ? ha.toString : p;
      function Q(r) {
        if (wn(r) && !gi(r) && !(r instanceof yi)) {
          if (r instanceof Dn)
            return r;
          if (wi.call(r, "__wrapped__"))
            return ru(r);
        }
        return new Dn(r);
      }
      var So = function() {
        function r() {
        }
        return function(a) {
          if (!pn(a))
            return {};
          if (ia)
            return ia(a);
          r.prototype = a;
          var u = new r();
          return r.prototype = p, u;
        };
      }();
      function Ls() {
      }
      function Dn(r, a) {
        this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!a, this.__index__ = 0, this.__values__ = p;
      }
      Q.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Ma,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: dn,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ls,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: Q
        }
      }, Q.prototype = Ls.prototype, Q.prototype.constructor = Q, Dn.prototype = So(Ls.prototype), Dn.prototype.constructor = Dn;
      function yi(r) {
        this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Dt, this.__views__ = [];
      }
      function Rs() {
        var r = new yi(this.__wrapped__);
        return r.__actions__ = Hn(this.__actions__), r.__dir__ = this.__dir__, r.__filtered__ = this.__filtered__, r.__iteratees__ = Hn(this.__iteratees__), r.__takeCount__ = this.__takeCount__, r.__views__ = Hn(this.__views__), r;
      }
      function Dl() {
        if (this.__filtered__) {
          var r = new yi(this);
          r.__dir__ = -1, r.__filtered__ = !0;
        } else
          r = this.clone(), r.__dir__ *= -1;
        return r;
      }
      function Is() {
        var r = this.__wrapped__.value(), a = this.__dir__, u = gi(r), _ = a < 0, k = u ? r.length : 0, at = Zu(0, k, this.__views__), yt = at.start, St = at.end, Nt = St - yt, re = _ ? St : yt - 1, ae = this.__iteratees__, fe = ae.length, ze = 0, Je = In(Nt, this.__takeCount__);
        if (!u || !_ && k == Nt && Je == Nt)
          return ri(r, this.__actions__);
        var li = [];
        t:
          for (; Nt-- && ze < Je; ) {
            re += a;
            for (var Ti = -1, hi = r[re]; ++Ti < fe; ) {
              var Ci = ae[Ti], Bi = Ci.iteratee, Pr = Ci.type, ar = Bi(hi);
              if (Pr == Bt)
                hi = ar;
              else if (!ar) {
                if (Pr == D)
                  continue t;
                break t;
              }
            }
            li[ze++] = hi;
          }
        return li;
      }
      yi.prototype = So(Ls.prototype), yi.prototype.constructor = yi;
      function dr(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.clear(); ++a < u; ) {
          var _ = r[a];
          this.set(_[0], _[1]);
        }
      }
      function Os() {
        this.__data__ = Ps ? Ps(null) : {}, this.size = 0;
      }
      function Ds(r) {
        var a = this.has(r) && delete this.__data__[r];
        return this.size -= a ? 1 : 0, a;
      }
      function ua(r) {
        var a = this.__data__;
        if (Ps) {
          var u = a[r];
          return u === E ? p : u;
        }
        return wi.call(a, r) ? a[r] : p;
      }
      function Fa(r) {
        var a = this.__data__;
        return Ps ? a[r] !== p : wi.call(a, r);
      }
      function ca(r, a) {
        var u = this.__data__;
        return this.size += this.has(r) ? 0 : 1, u[r] = Ps && a === p ? E : a, this;
      }
      dr.prototype.clear = Os, dr.prototype.delete = Ds, dr.prototype.get = ua, dr.prototype.has = Fa, dr.prototype.set = ca;
      function $n(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.clear(); ++a < u; ) {
          var _ = r[a];
          this.set(_[0], _[1]);
        }
      }
      function fa() {
        this.__data__ = [], this.size = 0;
      }
      function ro(r) {
        var a = this.__data__, u = ma(a, r);
        if (u < 0)
          return !1;
        var _ = a.length - 1;
        return u == _ ? a.pop() : qo.call(a, u, 1), --this.size, !0;
      }
      function pa(r) {
        var a = this.__data__, u = ma(a, r);
        return u < 0 ? p : a[u][1];
      }
      function da(r) {
        return ma(this.__data__, r) > -1;
      }
      function oo(r, a) {
        var u = this.__data__, _ = ma(u, r);
        return _ < 0 ? (++this.size, u.push([r, a])) : u[_][1] = a, this;
      }
      $n.prototype.clear = fa, $n.prototype.delete = ro, $n.prototype.get = pa, $n.prototype.has = da, $n.prototype.set = oo;
      function nr(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.clear(); ++a < u; ) {
          var _ = r[a];
          this.set(_[0], _[1]);
        }
      }
      function zl() {
        this.size = 0, this.__data__ = {
          hash: new dr(),
          map: new (Jo || $n)(),
          string: new dr()
        };
      }
      function Bl(r) {
        var a = Xl(this, r).delete(r);
        return this.size -= a ? 1 : 0, a;
      }
      function cl(r) {
        return Xl(this, r).get(r);
      }
      function fi(r) {
        return Xl(this, r).has(r);
      }
      function Eo(r, a) {
        var u = Xl(this, r), _ = u.size;
        return u.set(r, a), this.size += u.size == _ ? 0 : 1, this;
      }
      nr.prototype.clear = zl, nr.prototype.delete = Bl, nr.prototype.get = cl, nr.prototype.has = fi, nr.prototype.set = Eo;
      function Qo(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.__data__ = new nr(); ++a < u; )
          this.add(r[a]);
      }
      function Ei(r) {
        return this.__data__.set(r, E), this;
      }
      function bn(r) {
        return this.__data__.has(r);
      }
      Qo.prototype.add = Qo.prototype.push = Ei, Qo.prototype.has = bn;
      function Ar(r) {
        var a = this.__data__ = new $n(r);
        this.size = a.size;
      }
      function qe() {
        this.__data__ = new $n(), this.size = 0;
      }
      function jr(r) {
        var a = this.__data__, u = a.delete(r);
        return this.size = a.size, u;
      }
      function uh(r) {
        return this.__data__.get(r);
      }
      function ch(r) {
        return this.__data__.has(r);
      }
      function fh(r, a) {
        var u = this.__data__;
        if (u instanceof $n) {
          var _ = u.__data__;
          if (!Jo || _.length < G - 1)
            return _.push([r, a]), this.size = ++u.size, this;
          u = this.__data__ = new nr(_);
        }
        return u.set(r, a), this.size = u.size, this;
      }
      Ar.prototype.clear = qe, Ar.prototype.delete = jr, Ar.prototype.get = uh, Ar.prototype.has = ch, Ar.prototype.set = fh;
      function Nl(r, a) {
        var u = gi(r), _ = !u && Ta(r), k = !u && !_ && Gs(r), at = !u && !_ && !k && Za(r), yt = u || _ || k || at, St = yt ? to(r.length, bs) : [], Nt = St.length;
        for (var re in r)
          (a || wi.call(r, re)) && !(yt && // Safari 9 has enumerable `arguments.length` in strict mode.
          (re == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          k && (re == "offset" || re == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          at && (re == "buffer" || re == "byteLength" || re == "byteOffset") || // Skip index properties.
          rs(re, Nt))) && St.push(re);
        return St;
      }
      function fl(r) {
        var a = r.length;
        return a ? r[pe(0, a - 1)] : p;
      }
      function ph(r, a) {
        return ql(Hn(r), bo(a, 0, r.length));
      }
      function kl(r) {
        return ql(Hn(r));
      }
      function Ga(r, a, u) {
        (u !== p && !ho(r[a], u) || u === p && !(a in r)) && so(r, a, u);
      }
      function zs(r, a, u) {
        var _ = r[a];
        (!(wi.call(r, a) && ho(_, u)) || u === p && !(a in r)) && so(r, a, u);
      }
      function ma(r, a) {
        for (var u = r.length; u--; )
          if (ho(r[u][0], a))
            return u;
        return -1;
      }
      function Ul(r, a, u, _) {
        return un(r, function(k, at, yt) {
          a(_, k, u(k), yt);
        }), _;
      }
      function pl(r, a) {
        return r && Mn(a, Nn(a), r);
      }
      function dl(r, a) {
        return r && Mn(a, yr(a), r);
      }
      function so(r, a, u) {
        a == "__proto__" && Yo ? Yo(r, a, {
          configurable: !0,
          enumerable: !0,
          value: u,
          writable: !0
        }) : r[a] = u;
      }
      function ml(r, a) {
        for (var u = -1, _ = a.length, k = Yt(_), at = r == null; ++u < _; )
          k[u] = at ? p : Ph(r, a[u]);
        return k;
      }
      function bo(r, a, u) {
        return r === r && (u !== p && (r = r <= u ? r : u), a !== p && (r = r >= a ? r : a)), r;
      }
      function rr(r, a, u, _, k, at) {
        var yt, St = a & H, Nt = a & K, re = a & B;
        if (u && (yt = k ? u(r, _, k, at) : u(r)), yt !== p)
          return yt;
        if (!pn(r))
          return r;
        var ae = gi(r);
        if (ae) {
          if (yt = $u(r), !St)
            return Hn(r, yt);
        } else {
          var fe = Qn(r), ze = fe == an || fe == Zi;
          if (Gs(r))
            return ao(r, St);
          if (fe == ct || fe == Zt || ze && !k) {
            if (yt = Nt || ze ? {} : Zh(r), !St)
              return Nt ? Wl(r, dl(yt, r)) : qr(r, pl(yt, r));
          } else {
            if (!_i[fe])
              return k ? r : {};
            yt = Ku(r, fe, St);
          }
        }
        at || (at = new Ar());
        var Je = at.get(r);
        if (Je)
          return Je;
        at.set(r, yt), Su(r) ? r.forEach(function(hi) {
          yt.add(rr(hi, a, u, hi, r, at));
        }) : Tu(r) && r.forEach(function(hi, Ci) {
          yt.set(Ci, rr(hi, a, u, Ci, r, at));
        });
        var li = re ? Nt ? mh : dh : Nt ? yr : Nn, Ti = ae ? p : li(r);
        return qi(Ti || r, function(hi, Ci) {
          Ti && (Ci = hi, hi = r[Ci]), zs(yt, Ci, rr(hi, a, u, Ci, r, at));
        }), yt;
      }
      function Bs(r) {
        var a = Nn(r);
        return function(u) {
          return Fl(u, r, a);
        };
      }
      function Fl(r, a, u) {
        var _ = u.length;
        if (r == null)
          return !_;
        for (r = Ee(r); _--; ) {
          var k = u[_], at = a[k], yt = r[k];
          if (yt === p && !(k in r) || !at(yt))
            return !1;
        }
        return !0;
      }
      function Vr(r, a, u) {
        if (typeof r != "function")
          throw new Xn(C);
        return Ml(function() {
          r.apply(p, u);
        }, a);
      }
      function ga(r, a, u, _) {
        var k = -1, at = $s, yt = !0, St = r.length, Nt = [], re = a.length;
        if (!St)
          return Nt;
        u && (a = Vi(a, Ln(u))), _ ? (at = La, yt = !1) : a.length >= G && (at = kr, yt = !1, a = new Qo(a));
        t:
          for (; ++k < St; ) {
            var ae = r[k], fe = u == null ? ae : u(ae);
            if (ae = _ || ae !== 0 ? ae : 0, yt && fe === fe) {
              for (var ze = re; ze--; )
                if (a[ze] === fe)
                  continue t;
              Nt.push(ae);
            } else
              at(a, fe, _) || Nt.push(ae);
          }
        return Nt;
      }
      var un = ut(gr), Gl = ut(Wa, !0);
      function zn(r, a) {
        var u = !0;
        return un(r, function(_, k, at) {
          return u = !!a(_, k, at), u;
        }), u;
      }
      function Xr(r, a, u) {
        for (var _ = -1, k = r.length; ++_ < k; ) {
          var at = r[_], yt = a(at);
          if (yt != null && (St === p ? yt === yt && !Cr(yt) : u(yt, St)))
            var St = yt, Nt = at;
        }
        return Nt;
      }
      function Gn(r, a, u, _) {
        var k = r.length;
        for (u = xi(u), u < 0 && (u = -u > k ? 0 : k + u), _ = _ === p || _ > k ? k : xi(_), _ < 0 && (_ += k), _ = u > _ ? 0 : bu(_); u < _; )
          r[u++] = a;
        return r;
      }
      function mr(r, a) {
        var u = [];
        return un(r, function(_, k, at) {
          a(_, k, at) && u.push(_);
        }), u;
      }
      function vn(r, a, u, _, k) {
        var at = -1, yt = r.length;
        for (u || (u = tc), k || (k = []); ++at < yt; ) {
          var St = r[at];
          a > 0 && u(St) ? a > 1 ? vn(St, a - 1, u, _, k) : Br(k, St) : _ || (k[k.length] = St);
        }
        return k;
      }
      var va = wt(), Ha = wt(!0);
      function gr(r, a) {
        return r && va(r, a, Nn);
      }
      function Wa(r, a) {
        return r && Ha(r, a, Nn);
      }
      function ts(r, a) {
        return hr(a, function(u) {
          return os(r[u]);
        });
      }
      function Ao(r, a) {
        a = Ze(a, r);
        for (var u = 0, _ = a.length; r != null && u < _; )
          r = r[Po(a[u++])];
        return u && u == _ ? r : p;
      }
      function Hl(r, a, u) {
        var _ = a(r);
        return gi(r) ? _ : Br(_, u(r));
      }
      function Bn(r) {
        return r == null ? r === p ? nt : jt : Wr && Wr in Ee(r) ? Yu(r) : ac(r);
      }
      function ja(r, a) {
        return r > a;
      }
      function Va(r, a) {
        return r != null && wi.call(r, a);
      }
      function gl(r, a) {
        return r != null && a in Ee(r);
      }
      function Xa(r, a, u) {
        return r >= In(a, u) && r < hn(a, u);
      }
      function ya(r, a, u) {
        for (var _ = u ? La : $s, k = r[0].length, at = r.length, yt = at, St = Yt(at), Nt = 1 / 0, re = []; yt--; ) {
          var ae = r[yt];
          yt && a && (ae = Vi(ae, Ln(a))), Nt = In(ae.length, Nt), St[yt] = !u && (a || k >= 120 && ae.length >= 120) ? new Qo(yt && ae) : p;
        }
        ae = r[0];
        var fe = -1, ze = St[0];
        t:
          for (; ++fe < k && re.length < Nt; ) {
            var Je = ae[fe], li = a ? a(Je) : Je;
            if (Je = u || Je !== 0 ? Je : 0, !(ze ? kr(ze, li) : _(re, li, u))) {
              for (yt = at; --yt; ) {
                var Ti = St[yt];
                if (!(Ti ? kr(Ti, li) : _(r[yt], li, u)))
                  continue t;
              }
              ze && ze.push(li), re.push(Je);
            }
          }
        return re;
      }
      function t(r, a, u, _) {
        return gr(r, function(k, at, yt) {
          a(_, u(k), at, yt);
        }), _;
      }
      function e(r, a, u) {
        a = Ze(a, r), r = Qh(r, a);
        var _ = r == null ? r : r[Po(Zr(a))];
        return _ == null ? p : er(_, r, u);
      }
      function i(r) {
        return wn(r) && Bn(r) == Zt;
      }
      function n(r) {
        return wn(r) && Bn(r) == Gt;
      }
      function o(r) {
        return wn(r) && Bn(r) == Ge;
      }
      function s(r, a, u, _, k) {
        return r === a ? !0 : r == null || a == null || !wn(r) && !wn(a) ? r !== r && a !== a : l(r, a, u, _, s, k);
      }
      function l(r, a, u, _, k, at) {
        var yt = gi(r), St = gi(a), Nt = yt ? ti : Qn(r), re = St ? ti : Qn(a);
        Nt = Nt == Zt ? ct : Nt, re = re == Zt ? ct : re;
        var ae = Nt == ct, fe = re == ct, ze = Nt == re;
        if (ze && Gs(r)) {
          if (!Gs(a))
            return !1;
          yt = !0, ae = !1;
        }
        if (ze && !ae)
          return at || (at = new Ar()), yt || Za(r) ? Xh(r, a, u, _, k, at) : Xu(r, a, Nt, u, _, k, at);
        if (!(u & q)) {
          var Je = ae && wi.call(r, "__wrapped__"), li = fe && wi.call(a, "__wrapped__");
          if (Je || li) {
            var Ti = Je ? r.value() : r, hi = li ? a.value() : a;
            return at || (at = new Ar()), k(Ti, hi, u, _, at);
          }
        }
        return ze ? (at || (at = new Ar()), qu(r, a, u, _, k, at)) : !1;
      }
      function h(r) {
        return wn(r) && Qn(r) == R;
      }
      function c(r, a, u, _) {
        var k = u.length, at = k, yt = !_;
        if (r == null)
          return !at;
        for (r = Ee(r); k--; ) {
          var St = u[k];
          if (yt && St[2] ? St[1] !== r[St[0]] : !(St[0] in r))
            return !1;
        }
        for (; ++k < at; ) {
          St = u[k];
          var Nt = St[0], re = r[Nt], ae = St[1];
          if (yt && St[2]) {
            if (re === p && !(Nt in r))
              return !1;
          } else {
            var fe = new Ar();
            if (_)
              var ze = _(re, ae, Nt, r, a, fe);
            if (!(ze === p ? s(ae, re, q | b, _, fe) : ze))
              return !1;
          }
        }
        return !0;
      }
      function f(r) {
        if (!pn(r) || ic(r))
          return !1;
        var a = os(r) ? io : Ro;
        return a.test(wa(r));
      }
      function v(r) {
        return wn(r) && Bn(r) == ie;
      }
      function y(r) {
        return wn(r) && Qn(r) == Kt;
      }
      function S(r) {
        return wn(r) && Ql(r.length) && !!Wi[Bn(r)];
      }
      function P(r) {
        return typeof r == "function" ? r : r == null ? _r : typeof r == "object" ? gi(r) ? bt(r[0], r[1]) : mt(r) : Nu(r);
      }
      function N(r) {
        if (!Tl(r))
          return Il(r);
        var a = [];
        for (var u in Ee(r))
          wi.call(r, u) && u != "constructor" && a.push(u);
        return a;
      }
      function j(r) {
        if (!pn(r))
          return sc(r);
        var a = Tl(r), u = [];
        for (var _ in r)
          _ == "constructor" && (a || !wi.call(r, _)) || u.push(_);
        return u;
      }
      function et(r, a) {
        return r < a;
      }
      function _t(r, a) {
        var u = -1, _ = vr(r) ? Yt(r.length) : [];
        return un(r, function(k, at, yt) {
          _[++u] = a(k, at, yt);
        }), _;
      }
      function mt(r) {
        var a = vh(r);
        return a.length == 1 && a[0][2] ? $h(a[0][0], a[0][1]) : function(u) {
          return u === r || c(u, r, a);
        };
      }
      function bt(r, a) {
        return _h(r) && Jh(a) ? $h(Po(r), a) : function(u) {
          var _ = Ph(u, r);
          return _ === p && _ === a ? Lh(u, r) : s(a, _, q | b);
        };
      }
      function xt(r, a, u, _, k) {
        r !== a && va(a, function(at, yt) {
          if (k || (k = new Ar()), pn(at))
            Wt(r, a, yt, u, xt, _, k);
          else {
            var St = _ ? _(wh(r, yt), at, yt + "", r, a, k) : p;
            St === p && (St = at), Ga(r, yt, St);
          }
        }, yr);
      }
      function Wt(r, a, u, _, k, at, yt) {
        var St = wh(r, u), Nt = wh(a, u), re = yt.get(Nt);
        if (re) {
          Ga(r, u, re);
          return;
        }
        var ae = at ? at(St, Nt, u + "", r, a, yt) : p, fe = ae === p;
        if (fe) {
          var ze = gi(Nt), Je = !ze && Gs(Nt), li = !ze && !Je && Za(Nt);
          ae = Nt, ze || Je || li ? gi(St) ? ae = St : Sn(St) ? ae = Hn(St) : Je ? (fe = !1, ae = ao(Nt, !0)) : li ? (fe = !1, ae = _a(Nt, !0)) : ae = [] : Sl(Nt) || Ta(Nt) ? (ae = St, Ta(St) ? ae = Au(St) : (!pn(St) || os(St)) && (ae = Zh(Nt))) : fe = !1;
        }
        fe && (yt.set(Nt, ae), k(ae, Nt, _, at, yt), yt.delete(Nt)), Ga(r, u, ae);
      }
      function W(r, a) {
        var u = r.length;
        if (u)
          return a += a < 0 ? u : 0, rs(a, u) ? r[a] : p;
      }
      function it(r, a, u) {
        a.length ? a = Vi(a, function(at) {
          return gi(at) ? function(yt) {
            return Ao(yt, at.length === 1 ? at[0] : at);
          } : at;
        }) : a = [_r];
        var _ = -1;
        a = Vi(a, Ln(oi()));
        var k = _t(r, function(at, yt, St) {
          var Nt = Vi(a, function(re) {
            return re(at);
          });
          return { criteria: Nt, index: ++_, value: at };
        });
        return Ll(k, function(at, yt) {
          return Co(at, yt, u);
        });
      }
      function It(r, a) {
        return ee(r, a, function(u, _) {
          return Lh(r, _);
        });
      }
      function ee(r, a, u) {
        for (var _ = -1, k = a.length, at = {}; ++_ < k; ) {
          var yt = a[_], St = Ao(r, yt);
          u(St, yt) && ci(at, Ze(yt, r), St);
        }
        return at;
      }
      function $t(r) {
        return function(a) {
          return Ao(a, r);
        };
      }
      function qt(r, a, u, _) {
        var k = _ ? Qs : ur, at = -1, yt = a.length, St = r;
        for (r === a && (a = Hn(a)), u && (St = Vi(r, Ln(u))); ++at < yt; )
          for (var Nt = 0, re = a[at], ae = u ? u(re) : re; (Nt = k(St, ae, Nt, _)) > -1; )
            St !== r && qo.call(St, Nt, 1), qo.call(r, Nt, 1);
        return r;
      }
      function Te(r, a) {
        for (var u = r ? a.length : 0, _ = u - 1; u--; ) {
          var k = a[u];
          if (u == _ || k !== at) {
            var at = k;
            rs(k) ? qo.call(r, k, 1) : Gi(r, k);
          }
        }
        return r;
      }
      function pe(r, a) {
        return r + Zo(ka() * (a - r + 1));
      }
      function Oe(r, a, u, _) {
        for (var k = -1, at = hn(no((a - r) / (u || 1)), 0), yt = Yt(at); at--; )
          yt[_ ? at : ++k] = r, r += u;
        return yt;
      }
      function be(r, a) {
        var u = "";
        if (!r || a < 1 || a > ge)
          return u;
        do
          a % 2 && (u += r), a = Zo(a / 2), a && (r += r);
        while (a);
        return u;
      }
      function se(r, a) {
        return Th(Kh(r, a, _r), r + "");
      }
      function je(r) {
        return fl(Ja(r));
      }
      function Ke(r, a) {
        var u = Ja(r);
        return ql(u, bo(a, 0, u.length));
      }
      function ci(r, a, u, _) {
        if (!pn(r))
          return r;
        a = Ze(a, r);
        for (var k = -1, at = a.length, yt = at - 1, St = r; St != null && ++k < at; ) {
          var Nt = Po(a[k]), re = u;
          if (Nt === "__proto__" || Nt === "constructor" || Nt === "prototype")
            return r;
          if (k != yt) {
            var ae = St[Nt];
            re = _ ? _(ae, Nt, St) : p, re === p && (re = pn(ae) ? ae : rs(a[k + 1]) ? [] : {});
          }
          zs(St, Nt, re), St = St[Nt];
        }
        return r;
      }
      var yn = la ? function(r, a) {
        return la.set(r, a), r;
      } : _r, cn = Yo ? function(r, a) {
        return Yo(r, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Ih(a),
          writable: !0
        });
      } : _r;
      function ji(r) {
        return ql(Ja(r));
      }
      function Fi(r, a, u) {
        var _ = -1, k = r.length;
        a < 0 && (a = -a > k ? 0 : k + a), u = u > k ? k : u, u < 0 && (u += k), k = a > u ? 0 : u - a >>> 0, a >>>= 0;
        for (var at = Yt(k); ++_ < k; )
          at[_] = r[_ + a];
        return at;
      }
      function Qi(r, a) {
        var u;
        return un(r, function(_, k, at) {
          return u = a(_, k, at), !u;
        }), !!u;
      }
      function _n(r, a, u) {
        var _ = 0, k = r == null ? _ : r.length;
        if (typeof a == "number" && a === a && k <= Fe) {
          for (; _ < k; ) {
            var at = _ + k >>> 1, yt = r[at];
            yt !== null && !Cr(yt) && (u ? yt <= a : yt < a) ? _ = at + 1 : k = at;
          }
          return k;
        }
        return Ae(r, a, _r, u);
      }
      function Ae(r, a, u, _) {
        var k = 0, at = r == null ? 0 : r.length;
        if (at === 0)
          return 0;
        a = u(a);
        for (var yt = a !== a, St = a === null, Nt = Cr(a), re = a === p; k < at; ) {
          var ae = Zo((k + at) / 2), fe = u(r[ae]), ze = fe !== p, Je = fe === null, li = fe === fe, Ti = Cr(fe);
          if (yt)
            var hi = _ || li;
          else
            re ? hi = li && (_ || ze) : St ? hi = li && ze && (_ || !Je) : Nt ? hi = li && ze && !Je && (_ || !Ti) : Je || Ti ? hi = !1 : hi = _ ? fe <= a : fe < a;
          hi ? k = ae + 1 : at = ae;
        }
        return In(at, kt);
      }
      function Qe(r, a) {
        for (var u = -1, _ = r.length, k = 0, at = []; ++u < _; ) {
          var yt = r[u], St = a ? a(yt) : yt;
          if (!u || !ho(St, Nt)) {
            var Nt = St;
            at[k++] = yt === 0 ? 0 : yt;
          }
        }
        return at;
      }
      function Ut(r) {
        return typeof r == "number" ? r : Cr(r) ? Ft : +r;
      }
      function Ye(r) {
        if (typeof r == "string")
          return r;
        if (gi(r))
          return Vi(r, Ye) + "";
        if (Cr(r))
          return ul ? ul.call(r) : "";
        var a = r + "";
        return a == "0" && 1 / r == -Rt ? "-0" : a;
      }
      function ei(r, a, u) {
        var _ = -1, k = $s, at = r.length, yt = !0, St = [], Nt = St;
        if (u)
          yt = !1, k = La;
        else if (at >= G) {
          var re = a ? null : Fs(r);
          if (re)
            return Xo(re);
          yt = !1, k = kr, Nt = new Qo();
        } else
          Nt = a ? [] : St;
        t:
          for (; ++_ < at; ) {
            var ae = r[_], fe = a ? a(ae) : ae;
            if (ae = u || ae !== 0 ? ae : 0, yt && fe === fe) {
              for (var ze = Nt.length; ze--; )
                if (Nt[ze] === fe)
                  continue t;
              a && Nt.push(fe), St.push(ae);
            } else
              k(Nt, fe, u) || (Nt !== St && Nt.push(fe), St.push(ae));
          }
        return St;
      }
      function Gi(r, a) {
        return a = Ze(a, r), r = Qh(r, a), r == null || delete r[Po(Zr(a))];
      }
      function Ce(r, a, u, _) {
        return ci(r, a, u(Ao(r, a)), _);
      }
      function Xe(r, a, u, _) {
        for (var k = r.length, at = _ ? k : -1; (_ ? at-- : ++at < k) && a(r[at], at, r); )
          ;
        return u ? Fi(r, _ ? 0 : at, _ ? at + 1 : k) : Fi(r, _ ? at + 1 : 0, _ ? k : at);
      }
      function ri(r, a) {
        var u = r;
        return u instanceof yi && (u = u.value()), Ra(a, function(_, k) {
          return k.func.apply(k.thisArg, Br([_], k.args));
        }, u);
      }
      function Ai(r, a, u) {
        var _ = r.length;
        if (_ < 2)
          return _ ? ei(r[0]) : [];
        for (var k = -1, at = Yt(_); ++k < _; )
          for (var yt = r[k], St = -1; ++St < _; )
            St != k && (at[k] = ga(at[k] || yt, r[St], a, u));
        return ei(vn(at, 1), a, u);
      }
      function bi(r, a, u) {
        for (var _ = -1, k = r.length, at = a.length, yt = {}; ++_ < k; ) {
          var St = _ < at ? a[_] : p;
          u(yt, r[_], St);
        }
        return yt;
      }
      function ne(r) {
        return Sn(r) ? r : [];
      }
      function ii(r) {
        return typeof r == "function" ? r : _r;
      }
      function Ze(r, a) {
        return gi(r) ? r : _h(r, a) ? [r] : nu(Xi(r));
      }
      var ai = se;
      function fn(r, a, u) {
        var _ = r.length;
        return u = u === p ? _ : u, !a && u >= _ ? r : Fi(r, a, u);
      }
      var xn = za || function(r) {
        return ln.clearTimeout(r);
      };
      function ao(r, a) {
        if (a)
          return r.slice();
        var u = r.length, _ = ea ? ea(u) : new r.constructor(u);
        return r.copy(_), _;
      }
      function Ns(r) {
        var a = new r.constructor(r.byteLength);
        return new Ji(a).set(new Ji(r)), a;
      }
      function vl(r, a) {
        var u = a ? Ns(r.buffer) : r.buffer;
        return new r.constructor(u, r.byteOffset, r.byteLength);
      }
      function ks(r) {
        var a = new r.constructor(r.source, Ea.exec(r));
        return a.lastIndex = r.lastIndex, a;
      }
      function es(r) {
        return Ko ? Ee(Ko.call(r)) : {};
      }
      function _a(r, a) {
        var u = a ? Ns(r.buffer) : r.buffer;
        return new r.constructor(u, r.byteOffset, r.length);
      }
      function is(r, a) {
        if (r !== a) {
          var u = r !== p, _ = r === null, k = r === r, at = Cr(r), yt = a !== p, St = a === null, Nt = a === a, re = Cr(a);
          if (!St && !re && !at && r > a || at && yt && Nt && !St && !re || _ && yt && Nt || !u && Nt || !k)
            return 1;
          if (!_ && !at && !re && r < a || re && u && k && !_ && !at || St && u && k || !yt && k || !Nt)
            return -1;
        }
        return 0;
      }
      function Co(r, a, u) {
        for (var _ = -1, k = r.criteria, at = a.criteria, yt = k.length, St = u.length; ++_ < yt; ) {
          var Nt = is(k[_], at[_]);
          if (Nt) {
            if (_ >= St)
              return Nt;
            var re = u[_];
            return Nt * (re == "desc" ? -1 : 1);
          }
        }
        return r.index - a.index;
      }
      function yl(r, a, u, _) {
        for (var k = -1, at = r.length, yt = u.length, St = -1, Nt = a.length, re = hn(at - yt, 0), ae = Yt(Nt + re), fe = !_; ++St < Nt; )
          ae[St] = a[St];
        for (; ++k < yt; )
          (fe || k < at) && (ae[u[k]] = r[k]);
        for (; re--; )
          ae[St++] = r[k++];
        return ae;
      }
      function _l(r, a, u, _) {
        for (var k = -1, at = r.length, yt = -1, St = u.length, Nt = -1, re = a.length, ae = hn(at - St, 0), fe = Yt(ae + re), ze = !_; ++k < ae; )
          fe[k] = r[k];
        for (var Je = k; ++Nt < re; )
          fe[Je + Nt] = a[Nt];
        for (; ++yt < St; )
          (ze || k < at) && (fe[Je + u[yt]] = r[k++]);
        return fe;
      }
      function Hn(r, a) {
        var u = -1, _ = r.length;
        for (a || (a = Yt(_)); ++u < _; )
          a[u] = r[u];
        return a;
      }
      function Mn(r, a, u, _) {
        var k = !u;
        u || (u = {});
        for (var at = -1, yt = a.length; ++at < yt; ) {
          var St = a[at], Nt = _ ? _(u[St], r[St], St, u, r) : p;
          Nt === p && (Nt = r[St]), k ? so(u, St, Nt) : zs(u, St, Nt);
        }
        return u;
      }
      function qr(r, a) {
        return Mn(r, yh(r), a);
      }
      function Wl(r, a) {
        return Mn(r, qh(r), a);
      }
      function Us(r, a) {
        return function(u, _) {
          var k = gi(u) ? Pa : Ul, at = a ? a() : {};
          return k(u, r, oi(_, 2), at);
        };
      }
      function lo(r) {
        return se(function(a, u) {
          var _ = -1, k = u.length, at = k > 1 ? u[k - 1] : p, yt = k > 2 ? u[2] : p;
          for (at = r.length > 3 && typeof at == "function" ? (k--, at) : p, yt && sr(u[0], u[1], yt) && (at = k < 3 ? p : at, k = 1), a = Ee(a); ++_ < k; ) {
            var St = u[_];
            St && r(a, St, _, at);
          }
          return a;
        });
      }
      function ut(r, a) {
        return function(u, _) {
          if (u == null)
            return u;
          if (!vr(u))
            return r(u, _);
          for (var k = u.length, at = a ? k : -1, yt = Ee(u); (a ? at-- : ++at < k) && _(yt[at], at, yt) !== !1; )
            ;
          return u;
        };
      }
      function wt(r) {
        return function(a, u, _) {
          for (var k = -1, at = Ee(a), yt = _(a), St = yt.length; St--; ) {
            var Nt = yt[r ? St : ++k];
            if (u(at[Nt], Nt, at) === !1)
              break;
          }
          return a;
        };
      }
      function dt(r, a, u) {
        var _ = a & A, k = We(r);
        function at() {
          var yt = this && this !== ln && this instanceof at ? k : r;
          return yt.apply(_ ? u : this, arguments);
        }
        return at;
      }
      function Me(r) {
        return function(a) {
          a = Xi(a);
          var u = cr(a) ? Vn(a) : p, _ = u ? u[0] : a.charAt(0), k = u ? fn(u, 1).join("") : a.slice(1);
          return _[r]() + k;
        };
      }
      function De(r) {
        return function(a) {
          return Ra(zu(Du(a).replace(ps, "")), r, "");
        };
      }
      function We(r) {
        return function() {
          var a = arguments;
          switch (a.length) {
            case 0:
              return new r();
            case 1:
              return new r(a[0]);
            case 2:
              return new r(a[0], a[1]);
            case 3:
              return new r(a[0], a[1], a[2]);
            case 4:
              return new r(a[0], a[1], a[2], a[3]);
            case 5:
              return new r(a[0], a[1], a[2], a[3], a[4]);
            case 6:
              return new r(a[0], a[1], a[2], a[3], a[4], a[5]);
            case 7:
              return new r(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
          }
          var u = So(r.prototype), _ = r.apply(u, a);
          return pn(_) ? _ : u;
        };
      }
      function Se(r, a, u) {
        var _ = We(r);
        function k() {
          for (var at = arguments.length, yt = Yt(at), St = at, Nt = Ya(k); St--; )
            yt[St] = arguments[St];
          var re = at < 3 && yt[0] !== Nt && yt[at - 1] !== Nt ? [] : fr(yt, Nt);
          if (at -= re.length, at < u)
            return wl(
              r,
              a,
              Yi,
              k.placeholder,
              p,
              yt,
              re,
              p,
              p,
              u - at
            );
          var ae = this && this !== ln && this instanceof k ? _ : r;
          return er(ae, this, yt);
        }
        return k;
      }
      function $e(r) {
        return function(a, u, _) {
          var k = Ee(a);
          if (!vr(a)) {
            var at = oi(u, 3);
            a = Nn(a), u = function(St) {
              return at(k[St], St, k);
            };
          }
          var yt = r(a, u, _);
          return yt > -1 ? k[at ? a[yt] : yt] : p;
        };
      }
      function Pi(r) {
        return ns(function(a) {
          var u = a.length, _ = u, k = Dn.prototype.thru;
          for (r && a.reverse(); _--; ) {
            var at = a[_];
            if (typeof at != "function")
              throw new Xn(C);
            if (k && !yt && Vl(at) == "wrapper")
              var yt = new Dn([], !0);
          }
          for (_ = yt ? _ : u; ++_ < u; ) {
            at = a[_];
            var St = Vl(at), Nt = St == "wrapper" ? gh(at) : p;
            Nt && xh(Nt[0]) && Nt[1] == (V | M | F | ht) && !Nt[4].length && Nt[9] == 1 ? yt = yt[Vl(Nt[0])].apply(yt, Nt[3]) : yt = at.length == 1 && xh(at) ? yt[St]() : yt.thru(at);
          }
          return function() {
            var re = arguments, ae = re[0];
            if (yt && re.length == 1 && gi(ae))
              return yt.plant(ae).value();
            for (var fe = 0, ze = u ? a[fe].apply(this, re) : ae; ++fe < u; )
              ze = a[fe].call(this, ze);
            return ze;
          };
        });
      }
      function Yi(r, a, u, _, k, at, yt, St, Nt, re) {
        var ae = a & V, fe = a & A, ze = a & d, Je = a & (M | x), li = a & ft, Ti = ze ? p : We(r);
        function hi() {
          for (var Ci = arguments.length, Bi = Yt(Ci), Pr = Ci; Pr--; )
            Bi[Pr] = arguments[Pr];
          if (Je)
            var ar = Ya(hi), Lr = Ur(Bi, ar);
          if (_ && (Bi = yl(Bi, _, k, Je)), at && (Bi = _l(Bi, at, yt, Je)), Ci -= Lr, Je && Ci < re) {
            var En = fr(Bi, ar);
            return wl(
              r,
              a,
              Yi,
              hi.placeholder,
              u,
              Bi,
              En,
              St,
              Nt,
              re - Ci
            );
          }
          var uo = fe ? u : this, as = ze ? uo[r] : r;
          return Ci = Bi.length, St ? Bi = lc(Bi, St) : li && Ci > 1 && Bi.reverse(), ae && Nt < Ci && (Bi.length = Nt), this && this !== ln && this instanceof hi && (as = Ti || We(as)), as.apply(uo, Bi);
        }
        return hi;
      }
      function me(r, a) {
        return function(u, _) {
          return t(u, r, a(_), {});
        };
      }
      function or(r, a) {
        return function(u, _) {
          var k;
          if (u === p && _ === p)
            return a;
          if (u !== p && (k = u), _ !== p) {
            if (k === p)
              return _;
            typeof u == "string" || typeof _ == "string" ? (u = Ye(u), _ = Ye(_)) : (u = Ut(u), _ = Ut(_)), k = r(u, _);
          }
          return k;
        };
      }
      function An(r) {
        return ns(function(a) {
          return a = Vi(a, Ln(oi())), se(function(u) {
            var _ = this;
            return r(a, function(k) {
              return er(k, _, u);
            });
          });
        });
      }
      function en(r, a) {
        a = a === p ? " " : Ye(a);
        var u = a.length;
        if (u < 2)
          return u ? be(a, r) : a;
        var _ = be(a, no(r / Er(a)));
        return cr(a) ? fn(Vn(_), 0, r).join("") : _.slice(0, r);
      }
      function Kn(r, a, u, _) {
        var k = a & A, at = We(r);
        function yt() {
          for (var St = -1, Nt = arguments.length, re = -1, ae = _.length, fe = Yt(ae + Nt), ze = this && this !== ln && this instanceof yt ? at : r; ++re < ae; )
            fe[re] = _[re];
          for (; Nt--; )
            fe[re++] = arguments[++St];
          return er(ze, k ? u : this, fe);
        }
        return yt;
      }
      function xl(r) {
        return function(a, u, _) {
          return _ && typeof _ != "number" && sr(a, u, _) && (u = _ = p), a = ss(a), u === p ? (u = a, a = 0) : u = ss(u), _ = _ === p ? a < u ? 1 : -1 : ss(_), Oe(a, u, _, r);
        };
      }
      function Yr(r) {
        return function(a, u) {
          return typeof a == "string" && typeof u == "string" || (a = Jr(a), u = Jr(u)), r(a, u);
        };
      }
      function wl(r, a, u, _, k, at, yt, St, Nt, re) {
        var ae = a & M, fe = ae ? yt : p, ze = ae ? p : yt, Je = ae ? at : p, li = ae ? p : at;
        a |= ae ? F : z, a &= ~(ae ? z : F), a & g || (a &= ~(A | d));
        var Ti = [
          r,
          a,
          k,
          Je,
          fe,
          li,
          ze,
          St,
          Nt,
          re
        ], hi = u.apply(p, Ti);
        return xh(r) && tu(hi, Ti), hi.placeholder = _, eu(hi, r, a);
      }
      function qa(r) {
        var a = on[r];
        return function(u, _) {
          if (u = Jr(u), _ = _ == null ? 0 : In(xi(_), 292), _ && Na(u)) {
            var k = (Xi(u) + "e").split("e"), at = a(k[0] + "e" + (+k[1] + _));
            return k = (Xi(at) + "e").split("e"), +(k[0] + "e" + (+k[1] - _));
          }
          return a(u);
        };
      }
      var Fs = $o && 1 / Xo(new $o([, -0]))[1] == Rt ? function(r) {
        return new $o(r);
      } : zh;
      function jl(r) {
        return function(a) {
          var u = Qn(a);
          return u == R ? kn(a) : u == Kt ? Rn(a) : eo(a, r(a));
        };
      }
      function Wn(r, a, u, _, k, at, yt, St) {
        var Nt = a & d;
        if (!Nt && typeof r != "function")
          throw new Xn(C);
        var re = _ ? _.length : 0;
        if (re || (a &= ~(F | z), _ = k = p), yt = yt === p ? yt : hn(xi(yt), 0), St = St === p ? St : xi(St), re -= k ? k.length : 0, a & z) {
          var ae = _, fe = k;
          _ = k = p;
        }
        var ze = Nt ? p : gh(r), Je = [
          r,
          a,
          u,
          _,
          k,
          ae,
          fe,
          at,
          yt,
          St
        ];
        if (ze && oc(Je, ze), r = Je[0], a = Je[1], u = Je[2], _ = Je[3], k = Je[4], St = Je[9] = Je[9] === p ? Nt ? 0 : r.length : hn(Je[9] - re, 0), !St && a & (M | x) && (a &= ~(M | x)), !a || a == A)
          var li = dt(r, a, u);
        else
          a == M || a == x ? li = Se(r, a, St) : (a == F || a == (A | F)) && !k.length ? li = Kn(r, a, u, _) : li = Yi.apply(p, Je);
        var Ti = ze ? yn : tu;
        return eu(Ti(li, Je), r, a);
      }
      function jh(r, a, u, _) {
        return r === p || ho(r, Fr[u]) && !wi.call(_, u) ? a : r;
      }
      function Vh(r, a, u, _, k, at) {
        return pn(r) && pn(a) && (at.set(a, r), xt(r, a, p, Vh, at), at.delete(a)), r;
      }
      function Vu(r) {
        return Sl(r) ? p : r;
      }
      function Xh(r, a, u, _, k, at) {
        var yt = u & q, St = r.length, Nt = a.length;
        if (St != Nt && !(yt && Nt > St))
          return !1;
        var re = at.get(r), ae = at.get(a);
        if (re && ae)
          return re == a && ae == r;
        var fe = -1, ze = !0, Je = u & b ? new Qo() : p;
        for (at.set(r, a), at.set(a, r); ++fe < St; ) {
          var li = r[fe], Ti = a[fe];
          if (_)
            var hi = yt ? _(Ti, li, fe, a, r, at) : _(li, Ti, fe, r, a, at);
          if (hi !== p) {
            if (hi)
              continue;
            ze = !1;
            break;
          }
          if (Je) {
            if (!Kr(a, function(Ci, Bi) {
              if (!kr(Je, Bi) && (li === Ci || k(li, Ci, u, _, at)))
                return Je.push(Bi);
            })) {
              ze = !1;
              break;
            }
          } else if (!(li === Ti || k(li, Ti, u, _, at))) {
            ze = !1;
            break;
          }
        }
        return at.delete(r), at.delete(a), ze;
      }
      function Xu(r, a, u, _, k, at, yt) {
        switch (u) {
          case Xt:
            if (r.byteLength != a.byteLength || r.byteOffset != a.byteOffset)
              return !1;
            r = r.buffer, a = a.buffer;
          case Gt:
            return !(r.byteLength != a.byteLength || !at(new Ji(r), new Ji(a)));
          case Ie:
          case Ge:
          case Jt:
            return ho(+r, +a);
          case Li:
            return r.name == a.name && r.message == a.message;
          case ie:
          case w:
            return r == a + "";
          case R:
            var St = kn;
          case Kt:
            var Nt = _ & q;
            if (St || (St = Xo), r.size != a.size && !Nt)
              return !1;
            var re = yt.get(r);
            if (re)
              return re == a;
            _ |= b, yt.set(r, a);
            var ae = Xh(St(r), St(a), _, k, at, yt);
            return yt.delete(r), ae;
          case X:
            if (Ko)
              return Ko.call(r) == Ko.call(a);
        }
        return !1;
      }
      function qu(r, a, u, _, k, at) {
        var yt = u & q, St = dh(r), Nt = St.length, re = dh(a), ae = re.length;
        if (Nt != ae && !yt)
          return !1;
        for (var fe = Nt; fe--; ) {
          var ze = St[fe];
          if (!(yt ? ze in a : wi.call(a, ze)))
            return !1;
        }
        var Je = at.get(r), li = at.get(a);
        if (Je && li)
          return Je == a && li == r;
        var Ti = !0;
        at.set(r, a), at.set(a, r);
        for (var hi = yt; ++fe < Nt; ) {
          ze = St[fe];
          var Ci = r[ze], Bi = a[ze];
          if (_)
            var Pr = yt ? _(Bi, Ci, ze, a, r, at) : _(Ci, Bi, ze, r, a, at);
          if (!(Pr === p ? Ci === Bi || k(Ci, Bi, u, _, at) : Pr)) {
            Ti = !1;
            break;
          }
          hi || (hi = ze == "constructor");
        }
        if (Ti && !hi) {
          var ar = r.constructor, Lr = a.constructor;
          ar != Lr && "constructor" in r && "constructor" in a && !(typeof ar == "function" && ar instanceof ar && typeof Lr == "function" && Lr instanceof Lr) && (Ti = !1);
        }
        return at.delete(r), at.delete(a), Ti;
      }
      function ns(r) {
        return Th(Kh(r, p, au), r + "");
      }
      function dh(r) {
        return Hl(r, Nn, yh);
      }
      function mh(r) {
        return Hl(r, yr, qh);
      }
      var gh = la ? function(r) {
        return la.get(r);
      } : zh;
      function Vl(r) {
        for (var a = r.name + "", u = Mo[a], _ = wi.call(Mo, a) ? u.length : 0; _--; ) {
          var k = u[_], at = k.func;
          if (at == null || at == r)
            return k.name;
        }
        return a;
      }
      function Ya(r) {
        var a = wi.call(Q, "placeholder") ? Q : r;
        return a.placeholder;
      }
      function oi() {
        var r = Q.iteratee || Oh;
        return r = r === Oh ? P : r, arguments.length ? r(arguments[0], arguments[1]) : r;
      }
      function Xl(r, a) {
        var u = r.__data__;
        return ec(a) ? u[typeof a == "string" ? "string" : "hash"] : u.map;
      }
      function vh(r) {
        for (var a = Nn(r), u = a.length; u--; ) {
          var _ = a[u], k = r[_];
          a[u] = [_, k, Jh(k)];
        }
        return a;
      }
      function xa(r, a) {
        var u = Wo(r, a);
        return f(u) ? u : p;
      }
      function Yu(r) {
        var a = wi.call(r, Wr), u = r[Wr];
        try {
          r[Wr] = p;
          var _ = !0;
        } catch {
        }
        var k = Zn.call(r);
        return _ && (a ? r[Wr] = u : delete r[Wr]), k;
      }
      var yh = ra ? function(r) {
        return r == null ? [] : (r = Ee(r), hr(ra(r), function(a) {
          return na.call(r, a);
        }));
      } : Bh, qh = ra ? function(r) {
        for (var a = []; r; )
          Br(a, yh(r)), r = Hr(r);
        return a;
      } : Bh, Qn = Bn;
      (sa && Qn(new sa(new ArrayBuffer(1))) != Xt || Jo && Qn(new Jo()) != R || aa && Qn(aa.resolve()) != pt || $o && Qn(new $o()) != Kt || gn && Qn(new gn()) != tt) && (Qn = function(r) {
        var a = Bn(r), u = a == ct ? r.constructor : p, _ = u ? wa(u) : "";
        if (_)
          switch (_) {
            case Ua:
              return Xt;
            case al:
              return R;
            case ll:
              return pt;
            case hl:
              return Kt;
            case Ol:
              return tt;
          }
        return a;
      });
      function Zu(r, a, u) {
        for (var _ = -1, k = u.length; ++_ < k; ) {
          var at = u[_], yt = at.size;
          switch (at.type) {
            case "drop":
              r += yt;
              break;
            case "dropRight":
              a -= yt;
              break;
            case "take":
              a = In(a, r + yt);
              break;
            case "takeRight":
              r = hn(r, a - yt);
              break;
          }
        }
        return { start: r, end: a };
      }
      function Ju(r) {
        var a = r.match(Ws);
        return a ? a[1].split(Or) : [];
      }
      function Yh(r, a, u) {
        a = Ze(a, r);
        for (var _ = -1, k = a.length, at = !1; ++_ < k; ) {
          var yt = Po(a[_]);
          if (!(at = r != null && u(r, yt)))
            break;
          r = r[yt];
        }
        return at || ++_ != k ? at : (k = r == null ? 0 : r.length, !!k && Ql(k) && rs(yt, k) && (gi(r) || Ta(r)));
      }
      function $u(r) {
        var a = r.length, u = new r.constructor(a);
        return a && typeof r[0] == "string" && wi.call(r, "index") && (u.index = r.index, u.input = r.input), u;
      }
      function Zh(r) {
        return typeof r.constructor == "function" && !Tl(r) ? So(Hr(r)) : {};
      }
      function Ku(r, a, u) {
        var _ = r.constructor;
        switch (a) {
          case Gt:
            return Ns(r);
          case Ie:
          case Ge:
            return new _(+r);
          case Xt:
            return vl(r, u);
          case Vt:
          case Ne:
          case Re:
          case de:
          case we:
          case vi:
          case Mi:
          case ni:
          case Si:
            return _a(r, u);
          case R:
            return new _();
          case Jt:
          case w:
            return new _(r);
          case ie:
            return ks(r);
          case Kt:
            return new _();
          case X:
            return es(r);
        }
      }
      function Qu(r, a) {
        var u = a.length;
        if (!u)
          return r;
        var _ = u - 1;
        return a[_] = (u > 1 ? "& " : "") + a[_], a = a.join(u > 2 ? ", " : " "), r.replace(us, `{
/* [wrapped with ` + a + `] */
`);
      }
      function tc(r) {
        return gi(r) || Ta(r) || !!(As && r && r[As]);
      }
      function rs(r, a) {
        var u = typeof r;
        return a = a ?? ge, !!a && (u == "number" || u != "symbol" && ba.test(r)) && r > -1 && r % 1 == 0 && r < a;
      }
      function sr(r, a, u) {
        if (!pn(u))
          return !1;
        var _ = typeof a;
        return (_ == "number" ? vr(u) && rs(a, u.length) : _ == "string" && a in u) ? ho(u[a], r) : !1;
      }
      function _h(r, a) {
        if (gi(r))
          return !1;
        var u = typeof r;
        return u == "number" || u == "symbol" || u == "boolean" || r == null || Cr(r) ? !0 : tr.test(r) || !Lo.test(r) || a != null && r in Ee(a);
      }
      function ec(r) {
        var a = typeof r;
        return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? r !== "__proto__" : r === null;
      }
      function xh(r) {
        var a = Vl(r), u = Q[a];
        if (typeof u != "function" || !(a in yi.prototype))
          return !1;
        if (r === u)
          return !0;
        var _ = gh(u);
        return !!_ && r === _[0];
      }
      function ic(r) {
        return !!pr && pr in r;
      }
      var nc = wo ? os : Nh;
      function Tl(r) {
        var a = r && r.constructor, u = typeof a == "function" && a.prototype || Fr;
        return r === u;
      }
      function Jh(r) {
        return r === r && !pn(r);
      }
      function $h(r, a) {
        return function(u) {
          return u == null ? !1 : u[r] === a && (a !== p || r in Ee(u));
        };
      }
      function rc(r) {
        var a = $l(r, function(_) {
          return u.size === U && u.clear(), _;
        }), u = a.cache;
        return a;
      }
      function oc(r, a) {
        var u = r[1], _ = a[1], k = u | _, at = k < (A | d | V), yt = _ == V && u == M || _ == V && u == ht && r[7].length <= a[8] || _ == (V | ht) && a[7].length <= a[8] && u == M;
        if (!(at || yt))
          return r;
        _ & A && (r[2] = a[2], k |= u & A ? 0 : g);
        var St = a[3];
        if (St) {
          var Nt = r[3];
          r[3] = Nt ? yl(Nt, St, a[4]) : St, r[4] = Nt ? fr(r[3], Y) : a[4];
        }
        return St = a[5], St && (Nt = r[5], r[5] = Nt ? _l(Nt, St, a[6]) : St, r[6] = Nt ? fr(r[5], Y) : a[6]), St = a[7], St && (r[7] = St), _ & V && (r[8] = r[8] == null ? a[8] : In(r[8], a[8])), r[9] == null && (r[9] = a[9]), r[0] = a[0], r[1] = k, r;
      }
      function sc(r) {
        var a = [];
        if (r != null)
          for (var u in Ee(r))
            a.push(u);
        return a;
      }
      function ac(r) {
        return Zn.call(r);
      }
      function Kh(r, a, u) {
        return a = hn(a === p ? r.length - 1 : a, 0), function() {
          for (var _ = arguments, k = -1, at = hn(_.length - a, 0), yt = Yt(at); ++k < at; )
            yt[k] = _[a + k];
          k = -1;
          for (var St = Yt(a + 1); ++k < a; )
            St[k] = _[k];
          return St[a] = u(yt), er(r, this, St);
        };
      }
      function Qh(r, a) {
        return a.length < 2 ? r : Ao(r, Fi(a, 0, -1));
      }
      function lc(r, a) {
        for (var u = r.length, _ = In(a.length, u), k = Hn(r); _--; ) {
          var at = a[_];
          r[_] = rs(at, u) ? k[at] : p;
        }
        return r;
      }
      function wh(r, a) {
        if (!(a === "constructor" && typeof r[a] == "function") && a != "__proto__")
          return r[a];
      }
      var tu = iu(yn), Ml = nl || function(r, a) {
        return ln.setTimeout(r, a);
      }, Th = iu(cn);
      function eu(r, a, u) {
        var _ = a + "";
        return Th(r, Qu(_, hc(Ju(_), u)));
      }
      function iu(r) {
        var a = 0, u = 0;
        return function() {
          var _ = oa(), k = Et - (_ - u);
          if (u = _, k > 0) {
            if (++a >= lt)
              return arguments[0];
          } else
            a = 0;
          return r.apply(p, arguments);
        };
      }
      function ql(r, a) {
        var u = -1, _ = r.length, k = _ - 1;
        for (a = a === p ? _ : a; ++u < a; ) {
          var at = pe(u, k), yt = r[at];
          r[at] = r[u], r[u] = yt;
        }
        return r.length = a, r;
      }
      var nu = rc(function(r) {
        var a = [];
        return r.charCodeAt(0) === 46 && a.push(""), r.replace(hs, function(u, _, k, at) {
          a.push(k ? at.replace(fs, "$1") : _ || u);
        }), a;
      });
      function Po(r) {
        if (typeof r == "string" || Cr(r))
          return r;
        var a = r + "";
        return a == "0" && 1 / r == -Rt ? "-0" : a;
      }
      function wa(r) {
        if (r != null) {
          try {
            return qn.call(r);
          } catch {
          }
          try {
            return r + "";
          } catch {
          }
        }
        return "";
      }
      function hc(r, a) {
        return qi(xe, function(u) {
          var _ = "_." + u[0];
          a & u[1] && !$s(r, _) && r.push(_);
        }), r.sort();
      }
      function ru(r) {
        if (r instanceof yi)
          return r.clone();
        var a = new Dn(r.__wrapped__, r.__chain__);
        return a.__actions__ = Hn(r.__actions__), a.__index__ = r.__index__, a.__values__ = r.__values__, a;
      }
      function uc(r, a, u) {
        (u ? sr(r, a, u) : a === p) ? a = 1 : a = hn(xi(a), 0);
        var _ = r == null ? 0 : r.length;
        if (!_ || a < 1)
          return [];
        for (var k = 0, at = 0, yt = Yt(no(_ / a)); k < _; )
          yt[at++] = Fi(r, k, k += a);
        return yt;
      }
      function cc(r) {
        for (var a = -1, u = r == null ? 0 : r.length, _ = 0, k = []; ++a < u; ) {
          var at = r[a];
          at && (k[_++] = at);
        }
        return k;
      }
      function fc() {
        var r = arguments.length;
        if (!r)
          return [];
        for (var a = Yt(r - 1), u = arguments[0], _ = r; _--; )
          a[_ - 1] = arguments[_];
        return Br(gi(u) ? Hn(u) : [u], vn(a, 1));
      }
      var pc = se(function(r, a) {
        return Sn(r) ? ga(r, vn(a, 1, Sn, !0)) : [];
      }), dc = se(function(r, a) {
        var u = Zr(a);
        return Sn(u) && (u = p), Sn(r) ? ga(r, vn(a, 1, Sn, !0), oi(u, 2)) : [];
      }), mc = se(function(r, a) {
        var u = Zr(a);
        return Sn(u) && (u = p), Sn(r) ? ga(r, vn(a, 1, Sn, !0), p, u) : [];
      });
      function gc(r, a, u) {
        var _ = r == null ? 0 : r.length;
        return _ ? (a = u || a === p ? 1 : xi(a), Fi(r, a < 0 ? 0 : a, _)) : [];
      }
      function vc(r, a, u) {
        var _ = r == null ? 0 : r.length;
        return _ ? (a = u || a === p ? 1 : xi(a), a = _ - a, Fi(r, 0, a < 0 ? 0 : a)) : [];
      }
      function yc(r, a) {
        return r && r.length ? Xe(r, oi(a, 3), !0, !0) : [];
      }
      function _c(r, a) {
        return r && r.length ? Xe(r, oi(a, 3), !0) : [];
      }
      function xc(r, a, u, _) {
        var k = r == null ? 0 : r.length;
        return k ? (u && typeof u != "number" && sr(r, a, u) && (u = 0, _ = k), Gn(r, a, u, _)) : [];
      }
      function ou(r, a, u) {
        var _ = r == null ? 0 : r.length;
        if (!_)
          return -1;
        var k = u == null ? 0 : xi(u);
        return k < 0 && (k = hn(_ + k, 0)), mo(r, oi(a, 3), k);
      }
      function su(r, a, u) {
        var _ = r == null ? 0 : r.length;
        if (!_)
          return -1;
        var k = _ - 1;
        return u !== p && (k = xi(u), k = u < 0 ? hn(_ + k, 0) : In(k, _ - 1)), mo(r, oi(a, 3), k, !0);
      }
      function au(r) {
        var a = r == null ? 0 : r.length;
        return a ? vn(r, 1) : [];
      }
      function wc(r) {
        var a = r == null ? 0 : r.length;
        return a ? vn(r, Rt) : [];
      }
      function Tc(r, a) {
        var u = r == null ? 0 : r.length;
        return u ? (a = a === p ? 1 : xi(a), vn(r, a)) : [];
      }
      function Mc(r) {
        for (var a = -1, u = r == null ? 0 : r.length, _ = {}; ++a < u; ) {
          var k = r[a];
          _[k[0]] = k[1];
        }
        return _;
      }
      function lu(r) {
        return r && r.length ? r[0] : p;
      }
      function Sc(r, a, u) {
        var _ = r == null ? 0 : r.length;
        if (!_)
          return -1;
        var k = u == null ? 0 : xi(u);
        return k < 0 && (k = hn(_ + k, 0)), ur(r, a, k);
      }
      function Ec(r) {
        var a = r == null ? 0 : r.length;
        return a ? Fi(r, 0, -1) : [];
      }
      var bc = se(function(r) {
        var a = Vi(r, ne);
        return a.length && a[0] === r[0] ? ya(a) : [];
      }), Ac = se(function(r) {
        var a = Zr(r), u = Vi(r, ne);
        return a === Zr(u) ? a = p : u.pop(), u.length && u[0] === r[0] ? ya(u, oi(a, 2)) : [];
      }), Cc = se(function(r) {
        var a = Zr(r), u = Vi(r, ne);
        return a = typeof a == "function" ? a : p, a && u.pop(), u.length && u[0] === r[0] ? ya(u, p, a) : [];
      });
      function Pc(r, a) {
        return r == null ? "" : ol.call(r, a);
      }
      function Zr(r) {
        var a = r == null ? 0 : r.length;
        return a ? r[a - 1] : p;
      }
      function Lc(r, a, u) {
        var _ = r == null ? 0 : r.length;
        if (!_)
          return -1;
        var k = _;
        return u !== p && (k = xi(u), k = k < 0 ? hn(_ + k, 0) : In(k, _ - 1)), a === a ? Oa(r, a, k) : mo(r, ko, k, !0);
      }
      function Rc(r, a) {
        return r && r.length ? W(r, xi(a)) : p;
      }
      var Ic = se(hu);
      function hu(r, a) {
        return r && r.length && a && a.length ? qt(r, a) : r;
      }
      function Oc(r, a, u) {
        return r && r.length && a && a.length ? qt(r, a, oi(u, 2)) : r;
      }
      function Dc(r, a, u) {
        return r && r.length && a && a.length ? qt(r, a, p, u) : r;
      }
      var zc = ns(function(r, a) {
        var u = r == null ? 0 : r.length, _ = ml(r, a);
        return Te(r, Vi(a, function(k) {
          return rs(k, u) ? +k : k;
        }).sort(is)), _;
      });
      function Bc(r, a) {
        var u = [];
        if (!(r && r.length))
          return u;
        var _ = -1, k = [], at = r.length;
        for (a = oi(a, 3); ++_ < at; ) {
          var yt = r[_];
          a(yt, _, r) && (u.push(yt), k.push(_));
        }
        return Te(r, k), u;
      }
      function Mh(r) {
        return r == null ? r : Cs.call(r);
      }
      function Nc(r, a, u) {
        var _ = r == null ? 0 : r.length;
        return _ ? (u && typeof u != "number" && sr(r, a, u) ? (a = 0, u = _) : (a = a == null ? 0 : xi(a), u = u === p ? _ : xi(u)), Fi(r, a, u)) : [];
      }
      function kc(r, a) {
        return _n(r, a);
      }
      function Uc(r, a, u) {
        return Ae(r, a, oi(u, 2));
      }
      function Fc(r, a) {
        var u = r == null ? 0 : r.length;
        if (u) {
          var _ = _n(r, a);
          if (_ < u && ho(r[_], a))
            return _;
        }
        return -1;
      }
      function Gc(r, a) {
        return _n(r, a, !0);
      }
      function Hc(r, a, u) {
        return Ae(r, a, oi(u, 2), !0);
      }
      function Wc(r, a) {
        var u = r == null ? 0 : r.length;
        if (u) {
          var _ = _n(r, a, !0) - 1;
          if (ho(r[_], a))
            return _;
        }
        return -1;
      }
      function jc(r) {
        return r && r.length ? Qe(r) : [];
      }
      function Vc(r, a) {
        return r && r.length ? Qe(r, oi(a, 2)) : [];
      }
      function Xc(r) {
        var a = r == null ? 0 : r.length;
        return a ? Fi(r, 1, a) : [];
      }
      function qc(r, a, u) {
        return r && r.length ? (a = u || a === p ? 1 : xi(a), Fi(r, 0, a < 0 ? 0 : a)) : [];
      }
      function Yc(r, a, u) {
        var _ = r == null ? 0 : r.length;
        return _ ? (a = u || a === p ? 1 : xi(a), a = _ - a, Fi(r, a < 0 ? 0 : a, _)) : [];
      }
      function Zc(r, a) {
        return r && r.length ? Xe(r, oi(a, 3), !1, !0) : [];
      }
      function Jc(r, a) {
        return r && r.length ? Xe(r, oi(a, 3)) : [];
      }
      var $c = se(function(r) {
        return ei(vn(r, 1, Sn, !0));
      }), Kc = se(function(r) {
        var a = Zr(r);
        return Sn(a) && (a = p), ei(vn(r, 1, Sn, !0), oi(a, 2));
      }), Qc = se(function(r) {
        var a = Zr(r);
        return a = typeof a == "function" ? a : p, ei(vn(r, 1, Sn, !0), p, a);
      });
      function tf(r) {
        return r && r.length ? ei(r) : [];
      }
      function ef(r, a) {
        return r && r.length ? ei(r, oi(a, 2)) : [];
      }
      function nf(r, a) {
        return a = typeof a == "function" ? a : p, r && r.length ? ei(r, p, a) : [];
      }
      function Sh(r) {
        if (!(r && r.length))
          return [];
        var a = 0;
        return r = hr(r, function(u) {
          if (Sn(u))
            return a = hn(u.length, a), !0;
        }), to(a, function(u) {
          return Vi(r, go(u));
        });
      }
      function uu(r, a) {
        if (!(r && r.length))
          return [];
        var u = Sh(r);
        return a == null ? u : Vi(u, function(_) {
          return er(a, p, _);
        });
      }
      var rf = se(function(r, a) {
        return Sn(r) ? ga(r, a) : [];
      }), of = se(function(r) {
        return Ai(hr(r, Sn));
      }), sf = se(function(r) {
        var a = Zr(r);
        return Sn(a) && (a = p), Ai(hr(r, Sn), oi(a, 2));
      }), af = se(function(r) {
        var a = Zr(r);
        return a = typeof a == "function" ? a : p, Ai(hr(r, Sn), p, a);
      }), lf = se(Sh);
      function hf(r, a) {
        return bi(r || [], a || [], zs);
      }
      function uf(r, a) {
        return bi(r || [], a || [], ci);
      }
      var cf = se(function(r) {
        var a = r.length, u = a > 1 ? r[a - 1] : p;
        return u = typeof u == "function" ? (r.pop(), u) : p, uu(r, u);
      });
      function cu(r) {
        var a = Q(r);
        return a.__chain__ = !0, a;
      }
      function ff(r, a) {
        return a(r), r;
      }
      function Yl(r, a) {
        return a(r);
      }
      var pf = ns(function(r) {
        var a = r.length, u = a ? r[0] : 0, _ = this.__wrapped__, k = function(at) {
          return ml(at, r);
        };
        return a > 1 || this.__actions__.length || !(_ instanceof yi) || !rs(u) ? this.thru(k) : (_ = _.slice(u, +u + (a ? 1 : 0)), _.__actions__.push({
          func: Yl,
          args: [k],
          thisArg: p
        }), new Dn(_, this.__chain__).thru(function(at) {
          return a && !at.length && at.push(p), at;
        }));
      });
      function df() {
        return cu(this);
      }
      function mf() {
        return new Dn(this.value(), this.__chain__);
      }
      function gf() {
        this.__values__ === p && (this.__values__ = Eu(this.value()));
        var r = this.__index__ >= this.__values__.length, a = r ? p : this.__values__[this.__index__++];
        return { done: r, value: a };
      }
      function vf() {
        return this;
      }
      function yf(r) {
        for (var a, u = this; u instanceof Ls; ) {
          var _ = ru(u);
          _.__index__ = 0, _.__values__ = p, a ? k.__wrapped__ = _ : a = _;
          var k = _;
          u = u.__wrapped__;
        }
        return k.__wrapped__ = r, a;
      }
      function _f() {
        var r = this.__wrapped__;
        if (r instanceof yi) {
          var a = r;
          return this.__actions__.length && (a = new yi(this)), a = a.reverse(), a.__actions__.push({
            func: Yl,
            args: [Mh],
            thisArg: p
          }), new Dn(a, this.__chain__);
        }
        return this.thru(Mh);
      }
      function xf() {
        return ri(this.__wrapped__, this.__actions__);
      }
      var wf = Us(function(r, a, u) {
        wi.call(r, u) ? ++r[u] : so(r, u, 1);
      });
      function Tf(r, a, u) {
        var _ = gi(r) ? il : zn;
        return u && sr(r, a, u) && (a = p), _(r, oi(a, 3));
      }
      function Mf(r, a) {
        var u = gi(r) ? hr : mr;
        return u(r, oi(a, 3));
      }
      var Sf = $e(ou), Ef = $e(su);
      function bf(r, a) {
        return vn(Zl(r, a), 1);
      }
      function Af(r, a) {
        return vn(Zl(r, a), Rt);
      }
      function Cf(r, a, u) {
        return u = u === p ? 1 : xi(u), vn(Zl(r, a), u);
      }
      function fu(r, a) {
        var u = gi(r) ? qi : un;
        return u(r, oi(a, 3));
      }
      function pu(r, a) {
        var u = gi(r) ? Bo : Gl;
        return u(r, oi(a, 3));
      }
      var Pf = Us(function(r, a, u) {
        wi.call(r, u) ? r[u].push(a) : so(r, u, [a]);
      });
      function Lf(r, a, u, _) {
        r = vr(r) ? r : Ja(r), u = u && !_ ? xi(u) : 0;
        var k = r.length;
        return u < 0 && (u = hn(k + u, 0)), th(r) ? u <= k && r.indexOf(a, u) > -1 : !!k && ur(r, a, u) > -1;
      }
      var Rf = se(function(r, a, u) {
        var _ = -1, k = typeof a == "function", at = vr(r) ? Yt(r.length) : [];
        return un(r, function(yt) {
          at[++_] = k ? er(a, yt, u) : e(yt, a, u);
        }), at;
      }), If = Us(function(r, a, u) {
        so(r, u, a);
      });
      function Zl(r, a) {
        var u = gi(r) ? Vi : _t;
        return u(r, oi(a, 3));
      }
      function Of(r, a, u, _) {
        return r == null ? [] : (gi(a) || (a = a == null ? [] : [a]), u = _ ? p : u, gi(u) || (u = u == null ? [] : [u]), it(r, a, u));
      }
      var Df = Us(function(r, a, u) {
        r[u ? 0 : 1].push(a);
      }, function() {
        return [[], []];
      });
      function zf(r, a, u) {
        var _ = gi(r) ? Ra : vo, k = arguments.length < 3;
        return _(r, oi(a, 4), u, k, un);
      }
      function Bf(r, a, u) {
        var _ = gi(r) ? Cl : vo, k = arguments.length < 3;
        return _(r, oi(a, 4), u, k, Gl);
      }
      function Nf(r, a) {
        var u = gi(r) ? hr : mr;
        return u(r, Kl(oi(a, 3)));
      }
      function kf(r) {
        var a = gi(r) ? fl : je;
        return a(r);
      }
      function Uf(r, a, u) {
        (u ? sr(r, a, u) : a === p) ? a = 1 : a = xi(a);
        var _ = gi(r) ? ph : Ke;
        return _(r, a);
      }
      function Ff(r) {
        var a = gi(r) ? kl : ji;
        return a(r);
      }
      function Gf(r) {
        if (r == null)
          return 0;
        if (vr(r))
          return th(r) ? Er(r) : r.length;
        var a = Qn(r);
        return a == R || a == Kt ? r.size : N(r).length;
      }
      function Hf(r, a, u) {
        var _ = gi(r) ? Kr : Qi;
        return u && sr(r, a, u) && (a = p), _(r, oi(a, 3));
      }
      var Wf = se(function(r, a) {
        if (r == null)
          return [];
        var u = a.length;
        return u > 1 && sr(r, a[0], a[1]) ? a = [] : u > 2 && sr(a[0], a[1], a[2]) && (a = [a[0]]), it(r, vn(a, 1), []);
      }), Jl = Ba || function() {
        return ln.Date.now();
      };
      function jf(r, a) {
        if (typeof a != "function")
          throw new Xn(C);
        return r = xi(r), function() {
          if (--r < 1)
            return a.apply(this, arguments);
        };
      }
      function du(r, a, u) {
        return a = u ? p : a, a = r && a == null ? r.length : a, Wn(r, V, p, p, p, p, a);
      }
      function mu(r, a) {
        var u;
        if (typeof a != "function")
          throw new Xn(C);
        return r = xi(r), function() {
          return --r > 0 && (u = a.apply(this, arguments)), r <= 1 && (a = p), u;
        };
      }
      var Eh = se(function(r, a, u) {
        var _ = A;
        if (u.length) {
          var k = fr(u, Ya(Eh));
          _ |= F;
        }
        return Wn(r, _, a, u, k);
      }), gu = se(function(r, a, u) {
        var _ = A | d;
        if (u.length) {
          var k = fr(u, Ya(gu));
          _ |= F;
        }
        return Wn(a, _, r, u, k);
      });
      function vu(r, a, u) {
        a = u ? p : a;
        var _ = Wn(r, M, p, p, p, p, p, a);
        return _.placeholder = vu.placeholder, _;
      }
      function yu(r, a, u) {
        a = u ? p : a;
        var _ = Wn(r, x, p, p, p, p, p, a);
        return _.placeholder = yu.placeholder, _;
      }
      function _u(r, a, u) {
        var _, k, at, yt, St, Nt, re = 0, ae = !1, fe = !1, ze = !0;
        if (typeof r != "function")
          throw new Xn(C);
        a = Jr(a) || 0, pn(u) && (ae = !!u.leading, fe = "maxWait" in u, at = fe ? hn(Jr(u.maxWait) || 0, a) : at, ze = "trailing" in u ? !!u.trailing : ze);
        function Je(En) {
          var uo = _, as = k;
          return _ = k = p, re = En, yt = r.apply(as, uo), yt;
        }
        function li(En) {
          return re = En, St = Ml(Ci, a), ae ? Je(En) : yt;
        }
        function Ti(En) {
          var uo = En - Nt, as = En - re, ku = a - uo;
          return fe ? In(ku, at - as) : ku;
        }
        function hi(En) {
          var uo = En - Nt, as = En - re;
          return Nt === p || uo >= a || uo < 0 || fe && as >= at;
        }
        function Ci() {
          var En = Jl();
          if (hi(En))
            return Bi(En);
          St = Ml(Ci, Ti(En));
        }
        function Bi(En) {
          return St = p, ze && _ ? Je(En) : (_ = k = p, yt);
        }
        function Pr() {
          St !== p && xn(St), re = 0, _ = Nt = k = St = p;
        }
        function ar() {
          return St === p ? yt : Bi(Jl());
        }
        function Lr() {
          var En = Jl(), uo = hi(En);
          if (_ = arguments, k = this, Nt = En, uo) {
            if (St === p)
              return li(Nt);
            if (fe)
              return xn(St), St = Ml(Ci, a), Je(Nt);
          }
          return St === p && (St = Ml(Ci, a)), yt;
        }
        return Lr.cancel = Pr, Lr.flush = ar, Lr;
      }
      var Vf = se(function(r, a) {
        return Vr(r, 1, a);
      }), Xf = se(function(r, a, u) {
        return Vr(r, Jr(a) || 0, u);
      });
      function qf(r) {
        return Wn(r, ft);
      }
      function $l(r, a) {
        if (typeof r != "function" || a != null && typeof a != "function")
          throw new Xn(C);
        var u = function() {
          var _ = arguments, k = a ? a.apply(this, _) : _[0], at = u.cache;
          if (at.has(k))
            return at.get(k);
          var yt = r.apply(this, _);
          return u.cache = at.set(k, yt) || at, yt;
        };
        return u.cache = new ($l.Cache || nr)(), u;
      }
      $l.Cache = nr;
      function Kl(r) {
        if (typeof r != "function")
          throw new Xn(C);
        return function() {
          var a = arguments;
          switch (a.length) {
            case 0:
              return !r.call(this);
            case 1:
              return !r.call(this, a[0]);
            case 2:
              return !r.call(this, a[0], a[1]);
            case 3:
              return !r.call(this, a[0], a[1], a[2]);
          }
          return !r.apply(this, a);
        };
      }
      function Yf(r) {
        return mu(2, r);
      }
      var Zf = ai(function(r, a) {
        a = a.length == 1 && gi(a[0]) ? Vi(a[0], Ln(oi())) : Vi(vn(a, 1), Ln(oi()));
        var u = a.length;
        return se(function(_) {
          for (var k = -1, at = In(_.length, u); ++k < at; )
            _[k] = a[k].call(this, _[k]);
          return er(r, this, _);
        });
      }), bh = se(function(r, a) {
        var u = fr(a, Ya(bh));
        return Wn(r, F, p, a, u);
      }), xu = se(function(r, a) {
        var u = fr(a, Ya(xu));
        return Wn(r, z, p, a, u);
      }), Jf = ns(function(r, a) {
        return Wn(r, ht, p, p, p, a);
      });
      function $f(r, a) {
        if (typeof r != "function")
          throw new Xn(C);
        return a = a === p ? a : xi(a), se(r, a);
      }
      function Kf(r, a) {
        if (typeof r != "function")
          throw new Xn(C);
        return a = a == null ? 0 : hn(xi(a), 0), se(function(u) {
          var _ = u[a], k = fn(u, 0, a);
          return _ && Br(k, _), er(r, this, k);
        });
      }
      function Qf(r, a, u) {
        var _ = !0, k = !0;
        if (typeof r != "function")
          throw new Xn(C);
        return pn(u) && (_ = "leading" in u ? !!u.leading : _, k = "trailing" in u ? !!u.trailing : k), _u(r, a, {
          leading: _,
          maxWait: a,
          trailing: k
        });
      }
      function tp(r) {
        return du(r, 1);
      }
      function ep(r, a) {
        return bh(ii(a), r);
      }
      function ip() {
        if (!arguments.length)
          return [];
        var r = arguments[0];
        return gi(r) ? r : [r];
      }
      function np(r) {
        return rr(r, B);
      }
      function rp(r, a) {
        return a = typeof a == "function" ? a : p, rr(r, B, a);
      }
      function op(r) {
        return rr(r, H | B);
      }
      function sp(r, a) {
        return a = typeof a == "function" ? a : p, rr(r, H | B, a);
      }
      function ap(r, a) {
        return a == null || Fl(r, a, Nn(a));
      }
      function ho(r, a) {
        return r === a || r !== r && a !== a;
      }
      var lp = Yr(ja), hp = Yr(function(r, a) {
        return r >= a;
      }), Ta = i(function() {
        return arguments;
      }()) ? i : function(r) {
        return wn(r) && wi.call(r, "callee") && !na.call(r, "callee");
      }, gi = Yt.isArray, up = el ? Ln(el) : n;
      function vr(r) {
        return r != null && Ql(r.length) && !os(r);
      }
      function Sn(r) {
        return wn(r) && vr(r);
      }
      function cp(r) {
        return r === !0 || r === !1 || wn(r) && Bn(r) == Ie;
      }
      var Gs = rl || Nh, fp = xs ? Ln(xs) : o;
      function pp(r) {
        return wn(r) && r.nodeType === 1 && !Sl(r);
      }
      function dp(r) {
        if (r == null)
          return !0;
        if (vr(r) && (gi(r) || typeof r == "string" || typeof r.splice == "function" || Gs(r) || Za(r) || Ta(r)))
          return !r.length;
        var a = Qn(r);
        if (a == R || a == Kt)
          return !r.size;
        if (Tl(r))
          return !N(r).length;
        for (var u in r)
          if (wi.call(r, u))
            return !1;
        return !0;
      }
      function mp(r, a) {
        return s(r, a);
      }
      function gp(r, a, u) {
        u = typeof u == "function" ? u : p;
        var _ = u ? u(r, a) : p;
        return _ === p ? s(r, a, p, u) : !!_;
      }
      function Ah(r) {
        if (!wn(r))
          return !1;
        var a = Bn(r);
        return a == Li || a == pi || typeof r.message == "string" && typeof r.name == "string" && !Sl(r);
      }
      function vp(r) {
        return typeof r == "number" && Na(r);
      }
      function os(r) {
        if (!pn(r))
          return !1;
        var a = Bn(r);
        return a == an || a == Zi || a == Ni || a == Lt;
      }
      function wu(r) {
        return typeof r == "number" && r == xi(r);
      }
      function Ql(r) {
        return typeof r == "number" && r > -1 && r % 1 == 0 && r <= ge;
      }
      function pn(r) {
        var a = typeof r;
        return r != null && (a == "object" || a == "function");
      }
      function wn(r) {
        return r != null && typeof r == "object";
      }
      var Tu = ws ? Ln(ws) : h;
      function yp(r, a) {
        return r === a || c(r, a, vh(a));
      }
      function _p(r, a, u) {
        return u = typeof u == "function" ? u : p, c(r, a, vh(a), u);
      }
      function xp(r) {
        return Mu(r) && r != +r;
      }
      function wp(r) {
        if (nc(r))
          throw new si(m);
        return f(r);
      }
      function Tp(r) {
        return r === null;
      }
      function Mp(r) {
        return r == null;
      }
      function Mu(r) {
        return typeof r == "number" || wn(r) && Bn(r) == Jt;
      }
      function Sl(r) {
        if (!wn(r) || Bn(r) != ct)
          return !1;
        var a = Hr(r);
        if (a === null)
          return !0;
        var u = wi.call(a, "constructor") && a.constructor;
        return typeof u == "function" && u instanceof u && qn.call(u) == Gr;
      }
      var Ch = bl ? Ln(bl) : v;
      function Sp(r) {
        return wu(r) && r >= -ge && r <= ge;
      }
      var Su = Al ? Ln(Al) : y;
      function th(r) {
        return typeof r == "string" || !gi(r) && wn(r) && Bn(r) == w;
      }
      function Cr(r) {
        return typeof r == "symbol" || wn(r) && Bn(r) == X;
      }
      var Za = Ca ? Ln(Ca) : S;
      function Ep(r) {
        return r === p;
      }
      function bp(r) {
        return wn(r) && Qn(r) == tt;
      }
      function Ap(r) {
        return wn(r) && Bn(r) == vt;
      }
      var Cp = Yr(et), Pp = Yr(function(r, a) {
        return r <= a;
      });
      function Eu(r) {
        if (!r)
          return [];
        if (vr(r))
          return th(r) ? Vn(r) : Hn(r);
        if (To && r[To])
          return Vo(r[To]());
        var a = Qn(r), u = a == R ? kn : a == Kt ? Xo : Ja;
        return u(r);
      }
      function ss(r) {
        if (!r)
          return r === 0 ? r : 0;
        if (r = Jr(r), r === Rt || r === -Rt) {
          var a = r < 0 ? -1 : 1;
          return a * ue;
        }
        return r === r ? r : 0;
      }
      function xi(r) {
        var a = ss(r), u = a % 1;
        return a === a ? u ? a - u : a : 0;
      }
      function bu(r) {
        return r ? bo(xi(r), 0, Dt) : 0;
      }
      function Jr(r) {
        if (typeof r == "number")
          return r;
        if (Cr(r))
          return Ft;
        if (pn(r)) {
          var a = typeof r.valueOf == "function" ? r.valueOf() : r;
          r = pn(a) ? a + "" : a;
        }
        if (typeof r != "string")
          return r === 0 ? r : +r;
        r = Ms(r);
        var u = Qa.test(r);
        return u || Io.test(r) ? vs(r.slice(2), u ? 2 : 8) : Ka.test(r) ? Ft : +r;
      }
      function Au(r) {
        return Mn(r, yr(r));
      }
      function Lp(r) {
        return r ? bo(xi(r), -ge, ge) : r === 0 ? r : 0;
      }
      function Xi(r) {
        return r == null ? "" : Ye(r);
      }
      var Rp = lo(function(r, a) {
        if (Tl(a) || vr(a)) {
          Mn(a, Nn(a), r);
          return;
        }
        for (var u in a)
          wi.call(a, u) && zs(r, u, a[u]);
      }), Cu = lo(function(r, a) {
        Mn(a, yr(a), r);
      }), eh = lo(function(r, a, u, _) {
        Mn(a, yr(a), r, _);
      }), Ip = lo(function(r, a, u, _) {
        Mn(a, Nn(a), r, _);
      }), Op = ns(ml);
      function Dp(r, a) {
        var u = So(r);
        return a == null ? u : pl(u, a);
      }
      var zp = se(function(r, a) {
        r = Ee(r);
        var u = -1, _ = a.length, k = _ > 2 ? a[2] : p;
        for (k && sr(a[0], a[1], k) && (_ = 1); ++u < _; )
          for (var at = a[u], yt = yr(at), St = -1, Nt = yt.length; ++St < Nt; ) {
            var re = yt[St], ae = r[re];
            (ae === p || ho(ae, Fr[re]) && !wi.call(r, re)) && (r[re] = at[re]);
          }
        return r;
      }), Bp = se(function(r) {
        return r.push(p, Vh), er(Pu, p, r);
      });
      function Np(r, a) {
        return No(r, oi(a, 3), gr);
      }
      function kp(r, a) {
        return No(r, oi(a, 3), Wa);
      }
      function Up(r, a) {
        return r == null ? r : va(r, oi(a, 3), yr);
      }
      function Fp(r, a) {
        return r == null ? r : Ha(r, oi(a, 3), yr);
      }
      function Gp(r, a) {
        return r && gr(r, oi(a, 3));
      }
      function Hp(r, a) {
        return r && Wa(r, oi(a, 3));
      }
      function Wp(r) {
        return r == null ? [] : ts(r, Nn(r));
      }
      function jp(r) {
        return r == null ? [] : ts(r, yr(r));
      }
      function Ph(r, a, u) {
        var _ = r == null ? p : Ao(r, a);
        return _ === p ? u : _;
      }
      function Vp(r, a) {
        return r != null && Yh(r, a, Va);
      }
      function Lh(r, a) {
        return r != null && Yh(r, a, gl);
      }
      var Xp = me(function(r, a, u) {
        a != null && typeof a.toString != "function" && (a = Zn.call(a)), r[a] = u;
      }, Ih(_r)), qp = me(function(r, a, u) {
        a != null && typeof a.toString != "function" && (a = Zn.call(a)), wi.call(r, a) ? r[a].push(u) : r[a] = [u];
      }, oi), Yp = se(e);
      function Nn(r) {
        return vr(r) ? Nl(r) : N(r);
      }
      function yr(r) {
        return vr(r) ? Nl(r, !0) : j(r);
      }
      function Zp(r, a) {
        var u = {};
        return a = oi(a, 3), gr(r, function(_, k, at) {
          so(u, a(_, k, at), _);
        }), u;
      }
      function Jp(r, a) {
        var u = {};
        return a = oi(a, 3), gr(r, function(_, k, at) {
          so(u, k, a(_, k, at));
        }), u;
      }
      var $p = lo(function(r, a, u) {
        xt(r, a, u);
      }), Pu = lo(function(r, a, u, _) {
        xt(r, a, u, _);
      }), Kp = ns(function(r, a) {
        var u = {};
        if (r == null)
          return u;
        var _ = !1;
        a = Vi(a, function(at) {
          return at = Ze(at, r), _ || (_ = at.length > 1), at;
        }), Mn(r, mh(r), u), _ && (u = rr(u, H | K | B, Vu));
        for (var k = a.length; k--; )
          Gi(u, a[k]);
        return u;
      });
      function Qp(r, a) {
        return Lu(r, Kl(oi(a)));
      }
      var td = ns(function(r, a) {
        return r == null ? {} : It(r, a);
      });
      function Lu(r, a) {
        if (r == null)
          return {};
        var u = Vi(mh(r), function(_) {
          return [_];
        });
        return a = oi(a), ee(r, u, function(_, k) {
          return a(_, k[0]);
        });
      }
      function ed(r, a, u) {
        a = Ze(a, r);
        var _ = -1, k = a.length;
        for (k || (k = 1, r = p); ++_ < k; ) {
          var at = r == null ? p : r[Po(a[_])];
          at === p && (_ = k, at = u), r = os(at) ? at.call(r) : at;
        }
        return r;
      }
      function id(r, a, u) {
        return r == null ? r : ci(r, a, u);
      }
      function nd(r, a, u, _) {
        return _ = typeof _ == "function" ? _ : p, r == null ? r : ci(r, a, u, _);
      }
      var Ru = jl(Nn), Iu = jl(yr);
      function rd(r, a, u) {
        var _ = gi(r), k = _ || Gs(r) || Za(r);
        if (a = oi(a, 4), u == null) {
          var at = r && r.constructor;
          k ? u = _ ? new at() : [] : pn(r) ? u = os(at) ? So(Hr(r)) : {} : u = {};
        }
        return (k ? qi : gr)(r, function(yt, St, Nt) {
          return a(u, yt, St, Nt);
        }), u;
      }
      function od(r, a) {
        return r == null ? !0 : Gi(r, a);
      }
      function sd(r, a, u) {
        return r == null ? r : Ce(r, a, ii(u));
      }
      function ad(r, a, u, _) {
        return _ = typeof _ == "function" ? _ : p, r == null ? r : Ce(r, a, ii(u), _);
      }
      function Ja(r) {
        return r == null ? [] : Uo(r, Nn(r));
      }
      function ld(r) {
        return r == null ? [] : Uo(r, yr(r));
      }
      function hd(r, a, u) {
        return u === p && (u = a, a = p), u !== p && (u = Jr(u), u = u === u ? u : 0), a !== p && (a = Jr(a), a = a === a ? a : 0), bo(Jr(r), a, u);
      }
      function ud(r, a, u) {
        return a = ss(a), u === p ? (u = a, a = 0) : u = ss(u), r = Jr(r), Xa(r, a, u);
      }
      function cd(r, a, u) {
        if (u && typeof u != "boolean" && sr(r, a, u) && (a = u = p), u === p && (typeof a == "boolean" ? (u = a, a = p) : typeof r == "boolean" && (u = r, r = p)), r === p && a === p ? (r = 0, a = 1) : (r = ss(r), a === p ? (a = r, r = 0) : a = ss(a)), r > a) {
          var _ = r;
          r = a, a = _;
        }
        if (u || r % 1 || a % 1) {
          var k = ka();
          return In(r + k * (a - r + Js("1e-" + ((k + "").length - 1))), a);
        }
        return pe(r, a);
      }
      var fd = De(function(r, a, u) {
        return a = a.toLowerCase(), r + (u ? Ou(a) : a);
      });
      function Ou(r) {
        return Rh(Xi(r).toLowerCase());
      }
      function Du(r) {
        return r = Xi(r), r && r.replace(Aa, Go).replace(tl, "");
      }
      function pd(r, a, u) {
        r = Xi(r), a = Ye(a);
        var _ = r.length;
        u = u === p ? _ : bo(xi(u), 0, _);
        var k = u;
        return u -= a.length, u >= 0 && r.slice(u, k) == a;
      }
      function dd(r) {
        return r = Xi(r), r && Rr.test(r) ? r.replace(Ri, Sr) : r;
      }
      function md(r) {
        return r = Xi(r), r && Sa.test(r) ? r.replace(Hs, "\\$&") : r;
      }
      var gd = De(function(r, a, u) {
        return r + (u ? "-" : "") + a.toLowerCase();
      }), vd = De(function(r, a, u) {
        return r + (u ? " " : "") + a.toLowerCase();
      }), yd = Me("toLowerCase");
      function _d(r, a, u) {
        r = Xi(r), a = xi(a);
        var _ = a ? Er(r) : 0;
        if (!a || _ >= a)
          return r;
        var k = (a - _) / 2;
        return en(Zo(k), u) + r + en(no(k), u);
      }
      function xd(r, a, u) {
        r = Xi(r), a = xi(a);
        var _ = a ? Er(r) : 0;
        return a && _ < a ? r + en(a - _, u) : r;
      }
      function wd(r, a, u) {
        r = Xi(r), a = xi(a);
        var _ = a ? Er(r) : 0;
        return a && _ < a ? en(a - _, u) + r : r;
      }
      function Td(r, a, u) {
        return u || a == null ? a = 0 : a && (a = +a), sl(Xi(r).replace(Ir, ""), a || 0);
      }
      function Md(r, a, u) {
        return (u ? sr(r, a, u) : a === p) ? a = 1 : a = xi(a), be(Xi(r), a);
      }
      function Sd() {
        var r = arguments, a = Xi(r[0]);
        return r.length < 3 ? a : a.replace(r[1], r[2]);
      }
      var Ed = De(function(r, a, u) {
        return r + (u ? "_" : "") + a.toLowerCase();
      });
      function bd(r, a, u) {
        return u && typeof u != "number" && sr(r, a, u) && (a = u = p), u = u === p ? Dt : u >>> 0, u ? (r = Xi(r), r && (typeof a == "string" || a != null && !Ch(a)) && (a = Ye(a), !a && cr(r)) ? fn(Vn(r), 0, u) : r.split(a, u)) : [];
      }
      var Ad = De(function(r, a, u) {
        return r + (u ? " " : "") + Rh(a);
      });
      function Cd(r, a, u) {
        return r = Xi(r), u = u == null ? 0 : bo(xi(u), 0, r.length), a = Ye(a), r.slice(u, u + a.length) == a;
      }
      function Pd(r, a, u) {
        var _ = Q.templateSettings;
        u && sr(r, a, u) && (a = p), r = Xi(r), a = eh({}, a, _, jh);
        var k = eh({}, a.imports, _.imports, jh), at = Nn(k), yt = Uo(k, at), St, Nt, re = 0, ae = a.interpolate || Tr, fe = "__p += '", ze = Un(
          (a.escape || Tr).source + "|" + ae.source + "|" + (ae === ls ? Dr : Tr).source + "|" + (a.evaluate || Tr).source + "|$",
          "g"
        ), Je = "//# sourceURL=" + (wi.call(a, "sourceURL") ? (a.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ms + "]") + `
`;
        r.replace(ze, function(hi, Ci, Bi, Pr, ar, Lr) {
          return Bi || (Bi = Pr), fe += r.slice(re, Lr).replace(L, Ho), Ci && (St = !0, fe += `' +
__e(` + Ci + `) +
'`), ar && (Nt = !0, fe += `';
` + ar + `;
__p += '`), Bi && (fe += `' +
((__t = (` + Bi + `)) == null ? '' : __t) +
'`), re = Lr + hi.length, hi;
        }), fe += `';
`;
        var li = wi.call(a, "variable") && a.variable;
        if (!li)
          fe = `with (obj) {
` + fe + `
}
`;
        else if (cs.test(li))
          throw new si(O);
        fe = (Nt ? fe.replace(wr, "") : fe).replace(jn, "$1").replace(tn, "$1;"), fe = "function(" + (li || "obj") + `) {
` + (li ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (St ? ", __e = _.escape" : "") + (Nt ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + fe + `return __p
}`;
        var Ti = Bu(function() {
          return zi(at, Je + "return " + fe).apply(p, yt);
        });
        if (Ti.source = fe, Ah(Ti))
          throw Ti;
        return Ti;
      }
      function Ld(r) {
        return Xi(r).toLowerCase();
      }
      function Rd(r) {
        return Xi(r).toUpperCase();
      }
      function Id(r, a, u) {
        if (r = Xi(r), r && (u || a === p))
          return Ms(r);
        if (!r || !(a = Ye(a)))
          return r;
        var _ = Vn(r), k = Vn(a), at = _o(_, k), yt = Fo(_, k) + 1;
        return fn(_, at, yt).join("");
      }
      function Od(r, a, u) {
        if (r = Xi(r), r && (u || a === p))
          return r.slice(0, Ss(r) + 1);
        if (!r || !(a = Ye(a)))
          return r;
        var _ = Vn(r), k = Fo(_, Vn(a)) + 1;
        return fn(_, 0, k).join("");
      }
      function Dd(r, a, u) {
        if (r = Xi(r), r && (u || a === p))
          return r.replace(Ir, "");
        if (!r || !(a = Ye(a)))
          return r;
        var _ = Vn(r), k = _o(_, Vn(a));
        return fn(_, k).join("");
      }
      function zd(r, a) {
        var u = gt, _ = zt;
        if (pn(a)) {
          var k = "separator" in a ? a.separator : k;
          u = "length" in a ? xi(a.length) : u, _ = "omission" in a ? Ye(a.omission) : _;
        }
        r = Xi(r);
        var at = r.length;
        if (cr(r)) {
          var yt = Vn(r);
          at = yt.length;
        }
        if (u >= at)
          return r;
        var St = u - Er(_);
        if (St < 1)
          return _;
        var Nt = yt ? fn(yt, 0, St).join("") : r.slice(0, St);
        if (k === p)
          return Nt + _;
        if (yt && (St += Nt.length - St), Ch(k)) {
          if (r.slice(St).search(k)) {
            var re, ae = Nt;
            for (k.global || (k = Un(k.source, Xi(Ea.exec(k)) + "g")), k.lastIndex = 0; re = k.exec(ae); )
              var fe = re.index;
            Nt = Nt.slice(0, fe === p ? St : fe);
          }
        } else if (r.indexOf(Ye(k), St) != St) {
          var ze = Nt.lastIndexOf(k);
          ze > -1 && (Nt = Nt.slice(0, ze));
        }
        return Nt + _;
      }
      function Bd(r) {
        return r = Xi(r), r && co.test(r) ? r.replace($r, Da) : r;
      }
      var Nd = De(function(r, a, u) {
        return r + (u ? " " : "") + a.toUpperCase();
      }), Rh = Me("toUpperCase");
      function zu(r, a, u) {
        return r = Xi(r), a = u ? p : a, a === p ? jo(r) ? lh(r) : Ks(r) : r.match(a) || [];
      }
      var Bu = se(function(r, a) {
        try {
          return er(r, p, a);
        } catch (u) {
          return Ah(u) ? u : new si(u);
        }
      }), kd = ns(function(r, a) {
        return qi(a, function(u) {
          u = Po(u), so(r, u, Eh(r[u], r));
        }), r;
      });
      function Ud(r) {
        var a = r == null ? 0 : r.length, u = oi();
        return r = a ? Vi(r, function(_) {
          if (typeof _[1] != "function")
            throw new Xn(C);
          return [u(_[0]), _[1]];
        }) : [], se(function(_) {
          for (var k = -1; ++k < a; ) {
            var at = r[k];
            if (er(at[0], this, _))
              return er(at[1], this, _);
          }
        });
      }
      function Fd(r) {
        return Bs(rr(r, H));
      }
      function Ih(r) {
        return function() {
          return r;
        };
      }
      function Gd(r, a) {
        return r == null || r !== r ? a : r;
      }
      var Hd = Pi(), Wd = Pi(!0);
      function _r(r) {
        return r;
      }
      function Oh(r) {
        return P(typeof r == "function" ? r : rr(r, H));
      }
      function jd(r) {
        return mt(rr(r, H));
      }
      function Vd(r, a) {
        return bt(r, rr(a, H));
      }
      var Xd = se(function(r, a) {
        return function(u) {
          return e(u, r, a);
        };
      }), qd = se(function(r, a) {
        return function(u) {
          return e(r, u, a);
        };
      });
      function Dh(r, a, u) {
        var _ = Nn(a), k = ts(a, _);
        u == null && !(pn(a) && (k.length || !_.length)) && (u = a, a = r, r = this, k = ts(a, Nn(a)));
        var at = !(pn(u) && "chain" in u) || !!u.chain, yt = os(r);
        return qi(k, function(St) {
          var Nt = a[St];
          r[St] = Nt, yt && (r.prototype[St] = function() {
            var re = this.__chain__;
            if (at || re) {
              var ae = r(this.__wrapped__), fe = ae.__actions__ = Hn(this.__actions__);
              return fe.push({ func: Nt, args: arguments, thisArg: r }), ae.__chain__ = re, ae;
            }
            return Nt.apply(r, Br([this.value()], arguments));
          });
        }), r;
      }
      function Yd() {
        return ln._ === this && (ln._ = br), this;
      }
      function zh() {
      }
      function Zd(r) {
        return r = xi(r), se(function(a) {
          return W(a, r);
        });
      }
      var Jd = An(Vi), $d = An(il), Kd = An(Kr);
      function Nu(r) {
        return _h(r) ? go(Po(r)) : $t(r);
      }
      function Qd(r) {
        return function(a) {
          return r == null ? p : Ao(r, a);
        };
      }
      var tm = xl(), em = xl(!0);
      function Bh() {
        return [];
      }
      function Nh() {
        return !1;
      }
      function im() {
        return {};
      }
      function nm() {
        return "";
      }
      function rm() {
        return !0;
      }
      function om(r, a) {
        if (r = xi(r), r < 1 || r > ge)
          return [];
        var u = Dt, _ = In(r, Dt);
        a = oi(a), r -= Dt;
        for (var k = to(_, a); ++u < r; )
          a(u);
        return k;
      }
      function sm(r) {
        return gi(r) ? Vi(r, Po) : Cr(r) ? [r] : Hn(nu(Xi(r)));
      }
      function am(r) {
        var a = ++Yn;
        return Xi(r) + a;
      }
      var lm = or(function(r, a) {
        return r + a;
      }, 0), hm = qa("ceil"), um = or(function(r, a) {
        return r / a;
      }, 1), cm = qa("floor");
      function fm(r) {
        return r && r.length ? Xr(r, _r, ja) : p;
      }
      function pm(r, a) {
        return r && r.length ? Xr(r, oi(a, 2), ja) : p;
      }
      function dm(r) {
        return Ts(r, _r);
      }
      function mm(r, a) {
        return Ts(r, oi(a, 2));
      }
      function gm(r) {
        return r && r.length ? Xr(r, _r, et) : p;
      }
      function vm(r, a) {
        return r && r.length ? Xr(r, oi(a, 2), et) : p;
      }
      var ym = or(function(r, a) {
        return r * a;
      }, 1), _m = qa("round"), xm = or(function(r, a) {
        return r - a;
      }, 0);
      function wm(r) {
        return r && r.length ? yo(r, _r) : 0;
      }
      function Tm(r, a) {
        return r && r.length ? yo(r, oi(a, 2)) : 0;
      }
      return Q.after = jf, Q.ary = du, Q.assign = Rp, Q.assignIn = Cu, Q.assignInWith = eh, Q.assignWith = Ip, Q.at = Op, Q.before = mu, Q.bind = Eh, Q.bindAll = kd, Q.bindKey = gu, Q.castArray = ip, Q.chain = cu, Q.chunk = uc, Q.compact = cc, Q.concat = fc, Q.cond = Ud, Q.conforms = Fd, Q.constant = Ih, Q.countBy = wf, Q.create = Dp, Q.curry = vu, Q.curryRight = yu, Q.debounce = _u, Q.defaults = zp, Q.defaultsDeep = Bp, Q.defer = Vf, Q.delay = Xf, Q.difference = pc, Q.differenceBy = dc, Q.differenceWith = mc, Q.drop = gc, Q.dropRight = vc, Q.dropRightWhile = yc, Q.dropWhile = _c, Q.fill = xc, Q.filter = Mf, Q.flatMap = bf, Q.flatMapDeep = Af, Q.flatMapDepth = Cf, Q.flatten = au, Q.flattenDeep = wc, Q.flattenDepth = Tc, Q.flip = qf, Q.flow = Hd, Q.flowRight = Wd, Q.fromPairs = Mc, Q.functions = Wp, Q.functionsIn = jp, Q.groupBy = Pf, Q.initial = Ec, Q.intersection = bc, Q.intersectionBy = Ac, Q.intersectionWith = Cc, Q.invert = Xp, Q.invertBy = qp, Q.invokeMap = Rf, Q.iteratee = Oh, Q.keyBy = If, Q.keys = Nn, Q.keysIn = yr, Q.map = Zl, Q.mapKeys = Zp, Q.mapValues = Jp, Q.matches = jd, Q.matchesProperty = Vd, Q.memoize = $l, Q.merge = $p, Q.mergeWith = Pu, Q.method = Xd, Q.methodOf = qd, Q.mixin = Dh, Q.negate = Kl, Q.nthArg = Zd, Q.omit = Kp, Q.omitBy = Qp, Q.once = Yf, Q.orderBy = Of, Q.over = Jd, Q.overArgs = Zf, Q.overEvery = $d, Q.overSome = Kd, Q.partial = bh, Q.partialRight = xu, Q.partition = Df, Q.pick = td, Q.pickBy = Lu, Q.property = Nu, Q.propertyOf = Qd, Q.pull = Ic, Q.pullAll = hu, Q.pullAllBy = Oc, Q.pullAllWith = Dc, Q.pullAt = zc, Q.range = tm, Q.rangeRight = em, Q.rearg = Jf, Q.reject = Nf, Q.remove = Bc, Q.rest = $f, Q.reverse = Mh, Q.sampleSize = Uf, Q.set = id, Q.setWith = nd, Q.shuffle = Ff, Q.slice = Nc, Q.sortBy = Wf, Q.sortedUniq = jc, Q.sortedUniqBy = Vc, Q.split = bd, Q.spread = Kf, Q.tail = Xc, Q.take = qc, Q.takeRight = Yc, Q.takeRightWhile = Zc, Q.takeWhile = Jc, Q.tap = ff, Q.throttle = Qf, Q.thru = Yl, Q.toArray = Eu, Q.toPairs = Ru, Q.toPairsIn = Iu, Q.toPath = sm, Q.toPlainObject = Au, Q.transform = rd, Q.unary = tp, Q.union = $c, Q.unionBy = Kc, Q.unionWith = Qc, Q.uniq = tf, Q.uniqBy = ef, Q.uniqWith = nf, Q.unset = od, Q.unzip = Sh, Q.unzipWith = uu, Q.update = sd, Q.updateWith = ad, Q.values = Ja, Q.valuesIn = ld, Q.without = rf, Q.words = zu, Q.wrap = ep, Q.xor = of, Q.xorBy = sf, Q.xorWith = af, Q.zip = lf, Q.zipObject = hf, Q.zipObjectDeep = uf, Q.zipWith = cf, Q.entries = Ru, Q.entriesIn = Iu, Q.extend = Cu, Q.extendWith = eh, Dh(Q, Q), Q.add = lm, Q.attempt = Bu, Q.camelCase = fd, Q.capitalize = Ou, Q.ceil = hm, Q.clamp = hd, Q.clone = np, Q.cloneDeep = op, Q.cloneDeepWith = sp, Q.cloneWith = rp, Q.conformsTo = ap, Q.deburr = Du, Q.defaultTo = Gd, Q.divide = um, Q.endsWith = pd, Q.eq = ho, Q.escape = dd, Q.escapeRegExp = md, Q.every = Tf, Q.find = Sf, Q.findIndex = ou, Q.findKey = Np, Q.findLast = Ef, Q.findLastIndex = su, Q.findLastKey = kp, Q.floor = cm, Q.forEach = fu, Q.forEachRight = pu, Q.forIn = Up, Q.forInRight = Fp, Q.forOwn = Gp, Q.forOwnRight = Hp, Q.get = Ph, Q.gt = lp, Q.gte = hp, Q.has = Vp, Q.hasIn = Lh, Q.head = lu, Q.identity = _r, Q.includes = Lf, Q.indexOf = Sc, Q.inRange = ud, Q.invoke = Yp, Q.isArguments = Ta, Q.isArray = gi, Q.isArrayBuffer = up, Q.isArrayLike = vr, Q.isArrayLikeObject = Sn, Q.isBoolean = cp, Q.isBuffer = Gs, Q.isDate = fp, Q.isElement = pp, Q.isEmpty = dp, Q.isEqual = mp, Q.isEqualWith = gp, Q.isError = Ah, Q.isFinite = vp, Q.isFunction = os, Q.isInteger = wu, Q.isLength = Ql, Q.isMap = Tu, Q.isMatch = yp, Q.isMatchWith = _p, Q.isNaN = xp, Q.isNative = wp, Q.isNil = Mp, Q.isNull = Tp, Q.isNumber = Mu, Q.isObject = pn, Q.isObjectLike = wn, Q.isPlainObject = Sl, Q.isRegExp = Ch, Q.isSafeInteger = Sp, Q.isSet = Su, Q.isString = th, Q.isSymbol = Cr, Q.isTypedArray = Za, Q.isUndefined = Ep, Q.isWeakMap = bp, Q.isWeakSet = Ap, Q.join = Pc, Q.kebabCase = gd, Q.last = Zr, Q.lastIndexOf = Lc, Q.lowerCase = vd, Q.lowerFirst = yd, Q.lt = Cp, Q.lte = Pp, Q.max = fm, Q.maxBy = pm, Q.mean = dm, Q.meanBy = mm, Q.min = gm, Q.minBy = vm, Q.stubArray = Bh, Q.stubFalse = Nh, Q.stubObject = im, Q.stubString = nm, Q.stubTrue = rm, Q.multiply = ym, Q.nth = Rc, Q.noConflict = Yd, Q.noop = zh, Q.now = Jl, Q.pad = _d, Q.padEnd = xd, Q.padStart = wd, Q.parseInt = Td, Q.random = cd, Q.reduce = zf, Q.reduceRight = Bf, Q.repeat = Md, Q.replace = Sd, Q.result = ed, Q.round = _m, Q.runInContext = At, Q.sample = kf, Q.size = Gf, Q.snakeCase = Ed, Q.some = Hf, Q.sortedIndex = kc, Q.sortedIndexBy = Uc, Q.sortedIndexOf = Fc, Q.sortedLastIndex = Gc, Q.sortedLastIndexBy = Hc, Q.sortedLastIndexOf = Wc, Q.startCase = Ad, Q.startsWith = Cd, Q.subtract = xm, Q.sum = wm, Q.sumBy = Tm, Q.template = Pd, Q.times = om, Q.toFinite = ss, Q.toInteger = xi, Q.toLength = bu, Q.toLower = Ld, Q.toNumber = Jr, Q.toSafeInteger = Lp, Q.toString = Xi, Q.toUpper = Rd, Q.trim = Id, Q.trimEnd = Od, Q.trimStart = Dd, Q.truncate = zd, Q.unescape = Bd, Q.uniqueId = am, Q.upperCase = Nd, Q.upperFirst = Rh, Q.each = fu, Q.eachRight = pu, Q.first = lu, Dh(Q, function() {
        var r = {};
        return gr(Q, function(a, u) {
          wi.call(Q.prototype, u) || (r[u] = a);
        }), r;
      }(), { chain: !1 }), Q.VERSION = $, qi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(r) {
        Q[r].placeholder = Q;
      }), qi(["drop", "take"], function(r, a) {
        yi.prototype[r] = function(u) {
          u = u === p ? 1 : hn(xi(u), 0);
          var _ = this.__filtered__ && !a ? new yi(this) : this.clone();
          return _.__filtered__ ? _.__takeCount__ = In(u, _.__takeCount__) : _.__views__.push({
            size: In(u, Dt),
            type: r + (_.__dir__ < 0 ? "Right" : "")
          }), _;
        }, yi.prototype[r + "Right"] = function(u) {
          return this.reverse()[r](u).reverse();
        };
      }), qi(["filter", "map", "takeWhile"], function(r, a) {
        var u = a + 1, _ = u == D || u == Ct;
        yi.prototype[r] = function(k) {
          var at = this.clone();
          return at.__iteratees__.push({
            iteratee: oi(k, 3),
            type: u
          }), at.__filtered__ = at.__filtered__ || _, at;
        };
      }), qi(["head", "last"], function(r, a) {
        var u = "take" + (a ? "Right" : "");
        yi.prototype[r] = function() {
          return this[u](1).value()[0];
        };
      }), qi(["initial", "tail"], function(r, a) {
        var u = "drop" + (a ? "" : "Right");
        yi.prototype[r] = function() {
          return this.__filtered__ ? new yi(this) : this[u](1);
        };
      }), yi.prototype.compact = function() {
        return this.filter(_r);
      }, yi.prototype.find = function(r) {
        return this.filter(r).head();
      }, yi.prototype.findLast = function(r) {
        return this.reverse().find(r);
      }, yi.prototype.invokeMap = se(function(r, a) {
        return typeof r == "function" ? new yi(this) : this.map(function(u) {
          return e(u, r, a);
        });
      }), yi.prototype.reject = function(r) {
        return this.filter(Kl(oi(r)));
      }, yi.prototype.slice = function(r, a) {
        r = xi(r);
        var u = this;
        return u.__filtered__ && (r > 0 || a < 0) ? new yi(u) : (r < 0 ? u = u.takeRight(-r) : r && (u = u.drop(r)), a !== p && (a = xi(a), u = a < 0 ? u.dropRight(-a) : u.take(a - r)), u);
      }, yi.prototype.takeRightWhile = function(r) {
        return this.reverse().takeWhile(r).reverse();
      }, yi.prototype.toArray = function() {
        return this.take(Dt);
      }, gr(yi.prototype, function(r, a) {
        var u = /^(?:filter|find|map|reject)|While$/.test(a), _ = /^(?:head|last)$/.test(a), k = Q[_ ? "take" + (a == "last" ? "Right" : "") : a], at = _ || /^find/.test(a);
        k && (Q.prototype[a] = function() {
          var yt = this.__wrapped__, St = _ ? [1] : arguments, Nt = yt instanceof yi, re = St[0], ae = Nt || gi(yt), fe = function(Ci) {
            var Bi = k.apply(Q, Br([Ci], St));
            return _ && ze ? Bi[0] : Bi;
          };
          ae && u && typeof re == "function" && re.length != 1 && (Nt = ae = !1);
          var ze = this.__chain__, Je = !!this.__actions__.length, li = at && !ze, Ti = Nt && !Je;
          if (!at && ae) {
            yt = Ti ? yt : new yi(this);
            var hi = r.apply(yt, St);
            return hi.__actions__.push({ func: Yl, args: [fe], thisArg: p }), new Dn(hi, ze);
          }
          return li && Ti ? r.apply(this, St) : (hi = this.thru(fe), li ? _ ? hi.value()[0] : hi.value() : hi);
        });
      }), qi(["pop", "push", "shift", "sort", "splice", "unshift"], function(r) {
        var a = Tn[r], u = /^(?:push|sort|unshift)$/.test(r) ? "tap" : "thru", _ = /^(?:pop|shift)$/.test(r);
        Q.prototype[r] = function() {
          var k = arguments;
          if (_ && !this.__chain__) {
            var at = this.value();
            return a.apply(gi(at) ? at : [], k);
          }
          return this[u](function(yt) {
            return a.apply(gi(yt) ? yt : [], k);
          });
        };
      }), gr(yi.prototype, function(r, a) {
        var u = Q[a];
        if (u) {
          var _ = u.name + "";
          wi.call(Mo, _) || (Mo[_] = []), Mo[_].push({ name: a, func: u });
        }
      }), Mo[Yi(p, d).name] = [{
        name: "wrapper",
        func: p
      }], yi.prototype.clone = Rs, yi.prototype.reverse = Dl, yi.prototype.value = Is, Q.prototype.at = pf, Q.prototype.chain = df, Q.prototype.commit = mf, Q.prototype.next = gf, Q.prototype.plant = yf, Q.prototype.reverse = _f, Q.prototype.toJSON = Q.prototype.valueOf = Q.prototype.value = xf, Q.prototype.first = Q.prototype.head, To && (Q.prototype[To] = vf), Q;
    }, xo = hh();
    Mr ? ((Mr.exports = xo)._ = xo, po._ = xo) : ln._ = xo;
  }).call(xr);
})(oh, oh.exports);
var Km = oh.exports;
const Fh = /* @__PURE__ */ Wh(Km);
class ag {
  constructor(J, p = [], $ = !1) {
    /**
     * 矢量数据简化
     * @param {*} geojson  geojson数据
     * @returns  { Object }
     */
    kh(this, "simplifyFunc", (J) => {
      try {
        J = turf.simplify(J, {
          tolerance: 5e-4,
          highQuality: !1,
          mutate: !0
        });
      } catch {
      }
      return J;
    });
    mars3d ? (this.map = J, this.vectorArr = p, this.geoJsonType = /* @__PURE__ */ new Map([
      ["Point"],
      ["LineString"],
      ["Polygon"],
      ["MultiPoint"],
      ["MultiLineString"],
      ["MultiPolygon"]
    ]), this.avoidanceArr = [], this.editDate = {
      id: ""
    }, this.isDynamicMasking = $) : console.error("未引入指定插件");
  }
  /**
   * 移除矢量数据
   * @param  { String } id 矢量数据id
   *
   */
  remove(J) {
    this.map.removeLayer(this.map.getLayer(J, "vectorId")), window.dynamicMasking.remove(J);
  }
  /**
   * add 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  add(J, p) {
    return new Promise(($, G) => {
      let m;
      if (typeof J != "object") {
        let H = this.map.getLayer(J, "vectorId");
        if (H)
          return $(H);
        m = this.query(J);
      } else {
        let H = this.map.getLayer(J.id, "vectorId");
        if (H)
          return $(H);
        m = J;
      }
      let { value: C, url: O, id: E, title: U } = m;
      new Cesium.Resource({
        url: O
      }).fetchJson().then((H) => {
        let { id: K, title: B, shpInfo: q } = m, { attributes: b, geometryType: A, geometryCount: d, pointCount: g } = q, {
          width: M,
          materialType: x,
          materialOptions: F,
          clampToGround: z,
          distanceDisplayCondition: V,
          distanceDisplayCondition_near: ht,
          distanceDisplayCondition_far: ft,
          zIndex: gt,
          label: zt,
          fill: lt,
          diffHeight: Et,
          outline: D,
          outlineStyle: Bt,
          color: Ct,
          pixelSize: Rt,
          outlineColor: ge,
          outlineWidth: ue
        } = JSON.parse(b), Ft;
        switch (console.log("geometryType", A), this.isDynamicMasking ? (zt.color = Cesium.Color.fromCssColorString(
          zt.color
        ).withAlpha(0), zt.outlineColor = Cesium.Color.fromCssColorString(
          zt.outlineColor
        ).withAlpha(1e-3), zt.backgroundColor = Cesium.Color.fromCssColorString(
          zt.backgroundColor
        ).withAlpha(1e-3), zt.background = !1, zt.outline = !1, zt.show = !1) : (zt.color = Cesium.Color.fromCssColorString(zt.color), zt.outlineColor = Cesium.Color.fromCssColorString(
          zt.outlineColor
        ), zt.backgroundColor = Cesium.Color.fromCssColorString(
          zt.backgroundColor
        )), A) {
          case "LineString":
          case "MultiLineString":
            zt.backgroundPadding = 5, Ft = new mars3d.layer.GeoJsonLayer({
              data: H,
              vectorId: K,
              format: g > 1e4 ? this.simplifyFunc : null,
              symbol: {
                type: "polylineC",
                styleOptions: {
                  width: M,
                  clampToGround: z,
                  distanceDisplayCondition: V,
                  distanceDisplayCondition_far: ft,
                  distanceDisplayCondition_near: ht,
                  materialType: x,
                  materialOptions: F,
                  label: zt
                }
              },
              popup: `&nbsp;&nbsp; ${B} &nbsp;&nbsp;`,
              hasZIndex: !0,
              zIndex: gt
            });
            break;
          case "Polygon":
          case "MultiPolygon":
            x == "PolyGrass" && (F = {
              evenColor: new Cesium.Color(0.25, 0.4, 0.1, 1),
              oddColor: new Cesium.Color(0.1, 0.1, 0.1, 1),
              frequency: 1.5
              // 斑驳
            }), Ft = new mars3d.layer.GeoJsonLayer({
              data: H,
              vectorId: K,
              format: g > 1e4 ? this.simplifyFunc : null,
              symbol: {
                type: "polygon",
                styleOptions: {
                  fill: lt,
                  diffHeight: Et,
                  clampToGround: z,
                  materialType: x,
                  materialOptions: F,
                  distanceDisplayCondition: V,
                  distanceDisplayCondition_far: ft,
                  distanceDisplayCondition_near: ht,
                  outlineStyle: Bt,
                  outline: D,
                  label: zt
                }
              },
              popup: `&nbsp;&nbsp; ${B} &nbsp;&nbsp;`
            });
            break;
          case "Point":
          case "MultiPoint":
            Ft = new mars3d.layer.GeoJsonLayer({
              data: H,
              vectorId: K,
              format: g > 1e4 ? this.simplifyFunc : null,
              symbol: {
                type: "pointP",
                styleOptions: {
                  color: Ct,
                  pixelSize: Rt,
                  outline: D,
                  outlineColor: ge,
                  outlineWidth: ue,
                  visibleDepth: !1,
                  label: zt
                }
              }
            });
            break;
        }
        window.map.addLayer(Ft), Ft.bindPopup((kt) => {
          console.log("event", kt);
        });
        let Dt = Fh.debounce((kt) => {
          console.log("测试shp矢量加载完成"), window.dynamicMasking.add(kt, JSON.parse(b));
        }, 500);
        Ft.readyPromise.then((kt) => {
          Dt(kt), $(kt);
        }).catch((kt) => {
          console.error("测试shp矢量加载失败", kt), $({
            tite: "【矢量】" + modelTitle + "加载失败",
            type: "error",
            id: modelId,
            url: O
          });
        });
      }).catch((H) => {
        console.error("数据有误", H), $({
          tite: "【矢量】" + modelTitle + "数据有误",
          type: "error",
          id: modelId,
          url: O
        });
      });
    });
  }
  /**
   * 更新 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData(J) {
    this.vectorArr = J;
  }
  /**
   * 处理kml数据
   * @param  { Object } item 查询出来的对象
   * @returns { Object } 样式对象
   */
  processingKML(J) {
    let p, $ = 2e3, G = !0, { kmlInfo: m } = J, {
      fill: C,
      areaColor: O,
      areaSideColor: E,
      transparency: U,
      isAreaSideColor: Y,
      minDistinct: H,
      textDistinct: K,
      textSize: B,
      textColor: q,
      fontStyle: b,
      outLine: A,
      sideColor: d,
      backGround: g,
      backGroundColor: M,
      clampToGround: x
    } = m;
    console.log("minDistinct", H);
    let F = {
      fill: C,
      color: O,
      opacity: U || 0.5,
      outline: Y,
      outlineColor: E,
      outlineWidth: 2,
      clampToGround: x,
      // distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1000000),
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: K || 1e6,
      distanceDisplayCondition_near: H || 0,
      classificationType: p,
      opacity: String(U)
    }, z = {
      text: "{name}",
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      pixelOffsetY: -10,
      font_size: 26,
      color: q || "#ffffff",
      font_family: b || "黑体",
      outline: A || !0,
      outlineColor: d || "#000000",
      outlineWidth: 4,
      scaleByDistance: !0,
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: K || 1e6,
      distanceDisplayCondition_near: H || 0,
      background: g || !1,
      backgroundColor: M || "",
      visibleDepth: G,
      clampToGround: x || !1,
      disableDepthTestDistance: $
    };
    return {
      ...F,
      label: z
    };
  }
  /**
   * 选中矢量
   * @param  { String } id 模型id
   *
   */
  selected(J) {
    this.map.getLayer(J, "vectorId").flyTo();
  }
  /**
   * 查询矢量数据的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(J) {
    return this.vectorArr.length == 0 ? !1 : this.vectorArr.find((p) => p.id == J);
  }
  /**
   * 批量编辑矢量
   * @param  { String } id 对象id
   * @param  { Object } vector 矢量对象
   * @param  { Object } label  注记对象
   * @returns { Object }
   */
  editVector(J, p, $) {
    let G = this.map.getLayer(J, "vectorId"), m = Hu(p, $);
    console.log("编辑数据", m), G && (G.eachGraphic((C) => {
      C.label.show === !1 && (delete C.label.outline, delete C.label.background, delete C.label.outlineColor, delete C.label.backgroundColor), C.setStyle({
        ...m
      });
    }), dynamicMasking.modify(J, m));
  }
  /**
   * 加载国家边界线
   *
   * @returns { any }
   */
  nationalBoundaries() {
    let J = "/gis/nationalBoundaries.json", p = new mars3d.layer.GeoJsonLayer({
      name: "国界",
      url: J,
      format: ($) => {
        try {
          $ = turf.simplify($, {
            tolerance: 1e-5,
            highQuality: !1,
            mutate: !0
          });
        } catch (G) {
          console.error(G);
        }
        return $;
      },
      symbol: {
        type: "polylineC",
        styleOptions: {
          width: 2,
          materialType: "Color",
          materialOptions: {
            color: "#CD9B1D"
          },
          distanceDisplayCondition: !0,
          distanceDisplayCondition_near: 1e3,
          distanceDisplayCondition_far: 2e7,
          clampToGround: !0,
          classificationType: Cesium.ClassificationType.TERRAIN
        }
      }
    });
    map.addLayer(p);
  }
  /**
   * 切换动态避让
   * @returns { any }
   */
  switchDynamicMasking(J) {
    this.isDynamicMasking = J;
  }
}
class lg {
  constructor(J, p = []) {
    mars3d ? (this.map = J, this.terrainProviderArr = p, this.terrainProviderId = "", this.events = {}, this.map.on(mars3d.EventType.terrainLoadError, ($) => {
      console.error("地形服务加载失败", $), this.hide();
    }), this.map.viewer.scene.globe.tileLoadProgressEvent.addEventListener(
      ($) => {
        this.map.viewer.scene.globe.tilesLoaded && this.emit("load", $);
      }
    )) : console.error("未引入指定插件");
  }
  /**
   * add 添加地形
   * @param  { Object || String } terrainProviderParameter 地形属性 或者 地形id
   */
  add(J) {
    let { url: p, id: $ } = J;
    if (this.terrainProviderId == $ && this.map.terrainProvider._layers)
      return !1;
    this.map.terrainProvider = mars3d.LayerUtil.createTerrainProvider({
      imageXyzId: $,
      type: "xyz",
      url: p,
      //item.gisInfo.gisUrl,
      requestVertexNormals: !0,
      requestMetadata: !0
    }), this.terrainProviderId = $;
  }
  /**
   * 开启地形
   *
   */
  show() {
    this.map.hasTerrain = !0;
  }
  /**
   * 隐藏地形
   *
   */
  hide() {
    this.map.hasTerrain = !1;
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(J, p) {
    J == "load" ? this.events[J] ? this.events[J].push(p) : this.events[J] = [p] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(J, ...p) {
    this.events[J] != null && this.events[J].forEach(($) => $(...p));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(J, p) {
    this.events[J] = this.events[J].filter(($) => $ !== p);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(J, p) {
    const $ = () => {
      p(), this.off(J, $);
    };
    this.on(J, $);
  }
  /**
   * 地形裁剪
   */
  addClip(J) {
    return new Promise((p, $) => {
      window.bimClip ? p(bimClip.clipGisAdd(J)) : $("挖洞工具未初始化");
    });
  }
}
class hg {
  constructor(J, p = []) {
    mars3d ? (this.map = J, this.elevationImageArr = p, this.elevationImageLayer, this.form = {
      brightnessVal: 1.3,
      //环境亮度配置
      msaaSamples: 4,
      //反锯齿配置
      surfaceOpacity: 1,
      //地表不透明度
      layerOpacity: 1,
      //瓦片透明度
      layerBrightness: 2,
      //瓦片亮度
      layerContrast: 1,
      //瓦片对比度
      layerHue: 0,
      //瓦片色彩
      layerSaturation: 1,
      //瓦片饱和度
      layerGamma: 1
      //瓦片伽马值
    }) : console.error("未引入指定插件");
  }
  /**
   * 给影像数组添加数据
   * @param  { Object } data 集合数据
   */
  pushVector(J) {
    this.elevationImageArr.push(J);
  }
  /**
   * 添加影像
   * @param  { Object || String } xyzParameter 影像属性 或者 影像id
   * @param  { Object } fn 监听函数
   *
   */
  add(J, p) {
    let $;
    if (typeof J != "object" ? $ = J : $ = J.imageXyzId, this.map.getLayer($, "imageXyzId"))
      return !1;
    const {
      layerOpacity: G,
      layerBrightness: m,
      layerContrast: C,
      layerHue: O,
      layerSaturation: E,
      layerGamma: U,
      surfaceOpacity: Y
    } = this.exposureEnvironmentSettings();
    return new Promise((H, K) => {
      let B, q, b, A, d;
      if (typeof J != "object") {
        let g = this.query(J);
        g || K("缺少树结构");
        let { gisInfo: M } = g;
        B = M.id, b = M.order, q = g.url, A = M.minLevel, d = M.maxLevel;
      } else
        B = J.imageXyzId, q = J.url, b = J.zIndex, A = J.minimumLevel, d = J.maximumLevel;
      this.elevationImageLayer = new mars3d.layer.XyzLayer({
        imageXyzId: B,
        type: "xyz",
        url: q,
        //item.gisUrl,
        hasZIndex: !0,
        //是否可以调整图层顺序（在同类型图层间）
        zIndex: b.toString(),
        //图层顺序，数字大的在上面。（当hasZIndex为true时）
        brightness: m,
        //亮度0.0-1.0。
        opacity: G,
        saturation: E,
        contrast: C,
        hue: O,
        gamma: U,
        alpha: Y,
        show: !0,
        minimumLevel: A || 0,
        maximumLevel: d || 15
      }), this.elevationImageLayer.on(mars3d.EventType.load, (g) => {
        H(g);
      }), this.map.addLayer(this.elevationImageLayer), p && Object.keys(p).forEach((g) => {
        this.elevationImageLayer.on(fnType.get(g), (M) => {
          p[g](M);
        });
      });
    });
  }
  /**
   * 移除影像方法
   * @param  { String } id 影像id
   *
   */
  remove(J) {
    console.log(J), this.map.removeLayer(this.map.getLayer(J, "imageXyzId"));
  }
  /**
   * 查询影像方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的对象 或者 false
   */
  query(J) {
    return this.elevationImageArr.length == 0 ? !1 : this.elevationImageArr.find((p) => p.id == J);
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.elevationImageArr = [], this.elevationImageLayer = null;
  }
  /**
   *
   * 是否读取本地化数据 来初始化地球
   * @returns { any }
   */
  exposureEnvironmentSettings() {
    return localStorage.getItem("environmentSettings") ? JSON.parse(localStorage.getItem("environmentSettings")) : (localStorage.setItem("environmentSettings", JSON.stringify(this.form)), JSON.parse(JSON.stringify(this.form)));
  }
}
class ug {
  constructor(J, p, ...$) {
    /**
     * 手动释放 1秒防抖
     * @param  { object } data - 模型的树形结构
     * @returns { any }
     */
    kh(this, "manualFreed", Fh.debounce(() => {
      let { lng: J, lat: p, alt: $, pitch: G } = this.map.getCameraView(), m;
      this.modelArray.forEach((C) => {
        m = C.releasedDistance ? C.releasedDistance : 1e4, this.disTance(
          [J, p, $],
          [C.center._lng, C.center._lat, C.center._alt],
          this.calculateDistance(G, m)
        ) ? this.map.getLayer(C.id, "modelId") && this.emit("leave", C) : this.map.getLayer(C.id, "modelId") || this.emit("enter", C);
      });
    }, 200));
    mars3d ? (J && J != null && (this.modelArray = J), this.showModelArray = [], p && p != null && (this.map = p), this.Cesium = mars3d.Cesium, this.events = {}) : console.error("未引入指定插件");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(J, p) {
    J == "enter" || J == "leave" ? this.events[J] ? this.events[J].push(p) : this.events[J] = [p] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(J, ...p) {
    this.events[J] != null && this.events[J].forEach(($) => $(...p));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(J, p) {
    this.events[J] = this.events[J].filter(($) => $ !== p);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(J, p) {
    const $ = () => {
      p(), this.off(J, $);
    };
    this.on(J, $);
  }
  /**
   * modelArray
   * 读取数据
   * @param  { string | number } key - 需要查询对象的key 目前只有 modelArray 和 showModelIdArray
   * @returns { any }
   */
  say(J) {
    return this[J];
  }
  /**
   * modelArray
   * 添加数据
   * @param  { string | number } key - 需要添加对象的key 目前只有 modelArray 和 showModelArray
   * @param  { object | array } item - 添加的数据item
   * @returns { any }
   */
  add(J, p) {
    this[J].push(p);
  }
  /**
   * modelArray
   * 移除数据
   * @param  { string | number } key - 需要添加对象的key 目前只有 showModelArray
   * @param  { object | array } item - 添加的数据item
   * @returns { any }
   */
  remove(J, p) {
    this[J] = this[J].filter(function($) {
      return $ !== p;
    });
  }
  /**
   * modelArray && events
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArray = [], this.events = {};
  }
  /**
   * 工具函数
   * modelArray - excavationDetails
   * 更新 modelArray 自定义属性 excavationDetails
   * @param  { string } parentId - 模型id
   * @param  { string } id - 自己实例的id
   * @param  { string } type - update | delete | add | edit 操作类型
   * @param  { object | array } data - 更新的数据
   * @returns { object }
   */
  updateCustomExcavationDetails(J, p, $, G = [], m = {}) {
    let C, O, E;
    switch (C = this.modelArray.find((U) => U.modelId == J).customize.bimModelExcavationDetails, E = C.find((U, Y) => {
      if (U.id == p)
        return O = Y, U;
    }), $) {
      case "delete":
        C.splice(O, 1);
        break;
      case "update":
        E.excavationDetails = G;
        break;
      case "add":
        C.push(m);
        break;
      case "edit":
        E.excavationDetails = m.excavationDetails, E.kId = m.kId;
        break;
    }
    return C;
  }
  /**
   * 工具函数
   * 开启视角监听事件 调用freed来实现动态释放逻辑
   * @param  { object } data - 模型的树形结构 重要数据
   * @returns { any }
   */
  resourceRelease() {
    this.map.viewer.camera.moveEnd.addEventListener(() => {
      this.freed();
    });
  }
  /**
   * 功能函数
   * 动态释放的主要逻辑
   * @param  { object } data - 模型的树形结构
   * @returns { any }
   */
  freed() {
    let { alt: J } = this.map.getCameraView();
    J < 2e4 && (this.freed = Fh.throttle(() => {
      let { lng: p, lat: $, alt: G, pitch: m } = this.map.getCameraView();
      this.modelArray && this.modelArray.forEach((C) => {
        let O = C.bimModel.releasedDistance ? C.bimModel.releasedDistance : 1e4;
        C.center && this.disTance(
          [p, $, G],
          [C.center._lng, C.center._lat, C.center._alt],
          this.calculateDistance(m, O)
        ) ? this.map.getLayer(C.id, "modelId") && this.emit("leave", C) : this.showModelArray.indexOf(C.id) >= 0 && !this.map.getLayer(C.id, "modelId") && this.emit("enter", C);
      });
    }, 2e3), this.freed());
  }
  /**
   * 通过id查询对象
   * @param  { object } data - 模型的树形结构
   * @param  { string } id - 模型id
   * @param  { string } type - 查找类型
   * @returns { boolean }
   */
  findPnodeId(J, p, $ = "id") {
    let G;
    if (J) {
      for (var m = 0; m < J.length; m++) {
        let C = J[m];
        if (C[$] == p)
          return G = C, G;
        if (C.children && C.children.length > 0 && (G = this.findPnodeId(C.children, p, $), G))
          return G;
      }
      return G;
    }
  }
  /**
   * modelArray
   * 动态释放的计算方法
   * @param  { array } positionsStart - 起始坐标
   * @param  { array } positionsEnd - 结束坐标
   * @param  { number } limit - 设置的长度
   * @returns { boolean }
   */
  disTance(J, p, $) {
    let G, m, C;
    return G = Cesium.Cartesian3.fromDegrees(...J), m = Cesium.Cartesian3.fromDegrees(...p), C = Cesium.Cartesian3.distance(G, m), C > $;
  }
  /**
   * @function 获取模型的可视范围
   * @param { number } angle 当前角度
   * @param { number } maxDistance 最大可视距离
   * @returns { number } 当前可视距离
   * */
  calculateDistance(J, p) {
    let $ = (J + 180) % 360 - 180;
    $ = Math.max(-90, Math.min($, 90));
    let G = (p - p / 5) * (Math.abs($) / 90) + p / 5;
    return Math.round(G);
  }
}
class cg {
  constructor(J, p = [], $) {
    mars3d ? (this.map = J, this.entityArr = p, this.entityLayer = J.getLayer("bimEntity", "entityId"), this.entityItem = null, this.events = {}) : console.error("未引入指定插件");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on(J, p) {
    J == "change" ? this.events[J] ? this.events[J].push(p) : this.events[J] = [p] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit(J, ...p) {
    this.events[J] != null && this.events[J].forEach(($) => $(...p));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(J, p) {
    this.events[J] = this.events[J].filter(($) => $ !== p);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once(J, p) {
    const $ = () => {
      p(), this.off(J, $);
    };
    this.on(J, $);
  }
  /**
   * 添加标会实例
   * @param  { String } modelParameter 标绘实例id 或者 标绘参数
   *
   */
  add(J, p) {
    return new Promise(($, G) => {
      var m;
      if (this.entityLayer) {
        let C, O, E;
        if (typeof J != "object" ? (C = this.entityLayer.getGraphicByAttr(
          J,
          "entityId"
        ), O = this.query(J), E = JSON.parse(O.bimPlanPainting.graphic), E.attr = E.attr || {}, E.attr.entityId = E.attr.entityId || J) : (C = this.entityLayer.getGraphicByAttr(
          J.id,
          "entityId"
        ), E = JSON.parse(JSON.stringify(J)), E.attr = E.attr || {}, E.attr.entityId = E.attr.entityId || p, E.attr == null ? E.attr = {
          entityId: J
        } : ((m = E.attr) == null ? void 0 : m.entityId) == null && p && (E.attr.entityId = p)), C)
          return $();
        console.log(E), this.entityLayer.addGraphic(E), $(E);
      } else
        $(), console.error("未初始化标绘实例图层");
    });
  }
  /**
   * 查询矢量数据的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query(J) {
    return this.entityArr.length == 0 ? !1 : this.entityArr.find((p) => p.id == J);
  }
  /**
   * 查询矢量数据的实体
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 返回标绘实体
   */
  queryEntity(J) {
    if (bimEntity.entityLayer)
      return bimEntity.entityLayer.getGraphicByAttr(J, "entityId");
  }
  /**
   * 选中标绘
   * @param  { String } id 模型id
   *
   */
  selected(J) {
    let p = this.entityLayer.getGraphicByAttr(J, "entityId");
    p._point && p._point._alt > 0 ? p.flyTo({
      radius: p._point._alt + 500
    }) : p.flyTo();
  }
  /**
   * 移除标绘
   * @param  { String } id 模型id
   *
   */
  remove(J) {
    this.entityLayer.getGraphicByAttr(J, "entityId") && (this.entityLayer.getGraphicByAttr(J, "entityId").remove(), this.entityItem && this.entityItem.options.attr.entityId == J && (this.entityItem = null));
  }
  /**
   * 移除当前标绘对象
   * @param  { String } id 模型id
   *
   */
  removeEntityItem() {
    this.entityItem = null;
  }
  /**
   * 更新 矢量数据集合
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData(J) {
    this.entityArr = J;
  }
  /**
   * 开始绘制标绘
   * @param  { Object } data 标绘参数
   *
   */
  startDrawGraphic(J) {
    let { type: p, style: $ } = J;
    if (p == "div") {
      let {
        title: G,
        divType: m,
        theme_color: C,
        font_color: O,
        scaleByDistance: E,
        scaleByDistance_far: U,
        scaleByDistance_farValue: Y,
        scaleByDistance_near: H,
        scaleByDistance_nearValue: K,
        distanceDisplayCondition: B,
        distanceDisplayCondition_far: q,
        distanceDisplayCondition_near: b,
        clampToGround: A
      } = $, d = {
        type: "div",
        style: {
          pointerEvents: !0,
          scaleByDistance: E,
          scaleByDistance_far: U,
          scaleByDistance_farValue: Y,
          scaleByDistance_near: H,
          scaleByDistance_nearValue: K,
          distanceDisplayCondition: B,
          distanceDisplayCondition_far: q,
          distanceDisplayCondition_near: b,
          clampToGround: A,
          horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM
        }
      };
      switch (m) {
        case "1":
          d.style.html = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${C};--theme-font-color1:${O};">
            <div class="title">${G}</div>
          </div>`, d.style.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
          break;
      }
      this.entityLayer.startDraw(d).then((g) => {
        setTimeout(() => {
          this.entityItem = g, this.entityLayer.startEditing(g);
        }, 500);
      });
    } else
      console.log(J), this.entityLayer.startDraw(J).then((G) => {
        setTimeout(() => {
          this.entityItem = G, this.entityLayer.startEditing(G);
        }, 500);
      });
  }
  /**
   * 停止绘制标绘
   *
   */
  stopDraw(J = !0) {
    this.entityLayer && this.entityLayer.stopDraw(), J && this.entityItem && (this.entityItem.stopEditing(), this.entityItem.remove(), this.entityItem = null);
  }
  /**
   * 更新标绘
   * @param  { Object } data 标绘参数
   *
   */
  updateEntityItem(J) {
    let p = this.entityLayer.getGraphicByAttr(J, "entityId");
    p && (this.entityItem = p);
  }
  /**
   * 编辑标绘
   * @param  { String | Number } id 标绘id或者是edit新建标绘
   * @param  { Object } vector 标绘主体
   * @param  { Object } label 标绘label
   * @param  { String } 自定义类型 目前有div
   */
  edit(J, p, $, G) {
    let m = Hu(p, $);
    p.vectorStyle && this.entityItem && (console.log("edit", p.vectorStyle.divType, this.entityItem), p.vectorStyle.divType == 5 ? this.entityItem.setStyle({
      ...m,
      horizontalOrigin: Cesium.HorizontalOrigin.LEFT
    }) : (console.log("newStyle", m), this.entityItem.setStyle({
      ...m
      // horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
    })));
  }
  /**
   * 开启拖动/关闭拖动
   * @param  { Boolean } isEnableDragging 是否开启
   */
  enableDragging(J = !0) {
    J ? this.entityLayer.startEditing(this.entityItem) : (this.entityLayer.stopDraw(), this.entityItem && this.entityItem.stopEditing());
  }
  /**
   * 添加右键菜单
   *
   */
  addRightMenu() {
    this.entityLayer.bindContextMenu([
      {
        text: "编辑对象",
        callback: (J) => {
          this.emit("change", J);
        }
      }
    ]);
  }
  /**
   * 移除右键菜单
   *
   */
  removeRightMenu() {
    this.entityLayer.hasContextMenu() && this.entityLayer.unbindContextMenu();
  }
  /**
   * 解耦div数据
   * @param  { String } htmlString HTML字符串
   * @returns { Object } 返回的是表单数据
   */
  processDivData(J) {
    let p = {
      "--theme-color1": "theme_color",
      "--theme-font-color1": "font_color",
      "--theme-color2": "theme_color2",
      "--theme-color3": "theme_color3"
    }, $ = {
      title: "",
      theme_color: "",
      font_color: "",
      content: "",
      divType: "",
      divStyle: {}
    };
    const G = document.createElement("div");
    G.innerHTML = J;
    const m = G.querySelector(".entity-div-style");
    return console.log("解耦", m), Object.keys(p).forEach((C) => {
      C == "--theme-color2" || C == "--theme-color3" ? $.divStyle[p[C]] = m.style.getPropertyValue(C) || "#fff" : $[p[C]] = m.style.getPropertyValue(C);
    }), $.title = m.querySelector(".title") ? m.querySelector(".title").innerText : "标题", $.content = m.querySelector(".content") ? m.querySelector(".content").innerText : "内容", $.divType = m.classList[1] ? m.classList[1].replace("entity-div-style", "") : "", $;
  }
  /**
   * 更新html数据
   * @param  { String } divType 类型
   * @param  { Object } list 配合类型的样式参数
   * @returns { Object } html 字符串
   */
  updateHtml(J, p) {
    let { theme_color: $, font_color: G, title: m, content: C, divStyle: O } = p, { theme_color2: E, theme_color3: U } = O, Y = "";
    switch (J) {
      case "1":
        Y = `<div class="entity-div-style entity-div-style1" style="--theme-color1:${$};--theme-font-color1:${G};">
            <div class="title">${m}</div>
          </div>`;
        break;
      case "2":
        Y = `<div class="entity-div-style entity-div-style2" style="--theme-color1:${$};--theme-font-color1:${G};">
            <div class="title">${m}</div>
            <div class="mars3d-divUpLabel-line"></div>
          </div>`;
        break;
      case "3":
        Y = `<div class="entity-div-style entity-div-style3" style="--theme-color1:${$};--theme-font-color1:${G};--theme-color2:${E};--theme-color3:${U}">
            <div class="image"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>
            <div class="infotop"><div class="title">${m}</div><div class="content overflow-auto scrollbar h-full">${C}</div></div>
          </div >`;
        break;
      case "4":
        Y = `<div class="entity-div-style entity-div-style4" style="--theme-color1:${$};--theme-font-color1:${G};">
            <div class="title">${m}</div>
          </div >`;
        break;
      case "5":
        Y = `<div class="entity-div-style entity-div-style5 marsTiltPanel marsTiltPanel-theme-green" style="--theme-color1:${$};--theme-font-color1:${G};--theme-color2:${E};">
            <div class="marsTiltPanel-wrap">
              <div class="area">
                <div class="arrow-lt"></div>
                <div class="b-t"></div>
                <div class="b-r"></div>
                <div class="b-b"></div>
                <div class="b-l"></div>
                <div class="arrow-rb"></div>
                <div class="label-wrap">
                  <div class="title">${m}</div>
                  <div class="content">${C}</div>
                </div>
              </div>
              <div class="b-t-l"></div>
              <div class="b-b-r"></div>
            </div>
            <div class="arrow"></div>
          </div >`;
        break;
      case "6":
        Y = `<div class="entity-div-style entity-div-style6" style="--theme-color1:${$};--theme-font-color1:${G};--theme-color2:${E};">
            <div class="title">${m}</div>
          </div >`;
        break;
      case "7":
        Y = `<div class="entity-div-style entity-div-style7" style="--theme-color1:${$};--theme-font-color1:${G};">
            <div class="title">${m}</div>
            <div class="pile-number">
              <div class="circular"></div>
              <div class="pole"></div>
            </div>
          </div >`;
        break;
    }
    return Y;
  }
}
function nh(T) {
  throw new Error('Could not dynamically require "' + T + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Wu = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(T, J) {
  (function(p) {
    T.exports = p();
  })(function() {
    return function p($, G, m) {
      function C(U, Y) {
        if (!G[U]) {
          if (!$[U]) {
            var H = typeof nh == "function" && nh;
            if (!Y && H)
              return H(U, !0);
            if (O)
              return O(U, !0);
            var K = new Error("Cannot find module '" + U + "'");
            throw K.code = "MODULE_NOT_FOUND", K;
          }
          var B = G[U] = { exports: {} };
          $[U][0].call(B.exports, function(q) {
            var b = $[U][1][q];
            return C(b || q);
          }, B, B.exports, p, $, G, m);
        }
        return G[U].exports;
      }
      for (var O = typeof nh == "function" && nh, E = 0; E < m.length; E++)
        C(m[E]);
      return C;
    }({ 1: [function(p, $, G) {
      var m = p("./utils"), C = p("./support"), O = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      G.encode = function(E) {
        for (var U, Y, H, K, B, q, b, A = [], d = 0, g = E.length, M = g, x = m.getTypeOf(E) !== "string"; d < E.length; )
          M = g - d, H = x ? (U = E[d++], Y = d < g ? E[d++] : 0, d < g ? E[d++] : 0) : (U = E.charCodeAt(d++), Y = d < g ? E.charCodeAt(d++) : 0, d < g ? E.charCodeAt(d++) : 0), K = U >> 2, B = (3 & U) << 4 | Y >> 4, q = 1 < M ? (15 & Y) << 2 | H >> 6 : 64, b = 2 < M ? 63 & H : 64, A.push(O.charAt(K) + O.charAt(B) + O.charAt(q) + O.charAt(b));
        return A.join("");
      }, G.decode = function(E) {
        var U, Y, H, K, B, q, b = 0, A = 0, d = "data:";
        if (E.substr(0, d.length) === d)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var g, M = 3 * (E = E.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (E.charAt(E.length - 1) === O.charAt(64) && M--, E.charAt(E.length - 2) === O.charAt(64) && M--, M % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (g = C.uint8array ? new Uint8Array(0 | M) : new Array(0 | M); b < E.length; )
          U = O.indexOf(E.charAt(b++)) << 2 | (K = O.indexOf(E.charAt(b++))) >> 4, Y = (15 & K) << 4 | (B = O.indexOf(E.charAt(b++))) >> 2, H = (3 & B) << 6 | (q = O.indexOf(E.charAt(b++))), g[A++] = U, B !== 64 && (g[A++] = Y), q !== 64 && (g[A++] = H);
        return g;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(p, $, G) {
      var m = p("./external"), C = p("./stream/DataWorker"), O = p("./stream/Crc32Probe"), E = p("./stream/DataLengthProbe");
      function U(Y, H, K, B, q) {
        this.compressedSize = Y, this.uncompressedSize = H, this.crc32 = K, this.compression = B, this.compressedContent = q;
      }
      U.prototype = { getContentWorker: function() {
        var Y = new C(m.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new E("data_length")), H = this;
        return Y.on("end", function() {
          if (this.streamInfo.data_length !== H.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), Y;
      }, getCompressedWorker: function() {
        return new C(m.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, U.createWorkerFrom = function(Y, H, K) {
        return Y.pipe(new O()).pipe(new E("uncompressedSize")).pipe(H.compressWorker(K)).pipe(new E("compressedSize")).withStreamInfo("compression", H);
      }, $.exports = U;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(p, $, G) {
      var m = p("./stream/GenericWorker");
      G.STORE = { magic: "\0\0", compressWorker: function() {
        return new m("STORE compression");
      }, uncompressWorker: function() {
        return new m("STORE decompression");
      } }, G.DEFLATE = p("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(p, $, G) {
      var m = p("./utils"), C = function() {
        for (var O, E = [], U = 0; U < 256; U++) {
          O = U;
          for (var Y = 0; Y < 8; Y++)
            O = 1 & O ? 3988292384 ^ O >>> 1 : O >>> 1;
          E[U] = O;
        }
        return E;
      }();
      $.exports = function(O, E) {
        return O !== void 0 && O.length ? m.getTypeOf(O) !== "string" ? function(U, Y, H, K) {
          var B = C, q = K + H;
          U ^= -1;
          for (var b = K; b < q; b++)
            U = U >>> 8 ^ B[255 & (U ^ Y[b])];
          return -1 ^ U;
        }(0 | E, O, O.length, 0) : function(U, Y, H, K) {
          var B = C, q = K + H;
          U ^= -1;
          for (var b = K; b < q; b++)
            U = U >>> 8 ^ B[255 & (U ^ Y.charCodeAt(b))];
          return -1 ^ U;
        }(0 | E, O, O.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(p, $, G) {
      G.base64 = !1, G.binary = !1, G.dir = !1, G.createFolders = !0, G.date = null, G.compression = null, G.compressionOptions = null, G.comment = null, G.unixPermissions = null, G.dosPermissions = null;
    }, {}], 6: [function(p, $, G) {
      var m = null;
      m = typeof Promise < "u" ? Promise : p("lie"), $.exports = { Promise: m };
    }, { lie: 37 }], 7: [function(p, $, G) {
      var m = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", C = p("pako"), O = p("./utils"), E = p("./stream/GenericWorker"), U = m ? "uint8array" : "array";
      function Y(H, K) {
        E.call(this, "FlateWorker/" + H), this._pako = null, this._pakoAction = H, this._pakoOptions = K, this.meta = {};
      }
      G.magic = "\b\0", O.inherits(Y, E), Y.prototype.processChunk = function(H) {
        this.meta = H.meta, this._pako === null && this._createPako(), this._pako.push(O.transformTo(U, H.data), !1);
      }, Y.prototype.flush = function() {
        E.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, Y.prototype.cleanUp = function() {
        E.prototype.cleanUp.call(this), this._pako = null;
      }, Y.prototype._createPako = function() {
        this._pako = new C[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var H = this;
        this._pako.onData = function(K) {
          H.push({ data: K, meta: H.meta });
        };
      }, G.compressWorker = function(H) {
        return new Y("Deflate", H);
      }, G.uncompressWorker = function() {
        return new Y("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(p, $, G) {
      function m(B, q) {
        var b, A = "";
        for (b = 0; b < q; b++)
          A += String.fromCharCode(255 & B), B >>>= 8;
        return A;
      }
      function C(B, q, b, A, d, g) {
        var M, x, F = B.file, z = B.compression, V = g !== U.utf8encode, ht = O.transformTo("string", g(F.name)), ft = O.transformTo("string", U.utf8encode(F.name)), gt = F.comment, zt = O.transformTo("string", g(gt)), lt = O.transformTo("string", U.utf8encode(gt)), Et = ft.length !== F.name.length, D = lt.length !== gt.length, Bt = "", Ct = "", Rt = "", ge = F.dir, ue = F.date, Ft = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        q && !b || (Ft.crc32 = B.crc32, Ft.compressedSize = B.compressedSize, Ft.uncompressedSize = B.uncompressedSize);
        var Dt = 0;
        q && (Dt |= 8), V || !Et && !D || (Dt |= 2048);
        var kt = 0, Fe = 0;
        ge && (kt |= 16), d === "UNIX" ? (Fe = 798, kt |= function(Zt, ti) {
          var Ni = Zt;
          return Zt || (Ni = ti ? 16893 : 33204), (65535 & Ni) << 16;
        }(F.unixPermissions, ge)) : (Fe = 20, kt |= function(Zt) {
          return 63 & (Zt || 0);
        }(F.dosPermissions)), M = ue.getUTCHours(), M <<= 6, M |= ue.getUTCMinutes(), M <<= 5, M |= ue.getUTCSeconds() / 2, x = ue.getUTCFullYear() - 1980, x <<= 4, x |= ue.getUTCMonth() + 1, x <<= 5, x |= ue.getUTCDate(), Et && (Ct = m(1, 1) + m(Y(ht), 4) + ft, Bt += "up" + m(Ct.length, 2) + Ct), D && (Rt = m(1, 1) + m(Y(zt), 4) + lt, Bt += "uc" + m(Rt.length, 2) + Rt);
        var xe = "";
        return xe += `
\0`, xe += m(Dt, 2), xe += z.magic, xe += m(M, 2), xe += m(x, 2), xe += m(Ft.crc32, 4), xe += m(Ft.compressedSize, 4), xe += m(Ft.uncompressedSize, 4), xe += m(ht.length, 2), xe += m(Bt.length, 2), { fileRecord: H.LOCAL_FILE_HEADER + xe + ht + Bt, dirRecord: H.CENTRAL_FILE_HEADER + m(Fe, 2) + xe + m(zt.length, 2) + "\0\0\0\0" + m(kt, 4) + m(A, 4) + ht + Bt + zt };
      }
      var O = p("../utils"), E = p("../stream/GenericWorker"), U = p("../utf8"), Y = p("../crc32"), H = p("../signature");
      function K(B, q, b, A) {
        E.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = q, this.zipPlatform = b, this.encodeFileName = A, this.streamFiles = B, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      O.inherits(K, E), K.prototype.push = function(B) {
        var q = B.meta.percent || 0, b = this.entriesCount, A = this._sources.length;
        this.accumulate ? this.contentBuffer.push(B) : (this.bytesWritten += B.data.length, E.prototype.push.call(this, { data: B.data, meta: { currentFile: this.currentFile, percent: b ? (q + 100 * (b - A - 1)) / b : 100 } }));
      }, K.prototype.openedSource = function(B) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = B.file.name;
        var q = this.streamFiles && !B.file.dir;
        if (q) {
          var b = C(B, q, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: b.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, K.prototype.closedSource = function(B) {
        this.accumulate = !1;
        var q = this.streamFiles && !B.file.dir, b = C(B, q, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(b.dirRecord), q)
          this.push({ data: function(A) {
            return H.DATA_DESCRIPTOR + m(A.crc32, 4) + m(A.compressedSize, 4) + m(A.uncompressedSize, 4);
          }(B), meta: { percent: 100 } });
        else
          for (this.push({ data: b.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, K.prototype.flush = function() {
        for (var B = this.bytesWritten, q = 0; q < this.dirRecords.length; q++)
          this.push({ data: this.dirRecords[q], meta: { percent: 100 } });
        var b = this.bytesWritten - B, A = function(d, g, M, x, F) {
          var z = O.transformTo("string", F(x));
          return H.CENTRAL_DIRECTORY_END + "\0\0\0\0" + m(d, 2) + m(d, 2) + m(g, 4) + m(M, 4) + m(z.length, 2) + z;
        }(this.dirRecords.length, b, B, this.zipComment, this.encodeFileName);
        this.push({ data: A, meta: { percent: 100 } });
      }, K.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, K.prototype.registerPrevious = function(B) {
        this._sources.push(B);
        var q = this;
        return B.on("data", function(b) {
          q.processChunk(b);
        }), B.on("end", function() {
          q.closedSource(q.previous.streamInfo), q._sources.length ? q.prepareNextSource() : q.end();
        }), B.on("error", function(b) {
          q.error(b);
        }), this;
      }, K.prototype.resume = function() {
        return !!E.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, K.prototype.error = function(B) {
        var q = this._sources;
        if (!E.prototype.error.call(this, B))
          return !1;
        for (var b = 0; b < q.length; b++)
          try {
            q[b].error(B);
          } catch {
          }
        return !0;
      }, K.prototype.lock = function() {
        E.prototype.lock.call(this);
        for (var B = this._sources, q = 0; q < B.length; q++)
          B[q].lock();
      }, $.exports = K;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(p, $, G) {
      var m = p("../compressions"), C = p("./ZipFileWorker");
      G.generateWorker = function(O, E, U) {
        var Y = new C(E.streamFiles, U, E.platform, E.encodeFileName), H = 0;
        try {
          O.forEach(function(K, B) {
            H++;
            var q = function(g, M) {
              var x = g || M, F = m[x];
              if (!F)
                throw new Error(x + " is not a valid compression method !");
              return F;
            }(B.options.compression, E.compression), b = B.options.compressionOptions || E.compressionOptions || {}, A = B.dir, d = B.date;
            B._compressWorker(q, b).withStreamInfo("file", { name: K, dir: A, date: d, comment: B.comment || "", unixPermissions: B.unixPermissions, dosPermissions: B.dosPermissions }).pipe(Y);
          }), Y.entriesCount = H;
        } catch (K) {
          Y.error(K);
        }
        return Y;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(p, $, G) {
      function m() {
        if (!(this instanceof m))
          return new m();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var C = new m();
          for (var O in this)
            typeof this[O] != "function" && (C[O] = this[O]);
          return C;
        };
      }
      (m.prototype = p("./object")).loadAsync = p("./load"), m.support = p("./support"), m.defaults = p("./defaults"), m.version = "3.10.1", m.loadAsync = function(C, O) {
        return new m().loadAsync(C, O);
      }, m.external = p("./external"), $.exports = m;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(p, $, G) {
      var m = p("./utils"), C = p("./external"), O = p("./utf8"), E = p("./zipEntries"), U = p("./stream/Crc32Probe"), Y = p("./nodejsUtils");
      function H(K) {
        return new C.Promise(function(B, q) {
          var b = K.decompressed.getContentWorker().pipe(new U());
          b.on("error", function(A) {
            q(A);
          }).on("end", function() {
            b.streamInfo.crc32 !== K.decompressed.crc32 ? q(new Error("Corrupted zip : CRC32 mismatch")) : B();
          }).resume();
        });
      }
      $.exports = function(K, B) {
        var q = this;
        return B = m.extend(B || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: O.utf8decode }), Y.isNode && Y.isStream(K) ? C.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : m.prepareContent("the loaded zip file", K, !0, B.optimizedBinaryString, B.base64).then(function(b) {
          var A = new E(B);
          return A.load(b), A;
        }).then(function(b) {
          var A = [C.Promise.resolve(b)], d = b.files;
          if (B.checkCRC32)
            for (var g = 0; g < d.length; g++)
              A.push(H(d[g]));
          return C.Promise.all(A);
        }).then(function(b) {
          for (var A = b.shift(), d = A.files, g = 0; g < d.length; g++) {
            var M = d[g], x = M.fileNameStr, F = m.resolve(M.fileNameStr);
            q.file(F, M.decompressed, { binary: !0, optimizedBinaryString: !0, date: M.date, dir: M.dir, comment: M.fileCommentStr.length ? M.fileCommentStr : null, unixPermissions: M.unixPermissions, dosPermissions: M.dosPermissions, createFolders: B.createFolders }), M.dir || (q.file(F).unsafeOriginalName = x);
          }
          return A.zipComment.length && (q.comment = A.zipComment), q;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(p, $, G) {
      var m = p("../utils"), C = p("../stream/GenericWorker");
      function O(E, U) {
        C.call(this, "Nodejs stream input adapter for " + E), this._upstreamEnded = !1, this._bindStream(U);
      }
      m.inherits(O, C), O.prototype._bindStream = function(E) {
        var U = this;
        (this._stream = E).pause(), E.on("data", function(Y) {
          U.push({ data: Y, meta: { percent: 0 } });
        }).on("error", function(Y) {
          U.isPaused ? this.generatedError = Y : U.error(Y);
        }).on("end", function() {
          U.isPaused ? U._upstreamEnded = !0 : U.end();
        });
      }, O.prototype.pause = function() {
        return !!C.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, O.prototype.resume = function() {
        return !!C.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, $.exports = O;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(p, $, G) {
      var m = p("readable-stream").Readable;
      function C(O, E, U) {
        m.call(this, E), this._helper = O;
        var Y = this;
        O.on("data", function(H, K) {
          Y.push(H) || Y._helper.pause(), U && U(K);
        }).on("error", function(H) {
          Y.emit("error", H);
        }).on("end", function() {
          Y.push(null);
        });
      }
      p("../utils").inherits(C, m), C.prototype._read = function() {
        this._helper.resume();
      }, $.exports = C;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(p, $, G) {
      $.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(m, C) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(m, C);
        if (typeof m == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(m, C);
      }, allocBuffer: function(m) {
        if (Buffer.alloc)
          return Buffer.alloc(m);
        var C = new Buffer(m);
        return C.fill(0), C;
      }, isBuffer: function(m) {
        return Buffer.isBuffer(m);
      }, isStream: function(m) {
        return m && typeof m.on == "function" && typeof m.pause == "function" && typeof m.resume == "function";
      } };
    }, {}], 15: [function(p, $, G) {
      function m(F, z, V) {
        var ht, ft = O.getTypeOf(z), gt = O.extend(V || {}, Y);
        gt.date = gt.date || /* @__PURE__ */ new Date(), gt.compression !== null && (gt.compression = gt.compression.toUpperCase()), typeof gt.unixPermissions == "string" && (gt.unixPermissions = parseInt(gt.unixPermissions, 8)), gt.unixPermissions && 16384 & gt.unixPermissions && (gt.dir = !0), gt.dosPermissions && 16 & gt.dosPermissions && (gt.dir = !0), gt.dir && (F = d(F)), gt.createFolders && (ht = A(F)) && g.call(this, ht, !0);
        var zt = ft === "string" && gt.binary === !1 && gt.base64 === !1;
        V && V.binary !== void 0 || (gt.binary = !zt), (z instanceof H && z.uncompressedSize === 0 || gt.dir || !z || z.length === 0) && (gt.base64 = !1, gt.binary = !0, z = "", gt.compression = "STORE", ft = "string");
        var lt = null;
        lt = z instanceof H || z instanceof E ? z : q.isNode && q.isStream(z) ? new b(F, z) : O.prepareContent(F, z, gt.binary, gt.optimizedBinaryString, gt.base64);
        var Et = new K(F, lt, gt);
        this.files[F] = Et;
      }
      var C = p("./utf8"), O = p("./utils"), E = p("./stream/GenericWorker"), U = p("./stream/StreamHelper"), Y = p("./defaults"), H = p("./compressedObject"), K = p("./zipObject"), B = p("./generate"), q = p("./nodejsUtils"), b = p("./nodejs/NodejsStreamInputAdapter"), A = function(F) {
        F.slice(-1) === "/" && (F = F.substring(0, F.length - 1));
        var z = F.lastIndexOf("/");
        return 0 < z ? F.substring(0, z) : "";
      }, d = function(F) {
        return F.slice(-1) !== "/" && (F += "/"), F;
      }, g = function(F, z) {
        return z = z !== void 0 ? z : Y.createFolders, F = d(F), this.files[F] || m.call(this, F, null, { dir: !0, createFolders: z }), this.files[F];
      };
      function M(F) {
        return Object.prototype.toString.call(F) === "[object RegExp]";
      }
      var x = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(F) {
        var z, V, ht;
        for (z in this.files)
          ht = this.files[z], (V = z.slice(this.root.length, z.length)) && z.slice(0, this.root.length) === this.root && F(V, ht);
      }, filter: function(F) {
        var z = [];
        return this.forEach(function(V, ht) {
          F(V, ht) && z.push(ht);
        }), z;
      }, file: function(F, z, V) {
        if (arguments.length !== 1)
          return F = this.root + F, m.call(this, F, z, V), this;
        if (M(F)) {
          var ht = F;
          return this.filter(function(gt, zt) {
            return !zt.dir && ht.test(gt);
          });
        }
        var ft = this.files[this.root + F];
        return ft && !ft.dir ? ft : null;
      }, folder: function(F) {
        if (!F)
          return this;
        if (M(F))
          return this.filter(function(ft, gt) {
            return gt.dir && F.test(ft);
          });
        var z = this.root + F, V = g.call(this, z), ht = this.clone();
        return ht.root = V.name, ht;
      }, remove: function(F) {
        F = this.root + F;
        var z = this.files[F];
        if (z || (F.slice(-1) !== "/" && (F += "/"), z = this.files[F]), z && !z.dir)
          delete this.files[F];
        else
          for (var V = this.filter(function(ft, gt) {
            return gt.name.slice(0, F.length) === F;
          }), ht = 0; ht < V.length; ht++)
            delete this.files[V[ht].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(F) {
        var z, V = {};
        try {
          if ((V = O.extend(F || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: C.utf8encode })).type = V.type.toLowerCase(), V.compression = V.compression.toUpperCase(), V.type === "binarystring" && (V.type = "string"), !V.type)
            throw new Error("No output type specified.");
          O.checkSupport(V.type), V.platform !== "darwin" && V.platform !== "freebsd" && V.platform !== "linux" && V.platform !== "sunos" || (V.platform = "UNIX"), V.platform === "win32" && (V.platform = "DOS");
          var ht = V.comment || this.comment || "";
          z = B.generateWorker(this, V, ht);
        } catch (ft) {
          (z = new E("error")).error(ft);
        }
        return new U(z, V.type || "string", V.mimeType);
      }, generateAsync: function(F, z) {
        return this.generateInternalStream(F).accumulate(z);
      }, generateNodeStream: function(F, z) {
        return (F = F || {}).type || (F.type = "nodebuffer"), this.generateInternalStream(F).toNodejsStream(z);
      } };
      $.exports = x;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(p, $, G) {
      $.exports = p("stream");
    }, { stream: void 0 }], 17: [function(p, $, G) {
      var m = p("./DataReader");
      function C(O) {
        m.call(this, O);
        for (var E = 0; E < this.data.length; E++)
          O[E] = 255 & O[E];
      }
      p("../utils").inherits(C, m), C.prototype.byteAt = function(O) {
        return this.data[this.zero + O];
      }, C.prototype.lastIndexOfSignature = function(O) {
        for (var E = O.charCodeAt(0), U = O.charCodeAt(1), Y = O.charCodeAt(2), H = O.charCodeAt(3), K = this.length - 4; 0 <= K; --K)
          if (this.data[K] === E && this.data[K + 1] === U && this.data[K + 2] === Y && this.data[K + 3] === H)
            return K - this.zero;
        return -1;
      }, C.prototype.readAndCheckSignature = function(O) {
        var E = O.charCodeAt(0), U = O.charCodeAt(1), Y = O.charCodeAt(2), H = O.charCodeAt(3), K = this.readData(4);
        return E === K[0] && U === K[1] && Y === K[2] && H === K[3];
      }, C.prototype.readData = function(O) {
        if (this.checkOffset(O), O === 0)
          return [];
        var E = this.data.slice(this.zero + this.index, this.zero + this.index + O);
        return this.index += O, E;
      }, $.exports = C;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(p, $, G) {
      var m = p("../utils");
      function C(O) {
        this.data = O, this.length = O.length, this.index = 0, this.zero = 0;
      }
      C.prototype = { checkOffset: function(O) {
        this.checkIndex(this.index + O);
      }, checkIndex: function(O) {
        if (this.length < this.zero + O || O < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + O + "). Corrupted zip ?");
      }, setIndex: function(O) {
        this.checkIndex(O), this.index = O;
      }, skip: function(O) {
        this.setIndex(this.index + O);
      }, byteAt: function() {
      }, readInt: function(O) {
        var E, U = 0;
        for (this.checkOffset(O), E = this.index + O - 1; E >= this.index; E--)
          U = (U << 8) + this.byteAt(E);
        return this.index += O, U;
      }, readString: function(O) {
        return m.transformTo("string", this.readData(O));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var O = this.readInt(4);
        return new Date(Date.UTC(1980 + (O >> 25 & 127), (O >> 21 & 15) - 1, O >> 16 & 31, O >> 11 & 31, O >> 5 & 63, (31 & O) << 1));
      } }, $.exports = C;
    }, { "../utils": 32 }], 19: [function(p, $, G) {
      var m = p("./Uint8ArrayReader");
      function C(O) {
        m.call(this, O);
      }
      p("../utils").inherits(C, m), C.prototype.readData = function(O) {
        this.checkOffset(O);
        var E = this.data.slice(this.zero + this.index, this.zero + this.index + O);
        return this.index += O, E;
      }, $.exports = C;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(p, $, G) {
      var m = p("./DataReader");
      function C(O) {
        m.call(this, O);
      }
      p("../utils").inherits(C, m), C.prototype.byteAt = function(O) {
        return this.data.charCodeAt(this.zero + O);
      }, C.prototype.lastIndexOfSignature = function(O) {
        return this.data.lastIndexOf(O) - this.zero;
      }, C.prototype.readAndCheckSignature = function(O) {
        return O === this.readData(4);
      }, C.prototype.readData = function(O) {
        this.checkOffset(O);
        var E = this.data.slice(this.zero + this.index, this.zero + this.index + O);
        return this.index += O, E;
      }, $.exports = C;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(p, $, G) {
      var m = p("./ArrayReader");
      function C(O) {
        m.call(this, O);
      }
      p("../utils").inherits(C, m), C.prototype.readData = function(O) {
        if (this.checkOffset(O), O === 0)
          return new Uint8Array(0);
        var E = this.data.subarray(this.zero + this.index, this.zero + this.index + O);
        return this.index += O, E;
      }, $.exports = C;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(p, $, G) {
      var m = p("../utils"), C = p("../support"), O = p("./ArrayReader"), E = p("./StringReader"), U = p("./NodeBufferReader"), Y = p("./Uint8ArrayReader");
      $.exports = function(H) {
        var K = m.getTypeOf(H);
        return m.checkSupport(K), K !== "string" || C.uint8array ? K === "nodebuffer" ? new U(H) : C.uint8array ? new Y(m.transformTo("uint8array", H)) : new O(m.transformTo("array", H)) : new E(H);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(p, $, G) {
      G.LOCAL_FILE_HEADER = "PK", G.CENTRAL_FILE_HEADER = "PK", G.CENTRAL_DIRECTORY_END = "PK", G.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", G.ZIP64_CENTRAL_DIRECTORY_END = "PK", G.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(p, $, G) {
      var m = p("./GenericWorker"), C = p("../utils");
      function O(E) {
        m.call(this, "ConvertWorker to " + E), this.destType = E;
      }
      C.inherits(O, m), O.prototype.processChunk = function(E) {
        this.push({ data: C.transformTo(this.destType, E.data), meta: E.meta });
      }, $.exports = O;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(p, $, G) {
      var m = p("./GenericWorker"), C = p("../crc32");
      function O() {
        m.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      p("../utils").inherits(O, m), O.prototype.processChunk = function(E) {
        this.streamInfo.crc32 = C(E.data, this.streamInfo.crc32 || 0), this.push(E);
      }, $.exports = O;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(p, $, G) {
      var m = p("../utils"), C = p("./GenericWorker");
      function O(E) {
        C.call(this, "DataLengthProbe for " + E), this.propName = E, this.withStreamInfo(E, 0);
      }
      m.inherits(O, C), O.prototype.processChunk = function(E) {
        if (E) {
          var U = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = U + E.data.length;
        }
        C.prototype.processChunk.call(this, E);
      }, $.exports = O;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(p, $, G) {
      var m = p("../utils"), C = p("./GenericWorker");
      function O(E) {
        C.call(this, "DataWorker");
        var U = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, E.then(function(Y) {
          U.dataIsReady = !0, U.data = Y, U.max = Y && Y.length || 0, U.type = m.getTypeOf(Y), U.isPaused || U._tickAndRepeat();
        }, function(Y) {
          U.error(Y);
        });
      }
      m.inherits(O, C), O.prototype.cleanUp = function() {
        C.prototype.cleanUp.call(this), this.data = null;
      }, O.prototype.resume = function() {
        return !!C.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, m.delay(this._tickAndRepeat, [], this)), !0);
      }, O.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (m.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, O.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var E = null, U = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            E = this.data.substring(this.index, U);
            break;
          case "uint8array":
            E = this.data.subarray(this.index, U);
            break;
          case "array":
          case "nodebuffer":
            E = this.data.slice(this.index, U);
        }
        return this.index = U, this.push({ data: E, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, $.exports = O;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(p, $, G) {
      function m(C) {
        this.name = C || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      m.prototype = { push: function(C) {
        this.emit("data", C);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (C) {
          this.emit("error", C);
        }
        return !0;
      }, error: function(C) {
        return !this.isFinished && (this.isPaused ? this.generatedError = C : (this.isFinished = !0, this.emit("error", C), this.previous && this.previous.error(C), this.cleanUp()), !0);
      }, on: function(C, O) {
        return this._listeners[C].push(O), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(C, O) {
        if (this._listeners[C])
          for (var E = 0; E < this._listeners[C].length; E++)
            this._listeners[C][E].call(this, O);
      }, pipe: function(C) {
        return C.registerPrevious(this);
      }, registerPrevious: function(C) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = C.streamInfo, this.mergeStreamInfo(), this.previous = C;
        var O = this;
        return C.on("data", function(E) {
          O.processChunk(E);
        }), C.on("end", function() {
          O.end();
        }), C.on("error", function(E) {
          O.error(E);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var C = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), C = !0), this.previous && this.previous.resume(), !C;
      }, flush: function() {
      }, processChunk: function(C) {
        this.push(C);
      }, withStreamInfo: function(C, O) {
        return this.extraStreamInfo[C] = O, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var C in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, C) && (this.streamInfo[C] = this.extraStreamInfo[C]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var C = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + C : C;
      } }, $.exports = m;
    }, {}], 29: [function(p, $, G) {
      var m = p("../utils"), C = p("./ConvertWorker"), O = p("./GenericWorker"), E = p("../base64"), U = p("../support"), Y = p("../external"), H = null;
      if (U.nodestream)
        try {
          H = p("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function K(q, b) {
        return new Y.Promise(function(A, d) {
          var g = [], M = q._internalType, x = q._outputType, F = q._mimeType;
          q.on("data", function(z, V) {
            g.push(z), b && b(V);
          }).on("error", function(z) {
            g = [], d(z);
          }).on("end", function() {
            try {
              var z = function(V, ht, ft) {
                switch (V) {
                  case "blob":
                    return m.newBlob(m.transformTo("arraybuffer", ht), ft);
                  case "base64":
                    return E.encode(ht);
                  default:
                    return m.transformTo(V, ht);
                }
              }(x, function(V, ht) {
                var ft, gt = 0, zt = null, lt = 0;
                for (ft = 0; ft < ht.length; ft++)
                  lt += ht[ft].length;
                switch (V) {
                  case "string":
                    return ht.join("");
                  case "array":
                    return Array.prototype.concat.apply([], ht);
                  case "uint8array":
                    for (zt = new Uint8Array(lt), ft = 0; ft < ht.length; ft++)
                      zt.set(ht[ft], gt), gt += ht[ft].length;
                    return zt;
                  case "nodebuffer":
                    return Buffer.concat(ht);
                  default:
                    throw new Error("concat : unsupported type '" + V + "'");
                }
              }(M, g), F);
              A(z);
            } catch (V) {
              d(V);
            }
            g = [];
          }).resume();
        });
      }
      function B(q, b, A) {
        var d = b;
        switch (b) {
          case "blob":
          case "arraybuffer":
            d = "uint8array";
            break;
          case "base64":
            d = "string";
        }
        try {
          this._internalType = d, this._outputType = b, this._mimeType = A, m.checkSupport(d), this._worker = q.pipe(new C(d)), q.lock();
        } catch (g) {
          this._worker = new O("error"), this._worker.error(g);
        }
      }
      B.prototype = { accumulate: function(q) {
        return K(this, q);
      }, on: function(q, b) {
        var A = this;
        return q === "data" ? this._worker.on(q, function(d) {
          b.call(A, d.data, d.meta);
        }) : this._worker.on(q, function() {
          m.delay(b, arguments, A);
        }), this;
      }, resume: function() {
        return m.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(q) {
        if (m.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new H(this, { objectMode: this._outputType !== "nodebuffer" }, q);
      } }, $.exports = B;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(p, $, G) {
      if (G.base64 = !0, G.array = !0, G.string = !0, G.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", G.nodebuffer = typeof Buffer < "u", G.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        G.blob = !1;
      else {
        var m = new ArrayBuffer(0);
        try {
          G.blob = new Blob([m], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var C = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            C.append(m), G.blob = C.getBlob("application/zip").size === 0;
          } catch {
            G.blob = !1;
          }
        }
      }
      try {
        G.nodestream = !!p("readable-stream").Readable;
      } catch {
        G.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(p, $, G) {
      for (var m = p("./utils"), C = p("./support"), O = p("./nodejsUtils"), E = p("./stream/GenericWorker"), U = new Array(256), Y = 0; Y < 256; Y++)
        U[Y] = 252 <= Y ? 6 : 248 <= Y ? 5 : 240 <= Y ? 4 : 224 <= Y ? 3 : 192 <= Y ? 2 : 1;
      U[254] = U[254] = 1;
      function H() {
        E.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function K() {
        E.call(this, "utf-8 encode");
      }
      G.utf8encode = function(B) {
        return C.nodebuffer ? O.newBufferFrom(B, "utf-8") : function(q) {
          var b, A, d, g, M, x = q.length, F = 0;
          for (g = 0; g < x; g++)
            (64512 & (A = q.charCodeAt(g))) == 55296 && g + 1 < x && (64512 & (d = q.charCodeAt(g + 1))) == 56320 && (A = 65536 + (A - 55296 << 10) + (d - 56320), g++), F += A < 128 ? 1 : A < 2048 ? 2 : A < 65536 ? 3 : 4;
          for (b = C.uint8array ? new Uint8Array(F) : new Array(F), g = M = 0; M < F; g++)
            (64512 & (A = q.charCodeAt(g))) == 55296 && g + 1 < x && (64512 & (d = q.charCodeAt(g + 1))) == 56320 && (A = 65536 + (A - 55296 << 10) + (d - 56320), g++), A < 128 ? b[M++] = A : (A < 2048 ? b[M++] = 192 | A >>> 6 : (A < 65536 ? b[M++] = 224 | A >>> 12 : (b[M++] = 240 | A >>> 18, b[M++] = 128 | A >>> 12 & 63), b[M++] = 128 | A >>> 6 & 63), b[M++] = 128 | 63 & A);
          return b;
        }(B);
      }, G.utf8decode = function(B) {
        return C.nodebuffer ? m.transformTo("nodebuffer", B).toString("utf-8") : function(q) {
          var b, A, d, g, M = q.length, x = new Array(2 * M);
          for (b = A = 0; b < M; )
            if ((d = q[b++]) < 128)
              x[A++] = d;
            else if (4 < (g = U[d]))
              x[A++] = 65533, b += g - 1;
            else {
              for (d &= g === 2 ? 31 : g === 3 ? 15 : 7; 1 < g && b < M; )
                d = d << 6 | 63 & q[b++], g--;
              1 < g ? x[A++] = 65533 : d < 65536 ? x[A++] = d : (d -= 65536, x[A++] = 55296 | d >> 10 & 1023, x[A++] = 56320 | 1023 & d);
            }
          return x.length !== A && (x.subarray ? x = x.subarray(0, A) : x.length = A), m.applyFromCharCode(x);
        }(B = m.transformTo(C.uint8array ? "uint8array" : "array", B));
      }, m.inherits(H, E), H.prototype.processChunk = function(B) {
        var q = m.transformTo(C.uint8array ? "uint8array" : "array", B.data);
        if (this.leftOver && this.leftOver.length) {
          if (C.uint8array) {
            var b = q;
            (q = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), q.set(b, this.leftOver.length);
          } else
            q = this.leftOver.concat(q);
          this.leftOver = null;
        }
        var A = function(g, M) {
          var x;
          for ((M = M || g.length) > g.length && (M = g.length), x = M - 1; 0 <= x && (192 & g[x]) == 128; )
            x--;
          return x < 0 || x === 0 ? M : x + U[g[x]] > M ? x : M;
        }(q), d = q;
        A !== q.length && (C.uint8array ? (d = q.subarray(0, A), this.leftOver = q.subarray(A, q.length)) : (d = q.slice(0, A), this.leftOver = q.slice(A, q.length))), this.push({ data: G.utf8decode(d), meta: B.meta });
      }, H.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: G.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, G.Utf8DecodeWorker = H, m.inherits(K, E), K.prototype.processChunk = function(B) {
        this.push({ data: G.utf8encode(B.data), meta: B.meta });
      }, G.Utf8EncodeWorker = K;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(p, $, G) {
      var m = p("./support"), C = p("./base64"), O = p("./nodejsUtils"), E = p("./external");
      function U(b) {
        return b;
      }
      function Y(b, A) {
        for (var d = 0; d < b.length; ++d)
          A[d] = 255 & b.charCodeAt(d);
        return A;
      }
      p("setimmediate"), G.newBlob = function(b, A) {
        G.checkSupport("blob");
        try {
          return new Blob([b], { type: A });
        } catch {
          try {
            var d = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return d.append(b), d.getBlob(A);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var H = { stringifyByChunk: function(b, A, d) {
        var g = [], M = 0, x = b.length;
        if (x <= d)
          return String.fromCharCode.apply(null, b);
        for (; M < x; )
          A === "array" || A === "nodebuffer" ? g.push(String.fromCharCode.apply(null, b.slice(M, Math.min(M + d, x)))) : g.push(String.fromCharCode.apply(null, b.subarray(M, Math.min(M + d, x)))), M += d;
        return g.join("");
      }, stringifyByChar: function(b) {
        for (var A = "", d = 0; d < b.length; d++)
          A += String.fromCharCode(b[d]);
        return A;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return m.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return m.nodebuffer && String.fromCharCode.apply(null, O.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function K(b) {
        var A = 65536, d = G.getTypeOf(b), g = !0;
        if (d === "uint8array" ? g = H.applyCanBeUsed.uint8array : d === "nodebuffer" && (g = H.applyCanBeUsed.nodebuffer), g)
          for (; 1 < A; )
            try {
              return H.stringifyByChunk(b, d, A);
            } catch {
              A = Math.floor(A / 2);
            }
        return H.stringifyByChar(b);
      }
      function B(b, A) {
        for (var d = 0; d < b.length; d++)
          A[d] = b[d];
        return A;
      }
      G.applyFromCharCode = K;
      var q = {};
      q.string = { string: U, array: function(b) {
        return Y(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return q.string.uint8array(b).buffer;
      }, uint8array: function(b) {
        return Y(b, new Uint8Array(b.length));
      }, nodebuffer: function(b) {
        return Y(b, O.allocBuffer(b.length));
      } }, q.array = { string: K, array: U, arraybuffer: function(b) {
        return new Uint8Array(b).buffer;
      }, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return O.newBufferFrom(b);
      } }, q.arraybuffer = { string: function(b) {
        return K(new Uint8Array(b));
      }, array: function(b) {
        return B(new Uint8Array(b), new Array(b.byteLength));
      }, arraybuffer: U, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return O.newBufferFrom(new Uint8Array(b));
      } }, q.uint8array = { string: K, array: function(b) {
        return B(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return b.buffer;
      }, uint8array: U, nodebuffer: function(b) {
        return O.newBufferFrom(b);
      } }, q.nodebuffer = { string: K, array: function(b) {
        return B(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return q.nodebuffer.uint8array(b).buffer;
      }, uint8array: function(b) {
        return B(b, new Uint8Array(b.length));
      }, nodebuffer: U }, G.transformTo = function(b, A) {
        if (A = A || "", !b)
          return A;
        G.checkSupport(b);
        var d = G.getTypeOf(A);
        return q[d][b](A);
      }, G.resolve = function(b) {
        for (var A = b.split("/"), d = [], g = 0; g < A.length; g++) {
          var M = A[g];
          M === "." || M === "" && g !== 0 && g !== A.length - 1 || (M === ".." ? d.pop() : d.push(M));
        }
        return d.join("/");
      }, G.getTypeOf = function(b) {
        return typeof b == "string" ? "string" : Object.prototype.toString.call(b) === "[object Array]" ? "array" : m.nodebuffer && O.isBuffer(b) ? "nodebuffer" : m.uint8array && b instanceof Uint8Array ? "uint8array" : m.arraybuffer && b instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, G.checkSupport = function(b) {
        if (!m[b.toLowerCase()])
          throw new Error(b + " is not supported by this platform");
      }, G.MAX_VALUE_16BITS = 65535, G.MAX_VALUE_32BITS = -1, G.pretty = function(b) {
        var A, d, g = "";
        for (d = 0; d < (b || "").length; d++)
          g += "\\x" + ((A = b.charCodeAt(d)) < 16 ? "0" : "") + A.toString(16).toUpperCase();
        return g;
      }, G.delay = function(b, A, d) {
        setImmediate(function() {
          b.apply(d || null, A || []);
        });
      }, G.inherits = function(b, A) {
        function d() {
        }
        d.prototype = A.prototype, b.prototype = new d();
      }, G.extend = function() {
        var b, A, d = {};
        for (b = 0; b < arguments.length; b++)
          for (A in arguments[b])
            Object.prototype.hasOwnProperty.call(arguments[b], A) && d[A] === void 0 && (d[A] = arguments[b][A]);
        return d;
      }, G.prepareContent = function(b, A, d, g, M) {
        return E.Promise.resolve(A).then(function(x) {
          return m.blob && (x instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(x)) !== -1) && typeof FileReader < "u" ? new E.Promise(function(F, z) {
            var V = new FileReader();
            V.onload = function(ht) {
              F(ht.target.result);
            }, V.onerror = function(ht) {
              z(ht.target.error);
            }, V.readAsArrayBuffer(x);
          }) : x;
        }).then(function(x) {
          var F = G.getTypeOf(x);
          return F ? (F === "arraybuffer" ? x = G.transformTo("uint8array", x) : F === "string" && (M ? x = C.decode(x) : d && g !== !0 && (x = function(z) {
            return Y(z, m.uint8array ? new Uint8Array(z.length) : new Array(z.length));
          }(x))), x) : E.Promise.reject(new Error("Can't read the data of '" + b + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(p, $, G) {
      var m = p("./reader/readerFor"), C = p("./utils"), O = p("./signature"), E = p("./zipEntry"), U = p("./support");
      function Y(H) {
        this.files = [], this.loadOptions = H;
      }
      Y.prototype = { checkSignature: function(H) {
        if (!this.reader.readAndCheckSignature(H)) {
          this.reader.index -= 4;
          var K = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + C.pretty(K) + ", expected " + C.pretty(H) + ")");
        }
      }, isSignature: function(H, K) {
        var B = this.reader.index;
        this.reader.setIndex(H);
        var q = this.reader.readString(4) === K;
        return this.reader.setIndex(B), q;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var H = this.reader.readData(this.zipCommentLength), K = U.uint8array ? "uint8array" : "array", B = C.transformTo(K, H);
        this.zipComment = this.loadOptions.decodeFileName(B);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var H, K, B, q = this.zip64EndOfCentralSize - 44; 0 < q; )
          H = this.reader.readInt(2), K = this.reader.readInt(4), B = this.reader.readData(K), this.zip64ExtensibleData[H] = { id: H, length: K, value: B };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var H, K;
        for (H = 0; H < this.files.length; H++)
          K = this.files[H], this.reader.setIndex(K.localHeaderOffset), this.checkSignature(O.LOCAL_FILE_HEADER), K.readLocalPart(this.reader), K.handleUTF8(), K.processAttributes();
      }, readCentralDir: function() {
        var H;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(O.CENTRAL_FILE_HEADER); )
          (H = new E({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(H);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var H = this.reader.lastIndexOfSignature(O.CENTRAL_DIRECTORY_END);
        if (H < 0)
          throw this.isSignature(0, O.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(H);
        var K = H;
        if (this.checkSignature(O.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === C.MAX_VALUE_16BITS || this.diskWithCentralDirStart === C.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === C.MAX_VALUE_16BITS || this.centralDirRecords === C.MAX_VALUE_16BITS || this.centralDirSize === C.MAX_VALUE_32BITS || this.centralDirOffset === C.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (H = this.reader.lastIndexOfSignature(O.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(H), this.checkSignature(O.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, O.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(O.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(O.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var B = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (B += 20, B += 12 + this.zip64EndOfCentralSize);
        var q = K - B;
        if (0 < q)
          this.isSignature(K, O.CENTRAL_FILE_HEADER) || (this.reader.zero = q);
        else if (q < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(q) + " bytes.");
      }, prepareReader: function(H) {
        this.reader = m(H);
      }, load: function(H) {
        this.prepareReader(H), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, $.exports = Y;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(p, $, G) {
      var m = p("./reader/readerFor"), C = p("./utils"), O = p("./compressedObject"), E = p("./crc32"), U = p("./utf8"), Y = p("./compressions"), H = p("./support");
      function K(B, q) {
        this.options = B, this.loadOptions = q;
      }
      K.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(B) {
        var q, b;
        if (B.skip(22), this.fileNameLength = B.readInt(2), b = B.readInt(2), this.fileName = B.readData(this.fileNameLength), B.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((q = function(A) {
          for (var d in Y)
            if (Object.prototype.hasOwnProperty.call(Y, d) && Y[d].magic === A)
              return Y[d];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + C.pretty(this.compressionMethod) + " unknown (inner file : " + C.transformTo("string", this.fileName) + ")");
        this.decompressed = new O(this.compressedSize, this.uncompressedSize, this.crc32, q, B.readData(this.compressedSize));
      }, readCentralPart: function(B) {
        this.versionMadeBy = B.readInt(2), B.skip(2), this.bitFlag = B.readInt(2), this.compressionMethod = B.readString(2), this.date = B.readDate(), this.crc32 = B.readInt(4), this.compressedSize = B.readInt(4), this.uncompressedSize = B.readInt(4);
        var q = B.readInt(2);
        if (this.extraFieldsLength = B.readInt(2), this.fileCommentLength = B.readInt(2), this.diskNumberStart = B.readInt(2), this.internalFileAttributes = B.readInt(2), this.externalFileAttributes = B.readInt(4), this.localHeaderOffset = B.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        B.skip(q), this.readExtraFields(B), this.parseZIP64ExtraField(B), this.fileComment = B.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var B = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), B == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), B == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var B = m(this.extraFields[1].value);
          this.uncompressedSize === C.MAX_VALUE_32BITS && (this.uncompressedSize = B.readInt(8)), this.compressedSize === C.MAX_VALUE_32BITS && (this.compressedSize = B.readInt(8)), this.localHeaderOffset === C.MAX_VALUE_32BITS && (this.localHeaderOffset = B.readInt(8)), this.diskNumberStart === C.MAX_VALUE_32BITS && (this.diskNumberStart = B.readInt(4));
        }
      }, readExtraFields: function(B) {
        var q, b, A, d = B.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); B.index + 4 < d; )
          q = B.readInt(2), b = B.readInt(2), A = B.readData(b), this.extraFields[q] = { id: q, length: b, value: A };
        B.setIndex(d);
      }, handleUTF8: function() {
        var B = H.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = U.utf8decode(this.fileName), this.fileCommentStr = U.utf8decode(this.fileComment);
        else {
          var q = this.findExtraFieldUnicodePath();
          if (q !== null)
            this.fileNameStr = q;
          else {
            var b = C.transformTo(B, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(b);
          }
          var A = this.findExtraFieldUnicodeComment();
          if (A !== null)
            this.fileCommentStr = A;
          else {
            var d = C.transformTo(B, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(d);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var B = this.extraFields[28789];
        if (B) {
          var q = m(B.value);
          return q.readInt(1) !== 1 || E(this.fileName) !== q.readInt(4) ? null : U.utf8decode(q.readData(B.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var B = this.extraFields[25461];
        if (B) {
          var q = m(B.value);
          return q.readInt(1) !== 1 || E(this.fileComment) !== q.readInt(4) ? null : U.utf8decode(q.readData(B.length - 5));
        }
        return null;
      } }, $.exports = K;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(p, $, G) {
      function m(q, b, A) {
        this.name = q, this.dir = A.dir, this.date = A.date, this.comment = A.comment, this.unixPermissions = A.unixPermissions, this.dosPermissions = A.dosPermissions, this._data = b, this._dataBinary = A.binary, this.options = { compression: A.compression, compressionOptions: A.compressionOptions };
      }
      var C = p("./stream/StreamHelper"), O = p("./stream/DataWorker"), E = p("./utf8"), U = p("./compressedObject"), Y = p("./stream/GenericWorker");
      m.prototype = { internalStream: function(q) {
        var b = null, A = "string";
        try {
          if (!q)
            throw new Error("No output type specified.");
          var d = (A = q.toLowerCase()) === "string" || A === "text";
          A !== "binarystring" && A !== "text" || (A = "string"), b = this._decompressWorker();
          var g = !this._dataBinary;
          g && !d && (b = b.pipe(new E.Utf8EncodeWorker())), !g && d && (b = b.pipe(new E.Utf8DecodeWorker()));
        } catch (M) {
          (b = new Y("error")).error(M);
        }
        return new C(b, A, "");
      }, async: function(q, b) {
        return this.internalStream(q).accumulate(b);
      }, nodeStream: function(q, b) {
        return this.internalStream(q || "nodebuffer").toNodejsStream(b);
      }, _compressWorker: function(q, b) {
        if (this._data instanceof U && this._data.compression.magic === q.magic)
          return this._data.getCompressedWorker();
        var A = this._decompressWorker();
        return this._dataBinary || (A = A.pipe(new E.Utf8EncodeWorker())), U.createWorkerFrom(A, q, b);
      }, _decompressWorker: function() {
        return this._data instanceof U ? this._data.getContentWorker() : this._data instanceof Y ? this._data : new O(this._data);
      } };
      for (var H = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], K = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, B = 0; B < H.length; B++)
        m.prototype[H[B]] = K;
      $.exports = m;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(p, $, G) {
      (function(m) {
        var C, O, E = m.MutationObserver || m.WebKitMutationObserver;
        if (E) {
          var U = 0, Y = new E(q), H = m.document.createTextNode("");
          Y.observe(H, { characterData: !0 }), C = function() {
            H.data = U = ++U % 2;
          };
        } else if (m.setImmediate || m.MessageChannel === void 0)
          C = "document" in m && "onreadystatechange" in m.document.createElement("script") ? function() {
            var b = m.document.createElement("script");
            b.onreadystatechange = function() {
              q(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
            }, m.document.documentElement.appendChild(b);
          } : function() {
            setTimeout(q, 0);
          };
        else {
          var K = new m.MessageChannel();
          K.port1.onmessage = q, C = function() {
            K.port2.postMessage(0);
          };
        }
        var B = [];
        function q() {
          var b, A;
          O = !0;
          for (var d = B.length; d; ) {
            for (A = B, B = [], b = -1; ++b < d; )
              A[b]();
            d = B.length;
          }
          O = !1;
        }
        $.exports = function(b) {
          B.push(b) !== 1 || O || C();
        };
      }).call(this, typeof xr < "u" ? xr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(p, $, G) {
      var m = p("immediate");
      function C() {
      }
      var O = {}, E = ["REJECTED"], U = ["FULFILLED"], Y = ["PENDING"];
      function H(d) {
        if (typeof d != "function")
          throw new TypeError("resolver must be a function");
        this.state = Y, this.queue = [], this.outcome = void 0, d !== C && b(this, d);
      }
      function K(d, g, M) {
        this.promise = d, typeof g == "function" && (this.onFulfilled = g, this.callFulfilled = this.otherCallFulfilled), typeof M == "function" && (this.onRejected = M, this.callRejected = this.otherCallRejected);
      }
      function B(d, g, M) {
        m(function() {
          var x;
          try {
            x = g(M);
          } catch (F) {
            return O.reject(d, F);
          }
          x === d ? O.reject(d, new TypeError("Cannot resolve promise with itself")) : O.resolve(d, x);
        });
      }
      function q(d) {
        var g = d && d.then;
        if (d && (typeof d == "object" || typeof d == "function") && typeof g == "function")
          return function() {
            g.apply(d, arguments);
          };
      }
      function b(d, g) {
        var M = !1;
        function x(V) {
          M || (M = !0, O.reject(d, V));
        }
        function F(V) {
          M || (M = !0, O.resolve(d, V));
        }
        var z = A(function() {
          g(F, x);
        });
        z.status === "error" && x(z.value);
      }
      function A(d, g) {
        var M = {};
        try {
          M.value = d(g), M.status = "success";
        } catch (x) {
          M.status = "error", M.value = x;
        }
        return M;
      }
      ($.exports = H).prototype.finally = function(d) {
        if (typeof d != "function")
          return this;
        var g = this.constructor;
        return this.then(function(M) {
          return g.resolve(d()).then(function() {
            return M;
          });
        }, function(M) {
          return g.resolve(d()).then(function() {
            throw M;
          });
        });
      }, H.prototype.catch = function(d) {
        return this.then(null, d);
      }, H.prototype.then = function(d, g) {
        if (typeof d != "function" && this.state === U || typeof g != "function" && this.state === E)
          return this;
        var M = new this.constructor(C);
        return this.state !== Y ? B(M, this.state === U ? d : g, this.outcome) : this.queue.push(new K(M, d, g)), M;
      }, K.prototype.callFulfilled = function(d) {
        O.resolve(this.promise, d);
      }, K.prototype.otherCallFulfilled = function(d) {
        B(this.promise, this.onFulfilled, d);
      }, K.prototype.callRejected = function(d) {
        O.reject(this.promise, d);
      }, K.prototype.otherCallRejected = function(d) {
        B(this.promise, this.onRejected, d);
      }, O.resolve = function(d, g) {
        var M = A(q, g);
        if (M.status === "error")
          return O.reject(d, M.value);
        var x = M.value;
        if (x)
          b(d, x);
        else {
          d.state = U, d.outcome = g;
          for (var F = -1, z = d.queue.length; ++F < z; )
            d.queue[F].callFulfilled(g);
        }
        return d;
      }, O.reject = function(d, g) {
        d.state = E, d.outcome = g;
        for (var M = -1, x = d.queue.length; ++M < x; )
          d.queue[M].callRejected(g);
        return d;
      }, H.resolve = function(d) {
        return d instanceof this ? d : O.resolve(new this(C), d);
      }, H.reject = function(d) {
        var g = new this(C);
        return O.reject(g, d);
      }, H.all = function(d) {
        var g = this;
        if (Object.prototype.toString.call(d) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var M = d.length, x = !1;
        if (!M)
          return this.resolve([]);
        for (var F = new Array(M), z = 0, V = -1, ht = new this(C); ++V < M; )
          ft(d[V], V);
        return ht;
        function ft(gt, zt) {
          g.resolve(gt).then(function(lt) {
            F[zt] = lt, ++z !== M || x || (x = !0, O.resolve(ht, F));
          }, function(lt) {
            x || (x = !0, O.reject(ht, lt));
          });
        }
      }, H.race = function(d) {
        var g = this;
        if (Object.prototype.toString.call(d) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var M = d.length, x = !1;
        if (!M)
          return this.resolve([]);
        for (var F = -1, z = new this(C); ++F < M; )
          V = d[F], g.resolve(V).then(function(ht) {
            x || (x = !0, O.resolve(z, ht));
          }, function(ht) {
            x || (x = !0, O.reject(z, ht));
          });
        var V;
        return z;
      };
    }, { immediate: 36 }], 38: [function(p, $, G) {
      var m = {};
      (0, p("./lib/utils/common").assign)(m, p("./lib/deflate"), p("./lib/inflate"), p("./lib/zlib/constants")), $.exports = m;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(p, $, G) {
      var m = p("./zlib/deflate"), C = p("./utils/common"), O = p("./utils/strings"), E = p("./zlib/messages"), U = p("./zlib/zstream"), Y = Object.prototype.toString, H = 0, K = -1, B = 0, q = 8;
      function b(d) {
        if (!(this instanceof b))
          return new b(d);
        this.options = C.assign({ level: K, method: q, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: B, to: "" }, d || {});
        var g = this.options;
        g.raw && 0 < g.windowBits ? g.windowBits = -g.windowBits : g.gzip && 0 < g.windowBits && g.windowBits < 16 && (g.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new U(), this.strm.avail_out = 0;
        var M = m.deflateInit2(this.strm, g.level, g.method, g.windowBits, g.memLevel, g.strategy);
        if (M !== H)
          throw new Error(E[M]);
        if (g.header && m.deflateSetHeader(this.strm, g.header), g.dictionary) {
          var x;
          if (x = typeof g.dictionary == "string" ? O.string2buf(g.dictionary) : Y.call(g.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(g.dictionary) : g.dictionary, (M = m.deflateSetDictionary(this.strm, x)) !== H)
            throw new Error(E[M]);
          this._dict_set = !0;
        }
      }
      function A(d, g) {
        var M = new b(g);
        if (M.push(d, !0), M.err)
          throw M.msg || E[M.err];
        return M.result;
      }
      b.prototype.push = function(d, g) {
        var M, x, F = this.strm, z = this.options.chunkSize;
        if (this.ended)
          return !1;
        x = g === ~~g ? g : g === !0 ? 4 : 0, typeof d == "string" ? F.input = O.string2buf(d) : Y.call(d) === "[object ArrayBuffer]" ? F.input = new Uint8Array(d) : F.input = d, F.next_in = 0, F.avail_in = F.input.length;
        do {
          if (F.avail_out === 0 && (F.output = new C.Buf8(z), F.next_out = 0, F.avail_out = z), (M = m.deflate(F, x)) !== 1 && M !== H)
            return this.onEnd(M), !(this.ended = !0);
          F.avail_out !== 0 && (F.avail_in !== 0 || x !== 4 && x !== 2) || (this.options.to === "string" ? this.onData(O.buf2binstring(C.shrinkBuf(F.output, F.next_out))) : this.onData(C.shrinkBuf(F.output, F.next_out)));
        } while ((0 < F.avail_in || F.avail_out === 0) && M !== 1);
        return x === 4 ? (M = m.deflateEnd(this.strm), this.onEnd(M), this.ended = !0, M === H) : x !== 2 || (this.onEnd(H), !(F.avail_out = 0));
      }, b.prototype.onData = function(d) {
        this.chunks.push(d);
      }, b.prototype.onEnd = function(d) {
        d === H && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = C.flattenChunks(this.chunks)), this.chunks = [], this.err = d, this.msg = this.strm.msg;
      }, G.Deflate = b, G.deflate = A, G.deflateRaw = function(d, g) {
        return (g = g || {}).raw = !0, A(d, g);
      }, G.gzip = function(d, g) {
        return (g = g || {}).gzip = !0, A(d, g);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(p, $, G) {
      var m = p("./zlib/inflate"), C = p("./utils/common"), O = p("./utils/strings"), E = p("./zlib/constants"), U = p("./zlib/messages"), Y = p("./zlib/zstream"), H = p("./zlib/gzheader"), K = Object.prototype.toString;
      function B(b) {
        if (!(this instanceof B))
          return new B(b);
        this.options = C.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
        var A = this.options;
        A.raw && 0 <= A.windowBits && A.windowBits < 16 && (A.windowBits = -A.windowBits, A.windowBits === 0 && (A.windowBits = -15)), !(0 <= A.windowBits && A.windowBits < 16) || b && b.windowBits || (A.windowBits += 32), 15 < A.windowBits && A.windowBits < 48 && !(15 & A.windowBits) && (A.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Y(), this.strm.avail_out = 0;
        var d = m.inflateInit2(this.strm, A.windowBits);
        if (d !== E.Z_OK)
          throw new Error(U[d]);
        this.header = new H(), m.inflateGetHeader(this.strm, this.header);
      }
      function q(b, A) {
        var d = new B(A);
        if (d.push(b, !0), d.err)
          throw d.msg || U[d.err];
        return d.result;
      }
      B.prototype.push = function(b, A) {
        var d, g, M, x, F, z, V = this.strm, ht = this.options.chunkSize, ft = this.options.dictionary, gt = !1;
        if (this.ended)
          return !1;
        g = A === ~~A ? A : A === !0 ? E.Z_FINISH : E.Z_NO_FLUSH, typeof b == "string" ? V.input = O.binstring2buf(b) : K.call(b) === "[object ArrayBuffer]" ? V.input = new Uint8Array(b) : V.input = b, V.next_in = 0, V.avail_in = V.input.length;
        do {
          if (V.avail_out === 0 && (V.output = new C.Buf8(ht), V.next_out = 0, V.avail_out = ht), (d = m.inflate(V, E.Z_NO_FLUSH)) === E.Z_NEED_DICT && ft && (z = typeof ft == "string" ? O.string2buf(ft) : K.call(ft) === "[object ArrayBuffer]" ? new Uint8Array(ft) : ft, d = m.inflateSetDictionary(this.strm, z)), d === E.Z_BUF_ERROR && gt === !0 && (d = E.Z_OK, gt = !1), d !== E.Z_STREAM_END && d !== E.Z_OK)
            return this.onEnd(d), !(this.ended = !0);
          V.next_out && (V.avail_out !== 0 && d !== E.Z_STREAM_END && (V.avail_in !== 0 || g !== E.Z_FINISH && g !== E.Z_SYNC_FLUSH) || (this.options.to === "string" ? (M = O.utf8border(V.output, V.next_out), x = V.next_out - M, F = O.buf2string(V.output, M), V.next_out = x, V.avail_out = ht - x, x && C.arraySet(V.output, V.output, M, x, 0), this.onData(F)) : this.onData(C.shrinkBuf(V.output, V.next_out)))), V.avail_in === 0 && V.avail_out === 0 && (gt = !0);
        } while ((0 < V.avail_in || V.avail_out === 0) && d !== E.Z_STREAM_END);
        return d === E.Z_STREAM_END && (g = E.Z_FINISH), g === E.Z_FINISH ? (d = m.inflateEnd(this.strm), this.onEnd(d), this.ended = !0, d === E.Z_OK) : g !== E.Z_SYNC_FLUSH || (this.onEnd(E.Z_OK), !(V.avail_out = 0));
      }, B.prototype.onData = function(b) {
        this.chunks.push(b);
      }, B.prototype.onEnd = function(b) {
        b === E.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = C.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, G.Inflate = B, G.inflate = q, G.inflateRaw = function(b, A) {
        return (A = A || {}).raw = !0, q(b, A);
      }, G.ungzip = q;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(p, $, G) {
      var m = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      G.assign = function(E) {
        for (var U = Array.prototype.slice.call(arguments, 1); U.length; ) {
          var Y = U.shift();
          if (Y) {
            if (typeof Y != "object")
              throw new TypeError(Y + "must be non-object");
            for (var H in Y)
              Y.hasOwnProperty(H) && (E[H] = Y[H]);
          }
        }
        return E;
      }, G.shrinkBuf = function(E, U) {
        return E.length === U ? E : E.subarray ? E.subarray(0, U) : (E.length = U, E);
      };
      var C = { arraySet: function(E, U, Y, H, K) {
        if (U.subarray && E.subarray)
          E.set(U.subarray(Y, Y + H), K);
        else
          for (var B = 0; B < H; B++)
            E[K + B] = U[Y + B];
      }, flattenChunks: function(E) {
        var U, Y, H, K, B, q;
        for (U = H = 0, Y = E.length; U < Y; U++)
          H += E[U].length;
        for (q = new Uint8Array(H), U = K = 0, Y = E.length; U < Y; U++)
          B = E[U], q.set(B, K), K += B.length;
        return q;
      } }, O = { arraySet: function(E, U, Y, H, K) {
        for (var B = 0; B < H; B++)
          E[K + B] = U[Y + B];
      }, flattenChunks: function(E) {
        return [].concat.apply([], E);
      } };
      G.setTyped = function(E) {
        E ? (G.Buf8 = Uint8Array, G.Buf16 = Uint16Array, G.Buf32 = Int32Array, G.assign(G, C)) : (G.Buf8 = Array, G.Buf16 = Array, G.Buf32 = Array, G.assign(G, O));
      }, G.setTyped(m);
    }, {}], 42: [function(p, $, G) {
      var m = p("./common"), C = !0, O = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        C = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        O = !1;
      }
      for (var E = new m.Buf8(256), U = 0; U < 256; U++)
        E[U] = 252 <= U ? 6 : 248 <= U ? 5 : 240 <= U ? 4 : 224 <= U ? 3 : 192 <= U ? 2 : 1;
      function Y(H, K) {
        if (K < 65537 && (H.subarray && O || !H.subarray && C))
          return String.fromCharCode.apply(null, m.shrinkBuf(H, K));
        for (var B = "", q = 0; q < K; q++)
          B += String.fromCharCode(H[q]);
        return B;
      }
      E[254] = E[254] = 1, G.string2buf = function(H) {
        var K, B, q, b, A, d = H.length, g = 0;
        for (b = 0; b < d; b++)
          (64512 & (B = H.charCodeAt(b))) == 55296 && b + 1 < d && (64512 & (q = H.charCodeAt(b + 1))) == 56320 && (B = 65536 + (B - 55296 << 10) + (q - 56320), b++), g += B < 128 ? 1 : B < 2048 ? 2 : B < 65536 ? 3 : 4;
        for (K = new m.Buf8(g), b = A = 0; A < g; b++)
          (64512 & (B = H.charCodeAt(b))) == 55296 && b + 1 < d && (64512 & (q = H.charCodeAt(b + 1))) == 56320 && (B = 65536 + (B - 55296 << 10) + (q - 56320), b++), B < 128 ? K[A++] = B : (B < 2048 ? K[A++] = 192 | B >>> 6 : (B < 65536 ? K[A++] = 224 | B >>> 12 : (K[A++] = 240 | B >>> 18, K[A++] = 128 | B >>> 12 & 63), K[A++] = 128 | B >>> 6 & 63), K[A++] = 128 | 63 & B);
        return K;
      }, G.buf2binstring = function(H) {
        return Y(H, H.length);
      }, G.binstring2buf = function(H) {
        for (var K = new m.Buf8(H.length), B = 0, q = K.length; B < q; B++)
          K[B] = H.charCodeAt(B);
        return K;
      }, G.buf2string = function(H, K) {
        var B, q, b, A, d = K || H.length, g = new Array(2 * d);
        for (B = q = 0; B < d; )
          if ((b = H[B++]) < 128)
            g[q++] = b;
          else if (4 < (A = E[b]))
            g[q++] = 65533, B += A - 1;
          else {
            for (b &= A === 2 ? 31 : A === 3 ? 15 : 7; 1 < A && B < d; )
              b = b << 6 | 63 & H[B++], A--;
            1 < A ? g[q++] = 65533 : b < 65536 ? g[q++] = b : (b -= 65536, g[q++] = 55296 | b >> 10 & 1023, g[q++] = 56320 | 1023 & b);
          }
        return Y(g, q);
      }, G.utf8border = function(H, K) {
        var B;
        for ((K = K || H.length) > H.length && (K = H.length), B = K - 1; 0 <= B && (192 & H[B]) == 128; )
          B--;
        return B < 0 || B === 0 ? K : B + E[H[B]] > K ? B : K;
      };
    }, { "./common": 41 }], 43: [function(p, $, G) {
      $.exports = function(m, C, O, E) {
        for (var U = 65535 & m | 0, Y = m >>> 16 & 65535 | 0, H = 0; O !== 0; ) {
          for (O -= H = 2e3 < O ? 2e3 : O; Y = Y + (U = U + C[E++] | 0) | 0, --H; )
            ;
          U %= 65521, Y %= 65521;
        }
        return U | Y << 16 | 0;
      };
    }, {}], 44: [function(p, $, G) {
      $.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(p, $, G) {
      var m = function() {
        for (var C, O = [], E = 0; E < 256; E++) {
          C = E;
          for (var U = 0; U < 8; U++)
            C = 1 & C ? 3988292384 ^ C >>> 1 : C >>> 1;
          O[E] = C;
        }
        return O;
      }();
      $.exports = function(C, O, E, U) {
        var Y = m, H = U + E;
        C ^= -1;
        for (var K = U; K < H; K++)
          C = C >>> 8 ^ Y[255 & (C ^ O[K])];
        return -1 ^ C;
      };
    }, {}], 46: [function(p, $, G) {
      var m, C = p("../utils/common"), O = p("./trees"), E = p("./adler32"), U = p("./crc32"), Y = p("./messages"), H = 0, K = 4, B = 0, q = -2, b = -1, A = 4, d = 2, g = 8, M = 9, x = 286, F = 30, z = 19, V = 2 * x + 1, ht = 15, ft = 3, gt = 258, zt = gt + ft + 1, lt = 42, Et = 113, D = 1, Bt = 2, Ct = 3, Rt = 4;
      function ge(R, Jt) {
        return R.msg = Y[Jt], Jt;
      }
      function ue(R) {
        return (R << 1) - (4 < R ? 9 : 0);
      }
      function Ft(R) {
        for (var Jt = R.length; 0 <= --Jt; )
          R[Jt] = 0;
      }
      function Dt(R) {
        var Jt = R.state, jt = Jt.pending;
        jt > R.avail_out && (jt = R.avail_out), jt !== 0 && (C.arraySet(R.output, Jt.pending_buf, Jt.pending_out, jt, R.next_out), R.next_out += jt, Jt.pending_out += jt, R.total_out += jt, R.avail_out -= jt, Jt.pending -= jt, Jt.pending === 0 && (Jt.pending_out = 0));
      }
      function kt(R, Jt) {
        O._tr_flush_block(R, 0 <= R.block_start ? R.block_start : -1, R.strstart - R.block_start, Jt), R.block_start = R.strstart, Dt(R.strm);
      }
      function Fe(R, Jt) {
        R.pending_buf[R.pending++] = Jt;
      }
      function xe(R, Jt) {
        R.pending_buf[R.pending++] = Jt >>> 8 & 255, R.pending_buf[R.pending++] = 255 & Jt;
      }
      function Zt(R, Jt) {
        var jt, ct, pt = R.max_chain_length, Lt = R.strstart, ie = R.prev_length, Kt = R.nice_match, w = R.strstart > R.w_size - zt ? R.strstart - (R.w_size - zt) : 0, X = R.window, nt = R.w_mask, tt = R.prev, vt = R.strstart + gt, Gt = X[Lt + ie - 1], Xt = X[Lt + ie];
        R.prev_length >= R.good_match && (pt >>= 2), Kt > R.lookahead && (Kt = R.lookahead);
        do
          if (X[(jt = Jt) + ie] === Xt && X[jt + ie - 1] === Gt && X[jt] === X[Lt] && X[++jt] === X[Lt + 1]) {
            Lt += 2, jt++;
            do
              ;
            while (X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && X[++Lt] === X[++jt] && Lt < vt);
            if (ct = gt - (vt - Lt), Lt = vt - gt, ie < ct) {
              if (R.match_start = Jt, Kt <= (ie = ct))
                break;
              Gt = X[Lt + ie - 1], Xt = X[Lt + ie];
            }
          }
        while ((Jt = tt[Jt & nt]) > w && --pt != 0);
        return ie <= R.lookahead ? ie : R.lookahead;
      }
      function ti(R) {
        var Jt, jt, ct, pt, Lt, ie, Kt, w, X, nt, tt = R.w_size;
        do {
          if (pt = R.window_size - R.lookahead - R.strstart, R.strstart >= tt + (tt - zt)) {
            for (C.arraySet(R.window, R.window, tt, tt, 0), R.match_start -= tt, R.strstart -= tt, R.block_start -= tt, Jt = jt = R.hash_size; ct = R.head[--Jt], R.head[Jt] = tt <= ct ? ct - tt : 0, --jt; )
              ;
            for (Jt = jt = tt; ct = R.prev[--Jt], R.prev[Jt] = tt <= ct ? ct - tt : 0, --jt; )
              ;
            pt += tt;
          }
          if (R.strm.avail_in === 0)
            break;
          if (ie = R.strm, Kt = R.window, w = R.strstart + R.lookahead, X = pt, nt = void 0, nt = ie.avail_in, X < nt && (nt = X), jt = nt === 0 ? 0 : (ie.avail_in -= nt, C.arraySet(Kt, ie.input, ie.next_in, nt, w), ie.state.wrap === 1 ? ie.adler = E(ie.adler, Kt, nt, w) : ie.state.wrap === 2 && (ie.adler = U(ie.adler, Kt, nt, w)), ie.next_in += nt, ie.total_in += nt, nt), R.lookahead += jt, R.lookahead + R.insert >= ft)
            for (Lt = R.strstart - R.insert, R.ins_h = R.window[Lt], R.ins_h = (R.ins_h << R.hash_shift ^ R.window[Lt + 1]) & R.hash_mask; R.insert && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[Lt + ft - 1]) & R.hash_mask, R.prev[Lt & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = Lt, Lt++, R.insert--, !(R.lookahead + R.insert < ft)); )
              ;
        } while (R.lookahead < zt && R.strm.avail_in !== 0);
      }
      function Ni(R, Jt) {
        for (var jt, ct; ; ) {
          if (R.lookahead < zt) {
            if (ti(R), R.lookahead < zt && Jt === H)
              return D;
            if (R.lookahead === 0)
              break;
          }
          if (jt = 0, R.lookahead >= ft && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + ft - 1]) & R.hash_mask, jt = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart), jt !== 0 && R.strstart - jt <= R.w_size - zt && (R.match_length = Zt(R, jt)), R.match_length >= ft)
            if (ct = O._tr_tally(R, R.strstart - R.match_start, R.match_length - ft), R.lookahead -= R.match_length, R.match_length <= R.max_lazy_match && R.lookahead >= ft) {
              for (R.match_length--; R.strstart++, R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + ft - 1]) & R.hash_mask, jt = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart, --R.match_length != 0; )
                ;
              R.strstart++;
            } else
              R.strstart += R.match_length, R.match_length = 0, R.ins_h = R.window[R.strstart], R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + 1]) & R.hash_mask;
          else
            ct = O._tr_tally(R, 0, R.window[R.strstart]), R.lookahead--, R.strstart++;
          if (ct && (kt(R, !1), R.strm.avail_out === 0))
            return D;
        }
        return R.insert = R.strstart < ft - 1 ? R.strstart : ft - 1, Jt === K ? (kt(R, !0), R.strm.avail_out === 0 ? Ct : Rt) : R.last_lit && (kt(R, !1), R.strm.avail_out === 0) ? D : Bt;
      }
      function Ie(R, Jt) {
        for (var jt, ct, pt; ; ) {
          if (R.lookahead < zt) {
            if (ti(R), R.lookahead < zt && Jt === H)
              return D;
            if (R.lookahead === 0)
              break;
          }
          if (jt = 0, R.lookahead >= ft && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + ft - 1]) & R.hash_mask, jt = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart), R.prev_length = R.match_length, R.prev_match = R.match_start, R.match_length = ft - 1, jt !== 0 && R.prev_length < R.max_lazy_match && R.strstart - jt <= R.w_size - zt && (R.match_length = Zt(R, jt), R.match_length <= 5 && (R.strategy === 1 || R.match_length === ft && 4096 < R.strstart - R.match_start) && (R.match_length = ft - 1)), R.prev_length >= ft && R.match_length <= R.prev_length) {
            for (pt = R.strstart + R.lookahead - ft, ct = O._tr_tally(R, R.strstart - 1 - R.prev_match, R.prev_length - ft), R.lookahead -= R.prev_length - 1, R.prev_length -= 2; ++R.strstart <= pt && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + ft - 1]) & R.hash_mask, jt = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart), --R.prev_length != 0; )
              ;
            if (R.match_available = 0, R.match_length = ft - 1, R.strstart++, ct && (kt(R, !1), R.strm.avail_out === 0))
              return D;
          } else if (R.match_available) {
            if ((ct = O._tr_tally(R, 0, R.window[R.strstart - 1])) && kt(R, !1), R.strstart++, R.lookahead--, R.strm.avail_out === 0)
              return D;
          } else
            R.match_available = 1, R.strstart++, R.lookahead--;
        }
        return R.match_available && (ct = O._tr_tally(R, 0, R.window[R.strstart - 1]), R.match_available = 0), R.insert = R.strstart < ft - 1 ? R.strstart : ft - 1, Jt === K ? (kt(R, !0), R.strm.avail_out === 0 ? Ct : Rt) : R.last_lit && (kt(R, !1), R.strm.avail_out === 0) ? D : Bt;
      }
      function Ge(R, Jt, jt, ct, pt) {
        this.good_length = R, this.max_lazy = Jt, this.nice_length = jt, this.max_chain = ct, this.func = pt;
      }
      function pi() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = g, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new C.Buf16(2 * V), this.dyn_dtree = new C.Buf16(2 * (2 * F + 1)), this.bl_tree = new C.Buf16(2 * (2 * z + 1)), Ft(this.dyn_ltree), Ft(this.dyn_dtree), Ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new C.Buf16(ht + 1), this.heap = new C.Buf16(2 * x + 1), Ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new C.Buf16(2 * x + 1), Ft(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Li(R) {
        var Jt;
        return R && R.state ? (R.total_in = R.total_out = 0, R.data_type = d, (Jt = R.state).pending = 0, Jt.pending_out = 0, Jt.wrap < 0 && (Jt.wrap = -Jt.wrap), Jt.status = Jt.wrap ? lt : Et, R.adler = Jt.wrap === 2 ? 0 : 1, Jt.last_flush = H, O._tr_init(Jt), B) : ge(R, q);
      }
      function an(R) {
        var Jt = Li(R);
        return Jt === B && function(jt) {
          jt.window_size = 2 * jt.w_size, Ft(jt.head), jt.max_lazy_match = m[jt.level].max_lazy, jt.good_match = m[jt.level].good_length, jt.nice_match = m[jt.level].nice_length, jt.max_chain_length = m[jt.level].max_chain, jt.strstart = 0, jt.block_start = 0, jt.lookahead = 0, jt.insert = 0, jt.match_length = jt.prev_length = ft - 1, jt.match_available = 0, jt.ins_h = 0;
        }(R.state), Jt;
      }
      function Zi(R, Jt, jt, ct, pt, Lt) {
        if (!R)
          return q;
        var ie = 1;
        if (Jt === b && (Jt = 6), ct < 0 ? (ie = 0, ct = -ct) : 15 < ct && (ie = 2, ct -= 16), pt < 1 || M < pt || jt !== g || ct < 8 || 15 < ct || Jt < 0 || 9 < Jt || Lt < 0 || A < Lt)
          return ge(R, q);
        ct === 8 && (ct = 9);
        var Kt = new pi();
        return (R.state = Kt).strm = R, Kt.wrap = ie, Kt.gzhead = null, Kt.w_bits = ct, Kt.w_size = 1 << Kt.w_bits, Kt.w_mask = Kt.w_size - 1, Kt.hash_bits = pt + 7, Kt.hash_size = 1 << Kt.hash_bits, Kt.hash_mask = Kt.hash_size - 1, Kt.hash_shift = ~~((Kt.hash_bits + ft - 1) / ft), Kt.window = new C.Buf8(2 * Kt.w_size), Kt.head = new C.Buf16(Kt.hash_size), Kt.prev = new C.Buf16(Kt.w_size), Kt.lit_bufsize = 1 << pt + 6, Kt.pending_buf_size = 4 * Kt.lit_bufsize, Kt.pending_buf = new C.Buf8(Kt.pending_buf_size), Kt.d_buf = 1 * Kt.lit_bufsize, Kt.l_buf = 3 * Kt.lit_bufsize, Kt.level = Jt, Kt.strategy = Lt, Kt.method = jt, an(R);
      }
      m = [new Ge(0, 0, 0, 0, function(R, Jt) {
        var jt = 65535;
        for (jt > R.pending_buf_size - 5 && (jt = R.pending_buf_size - 5); ; ) {
          if (R.lookahead <= 1) {
            if (ti(R), R.lookahead === 0 && Jt === H)
              return D;
            if (R.lookahead === 0)
              break;
          }
          R.strstart += R.lookahead, R.lookahead = 0;
          var ct = R.block_start + jt;
          if ((R.strstart === 0 || R.strstart >= ct) && (R.lookahead = R.strstart - ct, R.strstart = ct, kt(R, !1), R.strm.avail_out === 0) || R.strstart - R.block_start >= R.w_size - zt && (kt(R, !1), R.strm.avail_out === 0))
            return D;
        }
        return R.insert = 0, Jt === K ? (kt(R, !0), R.strm.avail_out === 0 ? Ct : Rt) : (R.strstart > R.block_start && (kt(R, !1), R.strm.avail_out), D);
      }), new Ge(4, 4, 8, 4, Ni), new Ge(4, 5, 16, 8, Ni), new Ge(4, 6, 32, 32, Ni), new Ge(4, 4, 16, 16, Ie), new Ge(8, 16, 32, 32, Ie), new Ge(8, 16, 128, 128, Ie), new Ge(8, 32, 128, 256, Ie), new Ge(32, 128, 258, 1024, Ie), new Ge(32, 258, 258, 4096, Ie)], G.deflateInit = function(R, Jt) {
        return Zi(R, Jt, g, 15, 8, 0);
      }, G.deflateInit2 = Zi, G.deflateReset = an, G.deflateResetKeep = Li, G.deflateSetHeader = function(R, Jt) {
        return R && R.state ? R.state.wrap !== 2 ? q : (R.state.gzhead = Jt, B) : q;
      }, G.deflate = function(R, Jt) {
        var jt, ct, pt, Lt;
        if (!R || !R.state || 5 < Jt || Jt < 0)
          return R ? ge(R, q) : q;
        if (ct = R.state, !R.output || !R.input && R.avail_in !== 0 || ct.status === 666 && Jt !== K)
          return ge(R, R.avail_out === 0 ? -5 : q);
        if (ct.strm = R, jt = ct.last_flush, ct.last_flush = Jt, ct.status === lt)
          if (ct.wrap === 2)
            R.adler = 0, Fe(ct, 31), Fe(ct, 139), Fe(ct, 8), ct.gzhead ? (Fe(ct, (ct.gzhead.text ? 1 : 0) + (ct.gzhead.hcrc ? 2 : 0) + (ct.gzhead.extra ? 4 : 0) + (ct.gzhead.name ? 8 : 0) + (ct.gzhead.comment ? 16 : 0)), Fe(ct, 255 & ct.gzhead.time), Fe(ct, ct.gzhead.time >> 8 & 255), Fe(ct, ct.gzhead.time >> 16 & 255), Fe(ct, ct.gzhead.time >> 24 & 255), Fe(ct, ct.level === 9 ? 2 : 2 <= ct.strategy || ct.level < 2 ? 4 : 0), Fe(ct, 255 & ct.gzhead.os), ct.gzhead.extra && ct.gzhead.extra.length && (Fe(ct, 255 & ct.gzhead.extra.length), Fe(ct, ct.gzhead.extra.length >> 8 & 255)), ct.gzhead.hcrc && (R.adler = U(R.adler, ct.pending_buf, ct.pending, 0)), ct.gzindex = 0, ct.status = 69) : (Fe(ct, 0), Fe(ct, 0), Fe(ct, 0), Fe(ct, 0), Fe(ct, 0), Fe(ct, ct.level === 9 ? 2 : 2 <= ct.strategy || ct.level < 2 ? 4 : 0), Fe(ct, 3), ct.status = Et);
          else {
            var ie = g + (ct.w_bits - 8 << 4) << 8;
            ie |= (2 <= ct.strategy || ct.level < 2 ? 0 : ct.level < 6 ? 1 : ct.level === 6 ? 2 : 3) << 6, ct.strstart !== 0 && (ie |= 32), ie += 31 - ie % 31, ct.status = Et, xe(ct, ie), ct.strstart !== 0 && (xe(ct, R.adler >>> 16), xe(ct, 65535 & R.adler)), R.adler = 1;
          }
        if (ct.status === 69)
          if (ct.gzhead.extra) {
            for (pt = ct.pending; ct.gzindex < (65535 & ct.gzhead.extra.length) && (ct.pending !== ct.pending_buf_size || (ct.gzhead.hcrc && ct.pending > pt && (R.adler = U(R.adler, ct.pending_buf, ct.pending - pt, pt)), Dt(R), pt = ct.pending, ct.pending !== ct.pending_buf_size)); )
              Fe(ct, 255 & ct.gzhead.extra[ct.gzindex]), ct.gzindex++;
            ct.gzhead.hcrc && ct.pending > pt && (R.adler = U(R.adler, ct.pending_buf, ct.pending - pt, pt)), ct.gzindex === ct.gzhead.extra.length && (ct.gzindex = 0, ct.status = 73);
          } else
            ct.status = 73;
        if (ct.status === 73)
          if (ct.gzhead.name) {
            pt = ct.pending;
            do {
              if (ct.pending === ct.pending_buf_size && (ct.gzhead.hcrc && ct.pending > pt && (R.adler = U(R.adler, ct.pending_buf, ct.pending - pt, pt)), Dt(R), pt = ct.pending, ct.pending === ct.pending_buf_size)) {
                Lt = 1;
                break;
              }
              Lt = ct.gzindex < ct.gzhead.name.length ? 255 & ct.gzhead.name.charCodeAt(ct.gzindex++) : 0, Fe(ct, Lt);
            } while (Lt !== 0);
            ct.gzhead.hcrc && ct.pending > pt && (R.adler = U(R.adler, ct.pending_buf, ct.pending - pt, pt)), Lt === 0 && (ct.gzindex = 0, ct.status = 91);
          } else
            ct.status = 91;
        if (ct.status === 91)
          if (ct.gzhead.comment) {
            pt = ct.pending;
            do {
              if (ct.pending === ct.pending_buf_size && (ct.gzhead.hcrc && ct.pending > pt && (R.adler = U(R.adler, ct.pending_buf, ct.pending - pt, pt)), Dt(R), pt = ct.pending, ct.pending === ct.pending_buf_size)) {
                Lt = 1;
                break;
              }
              Lt = ct.gzindex < ct.gzhead.comment.length ? 255 & ct.gzhead.comment.charCodeAt(ct.gzindex++) : 0, Fe(ct, Lt);
            } while (Lt !== 0);
            ct.gzhead.hcrc && ct.pending > pt && (R.adler = U(R.adler, ct.pending_buf, ct.pending - pt, pt)), Lt === 0 && (ct.status = 103);
          } else
            ct.status = 103;
        if (ct.status === 103 && (ct.gzhead.hcrc ? (ct.pending + 2 > ct.pending_buf_size && Dt(R), ct.pending + 2 <= ct.pending_buf_size && (Fe(ct, 255 & R.adler), Fe(ct, R.adler >> 8 & 255), R.adler = 0, ct.status = Et)) : ct.status = Et), ct.pending !== 0) {
          if (Dt(R), R.avail_out === 0)
            return ct.last_flush = -1, B;
        } else if (R.avail_in === 0 && ue(Jt) <= ue(jt) && Jt !== K)
          return ge(R, -5);
        if (ct.status === 666 && R.avail_in !== 0)
          return ge(R, -5);
        if (R.avail_in !== 0 || ct.lookahead !== 0 || Jt !== H && ct.status !== 666) {
          var Kt = ct.strategy === 2 ? function(w, X) {
            for (var nt; ; ) {
              if (w.lookahead === 0 && (ti(w), w.lookahead === 0)) {
                if (X === H)
                  return D;
                break;
              }
              if (w.match_length = 0, nt = O._tr_tally(w, 0, w.window[w.strstart]), w.lookahead--, w.strstart++, nt && (kt(w, !1), w.strm.avail_out === 0))
                return D;
            }
            return w.insert = 0, X === K ? (kt(w, !0), w.strm.avail_out === 0 ? Ct : Rt) : w.last_lit && (kt(w, !1), w.strm.avail_out === 0) ? D : Bt;
          }(ct, Jt) : ct.strategy === 3 ? function(w, X) {
            for (var nt, tt, vt, Gt, Xt = w.window; ; ) {
              if (w.lookahead <= gt) {
                if (ti(w), w.lookahead <= gt && X === H)
                  return D;
                if (w.lookahead === 0)
                  break;
              }
              if (w.match_length = 0, w.lookahead >= ft && 0 < w.strstart && (tt = Xt[vt = w.strstart - 1]) === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt]) {
                Gt = w.strstart + gt;
                do
                  ;
                while (tt === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt] && tt === Xt[++vt] && vt < Gt);
                w.match_length = gt - (Gt - vt), w.match_length > w.lookahead && (w.match_length = w.lookahead);
              }
              if (w.match_length >= ft ? (nt = O._tr_tally(w, 1, w.match_length - ft), w.lookahead -= w.match_length, w.strstart += w.match_length, w.match_length = 0) : (nt = O._tr_tally(w, 0, w.window[w.strstart]), w.lookahead--, w.strstart++), nt && (kt(w, !1), w.strm.avail_out === 0))
                return D;
            }
            return w.insert = 0, X === K ? (kt(w, !0), w.strm.avail_out === 0 ? Ct : Rt) : w.last_lit && (kt(w, !1), w.strm.avail_out === 0) ? D : Bt;
          }(ct, Jt) : m[ct.level].func(ct, Jt);
          if (Kt !== Ct && Kt !== Rt || (ct.status = 666), Kt === D || Kt === Ct)
            return R.avail_out === 0 && (ct.last_flush = -1), B;
          if (Kt === Bt && (Jt === 1 ? O._tr_align(ct) : Jt !== 5 && (O._tr_stored_block(ct, 0, 0, !1), Jt === 3 && (Ft(ct.head), ct.lookahead === 0 && (ct.strstart = 0, ct.block_start = 0, ct.insert = 0))), Dt(R), R.avail_out === 0))
            return ct.last_flush = -1, B;
        }
        return Jt !== K ? B : ct.wrap <= 0 ? 1 : (ct.wrap === 2 ? (Fe(ct, 255 & R.adler), Fe(ct, R.adler >> 8 & 255), Fe(ct, R.adler >> 16 & 255), Fe(ct, R.adler >> 24 & 255), Fe(ct, 255 & R.total_in), Fe(ct, R.total_in >> 8 & 255), Fe(ct, R.total_in >> 16 & 255), Fe(ct, R.total_in >> 24 & 255)) : (xe(ct, R.adler >>> 16), xe(ct, 65535 & R.adler)), Dt(R), 0 < ct.wrap && (ct.wrap = -ct.wrap), ct.pending !== 0 ? B : 1);
      }, G.deflateEnd = function(R) {
        var Jt;
        return R && R.state ? (Jt = R.state.status) !== lt && Jt !== 69 && Jt !== 73 && Jt !== 91 && Jt !== 103 && Jt !== Et && Jt !== 666 ? ge(R, q) : (R.state = null, Jt === Et ? ge(R, -3) : B) : q;
      }, G.deflateSetDictionary = function(R, Jt) {
        var jt, ct, pt, Lt, ie, Kt, w, X, nt = Jt.length;
        if (!R || !R.state || (Lt = (jt = R.state).wrap) === 2 || Lt === 1 && jt.status !== lt || jt.lookahead)
          return q;
        for (Lt === 1 && (R.adler = E(R.adler, Jt, nt, 0)), jt.wrap = 0, nt >= jt.w_size && (Lt === 0 && (Ft(jt.head), jt.strstart = 0, jt.block_start = 0, jt.insert = 0), X = new C.Buf8(jt.w_size), C.arraySet(X, Jt, nt - jt.w_size, jt.w_size, 0), Jt = X, nt = jt.w_size), ie = R.avail_in, Kt = R.next_in, w = R.input, R.avail_in = nt, R.next_in = 0, R.input = Jt, ti(jt); jt.lookahead >= ft; ) {
          for (ct = jt.strstart, pt = jt.lookahead - (ft - 1); jt.ins_h = (jt.ins_h << jt.hash_shift ^ jt.window[ct + ft - 1]) & jt.hash_mask, jt.prev[ct & jt.w_mask] = jt.head[jt.ins_h], jt.head[jt.ins_h] = ct, ct++, --pt; )
            ;
          jt.strstart = ct, jt.lookahead = ft - 1, ti(jt);
        }
        return jt.strstart += jt.lookahead, jt.block_start = jt.strstart, jt.insert = jt.lookahead, jt.lookahead = 0, jt.match_length = jt.prev_length = ft - 1, jt.match_available = 0, R.next_in = Kt, R.input = w, R.avail_in = ie, jt.wrap = Lt, B;
      }, G.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(p, $, G) {
      $.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(p, $, G) {
      $.exports = function(m, C) {
        var O, E, U, Y, H, K, B, q, b, A, d, g, M, x, F, z, V, ht, ft, gt, zt, lt, Et, D, Bt;
        O = m.state, E = m.next_in, D = m.input, U = E + (m.avail_in - 5), Y = m.next_out, Bt = m.output, H = Y - (C - m.avail_out), K = Y + (m.avail_out - 257), B = O.dmax, q = O.wsize, b = O.whave, A = O.wnext, d = O.window, g = O.hold, M = O.bits, x = O.lencode, F = O.distcode, z = (1 << O.lenbits) - 1, V = (1 << O.distbits) - 1;
        t:
          do {
            M < 15 && (g += D[E++] << M, M += 8, g += D[E++] << M, M += 8), ht = x[g & z];
            e:
              for (; ; ) {
                if (g >>>= ft = ht >>> 24, M -= ft, (ft = ht >>> 16 & 255) === 0)
                  Bt[Y++] = 65535 & ht;
                else {
                  if (!(16 & ft)) {
                    if (!(64 & ft)) {
                      ht = x[(65535 & ht) + (g & (1 << ft) - 1)];
                      continue e;
                    }
                    if (32 & ft) {
                      O.mode = 12;
                      break t;
                    }
                    m.msg = "invalid literal/length code", O.mode = 30;
                    break t;
                  }
                  gt = 65535 & ht, (ft &= 15) && (M < ft && (g += D[E++] << M, M += 8), gt += g & (1 << ft) - 1, g >>>= ft, M -= ft), M < 15 && (g += D[E++] << M, M += 8, g += D[E++] << M, M += 8), ht = F[g & V];
                  i:
                    for (; ; ) {
                      if (g >>>= ft = ht >>> 24, M -= ft, !(16 & (ft = ht >>> 16 & 255))) {
                        if (!(64 & ft)) {
                          ht = F[(65535 & ht) + (g & (1 << ft) - 1)];
                          continue i;
                        }
                        m.msg = "invalid distance code", O.mode = 30;
                        break t;
                      }
                      if (zt = 65535 & ht, M < (ft &= 15) && (g += D[E++] << M, (M += 8) < ft && (g += D[E++] << M, M += 8)), B < (zt += g & (1 << ft) - 1)) {
                        m.msg = "invalid distance too far back", O.mode = 30;
                        break t;
                      }
                      if (g >>>= ft, M -= ft, (ft = Y - H) < zt) {
                        if (b < (ft = zt - ft) && O.sane) {
                          m.msg = "invalid distance too far back", O.mode = 30;
                          break t;
                        }
                        if (Et = d, (lt = 0) === A) {
                          if (lt += q - ft, ft < gt) {
                            for (gt -= ft; Bt[Y++] = d[lt++], --ft; )
                              ;
                            lt = Y - zt, Et = Bt;
                          }
                        } else if (A < ft) {
                          if (lt += q + A - ft, (ft -= A) < gt) {
                            for (gt -= ft; Bt[Y++] = d[lt++], --ft; )
                              ;
                            if (lt = 0, A < gt) {
                              for (gt -= ft = A; Bt[Y++] = d[lt++], --ft; )
                                ;
                              lt = Y - zt, Et = Bt;
                            }
                          }
                        } else if (lt += A - ft, ft < gt) {
                          for (gt -= ft; Bt[Y++] = d[lt++], --ft; )
                            ;
                          lt = Y - zt, Et = Bt;
                        }
                        for (; 2 < gt; )
                          Bt[Y++] = Et[lt++], Bt[Y++] = Et[lt++], Bt[Y++] = Et[lt++], gt -= 3;
                        gt && (Bt[Y++] = Et[lt++], 1 < gt && (Bt[Y++] = Et[lt++]));
                      } else {
                        for (lt = Y - zt; Bt[Y++] = Bt[lt++], Bt[Y++] = Bt[lt++], Bt[Y++] = Bt[lt++], 2 < (gt -= 3); )
                          ;
                        gt && (Bt[Y++] = Bt[lt++], 1 < gt && (Bt[Y++] = Bt[lt++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (E < U && Y < K);
        E -= gt = M >> 3, g &= (1 << (M -= gt << 3)) - 1, m.next_in = E, m.next_out = Y, m.avail_in = E < U ? U - E + 5 : 5 - (E - U), m.avail_out = Y < K ? K - Y + 257 : 257 - (Y - K), O.hold = g, O.bits = M;
      };
    }, {}], 49: [function(p, $, G) {
      var m = p("../utils/common"), C = p("./adler32"), O = p("./crc32"), E = p("./inffast"), U = p("./inftrees"), Y = 1, H = 2, K = 0, B = -2, q = 1, b = 852, A = 592;
      function d(lt) {
        return (lt >>> 24 & 255) + (lt >>> 8 & 65280) + ((65280 & lt) << 8) + ((255 & lt) << 24);
      }
      function g() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new m.Buf16(320), this.work = new m.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function M(lt) {
        var Et;
        return lt && lt.state ? (Et = lt.state, lt.total_in = lt.total_out = Et.total = 0, lt.msg = "", Et.wrap && (lt.adler = 1 & Et.wrap), Et.mode = q, Et.last = 0, Et.havedict = 0, Et.dmax = 32768, Et.head = null, Et.hold = 0, Et.bits = 0, Et.lencode = Et.lendyn = new m.Buf32(b), Et.distcode = Et.distdyn = new m.Buf32(A), Et.sane = 1, Et.back = -1, K) : B;
      }
      function x(lt) {
        var Et;
        return lt && lt.state ? ((Et = lt.state).wsize = 0, Et.whave = 0, Et.wnext = 0, M(lt)) : B;
      }
      function F(lt, Et) {
        var D, Bt;
        return lt && lt.state ? (Bt = lt.state, Et < 0 ? (D = 0, Et = -Et) : (D = 1 + (Et >> 4), Et < 48 && (Et &= 15)), Et && (Et < 8 || 15 < Et) ? B : (Bt.window !== null && Bt.wbits !== Et && (Bt.window = null), Bt.wrap = D, Bt.wbits = Et, x(lt))) : B;
      }
      function z(lt, Et) {
        var D, Bt;
        return lt ? (Bt = new g(), (lt.state = Bt).window = null, (D = F(lt, Et)) !== K && (lt.state = null), D) : B;
      }
      var V, ht, ft = !0;
      function gt(lt) {
        if (ft) {
          var Et;
          for (V = new m.Buf32(512), ht = new m.Buf32(32), Et = 0; Et < 144; )
            lt.lens[Et++] = 8;
          for (; Et < 256; )
            lt.lens[Et++] = 9;
          for (; Et < 280; )
            lt.lens[Et++] = 7;
          for (; Et < 288; )
            lt.lens[Et++] = 8;
          for (U(Y, lt.lens, 0, 288, V, 0, lt.work, { bits: 9 }), Et = 0; Et < 32; )
            lt.lens[Et++] = 5;
          U(H, lt.lens, 0, 32, ht, 0, lt.work, { bits: 5 }), ft = !1;
        }
        lt.lencode = V, lt.lenbits = 9, lt.distcode = ht, lt.distbits = 5;
      }
      function zt(lt, Et, D, Bt) {
        var Ct, Rt = lt.state;
        return Rt.window === null && (Rt.wsize = 1 << Rt.wbits, Rt.wnext = 0, Rt.whave = 0, Rt.window = new m.Buf8(Rt.wsize)), Bt >= Rt.wsize ? (m.arraySet(Rt.window, Et, D - Rt.wsize, Rt.wsize, 0), Rt.wnext = 0, Rt.whave = Rt.wsize) : (Bt < (Ct = Rt.wsize - Rt.wnext) && (Ct = Bt), m.arraySet(Rt.window, Et, D - Bt, Ct, Rt.wnext), (Bt -= Ct) ? (m.arraySet(Rt.window, Et, D - Bt, Bt, 0), Rt.wnext = Bt, Rt.whave = Rt.wsize) : (Rt.wnext += Ct, Rt.wnext === Rt.wsize && (Rt.wnext = 0), Rt.whave < Rt.wsize && (Rt.whave += Ct))), 0;
      }
      G.inflateReset = x, G.inflateReset2 = F, G.inflateResetKeep = M, G.inflateInit = function(lt) {
        return z(lt, 15);
      }, G.inflateInit2 = z, G.inflate = function(lt, Et) {
        var D, Bt, Ct, Rt, ge, ue, Ft, Dt, kt, Fe, xe, Zt, ti, Ni, Ie, Ge, pi, Li, an, Zi, R, Jt, jt, ct, pt = 0, Lt = new m.Buf8(4), ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!lt || !lt.state || !lt.output || !lt.input && lt.avail_in !== 0)
          return B;
        (D = lt.state).mode === 12 && (D.mode = 13), ge = lt.next_out, Ct = lt.output, Ft = lt.avail_out, Rt = lt.next_in, Bt = lt.input, ue = lt.avail_in, Dt = D.hold, kt = D.bits, Fe = ue, xe = Ft, Jt = K;
        t:
          for (; ; )
            switch (D.mode) {
              case q:
                if (D.wrap === 0) {
                  D.mode = 13;
                  break;
                }
                for (; kt < 16; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                if (2 & D.wrap && Dt === 35615) {
                  Lt[D.check = 0] = 255 & Dt, Lt[1] = Dt >>> 8 & 255, D.check = O(D.check, Lt, 2, 0), kt = Dt = 0, D.mode = 2;
                  break;
                }
                if (D.flags = 0, D.head && (D.head.done = !1), !(1 & D.wrap) || (((255 & Dt) << 8) + (Dt >> 8)) % 31) {
                  lt.msg = "incorrect header check", D.mode = 30;
                  break;
                }
                if ((15 & Dt) != 8) {
                  lt.msg = "unknown compression method", D.mode = 30;
                  break;
                }
                if (kt -= 4, R = 8 + (15 & (Dt >>>= 4)), D.wbits === 0)
                  D.wbits = R;
                else if (R > D.wbits) {
                  lt.msg = "invalid window size", D.mode = 30;
                  break;
                }
                D.dmax = 1 << R, lt.adler = D.check = 1, D.mode = 512 & Dt ? 10 : 12, kt = Dt = 0;
                break;
              case 2:
                for (; kt < 16; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                if (D.flags = Dt, (255 & D.flags) != 8) {
                  lt.msg = "unknown compression method", D.mode = 30;
                  break;
                }
                if (57344 & D.flags) {
                  lt.msg = "unknown header flags set", D.mode = 30;
                  break;
                }
                D.head && (D.head.text = Dt >> 8 & 1), 512 & D.flags && (Lt[0] = 255 & Dt, Lt[1] = Dt >>> 8 & 255, D.check = O(D.check, Lt, 2, 0)), kt = Dt = 0, D.mode = 3;
              case 3:
                for (; kt < 32; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                D.head && (D.head.time = Dt), 512 & D.flags && (Lt[0] = 255 & Dt, Lt[1] = Dt >>> 8 & 255, Lt[2] = Dt >>> 16 & 255, Lt[3] = Dt >>> 24 & 255, D.check = O(D.check, Lt, 4, 0)), kt = Dt = 0, D.mode = 4;
              case 4:
                for (; kt < 16; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                D.head && (D.head.xflags = 255 & Dt, D.head.os = Dt >> 8), 512 & D.flags && (Lt[0] = 255 & Dt, Lt[1] = Dt >>> 8 & 255, D.check = O(D.check, Lt, 2, 0)), kt = Dt = 0, D.mode = 5;
              case 5:
                if (1024 & D.flags) {
                  for (; kt < 16; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  D.length = Dt, D.head && (D.head.extra_len = Dt), 512 & D.flags && (Lt[0] = 255 & Dt, Lt[1] = Dt >>> 8 & 255, D.check = O(D.check, Lt, 2, 0)), kt = Dt = 0;
                } else
                  D.head && (D.head.extra = null);
                D.mode = 6;
              case 6:
                if (1024 & D.flags && (ue < (Zt = D.length) && (Zt = ue), Zt && (D.head && (R = D.head.extra_len - D.length, D.head.extra || (D.head.extra = new Array(D.head.extra_len)), m.arraySet(D.head.extra, Bt, Rt, Zt, R)), 512 & D.flags && (D.check = O(D.check, Bt, Zt, Rt)), ue -= Zt, Rt += Zt, D.length -= Zt), D.length))
                  break t;
                D.length = 0, D.mode = 7;
              case 7:
                if (2048 & D.flags) {
                  if (ue === 0)
                    break t;
                  for (Zt = 0; R = Bt[Rt + Zt++], D.head && R && D.length < 65536 && (D.head.name += String.fromCharCode(R)), R && Zt < ue; )
                    ;
                  if (512 & D.flags && (D.check = O(D.check, Bt, Zt, Rt)), ue -= Zt, Rt += Zt, R)
                    break t;
                } else
                  D.head && (D.head.name = null);
                D.length = 0, D.mode = 8;
              case 8:
                if (4096 & D.flags) {
                  if (ue === 0)
                    break t;
                  for (Zt = 0; R = Bt[Rt + Zt++], D.head && R && D.length < 65536 && (D.head.comment += String.fromCharCode(R)), R && Zt < ue; )
                    ;
                  if (512 & D.flags && (D.check = O(D.check, Bt, Zt, Rt)), ue -= Zt, Rt += Zt, R)
                    break t;
                } else
                  D.head && (D.head.comment = null);
                D.mode = 9;
              case 9:
                if (512 & D.flags) {
                  for (; kt < 16; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  if (Dt !== (65535 & D.check)) {
                    lt.msg = "header crc mismatch", D.mode = 30;
                    break;
                  }
                  kt = Dt = 0;
                }
                D.head && (D.head.hcrc = D.flags >> 9 & 1, D.head.done = !0), lt.adler = D.check = 0, D.mode = 12;
                break;
              case 10:
                for (; kt < 32; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                lt.adler = D.check = d(Dt), kt = Dt = 0, D.mode = 11;
              case 11:
                if (D.havedict === 0)
                  return lt.next_out = ge, lt.avail_out = Ft, lt.next_in = Rt, lt.avail_in = ue, D.hold = Dt, D.bits = kt, 2;
                lt.adler = D.check = 1, D.mode = 12;
              case 12:
                if (Et === 5 || Et === 6)
                  break t;
              case 13:
                if (D.last) {
                  Dt >>>= 7 & kt, kt -= 7 & kt, D.mode = 27;
                  break;
                }
                for (; kt < 3; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                switch (D.last = 1 & Dt, kt -= 1, 3 & (Dt >>>= 1)) {
                  case 0:
                    D.mode = 14;
                    break;
                  case 1:
                    if (gt(D), D.mode = 20, Et !== 6)
                      break;
                    Dt >>>= 2, kt -= 2;
                    break t;
                  case 2:
                    D.mode = 17;
                    break;
                  case 3:
                    lt.msg = "invalid block type", D.mode = 30;
                }
                Dt >>>= 2, kt -= 2;
                break;
              case 14:
                for (Dt >>>= 7 & kt, kt -= 7 & kt; kt < 32; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                if ((65535 & Dt) != (Dt >>> 16 ^ 65535)) {
                  lt.msg = "invalid stored block lengths", D.mode = 30;
                  break;
                }
                if (D.length = 65535 & Dt, kt = Dt = 0, D.mode = 15, Et === 6)
                  break t;
              case 15:
                D.mode = 16;
              case 16:
                if (Zt = D.length) {
                  if (ue < Zt && (Zt = ue), Ft < Zt && (Zt = Ft), Zt === 0)
                    break t;
                  m.arraySet(Ct, Bt, Rt, Zt, ge), ue -= Zt, Rt += Zt, Ft -= Zt, ge += Zt, D.length -= Zt;
                  break;
                }
                D.mode = 12;
                break;
              case 17:
                for (; kt < 14; ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                if (D.nlen = 257 + (31 & Dt), Dt >>>= 5, kt -= 5, D.ndist = 1 + (31 & Dt), Dt >>>= 5, kt -= 5, D.ncode = 4 + (15 & Dt), Dt >>>= 4, kt -= 4, 286 < D.nlen || 30 < D.ndist) {
                  lt.msg = "too many length or distance symbols", D.mode = 30;
                  break;
                }
                D.have = 0, D.mode = 18;
              case 18:
                for (; D.have < D.ncode; ) {
                  for (; kt < 3; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  D.lens[ie[D.have++]] = 7 & Dt, Dt >>>= 3, kt -= 3;
                }
                for (; D.have < 19; )
                  D.lens[ie[D.have++]] = 0;
                if (D.lencode = D.lendyn, D.lenbits = 7, jt = { bits: D.lenbits }, Jt = U(0, D.lens, 0, 19, D.lencode, 0, D.work, jt), D.lenbits = jt.bits, Jt) {
                  lt.msg = "invalid code lengths set", D.mode = 30;
                  break;
                }
                D.have = 0, D.mode = 19;
              case 19:
                for (; D.have < D.nlen + D.ndist; ) {
                  for (; Ge = (pt = D.lencode[Dt & (1 << D.lenbits) - 1]) >>> 16 & 255, pi = 65535 & pt, !((Ie = pt >>> 24) <= kt); ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  if (pi < 16)
                    Dt >>>= Ie, kt -= Ie, D.lens[D.have++] = pi;
                  else {
                    if (pi === 16) {
                      for (ct = Ie + 2; kt < ct; ) {
                        if (ue === 0)
                          break t;
                        ue--, Dt += Bt[Rt++] << kt, kt += 8;
                      }
                      if (Dt >>>= Ie, kt -= Ie, D.have === 0) {
                        lt.msg = "invalid bit length repeat", D.mode = 30;
                        break;
                      }
                      R = D.lens[D.have - 1], Zt = 3 + (3 & Dt), Dt >>>= 2, kt -= 2;
                    } else if (pi === 17) {
                      for (ct = Ie + 3; kt < ct; ) {
                        if (ue === 0)
                          break t;
                        ue--, Dt += Bt[Rt++] << kt, kt += 8;
                      }
                      kt -= Ie, R = 0, Zt = 3 + (7 & (Dt >>>= Ie)), Dt >>>= 3, kt -= 3;
                    } else {
                      for (ct = Ie + 7; kt < ct; ) {
                        if (ue === 0)
                          break t;
                        ue--, Dt += Bt[Rt++] << kt, kt += 8;
                      }
                      kt -= Ie, R = 0, Zt = 11 + (127 & (Dt >>>= Ie)), Dt >>>= 7, kt -= 7;
                    }
                    if (D.have + Zt > D.nlen + D.ndist) {
                      lt.msg = "invalid bit length repeat", D.mode = 30;
                      break;
                    }
                    for (; Zt--; )
                      D.lens[D.have++] = R;
                  }
                }
                if (D.mode === 30)
                  break;
                if (D.lens[256] === 0) {
                  lt.msg = "invalid code -- missing end-of-block", D.mode = 30;
                  break;
                }
                if (D.lenbits = 9, jt = { bits: D.lenbits }, Jt = U(Y, D.lens, 0, D.nlen, D.lencode, 0, D.work, jt), D.lenbits = jt.bits, Jt) {
                  lt.msg = "invalid literal/lengths set", D.mode = 30;
                  break;
                }
                if (D.distbits = 6, D.distcode = D.distdyn, jt = { bits: D.distbits }, Jt = U(H, D.lens, D.nlen, D.ndist, D.distcode, 0, D.work, jt), D.distbits = jt.bits, Jt) {
                  lt.msg = "invalid distances set", D.mode = 30;
                  break;
                }
                if (D.mode = 20, Et === 6)
                  break t;
              case 20:
                D.mode = 21;
              case 21:
                if (6 <= ue && 258 <= Ft) {
                  lt.next_out = ge, lt.avail_out = Ft, lt.next_in = Rt, lt.avail_in = ue, D.hold = Dt, D.bits = kt, E(lt, xe), ge = lt.next_out, Ct = lt.output, Ft = lt.avail_out, Rt = lt.next_in, Bt = lt.input, ue = lt.avail_in, Dt = D.hold, kt = D.bits, D.mode === 12 && (D.back = -1);
                  break;
                }
                for (D.back = 0; Ge = (pt = D.lencode[Dt & (1 << D.lenbits) - 1]) >>> 16 & 255, pi = 65535 & pt, !((Ie = pt >>> 24) <= kt); ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                if (Ge && !(240 & Ge)) {
                  for (Li = Ie, an = Ge, Zi = pi; Ge = (pt = D.lencode[Zi + ((Dt & (1 << Li + an) - 1) >> Li)]) >>> 16 & 255, pi = 65535 & pt, !(Li + (Ie = pt >>> 24) <= kt); ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  Dt >>>= Li, kt -= Li, D.back += Li;
                }
                if (Dt >>>= Ie, kt -= Ie, D.back += Ie, D.length = pi, Ge === 0) {
                  D.mode = 26;
                  break;
                }
                if (32 & Ge) {
                  D.back = -1, D.mode = 12;
                  break;
                }
                if (64 & Ge) {
                  lt.msg = "invalid literal/length code", D.mode = 30;
                  break;
                }
                D.extra = 15 & Ge, D.mode = 22;
              case 22:
                if (D.extra) {
                  for (ct = D.extra; kt < ct; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  D.length += Dt & (1 << D.extra) - 1, Dt >>>= D.extra, kt -= D.extra, D.back += D.extra;
                }
                D.was = D.length, D.mode = 23;
              case 23:
                for (; Ge = (pt = D.distcode[Dt & (1 << D.distbits) - 1]) >>> 16 & 255, pi = 65535 & pt, !((Ie = pt >>> 24) <= kt); ) {
                  if (ue === 0)
                    break t;
                  ue--, Dt += Bt[Rt++] << kt, kt += 8;
                }
                if (!(240 & Ge)) {
                  for (Li = Ie, an = Ge, Zi = pi; Ge = (pt = D.distcode[Zi + ((Dt & (1 << Li + an) - 1) >> Li)]) >>> 16 & 255, pi = 65535 & pt, !(Li + (Ie = pt >>> 24) <= kt); ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  Dt >>>= Li, kt -= Li, D.back += Li;
                }
                if (Dt >>>= Ie, kt -= Ie, D.back += Ie, 64 & Ge) {
                  lt.msg = "invalid distance code", D.mode = 30;
                  break;
                }
                D.offset = pi, D.extra = 15 & Ge, D.mode = 24;
              case 24:
                if (D.extra) {
                  for (ct = D.extra; kt < ct; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  D.offset += Dt & (1 << D.extra) - 1, Dt >>>= D.extra, kt -= D.extra, D.back += D.extra;
                }
                if (D.offset > D.dmax) {
                  lt.msg = "invalid distance too far back", D.mode = 30;
                  break;
                }
                D.mode = 25;
              case 25:
                if (Ft === 0)
                  break t;
                if (Zt = xe - Ft, D.offset > Zt) {
                  if ((Zt = D.offset - Zt) > D.whave && D.sane) {
                    lt.msg = "invalid distance too far back", D.mode = 30;
                    break;
                  }
                  ti = Zt > D.wnext ? (Zt -= D.wnext, D.wsize - Zt) : D.wnext - Zt, Zt > D.length && (Zt = D.length), Ni = D.window;
                } else
                  Ni = Ct, ti = ge - D.offset, Zt = D.length;
                for (Ft < Zt && (Zt = Ft), Ft -= Zt, D.length -= Zt; Ct[ge++] = Ni[ti++], --Zt; )
                  ;
                D.length === 0 && (D.mode = 21);
                break;
              case 26:
                if (Ft === 0)
                  break t;
                Ct[ge++] = D.length, Ft--, D.mode = 21;
                break;
              case 27:
                if (D.wrap) {
                  for (; kt < 32; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt |= Bt[Rt++] << kt, kt += 8;
                  }
                  if (xe -= Ft, lt.total_out += xe, D.total += xe, xe && (lt.adler = D.check = D.flags ? O(D.check, Ct, xe, ge - xe) : C(D.check, Ct, xe, ge - xe)), xe = Ft, (D.flags ? Dt : d(Dt)) !== D.check) {
                    lt.msg = "incorrect data check", D.mode = 30;
                    break;
                  }
                  kt = Dt = 0;
                }
                D.mode = 28;
              case 28:
                if (D.wrap && D.flags) {
                  for (; kt < 32; ) {
                    if (ue === 0)
                      break t;
                    ue--, Dt += Bt[Rt++] << kt, kt += 8;
                  }
                  if (Dt !== (4294967295 & D.total)) {
                    lt.msg = "incorrect length check", D.mode = 30;
                    break;
                  }
                  kt = Dt = 0;
                }
                D.mode = 29;
              case 29:
                Jt = 1;
                break t;
              case 30:
                Jt = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return B;
            }
        return lt.next_out = ge, lt.avail_out = Ft, lt.next_in = Rt, lt.avail_in = ue, D.hold = Dt, D.bits = kt, (D.wsize || xe !== lt.avail_out && D.mode < 30 && (D.mode < 27 || Et !== 4)) && zt(lt, lt.output, lt.next_out, xe - lt.avail_out) ? (D.mode = 31, -4) : (Fe -= lt.avail_in, xe -= lt.avail_out, lt.total_in += Fe, lt.total_out += xe, D.total += xe, D.wrap && xe && (lt.adler = D.check = D.flags ? O(D.check, Ct, xe, lt.next_out - xe) : C(D.check, Ct, xe, lt.next_out - xe)), lt.data_type = D.bits + (D.last ? 64 : 0) + (D.mode === 12 ? 128 : 0) + (D.mode === 20 || D.mode === 15 ? 256 : 0), (Fe == 0 && xe === 0 || Et === 4) && Jt === K && (Jt = -5), Jt);
      }, G.inflateEnd = function(lt) {
        if (!lt || !lt.state)
          return B;
        var Et = lt.state;
        return Et.window && (Et.window = null), lt.state = null, K;
      }, G.inflateGetHeader = function(lt, Et) {
        var D;
        return lt && lt.state && 2 & (D = lt.state).wrap ? ((D.head = Et).done = !1, K) : B;
      }, G.inflateSetDictionary = function(lt, Et) {
        var D, Bt = Et.length;
        return lt && lt.state ? (D = lt.state).wrap !== 0 && D.mode !== 11 ? B : D.mode === 11 && C(1, Et, Bt, 0) !== D.check ? -3 : zt(lt, Et, Bt, Bt) ? (D.mode = 31, -4) : (D.havedict = 1, K) : B;
      }, G.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(p, $, G) {
      var m = p("../utils/common"), C = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], O = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], E = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], U = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      $.exports = function(Y, H, K, B, q, b, A, d) {
        var g, M, x, F, z, V, ht, ft, gt, zt = d.bits, lt = 0, Et = 0, D = 0, Bt = 0, Ct = 0, Rt = 0, ge = 0, ue = 0, Ft = 0, Dt = 0, kt = null, Fe = 0, xe = new m.Buf16(16), Zt = new m.Buf16(16), ti = null, Ni = 0;
        for (lt = 0; lt <= 15; lt++)
          xe[lt] = 0;
        for (Et = 0; Et < B; Et++)
          xe[H[K + Et]]++;
        for (Ct = zt, Bt = 15; 1 <= Bt && xe[Bt] === 0; Bt--)
          ;
        if (Bt < Ct && (Ct = Bt), Bt === 0)
          return q[b++] = 20971520, q[b++] = 20971520, d.bits = 1, 0;
        for (D = 1; D < Bt && xe[D] === 0; D++)
          ;
        for (Ct < D && (Ct = D), lt = ue = 1; lt <= 15; lt++)
          if (ue <<= 1, (ue -= xe[lt]) < 0)
            return -1;
        if (0 < ue && (Y === 0 || Bt !== 1))
          return -1;
        for (Zt[1] = 0, lt = 1; lt < 15; lt++)
          Zt[lt + 1] = Zt[lt] + xe[lt];
        for (Et = 0; Et < B; Et++)
          H[K + Et] !== 0 && (A[Zt[H[K + Et]]++] = Et);
        if (V = Y === 0 ? (kt = ti = A, 19) : Y === 1 ? (kt = C, Fe -= 257, ti = O, Ni -= 257, 256) : (kt = E, ti = U, -1), lt = D, z = b, ge = Et = Dt = 0, x = -1, F = (Ft = 1 << (Rt = Ct)) - 1, Y === 1 && 852 < Ft || Y === 2 && 592 < Ft)
          return 1;
        for (; ; ) {
          for (ht = lt - ge, gt = A[Et] < V ? (ft = 0, A[Et]) : A[Et] > V ? (ft = ti[Ni + A[Et]], kt[Fe + A[Et]]) : (ft = 96, 0), g = 1 << lt - ge, D = M = 1 << Rt; q[z + (Dt >> ge) + (M -= g)] = ht << 24 | ft << 16 | gt | 0, M !== 0; )
            ;
          for (g = 1 << lt - 1; Dt & g; )
            g >>= 1;
          if (g !== 0 ? (Dt &= g - 1, Dt += g) : Dt = 0, Et++, --xe[lt] == 0) {
            if (lt === Bt)
              break;
            lt = H[K + A[Et]];
          }
          if (Ct < lt && (Dt & F) !== x) {
            for (ge === 0 && (ge = Ct), z += D, ue = 1 << (Rt = lt - ge); Rt + ge < Bt && !((ue -= xe[Rt + ge]) <= 0); )
              Rt++, ue <<= 1;
            if (Ft += 1 << Rt, Y === 1 && 852 < Ft || Y === 2 && 592 < Ft)
              return 1;
            q[x = Dt & F] = Ct << 24 | Rt << 16 | z - b | 0;
          }
        }
        return Dt !== 0 && (q[z + Dt] = lt - ge << 24 | 64 << 16 | 0), d.bits = Ct, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(p, $, G) {
      $.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(p, $, G) {
      var m = p("../utils/common"), C = 0, O = 1;
      function E(pt) {
        for (var Lt = pt.length; 0 <= --Lt; )
          pt[Lt] = 0;
      }
      var U = 0, Y = 29, H = 256, K = H + 1 + Y, B = 30, q = 19, b = 2 * K + 1, A = 15, d = 16, g = 7, M = 256, x = 16, F = 17, z = 18, V = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], ht = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], ft = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], gt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], zt = new Array(2 * (K + 2));
      E(zt);
      var lt = new Array(2 * B);
      E(lt);
      var Et = new Array(512);
      E(Et);
      var D = new Array(256);
      E(D);
      var Bt = new Array(Y);
      E(Bt);
      var Ct, Rt, ge, ue = new Array(B);
      function Ft(pt, Lt, ie, Kt, w) {
        this.static_tree = pt, this.extra_bits = Lt, this.extra_base = ie, this.elems = Kt, this.max_length = w, this.has_stree = pt && pt.length;
      }
      function Dt(pt, Lt) {
        this.dyn_tree = pt, this.max_code = 0, this.stat_desc = Lt;
      }
      function kt(pt) {
        return pt < 256 ? Et[pt] : Et[256 + (pt >>> 7)];
      }
      function Fe(pt, Lt) {
        pt.pending_buf[pt.pending++] = 255 & Lt, pt.pending_buf[pt.pending++] = Lt >>> 8 & 255;
      }
      function xe(pt, Lt, ie) {
        pt.bi_valid > d - ie ? (pt.bi_buf |= Lt << pt.bi_valid & 65535, Fe(pt, pt.bi_buf), pt.bi_buf = Lt >> d - pt.bi_valid, pt.bi_valid += ie - d) : (pt.bi_buf |= Lt << pt.bi_valid & 65535, pt.bi_valid += ie);
      }
      function Zt(pt, Lt, ie) {
        xe(pt, ie[2 * Lt], ie[2 * Lt + 1]);
      }
      function ti(pt, Lt) {
        for (var ie = 0; ie |= 1 & pt, pt >>>= 1, ie <<= 1, 0 < --Lt; )
          ;
        return ie >>> 1;
      }
      function Ni(pt, Lt, ie) {
        var Kt, w, X = new Array(A + 1), nt = 0;
        for (Kt = 1; Kt <= A; Kt++)
          X[Kt] = nt = nt + ie[Kt - 1] << 1;
        for (w = 0; w <= Lt; w++) {
          var tt = pt[2 * w + 1];
          tt !== 0 && (pt[2 * w] = ti(X[tt]++, tt));
        }
      }
      function Ie(pt) {
        var Lt;
        for (Lt = 0; Lt < K; Lt++)
          pt.dyn_ltree[2 * Lt] = 0;
        for (Lt = 0; Lt < B; Lt++)
          pt.dyn_dtree[2 * Lt] = 0;
        for (Lt = 0; Lt < q; Lt++)
          pt.bl_tree[2 * Lt] = 0;
        pt.dyn_ltree[2 * M] = 1, pt.opt_len = pt.static_len = 0, pt.last_lit = pt.matches = 0;
      }
      function Ge(pt) {
        8 < pt.bi_valid ? Fe(pt, pt.bi_buf) : 0 < pt.bi_valid && (pt.pending_buf[pt.pending++] = pt.bi_buf), pt.bi_buf = 0, pt.bi_valid = 0;
      }
      function pi(pt, Lt, ie, Kt) {
        var w = 2 * Lt, X = 2 * ie;
        return pt[w] < pt[X] || pt[w] === pt[X] && Kt[Lt] <= Kt[ie];
      }
      function Li(pt, Lt, ie) {
        for (var Kt = pt.heap[ie], w = ie << 1; w <= pt.heap_len && (w < pt.heap_len && pi(Lt, pt.heap[w + 1], pt.heap[w], pt.depth) && w++, !pi(Lt, Kt, pt.heap[w], pt.depth)); )
          pt.heap[ie] = pt.heap[w], ie = w, w <<= 1;
        pt.heap[ie] = Kt;
      }
      function an(pt, Lt, ie) {
        var Kt, w, X, nt, tt = 0;
        if (pt.last_lit !== 0)
          for (; Kt = pt.pending_buf[pt.d_buf + 2 * tt] << 8 | pt.pending_buf[pt.d_buf + 2 * tt + 1], w = pt.pending_buf[pt.l_buf + tt], tt++, Kt === 0 ? Zt(pt, w, Lt) : (Zt(pt, (X = D[w]) + H + 1, Lt), (nt = V[X]) !== 0 && xe(pt, w -= Bt[X], nt), Zt(pt, X = kt(--Kt), ie), (nt = ht[X]) !== 0 && xe(pt, Kt -= ue[X], nt)), tt < pt.last_lit; )
            ;
        Zt(pt, M, Lt);
      }
      function Zi(pt, Lt) {
        var ie, Kt, w, X = Lt.dyn_tree, nt = Lt.stat_desc.static_tree, tt = Lt.stat_desc.has_stree, vt = Lt.stat_desc.elems, Gt = -1;
        for (pt.heap_len = 0, pt.heap_max = b, ie = 0; ie < vt; ie++)
          X[2 * ie] !== 0 ? (pt.heap[++pt.heap_len] = Gt = ie, pt.depth[ie] = 0) : X[2 * ie + 1] = 0;
        for (; pt.heap_len < 2; )
          X[2 * (w = pt.heap[++pt.heap_len] = Gt < 2 ? ++Gt : 0)] = 1, pt.depth[w] = 0, pt.opt_len--, tt && (pt.static_len -= nt[2 * w + 1]);
        for (Lt.max_code = Gt, ie = pt.heap_len >> 1; 1 <= ie; ie--)
          Li(pt, X, ie);
        for (w = vt; ie = pt.heap[1], pt.heap[1] = pt.heap[pt.heap_len--], Li(pt, X, 1), Kt = pt.heap[1], pt.heap[--pt.heap_max] = ie, pt.heap[--pt.heap_max] = Kt, X[2 * w] = X[2 * ie] + X[2 * Kt], pt.depth[w] = (pt.depth[ie] >= pt.depth[Kt] ? pt.depth[ie] : pt.depth[Kt]) + 1, X[2 * ie + 1] = X[2 * Kt + 1] = w, pt.heap[1] = w++, Li(pt, X, 1), 2 <= pt.heap_len; )
          ;
        pt.heap[--pt.heap_max] = pt.heap[1], function(Xt, Vt) {
          var Ne, Re, de, we, vi, Mi, ni = Vt.dyn_tree, Si = Vt.max_code, wr = Vt.stat_desc.static_tree, jn = Vt.stat_desc.has_stree, tn = Vt.stat_desc.extra_bits, $r = Vt.stat_desc.extra_base, Ri = Vt.stat_desc.max_length, co = 0;
          for (we = 0; we <= A; we++)
            Xt.bl_count[we] = 0;
          for (ni[2 * Xt.heap[Xt.heap_max] + 1] = 0, Ne = Xt.heap_max + 1; Ne < b; Ne++)
            Ri < (we = ni[2 * ni[2 * (Re = Xt.heap[Ne]) + 1] + 1] + 1) && (we = Ri, co++), ni[2 * Re + 1] = we, Si < Re || (Xt.bl_count[we]++, vi = 0, $r <= Re && (vi = tn[Re - $r]), Mi = ni[2 * Re], Xt.opt_len += Mi * (we + vi), jn && (Xt.static_len += Mi * (wr[2 * Re + 1] + vi)));
          if (co !== 0) {
            do {
              for (we = Ri - 1; Xt.bl_count[we] === 0; )
                we--;
              Xt.bl_count[we]--, Xt.bl_count[we + 1] += 2, Xt.bl_count[Ri]--, co -= 2;
            } while (0 < co);
            for (we = Ri; we !== 0; we--)
              for (Re = Xt.bl_count[we]; Re !== 0; )
                Si < (de = Xt.heap[--Ne]) || (ni[2 * de + 1] !== we && (Xt.opt_len += (we - ni[2 * de + 1]) * ni[2 * de], ni[2 * de + 1] = we), Re--);
          }
        }(pt, Lt), Ni(X, Gt, pt.bl_count);
      }
      function R(pt, Lt, ie) {
        var Kt, w, X = -1, nt = Lt[1], tt = 0, vt = 7, Gt = 4;
        for (nt === 0 && (vt = 138, Gt = 3), Lt[2 * (ie + 1) + 1] = 65535, Kt = 0; Kt <= ie; Kt++)
          w = nt, nt = Lt[2 * (Kt + 1) + 1], ++tt < vt && w === nt || (tt < Gt ? pt.bl_tree[2 * w] += tt : w !== 0 ? (w !== X && pt.bl_tree[2 * w]++, pt.bl_tree[2 * x]++) : tt <= 10 ? pt.bl_tree[2 * F]++ : pt.bl_tree[2 * z]++, X = w, Gt = (tt = 0) === nt ? (vt = 138, 3) : w === nt ? (vt = 6, 3) : (vt = 7, 4));
      }
      function Jt(pt, Lt, ie) {
        var Kt, w, X = -1, nt = Lt[1], tt = 0, vt = 7, Gt = 4;
        for (nt === 0 && (vt = 138, Gt = 3), Kt = 0; Kt <= ie; Kt++)
          if (w = nt, nt = Lt[2 * (Kt + 1) + 1], !(++tt < vt && w === nt)) {
            if (tt < Gt)
              for (; Zt(pt, w, pt.bl_tree), --tt != 0; )
                ;
            else
              w !== 0 ? (w !== X && (Zt(pt, w, pt.bl_tree), tt--), Zt(pt, x, pt.bl_tree), xe(pt, tt - 3, 2)) : tt <= 10 ? (Zt(pt, F, pt.bl_tree), xe(pt, tt - 3, 3)) : (Zt(pt, z, pt.bl_tree), xe(pt, tt - 11, 7));
            X = w, Gt = (tt = 0) === nt ? (vt = 138, 3) : w === nt ? (vt = 6, 3) : (vt = 7, 4);
          }
      }
      E(ue);
      var jt = !1;
      function ct(pt, Lt, ie, Kt) {
        xe(pt, (U << 1) + (Kt ? 1 : 0), 3), function(w, X, nt, tt) {
          Ge(w), tt && (Fe(w, nt), Fe(w, ~nt)), m.arraySet(w.pending_buf, w.window, X, nt, w.pending), w.pending += nt;
        }(pt, Lt, ie, !0);
      }
      G._tr_init = function(pt) {
        jt || (function() {
          var Lt, ie, Kt, w, X, nt = new Array(A + 1);
          for (w = Kt = 0; w < Y - 1; w++)
            for (Bt[w] = Kt, Lt = 0; Lt < 1 << V[w]; Lt++)
              D[Kt++] = w;
          for (D[Kt - 1] = w, w = X = 0; w < 16; w++)
            for (ue[w] = X, Lt = 0; Lt < 1 << ht[w]; Lt++)
              Et[X++] = w;
          for (X >>= 7; w < B; w++)
            for (ue[w] = X << 7, Lt = 0; Lt < 1 << ht[w] - 7; Lt++)
              Et[256 + X++] = w;
          for (ie = 0; ie <= A; ie++)
            nt[ie] = 0;
          for (Lt = 0; Lt <= 143; )
            zt[2 * Lt + 1] = 8, Lt++, nt[8]++;
          for (; Lt <= 255; )
            zt[2 * Lt + 1] = 9, Lt++, nt[9]++;
          for (; Lt <= 279; )
            zt[2 * Lt + 1] = 7, Lt++, nt[7]++;
          for (; Lt <= 287; )
            zt[2 * Lt + 1] = 8, Lt++, nt[8]++;
          for (Ni(zt, K + 1, nt), Lt = 0; Lt < B; Lt++)
            lt[2 * Lt + 1] = 5, lt[2 * Lt] = ti(Lt, 5);
          Ct = new Ft(zt, V, H + 1, K, A), Rt = new Ft(lt, ht, 0, B, A), ge = new Ft(new Array(0), ft, 0, q, g);
        }(), jt = !0), pt.l_desc = new Dt(pt.dyn_ltree, Ct), pt.d_desc = new Dt(pt.dyn_dtree, Rt), pt.bl_desc = new Dt(pt.bl_tree, ge), pt.bi_buf = 0, pt.bi_valid = 0, Ie(pt);
      }, G._tr_stored_block = ct, G._tr_flush_block = function(pt, Lt, ie, Kt) {
        var w, X, nt = 0;
        0 < pt.level ? (pt.strm.data_type === 2 && (pt.strm.data_type = function(tt) {
          var vt, Gt = 4093624447;
          for (vt = 0; vt <= 31; vt++, Gt >>>= 1)
            if (1 & Gt && tt.dyn_ltree[2 * vt] !== 0)
              return C;
          if (tt.dyn_ltree[18] !== 0 || tt.dyn_ltree[20] !== 0 || tt.dyn_ltree[26] !== 0)
            return O;
          for (vt = 32; vt < H; vt++)
            if (tt.dyn_ltree[2 * vt] !== 0)
              return O;
          return C;
        }(pt)), Zi(pt, pt.l_desc), Zi(pt, pt.d_desc), nt = function(tt) {
          var vt;
          for (R(tt, tt.dyn_ltree, tt.l_desc.max_code), R(tt, tt.dyn_dtree, tt.d_desc.max_code), Zi(tt, tt.bl_desc), vt = q - 1; 3 <= vt && tt.bl_tree[2 * gt[vt] + 1] === 0; vt--)
            ;
          return tt.opt_len += 3 * (vt + 1) + 5 + 5 + 4, vt;
        }(pt), w = pt.opt_len + 3 + 7 >>> 3, (X = pt.static_len + 3 + 7 >>> 3) <= w && (w = X)) : w = X = ie + 5, ie + 4 <= w && Lt !== -1 ? ct(pt, Lt, ie, Kt) : pt.strategy === 4 || X === w ? (xe(pt, 2 + (Kt ? 1 : 0), 3), an(pt, zt, lt)) : (xe(pt, 4 + (Kt ? 1 : 0), 3), function(tt, vt, Gt, Xt) {
          var Vt;
          for (xe(tt, vt - 257, 5), xe(tt, Gt - 1, 5), xe(tt, Xt - 4, 4), Vt = 0; Vt < Xt; Vt++)
            xe(tt, tt.bl_tree[2 * gt[Vt] + 1], 3);
          Jt(tt, tt.dyn_ltree, vt - 1), Jt(tt, tt.dyn_dtree, Gt - 1);
        }(pt, pt.l_desc.max_code + 1, pt.d_desc.max_code + 1, nt + 1), an(pt, pt.dyn_ltree, pt.dyn_dtree)), Ie(pt), Kt && Ge(pt);
      }, G._tr_tally = function(pt, Lt, ie) {
        return pt.pending_buf[pt.d_buf + 2 * pt.last_lit] = Lt >>> 8 & 255, pt.pending_buf[pt.d_buf + 2 * pt.last_lit + 1] = 255 & Lt, pt.pending_buf[pt.l_buf + pt.last_lit] = 255 & ie, pt.last_lit++, Lt === 0 ? pt.dyn_ltree[2 * ie]++ : (pt.matches++, Lt--, pt.dyn_ltree[2 * (D[ie] + H + 1)]++, pt.dyn_dtree[2 * kt(Lt)]++), pt.last_lit === pt.lit_bufsize - 1;
      }, G._tr_align = function(pt) {
        xe(pt, 2, 3), Zt(pt, M, zt), function(Lt) {
          Lt.bi_valid === 16 ? (Fe(Lt, Lt.bi_buf), Lt.bi_buf = 0, Lt.bi_valid = 0) : 8 <= Lt.bi_valid && (Lt.pending_buf[Lt.pending++] = 255 & Lt.bi_buf, Lt.bi_buf >>= 8, Lt.bi_valid -= 8);
        }(pt);
      };
    }, { "../utils/common": 41 }], 53: [function(p, $, G) {
      $.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(p, $, G) {
      (function(m) {
        (function(C, O) {
          if (!C.setImmediate) {
            var E, U, Y, H, K = 1, B = {}, q = !1, b = C.document, A = Object.getPrototypeOf && Object.getPrototypeOf(C);
            A = A && A.setTimeout ? A : C, E = {}.toString.call(C.process) === "[object process]" ? function(x) {
              process.nextTick(function() {
                g(x);
              });
            } : function() {
              if (C.postMessage && !C.importScripts) {
                var x = !0, F = C.onmessage;
                return C.onmessage = function() {
                  x = !1;
                }, C.postMessage("", "*"), C.onmessage = F, x;
              }
            }() ? (H = "setImmediate$" + Math.random() + "$", C.addEventListener ? C.addEventListener("message", M, !1) : C.attachEvent("onmessage", M), function(x) {
              C.postMessage(H + x, "*");
            }) : C.MessageChannel ? ((Y = new MessageChannel()).port1.onmessage = function(x) {
              g(x.data);
            }, function(x) {
              Y.port2.postMessage(x);
            }) : b && "onreadystatechange" in b.createElement("script") ? (U = b.documentElement, function(x) {
              var F = b.createElement("script");
              F.onreadystatechange = function() {
                g(x), F.onreadystatechange = null, U.removeChild(F), F = null;
              }, U.appendChild(F);
            }) : function(x) {
              setTimeout(g, 0, x);
            }, A.setImmediate = function(x) {
              typeof x != "function" && (x = new Function("" + x));
              for (var F = new Array(arguments.length - 1), z = 0; z < F.length; z++)
                F[z] = arguments[z + 1];
              var V = { callback: x, args: F };
              return B[K] = V, E(K), K++;
            }, A.clearImmediate = d;
          }
          function d(x) {
            delete B[x];
          }
          function g(x) {
            if (q)
              setTimeout(g, 0, x);
            else {
              var F = B[x];
              if (F) {
                q = !0;
                try {
                  (function(z) {
                    var V = z.callback, ht = z.args;
                    switch (ht.length) {
                      case 0:
                        V();
                        break;
                      case 1:
                        V(ht[0]);
                        break;
                      case 2:
                        V(ht[0], ht[1]);
                        break;
                      case 3:
                        V(ht[0], ht[1], ht[2]);
                        break;
                      default:
                        V.apply(O, ht);
                    }
                  })(F);
                } finally {
                  d(x), q = !1;
                }
              }
            }
          }
          function M(x) {
            x.source === C && typeof x.data == "string" && x.data.indexOf(H) === 0 && g(+x.data.slice(H.length));
          }
        })(typeof self > "u" ? m === void 0 ? this : m : self);
      }).call(this, typeof xr < "u" ? xr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Wu);
var Qm = Wu.exports;
const tg = /* @__PURE__ */ Wh(Qm);
var ju = { exports: {} };
(function(T, J) {
  (function(p, $) {
    $();
  })(xr, function() {
    function p(U, Y) {
      return typeof Y > "u" ? Y = { autoBom: !1 } : typeof Y != "object" && (console.warn("Deprecated: Expected third argument to be a object"), Y = { autoBom: !Y }), Y.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(U.type) ? new Blob(["\uFEFF", U], { type: U.type }) : U;
    }
    function $(U, Y, H) {
      var K = new XMLHttpRequest();
      K.open("GET", U), K.responseType = "blob", K.onload = function() {
        E(K.response, Y, H);
      }, K.onerror = function() {
        console.error("could not download file");
      }, K.send();
    }
    function G(U) {
      var Y = new XMLHttpRequest();
      Y.open("HEAD", U, !1);
      try {
        Y.send();
      } catch {
      }
      return 200 <= Y.status && 299 >= Y.status;
    }
    function m(U) {
      try {
        U.dispatchEvent(new MouseEvent("click"));
      } catch {
        var Y = document.createEvent("MouseEvents");
        Y.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), U.dispatchEvent(Y);
      }
    }
    var C = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof xr == "object" && xr.global === xr ? xr : void 0, O = C.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), E = C.saveAs || (typeof window != "object" || window !== C ? function() {
    } : "download" in HTMLAnchorElement.prototype && !O ? function(U, Y, H) {
      var K = C.URL || C.webkitURL, B = document.createElement("a");
      Y = Y || U.name || "download", B.download = Y, B.rel = "noopener", typeof U == "string" ? (B.href = U, B.origin === location.origin ? m(B) : G(B.href) ? $(U, Y, H) : m(B, B.target = "_blank")) : (B.href = K.createObjectURL(U), setTimeout(function() {
        K.revokeObjectURL(B.href);
      }, 4e4), setTimeout(function() {
        m(B);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(U, Y, H) {
      if (Y = Y || U.name || "download", typeof U != "string")
        navigator.msSaveOrOpenBlob(p(U, H), Y);
      else if (G(U))
        $(U, Y, H);
      else {
        var K = document.createElement("a");
        K.href = U, K.target = "_blank", setTimeout(function() {
          m(K);
        });
      }
    } : function(U, Y, H, K) {
      if (K = K || open("", "_blank"), K && (K.document.title = K.document.body.innerText = "downloading..."), typeof U == "string")
        return $(U, Y, H);
      var B = U.type === "application/octet-stream", q = /constructor/i.test(C.HTMLElement) || C.safari, b = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((b || B && q || O) && typeof FileReader < "u") {
        var A = new FileReader();
        A.onloadend = function() {
          var M = A.result;
          M = b ? M : M.replace(/^data:[^;]*;/, "data:attachment/file;"), K ? K.location.href = M : location = M, K = null;
        }, A.readAsDataURL(U);
      } else {
        var d = C.URL || C.webkitURL, g = d.createObjectURL(U);
        K ? K.location = g : location.href = g, K = null, setTimeout(function() {
          d.revokeObjectURL(g);
        }, 4e4);
      }
    });
    C.saveAs = E.saveAs = E, T.exports = E;
  });
})(ju);
var eg = ju.exports;
const ig = /* @__PURE__ */ Wh(eg);
class fg {
  constructor(J, p) {
    window.mars3d ? (this.map = J, this.panoramicViewClass = p, this.coordinate = [
      {
        heading: 0,
        pitch: 0,
        stop: 5
      },
      {
        heading: 90,
        pitch: 0,
        stop: 5
      },
      {
        heading: 180,
        pitch: 0,
        stop: 5
      },
      {
        heading: 270,
        pitch: 0,
        stop: 5
      },
      {
        heading: 0,
        pitch: 90,
        stop: 5
      },
      {
        heading: 0,
        pitch: -90,
        stop: 5
      }
    ], this.screenshotArray = [], this.events = {}, this.timestamp = 0, this.lat, this.lng, this.alt) : console.error("未引入指定插件");
  }
  /**
   * 开启全景图下载
   * @returns { any }
   */
  start(J = !0) {
    var p, $;
    if (J) {
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
      const G = document.getElementById("app"), m = window.innerHeight, C = document.getElementById("mars3dContainer");
      C && (C.style.width = m.toString() + "px", C.style.height = m.toString() + "px"), G !== null && G.classList.add(this.panoramicViewClass);
      let { lat: O, lng: E, alt: U } = this.map.getCameraView();
      this.lat = O, this.lng = E, this.alt = U, this.map.viewer.scene.camera.frustum.fov = window.Cesium.Math.PI_OVER_THREE * 1.5;
    }
    this.screenshotArray && this.coordinate ? this.coordinate[(p = this.screenshotArray) == null ? void 0 : p.length] ? this.map.setCameraView(
      {
        lat: this.lat,
        lng: this.lng,
        alt: this.alt,
        ...this.coordinate[($ = this.screenshotArray) == null ? void 0 : $.length]
      },
      {
        complete: () => {
          setTimeout(() => {
            var G;
            this.screenshot((G = this.screenshotArray) == null ? void 0 : G.length);
          }, 100);
        }
      }
    ) : (this.downloadImagesAsZip(), this.screenshotArray = []) : (console.error("初始化失效"), this.emit("state", {
      type: "error"
    }));
  }
  /**
   * 截图
   * @returns { any }
   */
  async screenshot(J) {
    const p = await this.map.expImage({ download: !1 }), $ = this.map.container.getElementsByClassName(
      "cesium-viewer-cesiumWidgetContainer"
    ), G = await window.domtoimage.toPng(this.map.container, {
      filter: (m) => m !== $[0]
    });
    this.mergeImage(p.image, G, p.width, p.height).then(
      (m) => {
        var E;
        let C = Number(J) + 1, O = {
          src: m,
          name: "全景图_" + this.timestamp + "_" + C + ".jpg"
        };
        this.emit("intercept", O), (E = this.screenshotArray) == null || E.push(O), this.start(!1);
      }
    );
  }
  /**
   * 合成图片
   * @param {any} width
   * @param {any} height
   * @returns {any}
   */
  mergeImage(J, p, $, G) {
    return new Promise((m, C) => {
      const O = document.createElement("canvas");
      O.width = $, O.height = G;
      const E = O.getContext("2d");
      if (O && E) {
        const U = new Image();
        U.crossOrigin = "Anonymous", U.onload = () => {
          E.drawImage(U, 0, 0, $, G);
          const Y = new Image();
          Y.crossOrigin = "Anonymous", Y.onload = () => {
            E.drawImage(Y, 0, 0, $, G);
            const H = O.toDataURL("image/png");
            m(H);
          }, Y.src = p;
        }, U.src = J;
      } else
        C();
    });
  }
  /**
   * 下载图片
   * @returns {any}
   */
  download() {
    this.screenshotArray && this.screenshotArray.forEach((J) => {
      window.mars3d.Util.downloadBase64Image(J.name, J.src);
    });
  }
  /**
   * 下载压缩包
   * @returns
   */
  async downloadImagesAsZip() {
    if (this.screenshotArray) {
      const J = new tg();
      this.screenshotArray.forEach(($) => {
        const G = $.src.split(",")[1], m = atob(G), C = [];
        for (let U = 0; U < m.length; U += 1024) {
          const Y = m.slice(U, U + 1024), H = new Array(Y.length);
          for (let B = 0; B < Y.length; B++)
            H[B] = Y.charCodeAt(B);
          const K = new Uint8Array(H);
          C.push(K);
        }
        const O = new Blob(C, { type: "image/jpeg" }), E = `${$.name}`;
        J.file(E, O, { binary: !0 });
      });
      const p = await J.generateAsync({ type: "blob" });
      ig(p, "CHBIM-Panorama.zip"), this.emit("state", {
        type: "success",
        schedule: 100
      }), this.init();
    }
  }
  /**
   * 初始化
   */
  init() {
    const J = document.getElementById("app");
    J && J.classList.remove(this.panoramicViewClass);
    const p = document.getElementById("mars3dContainer");
    p && (p.style.width = "", p.style.height = "");
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { Function } fn - 回调函数
   * @returns { any }
   */
  on(J, p) {
    this.events[J] ? this.events[J].push(p) : this.events[J] = [p];
  }
  /**
   * events
   * 事件触发
   * @param  { string } event - 事件名
   * @returns { any }
   */
  emit(J, ...p) {
    this.events[J] != null && this.events[J].forEach(($) => $(...p));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off(J, p) {
    this.events[J] = this.events[J].filter(
      ($) => $ !== p
    );
  }
}
const ng = [Pm, $m], pg = {
  continuation: null,
  mapModali: null,
  install(T) {
    if (ng.forEach((C, O) => {
      T.component(C.name, C);
    }), this.continuation) {
      T.config.globalProperties.$continuation = this.continuation;
      return;
    }
    let J = Uu(Fm), p = document.createElement("div"), $ = document.body;
    if ($.appendChild(p), this.loading = J.mount(p), T.config.globalProperties.$loading = this.loading, window.$continuation = this.loading, this.mapModali) {
      T.config.globalProperties.$mapModali = this.mapModali;
      return;
    }
    let G = Uu(jm), m = document.createElement("div");
    $.appendChild(m), this.mapModali = G.mount(m), T.config.globalProperties.$mapModali = this.mapModali, window.$mapModali = this.mapModali;
  }
};
export {
  $m as BimBackgroundPlate,
  Fm as BimCutscenes,
  hg as BimElevationImage,
  cg as BimEntity,
  sg as BimModel,
  lg as BimTerrainProvider,
  ag as BimVector,
  Pm as Button,
  pg as ChbimPlugins,
  jm as MapModali,
  fg as PanoramicView,
  ug as ViewShed
};
