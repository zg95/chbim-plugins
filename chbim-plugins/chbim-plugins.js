var vm = Object.defineProperty;
var ym = (g, $, y) => $ in g ? vm(g, $, { enumerable: !0, configurable: !0, writable: !0, value: y }) : g[$] = y;
var zu = (g, $, y) => (ym(g, typeof $ != "symbol" ? $ + "" : $, y), y);
import { openBlock as oh, createElementBlock as sh, normalizeClass as Bu, renderSlot as Uu, defineComponent as Uh, ref as Bh, onMounted as Fh, createElementVNode as rr, toDisplayString as _m, createApp as Nu } from "vue";
const xm = (g, $) => {
  const y = g.__vccOpts || g;
  for (const [pt, gt] of $)
    y[pt] = gt;
  return y;
}, wm = {
  name: "MukButton"
}, Mm = /* @__PURE__ */ Object.assign(wm, {
  props: {
    size: {
      type: String,
      default: "middle"
    },
    type: {
      type: String,
      default: "default"
    }
  },
  setup(g) {
    return ($, y) => (oh(), sh("button", {
      class: Bu(["muk-btn", [g.size, g.type]])
    }, [
      Uu($.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), Tm = /* @__PURE__ */ xm(Mm, [["__scopeId", "data-v-0e6d93cd"]]);
class Sm {
  constructor() {
    this.dom = {
      mask: document.querySelector(".js-mask"),
      slices: [...document.querySelectorAll(".js-mask__slice")],
      lines: [...document.querySelectorAll(".js-mask-line")],
      logo: document.querySelector(".js-logo"),
      titles: [...document.querySelectorAll(".js-transition-title")]
    }, this.tl = null, this.state = !1, this.init();
  }
  resetScroll() {
    window.scrollTo(0, 0);
  }
  createTimeline() {
    this.tl = new TimelineMax({
      paused: !0,
      onComplete: () => {
        this.state = !1;
      }
    }), this.tl.set(this.dom.titles, {
      yPercent: 0
    }).set(this.dom.mask, {
      autoAlpha: 1
    }).staggerFromTo(
      this.dom.slices,
      1.5,
      {
        xPercent: 100
      },
      {
        xPercent: 0,
        ease: Expo.easeInOut
      },
      -0.075
    ).addCallback(this.resetScroll.bind(this)).addLabel("loaderStart").set(this.dom.titles, {
      yPercent: -100
    }).set([this.dom.lines[0], this.dom.logo], {
      autoAlpha: 1
    }).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: -100,
        rotation: 10
      },
      {
        yPercent: 0,
        rotation: 0,
        ease: Expo.easeOut
      }
    ).addLabel("intermediateFrame").staggerFromTo(
      this.dom.lines,
      0.5,
      {
        scaleX: 0
      },
      {
        scaleX: 1,
        ease: Expo.easeInOut
      },
      0.75,
      "-=1"
    ).set(this.dom.lines, {
      transformOrigin: "right"
    }).fromTo(
      this.dom.lines[0],
      1,
      {
        scaleX: 1
      },
      {
        scaleX: 0,
        ease: Expo.easeInOut
      }
    ).fromTo(
      this.dom.logo,
      1,
      {
        yPercent: 0
      },
      {
        yPercent: 105,
        ease: Expo.easeOut
      },
      "-=1"
    ).staggerFromTo(
      this.dom.slices,
      0.5,
      {
        xPercent: 0
      },
      {
        xPercent: 100,
        ease: Expo.easeInOut
      },
      0.075
    ).set(this.dom.mask, {
      autoAlpha: 0
    }).addLabel("imagesStart", "-=0.85").staggerFromTo(
      this.dom.titles,
      1.5,
      {
        yPercent: 100
      },
      {
        yPercent: 0,
        ease: Expo.easeInOut
      },
      0.05,
      "imagesStart"
    ).addLabel("loaderEnd");
  }
  continuation() {
    this.init(), this.resetScroll(), this.tl.tweenFromTo("loaderStart", "loaderEnd");
  }
  show() {
    this.init(), this.tl.tweenFromTo("loaderStart", "intermediateFrame");
  }
  hide() {
    this.resetScroll(), this.tl.tweenFromTo("intermediateFrame", "loaderEnd");
  }
  init() {
    document.querySelector(".mask-line.js-mask-line") && document.querySelector(".mask-line.js-mask-line").removeAttribute("style"), document.querySelector(".mask-line__inner.js-mask-line") && document.querySelector(".mask-line__inner.js-mask-line").removeAttribute("style"), this.createTimeline();
  }
}
const Em = { class: "mask js-mask" }, Am = /* @__PURE__ */ rr("div", { class: "mask__slice js-mask__slice" }, null, -1), Pm = /* @__PURE__ */ rr("div", { class: "mask__slice js-mask__slice" }, null, -1), Lm = /* @__PURE__ */ rr("div", { class: "mask__slice js-mask__slice" }, null, -1), Cm = { class: "mask__inner" }, Rm = { class: "logo logo--mask" }, bm = {
  class: "js-logo",
  style: { color: "#fff" }
}, Om = /* @__PURE__ */ rr("div", { class: "mask-line js-mask-line" }, [
  /* @__PURE__ */ rr("div", { class: "mask-line__inner js-mask-line" })
], -1), Im = {
  name: "BimCutscenes"
}, Dm = /* @__PURE__ */ Uh({
  ...Im,
  props: {
    text: {
      type: String,
      default: "CHBIM云平台"
    }
  },
  setup(g, { expose: $ }) {
    const y = Bh(null), pt = () => {
      y.value === null && (y.value = new Sm());
    }, gt = () => {
      pt(), y.value.continuation();
    };
    return Fh(() => {
      pt();
    }), $({
      continuation: gt
    }), (S, Mt) => (oh(), sh("div", Em, [
      Am,
      Pm,
      Lm,
      rr("div", Cm, [
        rr("figure", Rm, [
          rr("p", bm, _m(g.text), 1)
        ]),
        Om
      ])
    ]));
  }
});
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
var qi = typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window;
(qi._gsQueue || (qi._gsQueue = [])).push(function() {
  qi._gsDefine(
    "TweenMax",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(g, $, y) {
      var pt = function(at) {
        var Y, _ = [], x = at.length;
        for (Y = 0; Y !== x; _.push(at[Y++]))
          ;
        return _;
      }, gt = function(at, Y, _) {
        var x, B, E = at.cycle;
        for (x in E)
          B = E[x], at[x] = typeof B == "function" ? B(_, Y[_]) : B[_ % B.length];
        delete at.cycle;
      }, S = function(at, Y, _) {
        y.call(this, at, Y, _), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = S.prototype.render;
      }, Mt = 1e-10, kt = y._internals, nt = kt.isSelector, Tt = kt.isArray, Rt = S.prototype = y.to({}, 0.1, {}), vt = [];
      S.version = "2.0.2", Rt.constructor = S, Rt.kill()._gc = !1, S.killTweensOf = S.killDelayedCallsTo = y.killTweensOf, S.getTweensOf = y.getTweensOf, S.lagSmoothing = y.lagSmoothing, S.ticker = y.ticker, S.render = y.render, Rt.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), y.prototype.invalidate.call(this);
      }, Rt.updateTo = function(at, Y) {
        var _, x = this.ratio, B = this.vars.immediateRender || at.immediateRender;
        Y && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
        for (_ in at)
          this.vars[_] = at[_];
        if (this._initted || B) {
          if (Y)
            this._initted = !1, B && this.render(0, !0, !0);
          else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && y._onPluginEvent("_onDisable", this), this._time / this._duration > 0.998) {
            var E = this._totalTime;
            this.render(0, !0, !1), this._initted = !1, this.render(E, !0, !1);
          } else if (this._initted = !1, this._init(), this._time > 0 || B)
            for (var Z, z = 1 / (1 - x), X = this._firstPT; X; )
              Z = X.s + X.c, X.c *= z, X.s = Z - X.c, X = X._next;
        }
        return this;
      }, Rt.render = function(at, Y, _) {
        this._initted || this._duration === 0 && this.vars.repeat && this.invalidate();
        var x, B, E, Z, z, X, it, _t, dt, zt = this._dirty ? this.totalDuration() : this._totalDuration, Yt = this._time, re = this._totalTime, se = this._cycle, we = this._duration, Et = this._rawPrevTime;
        if (at >= zt - 1e-7 && at >= 0 ? (this._totalTime = zt, this._cycle = this._repeat, this._yoyo && 1 & this._cycle ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = we, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (x = !0, B = "onComplete", _ = _ || this._timeline.autoRemoveChildren), we === 0 && (this._initted || !this.vars.lazy || _) && (this._startTime === this._timeline._duration && (at = 0), (0 > Et || 0 >= at && at >= -1e-7 || Et === Mt && this.data !== "isPause") && Et !== at && (_ = !0, Et > Mt && (B = "onReverseComplete")), this._rawPrevTime = _t = !Y || at || Et === at ? at : Mt)) : 1e-7 > at ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (re !== 0 || we === 0 && Et > 0) && (B = "onReverseComplete", x = this._reversed), 0 > at && (this._active = !1, we === 0 && (this._initted || !this.vars.lazy || _) && (Et >= 0 && (_ = !0), this._rawPrevTime = _t = !Y || at || Et === at ? at : Mt)), this._initted || (_ = !0)) : (this._totalTime = this._time = at, this._repeat !== 0 && (Z = we + this._repeatDelay, this._cycle = this._totalTime / Z >> 0, this._cycle !== 0 && this._cycle === this._totalTime / Z && at >= re && this._cycle--, this._time = this._totalTime - this._cycle * Z, this._yoyo && 1 & this._cycle && (this._time = we - this._time, dt = this._yoyoEase || this.vars.yoyoEase, dt && (this._yoyoEase || (dt !== !0 || this._initted ? this._yoyoEase = dt = dt === !0 ? this._ease : dt instanceof Ease ? dt : Ease.map[dt] : (dt = this.vars.ease, this._yoyoEase = dt = dt ? dt instanceof Ease ? dt : typeof dt == "function" ? new Ease(dt, this.vars.easeParams) : Ease.map[dt] || y.defaultEase : y.defaultEase)), this.ratio = dt ? 1 - dt.getRatio((we - this._time) / we) : 0)), this._time > we ? this._time = we : this._time < 0 && (this._time = 0)), this._easeType && !dt ? (z = this._time / we, X = this._easeType, it = this._easePower, (X === 1 || X === 3 && z >= 0.5) && (z = 1 - z), X === 3 && (z *= 2), it === 1 ? z *= z : it === 2 ? z *= z * z : it === 3 ? z *= z * z * z : it === 4 && (z *= z * z * z * z), X === 1 ? this.ratio = 1 - z : X === 2 ? this.ratio = z : this._time / we < 0.5 ? this.ratio = z / 2 : this.ratio = 1 - z / 2) : dt || (this.ratio = this._ease.getRatio(this._time / we))), Yt === this._time && !_ && se === this._cycle)
          return void (re !== this._totalTime && this._onUpdate && (Y || this._callback("onUpdate")));
        if (!this._initted) {
          if (this._init(), !this._initted || this._gc)
            return;
          if (!_ && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
            return this._time = Yt, this._totalTime = re, this._rawPrevTime = Et, this._cycle = se, kt.lazyTweens.push(this), void (this._lazy = [at, Y]);
          !this._time || x || dt ? x && this._ease._calcEnd && !dt && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / we);
        }
        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== Yt && at >= 0 && (this._active = !0), re === 0 && (this._initted === 2 && at > 0 && this._init(), this._startAt && (at >= 0 ? this._startAt.render(at, !0, _) : B || (B = "_dummyGS")), this.vars.onStart && (this._totalTime !== 0 || we === 0) && (Y || this._callback("onStart"))), E = this._firstPT; E; )
          E.f ? E.t[E.p](E.c * this.ratio + E.s) : E.t[E.p] = E.c * this.ratio + E.s, E = E._next;
        this._onUpdate && (0 > at && this._startAt && this._startTime && this._startAt.render(at, !0, _), Y || (this._totalTime !== re || B) && this._callback("onUpdate")), this._cycle !== se && (Y || this._gc || this.vars.onRepeat && this._callback("onRepeat")), B && (!this._gc || _) && (0 > at && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(at, !0, _), x && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !Y && this.vars[B] && this._callback(B), we === 0 && this._rawPrevTime === Mt && _t !== Mt && (this._rawPrevTime = 0));
      }, S.to = function(at, Y, _) {
        return new S(at, Y, _);
      }, S.from = function(at, Y, _) {
        return _.runBackwards = !0, _.immediateRender = _.immediateRender != 0, new S(at, Y, _);
      }, S.fromTo = function(at, Y, _, x) {
        return x.startAt = _, x.immediateRender = x.immediateRender != 0 && _.immediateRender != 0, new S(at, Y, x);
      }, S.staggerTo = S.allTo = function(at, Y, _, x, B, E, Z) {
        x = x || 0;
        var z, X, it, _t, dt = 0, zt = [], Yt = function() {
          _.onComplete && _.onComplete.apply(_.onCompleteScope || this, arguments), B.apply(Z || _.callbackScope || this, E || vt);
        }, re = _.cycle, se = _.startAt && _.startAt.cycle;
        for (Tt(at) || (typeof at == "string" && (at = y.selector(at) || at), nt(at) && (at = pt(at))), at = at || [], 0 > x && (at = pt(at), at.reverse(), x *= -1), z = at.length - 1, it = 0; z >= it; it++) {
          X = {};
          for (_t in _)
            X[_t] = _[_t];
          if (re && (gt(X, at, it), X.duration != null && (Y = X.duration, delete X.duration)), se) {
            se = X.startAt = {};
            for (_t in _.startAt)
              se[_t] = _.startAt[_t];
            gt(X.startAt, at, it);
          }
          X.delay = dt + (X.delay || 0), it === z && B && (X.onComplete = Yt), zt[it] = new S(at[it], Y, X), dt += x;
        }
        return zt;
      }, S.staggerFrom = S.allFrom = function(at, Y, _, x, B, E, Z) {
        return _.runBackwards = !0, _.immediateRender = _.immediateRender != 0, S.staggerTo(at, Y, _, x, B, E, Z);
      }, S.staggerFromTo = S.allFromTo = function(at, Y, _, x, B, E, Z, z) {
        return x.startAt = _, x.immediateRender = x.immediateRender != 0 && _.immediateRender != 0, S.staggerTo(at, Y, x, B, E, Z, z);
      }, S.delayedCall = function(at, Y, _, x, B) {
        return new S(Y, 0, {
          delay: at,
          onComplete: Y,
          onCompleteParams: _,
          callbackScope: x,
          onReverseComplete: Y,
          onReverseCompleteParams: _,
          immediateRender: !1,
          useFrames: B,
          overwrite: 0
        });
      }, S.set = function(at, Y) {
        return new S(at, 0, Y);
      }, S.isTweening = function(at) {
        return y.getTweensOf(at, !0).length > 0;
      };
      var Nt = function(at, Y) {
        for (var _ = [], x = 0, B = at._first; B; )
          B instanceof y ? _[x++] = B : (Y && (_[x++] = B), _ = _.concat(Nt(B, Y)), x = _.length), B = B._next;
        return _;
      }, Ut = S.getAllTweens = function(at) {
        return Nt(g._rootTimeline, at).concat(Nt(g._rootFramesTimeline, at));
      };
      S.killAll = function(at, Y, _, x) {
        Y == null && (Y = !0), _ == null && (_ = !0);
        var B, E, Z, z = Ut(x != 0), X = z.length, it = Y && _ && x;
        for (Z = 0; X > Z; Z++)
          E = z[Z], (it || E instanceof $ || (B = E.target === E.vars.onComplete) && _ || Y && !B) && (at ? E.totalTime(E._reversed ? 0 : E.totalDuration()) : E._enabled(!1, !1));
      }, S.killChildTweensOf = function(at, Y) {
        if (at != null) {
          var _, x, B, E, Z, z = kt.tweenLookup;
          if (typeof at == "string" && (at = y.selector(at) || at), nt(at) && (at = pt(at)), Tt(at))
            for (E = at.length; --E > -1; )
              S.killChildTweensOf(at[E], Y);
          else {
            _ = [];
            for (B in z)
              for (x = z[B].target.parentNode; x; )
                x === at && (_ = _.concat(z[B].tweens)), x = x.parentNode;
            for (Z = _.length, E = 0; Z > E; E++)
              Y && _[E].totalTime(_[E].totalDuration()), _[E]._enabled(!1, !1);
          }
        }
      };
      var Ct = function(at, Y, _, x) {
        Y = Y !== !1, _ = _ !== !1, x = x !== !1;
        for (var B, E, Z = Ut(x), z = Y && _ && x, X = Z.length; --X > -1; )
          E = Z[X], (z || E instanceof $ || (B = E.target === E.vars.onComplete) && _ || Y && !B) && E.paused(at);
      };
      return S.pauseAll = function(at, Y, _) {
        Ct(!0, at, Y, _);
      }, S.resumeAll = function(at, Y, _) {
        Ct(!1, at, Y, _);
      }, S.globalTimeScale = function(at) {
        var Y = g._rootTimeline, _ = y.ticker.time;
        return arguments.length ? (at = at || Mt, Y._startTime = _ - (_ - Y._startTime) * Y._timeScale / at, Y = g._rootFramesTimeline, _ = y.ticker.frame, Y._startTime = _ - (_ - Y._startTime) * Y._timeScale / at, Y._timeScale = g._rootTimeline._timeScale = at, at) : Y._timeScale;
      }, Rt.progress = function(at, Y) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - at : at) + this._cycle * (this._duration + this._repeatDelay),
          Y
        ) : this._time / this.duration();
      }, Rt.totalProgress = function(at, Y) {
        return arguments.length ? this.totalTime(this.totalDuration() * at, Y) : this._totalTime / this.totalDuration();
      }, Rt.time = function(at, Y) {
        return arguments.length ? (this._dirty && this.totalDuration(), at > this._duration && (at = this._duration), this._yoyo && 1 & this._cycle ? at = this._duration - at + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (at += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(at, Y)) : this._time;
      }, Rt.duration = function(at) {
        return arguments.length ? g.prototype.duration.call(this, at) : this._duration;
      }, Rt.totalDuration = function(at) {
        return arguments.length ? this._repeat === -1 ? this : this.duration(
          (at - this._repeat * this._repeatDelay) / (this._repeat + 1)
        ) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration);
      }, Rt.repeat = function(at) {
        return arguments.length ? (this._repeat = at, this._uncache(!0)) : this._repeat;
      }, Rt.repeatDelay = function(at) {
        return arguments.length ? (this._repeatDelay = at, this._uncache(!0)) : this._repeatDelay;
      }, Rt.yoyo = function(at) {
        return arguments.length ? (this._yoyo = at, this) : this._yoyo;
      }, S;
    },
    !0
  ), qi._gsDefine(
    "TimelineLite",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(g, $, y) {
      var pt = function(_) {
        $.call(this, _), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
        var x, B, E = this.vars;
        for (B in E)
          x = E[B], nt(x) && x.join("").indexOf("{self}") !== -1 && (E[B] = this._swapSelfInParams(x));
        nt(E.tweens) && this.add(E.tweens, 0, E.align, E.stagger);
      }, gt = 1e-10, S = y._internals, Mt = pt._internals = {}, kt = S.isSelector, nt = S.isArray, Tt = S.lazyTweens, Rt = S.lazyRender, vt = qi._gsDefine.globals, Nt = function(_) {
        var x, B = {};
        for (x in _)
          B[x] = _[x];
        return B;
      }, Ut = function(_, x, B) {
        var E, Z, z = _.cycle;
        for (E in z)
          Z = z[E], _[E] = typeof Z == "function" ? Z(B, x[B]) : Z[B % Z.length];
        delete _.cycle;
      }, Ct = Mt.pauseCallback = function() {
      }, at = function(_) {
        var x, B = [], E = _.length;
        for (x = 0; x !== E; B.push(_[x++]))
          ;
        return B;
      }, Y = pt.prototype = new $();
      return pt.version = "2.0.2", Y.constructor = pt, Y.kill()._gc = Y._forcingPlayhead = Y._hasPause = !1, Y.to = function(_, x, B, E) {
        var Z = B.repeat && vt.TweenMax || y;
        return x ? this.add(new Z(_, x, B), E) : this.set(_, B, E);
      }, Y.from = function(_, x, B, E) {
        return this.add((B.repeat && vt.TweenMax || y).from(_, x, B), E);
      }, Y.fromTo = function(_, x, B, E, Z) {
        var z = E.repeat && vt.TweenMax || y;
        return x ? this.add(z.fromTo(_, x, B, E), Z) : this.set(_, E, Z);
      }, Y.staggerTo = function(_, x, B, E, Z, z, X, it) {
        var _t, dt, zt = new pt({
          onComplete: z,
          onCompleteParams: X,
          callbackScope: it,
          smoothChildTiming: this.smoothChildTiming
        }), Yt = B.cycle;
        for (typeof _ == "string" && (_ = y.selector(_) || _), _ = _ || [], kt(_) && (_ = at(_)), E = E || 0, 0 > E && (_ = at(_), _.reverse(), E *= -1), dt = 0; dt < _.length; dt++)
          _t = Nt(B), _t.startAt && (_t.startAt = Nt(_t.startAt), _t.startAt.cycle && Ut(_t.startAt, _, dt)), Yt && (Ut(_t, _, dt), _t.duration != null && (x = _t.duration, delete _t.duration)), zt.to(_[dt], x, _t, dt * E);
        return this.add(zt, Z);
      }, Y.staggerFrom = function(_, x, B, E, Z, z, X, it) {
        return B.immediateRender = B.immediateRender != 0, B.runBackwards = !0, this.staggerTo(_, x, B, E, Z, z, X, it);
      }, Y.staggerFromTo = function(_, x, B, E, Z, z, X, it, _t) {
        return E.startAt = B, E.immediateRender = E.immediateRender != 0 && B.immediateRender != 0, this.staggerTo(_, x, E, Z, z, X, it, _t);
      }, Y.call = function(_, x, B, E) {
        return this.add(y.delayedCall(0, _, x, B), E);
      }, Y.set = function(_, x, B) {
        return B = this._parseTimeOrLabel(B, 0, !0), x.immediateRender == null && (x.immediateRender = B === this._time && !this._paused), this.add(new y(_, 0, x), B);
      }, pt.exportRoot = function(_, x) {
        _ = _ || {}, _.smoothChildTiming == null && (_.smoothChildTiming = !0);
        var B, E, Z, z, X = new pt(_), it = X._timeline;
        for (x == null && (x = !0), it._remove(X, !0), X._startTime = 0, X._rawPrevTime = X._time = X._totalTime = it._time, Z = it._first; Z; )
          z = Z._next, x && Z instanceof y && Z.target === Z.vars.onComplete || (E = Z._startTime - Z._delay, 0 > E && (B = 1), X.add(Z, E)), Z = z;
        return it.add(X, 0), B && X.totalDuration(), X;
      }, Y.add = function(_, x, B, E) {
        var Z, z, X, it, _t, dt;
        if (typeof x != "number" && (x = this._parseTimeOrLabel(x, 0, !0, _)), !(_ instanceof g)) {
          if (_ instanceof Array || _ && _.push && nt(_)) {
            for (B = B || "normal", E = E || 0, Z = x, z = _.length, X = 0; z > X; X++)
              nt(it = _[X]) && (it = new pt({ tweens: it })), this.add(it, Z), typeof it != "string" && typeof it != "function" && (B === "sequence" ? Z = it._startTime + it.totalDuration() / it._timeScale : B === "start" && (it._startTime -= it.delay())), Z += E;
            return this._uncache(!0);
          }
          if (typeof _ == "string")
            return this.addLabel(_, x);
          if (typeof _ != "function")
            throw "Cannot add " + _ + " into the timeline; it is not a tween, timeline, function, or string.";
          _ = y.delayedCall(0, _);
        }
        if ($.prototype.add.call(this, _, x), _._time && (Z = Math.max(
          0,
          Math.min(
            _.totalDuration(),
            (this.rawTime() - _._startTime) * _._timeScale
          )
        ), Math.abs(Z - _._totalTime) > 1e-5 && _.render(Z, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
          for (_t = this, dt = _t.rawTime() > _._startTime; _t._timeline; )
            dt && _t._timeline.smoothChildTiming ? _t.totalTime(_t._totalTime, !0) : _t._gc && _t._enabled(!0, !1), _t = _t._timeline;
        return this;
      }, Y.remove = function(_) {
        if (_ instanceof g) {
          this._remove(_, !1);
          var x = _._timeline = _.vars.useFrames ? g._rootFramesTimeline : g._rootTimeline;
          return _._startTime = (_._paused ? _._pauseTime : x._time) - (_._reversed ? _.totalDuration() - _._totalTime : _._totalTime) / _._timeScale, this;
        }
        if (_ instanceof Array || _ && _.push && nt(_)) {
          for (var B = _.length; --B > -1; )
            this.remove(_[B]);
          return this;
        }
        return typeof _ == "string" ? this.removeLabel(_) : this.kill(null, _);
      }, Y._remove = function(_, x) {
        $.prototype._remove.call(this, _, x);
        var B = this._last;
        return B ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this;
      }, Y.append = function(_, x) {
        return this.add(_, this._parseTimeOrLabel(null, x, !0, _));
      }, Y.insert = Y.insertMultiple = function(_, x, B, E) {
        return this.add(_, x || 0, B, E);
      }, Y.appendMultiple = function(_, x, B, E) {
        return this.add(_, this._parseTimeOrLabel(null, x, !0, _), B, E);
      }, Y.addLabel = function(_, x) {
        return this._labels[_] = this._parseTimeOrLabel(x), this;
      }, Y.addPause = function(_, x, B, E) {
        var Z = y.delayedCall(0, Ct, B, E || this);
        return Z.vars.onComplete = Z.vars.onReverseComplete = x, Z.data = "isPause", this._hasPause = !0, this.add(Z, _);
      }, Y.removeLabel = function(_) {
        return delete this._labels[_], this;
      }, Y.getLabelTime = function(_) {
        return this._labels[_] != null ? this._labels[_] : -1;
      }, Y._parseTimeOrLabel = function(_, x, B, E) {
        var Z, z;
        if (E instanceof g && E.timeline === this)
          this.remove(E);
        else if (E && (E instanceof Array || E.push && nt(E)))
          for (z = E.length; --z > -1; )
            E[z] instanceof g && E[z].timeline === this && this.remove(E[z]);
        if (Z = typeof _ != "number" || x ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, typeof x == "string")
          return this._parseTimeOrLabel(
            x,
            B && typeof _ == "number" && this._labels[x] == null ? _ - Z : 0,
            B
          );
        if (x = x || 0, typeof _ != "string" || !isNaN(_) && this._labels[_] == null)
          _ == null && (_ = Z);
        else {
          if (z = _.indexOf("="), z === -1)
            return this._labels[_] == null ? B ? this._labels[_] = Z + x : x : this._labels[_] + x;
          x = parseInt(_.charAt(z - 1) + "1", 10) * Number(_.substr(z + 1)), _ = z > 1 ? this._parseTimeOrLabel(_.substr(0, z - 1), 0, B) : Z;
        }
        return Number(_) + x;
      }, Y.seek = function(_, x) {
        return this.totalTime(
          typeof _ == "number" ? _ : this._parseTimeOrLabel(_),
          x !== !1
        );
      }, Y.stop = function() {
        return this.paused(!0);
      }, Y.gotoAndPlay = function(_, x) {
        return this.play(_, x);
      }, Y.gotoAndStop = function(_, x) {
        return this.pause(_, x);
      }, Y.render = function(_, x, B) {
        this._gc && this._enabled(!0, !1);
        var E, Z, z, X, it, _t, dt, zt = this._time, Yt = this._dirty ? this.totalDuration() : this._totalDuration, re = this._startTime, se = this._timeScale, we = this._paused;
        if (zt !== this._time && (_ += this._time - zt), _ >= Yt - 1e-7 && _ >= 0)
          this._totalTime = this._time = Yt, this._reversed || this._hasPausedChild() || (Z = !0, X = "onComplete", it = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= _ && _ >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === gt) && this._rawPrevTime !== _ && this._first && (it = !0, this._rawPrevTime > gt && (X = "onReverseComplete"))), this._rawPrevTime = this._duration || !x || _ || this._rawPrevTime === _ ? _ : gt, _ = Yt + 1e-4;
        else if (1e-7 > _)
          if (this._totalTime = this._time = 0, (zt !== 0 || this._duration === 0 && this._rawPrevTime !== gt && (this._rawPrevTime > 0 || 0 > _ && this._rawPrevTime >= 0)) && (X = "onReverseComplete", Z = this._reversed), 0 > _)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (it = Z = !0, X = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (it = !0), this._rawPrevTime = _;
          else {
            if (this._rawPrevTime = this._duration || !x || _ || this._rawPrevTime === _ ? _ : gt, _ === 0 && Z)
              for (E = this._first; E && E._startTime === 0; )
                E._duration || (Z = !1), E = E._next;
            _ = 0, this._initted || (it = !0);
          }
        else {
          if (this._hasPause && !this._forcingPlayhead && !x) {
            if (_ >= zt)
              for (E = this._first; E && E._startTime <= _ && !_t; )
                E._duration || E.data !== "isPause" || E.ratio || E._startTime === 0 && this._rawPrevTime === 0 || (_t = E), E = E._next;
            else
              for (E = this._last; E && E._startTime >= _ && !_t; )
                E._duration || E.data === "isPause" && E._rawPrevTime > 0 && (_t = E), E = E._prev;
            _t && (this._time = _ = _t._startTime, this._totalTime = _ + this._cycle * (this._totalDuration + this._repeatDelay));
          }
          this._totalTime = this._time = this._rawPrevTime = _;
        }
        if (this._time !== zt && this._first || B || it || _t) {
          if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== zt && _ > 0 && (this._active = !0), zt === 0 && this.vars.onStart && (this._time === 0 && this._duration || x || this._callback("onStart")), dt = this._time, dt >= zt)
            for (E = this._first; E && (z = E._next, dt === this._time && (!this._paused || we)); )
              (E._active || E._startTime <= dt && !E._paused && !E._gc) && (_t === E && this.pause(), E._reversed ? E.render(
                (E._dirty ? E.totalDuration() : E._totalDuration) - (_ - E._startTime) * E._timeScale,
                x,
                B
              ) : E.render((_ - E._startTime) * E._timeScale, x, B)), E = z;
          else
            for (E = this._last; E && (z = E._prev, dt === this._time && (!this._paused || we)); ) {
              if (E._active || E._startTime <= zt && !E._paused && !E._gc) {
                if (_t === E) {
                  for (_t = E._prev; _t && _t.endTime() > this._time; )
                    _t.render(
                      _t._reversed ? _t.totalDuration() - (_ - _t._startTime) * _t._timeScale : (_ - _t._startTime) * _t._timeScale,
                      x,
                      B
                    ), _t = _t._prev;
                  _t = null, this.pause();
                }
                E._reversed ? E.render(
                  (E._dirty ? E.totalDuration() : E._totalDuration) - (_ - E._startTime) * E._timeScale,
                  x,
                  B
                ) : E.render((_ - E._startTime) * E._timeScale, x, B);
              }
              E = z;
            }
          this._onUpdate && (x || (Tt.length && Rt(), this._callback("onUpdate"))), X && (this._gc || (re === this._startTime || se !== this._timeScale) && (this._time === 0 || Yt >= this.totalDuration()) && (Z && (Tt.length && Rt(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !x && this.vars[X] && this._callback(X)));
        }
      }, Y._hasPausedChild = function() {
        for (var _ = this._first; _; ) {
          if (_._paused || _ instanceof pt && _._hasPausedChild())
            return !0;
          _ = _._next;
        }
        return !1;
      }, Y.getChildren = function(_, x, B, E) {
        E = E || -9999999999;
        for (var Z = [], z = this._first, X = 0; z; )
          z._startTime < E || (z instanceof y ? x !== !1 && (Z[X++] = z) : (B !== !1 && (Z[X++] = z), _ !== !1 && (Z = Z.concat(z.getChildren(!0, x, B)), X = Z.length))), z = z._next;
        return Z;
      }, Y.getTweensOf = function(_, x) {
        var B, E, Z = this._gc, z = [], X = 0;
        for (Z && this._enabled(!0, !0), B = y.getTweensOf(_), E = B.length; --E > -1; )
          (B[E].timeline === this || x && this._contains(B[E])) && (z[X++] = B[E]);
        return Z && this._enabled(!1, !0), z;
      }, Y.recent = function() {
        return this._recent;
      }, Y._contains = function(_) {
        for (var x = _.timeline; x; ) {
          if (x === this)
            return !0;
          x = x.timeline;
        }
        return !1;
      }, Y.shiftChildren = function(_, x, B) {
        B = B || 0;
        for (var E, Z = this._first, z = this._labels; Z; )
          Z._startTime >= B && (Z._startTime += _), Z = Z._next;
        if (x)
          for (E in z)
            z[E] >= B && (z[E] += _);
        return this._uncache(!0);
      }, Y._kill = function(_, x) {
        if (!_ && !x)
          return this._enabled(!1, !1);
        for (var B = x ? this.getTweensOf(x) : this.getChildren(!0, !0, !1), E = B.length, Z = !1; --E > -1; )
          B[E]._kill(_, x) && (Z = !0);
        return Z;
      }, Y.clear = function(_) {
        var x = this.getChildren(!1, !0, !0), B = x.length;
        for (this._time = this._totalTime = 0; --B > -1; )
          x[B]._enabled(!1, !1);
        return _ !== !1 && (this._labels = {}), this._uncache(!0);
      }, Y.invalidate = function() {
        for (var _ = this._first; _; )
          _.invalidate(), _ = _._next;
        return g.prototype.invalidate.call(this);
      }, Y._enabled = function(_, x) {
        if (_ === this._gc)
          for (var B = this._first; B; )
            B._enabled(_, !0), B = B._next;
        return $.prototype._enabled.call(this, _, x);
      }, Y.totalTime = function(_, x, B) {
        this._forcingPlayhead = !0;
        var E = g.prototype.totalTime.apply(this, arguments);
        return this._forcingPlayhead = !1, E;
      }, Y.duration = function(_) {
        return arguments.length ? (this.duration() !== 0 && _ !== 0 && this.timeScale(this._duration / _), this) : (this._dirty && this.totalDuration(), this._duration);
      }, Y.totalDuration = function(_) {
        if (!arguments.length) {
          if (this._dirty) {
            for (var x, B, E = 0, Z = this._last, z = 999999999999; Z; )
              x = Z._prev, Z._dirty && Z.totalDuration(), Z._startTime > z && this._sortChildren && !Z._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(Z, Z._startTime - Z._delay), this._calculatingDuration = 0) : z = Z._startTime, Z._startTime < 0 && !Z._paused && (E -= Z._startTime, this._timeline.smoothChildTiming && (this._startTime += Z._startTime / this._timeScale, this._time -= Z._startTime, this._totalTime -= Z._startTime, this._rawPrevTime -= Z._startTime), this.shiftChildren(-Z._startTime, !1, -9999999999), z = 0), B = Z._startTime + Z._totalDuration / Z._timeScale, B > E && (E = B), Z = x;
            this._duration = this._totalDuration = E, this._dirty = !1;
          }
          return this._totalDuration;
        }
        return _ && this.totalDuration() ? this.timeScale(this._totalDuration / _) : this;
      }, Y.paused = function(_) {
        if (!_)
          for (var x = this._first, B = this._time; x; )
            x._startTime === B && x.data === "isPause" && (x._rawPrevTime = 0), x = x._next;
        return g.prototype.paused.apply(this, arguments);
      }, Y.usesFrames = function() {
        for (var _ = this._timeline; _._timeline; )
          _ = _._timeline;
        return _ === g._rootFramesTimeline;
      }, Y.rawTime = function(_) {
        return _ && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(_) - this._startTime) * this._timeScale;
      }, pt;
    },
    !0
  ), qi._gsDefine(
    "TimelineMax",
    ["TimelineLite", "TweenLite", "easing.Ease"],
    function(g, $, y) {
      var pt = function(vt) {
        g.call(this, vt), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0;
      }, gt = 1e-10, S = $._internals, Mt = S.lazyTweens, kt = S.lazyRender, nt = qi._gsDefine.globals, Tt = new y(null, null, 1, 0), Rt = pt.prototype = new g();
      return Rt.constructor = pt, Rt.kill()._gc = !1, pt.version = "2.0.2", Rt.invalidate = function() {
        return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), g.prototype.invalidate.call(this);
      }, Rt.addCallback = function(vt, Nt, Ut, Ct) {
        return this.add($.delayedCall(0, vt, Ut, Ct), Nt);
      }, Rt.removeCallback = function(vt, Nt) {
        if (vt)
          if (Nt == null)
            this._kill(null, vt);
          else
            for (var Ut = this.getTweensOf(vt, !1), Ct = Ut.length, at = this._parseTimeOrLabel(Nt); --Ct > -1; )
              Ut[Ct]._startTime === at && Ut[Ct]._enabled(!1, !1);
        return this;
      }, Rt.removePause = function(vt) {
        return this.removeCallback(g._internals.pauseCallback, vt);
      }, Rt.tweenTo = function(vt, Nt) {
        Nt = Nt || {};
        var Ut, Ct, at, Y = {
          ease: Tt,
          useFrames: this.usesFrames(),
          immediateRender: !1,
          lazy: !1
        }, _ = Nt.repeat && nt.TweenMax || $;
        for (Ct in Nt)
          Y[Ct] = Nt[Ct];
        return Y.time = this._parseTimeOrLabel(vt), Ut = Math.abs(Number(Y.time) - this._time) / this._timeScale || 1e-3, at = new _(this, Ut, Y), Y.onStart = function() {
          at.target.paused(!0), at.vars.time === at.target.time() || Ut !== at.duration() || at.isFromTo || at.duration(
            Math.abs(at.vars.time - at.target.time()) / at.target._timeScale
          ).render(at.time(), !0, !0), Nt.onStart && Nt.onStart.apply(
            Nt.onStartScope || Nt.callbackScope || at,
            Nt.onStartParams || []
          );
        }, at;
      }, Rt.tweenFromTo = function(vt, Nt, Ut) {
        Ut = Ut || {}, vt = this._parseTimeOrLabel(vt), Ut.startAt = {
          onComplete: this.seek,
          onCompleteParams: [vt],
          callbackScope: this
        }, Ut.immediateRender = Ut.immediateRender !== !1;
        var Ct = this.tweenTo(Nt, Ut);
        return Ct.isFromTo = 1, Ct.duration(Math.abs(Ct.vars.time - vt) / this._timeScale || 1e-3);
      }, Rt.render = function(vt, Nt, Ut) {
        this._gc && this._enabled(!0, !1);
        var Ct, at, Y, _, x, B, E, Z, z = this._time, X = this._dirty ? this.totalDuration() : this._totalDuration, it = this._duration, _t = this._totalTime, dt = this._startTime, zt = this._timeScale, Yt = this._rawPrevTime, re = this._paused, se = this._cycle;
        if (z !== this._time && (vt += this._time - z), vt >= X - 1e-7 && vt >= 0)
          this._locked || (this._totalTime = X, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (at = !0, _ = "onComplete", x = !!this._timeline.autoRemoveChildren, this._duration === 0 && (0 >= vt && vt >= -1e-7 || 0 > Yt || Yt === gt) && Yt !== vt && this._first && (x = !0, Yt > gt && (_ = "onReverseComplete"))), this._rawPrevTime = this._duration || !Nt || vt || this._rawPrevTime === vt ? vt : gt, this._yoyo && 1 & this._cycle ? this._time = vt = 0 : (this._time = it, vt = it + 1e-4);
        else if (1e-7 > vt)
          if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (z !== 0 || it === 0 && Yt !== gt && (Yt > 0 || 0 > vt && Yt >= 0) && !this._locked) && (_ = "onReverseComplete", at = this._reversed), 0 > vt)
            this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (x = at = !0, _ = "onReverseComplete") : Yt >= 0 && this._first && (x = !0), this._rawPrevTime = vt;
          else {
            if (this._rawPrevTime = it || !Nt || vt || this._rawPrevTime === vt ? vt : gt, vt === 0 && at)
              for (Ct = this._first; Ct && Ct._startTime === 0; )
                Ct._duration || (at = !1), Ct = Ct._next;
            vt = 0, this._initted || (x = !0);
          }
        else if (it === 0 && 0 > Yt && (x = !0), this._time = this._rawPrevTime = vt, this._locked || (this._totalTime = vt, this._repeat !== 0 && (B = it + this._repeatDelay, this._cycle = this._totalTime / B >> 0, this._cycle !== 0 && this._cycle === this._totalTime / B && vt >= _t && this._cycle--, this._time = this._totalTime - this._cycle * B, this._yoyo && 1 & this._cycle && (this._time = it - this._time), this._time > it ? (this._time = it, vt = it + 1e-4) : this._time < 0 ? this._time = vt = 0 : vt = this._time)), this._hasPause && !this._forcingPlayhead && !Nt) {
          if (vt = this._time, vt >= z || this._repeat && se !== this._cycle)
            for (Ct = this._first; Ct && Ct._startTime <= vt && !E; )
              Ct._duration || Ct.data !== "isPause" || Ct.ratio || Ct._startTime === 0 && this._rawPrevTime === 0 || (E = Ct), Ct = Ct._next;
          else
            for (Ct = this._last; Ct && Ct._startTime >= vt && !E; )
              Ct._duration || Ct.data === "isPause" && Ct._rawPrevTime > 0 && (E = Ct), Ct = Ct._prev;
          E && E._startTime < it && (this._time = vt = E._startTime, this._totalTime = vt + this._cycle * (this._totalDuration + this._repeatDelay));
        }
        if (this._cycle !== se && !this._locked) {
          var we = this._yoyo && (1 & se) !== 0, Et = we === (this._yoyo && (1 & this._cycle) !== 0), ie = this._totalTime, ze = this._cycle, nn = this._rawPrevTime, Ft = this._time;
          if (this._totalTime = se * it, this._cycle < se ? we = !we : this._totalTime += it, this._time = z, this._rawPrevTime = it === 0 ? Yt - 1e-4 : Yt, this._cycle = se, this._locked = !0, z = we ? 0 : it, this.render(z, Nt, it === 0), Nt || this._gc || this.vars.onRepeat && (this._cycle = ze, this._locked = !1, this._callback("onRepeat")), z !== this._time || (Et && (this._cycle = se, this._locked = !0, z = we ? it + 1e-4 : -1e-4, this.render(z, !0, !1)), this._locked = !1, this._paused && !re))
            return;
          this._time = Ft, this._totalTime = ie, this._cycle = ze, this._rawPrevTime = nn;
        }
        if (!(this._time !== z && this._first || Ut || x || E))
          return void (_t !== this._totalTime && this._onUpdate && (Nt || this._callback("onUpdate")));
        if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== _t && vt > 0 && (this._active = !0), _t === 0 && this.vars.onStart && (this._totalTime === 0 && this._totalDuration || Nt || this._callback("onStart")), Z = this._time, Z >= z)
          for (Ct = this._first; Ct && (Y = Ct._next, Z === this._time && (!this._paused || re)); )
            (Ct._active || Ct._startTime <= this._time && !Ct._paused && !Ct._gc) && (E === Ct && this.pause(), Ct._reversed ? Ct.render(
              (Ct._dirty ? Ct.totalDuration() : Ct._totalDuration) - (vt - Ct._startTime) * Ct._timeScale,
              Nt,
              Ut
            ) : Ct.render((vt - Ct._startTime) * Ct._timeScale, Nt, Ut)), Ct = Y;
        else
          for (Ct = this._last; Ct && (Y = Ct._prev, Z === this._time && (!this._paused || re)); ) {
            if (Ct._active || Ct._startTime <= z && !Ct._paused && !Ct._gc) {
              if (E === Ct) {
                for (E = Ct._prev; E && E.endTime() > this._time; )
                  E.render(
                    E._reversed ? E.totalDuration() - (vt - E._startTime) * E._timeScale : (vt - E._startTime) * E._timeScale,
                    Nt,
                    Ut
                  ), E = E._prev;
                E = null, this.pause();
              }
              Ct._reversed ? Ct.render(
                (Ct._dirty ? Ct.totalDuration() : Ct._totalDuration) - (vt - Ct._startTime) * Ct._timeScale,
                Nt,
                Ut
              ) : Ct.render((vt - Ct._startTime) * Ct._timeScale, Nt, Ut);
            }
            Ct = Y;
          }
        this._onUpdate && (Nt || (Mt.length && kt(), this._callback("onUpdate"))), _ && (this._locked || this._gc || (dt === this._startTime || zt !== this._timeScale) && (this._time === 0 || X >= this.totalDuration()) && (at && (Mt.length && kt(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !Nt && this.vars[_] && this._callback(_)));
      }, Rt.getActive = function(vt, Nt, Ut) {
        vt == null && (vt = !0), Nt == null && (Nt = !0), Ut == null && (Ut = !1);
        var Ct, at, Y = [], _ = this.getChildren(vt, Nt, Ut), x = 0, B = _.length;
        for (Ct = 0; B > Ct; Ct++)
          at = _[Ct], at.isActive() && (Y[x++] = at);
        return Y;
      }, Rt.getLabelAfter = function(vt) {
        vt || vt !== 0 && (vt = this._time);
        var Nt, Ut = this.getLabelsArray(), Ct = Ut.length;
        for (Nt = 0; Ct > Nt; Nt++)
          if (Ut[Nt].time > vt)
            return Ut[Nt].name;
        return null;
      }, Rt.getLabelBefore = function(vt) {
        vt == null && (vt = this._time);
        for (var Nt = this.getLabelsArray(), Ut = Nt.length; --Ut > -1; )
          if (Nt[Ut].time < vt)
            return Nt[Ut].name;
        return null;
      }, Rt.getLabelsArray = function() {
        var vt, Nt = [], Ut = 0;
        for (vt in this._labels)
          Nt[Ut++] = { time: this._labels[vt], name: vt };
        return Nt.sort(function(Ct, at) {
          return Ct.time - at.time;
        }), Nt;
      }, Rt.invalidate = function() {
        return this._locked = !1, g.prototype.invalidate.call(this);
      }, Rt.progress = function(vt, Nt) {
        return arguments.length ? this.totalTime(
          this.duration() * (this._yoyo && 1 & this._cycle ? 1 - vt : vt) + this._cycle * (this._duration + this._repeatDelay),
          Nt
        ) : this._time / this.duration() || 0;
      }, Rt.totalProgress = function(vt, Nt) {
        return arguments.length ? this.totalTime(this.totalDuration() * vt, Nt) : this._totalTime / this.totalDuration() || 0;
      }, Rt.totalDuration = function(vt) {
        return arguments.length ? this._repeat !== -1 && vt ? this.timeScale(this.totalDuration() / vt) : this : (this._dirty && (g.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration);
      }, Rt.time = function(vt, Nt) {
        return arguments.length ? (this._dirty && this.totalDuration(), vt > this._duration && (vt = this._duration), this._yoyo && 1 & this._cycle ? vt = this._duration - vt + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (vt += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(vt, Nt)) : this._time;
      }, Rt.repeat = function(vt) {
        return arguments.length ? (this._repeat = vt, this._uncache(!0)) : this._repeat;
      }, Rt.repeatDelay = function(vt) {
        return arguments.length ? (this._repeatDelay = vt, this._uncache(!0)) : this._repeatDelay;
      }, Rt.yoyo = function(vt) {
        return arguments.length ? (this._yoyo = vt, this) : this._yoyo;
      }, Rt.currentLabel = function(vt) {
        return arguments.length ? this.seek(vt, !0) : this.getLabelBefore(this._time + 1e-8);
      }, pt;
    },
    !0
  ), function() {
    var g = 180 / Math.PI, $ = [], y = [], pt = [], gt = {}, S = qi._gsDefine.globals, Mt = function(_, x, B, E) {
      B === E && (B = E - (E - x) / 1e6), _ === x && (x = _ + (B - _) / 1e6), this.a = _, this.b = x, this.c = B, this.d = E, this.da = E - _, this.ca = B - _, this.ba = x - _;
    }, kt = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", nt = function(_, x, B, E) {
      var Z = { a: _ }, z = {}, X = {}, it = { c: E }, _t = (_ + x) / 2, dt = (x + B) / 2, zt = (B + E) / 2, Yt = (_t + dt) / 2, re = (dt + zt) / 2, se = (re - Yt) / 8;
      return Z.b = _t + (_ - _t) / 4, z.b = Yt + se, Z.c = z.a = (Z.b + z.b) / 2, z.c = X.a = (Yt + re) / 2, X.b = re - se, it.b = zt + (E - zt) / 4, X.c = it.a = (X.b + it.b) / 2, [Z, z, X, it];
    }, Tt = function(_, x, B, E, Z) {
      var z, X, it, _t, dt, zt, Yt, re, se, we, Et, ie, ze, nn = _.length - 1, Ft = 0, $e = _[0].a;
      for (z = 0; nn > z; z++)
        dt = _[Ft], X = dt.a, it = dt.d, _t = _[Ft + 1].d, Z ? (Et = $[z], ie = y[z], ze = (ie + Et) * x * 0.25 / (E ? 0.5 : pt[z] || 0.5), zt = it - (it - X) * (E ? 0.5 * x : Et !== 0 ? ze / Et : 0), Yt = it + (_t - it) * (E ? 0.5 * x : ie !== 0 ? ze / ie : 0), re = it - (zt + ((Yt - zt) * (3 * Et / (Et + ie) + 0.5) / 4 || 0))) : (zt = it - (it - X) * x * 0.5, Yt = it + (_t - it) * x * 0.5, re = it - (zt + Yt) / 2), zt += re, Yt += re, dt.c = se = zt, z !== 0 ? dt.b = $e : dt.b = $e = dt.a + 0.6 * (dt.c - dt.a), dt.da = it - X, dt.ca = se - X, dt.ba = $e - X, B ? (we = nt(X, $e, se, it), _.splice(Ft, 1, we[0], we[1], we[2], we[3]), Ft += 4) : Ft++, $e = Yt;
      dt = _[Ft], dt.b = $e, dt.c = $e + 0.4 * (dt.d - $e), dt.da = dt.d - dt.a, dt.ca = dt.c - dt.a, dt.ba = $e - dt.a, B && (we = nt(dt.a, $e, dt.c, dt.d), _.splice(Ft, 1, we[0], we[1], we[2], we[3]));
    }, Rt = function(_, x, B, E) {
      var Z, z, X, it, _t, dt, zt = [];
      if (E)
        for (_ = [E].concat(_), z = _.length; --z > -1; )
          typeof (dt = _[z][x]) == "string" && dt.charAt(1) === "=" && (_[z][x] = E[x] + Number(dt.charAt(0) + dt.substr(2)));
      if (Z = _.length - 2, 0 > Z)
        return zt[0] = new Mt(_[0][x], 0, 0, _[0][x]), zt;
      for (z = 0; Z > z; z++)
        X = _[z][x], it = _[z + 1][x], zt[z] = new Mt(X, 0, 0, it), B && (_t = _[z + 2][x], $[z] = ($[z] || 0) + (it - X) * (it - X), y[z] = (y[z] || 0) + (_t - it) * (_t - it));
      return zt[z] = new Mt(_[z][x], 0, 0, _[z + 1][x]), zt;
    }, vt = function(_, x, B, E, Z, z) {
      var X, it, _t, dt, zt, Yt, re, se, we = {}, Et = [], ie = z || _[0];
      Z = typeof Z == "string" ? "," + Z + "," : kt, x == null && (x = 1);
      for (it in _[0])
        Et.push(it);
      if (_.length > 1) {
        for (se = _[_.length - 1], re = !0, X = Et.length; --X > -1; )
          if (it = Et[X], Math.abs(ie[it] - se[it]) > 0.05) {
            re = !1;
            break;
          }
        re && (_ = _.concat(), z && _.unshift(z), _.push(_[1]), z = _[_.length - 3]);
      }
      for ($.length = y.length = pt.length = 0, X = Et.length; --X > -1; )
        it = Et[X], gt[it] = Z.indexOf("," + it + ",") !== -1, we[it] = Rt(_, it, gt[it], z);
      for (X = $.length; --X > -1; )
        $[X] = Math.sqrt($[X]), y[X] = Math.sqrt(y[X]);
      if (!E) {
        for (X = Et.length; --X > -1; )
          if (gt[it])
            for (_t = we[Et[X]], Yt = _t.length - 1, dt = 0; Yt > dt; dt++)
              zt = _t[dt + 1].da / y[dt] + _t[dt].da / $[dt] || 0, pt[dt] = (pt[dt] || 0) + zt * zt;
        for (X = pt.length; --X > -1; )
          pt[X] = Math.sqrt(pt[X]);
      }
      for (X = Et.length, dt = B ? 4 : 1; --X > -1; )
        it = Et[X], _t = we[it], Tt(_t, x, B, E, gt[it]), re && (_t.splice(0, dt), _t.splice(_t.length - dt, dt));
      return we;
    }, Nt = function(_, x, B) {
      x = x || "soft";
      var E, Z, z, X, it, _t, dt, zt, Yt, re, se, we = {}, Et = x === "cubic" ? 3 : 2, ie = x === "soft", ze = [];
      if (ie && B && (_ = [B].concat(_)), _ == null || _.length < Et + 1)
        throw "invalid Bezier data";
      for (Yt in _[0])
        ze.push(Yt);
      for (_t = ze.length; --_t > -1; ) {
        for (Yt = ze[_t], we[Yt] = it = [], re = 0, zt = _.length, dt = 0; zt > dt; dt++)
          E = B == null ? _[dt][Yt] : typeof (se = _[dt][Yt]) == "string" && se.charAt(1) === "=" ? B[Yt] + Number(se.charAt(0) + se.substr(2)) : Number(se), ie && dt > 1 && zt - 1 > dt && (it[re++] = (E + it[re - 2]) / 2), it[re++] = E;
        for (zt = re - Et + 1, re = 0, dt = 0; zt > dt; dt += Et)
          E = it[dt], Z = it[dt + 1], z = it[dt + 2], X = Et === 2 ? 0 : it[dt + 3], it[re++] = se = Et === 3 ? new Mt(E, Z, z, X) : new Mt(E, (2 * Z + E) / 3, (2 * Z + z) / 3, z);
        it.length = re;
      }
      return we;
    }, Ut = function(_, x, B) {
      for (var E, Z, z, X, it, _t, dt, zt, Yt, re, se, we = 1 / B, Et = _.length; --Et > -1; )
        for (re = _[Et], z = re.a, X = re.d - z, it = re.c - z, _t = re.b - z, E = Z = 0, zt = 1; B >= zt; zt++)
          dt = we * zt, Yt = 1 - dt, E = Z - (Z = (dt * dt * X + 3 * Yt * (dt * it + Yt * _t)) * dt), se = Et * B + zt - 1, x[se] = (x[se] || 0) + E * E;
    }, Ct = function(_, x) {
      x = x >> 0 || 6;
      var B, E, Z, z, X = [], it = [], _t = 0, dt = 0, zt = x - 1, Yt = [], re = [];
      for (B in _)
        Ut(_[B], X, x);
      for (Z = X.length, E = 0; Z > E; E++)
        _t += Math.sqrt(X[E]), z = E % x, re[z] = _t, z === zt && (dt += _t, z = E / x >> 0, Yt[z] = re, it[z] = dt, _t = 0, re = []);
      return { length: dt, lengths: it, segments: Yt };
    }, at = qi._gsDefine.plugin({
      propName: "bezier",
      priority: -1,
      version: "1.3.8",
      API: 2,
      global: !0,
      init: function(_, x, B) {
        this._target = _, x instanceof Array && (x = { values: x }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = x.timeResolution == null ? 6 : parseInt(x.timeResolution, 10);
        var E, Z, z, X, it, _t = x.values || [], dt = {}, zt = _t[0], Yt = x.autoRotate || B.vars.orientToBezier;
        this._autoRotate = Yt ? Yt instanceof Array ? Yt : [["x", "y", "rotation", Yt === !0 ? 0 : Number(Yt) || 0]] : null;
        for (E in zt)
          this._props.push(E);
        for (z = this._props.length; --z > -1; )
          E = this._props[z], this._overwriteProps.push(E), Z = this._func[E] = typeof _[E] == "function", dt[E] = Z ? _[E.indexOf("set") || typeof _["get" + E.substr(3)] != "function" ? E : "get" + E.substr(3)]() : parseFloat(_[E]), it || dt[E] !== _t[0][E] && (it = dt);
        if (this._beziers = x.type !== "cubic" && x.type !== "quadratic" && x.type !== "soft" ? vt(
          _t,
          isNaN(x.curviness) ? 1 : x.curviness,
          !1,
          x.type === "thruBasic",
          x.correlate,
          it
        ) : Nt(_t, x.type, dt), this._segCount = this._beziers[E].length, this._timeRes) {
          var re = Ct(this._beziers, this._timeRes);
          this._length = re.length, this._lengths = re.lengths, this._segments = re.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length;
        }
        if (Yt = this._autoRotate)
          for (this._initialRotations = [], Yt[0] instanceof Array || (this._autoRotate = Yt = [Yt]), z = Yt.length; --z > -1; ) {
            for (X = 0; 3 > X; X++)
              E = Yt[z][X], this._func[E] = typeof _[E] == "function" ? _[E.indexOf("set") || typeof _["get" + E.substr(3)] != "function" ? E : "get" + E.substr(3)] : !1;
            E = Yt[z][2], this._initialRotations[z] = (this._func[E] ? this._func[E].call(this._target) : this._target[E]) || 0, this._overwriteProps.push(E);
          }
        return this._startRatio = B.vars.runBackwards ? 1 : 0, !0;
      },
      set: function(_) {
        var x, B, E, Z, z, X, it, _t, dt, zt, Yt = this._segCount, re = this._func, se = this._target, we = _ !== this._startRatio;
        if (this._timeRes) {
          if (dt = this._lengths, zt = this._curSeg, _ *= this._length, E = this._li, _ > this._l2 && Yt - 1 > E) {
            for (_t = Yt - 1; _t > E && (this._l2 = dt[++E]) <= _; )
              ;
            this._l1 = dt[E - 1], this._li = E, this._curSeg = zt = this._segments[E], this._s2 = zt[this._s1 = this._si = 0];
          } else if (_ < this._l1 && E > 0) {
            for (; E > 0 && (this._l1 = dt[--E]) >= _; )
              ;
            E === 0 && _ < this._l1 ? this._l1 = 0 : E++, this._l2 = dt[E], this._li = E, this._curSeg = zt = this._segments[E], this._s1 = zt[(this._si = zt.length - 1) - 1] || 0, this._s2 = zt[this._si];
          }
          if (x = E, _ -= this._l1, E = this._si, _ > this._s2 && E < zt.length - 1) {
            for (_t = zt.length - 1; _t > E && (this._s2 = zt[++E]) <= _; )
              ;
            this._s1 = zt[E - 1], this._si = E;
          } else if (_ < this._s1 && E > 0) {
            for (; E > 0 && (this._s1 = zt[--E]) >= _; )
              ;
            E === 0 && _ < this._s1 ? this._s1 = 0 : E++, this._s2 = zt[E], this._si = E;
          }
          X = (E + (_ - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
        } else
          x = 0 > _ ? 0 : _ >= 1 ? Yt - 1 : Yt * _ >> 0, X = (_ - x * (1 / Yt)) * Yt;
        for (B = 1 - X, E = this._props.length; --E > -1; )
          Z = this._props[E], z = this._beziers[Z][x], it = (X * X * z.da + 3 * B * (X * z.ca + B * z.ba)) * X + z.a, this._mod[Z] && (it = this._mod[Z](it, se)), re[Z] ? se[Z](it) : se[Z] = it;
        if (this._autoRotate) {
          var Et, ie, ze, nn, Ft, $e, Oi, En = this._autoRotate;
          for (E = En.length; --E > -1; )
            Z = En[E][2], $e = En[E][3] || 0, Oi = En[E][4] === !0 ? 1 : g, z = this._beziers[En[E][0]], Et = this._beziers[En[E][1]], z && Et && (z = z[x], Et = Et[x], ie = z.a + (z.b - z.a) * X, nn = z.b + (z.c - z.b) * X, ie += (nn - ie) * X, nn += (z.c + (z.d - z.c) * X - nn) * X, ze = Et.a + (Et.b - Et.a) * X, Ft = Et.b + (Et.c - Et.b) * X, ze += (Ft - ze) * X, Ft += (Et.c + (Et.d - Et.c) * X - Ft) * X, it = we ? Math.atan2(Ft - ze, nn - ie) * Oi + $e : this._initialRotations[E], this._mod[Z] && (it = this._mod[Z](it, se)), re[Z] ? se[Z](it) : se[Z] = it);
        }
      }
    }), Y = at.prototype;
    at.bezierThrough = vt, at.cubicToQuadratic = nt, at._autoCSS = !0, at.quadraticToCubic = function(_, x, B) {
      return new Mt(_, (2 * x + _) / 3, (2 * x + B) / 3, B);
    }, at._cssRegister = function() {
      var _ = S.CSSPlugin;
      if (_) {
        var x = _._internals, B = x._parseToProxy, E = x._setPluginRatio, Z = x.CSSPropTween;
        x._registerComplexSpecialProp("bezier", {
          parser: function(z, X, it, _t, dt, zt) {
            X instanceof Array && (X = { values: X }), zt = new at();
            var Yt, re, se, we = X.values, Et = we.length - 1, ie = [], ze = {};
            if (0 > Et)
              return dt;
            for (Yt = 0; Et >= Yt; Yt++)
              se = B(z, we[Yt], _t, dt, zt, Et !== Yt), ie[Yt] = se.end;
            for (re in X)
              ze[re] = X[re];
            return ze.values = ie, dt = new Z(z, "bezier", 0, 0, se.pt, 2), dt.data = se, dt.plugin = zt, dt.setRatio = E, ze.autoRotate === 0 && (ze.autoRotate = !0), !ze.autoRotate || ze.autoRotate instanceof Array || (Yt = ze.autoRotate === !0 ? 0 : Number(ze.autoRotate), ze.autoRotate = se.end.left != null ? [["left", "top", "rotation", Yt, !1]] : se.end.x != null ? [["x", "y", "rotation", Yt, !1]] : !1), ze.autoRotate && (_t._transform || _t._enableTransforms(!1), se.autoRotate = _t._target._gsTransform, se.proxy.rotation = se.autoRotate.rotation || 0, _t._overwriteProps.push("rotation")), zt._onInitTween(se.proxy, ze, _t._tween), dt;
          }
        });
      }
    }, Y._mod = function(_) {
      for (var x, B = this._overwriteProps, E = B.length; --E > -1; )
        x = _[B[E]], x && typeof x == "function" && (this._mod[B[E]] = x);
    }, Y._kill = function(_) {
      var x, B, E = this._props;
      for (x in this._beziers)
        if (x in _)
          for (delete this._beziers[x], delete this._func[x], B = E.length; --B > -1; )
            E[B] === x && E.splice(B, 1);
      if (E = this._autoRotate)
        for (B = E.length; --B > -1; )
          _[E[B][2]] && E.splice(B, 1);
      return this._super._kill.call(this, _);
    };
  }(), qi._gsDefine(
    "plugins.CSSPlugin",
    ["plugins.TweenPlugin", "TweenLite"],
    function(g, $) {
      var y, pt, gt, S, Mt = function() {
        g.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = Mt.prototype.setRatio;
      }, kt = qi._gsDefine.globals, nt = {}, Tt = Mt.prototype = new g("css");
      Tt.constructor = Mt, Mt.version = "2.0.2", Mt.API = 2, Mt.defaultTransformPerspective = 0, Mt.defaultSkewType = "compensated", Mt.defaultSmoothOrigin = !0, Tt = "px", Mt.suffixMap = {
        top: Tt,
        right: Tt,
        bottom: Tt,
        left: Tt,
        width: Tt,
        height: Tt,
        fontSize: Tt,
        padding: Tt,
        margin: Tt,
        perspective: Tt,
        lineHeight: ""
      };
      var Rt, vt, Nt, Ut, Ct, at, Y, _, x = /(?:\-|\.|\b)(\d|\.|e\-)+/g, B = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, E = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, Z = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, z = /(?:\d|\-|\+|=|#|\.)*/g, X = /opacity *= *([^)]*)/i, it = /opacity:([^;]*)/i, _t = /alpha\(opacity *=.+?\)/i, dt = /^(rgb|hsl)/, zt = /([A-Z])/g, Yt = /-([a-z])/gi, re = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, se = function(M, b) {
        return b.toUpperCase();
      }, we = /(?:Left|Right|Width)/i, Et = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, ie = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, ze = /,(?=[^\)]*(?:\(|$))/gi, nn = /[\s,\(]/i, Ft = Math.PI / 180, $e = 180 / Math.PI, Oi = {}, En = { style: {} }, Yi = qi.document || {
        createElement: function() {
          return En;
        }
      }, Oe = function(M, b) {
        return Yi.createElementNS ? Yi.createElementNS(b || "http://www.w3.org/1999/xhtml", M) : Yi.createElement(M);
      }, Ai = Oe("div"), bn = Oe("img"), ii = Mt._internals = { _specialProps: nt }, ui = (qi.navigator || {}).userAgent || "", Ui = function() {
        var M = ui.indexOf("Android"), b = Oe("a");
        return Nt = ui.indexOf("Safari") !== -1 && ui.indexOf("Chrome") === -1 && (M === -1 || parseFloat(ui.substr(M + 8, 2)) > 3), Ct = Nt && parseFloat(ui.substr(ui.indexOf("Version/") + 8, 2)) < 6, Ut = ui.indexOf("Firefox") !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(ui) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(ui)) && (at = parseFloat(RegExp.$1)), b ? (b.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(b.style.opacity)) : !1;
      }(), vr = function(M) {
        return X.test(
          typeof M == "string" ? M : (M.currentStyle ? M.currentStyle.filter : M.style.filter) || ""
        ) ? parseFloat(RegExp.$1) / 100 : 1;
      }, Pr = function(M) {
        qi.console && console.log(M);
      }, Zn = "", Fi = "", Un = function(M, b) {
        b = b || Ai;
        var U, N, T = b.style;
        if (T[M] !== void 0)
          return M;
        for (M = M.charAt(0).toUpperCase() + M.substr(1), U = ["O", "Moz", "ms", "Ms", "Webkit"], N = 5; --N > -1 && T[U[N] + M] === void 0; )
          ;
        return N >= 0 ? (Fi = N === 3 ? "ms" : U[N], Zn = "-" + Fi.toLowerCase() + "-", Fi + M) : null;
      }, rn = (typeof window < "u" ? window : Yi.defaultView || { getComputedStyle: function() {
      } }).getComputedStyle, Ze = Mt.getStyle = function(M, b, U, N, T) {
        var rt;
        return Ui || b !== "opacity" ? (!N && M.style[b] ? rt = M.style[b] : (U = U || rn(M)) ? rt = U[b] || U.getPropertyValue(b) || U.getPropertyValue(b.replace(zt, "-$1").toLowerCase()) : M.currentStyle && (rt = M.currentStyle[b]), T == null || rt && rt !== "none" && rt !== "auto" && rt !== "auto auto" ? rt : T) : vr(M);
      }, _n = ii.convertToPixels = function(M, b, U, N, T) {
        if (N === "px" || !N && b !== "lineHeight")
          return U;
        if (N === "auto" || !U)
          return 0;
        var rt, F, ut, xt = we.test(b), ft = M, et = Ai.style, Xt = 0 > U, Vt = U === 1;
        if (Xt && (U = -U), Vt && (U *= 100), b !== "lineHeight" || N)
          if (N === "%" && b.indexOf("border") !== -1)
            rt = U / 100 * (xt ? M.clientWidth : M.clientHeight);
          else {
            if (et.cssText = "border:0 solid red;position:" + Ze(M, "position") + ";line-height:0;", N !== "%" && ft.appendChild && N.charAt(0) !== "v" && N !== "rem")
              et[xt ? "borderLeftWidth" : "borderTopWidth"] = U + N;
            else {
              if (ft = M.parentNode || Yi.body, Ze(ft, "display").indexOf("flex") !== -1 && (et.position = "absolute"), F = ft._gsCache, ut = $.ticker.frame, F && xt && F.time === ut)
                return F.width * U / 100;
              et[xt ? "width" : "height"] = U + N;
            }
            ft.appendChild(Ai), rt = parseFloat(Ai[xt ? "offsetWidth" : "offsetHeight"]), ft.removeChild(Ai), xt && N === "%" && Mt.cacheWidths !== !1 && (F = ft._gsCache = ft._gsCache || {}, F.time = ut, F.width = rt / U * 100), rt !== 0 || T || (rt = _n(M, b, U, N, !0));
          }
        else
          F = rn(M).lineHeight, M.style.lineHeight = U, rt = parseFloat(rn(M).lineHeight), M.style.lineHeight = F;
        return Vt && (rt /= 100), Xt ? -rt : rt;
      }, lo = ii.calculateOffset = function(M, b, U) {
        if (Ze(M, "position", U) !== "absolute")
          return 0;
        var N = b === "left" ? "Left" : "Top", T = Ze(M, "margin" + N, U);
        return M["offset" + N] - (_n(M, b, parseFloat(T), T.replace(z, "")) || 0);
      }, Fn = function(M, b) {
        var U, N, T, rt = {};
        if (b = b || rn(M, null))
          if (U = b.length)
            for (; --U > -1; )
              T = b[U], (T.indexOf("-transform") === -1 || ss === T) && (rt[T.replace(Yt, se)] = b.getPropertyValue(T));
          else
            for (U in b)
              (U.indexOf("Transform") === -1 || on === U) && (rt[U] = b[U]);
        else if (b = M.currentStyle || M.style)
          for (U in b)
            typeof U == "string" && rt[U] === void 0 && (rt[U.replace(Yt, se)] = b[U]);
        return Ui || (rt.opacity = vr(M)), N = br(M, b, !1), rt.rotation = N.rotation, rt.skewX = N.skewX, rt.scaleX = N.scaleX, rt.scaleY = N.scaleY, rt.x = N.x, rt.y = N.y, Jn && (rt.z = N.z, rt.rotationX = N.rotationX, rt.rotationY = N.rotationY, rt.scaleZ = N.scaleZ), rt.filters && delete rt.filters, rt;
      }, Ni = function(M, b, U, N, T) {
        var rt, F, ut, xt = {}, ft = M.style;
        for (F in U)
          F !== "cssText" && F !== "length" && isNaN(F) && (b[F] !== (rt = U[F]) || T && T[F]) && F.indexOf("Origin") === -1 && (typeof rt == "number" || typeof rt == "string") && (xt[F] = rt !== "auto" || F !== "left" && F !== "top" ? rt !== "" && rt !== "auto" && rt !== "none" || typeof b[F] != "string" || b[F].replace(Z, "") === "" ? rt : 0 : lo(M, F), ft[F] !== void 0 && (ut = new Ke(ft, F, ft[F], ut)));
        if (N)
          for (F in N)
            F !== "className" && (xt[F] = N[F]);
        return { difs: xt, firstMPT: ut };
      }, A = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, k = ["marginLeft", "marginRight", "marginTop", "marginBottom"], j = function(M, b, U) {
        if ((M.nodeName + "").toLowerCase() === "svg")
          return (U || rn(M))[b] || 0;
        if (M.getCTM && ks(M))
          return M.getBBox()[b] || 0;
        var N = parseFloat(b === "width" ? M.offsetWidth : M.offsetHeight), T = A[b], rt = T.length;
        for (U = U || rn(M, null); --rt > -1; )
          N -= parseFloat(Ze(M, "padding" + T[rt], U, !0)) || 0, N -= parseFloat(Ze(M, "border" + T[rt] + "Width", U, !0)) || 0;
        return N;
      }, q = function(M, b) {
        if (M === "contain" || M === "auto" || M === "auto auto")
          return M + " ";
        (M == null || M === "") && (M = "0 0");
        var U, N = M.split(" "), T = M.indexOf("left") !== -1 ? "0%" : M.indexOf("right") !== -1 ? "100%" : N[0], rt = M.indexOf("top") !== -1 ? "0%" : M.indexOf("bottom") !== -1 ? "100%" : N[1];
        if (N.length > 3 && !b) {
          for (N = M.split(", ").join(",").split(","), M = [], U = 0; U < N.length; U++)
            M.push(q(N[U]));
          return M.join(",");
        }
        return rt == null ? rt = T === "center" ? "50%" : "0" : rt === "center" && (rt = "50%"), (T === "center" || isNaN(parseFloat(T)) && (T + "").indexOf("=") === -1) && (T = "50%"), M = T + " " + rt + (N.length > 2 ? " " + N[2] : ""), b && (b.oxp = T.indexOf("%") !== -1, b.oyp = rt.indexOf("%") !== -1, b.oxr = T.charAt(1) === "=", b.oyr = rt.charAt(1) === "=", b.ox = parseFloat(T.replace(Z, "")), b.oy = parseFloat(rt.replace(Z, "")), b.v = M), b || M;
      }, ht = function(M, b) {
        return typeof M == "function" && (M = M(_, Y)), typeof M == "string" && M.charAt(1) === "=" ? parseInt(M.charAt(0) + "1", 10) * parseFloat(M.substr(2)) : parseFloat(M) - parseFloat(b) || 0;
      }, Lt = function(M, b) {
        typeof M == "function" && (M = M(_, Y));
        var U = typeof M == "string" && M.charAt(1) === "=";
        return typeof M == "string" && M.charAt(M.length - 2) === "v" && (M = (U ? M.substr(0, 2) : 0) + window["inner" + (M.substr(-2) === "vh" ? "Height" : "Width")] * (parseFloat(U ? M.substr(2) : M) / 100)), M == null ? b : U ? parseInt(M.charAt(0) + "1", 10) * parseFloat(M.substr(2)) + b : parseFloat(M) || 0;
      }, Gt = function(M, b, U, N) {
        var T, rt, F, ut, xt, ft = 1e-6;
        return typeof M == "function" && (M = M(_, Y)), M == null ? ut = b : typeof M == "number" ? ut = M : (T = 360, rt = M.split("_"), xt = M.charAt(1) === "=", F = (xt ? parseInt(M.charAt(0) + "1", 10) * parseFloat(rt[0].substr(2)) : parseFloat(rt[0])) * (M.indexOf("rad") === -1 ? 1 : $e) - (xt ? 0 : b), rt.length && (N && (N[U] = b + F), M.indexOf("short") !== -1 && (F %= T, F !== F % (T / 2) && (F = 0 > F ? F + T : F - T)), M.indexOf("_cw") !== -1 && 0 > F ? F = (F + 9999999999 * T) % T - (F / T | 0) * T : M.indexOf("ccw") !== -1 && F > 0 && (F = (F - 9999999999 * T) % T - (F / T | 0) * T)), ut = b + F), ft > ut && ut > -ft && (ut = 0), ut;
      }, Pt = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      }, Ae = function(M, b, U) {
        return M = 0 > M ? M + 1 : M > 1 ? M - 1 : M, 255 * (1 > 6 * M ? b + (U - b) * M * 6 : 0.5 > M ? U : 2 > 3 * M ? b + (U - b) * (2 / 3 - M) * 6 : b) + 0.5 | 0;
      }, Se = Mt.parseColor = function(M, b) {
        var U, N, T, rt, F, ut, xt, ft, et, Xt, Vt;
        if (M)
          if (typeof M == "number")
            U = [M >> 16, M >> 8 & 255, 255 & M];
          else {
            if (M.charAt(M.length - 1) === "," && (M = M.substr(0, M.length - 1)), Pt[M])
              U = Pt[M];
            else if (M.charAt(0) === "#")
              M.length === 4 && (N = M.charAt(1), T = M.charAt(2), rt = M.charAt(3), M = "#" + N + N + T + T + rt + rt), M = parseInt(M.substr(1), 16), U = [M >> 16, M >> 8 & 255, 255 & M];
            else if (M.substr(0, 3) === "hsl")
              if (U = Vt = M.match(x), b) {
                if (M.indexOf("=") !== -1)
                  return M.match(B);
              } else
                F = Number(U[0]) % 360 / 360, ut = Number(U[1]) / 100, xt = Number(U[2]) / 100, T = 0.5 >= xt ? xt * (ut + 1) : xt + ut - xt * ut, N = 2 * xt - T, U.length > 3 && (U[3] = Number(U[3])), U[0] = Ae(F + 1 / 3, N, T), U[1] = Ae(F, N, T), U[2] = Ae(F - 1 / 3, N, T);
            else
              U = M.match(x) || Pt.transparent;
            U[0] = Number(U[0]), U[1] = Number(U[1]), U[2] = Number(U[2]), U.length > 3 && (U[3] = Number(U[3]));
          }
        else
          U = Pt.black;
        return b && !Vt && (N = U[0] / 255, T = U[1] / 255, rt = U[2] / 255, ft = Math.max(N, T, rt), et = Math.min(N, T, rt), xt = (ft + et) / 2, ft === et ? F = ut = 0 : (Xt = ft - et, ut = xt > 0.5 ? Xt / (2 - ft - et) : Xt / (ft + et), F = ft === N ? (T - rt) / Xt + (rt > T ? 6 : 0) : ft === T ? (rt - N) / Xt + 2 : (N - T) / Xt + 4, F *= 60), U[0] = F + 0.5 | 0, U[1] = 100 * ut + 0.5 | 0, U[2] = 100 * xt + 0.5 | 0), U;
      }, te = function(M, b) {
        var U, N, T, rt = M.match(Pe) || [], F = 0, ut = "";
        if (!rt.length)
          return M;
        for (U = 0; U < rt.length; U++)
          N = rt[U], T = M.substr(F, M.indexOf(N, F) - F), F += T.length + N.length, N = Se(N, b), N.length === 3 && N.push(1), ut += T + (b ? "hsla(" + N[0] + "," + N[1] + "%," + N[2] + "%," + N[3] : "rgba(" + N.join(",")) + ")";
        return ut + M.substr(F);
      }, Pe = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
      for (Tt in Pt)
        Pe += "|" + Tt + "\\b";
      Pe = new RegExp(Pe + ")", "gi"), Mt.colorStringFilter = function(M) {
        var b, U = M[0] + " " + M[1];
        Pe.test(U) && (b = U.indexOf("hsl(") !== -1 || U.indexOf("hsla(") !== -1, M[0] = te(M[0], b), M[1] = te(M[1], b)), Pe.lastIndex = 0;
      }, $.defaultStringFilter || ($.defaultStringFilter = Mt.colorStringFilter);
      var ci = function(M, b, U, N) {
        if (M == null)
          return function(Vt) {
            return Vt;
          };
        var T, rt = b ? (M.match(Pe) || [""])[0] : "", F = M.split(rt).join("").match(E) || [], ut = M.substr(0, M.indexOf(F[0])), xt = M.charAt(M.length - 1) === ")" ? ")" : "", ft = M.indexOf(" ") !== -1 ? " " : ",", et = F.length, Xt = et > 0 ? F[0].replace(x, "") : "";
        return et ? T = b ? function(Vt) {
          var It, Kt, qt, Le;
          if (typeof Vt == "number")
            Vt += Xt;
          else if (N && ze.test(Vt)) {
            for (Le = Vt.replace(ze, "|").split("|"), qt = 0; qt < Le.length; qt++)
              Le[qt] = T(Le[qt]);
            return Le.join(",");
          }
          if (It = (Vt.match(Pe) || [rt])[0], Kt = Vt.split(It).join("").match(E) || [], qt = Kt.length, et > qt--)
            for (; ++qt < et; )
              Kt[qt] = U ? Kt[(qt - 1) / 2 | 0] : F[qt];
          return ut + Kt.join(ft) + ft + It + xt + (Vt.indexOf("inset") !== -1 ? " inset" : "");
        } : function(Vt) {
          var It, Kt, qt;
          if (typeof Vt == "number")
            Vt += Xt;
          else if (N && ze.test(Vt)) {
            for (Kt = Vt.replace(ze, "|").split("|"), qt = 0; qt < Kt.length; qt++)
              Kt[qt] = T(Kt[qt]);
            return Kt.join(",");
          }
          if (It = Vt.match(E) || [], qt = It.length, et > qt--)
            for (; ++qt < et; )
              It[qt] = U ? It[(qt - 1) / 2 | 0] : F[qt];
          return ut + It.join(ft) + xt;
        } : function(Vt) {
          return Vt;
        };
      }, wi = function(M) {
        return M = M.split(","), function(b, U, N, T, rt, F, ut) {
          var xt, ft = (U + "").split(" ");
          for (ut = {}, xt = 0; 4 > xt; xt++)
            ut[M[xt]] = ft[xt] = ft[xt] || ft[(xt - 1) / 2 >> 0];
          return T.parse(b, ut, rt, F);
        };
      }, Ke = (ii._setPluginRatio = function(M) {
        this.plugin.setRatio(M);
        for (var b, U, N, T, rt, F = this.data, ut = F.proxy, xt = F.firstMPT, ft = 1e-6; xt; )
          b = ut[xt.v], xt.r ? b = xt.r(b) : ft > b && b > -ft && (b = 0), xt.t[xt.p] = b, xt = xt._next;
        if (F.autoRotate && (F.autoRotate.rotation = F.mod ? F.mod.call(this._tween, ut.rotation, this.t, this._tween) : ut.rotation), M === 1 || M === 0)
          for (xt = F.firstMPT, rt = M === 1 ? "e" : "b"; xt; ) {
            if (U = xt.t, U.type) {
              if (U.type === 1) {
                for (T = U.xs0 + U.s + U.xs1, N = 1; N < U.l; N++)
                  T += U["xn" + N] + U["xs" + (N + 1)];
                U[rt] = T;
              }
            } else
              U[rt] = U.s + U.xs0;
            xt = xt._next;
          }
      }, function(M, b, U, N, T) {
        this.t = M, this.p = b, this.v = U, this.r = T, N && (N._prev = this, this._next = N);
      }), mi = (ii._parseToProxy = function(M, b, U, N, T, rt) {
        var F, ut, xt, ft, et, Xt = N, Vt = {}, It = {}, Kt = U._transform, qt = Oi;
        for (U._transform = null, Oi = b, N = et = U.parse(M, b, N, T), Oi = qt, rt && (U._transform = Kt, Xt && (Xt._prev = null, Xt._prev && (Xt._prev._next = null))); N && N !== Xt; ) {
          if (N.type <= 1 && (ut = N.p, It[ut] = N.s + N.c, Vt[ut] = N.s, rt || (ft = new Ke(N, "s", ut, ft, N.r), N.c = 0), N.type === 1))
            for (F = N.l; --F > 0; )
              xt = "xn" + F, ut = N.p + "_" + xt, It[ut] = N.data[xt], Vt[ut] = N[xt], rt || (ft = new Ke(N, xt, ut, ft, N.rxp[xt]));
          N = N._next;
        }
        return { proxy: Vt, end: It, firstMPT: ft, pt: et };
      }, ii.CSSPropTween = function(M, b, U, N, T, rt, F, ut, xt, ft, et) {
        this.t = M, this.p = b, this.s = U, this.c = N, this.n = F || b, M instanceof mi || S.push(this.n), this.r = ut && (typeof ut == "function" ? ut : Math.round), this.type = rt || 0, xt && (this.pr = xt, y = !0), this.b = ft === void 0 ? U : ft, this.e = et === void 0 ? U + N : et, T && (this._next = T, T._prev = this);
      }), Yr = function(M, b, U, N, T, rt) {
        var F = new mi(M, b, U, N - U, T, -1, rt);
        return F.b = U, F.e = F.xs0 = N, F;
      }, or = Mt.parseComplex = function(M, b, U, N, T, rt, F, ut, xt, ft) {
        U = U || rt || "", typeof N == "function" && (N = N(_, Y)), F = new mi(M, b, 0, 0, F, ft ? 2 : 1, null, !1, ut, U, N), N += "", T && Pe.test(N + U) && (N = [U, N], Mt.colorStringFilter(N), U = N[0], N = N[1]);
        var et, Xt, Vt, It, Kt, qt, Le, Me, qe, ye, ee, _e, Zt, Qe = U.split(", ").join(",").split(" "), fe = N.split(", ").join(",").split(" "), ne = Qe.length, de = Rt !== !1;
        for ((N.indexOf(",") !== -1 || U.indexOf(",") !== -1) && ((N + U).indexOf("rgb") !== -1 || (N + U).indexOf("hsl") !== -1 ? (Qe = Qe.join(" ").replace(ze, ", ").split(" "), fe = fe.join(" ").replace(ze, ", ").split(" ")) : (Qe = Qe.join(" ").split(",").join(", ").split(" "), fe = fe.join(" ").split(",").join(", ").split(" ")), ne = Qe.length), ne !== fe.length && (Qe = (rt || "").split(" "), ne = Qe.length), F.plugin = xt, F.setRatio = ft, Pe.lastIndex = 0, et = 0; ne > et; et++)
          if (It = Qe[et], Kt = fe[et] + "", Me = parseFloat(It), Me || Me === 0)
            F.appendXtra(
              "",
              Me,
              ht(Kt, Me),
              Kt.replace(B, ""),
              de && Kt.indexOf("px") !== -1 ? Math.round : !1,
              !0
            );
          else if (T && Pe.test(It))
            _e = Kt.indexOf(")") + 1, _e = ")" + (_e ? Kt.substr(_e) : ""), Zt = Kt.indexOf("hsl") !== -1 && Ui, ye = Kt, It = Se(It, Zt), Kt = Se(Kt, Zt), qe = It.length + Kt.length > 6, qe && !Ui && Kt[3] === 0 ? (F["xs" + F.l] += F.l ? " transparent" : "transparent", F.e = F.e.split(fe[et]).join("transparent")) : (Ui || (qe = !1), Zt ? F.appendXtra(
              ye.substr(0, ye.indexOf("hsl")) + (qe ? "hsla(" : "hsl("),
              It[0],
              ht(Kt[0], It[0]),
              ",",
              !1,
              !0
            ).appendXtra("", It[1], ht(Kt[1], It[1]), "%,", !1).appendXtra(
              "",
              It[2],
              ht(Kt[2], It[2]),
              qe ? "%," : "%" + _e,
              !1
            ) : F.appendXtra(
              ye.substr(0, ye.indexOf("rgb")) + (qe ? "rgba(" : "rgb("),
              It[0],
              Kt[0] - It[0],
              ",",
              Math.round,
              !0
            ).appendXtra("", It[1], Kt[1] - It[1], ",", Math.round).appendXtra(
              "",
              It[2],
              Kt[2] - It[2],
              qe ? "," : _e,
              Math.round
            ), qe && (It = It.length < 4 ? 1 : It[3], F.appendXtra(
              "",
              It,
              (Kt.length < 4 ? 1 : Kt[3]) - It,
              _e,
              !1
            ))), Pe.lastIndex = 0;
          else if (qt = It.match(x)) {
            if (Le = Kt.match(B), !Le || Le.length !== qt.length)
              return F;
            for (Vt = 0, Xt = 0; Xt < qt.length; Xt++)
              ee = qt[Xt], ye = It.indexOf(ee, Vt), F.appendXtra(
                It.substr(Vt, ye - Vt),
                Number(ee),
                ht(Le[Xt], ee),
                "",
                de && It.substr(ye + ee.length, 2) === "px" ? Math.round : !1,
                Xt === 0
              ), Vt = ye + ee.length;
            F["xs" + F.l] += It.substr(Vt);
          } else
            F["xs" + F.l] += F.l || F["xs" + F.l] ? " " + Kt : Kt;
        if (N.indexOf("=") !== -1 && F.data) {
          for (_e = F.xs0 + F.data.s, et = 1; et < F.l; et++)
            _e += F["xs" + et] + F.data["xn" + et];
          F.e = _e + F["xs" + et];
        }
        return F.l || (F.type = -1, F.xs0 = F.e), F.xfirst || F;
      }, Zi = 9;
      for (Tt = mi.prototype, Tt.l = Tt.pr = 0; --Zi > 0; )
        Tt["xn" + Zi] = 0, Tt["xs" + Zi] = "";
      Tt.xs0 = "", Tt._next = Tt._prev = Tt.xfirst = Tt.data = Tt.plugin = Tt.setRatio = Tt.rxp = null, Tt.appendXtra = function(M, b, U, N, T, rt) {
        var F = this, ut = F.l;
        return F["xs" + ut] += rt && (ut || F["xs" + ut]) ? " " + M : M || "", U || ut === 0 || F.plugin ? (F.l++, F.type = F.setRatio ? 2 : 1, F["xs" + F.l] = N || "", ut > 0 ? (F.data["xn" + ut] = b + U, F.rxp["xn" + ut] = T, F["xn" + ut] = b, F.plugin || (F.xfirst = new mi(
          F,
          "xn" + ut,
          b,
          U,
          F.xfirst || F,
          0,
          F.n,
          T,
          F.pr
        ), F.xfirst.xs0 = 0), F) : (F.data = { s: b + U }, F.rxp = {}, F.s = b, F.c = U, F.r = T, F)) : (F["xs" + ut] += b + (N || ""), F);
      };
      var os = function(M, b) {
        b = b || {}, this.p = b.prefix && Un(M) || M, nt[M] = nt[this.p] = this, this.format = b.formatter || ci(b.defaultValue, b.color, b.collapsible, b.multi), b.parser && (this.parse = b.parser), this.clrs = b.color, this.multi = b.multi, this.keyword = b.keyword, this.dflt = b.defaultValue, this.pr = b.priority || 0;
      }, Ii = ii._registerComplexSpecialProp = function(M, b, U) {
        typeof b != "object" && (b = { parser: U });
        var N, T = M.split(","), rt = b.defaultValue;
        for (U = U || [rt], N = 0; N < T.length; N++)
          b.prefix = N === 0 && b.prefix, b.defaultValue = U[N] || rt, new os(T[N], b);
      }, Za = ii._registerPluginProp = function(M) {
        if (!nt[M]) {
          var b = M.charAt(0).toUpperCase() + M.substr(1) + "Plugin";
          Ii(M, {
            parser: function(U, N, T, rt, F, ut, xt) {
              var ft = kt.com.greensock.plugins[b];
              return ft ? (ft._cssRegister(), nt[T].parse(U, N, T, rt, F, ut, xt)) : (Pr("Error: " + b + " js file not loaded."), F);
            }
          });
        }
      };
      Tt = os.prototype, Tt.parseComplex = function(M, b, U, N, T, rt) {
        var F, ut, xt, ft, et, Xt, Vt = this.keyword;
        if (this.multi && (ze.test(U) || ze.test(b) ? (ut = b.replace(ze, "|").split("|"), xt = U.replace(ze, "|").split("|")) : Vt && (ut = [b], xt = [U])), xt) {
          for (ft = xt.length > ut.length ? xt.length : ut.length, F = 0; ft > F; F++)
            b = ut[F] = ut[F] || this.dflt, U = xt[F] = xt[F] || this.dflt, Vt && (et = b.indexOf(Vt), Xt = U.indexOf(Vt), et !== Xt && (Xt === -1 ? ut[F] = ut[F].split(Vt).join("") : et === -1 && (ut[F] += " " + Vt)));
          b = ut.join(", "), U = xt.join(", ");
        }
        return or(M, this.p, b, U, this.clrs, this.dflt, N, this.pr, T, rt);
      }, Tt.parse = function(M, b, U, N, T, rt, F) {
        return this.parseComplex(
          M.style,
          this.format(Ze(M, this.p, gt, !1, this.dflt)),
          this.format(b),
          T,
          rt
        );
      }, Mt.registerSpecialProp = function(M, b, U) {
        Ii(M, {
          parser: function(N, T, rt, F, ut, xt, ft) {
            var et = new mi(N, rt, 0, 0, ut, 2, rt, !1, U);
            return et.plugin = xt, et.setRatio = b(N, T, F._tween, rt), et;
          },
          priority: U
        });
      }, Mt.useSVGTransformAttr = !0;
      var Lr, wa = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(
        ","
      ), on = Un("transform"), ss = Zn + "transform", Po = Un("transformOrigin"), Jn = Un("perspective") !== null, as = ii.Transform = function() {
        this.perspective = parseFloat(Mt.defaultTransformPerspective) || 0, this.force3D = Mt.defaultForce3D !== !1 && Jn ? Mt.defaultForce3D || "auto" : !1;
      }, Gs = qi.SVGElement, Ma = function(M, b, U) {
        var N, T = Yi.createElementNS("http://www.w3.org/2000/svg", M), rt = /([a-z])([A-Z])/g;
        for (N in U)
          T.setAttributeNS(null, N.replace(rt, "$1-$2").toLowerCase(), U[N]);
        return b.appendChild(T), T;
      }, Cr = Yi.documentElement || {}, Ja = function() {
        var M, b, U, N = at || /Android/i.test(ui) && !qi.chrome;
        return Yi.createElementNS && !N && (M = Ma("svg", Cr), b = Ma("rect", M, { width: 100, height: 50, x: 100 }), U = b.getBoundingClientRect().width, b.style[Po] = "50% 50%", b.style[on] = "scaleX(0.5)", N = U === b.getBoundingClientRect().width && !(Ut && Jn), Cr.removeChild(M)), N;
      }(), ls = function(M, b, U, N, T, rt) {
        var F, ut, xt, ft, et, Xt, Vt, It, Kt, qt, Le, Me, qe, ye, ee = M._gsTransform, _e = us(M, !0);
        ee && (qe = ee.xOrigin, ye = ee.yOrigin), (!N || (F = N.split(" ")).length < 2) && (Vt = M.getBBox(), Vt.x === 0 && Vt.y === 0 && Vt.width + Vt.height === 0 && (Vt = {
          x: parseFloat(
            M.hasAttribute("x") ? M.getAttribute("x") : M.hasAttribute("cx") ? M.getAttribute("cx") : 0
          ) || 0,
          y: parseFloat(
            M.hasAttribute("y") ? M.getAttribute("y") : M.hasAttribute("cy") ? M.getAttribute("cy") : 0
          ) || 0,
          width: 0,
          height: 0
        }), b = q(b).split(" "), F = [
          (b[0].indexOf("%") !== -1 ? parseFloat(b[0]) / 100 * Vt.width : parseFloat(b[0])) + Vt.x,
          (b[1].indexOf("%") !== -1 ? parseFloat(b[1]) / 100 * Vt.height : parseFloat(b[1])) + Vt.y
        ]), U.xOrigin = ft = parseFloat(F[0]), U.yOrigin = et = parseFloat(F[1]), N && _e !== hs && (Xt = _e[0], Vt = _e[1], It = _e[2], Kt = _e[3], qt = _e[4], Le = _e[5], Me = Xt * Kt - Vt * It, Me && (ut = ft * (Kt / Me) + et * (-It / Me) + (It * Le - Kt * qt) / Me, xt = ft * (-Vt / Me) + et * (Xt / Me) - (Xt * Le - Vt * qt) / Me, ft = U.xOrigin = F[0] = ut, et = U.yOrigin = F[1] = xt)), ee && (rt && (U.xOffset = ee.xOffset, U.yOffset = ee.yOffset, ee = U), T || T !== !1 && Mt.defaultSmoothOrigin !== !1 ? (ut = ft - qe, xt = et - ye, ee.xOffset += ut * _e[0] + xt * _e[2] - ut, ee.yOffset += ut * _e[1] + xt * _e[3] - xt) : ee.xOffset = ee.yOffset = 0), rt || M.setAttribute("data-svg-origin", F.join(" "));
      }, Hs = function(M) {
        var b, U = Oe(
          "svg",
          this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"
        ), N = this.parentNode, T = this.nextSibling, rt = this.style.cssText;
        if (Cr.appendChild(U), U.appendChild(this), this.style.display = "block", M)
          try {
            b = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Hs;
          } catch {
          }
        else
          this._originalGetBBox && (b = this._originalGetBBox());
        return T ? N.insertBefore(this, T) : N.appendChild(this), Cr.removeChild(U), this.style.cssText = rt, b;
      }, Rr = function(M) {
        try {
          return M.getBBox();
        } catch {
          return Hs.call(M, !0);
        }
      }, ks = function(M) {
        return !(!Gs || !M.getCTM || M.parentNode && !M.ownerSVGElement || !Rr(M));
      }, hs = [1, 0, 0, 1, 0, 0], us = function(M, b) {
        var U, N, T, rt, F, ut, xt = M._gsTransform || new as(), ft = 1e5, et = M.style;
        if (on ? N = Ze(M, ss, null, !0) : M.currentStyle && (N = M.currentStyle.filter.match(Et), N = N && N.length === 4 ? [
          N[0].substr(4),
          Number(N[2].substr(4)),
          Number(N[1].substr(4)),
          N[3].substr(4),
          xt.x || 0,
          xt.y || 0
        ].join(",") : ""), U = !N || N === "none" || N === "matrix(1, 0, 0, 1, 0, 0)", !on || !(ut = !rn(M) || rn(M).display === "none") && M.parentNode || (ut && (rt = et.display, et.display = "block"), M.parentNode || (F = 1, Cr.appendChild(M)), N = Ze(M, ss, null, !0), U = !N || N === "none" || N === "matrix(1, 0, 0, 1, 0, 0)", rt ? et.display = rt : ut && Lo(et, "display"), F && Cr.removeChild(M)), (xt.svg || M.getCTM && ks(M)) && (U && (et[on] + "").indexOf("matrix") !== -1 && (N = et[on], U = 0), T = M.getAttribute("transform"), U && T && (T = M.transform.baseVal.consolidate().matrix, N = "matrix(" + T.a + "," + T.b + "," + T.c + "," + T.d + "," + T.e + "," + T.f + ")", U = 0)), U)
          return hs;
        for (T = (N || "").match(x) || [], Zi = T.length; --Zi > -1; )
          rt = Number(T[Zi]), T[Zi] = (F = rt - (rt |= 0)) ? (F * ft + (0 > F ? -0.5 : 0.5) | 0) / ft + rt : rt;
        return b && T.length > 6 ? [T[0], T[1], T[4], T[5], T[12], T[13]] : T;
      }, br = ii.getTransform = function(M, b, U, N) {
        if (M._gsTransform && U && !N)
          return M._gsTransform;
        var T, rt, F, ut, xt, ft, et = U ? M._gsTransform || new as() : new as(), Xt = et.scaleX < 0, Vt = 2e-5, It = 1e5, Kt = Jn && (parseFloat(Ze(M, Po, b, !1, "0 0 0").split(" ")[2]) || et.zOrigin) || 0, qt = parseFloat(Mt.defaultTransformPerspective) || 0;
        if (et.svg = !(!M.getCTM || !ks(M)), et.svg && (ls(
          M,
          Ze(M, Po, b, !1, "50% 50%") + "",
          et,
          M.getAttribute("data-svg-origin")
        ), Lr = Mt.useSVGTransformAttr || Ja), T = us(M), T !== hs) {
          if (T.length === 16) {
            var Le, Me, qe, ye, ee, _e = T[0], Zt = T[1], Qe = T[2], fe = T[3], ne = T[4], de = T[5], sn = T[6], An = T[7], gi = T[8], vi = T[9], Ti = T[10], Gi = T[12], Hi = T[13], Wi = T[14], ji = T[11], Mi = Math.atan2(sn, Ti);
            et.zOrigin && (Wi = -et.zOrigin, Gi = gi * Wi - T[12], Hi = vi * Wi - T[13], Wi = Ti * Wi + et.zOrigin - T[14]), et.rotationX = Mi * $e, Mi && (ye = Math.cos(-Mi), ee = Math.sin(-Mi), Le = ne * ye + gi * ee, Me = de * ye + vi * ee, qe = sn * ye + Ti * ee, gi = ne * -ee + gi * ye, vi = de * -ee + vi * ye, Ti = sn * -ee + Ti * ye, ji = An * -ee + ji * ye, ne = Le, de = Me, sn = qe), Mi = Math.atan2(-Qe, Ti), et.rotationY = Mi * $e, Mi && (ye = Math.cos(-Mi), ee = Math.sin(-Mi), Le = _e * ye - gi * ee, Me = Zt * ye - vi * ee, qe = Qe * ye - Ti * ee, vi = Zt * ee + vi * ye, Ti = Qe * ee + Ti * ye, ji = fe * ee + ji * ye, _e = Le, Zt = Me, Qe = qe), Mi = Math.atan2(Zt, _e), et.rotation = Mi * $e, Mi && (ye = Math.cos(Mi), ee = Math.sin(Mi), Le = _e * ye + Zt * ee, Me = ne * ye + de * ee, qe = gi * ye + vi * ee, Zt = Zt * ye - _e * ee, de = de * ye - ne * ee, vi = vi * ye - gi * ee, _e = Le, ne = Me, gi = qe), et.rotationX && Math.abs(et.rotationX) + Math.abs(et.rotation) > 359.9 && (et.rotationX = et.rotation = 0, et.rotationY = 180 - et.rotationY), Mi = Math.atan2(ne, de), et.scaleX = (Math.sqrt(_e * _e + Zt * Zt + Qe * Qe) * It + 0.5 | 0) / It, et.scaleY = (Math.sqrt(de * de + sn * sn) * It + 0.5 | 0) / It, et.scaleZ = (Math.sqrt(gi * gi + vi * vi + Ti * Ti) * It + 0.5 | 0) / It, _e /= et.scaleX, ne /= et.scaleY, Zt /= et.scaleX, de /= et.scaleY, Math.abs(Mi) > Vt ? (et.skewX = Mi * $e, ne = 0, et.skewType !== "simple" && (et.scaleY *= 1 / Math.cos(Mi))) : et.skewX = 0, et.perspective = ji ? 1 / (0 > ji ? -ji : ji) : 0, et.x = Gi, et.y = Hi, et.z = Wi, et.svg && (et.x -= et.xOrigin - (et.xOrigin * _e - et.yOrigin * ne), et.y -= et.yOrigin - (et.yOrigin * Zt - et.xOrigin * de));
          } else if (!Jn || N || !T.length || et.x !== T[4] || et.y !== T[5] || !et.rotationX && !et.rotationY) {
            var yi = T.length >= 6, Pi = yi ? T[0] : 1, ti = T[1] || 0, Or = T[2] || 0, xn = yi ? T[3] : 1;
            et.x = T[4] || 0, et.y = T[5] || 0, F = Math.sqrt(Pi * Pi + ti * ti), ut = Math.sqrt(xn * xn + Or * Or), xt = Pi || ti ? Math.atan2(ti, Pi) * $e : et.rotation || 0, ft = Or || xn ? Math.atan2(Or, xn) * $e + xt : et.skewX || 0, et.scaleX = F, et.scaleY = ut, et.rotation = xt, et.skewX = ft, Jn && (et.rotationX = et.rotationY = et.z = 0, et.perspective = qt, et.scaleZ = 1), et.svg && (et.x -= et.xOrigin - (et.xOrigin * Pi + et.yOrigin * Or), et.y -= et.yOrigin - (et.xOrigin * ti + et.yOrigin * xn));
          }
          Math.abs(et.skewX) > 90 && Math.abs(et.skewX) < 270 && (Xt ? (et.scaleX *= -1, et.skewX += et.rotation <= 0 ? 180 : -180, et.rotation += et.rotation <= 0 ? 180 : -180) : (et.scaleY *= -1, et.skewX += et.skewX <= 0 ? 180 : -180)), et.zOrigin = Kt;
          for (rt in et)
            et[rt] < Vt && et[rt] > -Vt && (et[rt] = 0);
        }
        return U && (M._gsTransform = et, et.svg && (Lr && M.style[on] ? $.delayedCall(1e-3, function() {
          Lo(M.style, on);
        }) : !Lr && M.getAttribute("transform") && $.delayedCall(1e-3, function() {
          M.removeAttribute("transform");
        }))), et;
      }, Ta = function(M) {
        var b, U, N = this.data, T = -N.rotation * Ft, rt = T + N.skewX * Ft, F = 1e5, ut = (Math.cos(T) * N.scaleX * F | 0) / F, xt = (Math.sin(T) * N.scaleX * F | 0) / F, ft = (Math.sin(rt) * -N.scaleY * F | 0) / F, et = (Math.cos(rt) * N.scaleY * F | 0) / F, Xt = this.t.style, Vt = this.t.currentStyle;
        if (Vt) {
          U = xt, xt = -ft, ft = -U, b = Vt.filter, Xt.filter = "";
          var It, Kt, qt = this.t.offsetWidth, Le = this.t.offsetHeight, Me = Vt.position !== "absolute", qe = "progid:DXImageTransform.Microsoft.Matrix(M11=" + ut + ", M12=" + xt + ", M21=" + ft + ", M22=" + et, ye = N.x + qt * N.xPercent / 100, ee = N.y + Le * N.yPercent / 100;
          if (N.ox != null && (It = (N.oxp ? qt * N.ox * 0.01 : N.ox) - qt / 2, Kt = (N.oyp ? Le * N.oy * 0.01 : N.oy) - Le / 2, ye += It - (It * ut + Kt * xt), ee += Kt - (It * ft + Kt * et)), Me ? (It = qt / 2, Kt = Le / 2, qe += ", Dx=" + (It - (It * ut + Kt * xt) + ye) + ", Dy=" + (Kt - (It * ft + Kt * et) + ee) + ")") : qe += ", sizingMethod='auto expand')", b.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? Xt.filter = b.replace(ie, qe) : Xt.filter = qe + " " + b, (M === 0 || M === 1) && ut === 1 && xt === 0 && ft === 0 && et === 1 && (Me && qe.indexOf("Dx=0, Dy=0") === -1 || X.test(b) && parseFloat(RegExp.$1) !== 100 || b.indexOf(b.indexOf("Alpha")) === -1 && Xt.removeAttribute("filter")), !Me) {
            var _e, Zt, Qe, fe = 8 > at ? 1 : -1;
            for (It = N.ieOffsetX || 0, Kt = N.ieOffsetY || 0, N.ieOffsetX = Math.round(
              (qt - ((0 > ut ? -ut : ut) * qt + (0 > xt ? -xt : xt) * Le)) / 2 + ye
            ), N.ieOffsetY = Math.round(
              (Le - ((0 > et ? -et : et) * Le + (0 > ft ? -ft : ft) * qt)) / 2 + ee
            ), Zi = 0; 4 > Zi; Zi++)
              Zt = k[Zi], _e = Vt[Zt], U = _e.indexOf("px") !== -1 ? parseFloat(_e) : _n(this.t, Zt, parseFloat(_e), _e.replace(z, "")) || 0, Qe = U !== N[Zt] ? 2 > Zi ? -N.ieOffsetX : -N.ieOffsetY : 2 > Zi ? It - N.ieOffsetX : Kt - N.ieOffsetY, Xt[Zt] = (N[Zt] = Math.round(
                U - Qe * (Zi === 0 || Zi === 2 ? 1 : fe)
              )) + "px";
          }
        }
      }, $a = ii.set3DTransformRatio = ii.setTransformRatio = function(M) {
        var b, U, N, T, rt, F, ut, xt, ft, et, Xt, Vt, It, Kt, qt, Le, Me, qe, ye, ee, _e, Zt, Qe, fe = this.data, ne = this.t.style, de = fe.rotation, sn = fe.rotationX, An = fe.rotationY, gi = fe.scaleX, vi = fe.scaleY, Ti = fe.scaleZ, Gi = fe.x, Hi = fe.y, Wi = fe.z, ji = fe.svg, Mi = fe.perspective, yi = fe.force3D, Pi = fe.skewY, ti = fe.skewX;
        if (Pi && (ti += Pi, de += Pi), ((M === 1 || M === 0) && yi === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !yi) && !Wi && !Mi && !An && !sn && Ti === 1 || Lr && ji || !Jn)
          return void (de || ti || ji ? (de *= Ft, Zt = ti * Ft, Qe = 1e5, U = Math.cos(de) * gi, rt = Math.sin(de) * gi, N = Math.sin(de - Zt) * -vi, F = Math.cos(de - Zt) * vi, Zt && fe.skewType === "simple" && (b = Math.tan(Zt - Pi * Ft), b = Math.sqrt(1 + b * b), N *= b, F *= b, Pi && (b = Math.tan(Pi * Ft), b = Math.sqrt(1 + b * b), U *= b, rt *= b)), ji && (Gi += fe.xOrigin - (fe.xOrigin * U + fe.yOrigin * N) + fe.xOffset, Hi += fe.yOrigin - (fe.xOrigin * rt + fe.yOrigin * F) + fe.yOffset, Lr && (fe.xPercent || fe.yPercent) && (qt = this.t.getBBox(), Gi += 0.01 * fe.xPercent * qt.width, Hi += 0.01 * fe.yPercent * qt.height), qt = 1e-6, qt > Gi && Gi > -qt && (Gi = 0), qt > Hi && Hi > -qt && (Hi = 0)), ye = (U * Qe | 0) / Qe + "," + (rt * Qe | 0) / Qe + "," + (N * Qe | 0) / Qe + "," + (F * Qe | 0) / Qe + "," + Gi + "," + Hi + ")", ji && Lr ? this.t.setAttribute("transform", "matrix(" + ye) : ne[on] = (fe.xPercent || fe.yPercent ? "translate(" + fe.xPercent + "%," + fe.yPercent + "%) matrix(" : "matrix(") + ye) : ne[on] = (fe.xPercent || fe.yPercent ? "translate(" + fe.xPercent + "%," + fe.yPercent + "%) matrix(" : "matrix(") + gi + ",0,0," + vi + "," + Gi + "," + Hi + ")");
        if (Ut && (qt = 1e-4, qt > gi && gi > -qt && (gi = Ti = 2e-5), qt > vi && vi > -qt && (vi = Ti = 2e-5), !Mi || fe.z || fe.rotationX || fe.rotationY || (Mi = 0)), de || ti)
          de *= Ft, Le = U = Math.cos(de), Me = rt = Math.sin(de), ti && (de -= ti * Ft, Le = Math.cos(de), Me = Math.sin(de), fe.skewType === "simple" && (b = Math.tan((ti - Pi) * Ft), b = Math.sqrt(1 + b * b), Le *= b, Me *= b, fe.skewY && (b = Math.tan(Pi * Ft), b = Math.sqrt(1 + b * b), U *= b, rt *= b))), N = -Me, F = Le;
        else {
          if (!(An || sn || Ti !== 1 || Mi || ji))
            return void (ne[on] = (fe.xPercent || fe.yPercent ? "translate(" + fe.xPercent + "%," + fe.yPercent + "%) translate3d(" : "translate3d(") + Gi + "px," + Hi + "px," + Wi + "px)" + (gi !== 1 || vi !== 1 ? " scale(" + gi + "," + vi + ")" : ""));
          U = F = 1, N = rt = 0;
        }
        et = 1, T = ut = xt = ft = Xt = Vt = 0, It = Mi ? -1 / Mi : 0, Kt = fe.zOrigin, qt = 1e-6, ee = ",", _e = "0", de = An * Ft, de && (Le = Math.cos(de), Me = Math.sin(de), xt = -Me, Xt = It * -Me, T = U * Me, ut = rt * Me, et = Le, It *= Le, U *= Le, rt *= Le), de = sn * Ft, de && (Le = Math.cos(de), Me = Math.sin(de), b = N * Le + T * Me, qe = F * Le + ut * Me, ft = et * Me, Vt = It * Me, T = N * -Me + T * Le, ut = F * -Me + ut * Le, et *= Le, It *= Le, N = b, F = qe), Ti !== 1 && (T *= Ti, ut *= Ti, et *= Ti, It *= Ti), vi !== 1 && (N *= vi, F *= vi, ft *= vi, Vt *= vi), gi !== 1 && (U *= gi, rt *= gi, xt *= gi, Xt *= gi), (Kt || ji) && (Kt && (Gi += T * -Kt, Hi += ut * -Kt, Wi += et * -Kt + Kt), ji && (Gi += fe.xOrigin - (fe.xOrigin * U + fe.yOrigin * N) + fe.xOffset, Hi += fe.yOrigin - (fe.xOrigin * rt + fe.yOrigin * F) + fe.yOffset), qt > Gi && Gi > -qt && (Gi = _e), qt > Hi && Hi > -qt && (Hi = _e), qt > Wi && Wi > -qt && (Wi = 0)), ye = fe.xPercent || fe.yPercent ? "translate(" + fe.xPercent + "%," + fe.yPercent + "%) matrix3d(" : "matrix3d(", ye += (qt > U && U > -qt ? _e : U) + ee + (qt > rt && rt > -qt ? _e : rt) + ee + (qt > xt && xt > -qt ? _e : xt), ye += ee + (qt > Xt && Xt > -qt ? _e : Xt) + ee + (qt > N && N > -qt ? _e : N) + ee + (qt > F && F > -qt ? _e : F), sn || An || Ti !== 1 ? (ye += ee + (qt > ft && ft > -qt ? _e : ft) + ee + (qt > Vt && Vt > -qt ? _e : Vt) + ee + (qt > T && T > -qt ? _e : T), ye += ee + (qt > ut && ut > -qt ? _e : ut) + ee + (qt > et && et > -qt ? _e : et) + ee + (qt > It && It > -qt ? _e : It) + ee) : ye += ",0,0,0,0,1,0,", ye += Gi + ee + Hi + ee + Wi + ee + (Mi ? 1 + -Wi / Mi : 1) + ")", ne[on] = ye;
      };
      Tt = as.prototype, Tt.x = Tt.y = Tt.z = Tt.skewX = Tt.skewY = Tt.rotation = Tt.rotationX = Tt.rotationY = Tt.zOrigin = Tt.xPercent = Tt.yPercent = Tt.xOffset = Tt.yOffset = 0, Tt.scaleX = Tt.scaleY = Tt.scaleZ = 1, Ii(
        "transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",
        {
          parser: function(M, b, U, N, T, rt, F) {
            if (N._lastParsedTransform === F)
              return T;
            N._lastParsedTransform = F;
            var ut, xt = F.scale && typeof F.scale == "function" ? F.scale : 0;
            typeof F[U] == "function" && (ut = F[U], F[U] = b), xt && (F.scale = xt(_, M));
            var ft, et, Xt, Vt, It, Kt, qt, Le, Me, qe = M._gsTransform, ye = M.style, ee = 1e-6, _e = wa.length, Zt = F, Qe = {}, fe = "transformOrigin", ne = br(M, gt, !0, Zt.parseTransform), de = Zt.transform && (typeof Zt.transform == "function" ? Zt.transform(_, Y) : Zt.transform);
            if (ne.skewType = Zt.skewType || ne.skewType || Mt.defaultSkewType, N._transform = ne, "rotationZ" in Zt && (Zt.rotation = Zt.rotationZ), de && typeof de == "string" && on)
              et = Ai.style, et[on] = de, et.display = "block", et.position = "absolute", de.indexOf("%") !== -1 && (et.width = Ze(M, "width"), et.height = Ze(M, "height")), Yi.body.appendChild(Ai), ft = br(Ai, null, !1), ne.skewType === "simple" && (ft.scaleY *= Math.cos(ft.skewX * Ft)), ne.svg && (Kt = ne.xOrigin, qt = ne.yOrigin, ft.x -= ne.xOffset, ft.y -= ne.yOffset, (Zt.transformOrigin || Zt.svgOrigin) && (de = {}, ls(
                M,
                q(Zt.transformOrigin),
                de,
                Zt.svgOrigin,
                Zt.smoothOrigin,
                !0
              ), Kt = de.xOrigin, qt = de.yOrigin, ft.x -= de.xOffset - ne.xOffset, ft.y -= de.yOffset - ne.yOffset), (Kt || qt) && (Le = us(Ai, !0), ft.x -= Kt - (Kt * Le[0] + qt * Le[2]), ft.y -= qt - (Kt * Le[1] + qt * Le[3]))), Yi.body.removeChild(Ai), ft.perspective || (ft.perspective = ne.perspective), Zt.xPercent != null && (ft.xPercent = Lt(Zt.xPercent, ne.xPercent)), Zt.yPercent != null && (ft.yPercent = Lt(Zt.yPercent, ne.yPercent));
            else if (typeof Zt == "object") {
              if (ft = {
                scaleX: Lt(
                  Zt.scaleX != null ? Zt.scaleX : Zt.scale,
                  ne.scaleX
                ),
                scaleY: Lt(
                  Zt.scaleY != null ? Zt.scaleY : Zt.scale,
                  ne.scaleY
                ),
                scaleZ: Lt(Zt.scaleZ, ne.scaleZ),
                x: Lt(Zt.x, ne.x),
                y: Lt(Zt.y, ne.y),
                z: Lt(Zt.z, ne.z),
                xPercent: Lt(Zt.xPercent, ne.xPercent),
                yPercent: Lt(Zt.yPercent, ne.yPercent),
                perspective: Lt(Zt.transformPerspective, ne.perspective)
              }, It = Zt.directionalRotation, It != null)
                if (typeof It == "object")
                  for (et in It)
                    Zt[et] = It[et];
                else
                  Zt.rotation = It;
              typeof Zt.x == "string" && Zt.x.indexOf("%") !== -1 && (ft.x = 0, ft.xPercent = Lt(Zt.x, ne.xPercent)), typeof Zt.y == "string" && Zt.y.indexOf("%") !== -1 && (ft.y = 0, ft.yPercent = Lt(Zt.y, ne.yPercent)), ft.rotation = Gt(
                "rotation" in Zt ? Zt.rotation : "shortRotation" in Zt ? Zt.shortRotation + "_short" : ne.rotation,
                ne.rotation,
                "rotation",
                Qe
              ), Jn && (ft.rotationX = Gt(
                "rotationX" in Zt ? Zt.rotationX : "shortRotationX" in Zt ? Zt.shortRotationX + "_short" : ne.rotationX || 0,
                ne.rotationX,
                "rotationX",
                Qe
              ), ft.rotationY = Gt(
                "rotationY" in Zt ? Zt.rotationY : "shortRotationY" in Zt ? Zt.shortRotationY + "_short" : ne.rotationY || 0,
                ne.rotationY,
                "rotationY",
                Qe
              )), ft.skewX = Gt(Zt.skewX, ne.skewX), ft.skewY = Gt(Zt.skewY, ne.skewY);
            }
            for (Jn && Zt.force3D != null && (ne.force3D = Zt.force3D, Vt = !0), Xt = ne.force3D || ne.z || ne.rotationX || ne.rotationY || ft.z || ft.rotationX || ft.rotationY || ft.perspective, Xt || Zt.scale == null || (ft.scaleZ = 1); --_e > -1; )
              Me = wa[_e], de = ft[Me] - ne[Me], (de > ee || -ee > de || Zt[Me] != null || Oi[Me] != null) && (Vt = !0, T = new mi(ne, Me, ne[Me], de, T), Me in Qe && (T.e = Qe[Me]), T.xs0 = 0, T.plugin = rt, N._overwriteProps.push(T.n));
            return de = Zt.transformOrigin, ne.svg && (de || Zt.svgOrigin) && (Kt = ne.xOffset, qt = ne.yOffset, ls(M, q(de), ft, Zt.svgOrigin, Zt.smoothOrigin), T = Yr(
              ne,
              "xOrigin",
              (qe ? ne : ft).xOrigin,
              ft.xOrigin,
              T,
              fe
            ), T = Yr(
              ne,
              "yOrigin",
              (qe ? ne : ft).yOrigin,
              ft.yOrigin,
              T,
              fe
            ), (Kt !== ne.xOffset || qt !== ne.yOffset) && (T = Yr(
              ne,
              "xOffset",
              qe ? Kt : ne.xOffset,
              ne.xOffset,
              T,
              fe
            ), T = Yr(
              ne,
              "yOffset",
              qe ? qt : ne.yOffset,
              ne.yOffset,
              T,
              fe
            )), de = "0px 0px"), (de || Jn && Xt && ne.zOrigin) && (on ? (Vt = !0, Me = Po, de = (de || Ze(M, Me, gt, !1, "50% 50%")) + "", T = new mi(ye, Me, 0, 0, T, -1, fe), T.b = ye[Me], T.plugin = rt, Jn ? (et = ne.zOrigin, de = de.split(" "), ne.zOrigin = (de.length > 2 && (et === 0 || de[2] !== "0px") ? parseFloat(de[2]) : et) || 0, T.xs0 = T.e = de[0] + " " + (de[1] || "50%") + " 0px", T = new mi(ne, "zOrigin", 0, 0, T, -1, T.n), T.b = et, T.xs0 = T.e = ne.zOrigin) : T.xs0 = T.e = de) : q(de + "", ne)), Vt && (N._transformType = ne.svg && Lr || !Xt && this._transformType !== 3 ? 2 : 3), ut && (F[U] = ut), xt && (F.scale = xt), T;
          },
          prefix: !0
        }
      ), Ii("boxShadow", {
        defaultValue: "0px 0px 0px 0px #999",
        prefix: !0,
        color: !0,
        multi: !0,
        keyword: "inset"
      }), Ii("borderRadius", {
        defaultValue: "0px",
        parser: function(M, b, U, N, T, rt) {
          b = this.format(b);
          var F, ut, xt, ft, et, Xt, Vt, It, Kt, qt, Le, Me, qe, ye, ee, _e, Zt = [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomRightRadius",
            "borderBottomLeftRadius"
          ], Qe = M.style;
          for (Kt = parseFloat(M.offsetWidth), qt = parseFloat(M.offsetHeight), F = b.split(" "), ut = 0; ut < Zt.length; ut++)
            this.p.indexOf("border") && (Zt[ut] = Un(Zt[ut])), et = ft = Ze(M, Zt[ut], gt, !1, "0px"), et.indexOf(" ") !== -1 && (ft = et.split(" "), et = ft[0], ft = ft[1]), Xt = xt = F[ut], Vt = parseFloat(et), Me = et.substr((Vt + "").length), qe = Xt.charAt(1) === "=", qe ? (It = parseInt(Xt.charAt(0) + "1", 10), Xt = Xt.substr(2), It *= parseFloat(Xt), Le = Xt.substr((It + "").length - (0 > It ? 1 : 0)) || "") : (It = parseFloat(Xt), Le = Xt.substr((It + "").length)), Le === "" && (Le = pt[U] || Me), Le !== Me && (ye = _n(M, "borderLeft", Vt, Me), ee = _n(M, "borderTop", Vt, Me), Le === "%" ? (et = ye / Kt * 100 + "%", ft = ee / qt * 100 + "%") : Le === "em" ? (_e = _n(M, "borderLeft", 1, "em"), et = ye / _e + "em", ft = ee / _e + "em") : (et = ye + "px", ft = ee + "px"), qe && (Xt = parseFloat(et) + It + Le, xt = parseFloat(ft) + It + Le)), T = or(Qe, Zt[ut], et + " " + ft, Xt + " " + xt, !1, "0px", T);
          return T;
        },
        prefix: !0,
        formatter: ci("0px 0px 0px 0px", !1, !0)
      }), Ii(
        "borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius",
        {
          defaultValue: "0px",
          parser: function(M, b, U, N, T, rt) {
            return or(
              M.style,
              U,
              this.format(Ze(M, U, gt, !1, "0px 0px")),
              this.format(b),
              !1,
              "0px",
              T
            );
          },
          prefix: !0,
          formatter: ci("0px 0px", !1, !0)
        }
      ), Ii("backgroundPosition", {
        defaultValue: "0 0",
        parser: function(M, b, U, N, T, rt) {
          var F, ut, xt, ft, et, Xt, Vt = "background-position", It = gt || rn(M, null), Kt = this.format(
            (It ? at ? It.getPropertyValue(Vt + "-x") + " " + It.getPropertyValue(Vt + "-y") : It.getPropertyValue(Vt) : M.currentStyle.backgroundPositionX + " " + M.currentStyle.backgroundPositionY) || "0 0"
          ), qt = this.format(b);
          if (Kt.indexOf("%") !== -1 != (qt.indexOf("%") !== -1) && qt.split(",").length < 2 && (Xt = Ze(M, "backgroundImage").replace(re, ""), Xt && Xt !== "none")) {
            for (F = Kt.split(" "), ut = qt.split(" "), bn.setAttribute("src", Xt), xt = 2; --xt > -1; )
              Kt = F[xt], ft = Kt.indexOf("%") !== -1, ft !== (ut[xt].indexOf("%") !== -1) && (et = xt === 0 ? M.offsetWidth - bn.width : M.offsetHeight - bn.height, F[xt] = ft ? parseFloat(Kt) / 100 * et + "px" : parseFloat(Kt) / et * 100 + "%");
            Kt = F.join(" ");
          }
          return this.parseComplex(M.style, Kt, qt, T, rt);
        },
        formatter: q
      }), Ii("backgroundSize", {
        defaultValue: "0 0",
        formatter: function(M) {
          return M += "", M.substr(0, 2) === "co" ? M : q(M.indexOf(" ") === -1 ? M + " " + M : M);
        }
      }), Ii("perspective", { defaultValue: "0px", prefix: !0 }), Ii("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), Ii("transformStyle", { prefix: !0 }), Ii("backfaceVisibility", { prefix: !0 }), Ii("userSelect", { prefix: !0 }), Ii("margin", {
        parser: wi("marginTop,marginRight,marginBottom,marginLeft")
      }), Ii("padding", {
        parser: wi("paddingTop,paddingRight,paddingBottom,paddingLeft")
      }), Ii("clip", {
        defaultValue: "rect(0px,0px,0px,0px)",
        parser: function(M, b, U, N, T, rt) {
          var F, ut, xt;
          return 9 > at ? (ut = M.currentStyle, xt = 8 > at ? " " : ",", F = "rect(" + ut.clipTop + xt + ut.clipRight + xt + ut.clipBottom + xt + ut.clipLeft + ")", b = this.format(b).split(",").join(xt)) : (F = this.format(Ze(M, this.p, gt, !1, this.dflt)), b = this.format(b)), this.parseComplex(M.style, F, b, T, rt);
        }
      }), Ii("textShadow", {
        defaultValue: "0px 0px 0px #999",
        color: !0,
        multi: !0
      }), Ii("autoRound,strictUnits", {
        parser: function(M, b, U, N, T) {
          return T;
        }
      }), Ii("border", {
        defaultValue: "0px solid #000",
        parser: function(M, b, U, N, T, rt) {
          var F = Ze(M, "borderTopWidth", gt, !1, "0px"), ut = this.format(b).split(" "), xt = ut[0].replace(z, "");
          return xt !== "px" && (F = parseFloat(F) / _n(M, "borderTopWidth", 1, xt) + xt), this.parseComplex(
            M.style,
            this.format(
              F + " " + Ze(M, "borderTopStyle", gt, !1, "solid") + " " + Ze(M, "borderTopColor", gt, !1, "#000")
            ),
            ut.join(" "),
            T,
            rt
          );
        },
        color: !0,
        formatter: function(M) {
          var b = M.split(" ");
          return b[0] + " " + (b[1] || "solid") + " " + (M.match(Pe) || ["#000"])[0];
        }
      }), Ii("borderWidth", {
        parser: wi(
          "borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth"
        )
      }), Ii("float,cssFloat,styleFloat", {
        parser: function(M, b, U, N, T, rt) {
          var F = M.style, ut = "cssFloat" in F ? "cssFloat" : "styleFloat";
          return new mi(F, ut, 0, 0, T, -1, U, !1, 0, F[ut], b);
        }
      });
      var Qa = function(M) {
        var b, U = this.t, N = U.filter || Ze(this.data, "filter") || "", T = this.s + this.c * M | 0;
        T === 100 && (N.indexOf("atrix(") === -1 && N.indexOf("radient(") === -1 && N.indexOf("oader(") === -1 ? (U.removeAttribute("filter"), b = !Ze(this.data, "filter")) : (U.filter = N.replace(_t, ""), b = !0)), b || (this.xn1 && (U.filter = N = N || "alpha(opacity=" + T + ")"), N.indexOf("pacity") === -1 ? T === 0 && this.xn1 || (U.filter = N + " alpha(opacity=" + T + ")") : U.filter = N.replace(X, "opacity=" + T));
      };
      Ii("opacity,alpha,autoAlpha", {
        defaultValue: "1",
        parser: function(M, b, U, N, T, rt) {
          var F = parseFloat(Ze(M, "opacity", gt, !1, "1")), ut = M.style, xt = U === "autoAlpha";
          return typeof b == "string" && b.charAt(1) === "=" && (b = (b.charAt(0) === "-" ? -1 : 1) * parseFloat(b.substr(2)) + F), xt && F === 1 && Ze(M, "visibility", gt) === "hidden" && b !== 0 && (F = 0), Ui ? T = new mi(ut, "opacity", F, b - F, T) : (T = new mi(ut, "opacity", 100 * F, 100 * (b - F), T), T.xn1 = xt ? 1 : 0, ut.zoom = 1, T.type = 2, T.b = "alpha(opacity=" + T.s + ")", T.e = "alpha(opacity=" + (T.s + T.c) + ")", T.data = M, T.plugin = rt, T.setRatio = Qa), xt && (T = new mi(
            ut,
            "visibility",
            0,
            0,
            T,
            -1,
            null,
            !1,
            0,
            F !== 0 ? "inherit" : "hidden",
            b === 0 ? "hidden" : "inherit"
          ), T.xs0 = "inherit", N._overwriteProps.push(T.n), N._overwriteProps.push(U)), T;
        }
      });
      var Lo = function(M, b) {
        b && (M.removeProperty ? ((b.substr(0, 2) === "ms" || b.substr(0, 6) === "webkit") && (b = "-" + b), M.removeProperty(b.replace(zt, "-$1").toLowerCase())) : M.removeAttribute(b));
      }, Co = function(M) {
        if (this.t._gsClassPT = this, M === 1 || M === 0) {
          this.t.setAttribute("class", M === 0 ? this.b : this.e);
          for (var b = this.data, U = this.t.style; b; )
            b.v ? U[b.p] = b.v : Lo(U, b.p), b = b._next;
          M === 1 && this.t._gsClassPT === this && (this.t._gsClassPT = null);
        } else
          this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
      };
      Ii("className", {
        parser: function(M, b, U, N, T, rt, F) {
          var ut, xt, ft, et, Xt, Vt = M.getAttribute("class") || "", It = M.style.cssText;
          if (T = N._classNamePT = new mi(M, U, 0, 0, T, 2), T.setRatio = Co, T.pr = -11, y = !0, T.b = Vt, xt = Fn(M, gt), ft = M._gsClassPT) {
            for (et = {}, Xt = ft.data; Xt; )
              et[Xt.p] = 1, Xt = Xt._next;
            ft.setRatio(1);
          }
          return M._gsClassPT = T, T.e = b.charAt(1) !== "=" ? b : Vt.replace(
            new RegExp("(?:\\s|^)" + b.substr(2) + "(?![\\w-])"),
            ""
          ) + (b.charAt(0) === "+" ? " " + b.substr(2) : ""), M.setAttribute("class", T.e), ut = Ni(M, xt, Fn(M), F, et), M.setAttribute("class", Vt), T.data = ut.firstMPT, M.style.cssText = It, T = T.xfirst = N.parse(M, ut.difs, T, rt);
        }
      });
      var Sa = function(M) {
        if ((M === 1 || M === 0) && this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
          var b, U, N, T, rt, F = this.t.style, ut = nt.transform.parse;
          if (this.e === "all")
            F.cssText = "", T = !0;
          else
            for (b = this.e.split(" ").join("").split(","), N = b.length; --N > -1; )
              U = b[N], nt[U] && (nt[U].parse === ut ? T = !0 : U = U === "transformOrigin" ? Po : nt[U].p), Lo(F, U);
          T && (Lo(F, on), rt = this.t._gsTransform, rt && (rt.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform));
        }
      };
      for (Ii("clearProps", {
        parser: function(M, b, U, N, T) {
          return T = new mi(M, U, 0, 0, T, 2), T.setRatio = Sa, T.e = b, T.pr = -10, T.data = N._tween, y = !0, T;
        }
      }), Tt = "bezier,throwProps,physicsProps,physics2D".split(","), Zi = Tt.length; Zi--; )
        Za(Tt[Zi]);
      Tt = Mt.prototype, Tt._firstPT = Tt._lastParsedTransform = Tt._transform = null, Tt._onInitTween = function(M, b, U, N) {
        if (!M.nodeType)
          return !1;
        this._target = Y = M, this._tween = U, this._vars = b, _ = N, Rt = b.autoRound, y = !1, pt = b.suffixMap || Mt.suffixMap, gt = rn(M, ""), S = this._overwriteProps;
        var T, rt, F, ut, xt, ft, et, Xt, Vt, It = M.style;
        if (vt && It.zIndex === "" && (T = Ze(M, "zIndex", gt), (T === "auto" || T === "") && this._addLazySet(It, "zIndex", 0)), typeof b == "string" && (ut = It.cssText, T = Fn(M, gt), It.cssText = ut + ";" + b, T = Ni(M, T, Fn(M)).difs, !Ui && it.test(b) && (T.opacity = parseFloat(RegExp.$1)), b = T, It.cssText = ut), b.className ? this._firstPT = rt = nt.className.parse(
          M,
          b.className,
          "className",
          this,
          null,
          null,
          b
        ) : this._firstPT = rt = this.parse(M, b, null), this._transformType) {
          for (Vt = this._transformType === 3, on ? Nt && (vt = !0, It.zIndex === "" && (et = Ze(M, "zIndex", gt), (et === "auto" || et === "") && this._addLazySet(It, "zIndex", 0)), Ct && this._addLazySet(
            It,
            "WebkitBackfaceVisibility",
            this._vars.WebkitBackfaceVisibility || (Vt ? "visible" : "hidden")
          )) : It.zoom = 1, F = rt; F && F._next; )
            F = F._next;
          Xt = new mi(M, "transform", 0, 0, null, 2), this._linkCSSP(Xt, null, F), Xt.setRatio = on ? $a : Ta, Xt.data = this._transform || br(M, gt, !0), Xt.tween = U, Xt.pr = -1, S.pop();
        }
        if (y) {
          for (; rt; ) {
            for (ft = rt._next, F = ut; F && F.pr > rt.pr; )
              F = F._next;
            (rt._prev = F ? F._prev : xt) ? rt._prev._next = rt : ut = rt, (rt._next = F) ? F._prev = rt : xt = rt, rt = ft;
          }
          this._firstPT = ut;
        }
        return !0;
      }, Tt.parse = function(M, b, U, N) {
        var T, rt, F, ut, xt, ft, et, Xt, Vt, It, Kt = M.style;
        for (T in b) {
          if (ft = b[T], typeof ft == "function" && (ft = ft(_, Y)), rt = nt[T])
            U = rt.parse(M, ft, T, this, U, N, b);
          else {
            if (T.substr(0, 2) === "--") {
              this._tween._propLookup[T] = this._addTween.call(
                this._tween,
                M.style,
                "setProperty",
                rn(M).getPropertyValue(T) + "",
                ft + "",
                T,
                !1,
                T
              );
              continue;
            }
            xt = Ze(M, T, gt) + "", Vt = typeof ft == "string", T === "color" || T === "fill" || T === "stroke" || T.indexOf("Color") !== -1 || Vt && dt.test(ft) ? (Vt || (ft = Se(ft), ft = (ft.length > 3 ? "rgba(" : "rgb(") + ft.join(",") + ")"), U = or(Kt, T, xt, ft, !0, "transparent", U, 0, N)) : Vt && nn.test(ft) ? U = or(Kt, T, xt, ft, !0, null, U, 0, N) : (F = parseFloat(xt), et = F || F === 0 ? xt.substr((F + "").length) : "", (xt === "" || xt === "auto") && (T === "width" || T === "height" ? (F = j(M, T, gt), et = "px") : T === "left" || T === "top" ? (F = lo(M, T, gt), et = "px") : (F = T !== "opacity" ? 0 : 1, et = "")), It = Vt && ft.charAt(1) === "=", It ? (ut = parseInt(ft.charAt(0) + "1", 10), ft = ft.substr(2), ut *= parseFloat(ft), Xt = ft.replace(z, "")) : (ut = parseFloat(ft), Xt = Vt ? ft.replace(z, "") : ""), Xt === "" && (Xt = T in pt ? pt[T] : et), ft = ut || ut === 0 ? (It ? ut + F : ut) + Xt : b[T], et !== Xt && (Xt !== "" || T === "lineHeight") && (ut || ut === 0) && F && (F = _n(M, T, F, et), Xt === "%" ? (F /= _n(M, T, 100, "%") / 100, b.strictUnits !== !0 && (xt = F + "%")) : Xt === "em" || Xt === "rem" || Xt === "vw" || Xt === "vh" ? F /= _n(M, T, 1, Xt) : Xt !== "px" && (ut = _n(M, T, ut, Xt), Xt = "px"), It && (ut || ut === 0) && (ft = ut + F + Xt)), It && (ut += F), !F && F !== 0 || !ut && ut !== 0 ? Kt[T] !== void 0 && (ft || ft + "" != "NaN" && ft != null) ? (U = new mi(
              Kt,
              T,
              ut || F || 0,
              0,
              U,
              -1,
              T,
              !1,
              0,
              xt,
              ft
            ), U.xs0 = ft !== "none" || T !== "display" && T.indexOf("Style") === -1 ? ft : xt) : Pr("invalid " + T + " tween value: " + b[T]) : (U = new mi(
              Kt,
              T,
              F,
              ut - F,
              U,
              0,
              T,
              Rt !== !1 && (Xt === "px" || T === "zIndex"),
              0,
              xt,
              ft
            ), U.xs0 = Xt));
          }
          N && U && !U.plugin && (U.plugin = N);
        }
        return U;
      }, Tt.setRatio = function(M) {
        var b, U, N, T = this._firstPT, rt = 1e-6;
        if (M !== 1 || this._tween._time !== this._tween._duration && this._tween._time !== 0)
          if (M || this._tween._time !== this._tween._duration && this._tween._time !== 0 || this._tween._rawPrevTime === -1e-6)
            for (; T; ) {
              if (b = T.c * M + T.s, T.r ? b = T.r(b) : rt > b && b > -rt && (b = 0), T.type)
                if (T.type === 1)
                  if (N = T.l, N === 2)
                    T.t[T.p] = T.xs0 + b + T.xs1 + T.xn1 + T.xs2;
                  else if (N === 3)
                    T.t[T.p] = T.xs0 + b + T.xs1 + T.xn1 + T.xs2 + T.xn2 + T.xs3;
                  else if (N === 4)
                    T.t[T.p] = T.xs0 + b + T.xs1 + T.xn1 + T.xs2 + T.xn2 + T.xs3 + T.xn3 + T.xs4;
                  else if (N === 5)
                    T.t[T.p] = T.xs0 + b + T.xs1 + T.xn1 + T.xs2 + T.xn2 + T.xs3 + T.xn3 + T.xs4 + T.xn4 + T.xs5;
                  else {
                    for (U = T.xs0 + b + T.xs1, N = 1; N < T.l; N++)
                      U += T["xn" + N] + T["xs" + (N + 1)];
                    T.t[T.p] = U;
                  }
                else
                  T.type === -1 ? T.t[T.p] = T.xs0 : T.setRatio && T.setRatio(M);
              else
                T.t[T.p] = b + T.xs0;
              T = T._next;
            }
          else
            for (; T; )
              T.type !== 2 ? T.t[T.p] = T.b : T.setRatio(M), T = T._next;
        else
          for (; T; ) {
            if (T.type !== 2)
              if (T.r && T.type !== -1)
                if (b = T.r(T.s + T.c), T.type) {
                  if (T.type === 1) {
                    for (N = T.l, U = T.xs0 + b + T.xs1, N = 1; N < T.l; N++)
                      U += T["xn" + N] + T["xs" + (N + 1)];
                    T.t[T.p] = U;
                  }
                } else
                  T.t[T.p] = b + T.xs0;
              else
                T.t[T.p] = T.e;
            else
              T.setRatio(M);
            T = T._next;
          }
      }, Tt._enableTransforms = function(M) {
        this._transform = this._transform || br(this._target, gt, !0), this._transformType = this._transform.svg && Lr || !M && this._transformType !== 3 ? 2 : 3;
      };
      var Ea = function(M) {
        this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
      };
      Tt._addLazySet = function(M, b, U) {
        var N = this._firstPT = new mi(M, b, 0, 0, this._firstPT, 2);
        N.e = U, N.setRatio = Ea, N.data = this;
      }, Tt._linkCSSP = function(M, b, U, N) {
        return M && (b && (b._prev = M), M._next && (M._next._prev = M._prev), M._prev ? M._prev._next = M._next : this._firstPT === M && (this._firstPT = M._next, N = !0), U ? U._next = M : N || this._firstPT !== null || (this._firstPT = M), M._next = b, M._prev = U), M;
      }, Tt._mod = function(M) {
        for (var b = this._firstPT; b; )
          typeof M[b.p] == "function" && (b.r = M[b.p]), b = b._next;
      }, Tt._kill = function(M) {
        var b, U, N, T = M;
        if (M.autoAlpha || M.alpha) {
          T = {};
          for (U in M)
            T[U] = M[U];
          T.opacity = 1, T.autoAlpha && (T.visibility = 1);
        }
        for (M.className && (b = this._classNamePT) && (N = b.xfirst, N && N._prev ? this._linkCSSP(N._prev, b._next, N._prev._prev) : N === this._firstPT && (this._firstPT = b._next), b._next && this._linkCSSP(b._next, b._next._next, N._prev), this._classNamePT = null), b = this._firstPT; b; )
          b.plugin && b.plugin !== U && b.plugin._kill && (b.plugin._kill(M), U = b.plugin), b = b._next;
        return g.prototype._kill.call(this, T);
      };
      var yr = function(M, b, U) {
        var N, T, rt, F;
        if (M.slice)
          for (T = M.length; --T > -1; )
            yr(M[T], b, U);
        else
          for (N = M.childNodes, T = N.length; --T > -1; )
            rt = N[T], F = rt.type, rt.style && (b.push(Fn(rt)), U && U.push(rt)), F !== 1 && F !== 9 && F !== 11 || !rt.childNodes.length || yr(rt, b, U);
      };
      return Mt.cascadeTo = function(M, b, U) {
        var N, T, rt, F, ut = $.to(M, b, U), xt = [ut], ft = [], et = [], Xt = [], Vt = $._internals.reservedProps;
        for (M = ut._targets || ut.target, yr(M, ft, Xt), ut.render(b, !0, !0), yr(M, et), ut.render(0, !0, !0), ut._enabled(!0), N = Xt.length; --N > -1; )
          if (T = Ni(Xt[N], ft[N], et[N]), T.firstMPT) {
            T = T.difs;
            for (rt in U)
              Vt[rt] && (T[rt] = U[rt]);
            F = {};
            for (rt in T)
              F[rt] = ft[N][rt];
            xt.push($.fromTo(Xt[N], b, F, T));
          }
        return xt;
      }, g.activate([Mt]), Mt;
    },
    !0
  ), function() {
    var g = qi._gsDefine.plugin({
      propName: "roundProps",
      version: "1.7.0",
      priority: -1,
      API: 2,
      init: function(gt, S, Mt) {
        return this._tween = Mt, !0;
      }
    }), $ = function(gt) {
      var S = 1 > gt ? Math.pow(10, (gt + "").length - 2) : 1;
      return function(Mt) {
        return (Math.round(Mt / gt) * gt * S | 0) / S;
      };
    }, y = function(gt, S) {
      for (; gt; )
        gt.f || gt.blob || (gt.m = S || Math.round), gt = gt._next;
    }, pt = g.prototype;
    pt._onInitAllProps = function() {
      var gt, S, Mt, kt, nt = this._tween, Tt = nt.vars.roundProps, Rt = {}, vt = nt._propLookup.roundProps;
      if (typeof Tt != "object" || Tt.push)
        for (typeof Tt == "string" && (Tt = Tt.split(",")), Mt = Tt.length; --Mt > -1; )
          Rt[Tt[Mt]] = Math.round;
      else
        for (kt in Tt)
          Rt[kt] = $(Tt[kt]);
      for (kt in Rt)
        for (gt = nt._firstPT; gt; )
          S = gt._next, gt.pg ? gt.t._mod(Rt) : gt.n === kt && (gt.f === 2 && gt.t ? y(gt.t._firstPT, Rt[kt]) : (this._add(gt.t, kt, gt.s, gt.c, Rt[kt]), S && (S._prev = gt._prev), gt._prev ? gt._prev._next = S : nt._firstPT === gt && (nt._firstPT = S), gt._next = gt._prev = null, nt._propLookup[kt] = vt)), gt = S;
      return !1;
    }, pt._add = function(gt, S, Mt, kt, nt) {
      this._addTween(gt, S, Mt, Mt + kt, S, nt || Math.round), this._overwriteProps.push(S);
    };
  }(), function() {
    qi._gsDefine.plugin({
      propName: "attr",
      API: 2,
      version: "0.6.1",
      init: function(g, $, y, pt) {
        var gt, S;
        if (typeof g.setAttribute != "function")
          return !1;
        for (gt in $)
          S = $[gt], typeof S == "function" && (S = S(pt, g)), this._addTween(
            g,
            "setAttribute",
            g.getAttribute(gt) + "",
            S + "",
            gt,
            !1,
            gt
          ), this._overwriteProps.push(gt);
        return !0;
      }
    });
  }(), qi._gsDefine.plugin({
    propName: "directionalRotation",
    version: "0.3.1",
    API: 2,
    init: function(g, $, y, pt) {
      typeof $ != "object" && ($ = { rotation: $ }), this.finals = {};
      var gt, S, Mt, kt, nt, Tt, Rt = $.useRadians === !0 ? 2 * Math.PI : 360, vt = 1e-6;
      for (gt in $)
        gt !== "useRadians" && (kt = $[gt], typeof kt == "function" && (kt = kt(pt, g)), Tt = (kt + "").split("_"), S = Tt[0], Mt = parseFloat(
          typeof g[gt] != "function" ? g[gt] : g[gt.indexOf("set") || typeof g["get" + gt.substr(3)] != "function" ? gt : "get" + gt.substr(3)]()
        ), kt = this.finals[gt] = typeof S == "string" && S.charAt(1) === "=" ? Mt + parseInt(S.charAt(0) + "1", 10) * Number(S.substr(2)) : Number(S) || 0, nt = kt - Mt, Tt.length && (S = Tt.join("_"), S.indexOf("short") !== -1 && (nt %= Rt, nt !== nt % (Rt / 2) && (nt = 0 > nt ? nt + Rt : nt - Rt)), S.indexOf("_cw") !== -1 && 0 > nt ? nt = (nt + 9999999999 * Rt) % Rt - (nt / Rt | 0) * Rt : S.indexOf("ccw") !== -1 && nt > 0 && (nt = (nt - 9999999999 * Rt) % Rt - (nt / Rt | 0) * Rt)), (nt > vt || -vt > nt) && (this._addTween(g, gt, Mt, Mt + nt, gt), this._overwriteProps.push(gt)));
      return !0;
    },
    set: function(g) {
      var $;
      if (g !== 1)
        this._super.setRatio.call(this, g);
      else
        for ($ = this._firstPT; $; )
          $.f ? $.t[$.p](this.finals[$.p]) : $.t[$.p] = this.finals[$.p], $ = $._next;
    }
  })._autoCSS = !0, qi._gsDefine(
    "easing.Back",
    ["easing.Ease"],
    function(g) {
      var $, y, pt, gt, S = qi.GreenSockGlobals || qi, Mt = S.com.greensock, kt = 2 * Math.PI, nt = Math.PI / 2, Tt = Mt._class, Rt = function(x, B) {
        var E = Tt("easing." + x, function() {
        }, !0), Z = E.prototype = new g();
        return Z.constructor = E, Z.getRatio = B, E;
      }, vt = g.register || function() {
      }, Nt = function(x, B, E, Z, z) {
        var X = Tt(
          "easing." + x,
          { easeOut: new B(), easeIn: new E(), easeInOut: new Z() },
          !0
        );
        return vt(X, x), X;
      }, Ut = function(x, B, E) {
        this.t = x, this.v = B, E && (this.next = E, E.prev = this, this.c = E.v - B, this.gap = E.t - x);
      }, Ct = function(x, B) {
        var E = Tt(
          "easing." + x,
          function(z) {
            this._p1 = z || z === 0 ? z : 1.70158, this._p2 = 1.525 * this._p1;
          },
          !0
        ), Z = E.prototype = new g();
        return Z.constructor = E, Z.getRatio = B, Z.config = function(z) {
          return new E(z);
        }, E;
      }, at = Nt(
        "Back",
        Ct("BackOut", function(x) {
          return (x -= 1) * x * ((this._p1 + 1) * x + this._p1) + 1;
        }),
        Ct("BackIn", function(x) {
          return x * x * ((this._p1 + 1) * x - this._p1);
        }),
        Ct("BackInOut", function(x) {
          return (x *= 2) < 1 ? 0.5 * x * x * ((this._p2 + 1) * x - this._p2) : 0.5 * ((x -= 2) * x * ((this._p2 + 1) * x + this._p2) + 2);
        })
      ), Y = Tt(
        "easing.SlowMo",
        function(x, B, E) {
          B = B || B === 0 ? B : 0.7, x == null ? x = 0.7 : x > 1 && (x = 1), this._p = x !== 1 ? B : 0, this._p1 = (1 - x) / 2, this._p2 = x, this._p3 = this._p1 + this._p2, this._calcEnd = E === !0;
        },
        !0
      ), _ = Y.prototype = new g();
      return _.constructor = Y, _.getRatio = function(x) {
        var B = x + (0.5 - x) * this._p;
        return x < this._p1 ? this._calcEnd ? 1 - (x = 1 - x / this._p1) * x : B - (x = 1 - x / this._p1) * x * x * x * B : x > this._p3 ? this._calcEnd ? x === 1 ? 0 : 1 - (x = (x - this._p3) / this._p1) * x : B + (x - B) * (x = (x - this._p3) / this._p1) * x * x * x : this._calcEnd ? 1 : B;
      }, Y.ease = new Y(0.7, 0.7), _.config = Y.config = function(x, B, E) {
        return new Y(x, B, E);
      }, $ = Tt(
        "easing.SteppedEase",
        function(x, B) {
          x = x || 1, this._p1 = 1 / x, this._p2 = x + (B ? 0 : 1), this._p3 = B ? 1 : 0;
        },
        !0
      ), _ = $.prototype = new g(), _.constructor = $, _.getRatio = function(x) {
        return 0 > x ? x = 0 : x >= 1 && (x = 0.999999999), ((this._p2 * x | 0) + this._p3) * this._p1;
      }, _.config = $.config = function(x, B) {
        return new $(x, B);
      }, y = Tt(
        "easing.ExpoScaleEase",
        function(x, B, E) {
          this._p1 = Math.log(B / x), this._p2 = B - x, this._p3 = x, this._ease = E;
        },
        !0
      ), _ = y.prototype = new g(), _.constructor = y, _.getRatio = function(x) {
        return this._ease && (x = this._ease.getRatio(x)), (this._p3 * Math.exp(this._p1 * x) - this._p3) / this._p2;
      }, _.config = y.config = function(x, B, E) {
        return new y(x, B, E);
      }, pt = Tt(
        "easing.RoughEase",
        function(x) {
          x = x || {};
          for (var B, E, Z, z, X, it, _t = x.taper || "none", dt = [], zt = 0, Yt = 0 | (x.points || 20), re = Yt, se = x.randomize !== !1, we = x.clamp === !0, Et = x.template instanceof g ? x.template : null, ie = typeof x.strength == "number" ? 0.4 * x.strength : 0.4; --re > -1; )
            B = se ? Math.random() : 1 / Yt * re, E = Et ? Et.getRatio(B) : B, _t === "none" ? Z = ie : _t === "out" ? (z = 1 - B, Z = z * z * ie) : _t === "in" ? Z = B * B * ie : 0.5 > B ? (z = 2 * B, Z = z * z * 0.5 * ie) : (z = 2 * (1 - B), Z = z * z * 0.5 * ie), se ? E += Math.random() * Z - 0.5 * Z : re % 2 ? E += 0.5 * Z : E -= 0.5 * Z, we && (E > 1 ? E = 1 : 0 > E && (E = 0)), dt[zt++] = { x: B, y: E };
          for (dt.sort(function(ze, nn) {
            return ze.x - nn.x;
          }), it = new Ut(1, 1, null), re = Yt; --re > -1; )
            X = dt[re], it = new Ut(X.x, X.y, it);
          this._prev = new Ut(0, 0, it.t !== 0 ? it : it.next);
        },
        !0
      ), _ = pt.prototype = new g(), _.constructor = pt, _.getRatio = function(x) {
        var B = this._prev;
        if (x > B.t) {
          for (; B.next && x >= B.t; )
            B = B.next;
          B = B.prev;
        } else
          for (; B.prev && x <= B.t; )
            B = B.prev;
        return this._prev = B, B.v + (x - B.t) / B.gap * B.c;
      }, _.config = function(x) {
        return new pt(x);
      }, pt.ease = new pt(), Nt(
        "Bounce",
        Rt("BounceOut", function(x) {
          return 1 / 2.75 > x ? 7.5625 * x * x : 2 / 2.75 > x ? 7.5625 * (x -= 1.5 / 2.75) * x + 0.75 : 2.5 / 2.75 > x ? 7.5625 * (x -= 2.25 / 2.75) * x + 0.9375 : 7.5625 * (x -= 2.625 / 2.75) * x + 0.984375;
        }),
        Rt("BounceIn", function(x) {
          return (x = 1 - x) < 1 / 2.75 ? 1 - 7.5625 * x * x : 2 / 2.75 > x ? 1 - (7.5625 * (x -= 1.5 / 2.75) * x + 0.75) : 2.5 / 2.75 > x ? 1 - (7.5625 * (x -= 2.25 / 2.75) * x + 0.9375) : 1 - (7.5625 * (x -= 2.625 / 2.75) * x + 0.984375);
        }),
        Rt("BounceInOut", function(x) {
          var B = 0.5 > x;
          return x = B ? 1 - 2 * x : 2 * x - 1, x = 1 / 2.75 > x ? 7.5625 * x * x : 2 / 2.75 > x ? 7.5625 * (x -= 1.5 / 2.75) * x + 0.75 : 2.5 / 2.75 > x ? 7.5625 * (x -= 2.25 / 2.75) * x + 0.9375 : 7.5625 * (x -= 2.625 / 2.75) * x + 0.984375, B ? 0.5 * (1 - x) : 0.5 * x + 0.5;
        })
      ), Nt(
        "Circ",
        Rt("CircOut", function(x) {
          return Math.sqrt(1 - (x -= 1) * x);
        }),
        Rt("CircIn", function(x) {
          return -(Math.sqrt(1 - x * x) - 1);
        }),
        Rt("CircInOut", function(x) {
          return (x *= 2) < 1 ? -0.5 * (Math.sqrt(1 - x * x) - 1) : 0.5 * (Math.sqrt(1 - (x -= 2) * x) + 1);
        })
      ), gt = function(x, B, E) {
        var Z = Tt(
          "easing." + x,
          function(X, it) {
            this._p1 = X >= 1 ? X : 1, this._p2 = (it || E) / (1 > X ? X : 1), this._p3 = this._p2 / kt * (Math.asin(1 / this._p1) || 0), this._p2 = kt / this._p2;
          },
          !0
        ), z = Z.prototype = new g();
        return z.constructor = Z, z.getRatio = B, z.config = function(X, it) {
          return new Z(X, it);
        }, Z;
      }, Nt(
        "Elastic",
        gt(
          "ElasticOut",
          function(x) {
            return this._p1 * Math.pow(2, -10 * x) * Math.sin((x - this._p3) * this._p2) + 1;
          },
          0.3
        ),
        gt(
          "ElasticIn",
          function(x) {
            return -(this._p1 * Math.pow(2, 10 * (x -= 1)) * Math.sin((x - this._p3) * this._p2));
          },
          0.3
        ),
        gt(
          "ElasticInOut",
          function(x) {
            return (x *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (x -= 1)) * Math.sin((x - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (x -= 1)) * Math.sin((x - this._p3) * this._p2) * 0.5 + 1;
          },
          0.45
        )
      ), Nt(
        "Expo",
        Rt("ExpoOut", function(x) {
          return 1 - Math.pow(2, -10 * x);
        }),
        Rt("ExpoIn", function(x) {
          return Math.pow(2, 10 * (x - 1)) - 1e-3;
        }),
        Rt("ExpoInOut", function(x) {
          return (x *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (x - 1)) : 0.5 * (2 - Math.pow(2, -10 * (x - 1)));
        })
      ), Nt(
        "Sine",
        Rt("SineOut", function(x) {
          return Math.sin(x * nt);
        }),
        Rt("SineIn", function(x) {
          return -Math.cos(x * nt) + 1;
        }),
        Rt("SineInOut", function(x) {
          return -0.5 * (Math.cos(Math.PI * x) - 1);
        })
      ), Tt(
        "easing.EaseLookup",
        {
          find: function(x) {
            return g.map[x];
          }
        },
        !0
      ), vt(S.SlowMo, "SlowMo", "ease,"), vt(pt, "RoughEase", "ease,"), vt($, "SteppedEase", "ease,"), at;
    },
    !0
  );
}), qi._gsDefine && qi._gsQueue.pop()(), function(g, $) {
  var y = {}, pt = g.document, gt = g.GreenSockGlobals = g.GreenSockGlobals || g, S = gt[$];
  if (S)
    return typeof module < "u" && module.exports && (module.exports = S), S;
  var Mt, kt, nt, Tt, Rt, vt = function(A) {
    var k, j = A.split("."), q = gt;
    for (k = 0; k < j.length; k++)
      q[j[k]] = q = q[j[k]] || {};
    return q;
  }, Nt = vt("com.greensock"), Ut = 1e-10, Ct = function(A) {
    var k, j = [], q = A.length;
    for (k = 0; k !== q; j.push(A[k++]))
      ;
    return j;
  }, at = function() {
  }, Y = function() {
    var A = Object.prototype.toString, k = A.call([]);
    return function(j) {
      return j != null && (j instanceof Array || typeof j == "object" && !!j.push && A.call(j) === k);
    };
  }(), _ = {}, x = function(A, k, j, q) {
    this.sc = _[A] ? _[A].sc : [], _[A] = this, this.gsClass = null, this.func = j;
    var ht = [];
    this.check = function(Lt) {
      for (var Gt, Pt, Ae, Se, te = k.length, Pe = te; --te > -1; )
        (Gt = _[k[te]] || new x(k[te], [])).gsClass ? (ht[te] = Gt.gsClass, Pe--) : Lt && Gt.sc.push(this);
      if (Pe === 0 && j) {
        if (Pt = ("com.greensock." + A).split("."), Ae = Pt.pop(), Se = vt(Pt.join("."))[Ae] = this.gsClass = j.apply(j, ht), q)
          if (gt[Ae] = y[Ae] = Se, typeof module < "u" && module.exports)
            if (A === $) {
              module.exports = y[$] = Se;
              for (te in y)
                Se[te] = y[te];
            } else
              y[$] && (y[$][Ae] = Se);
          else
            typeof define == "function" && define.amd && define(
              (g.GreenSockAMDPath ? g.GreenSockAMDPath + "/" : "") + A.split(".").pop(),
              [],
              function() {
                return Se;
              }
            );
        for (te = 0; te < this.sc.length; te++)
          this.sc[te].check();
      }
    }, this.check(!0);
  }, B = g._gsDefine = function(A, k, j, q) {
    return new x(A, k, j, q);
  }, E = Nt._class = function(A, k, j) {
    return k = k || function() {
    }, B(
      A,
      [],
      function() {
        return k;
      },
      j
    ), k;
  };
  B.globals = gt;
  var Z = [0, 0, 1, 1], z = E(
    "easing.Ease",
    function(A, k, j, q) {
      this._func = A, this._type = j || 0, this._power = q || 0, this._params = k ? Z.concat(k) : Z;
    },
    !0
  ), X = z.map = {}, it = z.register = function(A, k, j, q) {
    for (var ht, Lt, Gt, Pt, Ae = k.split(","), Se = Ae.length, te = (j || "easeIn,easeOut,easeInOut").split(","); --Se > -1; )
      for (Lt = Ae[Se], ht = q ? E("easing." + Lt, null, !0) : Nt.easing[Lt] || {}, Gt = te.length; --Gt > -1; )
        Pt = te[Gt], X[Lt + "." + Pt] = X[Pt + Lt] = ht[Pt] = A.getRatio ? A : A[Pt] || new A();
  };
  for (nt = z.prototype, nt._calcEnd = !1, nt.getRatio = function(A) {
    if (this._func)
      return this._params[0] = A, this._func.apply(null, this._params);
    var k = this._type, j = this._power, q = k === 1 ? 1 - A : k === 2 ? A : 0.5 > A ? 2 * A : 2 * (1 - A);
    return j === 1 ? q *= q : j === 2 ? q *= q * q : j === 3 ? q *= q * q * q : j === 4 && (q *= q * q * q * q), k === 1 ? 1 - q : k === 2 ? q : 0.5 > A ? q / 2 : 1 - q / 2;
  }, Mt = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], kt = Mt.length; --kt > -1; )
    nt = Mt[kt] + ",Power" + kt, it(new z(null, null, 1, kt), nt, "easeOut", !0), it(new z(null, null, 2, kt), nt, "easeIn" + (kt === 0 ? ",easeNone" : "")), it(new z(null, null, 3, kt), nt, "easeInOut");
  X.linear = Nt.easing.Linear.easeIn, X.swing = Nt.easing.Quad.easeInOut;
  var _t = E("events.EventDispatcher", function(A) {
    this._listeners = {}, this._eventTarget = A || this;
  });
  nt = _t.prototype, nt.addEventListener = function(A, k, j, q, ht) {
    ht = ht || 0;
    var Lt, Gt, Pt = this._listeners[A], Ae = 0;
    for (this !== Tt || Rt || Tt.wake(), Pt == null && (this._listeners[A] = Pt = []), Gt = Pt.length; --Gt > -1; )
      Lt = Pt[Gt], Lt.c === k && Lt.s === j ? Pt.splice(Gt, 1) : Ae === 0 && Lt.pr < ht && (Ae = Gt + 1);
    Pt.splice(Ae, 0, { c: k, s: j, up: q, pr: ht });
  }, nt.removeEventListener = function(A, k) {
    var j, q = this._listeners[A];
    if (q) {
      for (j = q.length; --j > -1; )
        if (q[j].c === k)
          return void q.splice(j, 1);
    }
  }, nt.dispatchEvent = function(A) {
    var k, j, q, ht = this._listeners[A];
    if (ht)
      for (k = ht.length, k > 1 && (ht = ht.slice(0)), j = this._eventTarget; --k > -1; )
        q = ht[k], q && (q.up ? q.c.call(q.s || j, { type: A, target: j }) : q.c.call(q.s || j));
  };
  var dt = g.requestAnimationFrame, zt = g.cancelAnimationFrame, Yt = Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  }, re = Yt();
  for (Mt = ["ms", "moz", "webkit", "o"], kt = Mt.length; --kt > -1 && !dt; )
    dt = g[Mt[kt] + "RequestAnimationFrame"], zt = g[Mt[kt] + "CancelAnimationFrame"] || g[Mt[kt] + "CancelRequestAnimationFrame"];
  E("Ticker", function(A, k) {
    var j, q, ht, Lt, Gt, Pt = this, Ae = Yt(), Se = k !== !1 && dt ? "auto" : !1, te = 500, Pe = 33, ci = "tick", wi = function(Ke) {
      var mi, Yr, or = Yt() - re;
      or > te && (Ae += or - Pe), re += or, Pt.time = (re - Ae) / 1e3, mi = Pt.time - Gt, (!j || mi > 0 || Ke === !0) && (Pt.frame++, Gt += mi + (mi >= Lt ? 4e-3 : Lt - mi), Yr = !0), Ke !== !0 && (ht = q(wi)), Yr && Pt.dispatchEvent(ci);
    };
    _t.call(Pt), Pt.time = Pt.frame = 0, Pt.tick = function() {
      wi(!0);
    }, Pt.lagSmoothing = function(Ke, mi) {
      return arguments.length ? (te = Ke || 1 / Ut, void (Pe = Math.min(mi, te, 0))) : 1 / Ut > te;
    }, Pt.sleep = function() {
      ht != null && (Se && zt ? zt(ht) : clearTimeout(ht), q = at, ht = null, Pt === Tt && (Rt = !1));
    }, Pt.wake = function(Ke) {
      ht !== null ? Pt.sleep() : Ke ? Ae += -re + (re = Yt()) : Pt.frame > 10 && (re = Yt() - te + 5), q = j === 0 ? at : Se && dt ? dt : function(mi) {
        return setTimeout(mi, 1e3 * (Gt - Pt.time) + 1 | 0);
      }, Pt === Tt && (Rt = !0), wi(2);
    }, Pt.fps = function(Ke) {
      return arguments.length ? (j = Ke, Lt = 1 / (j || 60), Gt = this.time + Lt, void Pt.wake()) : j;
    }, Pt.useRAF = function(Ke) {
      return arguments.length ? (Pt.sleep(), Se = Ke, void Pt.fps(j)) : Se;
    }, Pt.fps(A), setTimeout(function() {
      Se === "auto" && Pt.frame < 5 && (pt || {}).visibilityState !== "hidden" && Pt.useRAF(!1);
    }, 1500);
  }), nt = Nt.Ticker.prototype = new Nt.events.EventDispatcher(), nt.constructor = Nt.Ticker;
  var se = E("core.Animation", function(A, k) {
    if (this.vars = k = k || {}, this._duration = this._totalDuration = A || 0, this._delay = Number(k.delay) || 0, this._timeScale = 1, this._active = k.immediateRender === !0, this.data = k.data, this._reversed = k.reversed === !0, Fi) {
      Rt || Tt.wake();
      var j = this.vars.useFrames ? Zn : Fi;
      j.add(this, j._time), this.vars.paused && this.paused(!0);
    }
  });
  Tt = se.ticker = new Nt.Ticker(), nt = se.prototype, nt._dirty = nt._gc = nt._initted = nt._paused = !1, nt._totalTime = nt._time = 0, nt._rawPrevTime = -1, nt._next = nt._last = nt._onUpdate = nt._timeline = nt.timeline = null, nt._paused = !1;
  var we = function() {
    Rt && Yt() - re > 2e3 && ((pt || {}).visibilityState !== "hidden" || !Tt.lagSmoothing()) && Tt.wake();
    var A = setTimeout(we, 2e3);
    A.unref && A.unref();
  };
  we(), nt.play = function(A, k) {
    return A != null && this.seek(A, k), this.reversed(!1).paused(!1);
  }, nt.pause = function(A, k) {
    return A != null && this.seek(A, k), this.paused(!0);
  }, nt.resume = function(A, k) {
    return A != null && this.seek(A, k), this.paused(!1);
  }, nt.seek = function(A, k) {
    return this.totalTime(Number(A), k !== !1);
  }, nt.restart = function(A, k) {
    return this.reversed(!1).paused(!1).totalTime(A ? -this._delay : 0, k !== !1, !0);
  }, nt.reverse = function(A, k) {
    return A != null && this.seek(A || this.totalDuration(), k), this.reversed(!0).paused(!1);
  }, nt.render = function(A, k, j) {
  }, nt.invalidate = function() {
    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this;
  }, nt.isActive = function() {
    var A, k = this._timeline, j = this._startTime;
    return !k || !this._gc && !this._paused && k.isActive() && (A = k.rawTime(!0)) >= j && A < j + this.totalDuration() / this._timeScale - 1e-7;
  }, nt._enabled = function(A, k) {
    return Rt || Tt.wake(), this._gc = !A, this._active = this.isActive(), k !== !0 && (A && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !A && this.timeline && this._timeline._remove(this, !0)), !1;
  }, nt._kill = function(A, k) {
    return this._enabled(!1, !1);
  }, nt.kill = function(A, k) {
    return this._kill(A, k), this;
  }, nt._uncache = function(A) {
    for (var k = A ? this : this.timeline; k; )
      k._dirty = !0, k = k.timeline;
    return this;
  }, nt._swapSelfInParams = function(A) {
    for (var k = A.length, j = A.concat(); --k > -1; )
      A[k] === "{self}" && (j[k] = this);
    return j;
  }, nt._callback = function(A) {
    var k = this.vars, j = k[A], q = k[A + "Params"], ht = k[A + "Scope"] || k.callbackScope || this, Lt = q ? q.length : 0;
    switch (Lt) {
      case 0:
        j.call(ht);
        break;
      case 1:
        j.call(ht, q[0]);
        break;
      case 2:
        j.call(ht, q[0], q[1]);
        break;
      default:
        j.apply(ht, q);
    }
  }, nt.eventCallback = function(A, k, j, q) {
    if ((A || "").substr(0, 2) === "on") {
      var ht = this.vars;
      if (arguments.length === 1)
        return ht[A];
      k == null ? delete ht[A] : (ht[A] = k, ht[A + "Params"] = Y(j) && j.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(j) : j, ht[A + "Scope"] = q), A === "onUpdate" && (this._onUpdate = k);
    }
    return this;
  }, nt.delay = function(A) {
    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + A - this._delay), this._delay = A, this) : this._delay;
  }, nt.duration = function(A) {
    return arguments.length ? (this._duration = this._totalDuration = A, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && A !== 0 && this.totalTime(this._totalTime * (A / this._duration), !0), this) : (this._dirty = !1, this._duration);
  }, nt.totalDuration = function(A) {
    return this._dirty = !1, arguments.length ? this.duration(A) : this._totalDuration;
  }, nt.time = function(A, k) {
    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(A > this._duration ? this._duration : A, k)) : this._time;
  }, nt.totalTime = function(A, k, j) {
    if (Rt || Tt.wake(), !arguments.length)
      return this._totalTime;
    if (this._timeline) {
      if (0 > A && !j && (A += this.totalDuration()), this._timeline.smoothChildTiming) {
        this._dirty && this.totalDuration();
        var q = this._totalDuration, ht = this._timeline;
        if (A > q && !j && (A = q), this._startTime = (this._paused ? this._pauseTime : ht._time) - (this._reversed ? q - A : A) / this._timeScale, ht._dirty || this._uncache(!1), ht._timeline)
          for (; ht._timeline; )
            ht._timeline._time !== (ht._startTime + ht._totalTime) / ht._timeScale && ht.totalTime(ht._totalTime, !0), ht = ht._timeline;
      }
      this._gc && this._enabled(!0, !1), (this._totalTime !== A || this._duration === 0) && (Ft.length && rn(), this.render(A, k, !1), Ft.length && rn());
    }
    return this;
  }, nt.progress = nt.totalProgress = function(A, k) {
    var j = this.duration();
    return arguments.length ? this.totalTime(j * A, k) : j ? this._time / j : this.ratio;
  }, nt.startTime = function(A) {
    return arguments.length ? (A !== this._startTime && (this._startTime = A, this.timeline && this.timeline._sortChildren && this.timeline.add(this, A - this._delay)), this) : this._startTime;
  }, nt.endTime = function(A) {
    return this._startTime + (A != 0 ? this.totalDuration() : this.duration()) / this._timeScale;
  }, nt.timeScale = function(A) {
    if (!arguments.length)
      return this._timeScale;
    var k, j;
    for (A = A || Ut, this._timeline && this._timeline.smoothChildTiming && (k = this._pauseTime, j = k || k === 0 ? k : this._timeline.totalTime(), this._startTime = j - (j - this._startTime) * this._timeScale / A), this._timeScale = A, j = this.timeline; j && j.timeline; )
      j._dirty = !0, j.totalDuration(), j = j.timeline;
    return this;
  }, nt.reversed = function(A) {
    return arguments.length ? (A != this._reversed && (this._reversed = A, this.totalTime(
      this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime,
      !0
    )), this) : this._reversed;
  }, nt.paused = function(A) {
    if (!arguments.length)
      return this._paused;
    var k, j, q = this._timeline;
    return A != this._paused && q && (Rt || A || Tt.wake(), k = q.rawTime(), j = k - this._pauseTime, !A && q.smoothChildTiming && (this._startTime += j, this._uncache(!1)), this._pauseTime = A ? k : null, this._paused = A, this._active = this.isActive(), !A && j !== 0 && this._initted && this.duration() && (k = q.smoothChildTiming ? this._totalTime : (k - this._startTime) / this._timeScale, this.render(k, k === this._totalTime, !0))), this._gc && !A && this._enabled(!0, !1), this;
  };
  var Et = E("core.SimpleTimeline", function(A) {
    se.call(this, 0, A), this.autoRemoveChildren = this.smoothChildTiming = !0;
  });
  nt = Et.prototype = new se(), nt.constructor = Et, nt.kill()._gc = !1, nt._first = nt._last = nt._recent = null, nt._sortChildren = !1, nt.add = nt.insert = function(A, k, j, q) {
    var ht, Lt;
    if (A._startTime = Number(k || 0) + A._delay, A._paused && this !== A._timeline && (A._pauseTime = this.rawTime() - (A._timeline.rawTime() - A._pauseTime)), A.timeline && A.timeline._remove(A, !0), A.timeline = A._timeline = this, A._gc && A._enabled(!0, !0), ht = this._last, this._sortChildren)
      for (Lt = A._startTime; ht && ht._startTime > Lt; )
        ht = ht._prev;
    return ht ? (A._next = ht._next, ht._next = A) : (A._next = this._first, this._first = A), A._next ? A._next._prev = A : this._last = A, A._prev = ht, this._recent = A, this._timeline && this._uncache(!0), this;
  }, nt._remove = function(A, k) {
    return A.timeline === this && (k || A._enabled(!1, !0), A._prev ? A._prev._next = A._next : this._first === A && (this._first = A._next), A._next ? A._next._prev = A._prev : this._last === A && (this._last = A._prev), A._next = A._prev = A.timeline = null, A === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this;
  }, nt.render = function(A, k, j) {
    var q, ht = this._first;
    for (this._totalTime = this._time = this._rawPrevTime = A; ht; )
      q = ht._next, (ht._active || A >= ht._startTime && !ht._paused && !ht._gc) && (ht._reversed ? ht.render(
        (ht._dirty ? ht.totalDuration() : ht._totalDuration) - (A - ht._startTime) * ht._timeScale,
        k,
        j
      ) : ht.render((A - ht._startTime) * ht._timeScale, k, j)), ht = q;
  }, nt.rawTime = function() {
    return Rt || Tt.wake(), this._totalTime;
  };
  var ie = E(
    "TweenLite",
    function(A, k, j) {
      if (se.call(this, k, j), this.render = ie.prototype.render, A == null)
        throw "Cannot tween a null target.";
      this.target = A = typeof A != "string" ? A : ie.selector(A) || A;
      var q, ht, Lt, Gt = A.jquery || A.length && A !== g && A[0] && (A[0] === g || A[0].nodeType && A[0].style && !A.nodeType), Pt = this.vars.overwrite;
      if (this._overwrite = Pt = Pt == null ? Pr[ie.defaultOverwrite] : typeof Pt == "number" ? Pt >> 0 : Pr[Pt], (Gt || A instanceof Array || A.push && Y(A)) && typeof A[0] != "number")
        for (this._targets = Lt = Ct(A), this._propLookup = [], this._siblings = [], q = 0; q < Lt.length; q++)
          ht = Lt[q], ht ? typeof ht != "string" ? ht.length && ht !== g && ht[0] && (ht[0] === g || ht[0].nodeType && ht[0].style && !ht.nodeType) ? (Lt.splice(q--, 1), this._targets = Lt = Lt.concat(Ct(ht))) : (this._siblings[q] = Ze(ht, this, !1), Pt === 1 && this._siblings[q].length > 1 && lo(ht, this, null, 1, this._siblings[q])) : (ht = Lt[q--] = ie.selector(ht), typeof ht == "string" && Lt.splice(q + 1, 1)) : Lt.splice(q--, 1);
      else
        this._propLookup = {}, this._siblings = Ze(A, this, !1), Pt === 1 && this._siblings.length > 1 && lo(A, this, null, 1, this._siblings);
      (this.vars.immediateRender || k === 0 && this._delay === 0 && this.vars.immediateRender !== !1) && (this._time = -Ut, this.render(Math.min(0, -this._delay)));
    },
    !0
  ), ze = function(A) {
    return A && A.length && A !== g && A[0] && (A[0] === g || A[0].nodeType && A[0].style && !A.nodeType);
  }, nn = function(A, k) {
    var j, q = {};
    for (j in A)
      vr[j] || j in k && j !== "transform" && j !== "x" && j !== "y" && j !== "width" && j !== "height" && j !== "className" && j !== "border" || !(!ii[j] || ii[j] && ii[j]._autoCSS) || (q[j] = A[j], delete A[j]);
    A.css = q;
  };
  nt = ie.prototype = new se(), nt.constructor = ie, nt.kill()._gc = !1, nt.ratio = 0, nt._firstPT = nt._targets = nt._overwrittenProps = nt._startAt = null, nt._notifyPluginsOfEnabled = nt._lazy = !1, ie.version = "2.0.2", ie.defaultEase = nt._ease = new z(null, null, 1, 1), ie.defaultOverwrite = "auto", ie.ticker = Tt, ie.autoSleep = 120, ie.lagSmoothing = function(A, k) {
    Tt.lagSmoothing(A, k);
  }, ie.selector = g.$ || g.jQuery || function(A) {
    var k = g.$ || g.jQuery;
    return k ? (ie.selector = k, k(A)) : (pt || (pt = g.document), pt ? pt.querySelectorAll ? pt.querySelectorAll(A) : pt.getElementById(A.charAt(0) === "#" ? A.substr(1) : A) : A);
  };
  var Ft = [], $e = {}, Oi = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, En = /[\+-]=-?[\.\d]/, Yi = function(A) {
    for (var k, j = this._firstPT, q = 1e-6; j; )
      k = j.blob ? A === 1 && this.end != null ? this.end : A ? this.join("") : this.start : j.c * A + j.s, j.m ? k = j.m.call(this._tween, k, this._target || j.t, this._tween) : q > k && k > -q && !j.blob && (k = 0), j.f ? j.fp ? j.t[j.p](j.fp, k) : j.t[j.p](k) : j.t[j.p] = k, j = j._next;
  }, Oe = function(A, k, j, q) {
    var ht, Lt, Gt, Pt, Ae, Se, te, Pe = [], ci = 0, wi = "", Ke = 0;
    for (Pe.start = A, Pe.end = k, A = Pe[0] = A + "", k = Pe[1] = k + "", j && (j(Pe), A = Pe[0], k = Pe[1]), Pe.length = 0, ht = A.match(Oi) || [], Lt = k.match(Oi) || [], q && (q._next = null, q.blob = 1, Pe._firstPT = Pe._applyPT = q), Ae = Lt.length, Pt = 0; Ae > Pt; Pt++)
      te = Lt[Pt], Se = k.substr(ci, k.indexOf(te, ci) - ci), wi += Se || !Pt ? Se : ",", ci += Se.length, Ke ? Ke = (Ke + 1) % 5 : Se.substr(-5) === "rgba(" && (Ke = 1), te === ht[Pt] || ht.length <= Pt ? wi += te : (wi && (Pe.push(wi), wi = ""), Gt = parseFloat(ht[Pt]), Pe.push(Gt), Pe._firstPT = {
        _next: Pe._firstPT,
        t: Pe,
        p: Pe.length - 1,
        s: Gt,
        c: (te.charAt(1) === "=" ? parseInt(te.charAt(0) + "1", 10) * parseFloat(te.substr(2)) : parseFloat(te) - Gt) || 0,
        f: 0,
        m: Ke && 4 > Ke ? Math.round : 0
      }), ci += te.length;
    return wi += k.substr(ci), wi && Pe.push(wi), Pe.setRatio = Yi, En.test(k) && (Pe.end = null), Pe;
  }, Ai = function(A, k, j, q, ht, Lt, Gt, Pt, Ae) {
    typeof q == "function" && (q = q(Ae || 0, A));
    var Se, te = typeof A[k], Pe = te !== "function" ? "" : k.indexOf("set") || typeof A["get" + k.substr(3)] != "function" ? k : "get" + k.substr(3), ci = j !== "get" ? j : Pe ? Gt ? A[Pe](Gt) : A[Pe]() : A[k], wi = typeof q == "string" && q.charAt(1) === "=", Ke = {
      t: A,
      p: k,
      s: ci,
      f: te === "function",
      pg: 0,
      n: ht || k,
      m: Lt ? typeof Lt == "function" ? Lt : Math.round : 0,
      pr: 0,
      c: wi ? parseInt(q.charAt(0) + "1", 10) * parseFloat(q.substr(2)) : parseFloat(q) - ci || 0
    };
    return (typeof ci != "number" || typeof q != "number" && !wi) && (Gt || isNaN(ci) || !wi && isNaN(q) || typeof ci == "boolean" || typeof q == "boolean" ? (Ke.fp = Gt, Se = Oe(
      ci,
      wi ? parseFloat(Ke.s) + Ke.c + (Ke.s + "").replace(/[0-9\-\.]/g, "") : q,
      Pt || ie.defaultStringFilter,
      Ke
    ), Ke = {
      t: Se,
      p: "setRatio",
      s: 0,
      c: 1,
      f: 2,
      pg: 0,
      n: ht || k,
      pr: 0,
      m: 0
    }) : (Ke.s = parseFloat(ci), wi || (Ke.c = parseFloat(q) - Ke.s || 0))), Ke.c ? ((Ke._next = this._firstPT) && (Ke._next._prev = Ke), this._firstPT = Ke, Ke) : void 0;
  }, bn = ie._internals = {
    isArray: Y,
    isSelector: ze,
    lazyTweens: Ft,
    blobDif: Oe
  }, ii = ie._plugins = {}, ui = bn.tweenLookup = {}, Ui = 0, vr = bn.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1
  }, Pr = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    true: 1,
    false: 0
  }, Zn = se._rootFramesTimeline = new Et(), Fi = se._rootTimeline = new Et(), Un = 30, rn = bn.lazyRender = function() {
    var A, k = Ft.length;
    for ($e = {}; --k > -1; )
      A = Ft[k], A && A._lazy !== !1 && (A.render(A._lazy[0], A._lazy[1], !0), A._lazy = !1);
    Ft.length = 0;
  };
  Fi._startTime = Tt.time, Zn._startTime = Tt.frame, Fi._active = Zn._active = !0, setTimeout(rn, 1), se._updateRoot = ie.render = function() {
    var A, k, j;
    if (Ft.length && rn(), Fi.render((Tt.time - Fi._startTime) * Fi._timeScale, !1, !1), Zn.render((Tt.frame - Zn._startTime) * Zn._timeScale, !1, !1), Ft.length && rn(), Tt.frame >= Un) {
      Un = Tt.frame + (parseInt(ie.autoSleep, 10) || 120);
      for (j in ui) {
        for (k = ui[j].tweens, A = k.length; --A > -1; )
          k[A]._gc && k.splice(A, 1);
        k.length === 0 && delete ui[j];
      }
      if (j = Fi._first, (!j || j._paused) && ie.autoSleep && !Zn._first && Tt._listeners.tick.length === 1) {
        for (; j && j._paused; )
          j = j._next;
        j || Tt.sleep();
      }
    }
  }, Tt.addEventListener("tick", se._updateRoot);
  var Ze = function(A, k, j) {
    var q, ht, Lt = A._gsTweenID;
    if (ui[Lt || (A._gsTweenID = Lt = "t" + Ui++)] || (ui[Lt] = { target: A, tweens: [] }), k && (q = ui[Lt].tweens, q[ht = q.length] = k, j))
      for (; --ht > -1; )
        q[ht] === k && q.splice(ht, 1);
    return ui[Lt].tweens;
  }, _n = function(A, k, j, q) {
    var ht, Lt, Gt = A.vars.onOverwrite;
    return Gt && (ht = Gt(A, k, j, q)), Gt = ie.onOverwrite, Gt && (Lt = Gt(A, k, j, q)), ht !== !1 && Lt !== !1;
  }, lo = function(A, k, j, q, ht) {
    var Lt, Gt, Pt, Ae;
    if (q === 1 || q >= 4) {
      for (Ae = ht.length, Lt = 0; Ae > Lt; Lt++)
        if ((Pt = ht[Lt]) !== k)
          Pt._gc || Pt._kill(null, A, k) && (Gt = !0);
        else if (q === 5)
          break;
      return Gt;
    }
    var Se, te = k._startTime + Ut, Pe = [], ci = 0, wi = k._duration === 0;
    for (Lt = ht.length; --Lt > -1; )
      (Pt = ht[Lt]) === k || Pt._gc || Pt._paused || (Pt._timeline !== k._timeline ? (Se = Se || Fn(k, 0, wi), Fn(Pt, Se, wi) === 0 && (Pe[ci++] = Pt)) : Pt._startTime <= te && Pt._startTime + Pt.totalDuration() / Pt._timeScale > te && ((wi || !Pt._initted) && te - Pt._startTime <= 2e-10 || (Pe[ci++] = Pt)));
    for (Lt = ci; --Lt > -1; )
      if (Pt = Pe[Lt], Ae = Pt._firstPT, q === 2 && Pt._kill(j, A, k) && (Gt = !0), q !== 2 || !Pt._firstPT && Pt._initted && Ae) {
        if (q !== 2 && !_n(Pt, k))
          continue;
        Pt._enabled(!1, !1) && (Gt = !0);
      }
    return Gt;
  }, Fn = function(A, k, j) {
    for (var q = A._timeline, ht = q._timeScale, Lt = A._startTime; q._timeline; ) {
      if (Lt += q._startTime, ht *= q._timeScale, q._paused)
        return -100;
      q = q._timeline;
    }
    return Lt /= ht, Lt > k ? Lt - k : j && Lt === k || !A._initted && 2 * Ut > Lt - k ? Ut : (Lt += A.totalDuration() / A._timeScale / ht) > k + Ut ? 0 : Lt - k - Ut;
  };
  nt._init = function() {
    var A, k, j, q, ht, Lt, Gt = this.vars, Pt = this._overwrittenProps, Ae = this._duration, Se = !!Gt.immediateRender, te = Gt.ease;
    if (Gt.startAt) {
      this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), ht = {};
      for (q in Gt.startAt)
        ht[q] = Gt.startAt[q];
      if (ht.data = "isStart", ht.overwrite = !1, ht.immediateRender = !0, ht.lazy = Se && Gt.lazy !== !1, ht.startAt = ht.delay = null, ht.onUpdate = Gt.onUpdate, ht.onUpdateParams = Gt.onUpdateParams, ht.onUpdateScope = Gt.onUpdateScope || Gt.callbackScope || this, this._startAt = ie.to(this.target || {}, 0, ht), Se) {
        if (this._time > 0)
          this._startAt = null;
        else if (Ae !== 0)
          return;
      }
    } else if (Gt.runBackwards && Ae !== 0)
      if (this._startAt)
        this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
      else {
        this._time !== 0 && (Se = !1), j = {};
        for (q in Gt)
          vr[q] && q !== "autoCSS" || (j[q] = Gt[q]);
        if (j.overwrite = 0, j.data = "isFromStart", j.lazy = Se && Gt.lazy !== !1, j.immediateRender = Se, this._startAt = ie.to(this.target, 0, j), Se) {
          if (this._time === 0)
            return;
        } else
          this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null);
      }
    if (this._ease = te = te ? te instanceof z ? te : typeof te == "function" ? new z(te, Gt.easeParams) : X[te] || ie.defaultEase : ie.defaultEase, Gt.easeParams instanceof Array && te.config && (this._ease = te.config.apply(te, Gt.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
      for (Lt = this._targets.length, A = 0; Lt > A; A++)
        this._initProps(
          this._targets[A],
          this._propLookup[A] = {},
          this._siblings[A],
          Pt ? Pt[A] : null,
          A
        ) && (k = !0);
    else
      k = this._initProps(
        this.target,
        this._propLookup,
        this._siblings,
        Pt,
        0
      );
    if (k && ie._onPluginEvent("_onInitAllProps", this), Pt && (this._firstPT || typeof this.target != "function" && this._enabled(!1, !1)), Gt.runBackwards)
      for (j = this._firstPT; j; )
        j.s += j.c, j.c = -j.c, j = j._next;
    this._onUpdate = Gt.onUpdate, this._initted = !0;
  }, nt._initProps = function(A, k, j, q, ht) {
    var Lt, Gt, Pt, Ae, Se, te;
    if (A == null)
      return !1;
    $e[A._gsTweenID] && rn(), this.vars.css || A.style && A !== g && A.nodeType && ii.css && this.vars.autoCSS !== !1 && nn(this.vars, A);
    for (Lt in this.vars)
      if (te = this.vars[Lt], vr[Lt])
        te && (te instanceof Array || te.push && Y(te)) && te.join("").indexOf("{self}") !== -1 && (this.vars[Lt] = te = this._swapSelfInParams(te, this));
      else if (ii[Lt] && (Ae = new ii[Lt]())._onInitTween(A, this.vars[Lt], this, ht)) {
        for (this._firstPT = Se = {
          _next: this._firstPT,
          t: Ae,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: Lt,
          pg: 1,
          pr: Ae._priority,
          m: 0
        }, Gt = Ae._overwriteProps.length; --Gt > -1; )
          k[Ae._overwriteProps[Gt]] = this._firstPT;
        (Ae._priority || Ae._onInitAllProps) && (Pt = !0), (Ae._onDisable || Ae._onEnable) && (this._notifyPluginsOfEnabled = !0), Se._next && (Se._next._prev = Se);
      } else
        k[Lt] = Ai.call(
          this,
          A,
          Lt,
          "get",
          te,
          Lt,
          0,
          null,
          this.vars.stringFilter,
          ht
        );
    return q && this._kill(q, A) ? this._initProps(A, k, j, q, ht) : this._overwrite > 1 && this._firstPT && j.length > 1 && lo(A, this, k, this._overwrite, j) ? (this._kill(k, A), this._initProps(A, k, j, q, ht)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && ($e[A._gsTweenID] = !0), Pt);
  }, nt.render = function(A, k, j) {
    var q, ht, Lt, Gt, Pt = this._time, Ae = this._duration, Se = this._rawPrevTime;
    if (A >= Ae - 1e-7 && A >= 0)
      this._totalTime = this._time = Ae, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (q = !0, ht = "onComplete", j = j || this._timeline.autoRemoveChildren), Ae === 0 && (this._initted || !this.vars.lazy || j) && (this._startTime === this._timeline._duration && (A = 0), (0 > Se || 0 >= A && A >= -1e-7 || Se === Ut && this.data !== "isPause") && Se !== A && (j = !0, Se > Ut && (ht = "onReverseComplete")), this._rawPrevTime = Gt = !k || A || Se === A ? A : Ut);
    else if (1e-7 > A)
      this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (Pt !== 0 || Ae === 0 && Se > 0) && (ht = "onReverseComplete", q = this._reversed), 0 > A && (this._active = !1, Ae === 0 && (this._initted || !this.vars.lazy || j) && (Se >= 0 && (Se !== Ut || this.data !== "isPause") && (j = !0), this._rawPrevTime = Gt = !k || A || Se === A ? A : Ut)), (!this._initted || this._startAt && this._startAt.progress()) && (j = !0);
    else if (this._totalTime = this._time = A, this._easeType) {
      var te = A / Ae, Pe = this._easeType, ci = this._easePower;
      (Pe === 1 || Pe === 3 && te >= 0.5) && (te = 1 - te), Pe === 3 && (te *= 2), ci === 1 ? te *= te : ci === 2 ? te *= te * te : ci === 3 ? te *= te * te * te : ci === 4 && (te *= te * te * te * te), Pe === 1 ? this.ratio = 1 - te : Pe === 2 ? this.ratio = te : 0.5 > A / Ae ? this.ratio = te / 2 : this.ratio = 1 - te / 2;
    } else
      this.ratio = this._ease.getRatio(A / Ae);
    if (this._time !== Pt || j) {
      if (!this._initted) {
        if (this._init(), !this._initted || this._gc)
          return;
        if (!j && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
          return this._time = this._totalTime = Pt, this._rawPrevTime = Se, Ft.push(this), void (this._lazy = [A, k]);
        this._time && !q ? this.ratio = this._ease.getRatio(this._time / Ae) : q && this._ease._calcEnd && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1));
      }
      for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== Pt && A >= 0 && (this._active = !0), Pt === 0 && (this._startAt && (A >= 0 ? this._startAt.render(A, !0, j) : ht || (ht = "_dummyGS")), this.vars.onStart && (this._time !== 0 || Ae === 0) && (k || this._callback("onStart"))), Lt = this._firstPT; Lt; )
        Lt.f ? Lt.t[Lt.p](Lt.c * this.ratio + Lt.s) : Lt.t[Lt.p] = Lt.c * this.ratio + Lt.s, Lt = Lt._next;
      this._onUpdate && (0 > A && this._startAt && A !== -1e-4 && this._startAt.render(A, !0, j), k || (this._time !== Pt || q || j) && this._callback("onUpdate")), ht && (!this._gc || j) && (0 > A && this._startAt && !this._onUpdate && A !== -1e-4 && this._startAt.render(A, !0, j), q && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !k && this.vars[ht] && this._callback(ht), Ae === 0 && this._rawPrevTime === Ut && Gt !== Ut && (this._rawPrevTime = 0));
    }
  }, nt._kill = function(A, k, j) {
    if (A === "all" && (A = null), A == null && (k == null || k === this.target))
      return this._lazy = !1, this._enabled(!1, !1);
    k = typeof k != "string" ? k || this._targets || this.target : ie.selector(k) || k;
    var q, ht, Lt, Gt, Pt, Ae, Se, te, Pe, ci = j && this._time && j._startTime === this._startTime && this._timeline === j._timeline, wi = this._firstPT;
    if ((Y(k) || ze(k)) && typeof k[0] != "number")
      for (q = k.length; --q > -1; )
        this._kill(A, k[q], j) && (Ae = !0);
    else {
      if (this._targets) {
        for (q = this._targets.length; --q > -1; )
          if (k === this._targets[q]) {
            Pt = this._propLookup[q] || {}, this._overwrittenProps = this._overwrittenProps || [], ht = this._overwrittenProps[q] = A ? this._overwrittenProps[q] || {} : "all";
            break;
          }
      } else {
        if (k !== this.target)
          return !1;
        Pt = this._propLookup, ht = this._overwrittenProps = A ? this._overwrittenProps || {} : "all";
      }
      if (Pt) {
        if (Se = A || Pt, te = A !== ht && ht !== "all" && A !== Pt && (typeof A != "object" || !A._tempKill), j && (ie.onOverwrite || this.vars.onOverwrite)) {
          for (Lt in Se)
            Pt[Lt] && (Pe || (Pe = []), Pe.push(Lt));
          if ((Pe || !A) && !_n(this, j, k, Pe))
            return !1;
        }
        for (Lt in Se)
          (Gt = Pt[Lt]) && (ci && (Gt.f ? Gt.t[Gt.p](Gt.s) : Gt.t[Gt.p] = Gt.s, Ae = !0), Gt.pg && Gt.t._kill(Se) && (Ae = !0), Gt.pg && Gt.t._overwriteProps.length !== 0 || (Gt._prev ? Gt._prev._next = Gt._next : Gt === this._firstPT && (this._firstPT = Gt._next), Gt._next && (Gt._next._prev = Gt._prev), Gt._next = Gt._prev = null), delete Pt[Lt]), te && (ht[Lt] = 1);
        !this._firstPT && this._initted && wi && this._enabled(!1, !1);
      }
    }
    return Ae;
  }, nt.invalidate = function() {
    return this._notifyPluginsOfEnabled && ie._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], se.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -Ut, this.render(Math.min(0, -this._delay))), this;
  }, nt._enabled = function(A, k) {
    if (Rt || Tt.wake(), A && this._gc) {
      var j, q = this._targets;
      if (q)
        for (j = q.length; --j > -1; )
          this._siblings[j] = Ze(q[j], this, !0);
      else
        this._siblings = Ze(this.target, this, !0);
    }
    return se.prototype._enabled.call(this, A, k), this._notifyPluginsOfEnabled && this._firstPT ? ie._onPluginEvent(A ? "_onEnable" : "_onDisable", this) : !1;
  }, ie.to = function(A, k, j) {
    return new ie(A, k, j);
  }, ie.from = function(A, k, j) {
    return j.runBackwards = !0, j.immediateRender = j.immediateRender != 0, new ie(A, k, j);
  }, ie.fromTo = function(A, k, j, q) {
    return q.startAt = j, q.immediateRender = q.immediateRender != 0 && j.immediateRender != 0, new ie(A, k, q);
  }, ie.delayedCall = function(A, k, j, q, ht) {
    return new ie(k, 0, {
      delay: A,
      onComplete: k,
      onCompleteParams: j,
      callbackScope: q,
      onReverseComplete: k,
      onReverseCompleteParams: j,
      immediateRender: !1,
      lazy: !1,
      useFrames: ht,
      overwrite: 0
    });
  }, ie.set = function(A, k) {
    return new ie(A, 0, k);
  }, ie.getTweensOf = function(A, k) {
    if (A == null)
      return [];
    A = typeof A != "string" ? A : ie.selector(A) || A;
    var j, q, ht, Lt;
    if ((Y(A) || ze(A)) && typeof A[0] != "number") {
      for (j = A.length, q = []; --j > -1; )
        q = q.concat(ie.getTweensOf(A[j], k));
      for (j = q.length; --j > -1; )
        for (Lt = q[j], ht = j; --ht > -1; )
          Lt === q[ht] && q.splice(j, 1);
    } else if (A._gsTweenID)
      for (q = Ze(A).concat(), j = q.length; --j > -1; )
        (q[j]._gc || k && !q[j].isActive()) && q.splice(j, 1);
    return q || [];
  }, ie.killTweensOf = ie.killDelayedCallsTo = function(A, k, j) {
    typeof k == "object" && (j = k, k = !1);
    for (var q = ie.getTweensOf(A, k), ht = q.length; --ht > -1; )
      q[ht]._kill(j, A);
  };
  var Ni = E(
    "plugins.TweenPlugin",
    function(A, k) {
      this._overwriteProps = (A || "").split(","), this._propName = this._overwriteProps[0], this._priority = k || 0, this._super = Ni.prototype;
    },
    !0
  );
  if (nt = Ni.prototype, Ni.version = "1.19.0", Ni.API = 2, nt._firstPT = null, nt._addTween = Ai, nt.setRatio = Yi, nt._kill = function(A) {
    var k, j = this._overwriteProps, q = this._firstPT;
    if (A[this._propName] != null)
      this._overwriteProps = [];
    else
      for (k = j.length; --k > -1; )
        A[j[k]] != null && j.splice(k, 1);
    for (; q; )
      A[q.n] != null && (q._next && (q._next._prev = q._prev), q._prev ? (q._prev._next = q._next, q._prev = null) : this._firstPT === q && (this._firstPT = q._next)), q = q._next;
    return !1;
  }, nt._mod = nt._roundProps = function(A) {
    for (var k, j = this._firstPT; j; )
      k = A[this._propName] || j.n != null && A[j.n.split(this._propName + "_").join("")], k && typeof k == "function" && (j.f === 2 ? j.t._applyPT.m = k : j.m = k), j = j._next;
  }, ie._onPluginEvent = function(A, k) {
    var j, q, ht, Lt, Gt, Pt = k._firstPT;
    if (A === "_onInitAllProps") {
      for (; Pt; ) {
        for (Gt = Pt._next, q = ht; q && q.pr > Pt.pr; )
          q = q._next;
        (Pt._prev = q ? q._prev : Lt) ? Pt._prev._next = Pt : ht = Pt, (Pt._next = q) ? q._prev = Pt : Lt = Pt, Pt = Gt;
      }
      Pt = k._firstPT = ht;
    }
    for (; Pt; )
      Pt.pg && typeof Pt.t[A] == "function" && Pt.t[A]() && (j = !0), Pt = Pt._next;
    return j;
  }, Ni.activate = function(A) {
    for (var k = A.length; --k > -1; )
      A[k].API === Ni.API && (ii[new A[k]()._propName] = A[k]);
    return !0;
  }, B.plugin = function(A) {
    if (!(A && A.propName && A.init && A.API))
      throw "illegal plugin definition.";
    var k, j = A.propName, q = A.priority || 0, ht = A.overwriteProps, Lt = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    }, Gt = E(
      "plugins." + j.charAt(0).toUpperCase() + j.substr(1) + "Plugin",
      function() {
        Ni.call(this, j, q), this._overwriteProps = ht || [];
      },
      A.global === !0
    ), Pt = Gt.prototype = new Ni(j);
    Pt.constructor = Gt, Gt.API = A.API;
    for (k in Lt)
      typeof A[k] == "function" && (Pt[Lt[k]] = A[k]);
    return Gt.version = A.version, Ni.activate([Gt]), Gt;
  }, Mt = g._gsQueue) {
    for (kt = 0; kt < Mt.length; kt++)
      Mt[kt]();
    for (nt in _)
      _[nt].func || g.console.log("GSAP encountered missing dependency: " + nt);
  }
  Rt = !1;
}(
  typeof module < "u" && module.exports && typeof global < "u" ? global : globalThis || window,
  "TweenMax"
);
const zm = { class: "modal-background" }, Nm = ["innerHTML"], Bm = {
  name: "MapModali"
}, Um = /* @__PURE__ */ Uh({
  ...Bm,
  props: {
    // text: {
    //   type: String,
    //   default: "CHBIM云平台",
    // },
  },
  setup(g, { expose: $ }) {
    const y = Bh(""), pt = Bh(""), gt = (Mt) => {
      pt.value = Mt, y.value = "five";
    }, S = () => {
      y.value = y.value + " out";
    };
    return Fh(() => {
    }), $({
      text: pt,
      show: gt,
      hide: S
    }), (Mt, kt) => (oh(), sh("div", {
      id: "modal-container",
      class: Bu(y.value),
      onClick: S
    }, [
      rr("div", zm, [
        rr("div", {
          class: "modal",
          onClick: kt[0] || (kt[0] = (nt) => {
            nt.stopPropagation();
          })
        }, [
          rr("p", {
            style: { "white-space": "pre-line", "line-height": "1", margin: "0", color: "#fff" },
            innerHTML: pt.value
          }, null, 8, Nm)
        ])
      ])
    ], 2));
  }
});
const Fm = { class: "bim_background_plate" }, Gm = { class: "content" }, Hm = /* @__PURE__ */ rr("canvas", { class: "landscape" }, null, -1), km = { class: "content__title" }, Vm = /* @__PURE__ */ rr("div", { class: "overlay" }, null, -1), Wm = {
  name: "BimBackgroundPlate"
}, jm = /* @__PURE__ */ Uh({
  ...Wm,
  setup(g) {
    const $ = () => {
      let gt = `
          vec3 mod289(vec3 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 mod289(vec4 x)
          {
          	return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 permute(vec4 x)
          {
          	return mod289(((x*34.0)+1.0)*x);
          }

          vec4 taylorInvSqrt(vec4 r)
          {
          	return 1.79284291400159 - 0.85373472095314 * r;
          }

          vec3 fade(vec3 t) {
          	return t*t*t*(t*(t*6.0-15.0)+10.0);
          }

          // Classic Perlin noise
          float cnoise(vec3 P)
          {
          	vec3 Pi0 = floor(P); // Integer part for indexing
          	vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          // Classic Perlin noise, periodic variant
          float pnoise(vec3 P, vec3 rep)
          {
          	vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
          	vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
          	Pi0 = mod289(Pi0);
          	Pi1 = mod289(Pi1);
          	vec3 Pf0 = fract(P); // Fractional part for interpolation
          	vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
          	vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
          	vec4 iy = vec4(Pi0.yy, Pi1.yy);
          	vec4 iz0 = Pi0.zzzz;
          	vec4 iz1 = Pi1.zzzz;

          	vec4 ixy = permute(permute(ix) + iy);
          	vec4 ixy0 = permute(ixy + iz0);
          	vec4 ixy1 = permute(ixy + iz1);

          	vec4 gx0 = ixy0 * (1.0 / 7.0);
          	vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
          	gx0 = fract(gx0);
          	vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
          	vec4 sz0 = step(gz0, vec4(0.0));
          	gx0 -= sz0 * (step(0.0, gx0) - 0.5);
          	gy0 -= sz0 * (step(0.0, gy0) - 0.5);

          	vec4 gx1 = ixy1 * (1.0 / 7.0);
          	vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
          	gx1 = fract(gx1);
          	vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
          	vec4 sz1 = step(gz1, vec4(0.0));
          	gx1 -= sz1 * (step(0.0, gx1) - 0.5);
          	gy1 -= sz1 * (step(0.0, gy1) - 0.5);

          	vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
          	vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
          	vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
          	vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
          	vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
          	vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
          	vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
          	vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

          	vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
          	g000 *= norm0.x;
          	g010 *= norm0.y;
          	g100 *= norm0.z;
          	g110 *= norm0.w;
          	vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
          	g001 *= norm1.x;
          	g011 *= norm1.y;
          	g101 *= norm1.z;
          	g111 *= norm1.w;

          	float n000 = dot(g000, Pf0);
          	float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
          	float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
          	float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
          	float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
          	float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
          	float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
          	float n111 = dot(g111, Pf1);

          	vec3 fade_xyz = fade(Pf0);
          	vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
          	vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
          	float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
          	return 2.2 * n_xyz;
          }

          #define PI 3.1415926535897932384626433832795

          uniform float time;
          uniform float scroll;
          uniform float maxHeight;
          uniform float speed;
          uniform float distortCenter;
          uniform float roadWidth;
          varying float vDisplace;

          varying float fogDepth;

          void main(){

          	float t = time * speed;
          	float wRoad = distortCenter;
          	float wRoad2 = wRoad * 0.5;

          	float angleCenter = uv.y * PI*4.0;
          	angleCenter += t * 0.9;

          	float centerOff = (
          		sin(angleCenter) +
          		sin(angleCenter*0.5)
          	) * wRoad;


          	vec3 noiseIn = vec3(uv, 1.0)*10.0;
          	float noise = cnoise(vec3(noiseIn.x, noiseIn.y + scroll, noiseIn.z));
          	noise += 1.0;
          	float h = noise;
          	float angle = (uv.x - centerOff) * PI;
          	float f = abs(cos(angle));
          	h *= pow(f, 1.5 + roadWidth);


          	vDisplace = h;


          	h*=maxHeight;

          	vec3 transformed = vec3( position.x, position.y, position.z + h );


          	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
          	gl_Position = projectionMatrix * mvPosition;

          	fogDepth = -mvPosition.z;

          }
`, S = `
   uniform float time;
          uniform vec3 color;
          uniform sampler2D pallete;
          varying float vDisplace;

          uniform vec3 fogColor;
          uniform float fogNear;
          uniform float fogFar;
          varying float fogDepth;

          void main(){

          	vec2 stripPos = vec2( 0.0, vDisplace * (sin(time)*0.5+0.7) );
          	vec4 stripColor = texture2D( pallete, stripPos );
          	stripColor *= pow(1.0-vDisplace, 1.0);

          	gl_FragColor = stripColor;

          	#ifdef USE_FOG
          		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
          		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
          	#endif
          }`;
      var Mt = document.querySelector(".landscape"), kt = window.innerWidth, nt = window.innerHeight, Tt, Rt, vt, Nt, Ut = { x: 0, y: 0, xDamped: 0, yDamped: 0 }, Ct = typeof window.orientation < "u";
      at();
      function at() {
        Y(), _(), x(), z(), Ct ? window.addEventListener("touchmove", Z, { passive: !1 }) : window.addEventListener("mousemove", Z), window.addEventListener("resize", E), E();
      }
      function Y() {
        Tt = new THREE.Scene();
        var _t = new THREE.Color(3355443);
        Tt.background = _t, Tt.fog = new THREE.Fog(_t, 0, 400), B(), vt = new THREE.PerspectiveCamera(60, kt / nt, 0.1, 1e4), vt.position.y = 8, vt.position.z = 4;
        let dt = new THREE.AmbientLight(16777215, 1);
        Tt.add(dt), Rt = new THREE.WebGLRenderer({
          canvas: Mt,
          antialias: !0
        }), Rt.setPixelRatio = devicePixelRatio, Rt.setSize(kt, nt);
      }
      function _() {
        var _t = new THREE.PlaneBufferGeometry(100, 400, 400, 400), dt = {
          time: { type: "f", value: 0 },
          scroll: { type: "f", value: 0 },
          distortCenter: { type: "f", value: 0.1 },
          roadWidth: { type: "f", value: 0.5 },
          pallete: { type: "t", value: null },
          speed: { type: "f", value: 3 },
          maxHeight: { type: "f", value: 10 },
          color: new THREE.Color(1, 1, 1)
        }, zt = new THREE.ShaderMaterial({
          uniforms: THREE.UniformsUtils.merge([
            THREE.ShaderLib.basic.uniforms,
            dt
          ]),
          vertexShader: gt,
          fragmentShader: S,
          wireframe: !1,
          fog: !0
        });
        Nt = new THREE.Mesh(_t, zt), Nt.position.z = -180, Nt.rotation.x = -Math.PI / 2, Tt.add(Nt);
      }
      function x() {
        new THREE.TextureLoader().load("", function(_t) {
          Nt.material.uniforms.pallete.value = _t, Nt.material.needsUpdate = !0;
        });
      }
      function B() {
        B = new THREE.Sky(), B.scale.setScalar(45e4), B.material.uniforms.turbidity.value = 13, B.material.uniforms.rayleigh.value = 1.2, B.material.uniforms.luminance.value = 1, B.material.uniforms.mieCoefficient.value = 0.1, B.material.uniforms.mieDirectionalG.value = 0.58, Tt.add(B);
        let _t = new THREE.Mesh(
          new THREE.SphereBufferGeometry(2e4, 16, 8),
          new THREE.MeshBasicMaterial({ color: 16777215 })
        );
        _t.visible = !1, Tt.add(_t);
        var dt = Math.PI * -2e-3, zt = 2 * Math.PI * -0.25;
        _t.position.x = 4e5 * Math.cos(zt), _t.position.y = 4e5 * Math.sin(zt) * Math.sin(dt), _t.position.z = 4e5 * Math.sin(zt) * Math.cos(dt), B.material.uniforms.sunPosition.value.copy(_t.position);
      }
      function E() {
        kt = window.innerWidth, nt = window.innerHeight, vt.aspect = kt / nt, vt.updateProjectionMatrix(), Rt.setSize(kt, nt);
      }
      function Z(_t) {
        _t.preventDefault();
        var dt, zt;
        _t.type == "mousemove" ? (dt = _t.clientX, zt = _t.clientY) : (dt = _t.changedTouches[0].clientX, zt = _t.changedTouches[0].clientY), Ut.x = dt, Ut.y = zt;
      }
      function z() {
        requestAnimationFrame(z), Ut.xDamped = it(Ut.xDamped, Ut.x, 0.1), Ut.yDamped = it(Ut.yDamped, Ut.y, 0.1);
        var _t = performance.now() * 1e-3;
        Nt.material.uniforms.time.value = _t, Nt.material.uniforms.scroll.value = _t + X(Ut.yDamped, 0, nt, 0, 4), Nt.material.uniforms.distortCenter.value = Math.sin(_t) * 0.1, Nt.material.uniforms.roadWidth.value = X(
          Ut.xDamped,
          0,
          kt,
          1,
          4.5
        ), vt.position.y = X(Ut.yDamped, 0, nt, 4, 11), Rt.render(Tt, vt);
      }
      function X(_t, dt, zt, Yt, re) {
        return Yt + (re - Yt) * ((_t - dt) / (zt - dt));
      }
      function it(_t, dt, zt) {
        return (1 - zt) * _t + zt * dt;
      }
    }, y = () => {
      const gt = document.querySelector(".overlay"), S = document.querySelector(".content__title");
      charming(S);
      const Mt = Array.from(S.querySelectorAll("span"));
      TweenMax.to(gt, 2, {
        ease: Quad.easeOut,
        opacity: 0
      }), TweenMax.set(Mt, { opacity: 0 }), TweenMax.staggerTo(
        Mt,
        1.5,
        {
          ease: Expo.easeOut,
          startAt: { rotationX: -100, z: -1e3 },
          opacity: 1,
          rotationX: 0,
          z: 0
        },
        0.1
      );
    }, pt = () => {
      $(), y();
    };
    return Fh(() => {
      pt();
    }), (gt, S) => (oh(), sh("div", Fm, [
      rr("div", Gm, [
        Hm,
        rr("h2", km, [
          Uu(gt.$slots, "default")
        ])
      ]),
      Vm
    ]));
  }
});
(function(g, $) {
  typeof exports == "object" && typeof module < "u" ? $(exports) : typeof define == "function" && define.amd ? define(["exports"], $) : $(g.THREE = {});
})(window, function(g) {
  function $() {
  }
  function y(t, e) {
    this.x = t || 0, this.y = e || 0;
  }
  function pt() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function gt(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = n !== void 0 ? n : 1;
  }
  function S(t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0;
  }
  function Mt() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error(
      "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
    );
  }
  function kt(t, e, i, n, o, s, l, h, c, p) {
    Object.defineProperty(this, "id", { value: Jo++ }), this.uuid = Je.generateUUID(), this.name = "", this.image = t !== void 0 ? t : kt.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = e !== void 0 ? e : kt.DEFAULT_MAPPING, this.wrapS = i !== void 0 ? i : 1001, this.wrapT = n !== void 0 ? n : 1001, this.magFilter = o !== void 0 ? o : 1006, this.minFilter = s !== void 0 ? s : 1008, this.anisotropy = c !== void 0 ? c : 1, this.format = l !== void 0 ? l : 1023, this.type = h !== void 0 ? h : 1009, this.offset = new y(0, 0), this.repeat = new y(1, 1), this.center = new y(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Mt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = p !== void 0 ? p : 3e3, this.version = 0, this.onUpdate = null;
  }
  function nt(t, e, i, n) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n !== void 0 ? n : 1;
  }
  function Tt(t, e, i) {
    this.width = t, this.height = e, this.scissor = new nt(0, 0, t, e), this.scissorTest = !1, this.viewport = new nt(0, 0, t, e), i = i || {}, i.minFilter === void 0 && (i.minFilter = 1006), this.texture = new kt(
      void 0,
      void 0,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    ), this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !0, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !0, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null;
  }
  function Rt(t, e, i) {
    Tt.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0;
  }
  function vt(t, e, i, n, o, s, l, h, c, p, f, d) {
    kt.call(this, null, s, l, h, c, p, n, o, f, d), this.image = { data: t, width: e, height: i }, this.magFilter = c !== void 0 ? c : 1003, this.minFilter = p !== void 0 ? p : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1;
  }
  function Nt(t, e) {
    this.min = t !== void 0 ? t : new S(1 / 0, 1 / 0, 1 / 0), this.max = e !== void 0 ? e : new S(-1 / 0, -1 / 0, -1 / 0);
  }
  function Ut(t, e) {
    this.center = t !== void 0 ? t : new S(), this.radius = e !== void 0 ? e : 0;
  }
  function Ct(t, e) {
    this.normal = t !== void 0 ? t : new S(1, 0, 0), this.constant = e !== void 0 ? e : 0;
  }
  function at(t, e, i, n, o, s) {
    this.planes = [
      t !== void 0 ? t : new Ct(),
      e !== void 0 ? e : new Ct(),
      i !== void 0 ? i : new Ct(),
      n !== void 0 ? n : new Ct(),
      o !== void 0 ? o : new Ct(),
      s !== void 0 ? s : new Ct()
    ];
  }
  function Y(t, e, i) {
    return e === void 0 && i === void 0 ? this.set(t) : this.setRGB(t, e, i);
  }
  function _() {
    function t(o, s) {
      i !== !1 && (n(o, s), e.requestAnimationFrame(t));
    }
    var e = null, i = !1, n = null;
    return {
      start: function() {
        i !== !0 && n !== null && (e.requestAnimationFrame(t), i = !0);
      },
      stop: function() {
        i = !1;
      },
      setAnimationLoop: function(o) {
        n = o;
      },
      setContext: function(o) {
        e = o;
      }
    };
  }
  function x(t) {
    function e(n, o) {
      var s = n.array, l = n.dynamic ? 35048 : 35044, h = t.createBuffer();
      return t.bindBuffer(o, h), t.bufferData(o, s, l), n.onUploadCallback(), o = 5126, s instanceof Float32Array ? o = 5126 : s instanceof Float64Array ? console.warn(
        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
      ) : s instanceof Uint16Array ? o = 5123 : s instanceof Int16Array ? o = 5122 : s instanceof Uint32Array ? o = 5125 : s instanceof Int32Array ? o = 5124 : s instanceof Int8Array ? o = 5120 : s instanceof Uint8Array && (o = 5121), {
        buffer: h,
        type: o,
        bytesPerElement: s.BYTES_PER_ELEMENT,
        version: n.version
      };
    }
    var i = /* @__PURE__ */ new WeakMap();
    return {
      get: function(n) {
        return n.isInterleavedBufferAttribute && (n = n.data), i.get(n);
      },
      remove: function(n) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var o = i.get(n);
        o && (t.deleteBuffer(o.buffer), i.delete(n));
      },
      update: function(n, o) {
        n.isInterleavedBufferAttribute && (n = n.data);
        var s = i.get(n);
        if (s === void 0)
          i.set(n, e(n, o));
        else if (s.version < n.version) {
          var l = n, h = l.array, c = l.updateRange;
          t.bindBuffer(o, s.buffer), l.dynamic === !1 ? t.bufferData(o, h, 35044) : c.count === -1 ? t.bufferSubData(o, 0, h) : c.count === 0 ? console.error(
            "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
          ) : (t.bufferSubData(
            o,
            c.offset * h.BYTES_PER_ELEMENT,
            h.subarray(c.offset, c.offset + c.count)
          ), c.count = -1), s.version = n.version;
        }
      }
    };
  }
  function B(t, e, i, n, o, s) {
    this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new S(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new Y(), this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = s !== void 0 ? s : 0;
  }
  function E(t, e, i, n) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || E.DefaultOrder;
  }
  function Z() {
    this.mask = 1;
  }
  function z() {
    Object.defineProperty(this, "id", { value: hh++ }), this.uuid = Je.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = z.DefaultUp.clone();
    var t = new S(), e = new E(), i = new gt(), n = new S(1, 1, 1);
    e.onChange(function() {
      i.setFromEuler(e, !1);
    }), i.onChange(function() {
      e.setFromQuaternion(i, void 0, !1);
    }), Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: t },
      rotation: { configurable: !0, enumerable: !0, value: e },
      quaternion: { configurable: !0, enumerable: !0, value: i },
      scale: { configurable: !0, enumerable: !0, value: n },
      modelViewMatrix: { value: new pt() },
      normalMatrix: { value: new Mt() }
    }), this.matrix = new pt(), this.matrixWorld = new pt(), this.matrixAutoUpdate = z.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Z(), this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
  }
  function X() {
    Object.defineProperty(this, "id", { value: uh += 2 }), this.uuid = Je.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
  }
  function it(t, e, i) {
    if (Array.isArray(t))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i === !0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function _t(t, e, i) {
    it.call(this, new Int8Array(t), e, i);
  }
  function dt(t, e, i) {
    it.call(this, new Uint8Array(t), e, i);
  }
  function zt(t, e, i) {
    it.call(this, new Uint8ClampedArray(t), e, i);
  }
  function Yt(t, e, i) {
    it.call(this, new Int16Array(t), e, i);
  }
  function re(t, e, i) {
    it.call(this, new Uint16Array(t), e, i);
  }
  function se(t, e, i) {
    it.call(this, new Int32Array(t), e, i);
  }
  function we(t, e, i) {
    it.call(this, new Uint32Array(t), e, i);
  }
  function Et(t, e, i) {
    it.call(this, new Float32Array(t), e, i);
  }
  function ie(t, e, i) {
    it.call(this, new Float64Array(t), e, i);
  }
  function ze() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  }
  function nn(t) {
    if (t.length === 0)
      return -1 / 0;
    for (var e = t[0], i = 1, n = t.length; i < n; ++i)
      t[i] > e && (e = t[i]);
    return e;
  }
  function Ft() {
    Object.defineProperty(this, "id", { value: ch += 2 }), this.uuid = Je.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  function $e(t, e, i, n, o, s) {
    X.call(this), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: o,
      depthSegments: s
    }, this.fromBufferGeometry(new Oi(t, e, i, n, o, s)), this.mergeVertices();
  }
  function Oi(t, e, i, n, o, s) {
    function l(P, R, I, Q, W, st, K, wt, C, D, ct) {
      var Dt = st / C, bt = K / D, St = st / 2, oe = K / 2, $t = wt / 2;
      K = C + 1;
      var me = D + 1, ue = st = 0, Wt, Ee, Be = new S();
      for (Ee = 0; Ee < me; Ee++) {
        var Ye = Ee * bt - oe;
        for (Wt = 0; Wt < K; Wt++)
          Be[P] = (Wt * Dt - St) * Q, Be[R] = Ye * W, Be[I] = $t, p.push(Be.x, Be.y, Be.z), Be[P] = 0, Be[R] = 0, Be[I] = 0 < wt ? 1 : -1, f.push(Be.x, Be.y, Be.z), d.push(Wt / C), d.push(1 - Ee / D), st += 1;
      }
      for (Ee = 0; Ee < D; Ee++)
        for (Wt = 0; Wt < C; Wt++)
          P = v + Wt + K * (Ee + 1), R = v + (Wt + 1) + K * (Ee + 1), I = v + (Wt + 1) + K * Ee, c.push(v + Wt + K * Ee, P, I), c.push(P, R, I), ue += 6;
      h.addGroup(w, ue, ct), w += ue, v += st;
    }
    Ft.call(this), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: n,
      heightSegments: o,
      depthSegments: s
    };
    var h = this;
    t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, s = Math.floor(s) || 1;
    var c = [], p = [], f = [], d = [], v = 0, w = 0;
    l("z", "y", "x", -1, -1, i, e, t, s, o, 0), l("z", "y", "x", 1, -1, i, e, -t, s, o, 1), l("x", "z", "y", 1, 1, t, i, e, n, s, 2), l("x", "z", "y", 1, -1, t, i, -e, n, s, 3), l("x", "y", "z", 1, -1, t, e, i, n, o, 4), l("x", "y", "z", -1, -1, t, e, -i, n, o, 5), this.setIndex(c), this.addAttribute("position", new Et(p, 3)), this.addAttribute("normal", new Et(f, 3)), this.addAttribute("uv", new Et(d, 2));
  }
  function En(t, e, i, n) {
    X.call(this), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, this.fromBufferGeometry(new Yi(t, e, i, n)), this.mergeVertices();
  }
  function Yi(t, e, i, n) {
    Ft.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: n
    }, t = t || 1, e = e || 1;
    var o = t / 2, s = e / 2;
    i = Math.floor(i) || 1, n = Math.floor(n) || 1;
    var l = i + 1, h = n + 1, c = t / i, p = e / n, f = [], d = [], v = [], w = [];
    for (t = 0; t < h; t++) {
      var P = t * p - s;
      for (e = 0; e < l; e++)
        d.push(e * c - o, -P, 0), v.push(0, 0, 1), w.push(e / i), w.push(1 - t / n);
    }
    for (t = 0; t < n; t++)
      for (e = 0; e < i; e++)
        o = e + l * (t + 1), s = e + 1 + l * (t + 1), h = e + 1 + l * t, f.push(e + l * t, o, h), f.push(o, s, h);
    this.setIndex(f), this.addAttribute("position", new Et(d, 3)), this.addAttribute("normal", new Et(v, 3)), this.addAttribute("uv", new Et(w, 2));
  }
  function Oe() {
    Object.defineProperty(this, "id", { value: Nl++ }), this.uuid = Je.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0;
  }
  function Ai(t) {
    Oe.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, t !== void 0 && (t.attributes !== void 0 && console.error(
      "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
    ), this.setValues(t));
  }
  function bn(t, e) {
    this.origin = t !== void 0 ? t : new S(), this.direction = e !== void 0 ? e : new S();
  }
  function ii(t, e, i) {
    this.a = t !== void 0 ? t : new S(), this.b = e !== void 0 ? e : new S(), this.c = i !== void 0 ? i : new S();
  }
  function ui(t) {
    Oe.call(this), this.type = "MeshBasicMaterial", this.color = new Y(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Ui(t, e) {
    z.call(this), this.type = "Mesh", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new ui({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets();
  }
  function vr(t, e, i, n) {
    function o(p, f) {
      e.buffers.color.setClear(p.r, p.g, p.b, f, n);
    }
    var s = new Y(0), l = 0, h, c;
    return {
      getClearColor: function() {
        return s;
      },
      setClearColor: function(p, f) {
        s.set(p), l = f !== void 0 ? f : 1, o(s, l);
      },
      getClearAlpha: function() {
        return l;
      },
      setClearAlpha: function(p) {
        l = p, o(s, l);
      },
      render: function(p, f, d, v) {
        f = f.background, f === null ? o(s, l) : f && f.isColor && (o(f, 1), v = !0), (t.autoClear || v) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.isWebGLRenderTargetCube) ? (c === void 0 && (c = new Ui(
          new Oi(1, 1, 1),
          new Ai({
            type: "BackgroundCubeMaterial",
            uniforms: vn.clone(Hr.cube.uniforms),
            vertexShader: Hr.cube.vertexShader,
            fragmentShader: Hr.cube.fragmentShader,
            side: 1,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), c.geometry.removeAttribute("normal"), c.geometry.removeAttribute("uv"), c.onBeforeRender = function(w, P, R) {
          this.matrixWorld.copyPosition(R.matrixWorld);
        }, i.update(c)), c.material.uniforms.tCube.value = f.isWebGLRenderTargetCube ? f.texture : f, c.material.uniforms.tFlip.value = f.isWebGLRenderTargetCube ? 1 : -1, p.push(c, c.geometry, c.material, 0, null)) : f && f.isTexture && (h === void 0 && (h = new Ui(
          new Yi(2, 2),
          new Ai({
            type: "BackgroundMaterial",
            uniforms: vn.clone(Hr.background.uniforms),
            vertexShader: Hr.background.vertexShader,
            fragmentShader: Hr.background.fragmentShader,
            side: 0,
            depthTest: !0,
            depthWrite: !1,
            fog: !1
          })
        ), h.geometry.removeAttribute("normal"), i.update(h)), h.material.uniforms.t2D.value = f, f.matrixAutoUpdate === !0 && f.updateMatrix(), h.material.uniforms.uvTransform.value.copy(f.matrix), p.push(h, h.geometry, h.material, 0, null));
      }
    };
  }
  function Pr(t, e, i, n) {
    var o;
    this.setMode = function(s) {
      o = s;
    }, this.render = function(s, l) {
      t.drawArrays(o, s, l), i.update(l, o);
    }, this.renderInstances = function(s, l, h) {
      if (n.isWebGL2)
        var c = t;
      else if (c = e.get("ANGLE_instanced_arrays"), c === null) {
        console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](
        o,
        l,
        h,
        s.maxInstancedCount
      ), i.update(h, o, s.maxInstancedCount);
    };
  }
  function Zn(t, e, i) {
    function n(Q) {
      if (Q === "highp") {
        if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision)
          return "highp";
        Q = "mediump";
      }
      return Q === "mediump" && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var o, s = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext, l = i.precision !== void 0 ? i.precision : "highp", h = n(l);
    h !== l && (console.warn(
      "THREE.WebGLRenderer:",
      l,
      "not supported, using",
      h,
      "instead."
    ), l = h), i = i.logarithmicDepthBuffer === !0, h = t.getParameter(34930);
    var c = t.getParameter(35660), p = t.getParameter(3379), f = t.getParameter(34076), d = t.getParameter(34921), v = t.getParameter(36347), w = t.getParameter(36348), P = t.getParameter(36349), R = 0 < c, I = s || !!e.get("OES_texture_float");
    return {
      isWebGL2: s,
      getMaxAnisotropy: function() {
        if (o !== void 0)
          return o;
        var Q = e.get("EXT_texture_filter_anisotropic");
        return o = Q !== null ? t.getParameter(Q.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      },
      getMaxPrecision: n,
      precision: l,
      logarithmicDepthBuffer: i,
      maxTextures: h,
      maxVertexTextures: c,
      maxTextureSize: p,
      maxCubemapSize: f,
      maxAttributes: d,
      maxVertexUniforms: v,
      maxVaryings: w,
      maxFragmentUniforms: P,
      vertexTextures: R,
      floatFragmentTextures: I,
      floatVertexTextures: R && I
    };
  }
  function Fi() {
    function t() {
      p.value !== n && (p.value = n, p.needsUpdate = 0 < o), i.numPlanes = o, i.numIntersection = 0;
    }
    function e(f, d, v, w) {
      var P = f !== null ? f.length : 0, R = null;
      if (P !== 0) {
        if (R = p.value, w !== !0 || R === null)
          for (w = v + 4 * P, d = d.matrixWorldInverse, c.getNormalMatrix(d), (R === null || R.length < w) && (R = new Float32Array(w)), w = 0; w !== P; ++w, v += 4)
            h.copy(f[w]).applyMatrix4(d, c), h.normal.toArray(R, v), R[v + 3] = h.constant;
        p.value = R, p.needsUpdate = !0;
      }
      return i.numPlanes = P, R;
    }
    var i = this, n = null, o = 0, s = !1, l = !1, h = new Ct(), c = new Mt(), p = { value: null, needsUpdate: !1 };
    this.uniform = p, this.numIntersection = this.numPlanes = 0, this.init = function(f, d, v) {
      var w = f.length !== 0 || d || o !== 0 || s;
      return s = d, n = e(f, v, 0), o = f.length, w;
    }, this.beginShadows = function() {
      l = !0, e(null);
    }, this.endShadows = function() {
      l = !1, t();
    }, this.setState = function(f, d, v, w, P, R) {
      if (!s || f === null || f.length === 0 || l && !v)
        l ? e(null) : t();
      else {
        v = l ? 0 : o;
        var I = 4 * v, Q = P.clippingState || null;
        for (p.value = Q, Q = e(f, w, I, R), f = 0; f !== I; ++f)
          Q[f] = n[f];
        P.clippingState = Q, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += v;
      }
    };
  }
  function Un(t) {
    var e = {};
    return {
      get: function(i) {
        if (e[i] !== void 0)
          return e[i];
        switch (i) {
          case "WEBGL_depth_texture":
            var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = t.getExtension(i);
        }
        return n === null && console.warn(
          "THREE.WebGLRenderer: " + i + " extension not supported."
        ), e[i] = n;
      }
    };
  }
  function rn(t, e, i) {
    function n(l) {
      var h = l.target;
      l = o[h.id], l.index !== null && e.remove(l.index);
      for (var c in l.attributes)
        e.remove(l.attributes[c]);
      h.removeEventListener("dispose", n), delete o[h.id], (c = s[l.id]) && (e.remove(c), delete s[l.id]), i.memory.geometries--;
    }
    var o = {}, s = {};
    return {
      get: function(l, h) {
        var c = o[h.id];
        return c || (h.addEventListener("dispose", n), h.isBufferGeometry ? c = h : h.isGeometry && (h._bufferGeometry === void 0 && (h._bufferGeometry = new Ft().setFromObject(l)), c = h._bufferGeometry), o[h.id] = c, i.memory.geometries++, c);
      },
      update: function(l) {
        var h = l.index, c = l.attributes;
        h !== null && e.update(h, 34963);
        for (var p in c)
          e.update(c[p], 34962);
        l = l.morphAttributes;
        for (p in l) {
          h = l[p], c = 0;
          for (var f = h.length; c < f; c++)
            e.update(h[c], 34962);
        }
      },
      getWireframeAttribute: function(l) {
        var h = s[l.id];
        if (h)
          return h;
        h = [];
        var c = l.index, p = l.attributes;
        if (c !== null) {
          c = c.array, p = 0;
          for (var f = c.length; p < f; p += 3) {
            var d = c[p + 0], v = c[p + 1], w = c[p + 2];
            h.push(d, v, v, w, w, d);
          }
        } else
          for (c = p.position.array, p = 0, f = c.length / 3 - 1; p < f; p += 3)
            d = p + 0, v = p + 1, w = p + 2, h.push(d, v, v, w, w, d);
        return h = new (65535 < nn(h) ? we : re)(h, 1), e.update(h, 34963), s[l.id] = h;
      }
    };
  }
  function Ze(t, e, i, n) {
    var o, s, l;
    this.setMode = function(h) {
      o = h;
    }, this.setIndex = function(h) {
      s = h.type, l = h.bytesPerElement;
    }, this.render = function(h, c) {
      t.drawElements(o, c, s, h * l), i.update(c, o);
    }, this.renderInstances = function(h, c, p) {
      if (n.isWebGL2)
        var f = t;
      else if (f = e.get("ANGLE_instanced_arrays"), f === null) {
        console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      f[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](
        o,
        p,
        s,
        c * l,
        h.maxInstancedCount
      ), i.update(p, o, h.maxInstancedCount);
    };
  }
  function _n(t) {
    var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function() {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      },
      update: function(i, n, o) {
        switch (o = o || 1, e.calls++, n) {
          case 4:
            e.triangles += i / 3 * o;
            break;
          case 5:
          case 6:
            e.triangles += o * (i - 2);
            break;
          case 1:
            e.lines += i / 2 * o;
            break;
          case 3:
            e.lines += o * (i - 1);
            break;
          case 2:
            e.lines += o * i;
            break;
          case 0:
            e.points += o * i;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      }
    };
  }
  function lo(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function Fn(t) {
    var e = {}, i = new Float32Array(8);
    return {
      update: function(n, o, s, l) {
        var h = n.morphTargetInfluences, c = h.length;
        if (n = e[o.id], n === void 0) {
          n = [];
          for (var p = 0; p < c; p++)
            n[p] = [p, 0];
          e[o.id] = n;
        }
        var f = s.morphTargets && o.morphAttributes.position;
        for (s = s.morphNormals && o.morphAttributes.normal, p = 0; p < c; p++) {
          var d = n[p];
          d[1] !== 0 && (f && o.removeAttribute("morphTarget" + p), s && o.removeAttribute("morphNormal" + p));
        }
        for (p = 0; p < c; p++)
          d = n[p], d[0] = p, d[1] = h[p];
        for (n.sort(lo), p = 0; 8 > p; p++) {
          if ((d = n[p]) && (h = d[0], c = d[1])) {
            f && o.addAttribute("morphTarget" + p, f[h]), s && o.addAttribute("morphNormal" + p, s[h]), i[p] = c;
            continue;
          }
          i[p] = 0;
        }
        l.getUniforms().setValue(t, "morphTargetInfluences", i);
      }
    };
  }
  function Ni(t, e) {
    var i = {};
    return {
      update: function(n) {
        var o = e.render.frame, s = n.geometry, l = t.get(n, s);
        return i[l.id] !== o && (s.isGeometry && l.updateFromObject(n), t.update(l), i[l.id] = o), l;
      },
      dispose: function() {
        i = {};
      }
    };
  }
  function A(t, e, i, n, o, s, l, h, c, p) {
    t = t !== void 0 ? t : [], kt.call(this, t, e !== void 0 ? e : 301, i, n, o, s, l, h, c, p), this.flipY = !1;
  }
  function k(t, e, i, n) {
    kt.call(this, null), this.image = { data: t, width: e, height: i, depth: n }, this.minFilter = this.magFilter = 1003, this.flipY = this.generateMipmaps = !1;
  }
  function j(t, e, i) {
    var n = t[0];
    if (0 >= n || 0 < n)
      return t;
    var o = e * i, s = Fa[o];
    if (s === void 0 && (s = new Float32Array(o), Fa[o] = s), e !== 0)
      for (n.toArray(s, 0), n = 1, o = 0; n !== e; ++n)
        o += i, t[n].toArray(s, o);
    return s;
  }
  function q(t, e) {
    if (t.length !== e.length)
      return !1;
    for (var i = 0, n = t.length; i < n; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  function ht(t, e) {
    for (var i = 0, n = e.length; i < n; i++)
      t[i] = e[i];
  }
  function Lt(t, e) {
    var i = Is[e];
    i === void 0 && (i = new Int32Array(e), Is[e] = i);
    for (var n = 0; n !== e; ++n)
      i[n] = t.allocTextureUnit();
    return i;
  }
  function Gt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e);
  }
  function Pt(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e);
  }
  function Ae(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : q(i, e) || (t.uniform2fv(this.addr, e), ht(i, e));
  }
  function Se(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : e.r !== void 0 ? (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : q(i, e) || (t.uniform3fv(this.addr, e), ht(i, e));
  }
  function te(t, e) {
    var i = this.cache;
    e.x !== void 0 ? (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : q(i, e) || (t.uniform4fv(this.addr, e), ht(i, e));
  }
  function Pe(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? q(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), ht(i, e)) : q(i, n) || (pl.set(n), t.uniformMatrix2fv(this.addr, !1, pl), ht(i, n));
  }
  function ci(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? q(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), ht(i, e)) : q(i, n) || (Ul.set(n), t.uniformMatrix3fv(this.addr, !1, Ul), ht(i, n));
  }
  function wi(t, e) {
    var i = this.cache, n = e.elements;
    n === void 0 ? q(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), ht(i, e)) : q(i, n) || (fa.set(n), t.uniformMatrix4fv(this.addr, !1, fa), ht(i, n));
  }
  function Ke(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTexture2D(e || cl, o);
  }
  function mi(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTexture3D(e || ph, o);
  }
  function Yr(t, e, i) {
    var n = this.cache, o = i.allocTextureUnit();
    n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), i.setTextureCube(e || Bl, o);
  }
  function or(t, e) {
    var i = this.cache;
    q(i, e) || (t.uniform2iv(this.addr, e), ht(i, e));
  }
  function Zi(t, e) {
    var i = this.cache;
    q(i, e) || (t.uniform3iv(this.addr, e), ht(i, e));
  }
  function os(t, e) {
    var i = this.cache;
    q(i, e) || (t.uniform4iv(this.addr, e), ht(i, e));
  }
  function Ii(t) {
    switch (t) {
      case 5126:
        return Gt;
      case 35664:
        return Ae;
      case 35665:
        return Se;
      case 35666:
        return te;
      case 35674:
        return Pe;
      case 35675:
        return ci;
      case 35676:
        return wi;
      case 35678:
      case 36198:
        return Ke;
      case 35679:
        return mi;
      case 35680:
        return Yr;
      case 5124:
      case 35670:
        return Pt;
      case 35667:
      case 35671:
        return or;
      case 35668:
      case 35672:
        return Zi;
      case 35669:
      case 35673:
        return os;
    }
  }
  function Za(t, e) {
    var i = this.cache;
    q(i, e) || (t.uniform1fv(this.addr, e), ht(i, e));
  }
  function Lr(t, e) {
    var i = this.cache;
    q(i, e) || (t.uniform1iv(this.addr, e), ht(i, e));
  }
  function wa(t, e) {
    var i = this.cache;
    e = j(e, this.size, 2), q(i, e) || (t.uniform2fv(this.addr, e), this.updateCache(e));
  }
  function on(t, e) {
    var i = this.cache;
    e = j(e, this.size, 3), q(i, e) || (t.uniform3fv(this.addr, e), this.updateCache(e));
  }
  function ss(t, e) {
    var i = this.cache;
    e = j(e, this.size, 4), q(i, e) || (t.uniform4fv(this.addr, e), this.updateCache(e));
  }
  function Po(t, e) {
    var i = this.cache;
    e = j(e, this.size, 4), q(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), this.updateCache(e));
  }
  function Jn(t, e) {
    var i = this.cache;
    e = j(e, this.size, 9), q(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), this.updateCache(e));
  }
  function as(t, e) {
    var i = this.cache;
    e = j(e, this.size, 16), q(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), this.updateCache(e));
  }
  function Gs(t, e, i) {
    var n = this.cache, o = e.length, s = Lt(i, o);
    for (q(n, s) === !1 && (t.uniform1iv(this.addr, s), ht(n, s)), t = 0; t !== o; ++t)
      i.setTexture2D(e[t] || cl, s[t]);
  }
  function Ma(t, e, i) {
    var n = this.cache, o = e.length, s = Lt(i, o);
    for (q(n, s) === !1 && (t.uniform1iv(this.addr, s), ht(n, s)), t = 0; t !== o; ++t)
      i.setTextureCube(e[t] || Bl, s[t]);
  }
  function Cr(t) {
    switch (t) {
      case 5126:
        return Za;
      case 35664:
        return wa;
      case 35665:
        return on;
      case 35666:
        return ss;
      case 35674:
        return Po;
      case 35675:
        return Jn;
      case 35676:
        return as;
      case 35678:
        return Gs;
      case 35680:
        return Ma;
      case 5124:
      case 35670:
        return Lr;
      case 35667:
      case 35671:
        return or;
      case 35668:
      case 35672:
        return Zi;
      case 35669:
      case 35673:
        return os;
    }
  }
  function Ja(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.setValue = Ii(e.type);
  }
  function ls(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = Cr(e.type);
  }
  function Hs(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  function Rr(t, e, i) {
    this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, 35718);
    for (var n = 0; n < i; ++n) {
      var o = t.getActiveUniform(e, n), s = t.getUniformLocation(e, o.name), l = this, h = o.name, c = h.length;
      for (fl.lastIndex = 0; ; ) {
        var p = fl.exec(h), f = fl.lastIndex, d = p[1], v = p[3];
        if (p[2] === "]" && (d |= 0), v === void 0 || v === "[" && f + 2 === c) {
          h = l, o = v === void 0 ? new Ja(d, o, s) : new ls(d, o, s), h.seq.push(o), h.map[o.id] = o;
          break;
        } else
          v = l.map[d], v === void 0 && (v = new Hs(d), d = l, l = v, d.seq.push(l), d.map[l.id] = l), l = v;
      }
    }
  }
  function ks(t) {
    t = t.split(`
`);
    for (var e = 0; e < t.length; e++)
      t[e] = e + 1 + ": " + t[e];
    return t.join(`
`);
  }
  function hs(t, e, i) {
    var n = t.createShader(e);
    return t.shaderSource(n, i), t.compileShader(n), t.getShaderParameter(n, 35713) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), t.getShaderInfoLog(n) !== "" && console.warn(
      "THREE.WebGLShader: gl.getShaderInfoLog()",
      e === 35633 ? "vertex" : "fragment",
      t.getShaderInfoLog(n),
      ks(i)
    ), n;
  }
  function us(t) {
    switch (t) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw Error("unsupported encoding: " + t);
    }
  }
  function br(t, e) {
    return e = us(e), "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }";
  }
  function Ta(t, e) {
    return e = us(e), "vec4 " + t + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
  }
  function $a(t, e) {
    switch (e) {
      case 1:
        e = "Linear";
        break;
      case 2:
        e = "Reinhard";
        break;
      case 3:
        e = "Uncharted2";
        break;
      case 4:
        e = "OptimizedCineon";
        break;
      default:
        throw Error("unsupported toneMapping: " + e);
    }
    return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
  }
  function Qa(t, e, i) {
    return t = t || {}, [
      t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
      (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
      t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
      (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ].filter(Co).join(`
`);
  }
  function Lo(t) {
    var e = [], i;
    for (i in t) {
      var n = t[i];
      n !== !1 && e.push("#define " + i + " " + n);
    }
    return e.join(`
`);
  }
  function Co(t) {
    return t !== "";
  }
  function Sa(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
  }
  function Ea(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
  }
  function yr(t) {
    return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, i) {
      if (e = li[i], e === void 0)
        throw Error("Can not resolve #include <" + i + ">");
      return yr(e);
    });
  }
  function M(t) {
    return t.replace(
      /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      function(e, i, n, o) {
        for (e = "", i = parseInt(i); i < parseInt(n); i++)
          e += o.replace(/\[ i \]/g, "[ " + i + " ]");
        return e;
      }
    );
  }
  function b(t, e, i, n, o, s, l) {
    var h = t.context, c = n.defines, p = o.vertexShader, f = o.fragmentShader, d = "SHADOWMAP_TYPE_BASIC";
    s.shadowMapType === 1 ? d = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === 2 && (d = "SHADOWMAP_TYPE_PCF_SOFT");
    var v = "ENVMAP_TYPE_CUBE", w = "ENVMAP_MODE_REFLECTION", P = "ENVMAP_BLENDING_MULTIPLY";
    if (s.envMap) {
      switch (n.envMap.mapping) {
        case 301:
        case 302:
          v = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          v = "ENVMAP_TYPE_CUBE_UV";
          break;
        case 303:
        case 304:
          v = "ENVMAP_TYPE_EQUIREC";
          break;
        case 305:
          v = "ENVMAP_TYPE_SPHERE";
      }
      switch (n.envMap.mapping) {
        case 302:
        case 304:
          w = "ENVMAP_MODE_REFRACTION";
      }
      switch (n.combine) {
        case 0:
          P = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          P = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          P = "ENVMAP_BLENDING_ADD";
      }
    }
    var R = 0 < t.gammaFactor ? t.gammaFactor : 1, I = l.isWebGL2 ? "" : Qa(n.extensions, s, e), Q = Lo(c), W = h.createProgram();
    n.isRawShaderMaterial ? (c = [Q].filter(Co).join(`
`), 0 < c.length && (c += `
`), e = [I, Q].filter(Co).join(`
`), 0 < e.length && (e += `
`)) : (c = [
      "precision " + s.precision + " float;",
      "precision " + s.precision + " int;",
      "#define SHADER_NAME " + o.name,
      Q,
      s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + R,
      "#define MAX_BONES " + s.maxBones,
      s.useFog && s.fog ? "#define USE_FOG" : "",
      s.useFog && s.fogExp ? "#define FOG_EXP2" : "",
      s.map ? "#define USE_MAP" : "",
      s.envMap ? "#define USE_ENVMAP" : "",
      s.envMap ? "#define " + w : "",
      s.lightMap ? "#define USE_LIGHTMAP" : "",
      s.aoMap ? "#define USE_AOMAP" : "",
      s.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      s.bumpMap ? "#define USE_BUMPMAP" : "",
      s.normalMap ? "#define USE_NORMALMAP" : "",
      s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      s.specularMap ? "#define USE_SPECULARMAP" : "",
      s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      s.metalnessMap ? "#define USE_METALNESSMAP" : "",
      s.alphaMap ? "#define USE_ALPHAMAP" : "",
      s.vertexColors ? "#define USE_COLOR" : "",
      s.flatShading ? "#define FLAT_SHADED" : "",
      s.skinning ? "#define USE_SKINNING" : "",
      s.useVertexTexture ? "#define BONE_TEXTURE" : "",
      s.morphTargets ? "#define USE_MORPHTARGETS" : "",
      s.morphNormals && s.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
      s.doubleSided ? "#define DOUBLE_SIDED" : "",
      s.flipSided ? "#define FLIP_SIDED" : "",
      s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      s.shadowMapEnabled ? "#define " + d : "",
      s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      s.logarithmicDepthBuffer && (l.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(Co).join(`
`), e = [
      I,
      "precision " + s.precision + " float;",
      "precision " + s.precision + " int;",
      "#define SHADER_NAME " + o.name,
      Q,
      s.alphaTest ? "#define ALPHATEST " + s.alphaTest + (s.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + R,
      s.useFog && s.fog ? "#define USE_FOG" : "",
      s.useFog && s.fogExp ? "#define FOG_EXP2" : "",
      s.map ? "#define USE_MAP" : "",
      s.envMap ? "#define USE_ENVMAP" : "",
      s.envMap ? "#define " + v : "",
      s.envMap ? "#define " + w : "",
      s.envMap ? "#define " + P : "",
      s.lightMap ? "#define USE_LIGHTMAP" : "",
      s.aoMap ? "#define USE_AOMAP" : "",
      s.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      s.bumpMap ? "#define USE_BUMPMAP" : "",
      s.normalMap ? "#define USE_NORMALMAP" : "",
      s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      s.specularMap ? "#define USE_SPECULARMAP" : "",
      s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      s.metalnessMap ? "#define USE_METALNESSMAP" : "",
      s.alphaMap ? "#define USE_ALPHAMAP" : "",
      s.vertexColors ? "#define USE_COLOR" : "",
      s.gradientMap ? "#define USE_GRADIENTMAP" : "",
      s.flatShading ? "#define FLAT_SHADED" : "",
      s.doubleSided ? "#define DOUBLE_SIDED" : "",
      s.flipSided ? "#define FLIP_SIDED" : "",
      s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      s.shadowMapEnabled ? "#define " + d : "",
      s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      s.logarithmicDepthBuffer && (l.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      s.envMap && (l.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      s.toneMapping !== 0 ? "#define TONE_MAPPING" : "",
      s.toneMapping !== 0 ? li.tonemapping_pars_fragment : "",
      s.toneMapping !== 0 ? $a("toneMapping", s.toneMapping) : "",
      s.dithering ? "#define DITHERING" : "",
      s.outputEncoding || s.mapEncoding || s.matcapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? li.encodings_pars_fragment : "",
      s.mapEncoding ? br("mapTexelToLinear", s.mapEncoding) : "",
      s.matcapEncoding ? br("matcapTexelToLinear", s.matcapEncoding) : "",
      s.envMapEncoding ? br("envMapTexelToLinear", s.envMapEncoding) : "",
      s.emissiveMapEncoding ? br("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "",
      s.outputEncoding ? Ta("linearToOutputTexel", s.outputEncoding) : "",
      s.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
      `
`
    ].filter(Co).join(`
`)), p = yr(p), p = Sa(p, s), p = Ea(p, s), f = yr(f), f = Sa(f, s), f = Ea(f, s), p = M(p), f = M(f), l.isWebGL2 && !n.isRawShaderMaterial && (l = !1, d = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && p.match(d) !== null && f.match(d) !== null && (l = !0, p = p.replace(d, ""), f = f.replace(d, "")), c = `#version 300 es

#define attribute in
#define varying out
#define texture2D texture
` + c, e = [
      `#version 300 es

#define varying in`,
      l ? "" : "out highp vec4 pc_fragColor;",
      l ? "" : "#define gl_FragColor pc_fragColor",
      `#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad`
    ].join(`
`) + `
` + e), f = e + f, p = hs(h, 35633, c + p), f = hs(h, 35632, f), h.attachShader(W, p), h.attachShader(W, f), n.index0AttributeName !== void 0 ? h.bindAttribLocation(W, 0, n.index0AttributeName) : s.morphTargets === !0 && h.bindAttribLocation(W, 0, "position"), h.linkProgram(W), s = h.getProgramInfoLog(W).trim(), l = h.getShaderInfoLog(p).trim(), d = h.getShaderInfoLog(f).trim(), w = v = !0, h.getProgramParameter(W, 35714) === !1 ? (v = !1, console.error(
      "THREE.WebGLProgram: shader error: ",
      h.getError(),
      "35715",
      h.getProgramParameter(W, 35715),
      "gl.getProgramInfoLog",
      s,
      l,
      d
    )) : s !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", s) : (l === "" || d === "") && (w = !1), w && (this.diagnostics = {
      runnable: v,
      material: n,
      programLog: s,
      vertexShader: { log: l, prefix: c },
      fragmentShader: { log: d, prefix: e }
    }), h.deleteShader(p), h.deleteShader(f);
    var st;
    this.getUniforms = function() {
      return st === void 0 && (st = new Rr(h, W, t)), st;
    };
    var K;
    return this.getAttributes = function() {
      if (K === void 0) {
        for (var wt = {}, C = h.getProgramParameter(W, 35721), D = 0; D < C; D++) {
          var ct = h.getActiveAttrib(W, D).name;
          wt[ct] = h.getAttribLocation(W, ct);
        }
        K = wt;
      }
      return K;
    }, this.destroy = function() {
      h.deleteProgram(W), this.program = void 0;
    }, Object.defineProperties(this, {
      uniforms: {
        get: function() {
          return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
        }
      },
      attributes: {
        get: function() {
          return console.warn(
            "THREE.WebGLProgram: .attributes is now .getAttributes()."
          ), this.getAttributes();
        }
      }
    }), this.name = o.name, this.id = no++, this.code = i, this.usedTimes = 1, this.program = W, this.vertexShader = p, this.fragmentShader = f, this;
  }
  function U(t, e, i) {
    function n(h, c) {
      if (h)
        h.isTexture ? p = h.encoding : h.isWebGLRenderTarget && (console.warn(
          "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
        ), p = h.texture.encoding);
      else
        var p = 3e3;
      return p === 3e3 && c && (p = 3007), p;
    }
    var o = [], s = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "phong",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    }, l = "precision supportsVertexTextures map mapEncoding matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(
      " "
    );
    this.getParameters = function(h, c, p, f, d, v, w) {
      var P = s[h.type];
      if (w.isSkinnedMesh) {
        var R = w.skeleton.bones;
        if (i.floatVertexTextures)
          R = 1024;
        else {
          var I = Math.min(
            Math.floor((i.maxVertexUniforms - 20) / 4),
            R.length
          );
          I < R.length ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " + R.length + " bones. This GPU supports " + I + "."
          ), R = 0) : R = I;
        }
      } else
        R = 0;
      I = i.precision, h.precision !== null && (I = i.getMaxPrecision(h.precision), I !== h.precision && console.warn(
        "THREE.WebGLProgram.getParameters:",
        h.precision,
        "not supported, using",
        I,
        "instead."
      ));
      var Q = t.getRenderTarget();
      return {
        shaderID: P,
        precision: I,
        supportsVertexTextures: i.vertexTextures,
        outputEncoding: n(Q ? Q.texture : null, t.gammaOutput),
        map: !!h.map,
        mapEncoding: n(h.map, t.gammaInput),
        matcap: !!h.matcap,
        matcapEncoding: n(h.matcap, t.gammaInput),
        envMap: !!h.envMap,
        envMapMode: h.envMap && h.envMap.mapping,
        envMapEncoding: n(h.envMap, t.gammaInput),
        envMapCubeUV: !!h.envMap && (h.envMap.mapping === 306 || h.envMap.mapping === 307),
        lightMap: !!h.lightMap,
        aoMap: !!h.aoMap,
        emissiveMap: !!h.emissiveMap,
        emissiveMapEncoding: n(h.emissiveMap, t.gammaInput),
        bumpMap: !!h.bumpMap,
        normalMap: !!h.normalMap,
        objectSpaceNormalMap: h.normalMapType === 1,
        displacementMap: !!h.displacementMap,
        roughnessMap: !!h.roughnessMap,
        metalnessMap: !!h.metalnessMap,
        specularMap: !!h.specularMap,
        alphaMap: !!h.alphaMap,
        gradientMap: !!h.gradientMap,
        combine: h.combine,
        vertexColors: h.vertexColors,
        fog: !!f,
        useFog: h.fog,
        fogExp: f && f.isFogExp2,
        flatShading: h.flatShading,
        sizeAttenuation: h.sizeAttenuation,
        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
        skinning: h.skinning && 0 < R,
        maxBones: R,
        useVertexTexture: i.floatVertexTextures,
        morphTargets: h.morphTargets,
        morphNormals: h.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: c.directional.length,
        numPointLights: c.point.length,
        numSpotLights: c.spot.length,
        numRectAreaLights: c.rectArea.length,
        numHemiLights: c.hemi.length,
        numClippingPlanes: d,
        numClipIntersection: v,
        dithering: h.dithering,
        shadowMapEnabled: t.shadowMap.enabled && w.receiveShadow && 0 < p.length,
        shadowMapType: t.shadowMap.type,
        toneMapping: t.toneMapping,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: h.premultipliedAlpha,
        alphaTest: h.alphaTest,
        doubleSided: h.side === 2,
        flipSided: h.side === 1,
        depthPacking: h.depthPacking !== void 0 ? h.depthPacking : !1
      };
    }, this.getProgramCode = function(h, c) {
      var p = [];
      if (c.shaderID ? p.push(c.shaderID) : (p.push(h.fragmentShader), p.push(h.vertexShader)), h.defines !== void 0)
        for (var f in h.defines)
          p.push(f), p.push(h.defines[f]);
      for (f = 0; f < l.length; f++)
        p.push(c[l[f]]);
      return p.push(h.onBeforeCompile.toString()), p.push(t.gammaOutput), p.push(t.gammaFactor), p.join();
    }, this.acquireProgram = function(h, c, p, f) {
      for (var d, v = 0, w = o.length; v < w; v++) {
        var P = o[v];
        if (P.code === f) {
          d = P, ++d.usedTimes;
          break;
        }
      }
      return d === void 0 && (d = new b(t, e, f, h, c, p, i), o.push(d)), d;
    }, this.releaseProgram = function(h) {
      if (--h.usedTimes === 0) {
        var c = o.indexOf(h);
        o[c] = o[o.length - 1], o.pop(), h.destroy();
      }
    }, this.programs = o;
  }
  function N() {
    var t = /* @__PURE__ */ new WeakMap();
    return {
      get: function(e) {
        var i = t.get(e);
        return i === void 0 && (i = {}, t.set(e, i)), i;
      },
      remove: function(e) {
        t.delete(e);
      },
      update: function(e, i, n) {
        t.get(e)[i] = n;
      },
      dispose: function() {
        t = /* @__PURE__ */ new WeakMap();
      }
    };
  }
  function T(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
  }
  function rt(t, e) {
    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
  }
  function F() {
    var t = [], e = 0, i = [], n = [];
    return {
      opaque: i,
      transparent: n,
      init: function() {
        e = 0, i.length = 0, n.length = 0;
      },
      push: function(o, s, l, h, c) {
        var p = t[e];
        p === void 0 ? (p = {
          id: o.id,
          object: o,
          geometry: s,
          material: l,
          program: l.program,
          renderOrder: o.renderOrder,
          z: h,
          group: c
        }, t[e] = p) : (p.id = o.id, p.object = o, p.geometry = s, p.material = l, p.program = l.program, p.renderOrder = o.renderOrder, p.z = h, p.group = c), (l.transparent === !0 ? n : i).push(p), e++;
      },
      sort: function() {
        1 < i.length && i.sort(T), 1 < n.length && n.sort(rt);
      }
    };
  }
  function ut() {
    var t = {};
    return {
      get: function(e, i) {
        return e = e.id + "," + i.id, i = t[e], i === void 0 && (i = new F(), t[e] = i), i;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function xt() {
    var t = {};
    return {
      get: function(e) {
        if (t[e.id] !== void 0)
          return t[e.id];
        switch (e.type) {
          case "DirectionalLight":
            var i = {
              direction: new S(),
              color: new Y(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new y()
            };
            break;
          case "SpotLight":
            i = {
              position: new S(),
              direction: new S(),
              color: new Y(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new y()
            };
            break;
          case "PointLight":
            i = {
              position: new S(),
              color: new Y(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new y(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case "HemisphereLight":
            i = { direction: new S(), skyColor: new Y(), groundColor: new Y() };
            break;
          case "RectAreaLight":
            i = {
              color: new Y(),
              position: new S(),
              halfWidth: new S(),
              halfHeight: new S()
            };
        }
        return t[e.id] = i;
      }
    };
  }
  function ft() {
    var t = new xt(), e = {
      id: dl++,
      hash: {
        stateID: -1,
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        shadowsLength: -1
      },
      ambient: [0, 0, 0],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    }, i = new S(), n = new pt(), o = new pt();
    return {
      setup: function(s, l, h) {
        var c = 0, p = 0, f = 0, d = 0, v = 0, w = 0, P = 0, R = 0;
        h = h.matrixWorldInverse;
        for (var I = 0, Q = s.length; I < Q; I++) {
          var W = s[I], st = W.color, K = W.intensity, wt = W.distance, C = W.shadow && W.shadow.map ? W.shadow.map.texture : null;
          if (W.isAmbientLight)
            c += st.r * K, p += st.g * K, f += st.b * K;
          else if (W.isDirectionalLight) {
            var D = t.get(W);
            D.color.copy(W.color).multiplyScalar(W.intensity), D.direction.setFromMatrixPosition(W.matrixWorld), i.setFromMatrixPosition(W.target.matrixWorld), D.direction.sub(i), D.direction.transformDirection(h), (D.shadow = W.castShadow) && (st = W.shadow, D.shadowBias = st.bias, D.shadowRadius = st.radius, D.shadowMapSize = st.mapSize), e.directionalShadowMap[d] = C, e.directionalShadowMatrix[d] = W.shadow.matrix, e.directional[d] = D, d++;
          } else
            W.isSpotLight ? (D = t.get(W), D.position.setFromMatrixPosition(W.matrixWorld), D.position.applyMatrix4(h), D.color.copy(st).multiplyScalar(K), D.distance = wt, D.direction.setFromMatrixPosition(W.matrixWorld), i.setFromMatrixPosition(W.target.matrixWorld), D.direction.sub(i), D.direction.transformDirection(h), D.coneCos = Math.cos(W.angle), D.penumbraCos = Math.cos(W.angle * (1 - W.penumbra)), D.decay = W.decay, (D.shadow = W.castShadow) && (st = W.shadow, D.shadowBias = st.bias, D.shadowRadius = st.radius, D.shadowMapSize = st.mapSize), e.spotShadowMap[w] = C, e.spotShadowMatrix[w] = W.shadow.matrix, e.spot[w] = D, w++) : W.isRectAreaLight ? (D = t.get(W), D.color.copy(st).multiplyScalar(K), D.position.setFromMatrixPosition(W.matrixWorld), D.position.applyMatrix4(h), o.identity(), n.copy(W.matrixWorld), n.premultiply(h), o.extractRotation(n), D.halfWidth.set(0.5 * W.width, 0, 0), D.halfHeight.set(0, 0.5 * W.height, 0), D.halfWidth.applyMatrix4(o), D.halfHeight.applyMatrix4(o), e.rectArea[P] = D, P++) : W.isPointLight ? (D = t.get(W), D.position.setFromMatrixPosition(W.matrixWorld), D.position.applyMatrix4(h), D.color.copy(W.color).multiplyScalar(W.intensity), D.distance = W.distance, D.decay = W.decay, (D.shadow = W.castShadow) && (st = W.shadow, D.shadowBias = st.bias, D.shadowRadius = st.radius, D.shadowMapSize = st.mapSize, D.shadowCameraNear = st.camera.near, D.shadowCameraFar = st.camera.far), e.pointShadowMap[v] = C, e.pointShadowMatrix[v] = W.shadow.matrix, e.point[v] = D, v++) : W.isHemisphereLight && (D = t.get(W), D.direction.setFromMatrixPosition(W.matrixWorld), D.direction.transformDirection(h), D.direction.normalize(), D.skyColor.copy(W.color).multiplyScalar(K), D.groundColor.copy(W.groundColor).multiplyScalar(K), e.hemi[R] = D, R++);
        }
        e.ambient[0] = c, e.ambient[1] = p, e.ambient[2] = f, e.directional.length = d, e.spot.length = w, e.rectArea.length = P, e.point.length = v, e.hemi.length = R, e.hash.stateID = e.id, e.hash.directionalLength = d, e.hash.pointLength = v, e.hash.spotLength = w, e.hash.rectAreaLength = P, e.hash.hemiLength = R, e.hash.shadowsLength = l.length;
      },
      state: e
    };
  }
  function et() {
    var t = new ft(), e = [], i = [];
    return {
      init: function() {
        e.length = 0, i.length = 0;
      },
      state: { lightsArray: e, shadowsArray: i, lights: t },
      setupLights: function(n) {
        t.setup(e, i, n);
      },
      pushLight: function(n) {
        e.push(n);
      },
      pushShadow: function(n) {
        i.push(n);
      }
    };
  }
  function Xt() {
    var t = {};
    return {
      get: function(e, i) {
        if (t[e.id] === void 0) {
          var n = new et();
          t[e.id] = {}, t[e.id][i.id] = n;
        } else
          t[e.id][i.id] === void 0 ? (n = new et(), t[e.id][i.id] = n) : n = t[e.id][i.id];
        return n;
      },
      dispose: function() {
        t = {};
      }
    };
  }
  function Vt(t) {
    Oe.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t);
  }
  function It(t) {
    Oe.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new S(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t);
  }
  function Kt(t, e, i) {
    function n(C, D, ct, Dt, bt, St) {
      var oe = C.geometry, $t = d, me = C.customDepthMaterial;
      return ct && ($t = v, me = C.customDistanceMaterial), me ? $t = me : (me = !1, D.morphTargets && (oe && oe.isBufferGeometry ? me = oe.morphAttributes && oe.morphAttributes.position && 0 < oe.morphAttributes.position.length : oe && oe.isGeometry && (me = oe.morphTargets && 0 < oe.morphTargets.length)), C.isSkinnedMesh && D.skinning === !1 && console.warn(
        "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
        C
      ), C = C.isSkinnedMesh && D.skinning, oe = 0, me && (oe |= 1), C && (oe |= 2), $t = $t[oe]), t.localClippingEnabled && D.clipShadows === !0 && D.clippingPlanes.length !== 0 && (oe = $t.uuid, me = D.uuid, C = w[oe], C === void 0 && (C = {}, w[oe] = C), oe = C[me], oe === void 0 && (oe = $t.clone(), C[me] = oe), $t = oe), $t.visible = D.visible, $t.wireframe = D.wireframe, $t.side = D.shadowSide != null ? D.shadowSide : P[D.side], $t.clipShadows = D.clipShadows, $t.clippingPlanes = D.clippingPlanes, $t.clipIntersection = D.clipIntersection, $t.wireframeLinewidth = D.wireframeLinewidth, $t.linewidth = D.linewidth, ct && $t.isMeshDistanceMaterial && ($t.referencePosition.copy(Dt), $t.nearDistance = bt, $t.farDistance = St), $t;
    }
    function o(C, D, ct, Dt) {
      if (C.visible !== !1) {
        if (C.layers.test(D.layers) && (C.isMesh || C.isLine || C.isPoints) && C.castShadow && (!C.frustumCulled || s.intersectsObject(C))) {
          C.modelViewMatrix.multiplyMatrices(
            ct.matrixWorldInverse,
            C.matrixWorld
          );
          var bt = e.update(C), St = C.material;
          if (Array.isArray(St))
            for (var oe = bt.groups, $t = 0, me = oe.length; $t < me; $t++) {
              var ue = oe[$t], Wt = St[ue.materialIndex];
              Wt && Wt.visible && (Wt = n(C, Wt, Dt, f, ct.near, ct.far), t.renderBufferDirect(ct, null, bt, Wt, C, ue));
            }
          else
            St.visible && (Wt = n(C, St, Dt, f, ct.near, ct.far), t.renderBufferDirect(ct, null, bt, Wt, C, null));
        }
        for (C = C.children, bt = 0, St = C.length; bt < St; bt++)
          o(C[bt], D, ct, Dt);
      }
    }
    var s = new at(), l = new pt(), h = new y(), c = new y(i, i), p = new S(), f = new S(), d = Array(4), v = Array(4), w = {}, P = { 0: 1, 1: 0, 2: 2 }, R = [
      new S(1, 0, 0),
      new S(-1, 0, 0),
      new S(0, 0, 1),
      new S(0, 0, -1),
      new S(0, 1, 0),
      new S(0, -1, 0)
    ], I = [
      new S(0, 1, 0),
      new S(0, 1, 0),
      new S(0, 1, 0),
      new S(0, 1, 0),
      new S(0, 0, 1),
      new S(0, 0, -1)
    ], Q = [new nt(), new nt(), new nt(), new nt(), new nt(), new nt()];
    for (i = 0; i !== 4; ++i) {
      var W = (i & 1) !== 0, st = (i & 2) !== 0, K = new Vt({ depthPacking: 3201, morphTargets: W, skinning: st });
      d[i] = K, W = new It({ morphTargets: W, skinning: st }), v[i] = W;
    }
    var wt = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(C, D, ct) {
      if (wt.enabled !== !1 && (wt.autoUpdate !== !1 || wt.needsUpdate !== !1) && C.length !== 0) {
        var Dt = t.state;
        Dt.disable(3042), Dt.buffers.color.setClear(1, 1, 1, 1), Dt.buffers.depth.setTest(!0), Dt.setScissorTest(!1);
        for (var bt, St = 0, oe = C.length; St < oe; St++) {
          var $t = C[St];
          bt = $t.shadow;
          var me = $t && $t.isPointLight;
          if (bt === void 0)
            console.warn("THREE.WebGLShadowMap:", $t, "has no shadow.");
          else {
            var ue = bt.camera;
            if (h.copy(bt.mapSize), h.min(c), me) {
              var Wt = h.x, Ee = h.y;
              Q[0].set(2 * Wt, Ee, Wt, Ee), Q[1].set(0, Ee, Wt, Ee), Q[2].set(3 * Wt, Ee, Wt, Ee), Q[3].set(Wt, Ee, Wt, Ee), Q[4].set(3 * Wt, 0, Wt, Ee), Q[5].set(Wt, 0, Wt, Ee), h.x *= 4, h.y *= 2;
            }
            for (bt.map === null && (bt.map = new Tt(h.x, h.y, {
              minFilter: 1003,
              magFilter: 1003,
              format: 1023
            }), bt.map.texture.name = $t.name + ".shadowMap", ue.updateProjectionMatrix()), bt.isSpotLightShadow && bt.update($t), Wt = bt.map, Ee = bt.matrix, f.setFromMatrixPosition($t.matrixWorld), ue.position.copy(f), me ? (bt = 6, Ee.makeTranslation(-f.x, -f.y, -f.z)) : (bt = 1, p.setFromMatrixPosition($t.target.matrixWorld), ue.lookAt(p), ue.updateMatrixWorld(), Ee.set(
              0.5,
              0,
              0,
              0.5,
              0,
              0.5,
              0,
              0.5,
              0,
              0,
              0.5,
              0.5,
              0,
              0,
              0,
              1
            ), Ee.multiply(ue.projectionMatrix), Ee.multiply(ue.matrixWorldInverse)), t.setRenderTarget(Wt), t.clear(), $t = 0; $t < bt; $t++)
              me && (p.copy(ue.position), p.add(R[$t]), ue.up.copy(I[$t]), ue.lookAt(p), ue.updateMatrixWorld(), Dt.viewport(Q[$t])), l.multiplyMatrices(ue.projectionMatrix, ue.matrixWorldInverse), s.setFromMatrix(l), o(D, ct, ue, me);
          }
        }
        wt.needsUpdate = !1;
      }
    };
  }
  function qt(t, e, i, n) {
    function o(yt, be, Fe) {
      var Ei = new Uint8Array(4), pe = t.createTexture();
      for (t.bindTexture(yt, pe), t.texParameteri(yt, 10241, 9728), t.texParameteri(yt, 10240, 9728), yt = 0; yt < Fe; yt++)
        t.texImage2D(be + yt, 0, 6408, 1, 1, 0, 6408, 5121, Ei);
      return pe;
    }
    function s(yt, be) {
      Q[yt] = 1, W[yt] === 0 && (t.enableVertexAttribArray(yt), W[yt] = 1), st[yt] !== be && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](yt, be), st[yt] = be);
    }
    function l(yt) {
      K[yt] !== !0 && (t.enable(yt), K[yt] = !0);
    }
    function h(yt) {
      K[yt] !== !1 && (t.disable(yt), K[yt] = !1);
    }
    function c(yt, be, Fe, Ei, pe, Ce, He, pi) {
      if (yt === 0)
        D && (h(3042), D = !1);
      else if (D || (l(3042), D = !0), yt !== 5) {
        if (yt !== ct || pi !== ue) {
          if ((Dt !== 100 || oe !== 100) && (t.blendEquation(32774), oe = Dt = 100), pi)
            switch (yt) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", yt);
            }
          else
            switch (yt) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", yt);
            }
          me = $t = St = bt = null, ct = yt, ue = pi;
        }
      } else
        pe = pe || be, Ce = Ce || Fe, He = He || Ei, (be !== Dt || pe !== oe) && (t.blendEquationSeparate(i.convert(be), i.convert(pe)), Dt = be, oe = pe), (Fe !== bt || Ei !== St || Ce !== $t || He !== me) && (t.blendFuncSeparate(
          i.convert(Fe),
          i.convert(Ei),
          i.convert(Ce),
          i.convert(He)
        ), bt = Fe, St = Ei, $t = Ce, me = He), ct = yt, ue = null;
    }
    function p(yt) {
      Wt !== yt && (yt ? t.frontFace(2304) : t.frontFace(2305), Wt = yt);
    }
    function f(yt) {
      yt !== 0 ? (l(2884), yt !== Ee && (yt === 1 ? t.cullFace(1029) : yt === 2 ? t.cullFace(1028) : t.cullFace(1032))) : h(2884), Ee = yt;
    }
    function d(yt, be, Fe) {
      yt ? (l(32823), (Ye !== be || hn !== Fe) && (t.polygonOffset(be, Fe), Ye = be, hn = Fe)) : h(32823);
    }
    function v(yt) {
      yt === void 0 && (yt = 33984 + Ki - 1), Si !== yt && (t.activeTexture(yt), Si = yt);
    }
    var w = new function() {
      var yt = !1, be = new nt(), Fe = null, Ei = new nt(0, 0, 0, 0);
      return {
        setMask: function(pe) {
          Fe === pe || yt || (t.colorMask(pe, pe, pe, pe), Fe = pe);
        },
        setLocked: function(pe) {
          yt = pe;
        },
        setClear: function(pe, Ce, He, pi, hi) {
          hi === !0 && (pe *= pi, Ce *= pi, He *= pi), be.set(pe, Ce, He, pi), Ei.equals(be) === !1 && (t.clearColor(pe, Ce, He, pi), Ei.copy(be));
        },
        reset: function() {
          yt = !1, Fe = null, Ei.set(-1, 0, 0, 0);
        }
      };
    }(), P = new function() {
      var yt = !1, be = null, Fe = null, Ei = null;
      return {
        setTest: function(pe) {
          pe ? l(2929) : h(2929);
        },
        setMask: function(pe) {
          be === pe || yt || (t.depthMask(pe), be = pe);
        },
        setFunc: function(pe) {
          if (Fe !== pe) {
            if (pe)
              switch (pe) {
                case 0:
                  t.depthFunc(512);
                  break;
                case 1:
                  t.depthFunc(519);
                  break;
                case 2:
                  t.depthFunc(513);
                  break;
                case 3:
                  t.depthFunc(515);
                  break;
                case 4:
                  t.depthFunc(514);
                  break;
                case 5:
                  t.depthFunc(518);
                  break;
                case 6:
                  t.depthFunc(516);
                  break;
                case 7:
                  t.depthFunc(517);
                  break;
                default:
                  t.depthFunc(515);
              }
            else
              t.depthFunc(515);
            Fe = pe;
          }
        },
        setLocked: function(pe) {
          yt = pe;
        },
        setClear: function(pe) {
          Ei !== pe && (t.clearDepth(pe), Ei = pe);
        },
        reset: function() {
          yt = !1, Ei = Fe = be = null;
        }
      };
    }(), R = new function() {
      var yt = !1, be = null, Fe = null, Ei = null, pe = null, Ce = null, He = null, pi = null, hi = null;
      return {
        setTest: function(Bt) {
          Bt ? l(2960) : h(2960);
        },
        setMask: function(Bt) {
          be === Bt || yt || (t.stencilMask(Bt), be = Bt);
        },
        setFunc: function(Bt, Ge, Ie) {
          (Fe !== Bt || Ei !== Ge || pe !== Ie) && (t.stencilFunc(Bt, Ge, Ie), Fe = Bt, Ei = Ge, pe = Ie);
        },
        setOp: function(Bt, Ge, Ie) {
          (Ce !== Bt || He !== Ge || pi !== Ie) && (t.stencilOp(Bt, Ge, Ie), Ce = Bt, He = Ge, pi = Ie);
        },
        setLocked: function(Bt) {
          yt = Bt;
        },
        setClear: function(Bt) {
          hi !== Bt && (t.clearStencil(Bt), hi = Bt);
        },
        reset: function() {
          yt = !1, hi = pi = He = Ce = pe = Ei = Fe = be = null;
        }
      };
    }(), I = t.getParameter(34921), Q = new Uint8Array(I), W = new Uint8Array(I), st = new Uint8Array(I), K = {}, wt = null, C = null, D = null, ct = null, Dt = null, bt = null, St = null, oe = null, $t = null, me = null, ue = !1, Wt = null, Ee = null, Be = null, Ye = null, hn = null, Ki = t.getParameter(35661), Ci = !1;
    I = 0, I = t.getParameter(7938), I.indexOf("WebGL") !== -1 ? (I = parseFloat(/^WebGL ([0-9])/.exec(I)[1]), Ci = 1 <= I) : I.indexOf("OpenGL ES") !== -1 && (I = parseFloat(/^OpenGL ES ([0-9])/.exec(I)[1]), Ci = 2 <= I);
    var Si = null, ki = {}, un = new nt(), ce = new nt(), Ue = {};
    return Ue[3553] = o(3553, 3553, 1), Ue[34067] = o(34067, 34069, 6), w.setClear(0, 0, 0, 1), P.setClear(1), R.setClear(0), l(2929), P.setFunc(3), p(!1), f(1), l(2884), c(0), {
      buffers: { color: w, depth: P, stencil: R },
      initAttributes: function() {
        for (var yt = 0, be = Q.length; yt < be; yt++)
          Q[yt] = 0;
      },
      enableAttribute: function(yt) {
        s(yt, 0);
      },
      enableAttributeAndDivisor: s,
      disableUnusedAttributes: function() {
        for (var yt = 0, be = W.length; yt !== be; ++yt)
          W[yt] !== Q[yt] && (t.disableVertexAttribArray(yt), W[yt] = 0);
      },
      enable: l,
      disable: h,
      getCompressedTextureFormats: function() {
        if (wt === null && (wt = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
          for (var yt = t.getParameter(34467), be = 0; be < yt.length; be++)
            wt.push(yt[be]);
        return wt;
      },
      useProgram: function(yt) {
        return C !== yt ? (t.useProgram(yt), C = yt, !0) : !1;
      },
      setBlending: c,
      setMaterial: function(yt, be) {
        yt.side === 2 ? h(2884) : l(2884);
        var Fe = yt.side === 1;
        be && (Fe = !Fe), p(Fe), yt.blending === 1 && yt.transparent === !1 ? c(0) : c(
          yt.blending,
          yt.blendEquation,
          yt.blendSrc,
          yt.blendDst,
          yt.blendEquationAlpha,
          yt.blendSrcAlpha,
          yt.blendDstAlpha,
          yt.premultipliedAlpha
        ), P.setFunc(yt.depthFunc), P.setTest(yt.depthTest), P.setMask(yt.depthWrite), w.setMask(yt.colorWrite), d(yt.polygonOffset, yt.polygonOffsetFactor, yt.polygonOffsetUnits);
      },
      setFlipSided: p,
      setCullFace: f,
      setLineWidth: function(yt) {
        yt !== Be && (Ci && t.lineWidth(yt), Be = yt);
      },
      setPolygonOffset: d,
      setScissorTest: function(yt) {
        yt ? l(3089) : h(3089);
      },
      activeTexture: v,
      bindTexture: function(yt, be) {
        Si === null && v();
        var Fe = ki[Si];
        Fe === void 0 && (Fe = { type: void 0, texture: void 0 }, ki[Si] = Fe), (Fe.type !== yt || Fe.texture !== be) && (t.bindTexture(yt, be || Ue[yt]), Fe.type = yt, Fe.texture = be);
      },
      compressedTexImage2D: function() {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (yt) {
          console.error("THREE.WebGLState:", yt);
        }
      },
      texImage2D: function() {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (yt) {
          console.error("THREE.WebGLState:", yt);
        }
      },
      texImage3D: function() {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (yt) {
          console.error("THREE.WebGLState:", yt);
        }
      },
      scissor: function(yt) {
        un.equals(yt) === !1 && (t.scissor(yt.x, yt.y, yt.z, yt.w), un.copy(yt));
      },
      viewport: function(yt) {
        ce.equals(yt) === !1 && (t.viewport(yt.x, yt.y, yt.z, yt.w), ce.copy(yt));
      },
      reset: function() {
        for (var yt = 0; yt < W.length; yt++)
          W[yt] === 1 && (t.disableVertexAttribArray(yt), W[yt] = 0);
        K = {}, Si = wt = null, ki = {}, Ee = Wt = ct = C = null, w.reset(), P.reset(), R.reset();
      }
    };
  }
  function Le(t, e, i, n, o, s, l) {
    function h(C, D) {
      if (C.width > D || C.height > D) {
        if ("data" in C) {
          console.warn(
            "THREE.WebGLRenderer: image in DataTexture is too big (" + C.width + "x" + C.height + ")."
          );
          return;
        }
        D /= Math.max(C.width, C.height);
        var ct = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        );
        return ct.width = Math.floor(C.width * D), ct.height = Math.floor(C.height * D), ct.getContext("2d").drawImage(
          C,
          0,
          0,
          C.width,
          C.height,
          0,
          0,
          ct.width,
          ct.height
        ), console.warn(
          "THREE.WebGLRenderer: image is too big (" + C.width + "x" + C.height + "). Resized to " + ct.width + "x" + ct.height
        ), ct;
      }
      return C;
    }
    function c(C) {
      return Je.isPowerOfTwo(C.width) && Je.isPowerOfTwo(C.height);
    }
    function p(C, D) {
      return C.generateMipmaps && D && C.minFilter !== 1003 && C.minFilter !== 1006;
    }
    function f(C, D, ct, Dt) {
      t.generateMipmap(C), n.get(D).__maxMipLevel = Math.log(Math.max(ct, Dt)) * Math.LOG2E;
    }
    function d(C, D) {
      if (!o.isWebGL2)
        return C;
      if (C === 6403) {
        if (D === 5126)
          return 33326;
        if (D === 5131)
          return 33325;
        if (D === 5121)
          return 33321;
      }
      if (C === 6407) {
        if (D === 5126)
          return 34837;
        if (D === 5131)
          return 34843;
        if (D === 5121)
          return 32849;
      }
      if (C === 6408) {
        if (D === 5126)
          return 34836;
        if (D === 5131)
          return 34842;
        if (D === 5121)
          return 32856;
      }
      return C;
    }
    function v(C) {
      return C === 1003 || C === 1004 || C === 1005 ? 9728 : 9729;
    }
    function w(C) {
      C = C.target, C.removeEventListener("dispose", w);
      t: {
        var D = n.get(C);
        if (C.image && D.__image__webglTextureCube)
          t.deleteTexture(D.__image__webglTextureCube);
        else {
          if (D.__webglInit === void 0)
            break t;
          t.deleteTexture(D.__webglTexture);
        }
        n.remove(C);
      }
      C.isVideoTexture && delete K[C.id], l.memory.textures--;
    }
    function P(C) {
      C = C.target, C.removeEventListener("dispose", P);
      var D = n.get(C), ct = n.get(C.texture);
      if (C) {
        if (ct.__webglTexture !== void 0 && t.deleteTexture(ct.__webglTexture), C.depthTexture && C.depthTexture.dispose(), C.isWebGLRenderTargetCube)
          for (ct = 0; 6 > ct; ct++)
            t.deleteFramebuffer(D.__webglFramebuffer[ct]), D.__webglDepthbuffer && t.deleteRenderbuffer(D.__webglDepthbuffer[ct]);
        else
          t.deleteFramebuffer(D.__webglFramebuffer), D.__webglDepthbuffer && t.deleteRenderbuffer(D.__webglDepthbuffer);
        n.remove(C.texture), n.remove(C);
      }
      l.memory.textures--;
    }
    function R(C, D) {
      var ct = n.get(C);
      if (C.isVideoTexture) {
        var Dt = C.id, bt = l.render.frame;
        K[Dt] !== bt && (K[Dt] = bt, C.update());
      }
      if (0 < C.version && ct.__version !== C.version)
        if (Dt = C.image, Dt === void 0)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined"
          );
        else if (Dt.complete === !1)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        else {
          Q(ct, C, D);
          return;
        }
      i.activeTexture(33984 + D), i.bindTexture(3553, ct.__webglTexture);
    }
    function I(C, D, ct) {
      ct ? (t.texParameteri(C, 10242, s.convert(D.wrapS)), t.texParameteri(C, 10243, s.convert(D.wrapT)), t.texParameteri(C, 10240, s.convert(D.magFilter)), t.texParameteri(C, 10241, s.convert(D.minFilter))) : (t.texParameteri(C, 10242, 33071), t.texParameteri(C, 10243, 33071), D.wrapS === 1001 && D.wrapT === 1001 || console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
      ), t.texParameteri(C, 10240, v(D.magFilter)), t.texParameteri(C, 10241, v(D.minFilter)), D.minFilter !== 1003 && D.minFilter !== 1006 && console.warn(
        "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
      )), !(ct = e.get("EXT_texture_filter_anisotropic")) || D.type === 1015 && e.get("OES_texture_float_linear") === null || D.type === 1016 && (o.isWebGL2 || e.get("OES_texture_half_float_linear")) === null || !(1 < D.anisotropy || n.get(D).__currentAnisotropy) || (t.texParameterf(
        C,
        ct.TEXTURE_MAX_ANISOTROPY_EXT,
        Math.min(D.anisotropy, o.getMaxAnisotropy())
      ), n.get(D).__currentAnisotropy = D.anisotropy);
    }
    function Q(C, D, ct) {
      var Dt = D.isDataTexture3D ? 32879 : 3553;
      C.__webglInit === void 0 && (C.__webglInit = !0, D.addEventListener("dispose", w), C.__webglTexture = t.createTexture(), l.memory.textures++), i.activeTexture(33984 + ct), i.bindTexture(Dt, C.__webglTexture), t.pixelStorei(37440, D.flipY), t.pixelStorei(37441, D.premultiplyAlpha), t.pixelStorei(3317, D.unpackAlignment), ct = h(D.image, o.maxTextureSize);
      var bt = o.isWebGL2 ? !1 : D.wrapS !== 1001 || D.wrapT !== 1001 || D.minFilter !== 1003 && D.minFilter !== 1006;
      bt && c(ct) === !1 && (ct instanceof HTMLImageElement || ct instanceof HTMLCanvasElement || ct instanceof ImageBitmap) && (wt === void 0 && (wt = document.createElementNS(
        "http://www.w3.org/1999/xhtml",
        "canvas"
      )), wt.width = Je.floorPowerOfTwo(ct.width), wt.height = Je.floorPowerOfTwo(ct.height), wt.getContext("2d").drawImage(ct, 0, 0, wt.width, wt.height), console.warn(
        "THREE.WebGLRenderer: image is not power of two (" + ct.width + "x" + ct.height + "). Resized to " + wt.width + "x" + wt.height
      ), ct = wt), bt = c(ct);
      var St = s.convert(D.format), oe = s.convert(D.type), $t = d(St, oe);
      I(Dt, D, bt);
      var me = D.mipmaps;
      if (D.isDepthTexture) {
        if ($t = 6402, D.type === 1015) {
          if (!o.isWebGL2)
            throw Error("Float Depth Texture only supported in WebGL2.0");
          $t = 36012;
        } else
          o.isWebGL2 && ($t = 33189);
        D.format === 1026 && $t === 6402 && D.type !== 1012 && D.type !== 1014 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
        ), D.type = 1012, oe = s.convert(D.type)), D.format === 1027 && ($t = 34041, D.type !== 1020 && (console.warn(
          "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
        ), D.type = 1020, oe = s.convert(D.type))), i.texImage2D(3553, 0, $t, ct.width, ct.height, 0, St, oe, null);
      } else if (D.isDataTexture)
        if (0 < me.length && bt) {
          for (var ue = 0, Wt = me.length; ue < Wt; ue++)
            Dt = me[ue], i.texImage2D(3553, ue, $t, Dt.width, Dt.height, 0, St, oe, Dt.data);
          D.generateMipmaps = !1, C.__maxMipLevel = me.length - 1;
        } else
          i.texImage2D(3553, 0, $t, ct.width, ct.height, 0, St, oe, ct.data), C.__maxMipLevel = 0;
      else if (D.isCompressedTexture) {
        for (ue = 0, Wt = me.length; ue < Wt; ue++)
          Dt = me[ue], D.format !== 1023 && D.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(St) ? i.compressedTexImage2D(
            3553,
            ue,
            $t,
            Dt.width,
            Dt.height,
            0,
            Dt.data
          ) : console.warn(
            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
          ) : i.texImage2D(3553, ue, $t, Dt.width, Dt.height, 0, St, oe, Dt.data);
        C.__maxMipLevel = me.length - 1;
      } else if (D.isDataTexture3D)
        i.texImage3D(32879, 0, $t, ct.width, ct.height, ct.depth, 0, St, oe, ct.data), C.__maxMipLevel = 0;
      else if (0 < me.length && bt) {
        for (ue = 0, Wt = me.length; ue < Wt; ue++)
          Dt = me[ue], i.texImage2D(3553, ue, $t, St, oe, Dt);
        D.generateMipmaps = !1, C.__maxMipLevel = me.length - 1;
      } else
        i.texImage2D(3553, 0, $t, St, oe, ct), C.__maxMipLevel = 0;
      p(D, bt) && f(3553, D, ct.width, ct.height), C.__version = D.version, D.onUpdate && D.onUpdate(D);
    }
    function W(C, D, ct, Dt) {
      var bt = s.convert(D.texture.format), St = s.convert(D.texture.type), oe = d(bt, St);
      i.texImage2D(Dt, 0, oe, D.width, D.height, 0, bt, St, null), t.bindFramebuffer(36160, C), t.framebufferTexture2D(36160, ct, Dt, n.get(D.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }
    function st(C, D) {
      t.bindRenderbuffer(36161, C), D.depthBuffer && !D.stencilBuffer ? (t.renderbufferStorage(36161, 33189, D.width, D.height), t.framebufferRenderbuffer(36160, 36096, 36161, C)) : D.depthBuffer && D.stencilBuffer ? (t.renderbufferStorage(36161, 34041, D.width, D.height), t.framebufferRenderbuffer(36160, 33306, 36161, C)) : t.renderbufferStorage(36161, 32854, D.width, D.height), t.bindRenderbuffer(36161, null);
    }
    var K = {}, wt;
    this.setTexture2D = R, this.setTexture3D = function(C, D) {
      var ct = n.get(C);
      0 < C.version && ct.__version !== C.version ? Q(ct, C, D) : (i.activeTexture(33984 + D), i.bindTexture(32879, ct.__webglTexture));
    }, this.setTextureCube = function(C, D) {
      var ct = n.get(C);
      if (C.image.length === 6)
        if (0 < C.version && ct.__version !== C.version) {
          ct.__image__webglTextureCube || (C.addEventListener("dispose", w), ct.__image__webglTextureCube = t.createTexture(), l.memory.textures++), i.activeTexture(33984 + D), i.bindTexture(34067, ct.__image__webglTextureCube), t.pixelStorei(37440, C.flipY), D = C && C.isCompressedTexture;
          for (var Dt = C.image[0] && C.image[0].isDataTexture, bt = [], St = 0; 6 > St; St++)
            bt[St] = D || Dt ? Dt ? C.image[St].image : C.image[St] : h(C.image[St], o.maxCubemapSize);
          var oe = bt[0], $t = c(oe), me = s.convert(C.format), ue = s.convert(C.type), Wt = d(me, ue);
          for (I(34067, C, $t), St = 0; 6 > St; St++)
            if (D)
              for (var Ee, Be = bt[St].mipmaps, Ye = 0, hn = Be.length; Ye < hn; Ye++)
                Ee = Be[Ye], C.format !== 1023 && C.format !== 1022 ? -1 < i.getCompressedTextureFormats().indexOf(me) ? i.compressedTexImage2D(
                  34069 + St,
                  Ye,
                  Wt,
                  Ee.width,
                  Ee.height,
                  0,
                  Ee.data
                ) : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                ) : i.texImage2D(
                  34069 + St,
                  Ye,
                  Wt,
                  Ee.width,
                  Ee.height,
                  0,
                  me,
                  ue,
                  Ee.data
                );
            else
              Dt ? i.texImage2D(
                34069 + St,
                0,
                Wt,
                bt[St].width,
                bt[St].height,
                0,
                me,
                ue,
                bt[St].data
              ) : i.texImage2D(34069 + St, 0, Wt, me, ue, bt[St]);
          ct.__maxMipLevel = D ? Be.length - 1 : 0, p(C, $t) && f(34067, C, oe.width, oe.height), ct.__version = C.version, C.onUpdate && C.onUpdate(C);
        } else
          i.activeTexture(33984 + D), i.bindTexture(34067, ct.__image__webglTextureCube);
    }, this.setTextureCubeDynamic = function(C, D) {
      i.activeTexture(33984 + D), i.bindTexture(34067, n.get(C).__webglTexture);
    }, this.setupRenderTarget = function(C) {
      var D = n.get(C), ct = n.get(C.texture);
      C.addEventListener("dispose", P), ct.__webglTexture = t.createTexture(), l.memory.textures++;
      var Dt = C.isWebGLRenderTargetCube === !0, bt = c(C);
      if (Dt) {
        D.__webglFramebuffer = [];
        for (var St = 0; 6 > St; St++)
          D.__webglFramebuffer[St] = t.createFramebuffer();
      } else
        D.__webglFramebuffer = t.createFramebuffer();
      if (Dt) {
        for (i.bindTexture(34067, ct.__webglTexture), I(34067, C.texture, bt), St = 0; 6 > St; St++)
          W(D.__webglFramebuffer[St], C, 36064, 34069 + St);
        p(C.texture, bt) && f(34067, C.texture, C.width, C.height), i.bindTexture(34067, null);
      } else
        i.bindTexture(3553, ct.__webglTexture), I(3553, C.texture, bt), W(D.__webglFramebuffer, C, 36064, 3553), p(C.texture, bt) && f(3553, C.texture, C.width, C.height), i.bindTexture(3553, null);
      if (C.depthBuffer) {
        if (D = n.get(C), ct = C.isWebGLRenderTargetCube === !0, C.depthTexture) {
          if (ct)
            throw Error(
              "target.depthTexture not supported in Cube render targets"
            );
          if (C && C.isWebGLRenderTargetCube)
            throw Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (t.bindFramebuffer(36160, D.__webglFramebuffer), !C.depthTexture || !C.depthTexture.isDepthTexture)
            throw Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          if (n.get(C.depthTexture).__webglTexture && C.depthTexture.image.width === C.width && C.depthTexture.image.height === C.height || (C.depthTexture.image.width = C.width, C.depthTexture.image.height = C.height, C.depthTexture.needsUpdate = !0), R(C.depthTexture, 0), D = n.get(C.depthTexture).__webglTexture, C.depthTexture.format === 1026)
            t.framebufferTexture2D(36160, 36096, 3553, D, 0);
          else if (C.depthTexture.format === 1027)
            t.framebufferTexture2D(36160, 33306, 3553, D, 0);
          else
            throw Error("Unknown depthTexture format");
        } else if (ct)
          for (D.__webglDepthbuffer = [], ct = 0; 6 > ct; ct++)
            t.bindFramebuffer(36160, D.__webglFramebuffer[ct]), D.__webglDepthbuffer[ct] = t.createRenderbuffer(), st(D.__webglDepthbuffer[ct], C);
        else
          t.bindFramebuffer(36160, D.__webglFramebuffer), D.__webglDepthbuffer = t.createRenderbuffer(), st(D.__webglDepthbuffer, C);
        t.bindFramebuffer(36160, null);
      }
    }, this.updateRenderTargetMipmap = function(C) {
      var D = C.texture, ct = c(C);
      if (p(D, ct)) {
        ct = C.isWebGLRenderTargetCube ? 34067 : 3553;
        var Dt = n.get(D).__webglTexture;
        i.bindTexture(ct, Dt), f(ct, D, C.width, C.height), i.bindTexture(ct, null);
      }
    };
  }
  function Me(t, e, i) {
    return {
      convert: function(n) {
        if (n === 1e3)
          return 10497;
        if (n === 1001)
          return 33071;
        if (n === 1002)
          return 33648;
        if (n === 1003)
          return 9728;
        if (n === 1004)
          return 9984;
        if (n === 1005)
          return 9986;
        if (n === 1006)
          return 9729;
        if (n === 1007)
          return 9985;
        if (n === 1008)
          return 9987;
        if (n === 1009)
          return 5121;
        if (n === 1017)
          return 32819;
        if (n === 1018)
          return 32820;
        if (n === 1019)
          return 33635;
        if (n === 1010)
          return 5120;
        if (n === 1011)
          return 5122;
        if (n === 1012)
          return 5123;
        if (n === 1013)
          return 5124;
        if (n === 1014)
          return 5125;
        if (n === 1015)
          return 5126;
        if (n === 1016) {
          if (i.isWebGL2)
            return 5131;
          var o = e.get("OES_texture_half_float");
          if (o !== null)
            return o.HALF_FLOAT_OES;
        }
        if (n === 1021)
          return 6406;
        if (n === 1022)
          return 6407;
        if (n === 1023)
          return 6408;
        if (n === 1024)
          return 6409;
        if (n === 1025)
          return 6410;
        if (n === 1026)
          return 6402;
        if (n === 1027)
          return 34041;
        if (n === 1028)
          return 6403;
        if (n === 100)
          return 32774;
        if (n === 101)
          return 32778;
        if (n === 102)
          return 32779;
        if (n === 200)
          return 0;
        if (n === 201)
          return 1;
        if (n === 202)
          return 768;
        if (n === 203)
          return 769;
        if (n === 204)
          return 770;
        if (n === 205)
          return 771;
        if (n === 206)
          return 772;
        if (n === 207)
          return 773;
        if (n === 208)
          return 774;
        if (n === 209)
          return 775;
        if (n === 210)
          return 776;
        if ((n === 33776 || n === 33777 || n === 33778 || n === 33779) && (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null)) {
          if (n === 33776)
            return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (n === 33777)
            return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (n === 33778)
            return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (n === 33779)
            return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if ((n === 35840 || n === 35841 || n === 35842 || n === 35843) && (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null)) {
          if (n === 35840)
            return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (n === 35841)
            return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (n === 35842)
            return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (n === 35843)
            return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (n === 36196 && (o = e.get("WEBGL_compressed_texture_etc1"), o !== null))
          return o.COMPRESSED_RGB_ETC1_WEBGL;
        if ((n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821) && (o = e.get("WEBGL_compressed_texture_astc"), o !== null))
          return n;
        if (n === 103 || n === 104) {
          if (i.isWebGL2) {
            if (n === 103)
              return 32775;
            if (n === 104)
              return 32776;
          }
          if (o = e.get("EXT_blend_minmax"), o !== null) {
            if (n === 103)
              return o.MIN_EXT;
            if (n === 104)
              return o.MAX_EXT;
          }
        }
        if (n === 1020) {
          if (i.isWebGL2)
            return 34042;
          if (o = e.get("WEBGL_depth_texture"), o !== null)
            return o.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      }
    };
  }
  function qe() {
    z.call(this), this.type = "Group";
  }
  function ye() {
    z.call(this), this.type = "Camera", this.matrixWorldInverse = new pt(), this.projectionMatrix = new pt(), this.projectionMatrixInverse = new pt();
  }
  function ee(t, e, i, n) {
    ye.call(this), this.type = "PerspectiveCamera", this.fov = t !== void 0 ? t : 50, this.zoom = 1, this.near = i !== void 0 ? i : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = e !== void 0 ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  function _e(t) {
    ee.call(this), this.cameras = t || [];
  }
  function Zt(t, e, i) {
    To.setFromMatrixPosition(e.matrixWorld), tr.setFromMatrixPosition(i.matrixWorld);
    var n = To.distanceTo(tr), o = e.projectionMatrix.elements, s = i.projectionMatrix.elements, l = o[14] / (o[10] - 1);
    i = o[14] / (o[10] + 1);
    var h = (o[9] + 1) / o[5], c = (o[9] - 1) / o[5], p = (o[8] - 1) / o[0], f = (s[8] + 1) / s[0];
    o = l * p, s = l * f, f = n / (-p + f), p = f * -p, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(p), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = l + f, l = i + f, t.projectionMatrix.makePerspective(
      o - p,
      s + (n - p),
      h * i / l * e,
      c * i / l * e,
      e,
      l
    );
  }
  function Qe(t) {
    function e() {
      return o !== null && o.isPresenting === !0;
    }
    function i() {
      if (e()) {
        var C = o.getEyeParameters("left"), D = C.renderWidth * f;
        C = C.renderHeight * f, st = t.getPixelRatio(), W = t.getSize(), t.setDrawingBufferSize(2 * D, C, 1), wt.start();
      } else
        n.enabled && t.setDrawingBufferSize(W.width, W.height, st), wt.stop();
    }
    var n = this, o = null, s = null, l = null, h = [], c = new pt(), p = new pt(), f = 1, d = "stage";
    typeof window < "u" && "VRFrameData" in window && (s = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", i, !1));
    var v = new pt(), w = new gt(), P = new S(), R = new ee();
    R.bounds = new nt(0, 0, 0.5, 1), R.layers.enable(1);
    var I = new ee();
    I.bounds = new nt(0.5, 0, 0.5, 1), I.layers.enable(2);
    var Q = new _e([R, I]);
    Q.layers.enable(1), Q.layers.enable(2);
    var W, st, K = [];
    this.enabled = !1, this.getController = function(C) {
      var D = h[C];
      return D === void 0 && (D = new qe(), D.matrixAutoUpdate = !1, D.visible = !1, h[C] = D), D;
    }, this.getDevice = function() {
      return o;
    }, this.setDevice = function(C) {
      C !== void 0 && (o = C), wt.setContext(C);
    }, this.setFramebufferScaleFactor = function(C) {
      f = C;
    }, this.setFrameOfReferenceType = function(C) {
      d = C;
    }, this.setPoseTarget = function(C) {
      C !== void 0 && (l = C);
    }, this.getCamera = function(C) {
      var D = d === "stage" ? 1.6 : 0;
      if (o === null)
        return C.position.set(0, D, 0), C;
      if (o.depthNear = C.near, o.depthFar = C.far, o.getFrameData(s), d === "stage") {
        var ct = o.stageParameters;
        ct ? c.fromArray(ct.sittingToStandingTransform) : c.makeTranslation(0, D, 0);
      }
      if (D = s.pose, ct = l !== null ? l : C, ct.matrix.copy(c), ct.matrix.decompose(ct.position, ct.quaternion, ct.scale), D.orientation !== null && (w.fromArray(D.orientation), ct.quaternion.multiply(w)), D.position !== null && (w.setFromRotationMatrix(c), P.fromArray(D.position), P.applyQuaternion(w), ct.position.add(P)), ct.updateMatrixWorld(), o.isPresenting === !1)
        return C;
      R.near = C.near, I.near = C.near, R.far = C.far, I.far = C.far, R.matrixWorldInverse.fromArray(s.leftViewMatrix), I.matrixWorldInverse.fromArray(s.rightViewMatrix), p.getInverse(c), d === "stage" && (R.matrixWorldInverse.multiply(p), I.matrixWorldInverse.multiply(p)), C = ct.parent, C !== null && (v.getInverse(C.matrixWorld), R.matrixWorldInverse.multiply(v), I.matrixWorldInverse.multiply(v)), R.matrixWorld.getInverse(R.matrixWorldInverse), I.matrixWorld.getInverse(I.matrixWorldInverse), R.projectionMatrix.fromArray(s.leftProjectionMatrix), I.projectionMatrix.fromArray(s.rightProjectionMatrix), Zt(Q, R, I), C = o.getLayers(), C.length && (C = C[0], C.leftBounds !== null && C.leftBounds.length === 4 && R.bounds.fromArray(C.leftBounds), C.rightBounds !== null && C.rightBounds.length === 4 && I.bounds.fromArray(C.rightBounds));
      t:
        for (C = 0; C < h.length; C++) {
          D = h[C];
          e: {
            ct = C;
            for (var Dt = navigator.getGamepads && navigator.getGamepads(), bt = 0, St = 0, oe = Dt.length; bt < oe; bt++) {
              var $t = Dt[bt];
              if ($t && ($t.id === "Daydream Controller" || $t.id === "Gear VR Controller" || $t.id === "Oculus Go Controller" || $t.id === "OpenVR Gamepad" || $t.id.startsWith("Oculus Touch") || $t.id.startsWith("Spatial Controller"))) {
                if (St === ct) {
                  ct = $t;
                  break e;
                }
                St++;
              }
            }
            ct = void 0;
          }
          if (ct !== void 0 && ct.pose !== void 0) {
            if (ct.pose === null)
              break t;
            Dt = ct.pose, Dt.hasPosition === !1 && D.position.set(0.2, -0.6, -0.05), Dt.position !== null && D.position.fromArray(Dt.position), Dt.orientation !== null && D.quaternion.fromArray(Dt.orientation), D.matrix.compose(D.position, D.quaternion, D.scale), D.matrix.premultiply(c), D.matrix.decompose(D.position, D.quaternion, D.scale), D.matrixWorldNeedsUpdate = !0, D.visible = !0, Dt = ct.id === "Daydream Controller" ? 0 : 1, K[C] !== ct.buttons[Dt].pressed && (K[C] = ct.buttons[Dt].pressed, K[C] === !0 ? D.dispatchEvent({ type: "selectstart" }) : (D.dispatchEvent({ type: "selectend" }), D.dispatchEvent({ type: "select" })));
          } else
            D.visible = !1;
        }
      return Q;
    }, this.getStandingMatrix = function() {
      return c;
    }, this.isPresenting = e;
    var wt = new _();
    this.setAnimationLoop = function(C) {
      wt.setAnimationLoop(C);
    }, this.submitFrame = function() {
      e() && o.submitFrame();
    }, this.dispose = function() {
      typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", i);
    };
  }
  function fe(t) {
    function e() {
      return h !== null && p !== null;
    }
    function i(st) {
      var K = v[w.indexOf(st.inputSource)];
      K && K.dispatchEvent({ type: st.type });
    }
    function n() {
      t.setFramebuffer(null), W.stop();
    }
    function o(st, K) {
      K === null ? st.matrixWorld.copy(st.matrix) : st.matrixWorld.multiplyMatrices(K.matrixWorld, st.matrix), st.matrixWorldInverse.getInverse(st.matrixWorld);
    }
    var s = t.context, l = null, h = null, c = 1, p = null, f = "stage", d = null, v = [], w = [], P = new ee();
    P.layers.enable(1), P.viewport = new nt();
    var R = new ee();
    R.layers.enable(2), R.viewport = new nt();
    var I = new _e([P, R]);
    I.layers.enable(1), I.layers.enable(2), this.enabled = !1, this.getController = function(st) {
      var K = v[st];
      return K === void 0 && (K = new qe(), K.matrixAutoUpdate = !1, K.visible = !1, v[st] = K), K;
    }, this.getDevice = function() {
      return l;
    }, this.setDevice = function(st) {
      st !== void 0 && (l = st), st instanceof XRDevice && s.setCompatibleXRDevice(st);
    }, this.setFramebufferScaleFactor = function(st) {
      c = st;
    }, this.setFrameOfReferenceType = function(st) {
      f = st;
    }, this.setSession = function(st) {
      h = st, h !== null && (h.addEventListener("select", i), h.addEventListener("selectstart", i), h.addEventListener("selectend", i), h.addEventListener("end", n), h.baseLayer = new XRWebGLLayer(h, s, { framebufferScaleFactor: c }), h.requestFrameOfReference(f).then(function(K) {
        p = K, t.setFramebuffer(h.baseLayer.framebuffer), W.setContext(h), W.start();
      }), w = h.getInputSources(), h.addEventListener("inputsourceschange", function() {
        w = h.getInputSources(), console.log(w);
        for (var K = 0; K < v.length; K++)
          v[K].userData.inputSource = w[K];
      }));
    }, this.getCamera = function(st) {
      if (e()) {
        var K = st.parent, wt = I.cameras;
        o(I, K);
        for (var C = 0; C < wt.length; C++)
          o(wt[C], K);
        for (st.matrixWorld.copy(I.matrixWorld), st = st.children, C = 0, K = st.length; C < K; C++)
          st[C].updateMatrixWorld(!0);
        return Zt(I, P, R), I;
      }
      return st;
    }, this.isPresenting = e;
    var Q = null, W = new _();
    W.setAnimationLoop(function(st, K) {
      if (d = K.getDevicePose(p), d !== null)
        for (var wt = h.baseLayer, C = K.views, D = 0; D < C.length; D++) {
          var ct = C[D], Dt = wt.getViewport(ct), bt = d.getViewMatrix(ct), St = I.cameras[D];
          St.matrix.fromArray(bt).getInverse(St.matrix), St.projectionMatrix.fromArray(ct.projectionMatrix), St.viewport.set(Dt.x, Dt.y, Dt.width, Dt.height), D === 0 && I.matrix.copy(St.matrix);
        }
      for (D = 0; D < v.length; D++) {
        if (wt = v[D], (C = w[D]) && (C = K.getInputPose(C, p), C !== null)) {
          "targetRay" in C ? wt.matrix.elements = C.targetRay.transformMatrix : "pointerMatrix" in C && (wt.matrix.elements = C.pointerMatrix), wt.matrix.decompose(wt.position, wt.rotation, wt.scale), wt.visible = !0;
          continue;
        }
        wt.visible = !1;
      }
      Q && Q(st);
    }), this.setAnimationLoop = function(st) {
      Q = st;
    }, this.dispose = function() {
    }, this.getStandingMatrix = function() {
      return console.warn(
        "THREE.WebXRManager: getStandingMatrix() is no longer needed."
      ), new THREE.Matrix4();
    }, this.submitFrame = function() {
    };
  }
  function ne(t) {
    var e;
    function i() {
      Ge = new Un(Bt), Ie = new Zn(Bt, Ge, t), Ie.isWebGL2 || (Ge.get("WEBGL_depth_texture"), Ge.get("OES_texture_float"), Ge.get("OES_texture_half_float"), Ge.get("OES_texture_half_float_linear"), Ge.get("OES_standard_derivatives"), Ge.get("OES_element_index_uint"), Ge.get("ANGLE_instanced_arrays")), Ge.get("OES_texture_float_linear"), dn = new Me(Bt, Ge, Ie), We = new qt(Bt, Ge, dn, Ie), We.scissor(Ci.copy(be).multiplyScalar(Ue)), We.viewport(Ki.copy(yt).multiplyScalar(Ue)), tn = new _n(), cn = new N(), ro = new Le(Bt, Ge, We, cn, Ie, dn, tn), zs = new x(Bt), gl = new rn(Bt, zs, tn), Ns = new Ni(gl, tn), vl = new Fn(Bt), Qo = new U(St, Ge, Ie), va = new ut(), Ko = new Xt(), Eo = new vr(St, We, Ns, C), yl = new Pr(Bt, Ge, tn, Ie), Nn = new Ze(Bt, Ge, tn, Ie), tn.programs = Qo.programs, St.context = Bt, St.capabilities = Ie, St.extensions = Ge, St.properties = cn, St.renderLists = va, St.state = We, St.info = tn;
    }
    function n(H) {
      H.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), oe = !0;
    }
    function o() {
      console.log("THREE.WebGLRenderer: Context Restored."), oe = !1, i();
    }
    function s(H) {
      H = H.target, H.removeEventListener("dispose", s), l(H), cn.remove(H);
    }
    function l(H) {
      var tt = cn.get(H).program;
      H.program = void 0, tt !== void 0 && Qo.releaseProgram(tt);
    }
    function h(H, tt) {
      H.render(function(V) {
        St.renderBufferImmediate(V, tt);
      });
    }
    function c(H, tt, V) {
      if (H.visible !== !1) {
        if (H.layers.test(tt.layers)) {
          if (H.isLight)
            bt.pushLight(H), H.castShadow && bt.pushShadow(H);
          else if (H.isSprite) {
            if (!H.frustumCulled || Ei.intersectsSprite(H)) {
              V && hi.setFromMatrixPosition(H.matrixWorld).applyMatrix4(pi);
              var ae = Ns.update(H), ge = H.material;
              Dt.push(H, ae, ge, hi.z, null);
            }
          } else if (H.isImmediateRenderObject)
            V && hi.setFromMatrixPosition(H.matrixWorld).applyMatrix4(pi), Dt.push(H, null, H.material, hi.z, null);
          else if ((H.isMesh || H.isLine || H.isPoints) && (H.isSkinnedMesh && H.skeleton.update(), !H.frustumCulled || Ei.intersectsObject(H)))
            if (V && hi.setFromMatrixPosition(H.matrixWorld).applyMatrix4(pi), ae = Ns.update(H), ge = H.material, Array.isArray(ge))
              for (var Te = ae.groups, le = 0, Ne = Te.length; le < Ne; le++) {
                var di = Te[le], zi = ge[di.materialIndex];
                zi && zi.visible && Dt.push(H, ae, zi, hi.z, di);
              }
            else
              ge.visible && Dt.push(H, ae, ge, hi.z, null);
        }
        for (H = H.children, le = 0, Ne = H.length; le < Ne; le++)
          c(H[le], tt, V);
      }
    }
    function p(H, tt, V, ae) {
      for (var ge = 0, Te = H.length; ge < Te; ge++) {
        var le = H[ge], Ne = le.object, di = le.geometry, zi = ae === void 0 ? le.material : ae;
        if (le = le.group, V.isArrayCamera) {
          hn = V;
          for (var Qt = V.cameras, er = 0, yn = Qt.length; er < yn; er++) {
            var Vi = Qt[er];
            if (Ne.layers.test(Vi.layers)) {
              if ("viewport" in Vi)
                We.viewport(Ki.copy(Vi.viewport));
              else {
                var qn = Vi.bounds;
                We.viewport(
                  Ki.set(qn.x * un, qn.y * ce, qn.z * un, qn.w * ce).multiplyScalar(Ue)
                );
              }
              bt.setupLights(Vi), f(Ne, tt, Vi, di, zi, le);
            }
          }
        } else
          hn = null, f(Ne, tt, V, di, zi, le);
      }
    }
    function f(H, tt, V, ae, ge, Te) {
      if (H.onBeforeRender(St, tt, V, ae, ge, Te), bt = Ko.get(tt, hn || V), H.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse, H.matrixWorld), H.normalMatrix.getNormalMatrix(H.modelViewMatrix), H.isImmediateRenderObject) {
        We.setMaterial(ge);
        var le = v(V, tt.fog, ge, H);
        Ee = e = null, Be = !1, h(H, le);
      } else
        St.renderBufferDirect(V, tt.fog, ae, ge, H, Te);
      H.onAfterRender(St, tt, V, ae, ge, Te), bt = Ko.get(tt, hn || V);
    }
    function d(H, tt, V) {
      var ae = cn.get(H), ge = bt.state.lights, Te = ae.lightsHash, le = ge.state.hash;
      V = Qo.getParameters(
        H,
        ge.state,
        bt.state.shadowsArray,
        tt,
        pe.numPlanes,
        pe.numIntersection,
        V
      );
      var Ne = Qo.getProgramCode(H, V), di = ae.program, zi = !0;
      if (di === void 0)
        H.addEventListener("dispose", s);
      else if (di.code !== Ne)
        l(H);
      else {
        if (Te.stateID !== le.stateID || Te.directionalLength !== le.directionalLength || Te.pointLength !== le.pointLength || Te.spotLength !== le.spotLength || Te.rectAreaLength !== le.rectAreaLength || Te.hemiLength !== le.hemiLength || Te.shadowsLength !== le.shadowsLength)
          Te.stateID = le.stateID, Te.directionalLength = le.directionalLength, Te.pointLength = le.pointLength, Te.spotLength = le.spotLength, Te.rectAreaLength = le.rectAreaLength, Te.hemiLength = le.hemiLength, Te.shadowsLength = le.shadowsLength;
        else if (V.shaderID !== void 0)
          return;
        zi = !1;
      }
      if (zi && (V.shaderID ? (Ne = Hr[V.shaderID], ae.shader = {
        name: H.type,
        uniforms: vn.clone(Ne.uniforms),
        vertexShader: Ne.vertexShader,
        fragmentShader: Ne.fragmentShader
      }) : ae.shader = {
        name: H.type,
        uniforms: H.uniforms,
        vertexShader: H.vertexShader,
        fragmentShader: H.fragmentShader
      }, H.onBeforeCompile(ae.shader, St), Ne = Qo.getProgramCode(H, V), di = Qo.acquireProgram(H, ae.shader, V, Ne), ae.program = di, H.program = di), V = di.getAttributes(), H.morphTargets)
        for (Ne = H.numSupportedMorphTargets = 0; Ne < St.maxMorphTargets; Ne++)
          0 <= V["morphTarget" + Ne] && H.numSupportedMorphTargets++;
      if (H.morphNormals)
        for (Ne = H.numSupportedMorphNormals = 0; Ne < St.maxMorphNormals; Ne++)
          0 <= V["morphNormal" + Ne] && H.numSupportedMorphNormals++;
      V = ae.shader.uniforms, (!H.isShaderMaterial && !H.isRawShaderMaterial || H.clipping === !0) && (ae.numClippingPlanes = pe.numPlanes, ae.numIntersection = pe.numIntersection, V.clippingPlanes = pe.uniform), ae.fog = tt, Te === void 0 && (ae.lightsHash = Te = {}), Te.stateID = le.stateID, Te.directionalLength = le.directionalLength, Te.pointLength = le.pointLength, Te.spotLength = le.spotLength, Te.rectAreaLength = le.rectAreaLength, Te.hemiLength = le.hemiLength, Te.shadowsLength = le.shadowsLength, H.lights && (V.ambientLightColor.value = ge.state.ambient, V.directionalLights.value = ge.state.directional, V.spotLights.value = ge.state.spot, V.rectAreaLights.value = ge.state.rectArea, V.pointLights.value = ge.state.point, V.hemisphereLights.value = ge.state.hemi, V.directionalShadowMap.value = ge.state.directionalShadowMap, V.directionalShadowMatrix.value = ge.state.directionalShadowMatrix, V.spotShadowMap.value = ge.state.spotShadowMap, V.spotShadowMatrix.value = ge.state.spotShadowMatrix, V.pointShadowMap.value = ge.state.pointShadowMap, V.pointShadowMatrix.value = ge.state.pointShadowMatrix), H = ae.program.getUniforms(), H = Rr.seqWithValue(H.seq, V), ae.uniformsList = H;
    }
    function v(H, tt, V, ae) {
      ki = 0;
      var ge = cn.get(V), Te = ge.lightsHash, le = bt.state.lights.state.hash;
      Ce && (He || H !== Ye) && pe.setState(
        V.clippingPlanes,
        V.clipIntersection,
        V.clipShadows,
        H,
        ge,
        H === Ye && V.id === Wt
      ), V.needsUpdate === !1 && (ge.program === void 0 || V.fog && ge.fog !== tt ? V.needsUpdate = !0 : (!V.lights || Te.stateID === le.stateID && Te.directionalLength === le.directionalLength && Te.pointLength === le.pointLength && Te.spotLength === le.spotLength && Te.rectAreaLength === le.rectAreaLength && Te.hemiLength === le.hemiLength && Te.shadowsLength === le.shadowsLength) && (ge.numClippingPlanes === void 0 || ge.numClippingPlanes === pe.numPlanes && ge.numIntersection === pe.numIntersection) || (V.needsUpdate = !0)), V.needsUpdate && (d(V, tt, ae), V.needsUpdate = !1);
      var Ne = !1, di = !1, zi = !1;
      Te = ge.program, le = Te.getUniforms();
      var Qt = ge.shader.uniforms;
      if (We.useProgram(Te.program) && (zi = di = Ne = !0), V.id !== Wt && (Wt = V.id, di = !0), (Ne || Ye !== H) && (le.setValue(Bt, "projectionMatrix", H.projectionMatrix), Ie.logarithmicDepthBuffer && le.setValue(Bt, "logDepthBufFC", 2 / (Math.log(H.far + 1) / Math.LN2)), Ye !== H && (Ye = H, zi = di = !0), (V.isShaderMaterial || V.isMeshPhongMaterial || V.isMeshStandardMaterial || V.envMap) && (Ne = le.map.cameraPosition, Ne !== void 0 && Ne.setValue(Bt, hi.setFromMatrixPosition(H.matrixWorld))), (V.isMeshPhongMaterial || V.isMeshLambertMaterial || V.isMeshBasicMaterial || V.isMeshStandardMaterial || V.isShaderMaterial || V.skinning) && le.setValue(Bt, "viewMatrix", H.matrixWorldInverse)), V.skinning && (le.setOptional(Bt, ae, "bindMatrix"), le.setOptional(Bt, ae, "bindMatrixInverse"), H = ae.skeleton))
        if (Ne = H.bones, Ie.floatVertexTextures) {
          if (H.boneTexture === void 0) {
            Ne = Math.sqrt(4 * Ne.length), Ne = Je.ceilPowerOfTwo(Ne), Ne = Math.max(Ne, 4);
            var er = new Float32Array(Ne * Ne * 4);
            er.set(H.boneMatrices);
            var yn = new vt(er, Ne, Ne, 1023, 1015);
            yn.needsUpdate = !0, H.boneMatrices = er, H.boneTexture = yn, H.boneTextureSize = Ne;
          }
          le.setValue(Bt, "boneTexture", H.boneTexture), le.setValue(Bt, "boneTextureSize", H.boneTextureSize);
        } else
          le.setOptional(Bt, H, "boneMatrices");
      return di && (le.setValue(Bt, "toneMappingExposure", St.toneMappingExposure), le.setValue(Bt, "toneMappingWhitePoint", St.toneMappingWhitePoint), V.lights && (di = zi, Qt.ambientLightColor.needsUpdate = di, Qt.directionalLights.needsUpdate = di, Qt.pointLights.needsUpdate = di, Qt.spotLights.needsUpdate = di, Qt.rectAreaLights.needsUpdate = di, Qt.hemisphereLights.needsUpdate = di), tt && V.fog && (Qt.fogColor.value = tt.color, tt.isFog ? (Qt.fogNear.value = tt.near, Qt.fogFar.value = tt.far) : tt.isFogExp2 && (Qt.fogDensity.value = tt.density)), V.isMeshBasicMaterial ? w(Qt, V) : V.isMeshLambertMaterial ? (w(Qt, V), V.emissiveMap && (Qt.emissiveMap.value = V.emissiveMap)) : V.isMeshPhongMaterial ? (w(Qt, V), V.isMeshToonMaterial ? (P(Qt, V), V.gradientMap && (Qt.gradientMap.value = V.gradientMap)) : P(Qt, V)) : V.isMeshStandardMaterial ? (w(Qt, V), V.isMeshPhysicalMaterial ? (R(Qt, V), Qt.reflectivity.value = V.reflectivity, Qt.clearCoat.value = V.clearCoat, Qt.clearCoatRoughness.value = V.clearCoatRoughness) : R(Qt, V)) : V.isMeshMatcapMaterial ? (w(Qt, V), V.matcap && (Qt.matcap.value = V.matcap), V.bumpMap && (Qt.bumpMap.value = V.bumpMap, Qt.bumpScale.value = V.bumpScale, V.side === 1 && (Qt.bumpScale.value *= -1)), V.normalMap && (Qt.normalMap.value = V.normalMap, Qt.normalScale.value.copy(V.normalScale), V.side === 1 && Qt.normalScale.value.negate()), V.displacementMap && (Qt.displacementMap.value = V.displacementMap, Qt.displacementScale.value = V.displacementScale, Qt.displacementBias.value = V.displacementBias)) : V.isMeshDepthMaterial ? (w(Qt, V), V.displacementMap && (Qt.displacementMap.value = V.displacementMap, Qt.displacementScale.value = V.displacementScale, Qt.displacementBias.value = V.displacementBias)) : V.isMeshDistanceMaterial ? (w(Qt, V), V.displacementMap && (Qt.displacementMap.value = V.displacementMap, Qt.displacementScale.value = V.displacementScale, Qt.displacementBias.value = V.displacementBias), Qt.referencePosition.value.copy(V.referencePosition), Qt.nearDistance.value = V.nearDistance, Qt.farDistance.value = V.farDistance) : V.isMeshNormalMaterial ? (w(Qt, V), V.bumpMap && (Qt.bumpMap.value = V.bumpMap, Qt.bumpScale.value = V.bumpScale, V.side === 1 && (Qt.bumpScale.value *= -1)), V.normalMap && (Qt.normalMap.value = V.normalMap, Qt.normalScale.value.copy(V.normalScale), V.side === 1 && Qt.normalScale.value.negate()), V.displacementMap && (Qt.displacementMap.value = V.displacementMap, Qt.displacementScale.value = V.displacementScale, Qt.displacementBias.value = V.displacementBias)) : V.isLineBasicMaterial ? (Qt.diffuse.value = V.color, Qt.opacity.value = V.opacity, V.isLineDashedMaterial && (Qt.dashSize.value = V.dashSize, Qt.totalSize.value = V.dashSize + V.gapSize, Qt.scale.value = V.scale)) : V.isPointsMaterial ? (Qt.diffuse.value = V.color, Qt.opacity.value = V.opacity, Qt.size.value = V.size * Ue, Qt.scale.value = 0.5 * ce, Qt.map.value = V.map, V.map !== null && (V.map.matrixAutoUpdate === !0 && V.map.updateMatrix(), Qt.uvTransform.value.copy(V.map.matrix))) : V.isSpriteMaterial ? (Qt.diffuse.value = V.color, Qt.opacity.value = V.opacity, Qt.rotation.value = V.rotation, Qt.map.value = V.map, V.map !== null && (V.map.matrixAutoUpdate === !0 && V.map.updateMatrix(), Qt.uvTransform.value.copy(V.map.matrix))) : V.isShadowMaterial && (Qt.color.value = V.color, Qt.opacity.value = V.opacity), Qt.ltc_1 !== void 0 && (Qt.ltc_1.value = Re.LTC_1), Qt.ltc_2 !== void 0 && (Qt.ltc_2.value = Re.LTC_2), Rr.upload(Bt, ge.uniformsList, Qt, St)), V.isShaderMaterial && V.uniformsNeedUpdate === !0 && (Rr.upload(Bt, ge.uniformsList, Qt, St), V.uniformsNeedUpdate = !1), V.isSpriteMaterial && le.setValue(Bt, "center", ae.center), le.setValue(Bt, "modelViewMatrix", ae.modelViewMatrix), le.setValue(Bt, "normalMatrix", ae.normalMatrix), le.setValue(Bt, "modelMatrix", ae.matrixWorld), Te;
    }
    function w(H, tt) {
      if (H.opacity.value = tt.opacity, tt.color && (H.diffuse.value = tt.color), tt.emissive && H.emissive.value.copy(tt.emissive).multiplyScalar(tt.emissiveIntensity), tt.map && (H.map.value = tt.map), tt.alphaMap && (H.alphaMap.value = tt.alphaMap), tt.specularMap && (H.specularMap.value = tt.specularMap), tt.envMap && (H.envMap.value = tt.envMap, H.flipEnvMap.value = tt.envMap && tt.envMap.isCubeTexture ? -1 : 1, H.reflectivity.value = tt.reflectivity, H.refractionRatio.value = tt.refractionRatio, H.maxMipLevel.value = cn.get(tt.envMap).__maxMipLevel), tt.lightMap && (H.lightMap.value = tt.lightMap, H.lightMapIntensity.value = tt.lightMapIntensity), tt.aoMap && (H.aoMap.value = tt.aoMap, H.aoMapIntensity.value = tt.aoMapIntensity), tt.map)
        var V = tt.map;
      else
        tt.specularMap ? V = tt.specularMap : tt.displacementMap ? V = tt.displacementMap : tt.normalMap ? V = tt.normalMap : tt.bumpMap ? V = tt.bumpMap : tt.roughnessMap ? V = tt.roughnessMap : tt.metalnessMap ? V = tt.metalnessMap : tt.alphaMap ? V = tt.alphaMap : tt.emissiveMap && (V = tt.emissiveMap);
      V !== void 0 && (V.isWebGLRenderTarget && (V = V.texture), V.matrixAutoUpdate === !0 && V.updateMatrix(), H.uvTransform.value.copy(V.matrix));
    }
    function P(H, tt) {
      H.specular.value = tt.specular, H.shininess.value = Math.max(tt.shininess, 1e-4), tt.emissiveMap && (H.emissiveMap.value = tt.emissiveMap), tt.bumpMap && (H.bumpMap.value = tt.bumpMap, H.bumpScale.value = tt.bumpScale, tt.side === 1 && (H.bumpScale.value *= -1)), tt.normalMap && (H.normalMap.value = tt.normalMap, H.normalScale.value.copy(tt.normalScale), tt.side === 1 && H.normalScale.value.negate()), tt.displacementMap && (H.displacementMap.value = tt.displacementMap, H.displacementScale.value = tt.displacementScale, H.displacementBias.value = tt.displacementBias);
    }
    function R(H, tt) {
      H.roughness.value = tt.roughness, H.metalness.value = tt.metalness, tt.roughnessMap && (H.roughnessMap.value = tt.roughnessMap), tt.metalnessMap && (H.metalnessMap.value = tt.metalnessMap), tt.emissiveMap && (H.emissiveMap.value = tt.emissiveMap), tt.bumpMap && (H.bumpMap.value = tt.bumpMap, H.bumpScale.value = tt.bumpScale, tt.side === 1 && (H.bumpScale.value *= -1)), tt.normalMap && (H.normalMap.value = tt.normalMap, H.normalScale.value.copy(tt.normalScale), tt.side === 1 && H.normalScale.value.negate()), tt.displacementMap && (H.displacementMap.value = tt.displacementMap, H.displacementScale.value = tt.displacementScale, H.displacementBias.value = tt.displacementBias), tt.envMap && (H.envMapIntensity.value = tt.envMapIntensity);
    }
    console.log("THREE.WebGLRenderer", "98"), t = t || {};
    var I = t.canvas !== void 0 ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), Q = t.context !== void 0 ? t.context : null, W = t.alpha !== void 0 ? t.alpha : !1, st = t.depth !== void 0 ? t.depth : !0, K = t.stencil !== void 0 ? t.stencil : !0, wt = t.antialias !== void 0 ? t.antialias : !1, C = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, D = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, ct = t.powerPreference !== void 0 ? t.powerPreference : "default", Dt = null, bt = null;
    this.domElement = I, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
    var St = this, oe = !1, $t = null, me = null, ue = null, Wt = -1, Ee = e = null, Be = !1, Ye = null, hn = null, Ki = new nt(), Ci = new nt(), Si = null, ki = 0, un = I.width, ce = I.height, Ue = 1, yt = new nt(0, 0, un, ce), be = new nt(0, 0, un, ce), Fe = !1, Ei = new at(), pe = new Fi(), Ce = !1, He = !1, pi = new pt(), hi = new S();
    try {
      W = {
        alpha: W,
        depth: st,
        stencil: K,
        antialias: wt,
        premultipliedAlpha: C,
        preserveDrawingBuffer: D,
        powerPreference: ct
      }, I.addEventListener("webglcontextlost", n, !1), I.addEventListener("webglcontextrestored", o, !1);
      var Bt = Q || I.getContext("webgl", W) || I.getContext("experimental-webgl", W);
      if (Bt === null)
        throw I.getContext("webgl") !== null ? Error(
          "Error creating WebGL context with your selected attributes."
        ) : Error("Error creating WebGL context.");
      Bt.getShaderPrecisionFormat === void 0 && (Bt.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (H) {
      console.error("THREE.WebGLRenderer: " + H.message);
    }
    var Ge, Ie, We, tn, cn, ro, zs, gl, Ns, Qo, va, Ko, Eo, vl, yl, Nn, dn;
    i();
    var Wr = null;
    typeof navigator < "u" && (Wr = "xr" in navigator ? new fe(St) : new Qe(St)), this.vr = Wr;
    var kl = new Kt(St, Ns, Ie.maxTextureSize);
    this.shadowMap = kl, this.getContext = function() {
      return Bt;
    }, this.getContextAttributes = function() {
      return Bt.getContextAttributes();
    }, this.forceContextLoss = function() {
      var H = Ge.get("WEBGL_lose_context");
      H && H.loseContext();
    }, this.forceContextRestore = function() {
      var H = Ge.get("WEBGL_lose_context");
      H && H.restoreContext();
    }, this.getPixelRatio = function() {
      return Ue;
    }, this.setPixelRatio = function(H) {
      H !== void 0 && (Ue = H, this.setSize(un, ce, !1));
    }, this.getSize = function() {
      return { width: un, height: ce };
    }, this.setSize = function(H, tt, V) {
      Wr.isPresenting() ? console.warn(
        "THREE.WebGLRenderer: Can't change size while VR device is presenting."
      ) : (un = H, ce = tt, I.width = H * Ue, I.height = tt * Ue, V !== !1 && (I.style.width = H + "px", I.style.height = tt + "px"), this.setViewport(0, 0, H, tt));
    }, this.getDrawingBufferSize = function() {
      return { width: un * Ue, height: ce * Ue };
    }, this.setDrawingBufferSize = function(H, tt, V) {
      un = H, ce = tt, Ue = V, I.width = H * V, I.height = tt * V, this.setViewport(0, 0, H, tt);
    }, this.getCurrentViewport = function() {
      return Ki;
    }, this.setViewport = function(H, tt, V, ae) {
      yt.set(H, ce - tt - ae, V, ae), We.viewport(Ki.copy(yt).multiplyScalar(Ue));
    }, this.setScissor = function(H, tt, V, ae) {
      be.set(H, ce - tt - ae, V, ae), We.scissor(Ci.copy(be).multiplyScalar(Ue));
    }, this.setScissorTest = function(H) {
      We.setScissorTest(Fe = H);
    }, this.getClearColor = function() {
      return Eo.getClearColor();
    }, this.setClearColor = function() {
      Eo.setClearColor.apply(Eo, arguments);
    }, this.getClearAlpha = function() {
      return Eo.getClearAlpha();
    }, this.setClearAlpha = function() {
      Eo.setClearAlpha.apply(Eo, arguments);
    }, this.clear = function(H, tt, V) {
      var ae = 0;
      (H === void 0 || H) && (ae |= 16384), (tt === void 0 || tt) && (ae |= 256), (V === void 0 || V) && (ae |= 1024), Bt.clear(ae);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      I.removeEventListener("webglcontextlost", n, !1), I.removeEventListener("webglcontextrestored", o, !1), va.dispose(), Ko.dispose(), cn.dispose(), Ns.dispose(), Wr.dispose(), oo.stop();
    }, this.renderBufferImmediate = function(H, tt) {
      We.initAttributes();
      var V = cn.get(H);
      H.hasPositions && !V.position && (V.position = Bt.createBuffer()), H.hasNormals && !V.normal && (V.normal = Bt.createBuffer()), H.hasUvs && !V.uv && (V.uv = Bt.createBuffer()), H.hasColors && !V.color && (V.color = Bt.createBuffer()), tt = tt.getAttributes(), H.hasPositions && (Bt.bindBuffer(34962, V.position), Bt.bufferData(34962, H.positionArray, 35048), We.enableAttribute(tt.position), Bt.vertexAttribPointer(tt.position, 3, 5126, !1, 0, 0)), H.hasNormals && (Bt.bindBuffer(34962, V.normal), Bt.bufferData(34962, H.normalArray, 35048), We.enableAttribute(tt.normal), Bt.vertexAttribPointer(tt.normal, 3, 5126, !1, 0, 0)), H.hasUvs && (Bt.bindBuffer(34962, V.uv), Bt.bufferData(34962, H.uvArray, 35048), We.enableAttribute(tt.uv), Bt.vertexAttribPointer(tt.uv, 2, 5126, !1, 0, 0)), H.hasColors && (Bt.bindBuffer(34962, V.color), Bt.bufferData(34962, H.colorArray, 35048), We.enableAttribute(tt.color), Bt.vertexAttribPointer(tt.color, 3, 5126, !1, 0, 0)), We.disableUnusedAttributes(), Bt.drawArrays(4, 0, H.count), H.count = 0;
    }, this.renderBufferDirect = function(H, tt, V, ae, ge, Te) {
      var le = ge.isMesh && 0 > ge.normalMatrix.determinant();
      We.setMaterial(ae, le);
      var Ne = v(H, tt, ae, ge), di = !1;
      (e !== V.id || Ee !== Ne.id || Be !== (ae.wireframe === !0)) && (e = V.id, Ee = Ne.id, Be = ae.wireframe === !0, di = !0), ge.morphTargetInfluences && (vl.update(ge, V, ae, Ne), di = !0), le = V.index;
      var zi = V.attributes.position;
      if (tt = 1, ae.wireframe === !0 && (le = gl.getWireframeAttribute(V), tt = 2), H = yl, le !== null) {
        var Qt = zs.get(le);
        H = Nn, H.setIndex(Qt);
      }
      if (di) {
        if (V && V.isInstancedBufferGeometry & !Ie.isWebGL2 && Ge.get("ANGLE_instanced_arrays") === null)
          console.error(
            "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        else {
          We.initAttributes(), di = V.attributes, Ne = Ne.getAttributes();
          var er = ae.defaultAttributeValues;
          for (Bn in Ne) {
            var yn = Ne[Bn];
            if (0 <= yn) {
              var Vi = di[Bn];
              if (Vi !== void 0) {
                var qn = Vi.normalized, _l = Vi.itemSize, jr = zs.get(Vi);
                if (jr !== void 0) {
                  var xl = jr.buffer, ja = jr.type;
                  if (jr = jr.bytesPerElement, Vi.isInterleavedBufferAttribute) {
                    var Us = Vi.data, Vl = Us.stride;
                    Vi = Vi.offset, Us && Us.isInstancedInterleavedBuffer ? (We.enableAttributeAndDivisor(yn, Us.meshPerAttribute), V.maxInstancedCount === void 0 && (V.maxInstancedCount = Us.meshPerAttribute * Us.count)) : We.enableAttribute(yn), Bt.bindBuffer(34962, xl), Bt.vertexAttribPointer(yn, _l, ja, qn, Vl * jr, Vi * jr);
                  } else
                    Vi.isInstancedBufferAttribute ? (We.enableAttributeAndDivisor(yn, Vi.meshPerAttribute), V.maxInstancedCount === void 0 && (V.maxInstancedCount = Vi.meshPerAttribute * Vi.count)) : We.enableAttribute(yn), Bt.bindBuffer(34962, xl), Bt.vertexAttribPointer(yn, _l, ja, qn, 0, 0);
                }
              } else if (er !== void 0 && (qn = er[Bn], qn !== void 0))
                switch (qn.length) {
                  case 2:
                    Bt.vertexAttrib2fv(yn, qn);
                    break;
                  case 3:
                    Bt.vertexAttrib3fv(yn, qn);
                    break;
                  case 4:
                    Bt.vertexAttrib4fv(yn, qn);
                    break;
                  default:
                    Bt.vertexAttrib1fv(yn, qn);
                }
            }
          }
          We.disableUnusedAttributes();
        }
        le !== null && Bt.bindBuffer(34963, Qt.buffer);
      }
      Qt = 1 / 0, le !== null ? Qt = le.count : zi !== void 0 && (Qt = zi.count), le = V.drawRange.start * tt, zi = Te !== null ? Te.start * tt : 0;
      var Bn = Math.max(le, zi);
      if (Te = Math.max(
        0,
        Math.min(
          Qt,
          le + V.drawRange.count * tt,
          zi + (Te !== null ? Te.count * tt : 1 / 0)
        ) - 1 - Bn + 1
      ), Te !== 0) {
        if (ge.isMesh)
          if (ae.wireframe === !0)
            We.setLineWidth(ae.wireframeLinewidth * (me === null ? Ue : 1)), H.setMode(1);
          else
            switch (ge.drawMode) {
              case 0:
                H.setMode(4);
                break;
              case 1:
                H.setMode(5);
                break;
              case 2:
                H.setMode(6);
            }
        else
          ge.isLine ? (ae = ae.linewidth, ae === void 0 && (ae = 1), We.setLineWidth(ae * (me === null ? Ue : 1)), ge.isLineSegments ? H.setMode(1) : ge.isLineLoop ? H.setMode(2) : H.setMode(3)) : ge.isPoints ? H.setMode(0) : ge.isSprite && H.setMode(4);
        V && V.isInstancedBufferGeometry ? 0 < V.maxInstancedCount && H.renderInstances(V, Bn, Te) : H.render(Bn, Te);
      }
    }, this.compile = function(H, tt) {
      bt = Ko.get(H, tt), bt.init(), H.traverse(function(V) {
        V.isLight && (bt.pushLight(V), V.castShadow && bt.pushShadow(V));
      }), bt.setupLights(tt), H.traverse(function(V) {
        if (V.material)
          if (Array.isArray(V.material))
            for (var ae = 0; ae < V.material.length; ae++)
              d(V.material[ae], H.fog, V);
          else
            d(V.material, H.fog, V);
      });
    };
    var Bs = null, oo = new _();
    oo.setAnimationLoop(function(H) {
      Wr.isPresenting() || Bs && Bs(H);
    }), typeof window < "u" && oo.setContext(window), this.setAnimationLoop = function(H) {
      Bs = H, Wr.setAnimationLoop(H), oo.start();
    }, this.render = function(H, tt, V, ae) {
      if (!tt || !tt.isCamera)
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
      else if (!oe) {
        Ee = e = null, Be = !1, Wt = -1, Ye = null, H.autoUpdate === !0 && H.updateMatrixWorld(), tt.parent === null && tt.updateMatrixWorld(), Wr.enabled && (tt = Wr.getCamera(tt)), bt = Ko.get(H, tt), bt.init(), H.onBeforeRender(St, H, tt, V), pi.multiplyMatrices(tt.projectionMatrix, tt.matrixWorldInverse), Ei.setFromMatrix(pi), He = this.localClippingEnabled, Ce = pe.init(this.clippingPlanes, He, tt), Dt = va.get(H, tt), Dt.init(), c(H, tt, St.sortObjects), St.sortObjects === !0 && Dt.sort(), Ce && pe.beginShadows(), kl.render(bt.state.shadowsArray, H, tt), bt.setupLights(tt), Ce && pe.endShadows(), this.info.autoReset && this.info.reset(), V === void 0 && (V = null), this.setRenderTarget(V), Eo.render(Dt, H, tt, ae), ae = Dt.opaque;
        var ge = Dt.transparent;
        if (H.overrideMaterial) {
          var Te = H.overrideMaterial;
          ae.length && p(ae, H, tt, Te), ge.length && p(ge, H, tt, Te);
        } else
          ae.length && p(ae, H, tt), ge.length && p(ge, H, tt);
        V && ro.updateRenderTargetMipmap(V), We.buffers.depth.setTest(!0), We.buffers.depth.setMask(!0), We.buffers.color.setMask(!0), We.setPolygonOffset(!1), H.onAfterRender(St, H, tt), Wr.enabled && Wr.submitFrame(), bt = Dt = null;
      }
    }, this.allocTextureUnit = function() {
      var H = ki;
      return H >= Ie.maxTextures && console.warn(
        "THREE.WebGLRenderer: Trying to use " + H + " texture units while this GPU supports only " + Ie.maxTextures
      ), ki += 1, H;
    }, this.setTexture2D = function() {
      var H = !1;
      return function(tt, V) {
        tt && tt.isWebGLRenderTarget && (H || (console.warn(
          "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
        ), H = !0), tt = tt.texture), ro.setTexture2D(tt, V);
      };
    }(), this.setTexture3D = function() {
      return function(H, tt) {
        ro.setTexture3D(H, tt);
      };
    }(), this.setTexture = function() {
      var H = !1;
      return function(tt, V) {
        H || (console.warn(
          "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
        ), H = !0), ro.setTexture2D(tt, V);
      };
    }(), this.setTextureCube = function() {
      var H = !1;
      return function(tt, V) {
        tt && tt.isWebGLRenderTargetCube && (H || (console.warn(
          "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ), H = !0), tt = tt.texture), tt && tt.isCubeTexture || Array.isArray(tt.image) && tt.image.length === 6 ? ro.setTextureCube(tt, V) : ro.setTextureCubeDynamic(tt, V);
      };
    }(), this.setFramebuffer = function(H) {
      $t = H;
    }, this.getRenderTarget = function() {
      return me;
    }, this.setRenderTarget = function(H) {
      (me = H) && cn.get(H).__webglFramebuffer === void 0 && ro.setupRenderTarget(H);
      var tt = $t, V = !1;
      H ? (tt = cn.get(H).__webglFramebuffer, H.isWebGLRenderTargetCube && (tt = tt[H.activeCubeFace], V = !0), Ki.copy(H.viewport), Ci.copy(H.scissor), Si = H.scissorTest) : (Ki.copy(yt).multiplyScalar(Ue), Ci.copy(be).multiplyScalar(Ue), Si = Fe), ue !== tt && (Bt.bindFramebuffer(36160, tt), ue = tt), We.viewport(Ki), We.scissor(Ci), We.setScissorTest(Si), V && (V = cn.get(H.texture), Bt.framebufferTexture2D(
        36160,
        36064,
        34069 + H.activeCubeFace,
        V.__webglTexture,
        H.activeMipMapLevel
      ));
    }, this.readRenderTargetPixels = function(H, tt, V, ae, ge, Te) {
      if (H && H.isWebGLRenderTarget) {
        var le = cn.get(H).__webglFramebuffer;
        if (le) {
          var Ne = !1;
          le !== ue && (Bt.bindFramebuffer(36160, le), Ne = !0);
          try {
            var di = H.texture, zi = di.format, Qt = di.type;
            zi !== 1023 && dn.convert(zi) !== Bt.getParameter(35739) ? console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            ) : Qt === 1009 || dn.convert(Qt) === Bt.getParameter(35738) || Qt === 1015 && (Ie.isWebGL2 || Ge.get("OES_texture_float") || Ge.get("WEBGL_color_buffer_float")) || Qt === 1016 && (Ie.isWebGL2 ? Ge.get("EXT_color_buffer_float") : Ge.get("EXT_color_buffer_half_float")) ? Bt.checkFramebufferStatus(36160) === 36053 ? 0 <= tt && tt <= H.width - ae && 0 <= V && V <= H.height - ge && Bt.readPixels(tt, V, ae, ge, dn.convert(zi), dn.convert(Qt), Te) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
            ) : console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          } finally {
            Ne && Bt.bindFramebuffer(36160, ue);
          }
        }
      } else
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
    }, this.copyFramebufferToTexture = function(H, tt, V) {
      var ae = tt.image.width, ge = tt.image.height, Te = dn.convert(tt.format);
      this.setTexture2D(tt, 0), Bt.copyTexImage2D(3553, V || 0, Te, H.x, H.y, ae, ge, 0);
    }, this.copyTextureToTexture = function(H, tt, V, ae) {
      var ge = tt.image.width, Te = tt.image.height, le = dn.convert(V.format), Ne = dn.convert(V.type);
      this.setTexture2D(V, 0), tt.isDataTexture ? Bt.texSubImage2D(3553, ae || 0, H.x, H.y, ge, Te, le, Ne, tt.image.data) : Bt.texSubImage2D(3553, ae || 0, H.x, H.y, le, Ne, tt.image);
    };
  }
  function de(t, e) {
    this.name = "", this.color = new Y(t), this.density = e !== void 0 ? e : 25e-5;
  }
  function sn(t, e, i) {
    this.name = "", this.color = new Y(t), this.near = e !== void 0 ? e : 1, this.far = i !== void 0 ? i : 1e3;
  }
  function An() {
    z.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0;
  }
  function gi(t, e) {
    this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  function vi(t, e, i, n) {
    this.data = t, this.itemSize = e, this.offset = i, this.normalized = n === !0;
  }
  function Ti(t) {
    Oe.call(this), this.type = "SpriteMaterial", this.color = new Y(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t);
  }
  function Gi(t) {
    if (z.call(this), this.type = "Sprite", Ds === void 0) {
      Ds = new Ft();
      var e = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      e = new gi(e, 5), Ds.setIndex([0, 1, 2, 0, 2, 3]), Ds.addAttribute("position", new vi(e, 3, 0, !1)), Ds.addAttribute("uv", new vi(e, 2, 3, !1));
    }
    this.geometry = Ds, this.material = t !== void 0 ? t : new Ti(), this.center = new y(0.5, 0.5);
  }
  function Hi() {
    z.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
  }
  function Wi(t, e) {
    if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), e === void 0)
      this.calculateInverses();
    else if (this.bones.length === e.length)
      this.boneInverses = e.slice(0);
    else
      for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++)
        this.boneInverses.push(new pt());
  }
  function ji() {
    z.call(this), this.type = "Bone";
  }
  function Mi(t, e) {
    Ui.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new pt(), this.bindMatrixInverse = new pt(), t = this.initBones(), t = new Wi(t), this.bind(t, this.matrixWorld), this.normalizeSkinWeights();
  }
  function yi(t) {
    Oe.call(this), this.type = "LineBasicMaterial", this.color = new Y(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t);
  }
  function Pi(t, e, i) {
    i === 1 && console.error(
      "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
    ), z.call(this), this.type = "Line", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new yi({ color: 16777215 * Math.random() });
  }
  function ti(t, e) {
    Pi.call(this, t, e), this.type = "LineSegments";
  }
  function Or(t, e) {
    Pi.call(this, t, e), this.type = "LineLoop";
  }
  function xn(t) {
    Oe.call(this), this.type = "PointsMaterial", this.color = new Y(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(t);
  }
  function cs(t, e) {
    z.call(this), this.type = "Points", this.geometry = t !== void 0 ? t : new Ft(), this.material = e !== void 0 ? e : new xn({ color: 16777215 * Math.random() });
  }
  function Ka(t, e, i, n, o, s, l, h, c) {
    kt.call(this, t, e, i, n, o, s, l, h, c), this.generateMipmaps = !1;
  }
  function ho(t, e, i, n, o, s, l, h, c, p, f, d) {
    kt.call(this, null, s, l, h, c, p, n, o, f, d), this.image = { width: e, height: i }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1;
  }
  function Vs(t, e, i, n, o, s, l, h, c) {
    kt.call(this, t, e, i, n, o, s, l, h, c), this.needsUpdate = !0;
  }
  function Ws(t, e, i, n, o, s, l, h, c, p) {
    if (p = p !== void 0 ? p : 1026, p !== 1026 && p !== 1027)
      throw Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && p === 1026 && (i = 1012), i === void 0 && p === 1027 && (i = 1020), kt.call(this, null, n, o, s, l, h, p, i, c), this.image = { width: t, height: e }, this.magFilter = l !== void 0 ? l : 1003, this.minFilter = h !== void 0 ? h : 1003, this.generateMipmaps = this.flipY = !1;
  }
  function ps(t) {
    Ft.call(this), this.type = "WireframeGeometry";
    var e = [], i, n, o, s = [0, 0], l = {}, h = ["a", "b", "c"];
    if (t && t.isGeometry) {
      var c = t.faces, p = 0;
      for (n = c.length; p < n; p++) {
        var f = c[p];
        for (i = 0; 3 > i; i++) {
          var d = f[h[i]], v = f[h[(i + 1) % 3]];
          s[0] = Math.min(d, v), s[1] = Math.max(d, v), d = s[0] + "," + s[1], l[d] === void 0 && (l[d] = { index1: s[0], index2: s[1] });
        }
      }
      for (d in l)
        p = l[d], h = t.vertices[p.index1], e.push(h.x, h.y, h.z), h = t.vertices[p.index2], e.push(h.x, h.y, h.z);
    } else if (t && t.isBufferGeometry)
      if (h = new S(), t.index !== null) {
        c = t.attributes.position, f = t.index;
        var w = t.groups;
        for (w.length === 0 && (w = [{ start: 0, count: f.count, materialIndex: 0 }]), t = 0, o = w.length; t < o; ++t)
          for (p = w[t], i = p.start, n = p.count, p = i, n = i + n; p < n; p += 3)
            for (i = 0; 3 > i; i++)
              d = f.getX(p + i), v = f.getX(p + (i + 1) % 3), s[0] = Math.min(d, v), s[1] = Math.max(d, v), d = s[0] + "," + s[1], l[d] === void 0 && (l[d] = { index1: s[0], index2: s[1] });
        for (d in l)
          p = l[d], h.fromBufferAttribute(c, p.index1), e.push(h.x, h.y, h.z), h.fromBufferAttribute(c, p.index2), e.push(h.x, h.y, h.z);
      } else
        for (c = t.attributes.position, p = 0, n = c.count / 3; p < n; p++)
          for (i = 0; 3 > i; i++)
            l = 3 * p + i, h.fromBufferAttribute(c, l), e.push(h.x, h.y, h.z), l = 3 * p + (i + 1) % 3, h.fromBufferAttribute(c, l), e.push(h.x, h.y, h.z);
    this.addAttribute("position", new Et(e, 3));
  }
  function js(t, e, i) {
    X.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: i }, this.fromBufferGeometry(new fs(t, e, i)), this.mergeVertices();
  }
  function fs(t, e, i) {
    Ft.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: i };
    var n = [], o = [], s = [], l = [], h = new S(), c = new S(), p = new S(), f = new S(), d = new S(), v, w;
    3 > t.length && console.error(
      "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
    );
    var P = e + 1;
    for (v = 0; v <= i; v++) {
      var R = v / i;
      for (w = 0; w <= e; w++) {
        var I = w / e;
        t(I, R, c), o.push(c.x, c.y, c.z), 0 <= I - 1e-5 ? (t(I - 1e-5, R, p), f.subVectors(c, p)) : (t(I + 1e-5, R, p), f.subVectors(p, c)), 0 <= R - 1e-5 ? (t(I, R - 1e-5, p), d.subVectors(c, p)) : (t(I, R + 1e-5, p), d.subVectors(p, c)), h.crossVectors(f, d).normalize(), s.push(h.x, h.y, h.z), l.push(I, R);
      }
    }
    for (v = 0; v < i; v++)
      for (w = 0; w < e; w++)
        t = v * P + w + 1, h = (v + 1) * P + w + 1, c = (v + 1) * P + w, n.push(v * P + w, t, c), n.push(t, h, c);
    this.setIndex(n), this.addAttribute("position", new Et(o, 3)), this.addAttribute("normal", new Et(s, 3)), this.addAttribute("uv", new Et(l, 2));
  }
  function Li(t, e, i, n) {
    X.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, this.fromBufferGeometry(new ri(t, e, i, n)), this.mergeVertices();
  }
  function ri(t, e, i, n) {
    function o(p) {
      h.push(p.x, p.y, p.z);
    }
    function s(p, f) {
      p *= 3, f.x = t[p + 0], f.y = t[p + 1], f.z = t[p + 2];
    }
    function l(p, f, d, v) {
      0 > v && p.x === 1 && (c[f] = p.x - 1), d.x === 0 && d.z === 0 && (c[f] = v / 2 / Math.PI + 0.5);
    }
    Ft.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, i = i || 1, n = n || 0;
    var h = [], c = [];
    (function(p) {
      for (var f = new S(), d = new S(), v = new S(), w = 0; w < e.length; w += 3) {
        s(e[w + 0], f), s(e[w + 1], d), s(e[w + 2], v);
        var P, R, I = f, Q = d, W = v, st = Math.pow(2, p), K = [];
        for (R = 0; R <= st; R++) {
          K[R] = [];
          var wt = I.clone().lerp(W, R / st), C = Q.clone().lerp(W, R / st), D = st - R;
          for (P = 0; P <= D; P++)
            K[R][P] = P === 0 && R === st ? wt : wt.clone().lerp(C, P / D);
        }
        for (R = 0; R < st; R++)
          for (P = 0; P < 2 * (st - R) - 1; P++)
            I = Math.floor(P / 2), P % 2 === 0 ? (o(K[R][I + 1]), o(K[R + 1][I]), o(K[R][I])) : (o(K[R][I + 1]), o(K[R + 1][I + 1]), o(K[R + 1][I]));
      }
    })(n), function(p) {
      for (var f = new S(), d = 0; d < h.length; d += 3)
        f.x = h[d + 0], f.y = h[d + 1], f.z = h[d + 2], f.normalize().multiplyScalar(p), h[d + 0] = f.x, h[d + 1] = f.y, h[d + 2] = f.z;
    }(i), function() {
      for (var p = new S(), f = 0; f < h.length; f += 3)
        p.x = h[f + 0], p.y = h[f + 1], p.z = h[f + 2], c.push(
          Math.atan2(p.z, -p.x) / 2 / Math.PI + 0.5,
          1 - (Math.atan2(-p.y, Math.sqrt(p.x * p.x + p.z * p.z)) / Math.PI + 0.5)
        );
      p = new S(), f = new S();
      for (var d = new S(), v = new S(), w = new y(), P = new y(), R = new y(), I = 0, Q = 0; I < h.length; I += 9, Q += 6) {
        p.set(h[I + 0], h[I + 1], h[I + 2]), f.set(h[I + 3], h[I + 4], h[I + 5]), d.set(h[I + 6], h[I + 7], h[I + 8]), w.set(c[Q + 0], c[Q + 1]), P.set(c[Q + 2], c[Q + 3]), R.set(c[Q + 4], c[Q + 5]), v.copy(p).add(f).add(d).divideScalar(3);
        var W = Math.atan2(v.z, -v.x);
        l(w, Q + 0, p, W), l(P, Q + 2, f, W), l(R, Q + 4, d, W);
      }
      for (p = 0; p < c.length; p += 6)
        f = c[p + 0], d = c[p + 2], v = c[p + 4], w = Math.min(f, d, v), 0.9 < Math.max(f, d, v) && 0.1 > w && (0.2 > f && (c[p + 0] += 1), 0.2 > d && (c[p + 2] += 1), 0.2 > v && (c[p + 4] += 1));
    }(), this.addAttribute("position", new Et(h, 3)), this.addAttribute("normal", new Et(h.slice(), 3)), this.addAttribute("uv", new Et(c, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Xs(t, e) {
    X.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ds(t, e)), this.mergeVertices();
  }
  function ds(t, e) {
    ri.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function qs(t, e) {
    X.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Ro(t, e)), this.mergeVertices();
  }
  function Ro(t, e) {
    ri.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Ys(t, e) {
    X.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ms(t, e)), this.mergeVertices();
  }
  function ms(t, e) {
    var i = (1 + Math.sqrt(5)) / 2;
    ri.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1
      ],
      [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ],
      t,
      e
    ), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function gs(t, e) {
    X.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new vs(t, e)), this.mergeVertices();
  }
  function vs(t, e) {
    var i = (1 + Math.sqrt(5)) / 2, n = 1 / i;
    ri.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n
      ],
      [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ],
      t,
      e
    ), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e };
  }
  function Ji(t, e, i, n, o, s) {
    X.call(this), this.type = "TubeGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: o
    }, s !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed."), t = new uo(t, e, i, n, o), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices();
  }
  function uo(t, e, i, n, o) {
    function s(Q) {
      f = t.getPointAt(Q / e, f);
      var W = l.normals[Q];
      for (Q = l.binormals[Q], v = 0; v <= n; v++) {
        var st = v / n * Math.PI * 2, K = Math.sin(st);
        st = -Math.cos(st), c.x = st * W.x + K * Q.x, c.y = st * W.y + K * Q.y, c.z = st * W.z + K * Q.z, c.normalize(), P.push(c.x, c.y, c.z), h.x = f.x + i * c.x, h.y = f.y + i * c.y, h.z = f.z + i * c.z, w.push(h.x, h.y, h.z);
      }
    }
    Ft.call(this), this.type = "TubeBufferGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: n,
      closed: o
    }, e = e || 64, i = i || 1, n = n || 8, o = o || !1;
    var l = t.computeFrenetFrames(e, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    var h = new S(), c = new S(), p = new y(), f = new S(), d, v, w = [], P = [], R = [], I = [];
    for (d = 0; d < e; d++)
      s(d);
    for (s(o === !1 ? e : 0), d = 0; d <= e; d++)
      for (v = 0; v <= n; v++)
        p.x = d / e, p.y = v / n, R.push(p.x, p.y);
    (function() {
      for (v = 1; v <= e; v++)
        for (d = 1; d <= n; d++) {
          var Q = (n + 1) * v + (d - 1), W = (n + 1) * v + d, st = (n + 1) * (v - 1) + d;
          I.push((n + 1) * (v - 1) + (d - 1), Q, st), I.push(Q, W, st);
        }
    })(), this.setIndex(I), this.addAttribute("position", new Et(w, 3)), this.addAttribute("normal", new Et(P, 3)), this.addAttribute("uv", new Et(R, 2));
  }
  function _r(t, e, i, n, o, s, l) {
    X.call(this), this.type = "TorusKnotGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: o,
      q: s
    }, l !== void 0 && console.warn(
      "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
    ), this.fromBufferGeometry(new bo(t, e, i, n, o, s)), this.mergeVertices();
  }
  function bo(t, e, i, n, o, s) {
    function l(C, D, ct, Dt, bt) {
      var St = Math.sin(C);
      D = ct / D * C, ct = Math.cos(D), bt.x = Dt * (2 + ct) * 0.5 * Math.cos(C), bt.y = Dt * (2 + ct) * St * 0.5, bt.z = Dt * Math.sin(D) * 0.5;
    }
    Ft.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: n,
      p: o,
      q: s
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, s = s || 3;
    var h = [], c = [], p = [], f = [], d, v = new S(), w = new S(), P = new S(), R = new S(), I = new S(), Q = new S(), W = new S();
    for (d = 0; d <= i; ++d) {
      var st = d / i * o * Math.PI * 2;
      for (l(st, o, s, t, P), l(st + 0.01, o, s, t, R), Q.subVectors(R, P), W.addVectors(R, P), I.crossVectors(Q, W), W.crossVectors(I, Q), I.normalize(), W.normalize(), st = 0; st <= n; ++st) {
        var K = st / n * Math.PI * 2, wt = -e * Math.cos(K);
        K = e * Math.sin(K), v.x = P.x + (wt * W.x + K * I.x), v.y = P.y + (wt * W.y + K * I.y), v.z = P.z + (wt * W.z + K * I.z), c.push(v.x, v.y, v.z), w.subVectors(v, P).normalize(), p.push(w.x, w.y, w.z), f.push(d / i), f.push(st / n);
      }
    }
    for (st = 1; st <= i; st++)
      for (d = 1; d <= n; d++)
        t = (n + 1) * st + (d - 1), e = (n + 1) * st + d, o = (n + 1) * (st - 1) + d, h.push((n + 1) * (st - 1) + (d - 1), t, o), h.push(t, e, o);
    this.setIndex(h), this.addAttribute("position", new Et(c, 3)), this.addAttribute("normal", new Et(p, 3)), this.addAttribute("uv", new Et(f, 2));
  }
  function Oo(t, e, i, n, o) {
    X.call(this), this.type = "TorusGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: o
    }, this.fromBufferGeometry(new wn(t, e, i, n, o)), this.mergeVertices();
  }
  function wn(t, e, i, n, o) {
    Ft.call(this), this.type = "TorusBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: n,
      arc: o
    }, t = t || 1, e = e || 0.4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
    var s = [], l = [], h = [], c = [], p = new S(), f = new S(), d = new S(), v, w;
    for (v = 0; v <= i; v++)
      for (w = 0; w <= n; w++) {
        var P = w / n * o, R = v / i * Math.PI * 2;
        f.x = (t + e * Math.cos(R)) * Math.cos(P), f.y = (t + e * Math.cos(R)) * Math.sin(P), f.z = e * Math.sin(R), l.push(f.x, f.y, f.z), p.x = t * Math.cos(P), p.y = t * Math.sin(P), d.subVectors(f, p).normalize(), h.push(d.x, d.y, d.z), c.push(w / n), c.push(v / i);
      }
    for (v = 1; v <= i; v++)
      for (w = 1; w <= n; w++)
        t = (n + 1) * (v - 1) + w - 1, e = (n + 1) * (v - 1) + w, o = (n + 1) * v + w, s.push((n + 1) * v + w - 1, t, o), s.push(t, e, o);
    this.setIndex(s), this.addAttribute("position", new Et(l, 3)), this.addAttribute("normal", new Et(h, 3)), this.addAttribute("uv", new Et(c, 2));
  }
  function tl(t, e, i, n, o) {
    for (var s, l = 0, h = e, c = i - n; h < i; h += n)
      l += (t[c] - t[h]) * (t[h + 1] + t[c + 1]), c = h;
    if (o === 0 < l)
      for (o = e; o < i; o += n)
        s = La(o, t[o], t[o + 1], s);
    else
      for (o = i - n; o >= e; o -= n)
        s = La(o, t[o], t[o + 1], s);
    return s && Io(s, s.next) && (Ri(s), s = s.next), s;
  }
  function ys(t, e) {
    if (!t)
      return t;
    e || (e = t);
    do {
      var i = !1;
      if (t.steiner || !Io(t, t.next) && Di(t.prev, t, t.next) !== 0)
        t = t.next;
      else {
        if (Ri(t), t = e = t.prev, t === t.next)
          break;
        i = !0;
      }
    } while (i || t !== e);
    return e;
  }
  function _s(t, e, i, n, o, s, l) {
    if (t) {
      if (!l && s) {
        var h = t, c = h;
        do
          c.z === null && (c.z = Aa(c.x, c.y, n, o, s)), c.prevZ = c.prev, c = c.nextZ = c.next;
        while (c !== h);
        c.prevZ.nextZ = null, c.prevZ = null, h = c;
        var p, f, d, v, w = 1;
        do {
          c = h;
          var P = h = null;
          for (f = 0; c; ) {
            f++;
            var R = c;
            for (p = d = 0; p < w && (d++, R = R.nextZ, R); p++)
              ;
            for (v = w; 0 < d || 0 < v && R; )
              d !== 0 && (v === 0 || !R || c.z <= R.z) ? (p = c, c = c.nextZ, d--) : (p = R, R = R.nextZ, v--), P ? P.nextZ = p : h = p, p.prevZ = P, P = p;
            c = R;
          }
          P.nextZ = null, w *= 2;
        } while (1 < f);
      }
      for (h = t; t.prev !== t.next; ) {
        if (c = t.prev, R = t.next, s)
          t: {
            P = t, v = n;
            var I = o, Q = s;
            if (f = P.prev, d = P, w = P.next, 0 <= Di(f, d, w))
              P = !1;
            else {
              var W = f.x > d.x ? f.x > w.x ? f.x : w.x : d.x > w.x ? d.x : w.x, st = f.y > d.y ? f.y > w.y ? f.y : w.y : d.y > w.y ? d.y : w.y;
              for (p = Aa(
                f.x < d.x ? f.x < w.x ? f.x : w.x : d.x < w.x ? d.x : w.x,
                f.y < d.y ? f.y < w.y ? f.y : w.y : d.y < w.y ? d.y : w.y,
                v,
                I,
                Q
              ), v = Aa(W, st, v, I, Q), I = P.nextZ; I && I.z <= v; ) {
                if (I !== P.prev && I !== P.next && Pa(f.x, f.y, d.x, d.y, w.x, w.y, I.x, I.y) && 0 <= Di(I.prev, I, I.next)) {
                  P = !1;
                  break t;
                }
                I = I.nextZ;
              }
              for (I = P.prevZ; I && I.z >= p; ) {
                if (I !== P.prev && I !== P.next && Pa(f.x, f.y, d.x, d.y, w.x, w.y, I.x, I.y) && 0 <= Di(I.prev, I, I.next)) {
                  P = !1;
                  break t;
                }
                I = I.prevZ;
              }
              P = !0;
            }
          }
        else
          t:
            if (P = t, f = P.prev, d = P, w = P.next, 0 <= Di(f, d, w))
              P = !1;
            else {
              for (p = P.next.next; p !== P.prev; ) {
                if (Pa(f.x, f.y, d.x, d.y, w.x, w.y, p.x, p.y) && 0 <= Di(p.prev, p, p.next)) {
                  P = !1;
                  break t;
                }
                p = p.next;
              }
              P = !0;
            }
        if (P)
          e.push(c.i / i), e.push(t.i / i), e.push(R.i / i), Ri(t), h = t = R.next;
        else if (t = R, t === h) {
          if (!l)
            _s(ys(t), e, i, n, o, s, 1);
          else if (l === 1) {
            l = e, h = i, c = t;
            do
              R = c.prev, P = c.next.next, !Io(R, P) && el(R, c, c.next, P) && sr(R, P) && sr(P, R) && (l.push(R.i / h), l.push(c.i / h), l.push(P.i / h), Ri(c), Ri(c.next), c = t = P), c = c.next;
            while (c !== t);
            t = c, _s(t, e, i, n, o, s, 2);
          } else if (l === 2)
            t: {
              l = t;
              do {
                for (h = l.next.next; h !== l.prev; ) {
                  if (c = l.i !== h.i) {
                    if (c = l, R = h, P = c.next.i !== R.i && c.prev.i !== R.i) {
                      e: {
                        P = c;
                        do {
                          if (P.i !== c.i && P.next.i !== c.i && P.i !== R.i && P.next.i !== R.i && el(P, P.next, c, R)) {
                            P = !0;
                            break e;
                          }
                          P = P.next;
                        } while (P !== c);
                        P = !1;
                      }
                      P = !P;
                    }
                    if (P = P && sr(c, R) && sr(R, c)) {
                      P = c, f = !1, d = (c.x + R.x) / 2, R = (c.y + R.y) / 2;
                      do
                        P.y > R != P.next.y > R && P.next.y !== P.y && d < (P.next.x - P.x) * (R - P.y) / (P.next.y - P.y) + P.x && (f = !f), P = P.next;
                      while (P !== c);
                      P = f;
                    }
                    c = P;
                  }
                  if (c) {
                    t = Zs(l, h), l = ys(l, l.next), t = ys(t, t.next), _s(l, e, i, n, o, s), _s(t, e, i, n, o, s);
                    break t;
                  }
                  h = h.next;
                }
                l = l.next;
              } while (l !== t);
            }
          break;
        }
      }
    }
  }
  function El(t, e) {
    return t.x - e.x;
  }
  function Al(t, e) {
    var i = e, n = t.x, o = t.y, s = -1 / 0;
    do {
      if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
        var l = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
        if (l <= n && l > s) {
          if (s = l, l === n) {
            if (o === i.y)
              return i;
            if (o === i.next.y)
              return i.next;
          }
          var h = i.x < i.next.x ? i : i.next;
        }
      }
      i = i.next;
    } while (i !== e);
    if (!h)
      return null;
    if (n === s)
      return h.prev;
    e = h, l = h.x;
    var c = h.y, p = 1 / 0;
    for (i = h.next; i !== e; ) {
      if (n >= i.x && i.x >= l && n !== i.x && Pa(o < c ? n : s, o, l, c, o < c ? s : n, o, i.x, i.y)) {
        var f = Math.abs(o - i.y) / (n - i.x);
        (f < p || f === p && i.x > h.x) && sr(i, t) && (h = i, p = f);
      }
      i = i.next;
    }
    return h;
  }
  function Aa(t, e, i, n, o) {
    return t = 32767 * (t - i) * o, e = 32767 * (e - n) * o, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, (t | t << 1) & 1431655765 | ((e | e << 1) & 1431655765) << 1;
  }
  function $n(t) {
    var e = t, i = t;
    do
      e.x < i.x && (i = e), e = e.next;
    while (e !== t);
    return i;
  }
  function Pa(t, e, i, n, o, s, l, h) {
    return 0 <= (o - l) * (e - h) - (t - l) * (s - h) && 0 <= (t - l) * (n - h) - (i - l) * (e - h) && 0 <= (i - l) * (s - h) - (o - l) * (n - h);
  }
  function Di(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function Io(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function el(t, e, i, n) {
    return Io(t, e) && Io(i, n) || Io(t, n) && Io(i, e) ? !0 : 0 < Di(t, e, i) != 0 < Di(t, e, n) && 0 < Di(i, n, t) != 0 < Di(i, n, e);
  }
  function sr(t, e) {
    return 0 > Di(t.prev, t, t.next) ? 0 <= Di(t, e, t.next) && 0 <= Di(t, t.prev, e) : 0 > Di(t, e, t.prev) || 0 > Di(t, t.next, e);
  }
  function Zs(t, e) {
    var i = new Ir(t.i, t.x, t.y), n = new Ir(e.i, e.x, e.y), o = t.next, s = e.prev;
    return t.next = e, e.prev = t, i.next = o, o.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n;
  }
  function La(t, e, i, n) {
    return t = new Ir(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t;
  }
  function Ri(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function Ir(t, e, i) {
    this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1;
  }
  function Ca(t) {
    var e = t.length;
    2 < e && t[e - 1].equals(t[0]) && t.pop();
  }
  function Pl(t, e) {
    for (var i = 0; i < e.length; i++)
      t.push(e[i].x), t.push(e[i].y);
  }
  function Zr(t, e) {
    X.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new Dr(t, e)), this.mergeVertices();
  }
  function Dr(t, e) {
    function i(c) {
      function p(Ce, He, pi) {
        return He || console.error("THREE.ExtrudeGeometry: vec does not exist"), He.clone().multiplyScalar(pi).add(Ce);
      }
      function f(Ce, He, pi) {
        var hi = Ce.x - He.x, Bt = Ce.y - He.y, Ge = pi.x - Ce.x, Ie = pi.y - Ce.y, We = hi * hi + Bt * Bt;
        if (Math.abs(hi * Ie - Bt * Ge) > Number.EPSILON) {
          var tn = Math.sqrt(We), cn = Math.sqrt(Ge * Ge + Ie * Ie);
          if (We = He.x - Bt / tn, He = He.y + hi / tn, Ie = ((pi.x - Ie / cn - We) * Ie - (pi.y + Ge / cn - He) * Ge) / (hi * Ie - Bt * Ge), Ge = We + hi * Ie - Ce.x, hi = He + Bt * Ie - Ce.y, Bt = Ge * Ge + hi * hi, 2 >= Bt)
            return new y(Ge, hi);
          Bt = Math.sqrt(Bt / 2);
        } else
          Ce = !1, hi > Number.EPSILON ? Ge > Number.EPSILON && (Ce = !0) : hi < -Number.EPSILON ? Ge < -Number.EPSILON && (Ce = !0) : Math.sign(Bt) === Math.sign(Ie) && (Ce = !0), Ce ? (Ge = -Bt, Bt = Math.sqrt(We)) : (Ge = hi, hi = Bt, Bt = Math.sqrt(We / 2));
        return new y(Ge / Bt, hi / Bt);
      }
      function d(Ce, He) {
        for (ce = Ce.length; 0 <= --ce; ) {
          var pi = ce, hi = ce - 1;
          0 > hi && (hi = Ce.length - 1);
          var Bt, Ge = W + 2 * D;
          for (Bt = 0; Bt < Ge; Bt++) {
            var Ie = Si * Bt, We = Si * (Bt + 1), tn = He + hi + Ie, cn = He + hi + We;
            We = He + pi + We, P(He + pi + Ie), P(tn), P(We), P(tn), P(cn), P(We), Ie = o.length / 3, Ie = Dt.generateSideWallUV(n, o, Ie - 6, Ie - 3, Ie - 2, Ie - 1), R(Ie[0]), R(Ie[1]), R(Ie[3]), R(Ie[1]), R(Ie[2]), R(Ie[3]);
          }
        }
      }
      function v(Ce, He, pi) {
        I.push(Ce), I.push(He), I.push(pi);
      }
      function w(Ce, He, pi) {
        P(Ce), P(He), P(pi), Ce = o.length / 3, Ce = Dt.generateTopUV(n, o, Ce - 3, Ce - 2, Ce - 1), R(Ce[0]), R(Ce[1]), R(Ce[2]);
      }
      function P(Ce) {
        o.push(I[3 * Ce]), o.push(I[3 * Ce + 1]), o.push(I[3 * Ce + 2]);
      }
      function R(Ce) {
        s.push(Ce.x), s.push(Ce.y);
      }
      var I = [], Q = e.curveSegments !== void 0 ? e.curveSegments : 12, W = e.steps !== void 0 ? e.steps : 1, st = e.depth !== void 0 ? e.depth : 100, K = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, wt = e.bevelThickness !== void 0 ? e.bevelThickness : 6, C = e.bevelSize !== void 0 ? e.bevelSize : wt - 2, D = e.bevelSegments !== void 0 ? e.bevelSegments : 3, ct = e.extrudePath, Dt = e.UVGenerator !== void 0 ? e.UVGenerator : da;
      e.amount !== void 0 && (console.warn(
        "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
      ), st = e.amount);
      var bt = !1;
      if (ct) {
        var St = ct.getSpacedPoints(W);
        bt = !0, K = !1;
        var oe = ct.computeFrenetFrames(W, !1), $t = new S(), me = new S(), ue = new S();
      }
      K || (C = wt = D = 0);
      var Wt;
      Q = c.extractPoints(Q), c = Q.shape;
      var Ee = Q.holes;
      if (!kr.isClockWise(c)) {
        c = c.reverse();
        var Be = 0;
        for (Wt = Ee.length; Be < Wt; Be++) {
          var Ye = Ee[Be];
          kr.isClockWise(Ye) && (Ee[Be] = Ye.reverse());
        }
      }
      var hn = kr.triangulateShape(c, Ee), Ki = c;
      for (Be = 0, Wt = Ee.length; Be < Wt; Be++)
        Ye = Ee[Be], c = c.concat(Ye);
      var Ci, Si = c.length, ki, un = hn.length;
      Q = [];
      var ce = 0, Ue = Ki.length, yt = Ue - 1;
      for (Ci = ce + 1; ce < Ue; ce++, yt++, Ci++)
        yt === Ue && (yt = 0), Ci === Ue && (Ci = 0), Q[ce] = f(Ki[ce], Ki[yt], Ki[Ci]);
      ct = [];
      var be = Q.concat();
      for (Be = 0, Wt = Ee.length; Be < Wt; Be++) {
        Ye = Ee[Be];
        var Fe = [];
        for (ce = 0, Ue = Ye.length, yt = Ue - 1, Ci = ce + 1; ce < Ue; ce++, yt++, Ci++)
          yt === Ue && (yt = 0), Ci === Ue && (Ci = 0), Fe[ce] = f(Ye[ce], Ye[yt], Ye[Ci]);
        ct.push(Fe), be = be.concat(Fe);
      }
      for (yt = 0; yt < D; yt++) {
        Ue = yt / D;
        var Ei = wt * Math.cos(Ue * Math.PI / 2);
        for (Ci = C * Math.sin(Ue * Math.PI / 2), ce = 0, Ue = Ki.length; ce < Ue; ce++) {
          var pe = p(Ki[ce], Q[ce], Ci);
          v(pe.x, pe.y, -Ei);
        }
        for (Be = 0, Wt = Ee.length; Be < Wt; Be++)
          for (Ye = Ee[Be], Fe = ct[Be], ce = 0, Ue = Ye.length; ce < Ue; ce++)
            pe = p(Ye[ce], Fe[ce], Ci), v(pe.x, pe.y, -Ei);
      }
      for (Ci = C, ce = 0; ce < Si; ce++)
        pe = K ? p(c[ce], be[ce], Ci) : c[ce], bt ? (me.copy(oe.normals[0]).multiplyScalar(pe.x), $t.copy(oe.binormals[0]).multiplyScalar(pe.y), ue.copy(St[0]).add(me).add($t), v(ue.x, ue.y, ue.z)) : v(pe.x, pe.y, 0);
      for (Ue = 1; Ue <= W; Ue++)
        for (ce = 0; ce < Si; ce++)
          pe = K ? p(c[ce], be[ce], Ci) : c[ce], bt ? (me.copy(oe.normals[Ue]).multiplyScalar(pe.x), $t.copy(oe.binormals[Ue]).multiplyScalar(pe.y), ue.copy(St[Ue]).add(me).add($t), v(ue.x, ue.y, ue.z)) : v(pe.x, pe.y, st / W * Ue);
      for (yt = D - 1; 0 <= yt; yt--) {
        for (Ue = yt / D, Ei = wt * Math.cos(Ue * Math.PI / 2), Ci = C * Math.sin(Ue * Math.PI / 2), ce = 0, Ue = Ki.length; ce < Ue; ce++)
          pe = p(Ki[ce], Q[ce], Ci), v(pe.x, pe.y, st + Ei);
        for (Be = 0, Wt = Ee.length; Be < Wt; Be++)
          for (Ye = Ee[Be], Fe = ct[Be], ce = 0, Ue = Ye.length; ce < Ue; ce++)
            pe = p(Ye[ce], Fe[ce], Ci), bt ? v(pe.x, pe.y + St[W - 1].y, St[W - 1].x + Ei) : v(pe.x, pe.y, st + Ei);
      }
      (function() {
        var Ce = o.length / 3;
        if (K) {
          var He = 0 * Si;
          for (ce = 0; ce < un; ce++)
            ki = hn[ce], w(ki[2] + He, ki[1] + He, ki[0] + He);
          for (He = Si * (W + 2 * D), ce = 0; ce < un; ce++)
            ki = hn[ce], w(ki[0] + He, ki[1] + He, ki[2] + He);
        } else {
          for (ce = 0; ce < un; ce++)
            ki = hn[ce], w(ki[2], ki[1], ki[0]);
          for (ce = 0; ce < un; ce++)
            ki = hn[ce], w(ki[0] + Si * W, ki[1] + Si * W, ki[2] + Si * W);
        }
        n.addGroup(Ce, o.length / 3 - Ce, 0);
      })(), function() {
        var Ce = o.length / 3, He = 0;
        for (d(Ki, He), He += Ki.length, Be = 0, Wt = Ee.length; Be < Wt; Be++)
          Ye = Ee[Be], d(Ye, He), He += Ye.length;
        n.addGroup(Ce, o.length / 3 - Ce, 1);
      }();
    }
    Ft.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
    for (var n = this, o = [], s = [], l = 0, h = t.length; l < h; l++)
      i(t[l]);
    this.addAttribute("position", new Et(o, 3)), this.addAttribute("uv", new Et(s, 2)), this.computeVertexNormals();
  }
  function Ll(t, e, i) {
    if (i.shapes = [], Array.isArray(t))
      for (var n = 0, o = t.length; n < o; n++)
        i.shapes.push(t[n].uuid);
    else
      i.shapes.push(t.uuid);
    return e.extrudePath !== void 0 && (i.options.extrudePath = e.extrudePath.toJSON()), i;
  }
  function Js(t, e) {
    X.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Do(t, e)), this.mergeVertices();
  }
  function Do(t, e) {
    e = e || {};
    var i = e.font;
    if (!i || !i.isFont)
      return console.error(
        "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
      ), new X();
    t = i.generateShapes(t, e.size), e.depth = e.height !== void 0 ? e.height : 50, e.bevelThickness === void 0 && (e.bevelThickness = 10), e.bevelSize === void 0 && (e.bevelSize = 8), e.bevelEnabled === void 0 && (e.bevelEnabled = !1), Dr.call(this, t, e), this.type = "TextBufferGeometry";
  }
  function co(t, e, i, n, o, s, l) {
    X.call(this), this.type = "SphereGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: o,
      thetaStart: s,
      thetaLength: l
    }, this.fromBufferGeometry(new ar(t, e, i, n, o, s, l)), this.mergeVertices();
  }
  function ar(t, e, i, n, o, s, l) {
    Ft.call(this), this.type = "SphereBufferGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: n,
      phiLength: o,
      thetaStart: s,
      thetaLength: l
    }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = n !== void 0 ? n : 0, o = o !== void 0 ? o : 2 * Math.PI, s = s !== void 0 ? s : 0, l = l !== void 0 ? l : Math.PI;
    var h = s + l, c, p, f = 0, d = [], v = new S(), w = new S(), P = [], R = [], I = [], Q = [];
    for (p = 0; p <= i; p++) {
      var W = [], st = p / i;
      for (c = 0; c <= e; c++) {
        var K = c / e;
        v.x = -t * Math.cos(n + K * o) * Math.sin(s + st * l), v.y = t * Math.cos(s + st * l), v.z = t * Math.sin(n + K * o) * Math.sin(s + st * l), R.push(v.x, v.y, v.z), w.set(v.x, v.y, v.z).normalize(), I.push(w.x, w.y, w.z), Q.push(K, 1 - st), W.push(f++);
      }
      d.push(W);
    }
    for (p = 0; p < i; p++)
      for (c = 0; c < e; c++)
        t = d[p][c + 1], n = d[p][c], o = d[p + 1][c], l = d[p + 1][c + 1], (p !== 0 || 0 < s) && P.push(t, n, l), (p !== i - 1 || h < Math.PI) && P.push(n, o, l);
    this.setIndex(P), this.addAttribute("position", new Et(R, 3)), this.addAttribute("normal", new Et(I, 3)), this.addAttribute("uv", new Et(Q, 2));
  }
  function $s(t, e, i, n, o, s) {
    X.call(this), this.type = "RingGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: o,
      thetaLength: s
    }, this.fromBufferGeometry(new zo(t, e, i, n, o, s)), this.mergeVertices();
  }
  function zo(t, e, i, n, o, s) {
    Ft.call(this), this.type = "RingBufferGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: o,
      thetaLength: s
    }, t = t || 0.5, e = e || 1, o = o !== void 0 ? o : 0, s = s !== void 0 ? s : 2 * Math.PI, i = i !== void 0 ? Math.max(3, i) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
    var l = [], h = [], c = [], p = [], f = t, d = (e - t) / n, v = new S(), w = new y(), P, R;
    for (P = 0; P <= n; P++) {
      for (R = 0; R <= i; R++)
        t = o + R / i * s, v.x = f * Math.cos(t), v.y = f * Math.sin(t), h.push(v.x, v.y, v.z), c.push(0, 0, 1), w.x = (v.x / e + 1) / 2, w.y = (v.y / e + 1) / 2, p.push(w.x, w.y);
      f += d;
    }
    for (P = 0; P < n; P++)
      for (e = P * (i + 1), R = 0; R < i; R++)
        t = R + e, o = t + i + 1, s = t + i + 2, f = t + 1, l.push(t, o, f), l.push(o, s, f);
    this.setIndex(l), this.addAttribute("position", new Et(h, 3)), this.addAttribute("normal", new Et(c, 3)), this.addAttribute("uv", new Et(p, 2));
  }
  function xs(t, e, i, n) {
    X.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, this.fromBufferGeometry(new po(t, e, i, n)), this.mergeVertices();
  }
  function po(t, e, i, n) {
    Ft.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = Je.clamp(n, 0, 2 * Math.PI);
    var o = [], s = [], l = [], h = 1 / e, c = new S(), p = new y(), f;
    for (f = 0; f <= e; f++) {
      var d = i + f * h * n, v = Math.sin(d), w = Math.cos(d);
      for (d = 0; d <= t.length - 1; d++)
        c.x = t[d].x * v, c.y = t[d].y, c.z = t[d].x * w, s.push(c.x, c.y, c.z), p.x = f / e, p.y = d / (t.length - 1), l.push(p.x, p.y);
    }
    for (f = 0; f < e; f++)
      for (d = 0; d < t.length - 1; d++)
        i = d + f * t.length, h = i + t.length, c = i + t.length + 1, p = i + 1, o.push(i, h, p), o.push(h, c, p);
    if (this.setIndex(o), this.addAttribute("position", new Et(s, 3)), this.addAttribute("uv", new Et(l, 2)), this.computeVertexNormals(), n === 2 * Math.PI)
      for (n = this.attributes.normal.array, o = new S(), s = new S(), l = new S(), i = e * t.length * 3, d = f = 0; f < t.length; f++, d += 3)
        o.x = n[d + 0], o.y = n[d + 1], o.z = n[d + 2], s.x = n[i + d + 0], s.y = n[i + d + 1], s.z = n[i + d + 2], l.addVectors(o, s).normalize(), n[d + 0] = n[i + d + 0] = l.x, n[d + 1] = n[i + d + 1] = l.y, n[d + 2] = n[i + d + 2] = l.z;
  }
  function Jr(t, e) {
    X.call(this), this.type = "ShapeGeometry", typeof e == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new fo(t, e)), this.mergeVertices();
  }
  function fo(t, e) {
    function i(f) {
      var d, v = o.length / 3;
      f = f.extractPoints(e);
      var w = f.shape, P = f.holes;
      if (kr.isClockWise(w) === !1)
        for (w = w.reverse(), f = 0, d = P.length; f < d; f++) {
          var R = P[f];
          kr.isClockWise(R) === !0 && (P[f] = R.reverse());
        }
      var I = kr.triangulateShape(w, P);
      for (f = 0, d = P.length; f < d; f++)
        R = P[f], w = w.concat(R);
      for (f = 0, d = w.length; f < d; f++)
        R = w[f], o.push(R.x, R.y, 0), s.push(0, 0, 1), l.push(R.x, R.y);
      for (f = 0, d = I.length; f < d; f++)
        w = I[f], n.push(w[0] + v, w[1] + v, w[2] + v), c += 3;
    }
    Ft.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12;
    var n = [], o = [], s = [], l = [], h = 0, c = 0;
    if (Array.isArray(t) === !1)
      i(t);
    else
      for (var p = 0; p < t.length; p++)
        i(t[p]), this.addGroup(h, c, p), h += c, c = 0;
    this.setIndex(n), this.addAttribute("position", new Et(o, 3)), this.addAttribute("normal", new Et(s, 3)), this.addAttribute("uv", new Et(l, 2));
  }
  function Cl(t, e) {
    if (e.shapes = [], Array.isArray(t))
      for (var i = 0, n = t.length; i < n; i++)
        e.shapes.push(t[i].uuid);
    else
      e.shapes.push(t.uuid);
    return e;
  }
  function mo(t, e) {
    Ft.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e };
    var i = [];
    e = Math.cos(Je.DEG2RAD * (e !== void 0 ? e : 1));
    var n = [0, 0], o = {}, s = ["a", "b", "c"];
    if (t.isBufferGeometry) {
      var l = new X();
      l.fromBufferGeometry(t);
    } else
      l = t.clone();
    l.mergeVertices(), l.computeFaceNormals(), t = l.vertices, l = l.faces;
    for (var h = 0, c = l.length; h < c; h++)
      for (var p = l[h], f = 0; 3 > f; f++) {
        var d = p[s[f]], v = p[s[(f + 1) % 3]];
        n[0] = Math.min(d, v), n[1] = Math.max(d, v), d = n[0] + "," + n[1], o[d] === void 0 ? o[d] = { index1: n[0], index2: n[1], face1: h, face2: void 0 } : o[d].face2 = h;
      }
    for (d in o)
      n = o[d], (n.face2 === void 0 || l[n.face1].normal.dot(l[n.face2].normal) <= e) && (s = t[n.index1], i.push(s.x, s.y, s.z), s = t[n.index2], i.push(s.x, s.y, s.z));
    this.addAttribute("position", new Et(i, 3));
  }
  function $r(t, e, i, n, o, s, l, h) {
    X.call(this), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: o,
      openEnded: s,
      thetaStart: l,
      thetaLength: h
    }, this.fromBufferGeometry(new Qr(t, e, i, n, o, s, l, h)), this.mergeVertices();
  }
  function Qr(t, e, i, n, o, s, l, h) {
    function c(W) {
      var st, K = new y(), wt = new S(), C = 0, D = W === !0 ? t : e, ct = W === !0 ? 1 : -1, Dt = P;
      for (st = 1; st <= n; st++)
        d.push(0, I * ct, 0), v.push(0, ct, 0), w.push(0.5, 0.5), P++;
      var bt = P;
      for (st = 0; st <= n; st++) {
        var St = st / n * h + l, oe = Math.cos(St);
        St = Math.sin(St), wt.x = D * St, wt.y = I * ct, wt.z = D * oe, d.push(wt.x, wt.y, wt.z), v.push(0, ct, 0), K.x = 0.5 * oe + 0.5, K.y = 0.5 * St * ct + 0.5, w.push(K.x, K.y), P++;
      }
      for (st = 0; st < n; st++)
        K = Dt + st, wt = bt + st, W === !0 ? f.push(wt, wt + 1, K) : f.push(wt + 1, wt, K), C += 3;
      p.addGroup(Q, C, W === !0 ? 1 : 2), Q += C;
    }
    Ft.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: n,
      heightSegments: o,
      openEnded: s,
      thetaStart: l,
      thetaLength: h
    };
    var p = this;
    t = t !== void 0 ? t : 1, e = e !== void 0 ? e : 1, i = i || 1, n = Math.floor(n) || 8, o = Math.floor(o) || 1, s = s !== void 0 ? s : !1, l = l !== void 0 ? l : 0, h = h !== void 0 ? h : 2 * Math.PI;
    var f = [], d = [], v = [], w = [], P = 0, R = [], I = i / 2, Q = 0;
    (function() {
      var W, st, K = new S(), wt = new S(), C = 0, D = (e - t) / i;
      for (st = 0; st <= o; st++) {
        var ct = [], Dt = st / o, bt = Dt * (e - t) + t;
        for (W = 0; W <= n; W++) {
          var St = W / n, oe = St * h + l, $t = Math.sin(oe);
          oe = Math.cos(oe), wt.x = bt * $t, wt.y = -Dt * i + I, wt.z = bt * oe, d.push(wt.x, wt.y, wt.z), K.set($t, D, oe).normalize(), v.push(K.x, K.y, K.z), w.push(St, 1 - Dt), ct.push(P++);
        }
        R.push(ct);
      }
      for (W = 0; W < n; W++)
        for (st = 0; st < o; st++)
          K = R[st + 1][W], wt = R[st + 1][W + 1], D = R[st][W + 1], f.push(R[st][W], K, D), f.push(K, wt, D), C += 6;
      p.addGroup(Q, C, 0), Q += C;
    })(), s === !1 && (0 < t && c(!0), 0 < e && c(!1)), this.setIndex(f), this.addAttribute("position", new Et(d, 3)), this.addAttribute("normal", new Et(v, 3)), this.addAttribute("uv", new Et(w, 2));
  }
  function ws(t, e, i, n, o, s, l) {
    $r.call(this, 0, t, e, i, n, o, s, l), this.type = "ConeGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: o,
      thetaStart: s,
      thetaLength: l
    };
  }
  function Mn(t, e, i, n, o, s, l) {
    Qr.call(this, 0, t, e, i, n, o, s, l), this.type = "ConeBufferGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: n,
      openEnded: o,
      thetaStart: s,
      thetaLength: l
    };
  }
  function No(t, e, i, n) {
    X.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new zr(t, e, i, n)), this.mergeVertices();
  }
  function zr(t, e, i, n) {
    Ft.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, t = t || 1, e = e !== void 0 ? Math.max(3, e) : 8, i = i !== void 0 ? i : 0, n = n !== void 0 ? n : 2 * Math.PI;
    var o = [], s = [], l = [], h = [], c, p = new S(), f = new y();
    s.push(0, 0, 0), l.push(0, 0, 1), h.push(0.5, 0.5);
    var d = 0;
    for (c = 3; d <= e; d++, c += 3) {
      var v = i + d / e * n;
      p.x = t * Math.cos(v), p.y = t * Math.sin(v), s.push(p.x, p.y, p.z), l.push(0, 0, 1), f.x = (s[c] / t + 1) / 2, f.y = (s[c + 1] / t + 1) / 2, h.push(f.x, f.y);
    }
    for (c = 1; c <= e; c++)
      o.push(c, c + 1, 0);
    this.setIndex(o), this.addAttribute("position", new Et(s, 3)), this.addAttribute("normal", new Et(l, 3)), this.addAttribute("uv", new Et(h, 2));
  }
  function go(t) {
    Oe.call(this), this.type = "ShadowMaterial", this.color = new Y(0), this.transparent = !0, this.setValues(t);
  }
  function Bo(t) {
    Ai.call(this, t), this.type = "RawShaderMaterial";
  }
  function Nr(t) {
    Oe.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Y(16777215), this.metalness = this.roughness = 0.5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Y(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Uo(t) {
    Nr.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t);
  }
  function xr(t) {
    Oe.call(this), this.type = "MeshPhongMaterial", this.color = new Y(16777215), this.specular = new Y(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Y(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Fo(t) {
    xr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t);
  }
  function Go(t) {
    Oe.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t);
  }
  function lr(t) {
    Oe.call(this), this.type = "MeshLambertMaterial", this.color = new Y(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Y(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t);
  }
  function Ho(t) {
    if (Oe.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Y(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t), this.matcap === null) {
      t = document.createElement("canvas"), t.width = 1, t.height = 1;
      var e = t.getContext("2d");
      e.fillStyle = "#fff", e.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t);
    }
  }
  function ko(t) {
    yi.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
  }
  function On(t, e, i, n) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i;
  }
  function Qs(t, e, i, n) {
    On.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function hr(t, e, i, n) {
    On.call(this, t, e, i, n);
  }
  function Vo(t, e, i, n) {
    On.call(this, t, e, i, n);
  }
  function Tn(t, e, i, n) {
    if (t === void 0)
      throw Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = Ln.convertArray(e, this.TimeBufferType), this.values = Ln.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  function Ra(t, e, i) {
    Tn.call(this, t, e, i);
  }
  function ba(t, e, i, n) {
    Tn.call(this, t, e, i, n);
  }
  function wr(t, e, i, n) {
    Tn.call(this, t, e, i, n);
  }
  function Gn(t, e, i, n) {
    On.call(this, t, e, i, n);
  }
  function Ms(t, e, i, n) {
    Tn.call(this, t, e, i, n);
  }
  function Oa(t, e, i, n) {
    Tn.call(this, t, e, i, n);
  }
  function Ts(t, e, i, n) {
    Tn.call(this, t, e, i, n);
  }
  function Qn(t, e, i) {
    this.name = t, this.tracks = i, this.duration = e !== void 0 ? e : -1, this.uuid = Je.generateUUID(), 0 > this.duration && this.resetDuration();
  }
  function ah(t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return wr;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Ts;
      case "color":
        return ba;
      case "quaternion":
        return Ms;
      case "bool":
      case "boolean":
        return Ra;
      case "string":
        return Oa;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }
  function lh(t) {
    if (t.type === void 0)
      throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var e = ah(t.type);
    if (t.times === void 0) {
      var i = [], n = [];
      Ln.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n;
    }
    return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
  }
  function vo(t, e, i) {
    var n = this, o = !1, s = 0, l = 0, h = void 0;
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(c) {
      l++, o === !1 && n.onStart !== void 0 && n.onStart(c, s, l), o = !0;
    }, this.itemEnd = function(c) {
      s++, n.onProgress !== void 0 && n.onProgress(c, s, l), s === l && (o = !1, n.onLoad !== void 0) && n.onLoad();
    }, this.itemError = function(c) {
      n.onError !== void 0 && n.onError(c);
    }, this.resolveURL = function(c) {
      return h ? h(c) : c;
    }, this.setURLModifier = function(c) {
      return h = c, this;
    };
  }
  function lt(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function Ot(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function At(t) {
    this.manager = t !== void 0 ? t : zn, this._parser = null;
  }
  function xe(t) {
    this.manager = t !== void 0 ? t : zn, this._parser = null;
  }
  function Ve(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function _i(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function Xi(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function he() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  function In(t, e, i, n, o, s, l, h) {
    he.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = o || 0, this.aEndAngle = s || 2 * Math.PI, this.aClockwise = l || !1, this.aRotation = h || 0;
  }
  function Ss(t, e, i, n, o, s) {
    In.call(this, t, e, i, i, n, o, s), this.type = "ArcCurve";
  }
  function Hn() {
    var t = 0, e = 0, i = 0, n = 0;
    return {
      initCatmullRom: function(o, s, l, h, c) {
        o = c * (l - o), h = c * (h - s), t = s, e = o, i = -3 * s + 3 * l - 2 * o - h, n = 2 * s - 2 * l + o + h;
      },
      initNonuniformCatmullRom: function(o, s, l, h, c, p, f) {
        o = ((s - o) / c - (l - o) / (c + p) + (l - s) / p) * p, h = ((l - s) / p - (h - s) / (p + f) + (h - l) / f) * p, t = s, e = o, i = -3 * s + 3 * l - 2 * o - h, n = 2 * s - 2 * l + o + h;
      },
      calc: function(o) {
        var s = o * o;
        return t + e * o + i * s + n * s * o;
      }
    };
  }
  function fn(t, e, i, n) {
    he.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || 0.5;
  }
  function Rl(t, e, i, n, o) {
    e = 0.5 * (n - e), o = 0.5 * (o - i);
    var s = t * t;
    return (2 * i - 2 * n + e + o) * t * s + (-3 * i + 3 * n - 2 * e - o) * s + e * t + i;
  }
  function Br(t, e, i, n) {
    var o = 1 - t;
    return o * o * e + 2 * (1 - t) * t * i + t * t * n;
  }
  function yo(t, e, i, n, o) {
    var s = 1 - t, l = 1 - t;
    return s * s * s * e + 3 * l * l * t * i + 3 * (1 - t) * t * t * n + t * t * t * o;
  }
  function kn(t, e, i, n) {
    he.call(this), this.type = "CubicBezierCurve", this.v0 = t || new y(), this.v1 = e || new y(), this.v2 = i || new y(), this.v3 = n || new y();
  }
  function si(t, e, i, n) {
    he.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new S(), this.v1 = e || new S(), this.v2 = i || new S(), this.v3 = n || new S();
  }
  function Vn(t, e) {
    he.call(this), this.type = "LineCurve", this.v1 = t || new y(), this.v2 = e || new y();
  }
  function ur(t, e) {
    he.call(this), this.type = "LineCurve3", this.v1 = t || new S(), this.v2 = e || new S();
  }
  function Wn(t, e, i) {
    he.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new y(), this.v1 = e || new y(), this.v2 = i || new y();
  }
  function Ur(t, e, i) {
    he.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new S(), this.v1 = e || new S(), this.v2 = i || new S();
  }
  function Mr(t) {
    he.call(this), this.type = "SplineCurve", this.points = t || [];
  }
  function Kr() {
    he.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  function jn(t) {
    Kr.call(this), this.type = "Path", this.currentPoint = new y(), t && this.setFromPoints(t);
  }
  function Dn(t) {
    jn.call(this, t), this.uuid = Je.generateUUID(), this.type = "Shape", this.holes = [];
  }
  function Bi(t, e) {
    z.call(this), this.type = "Light", this.color = new Y(t), this.intensity = e !== void 0 ? e : 1, this.receiveShadow = void 0;
  }
  function Ks(t, e, i) {
    Bi.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(z.DefaultUp), this.updateMatrix(), this.groundColor = new Y(e);
  }
  function Fr(t) {
    this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new y(512, 512), this.map = null, this.matrix = new pt();
  }
  function ta() {
    Fr.call(this, new ee(50, 1, 0.5, 500));
  }
  function ea(t, e, i, n, o, s) {
    Bi.call(this, t, e), this.type = "SpotLight", this.position.copy(z.DefaultUp), this.updateMatrix(), this.target = new z(), Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(l) {
        this.intensity = l / Math.PI;
      }
    }), this.distance = i !== void 0 ? i : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = o !== void 0 ? o : 0, this.decay = s !== void 0 ? s : 1, this.shadow = new ta();
  }
  function Wo(t, e, i, n) {
    Bi.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
      get: function() {
        return 4 * this.intensity * Math.PI;
      },
      set: function(o) {
        this.intensity = o / (4 * Math.PI);
      }
    }), this.distance = i !== void 0 ? i : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new Fr(new ee(90, 1, 0.5, 500));
  }
  function Es(t, e, i, n, o, s) {
    ye.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t !== void 0 ? t : -1, this.right = e !== void 0 ? e : 1, this.top = i !== void 0 ? i : 1, this.bottom = n !== void 0 ? n : -1, this.near = o !== void 0 ? o : 0.1, this.far = s !== void 0 ? s : 2e3, this.updateProjectionMatrix();
  }
  function _o() {
    Fr.call(this, new Es(-5, 5, 5, -5, 0.5, 500));
  }
  function Gr(t, e) {
    Bi.call(this, t, e), this.type = "DirectionalLight", this.position.copy(z.DefaultUp), this.updateMatrix(), this.target = new z(), this.shadow = new _o();
  }
  function jo(t, e) {
    Bi.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0;
  }
  function Ia(t, e, i, n) {
    Bi.call(this, t, e), this.type = "RectAreaLight", this.width = i !== void 0 ? i : 10, this.height = n !== void 0 ? n : 10;
  }
  function Da(t) {
    this.manager = t !== void 0 ? t : zn, this.textures = {};
  }
  function il(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function to() {
  }
  function Xo(t) {
    typeof t == "boolean" && (console.warn(
      "THREE.JSONLoader: showStatus parameter has been removed from constructor."
    ), t = void 0), this.manager = t !== void 0 ? t : zn, this.withCredentials = !1;
  }
  function ia(t) {
    this.manager = t !== void 0 ? t : zn, this.resourcePath = "";
  }
  function nl(t) {
    typeof createImageBitmap > "u" && console.warn(
      "THREE.ImageBitmapLoader: createImageBitmap() not supported."
    ), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = t !== void 0 ? t : zn, this.options = void 0;
  }
  function za() {
    this.type = "ShapePath", this.color = new Y(), this.subPaths = [], this.currentPath = null;
  }
  function rl(t) {
    this.type = "Font", this.data = t;
  }
  function bl(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function $i(t) {
    this.manager = t !== void 0 ? t : zn;
  }
  function Sn() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ee(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ee(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
  }
  function na(t, e, i, n) {
    z.call(this), this.type = "CubeCamera";
    var o = new ee(90, 1, t, e);
    o.up.set(0, -1, 0), o.lookAt(new S(1, 0, 0)), this.add(o);
    var s = new ee(90, 1, t, e);
    s.up.set(0, -1, 0), s.lookAt(new S(-1, 0, 0)), this.add(s);
    var l = new ee(90, 1, t, e);
    l.up.set(0, 0, 1), l.lookAt(new S(0, 1, 0)), this.add(l);
    var h = new ee(90, 1, t, e);
    h.up.set(0, 0, -1), h.lookAt(new S(0, -1, 0)), this.add(h);
    var c = new ee(90, 1, t, e);
    c.up.set(0, -1, 0), c.lookAt(new S(0, 0, 1)), this.add(c);
    var p = new ee(90, 1, t, e);
    p.up.set(0, -1, 0), p.lookAt(new S(0, 0, -1)), this.add(p), n = n || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new Rt(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(f, d) {
      this.parent === null && this.updateMatrixWorld();
      var v = this.renderTarget, w = v.texture.generateMipmaps;
      v.texture.generateMipmaps = !1, v.activeCubeFace = 0, f.render(d, o, v), v.activeCubeFace = 1, f.render(d, s, v), v.activeCubeFace = 2, f.render(d, l, v), v.activeCubeFace = 3, f.render(d, h, v), v.activeCubeFace = 4, f.render(d, c, v), v.texture.generateMipmaps = w, v.activeCubeFace = 5, f.render(d, p, v), f.setRenderTarget(null);
    }, this.clear = function(f, d, v, w) {
      for (var P = this.renderTarget, R = 0; 6 > R; R++)
        P.activeCubeFace = R, f.setRenderTarget(P), f.clear(d, v, w);
      f.setRenderTarget(null);
    };
  }
  function ol(t) {
    this.autoStart = t !== void 0 ? t : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1;
  }
  function Na() {
    z.call(this), this.type = "AudioListener", this.context = ml.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0;
  }
  function As(t) {
    z.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
  }
  function ra(t) {
    As.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
  }
  function qo(t, e) {
    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e !== void 0 ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
  }
  function oa(t, e, i) {
    switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
      case "quaternion":
        e = this._slerp;
        break;
      case "string":
      case "bool":
        t = Array, e = this._select;
        break;
      default:
        e = this._lerp;
    }
    this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function Yo(t, e, i) {
    i = i || an.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }
  function an(t, e, i) {
    this.path = e, this.parsedPath = i || an.parseTrackName(e), this.node = an.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
  }
  function Ps() {
    this.uuid = Je.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var e = 0, i = arguments.length; e !== i; ++e)
      t[arguments[e].uuid] = e;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  function sa(t, e, i) {
    this._mixer = t, this._clip = e, this._localRoot = i || null, t = e.tracks, e = t.length, i = Array(e);
    for (var n = { endingStart: 2400, endingEnd: 2400 }, o = 0; o !== e; ++o) {
      var s = t[o].createInterpolant(null);
      i[o] = s, s.settings = n;
    }
    this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  }
  function xo(t) {
    this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
  }
  function Ba(t, e) {
    typeof t == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t;
  }
  function sl() {
    Ft.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
  }
  function al(t, e, i) {
    gi.call(this, t, e), this.meshPerAttribute = i || 1;
  }
  function ll(t, e, i, n) {
    typeof i == "number" && (n = i, i = !1, console.error(
      "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
    )), it.call(this, t, e, i), this.meshPerAttribute = n || 1;
  }
  function Ol(t, e, i, n) {
    this.ray = new bn(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    }, Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          return console.warn(
            "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
          ), this.Points;
        }
      }
    });
  }
  function aa(t, e) {
    return t.distance - e.distance;
  }
  function Zo(t, e, i, n) {
    if (t.visible !== !1 && (t.raycast(e, i), n === !0)) {
      t = t.children, n = 0;
      for (var o = t.length; n < o; n++)
        Zo(t[n], e, i, !0);
    }
  }
  function hl(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.phi = e !== void 0 ? e : 0, this.theta = i !== void 0 ? i : 0, this;
  }
  function O(t, e, i) {
    return this.radius = t !== void 0 ? t : 1, this.theta = e !== void 0 ? e : 0, this.y = i !== void 0 ? i : 0, this;
  }
  function wo(t, e) {
    this.min = t !== void 0 ? t : new y(1 / 0, 1 / 0), this.max = e !== void 0 ? e : new y(-1 / 0, -1 / 0);
  }
  function Ls(t, e) {
    this.start = t !== void 0 ? t : new S(), this.end = e !== void 0 ? e : new S();
  }
  function Pn(t) {
    z.call(this), this.material = t, this.render = function() {
    };
  }
  function ni(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16711680, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new Ft(), e = new Et(6 * e, 3), i.addAttribute("position", e), ti.call(this, i, new yi({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function Cs(t, e) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new Ft(), e = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (var i = 0, n = 1; 32 > i; i++, n++) {
      var o = i / 32 * Math.PI * 2, s = n / 32 * Math.PI * 2;
      e.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
    }
    t.addAttribute("position", new Et(e, 3)), e = new yi({ fog: !1 }), this.cone = new ti(t, e), this.add(this.cone), this.update();
  }
  function Il(t) {
    var e = [];
    t && t.isBone && e.push(t);
    for (var i = 0; i < t.children.length; i++)
      e.push.apply(e, Il(t.children[i]));
    return e;
  }
  function Rs(t) {
    for (var e = Il(t), i = new Ft(), n = [], o = [], s = new Y(0, 0, 1), l = new Y(0, 1, 0), h = 0; h < e.length; h++) {
      var c = e[h];
      c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(l.r, l.g, l.b));
    }
    i.addAttribute("position", new Et(n, 3)), i.addAttribute("color", new Et(o, 3)), n = new yi({
      vertexColors: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), ti.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
  }
  function cr(t, e, i) {
    this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new ar(e, 4, 2), e = new ui({ wireframe: !0, fog: !1 }), Ui.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  function bs(t, e) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new yi({ fog: !1 }), e = new Ft(), e.addAttribute("position", new it(new Float32Array(15), 3)), this.line = new Pi(e, t), this.add(this.line), this.update();
  }
  function Os(t, e, i) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t = new Ro(e), t.rotateY(0.5 * Math.PI), this.material = new ui({ wireframe: !0, fog: !1 }), this.color === void 0 && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new it(e, 3)), this.add(new Ui(t, this.material)), this.update();
  }
  function la(t, e, i, n) {
    t = t || 10, e = e || 10, i = new Y(i !== void 0 ? i : 4473924), n = new Y(n !== void 0 ? n : 8947848);
    var o = e / 2, s = t / e, l = t / 2;
    t = [];
    for (var h = [], c = 0, p = 0, f = -l; c <= e; c++, f += s) {
      t.push(-l, 0, f, l, 0, f), t.push(f, 0, -l, f, 0, l);
      var d = c === o ? i : n;
      d.toArray(h, p), p += 3, d.toArray(h, p), p += 3, d.toArray(h, p), p += 3, d.toArray(h, p), p += 3;
    }
    e = new Ft(), e.addAttribute("position", new Et(t, 3)), e.addAttribute("color", new Et(h, 3)), i = new yi({ vertexColors: 2 }), ti.call(this, e, i);
  }
  function Ua(t, e, i, n, o, s) {
    t = t || 10, e = e || 16, i = i || 8, n = n || 64, o = new Y(o !== void 0 ? o : 4473924), s = new Y(s !== void 0 ? s : 8947848);
    var l = [], h = [], c;
    for (c = 0; c <= e; c++) {
      var p = c / e * 2 * Math.PI, f = Math.sin(p) * t;
      p = Math.cos(p) * t, l.push(0, 0, 0), l.push(f, 0, p);
      var d = c & 1 ? o : s;
      h.push(d.r, d.g, d.b), h.push(d.r, d.g, d.b);
    }
    for (c = 0; c <= i; c++) {
      d = c & 1 ? o : s;
      var v = t - t / i * c;
      for (e = 0; e < n; e++)
        p = e / n * 2 * Math.PI, f = Math.sin(p) * v, p = Math.cos(p) * v, l.push(f, 0, p), h.push(d.r, d.g, d.b), p = (e + 1) / n * 2 * Math.PI, f = Math.sin(p) * v, p = Math.cos(p) * v, l.push(f, 0, p), h.push(d.r, d.g, d.b);
    }
    t = new Ft(), t.addAttribute("position", new Et(l, 3)), t.addAttribute("color", new Et(h, 3)), l = new yi({ vertexColors: 2 }), ti.call(this, t, l);
  }
  function ha(t, e, i, n) {
    this.object = t, this.size = e !== void 0 ? e : 1, t = i !== void 0 ? i : 16776960, n = n !== void 0 ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn(
      "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
    ), i = new Ft(), e = new Et(6 * e, 3), i.addAttribute("position", e), ti.call(this, i, new yi({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update();
  }
  function Xn(t, e, i) {
    z.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, e === void 0 && (e = 1), t = new Ft(), t.addAttribute(
      "position",
      new Et([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    ), e = new yi({ fog: !1 }), this.lightPlane = new Pi(t, e), this.add(this.lightPlane), t = new Ft(), t.addAttribute("position", new Et([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Pi(t, e), this.add(this.targetLine), this.update();
  }
  function ua(t) {
    function e(w, P, R) {
      i(w, R), i(P, R);
    }
    function i(w, P) {
      s.push(0, 0, 0), l.push(P.r, P.g, P.b), h[w] === void 0 && (h[w] = []), h[w].push(s.length / 3 - 1);
    }
    var n = new Ft(), o = new yi({ color: 16777215, vertexColors: 1 }), s = [], l = [], h = {}, c = new Y(16755200), p = new Y(16711680), f = new Y(43775), d = new Y(16777215), v = new Y(3355443);
    e("n1", "n2", c), e("n2", "n4", c), e("n4", "n3", c), e("n3", "n1", c), e("f1", "f2", c), e("f2", "f4", c), e("f4", "f3", c), e("f3", "f1", c), e("n1", "f1", c), e("n2", "f2", c), e("n3", "f3", c), e("n4", "f4", c), e("p", "n1", p), e("p", "n2", p), e("p", "n3", p), e("p", "n4", p), e("u1", "u2", f), e("u2", "u3", f), e("u3", "u1", f), e("c", "t", d), e("p", "c", v), e("cn1", "cn2", v), e("cn3", "cn4", v), e("cf1", "cf2", v), e("cf3", "cf4", v), n.addAttribute("position", new Et(s, 3)), n.addAttribute("color", new Et(l, 3)), ti.call(this, n, o), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = h, this.update();
  }
  function eo(t, e) {
    this.object = t, e === void 0 && (e = 16776960), t = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Float32Array(24), n = new Ft();
    n.setIndex(new it(t, 1)), n.addAttribute("position", new it(i, 3)), ti.call(this, n, new yi({ color: e })), this.matrixAutoUpdate = !1, this.update();
  }
  function ca(t, e) {
    this.type = "Box3Helper", this.box = t, t = e !== void 0 ? e : 16776960, e = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4,
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7
    ]);
    var i = new Ft();
    i.setIndex(new it(e, 1)), i.addAttribute(
      "position",
      new Et(
        [
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          -1
        ],
        3
      )
    ), ti.call(this, i, new yi({ color: t })), this.geometry.computeBoundingSphere();
  }
  function pa(t, e, i) {
    this.type = "PlaneHelper", this.plane = t, this.size = e === void 0 ? 1 : e, t = i !== void 0 ? i : 16776960, e = new Ft(), e.addAttribute(
      "position",
      new Et(
        [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        3
      )
    ), e.computeBoundingSphere(), Pi.call(this, e, new yi({ color: t })), e = new Ft(), e.addAttribute(
      "position",
      new Et([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    ), e.computeBoundingSphere(), this.add(
      new Ui(
        e,
        new ui({ color: t, opacity: 0.2, transparent: !0, depthWrite: !1 })
      )
    );
  }
  function io(t, e, i, n, o, s) {
    z.call(this), t === void 0 && (t = new THREE.Vector3(0, 0, 1)), e === void 0 && (e = new THREE.Vector3(0, 0, 0)), i === void 0 && (i = 1), n === void 0 && (n = 16776960), o === void 0 && (o = 0.2 * i), s === void 0 && (s = 0.2 * o), Wa === void 0 && (Wa = new Ft(), Wa.addAttribute("position", new Et([0, 0, 0, 0, 1, 0], 3)), ga = new Qr(0, 0.5, 1, 5, 1), ga.translate(0, -0.5, 0)), this.position.copy(e), this.line = new Pi(Wa, new yi({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ui(ga, new ui({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, o, s);
  }
  function Kn(t) {
    t = t || 1;
    var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
    t = new Ft(), t.addAttribute("position", new Et(e, 3)), t.addAttribute(
      "color",
      new Et([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
    ), e = new yi({ vertexColors: 2 }), ti.call(this, t, e);
  }
  function Dl(t) {
    console.warn(
      "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), fn.call(this, t), this.type = "catmullrom", this.closed = !0;
  }
  function zl(t) {
    console.warn(
      "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
    ), fn.call(this, t), this.type = "catmullrom";
  }
  function ul(t) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
    ), fn.call(this, t), this.type = "catmullrom";
  }
  Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52)), Number.isInteger === void 0 && (Number.isInteger = function(t) {
    return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
  }), Math.sign === void 0 && (Math.sign = function(t) {
    return 0 > t ? -1 : 0 < t ? 1 : +t;
  }), !("name" in Function.prototype) && Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  }), Object.assign === void 0 && function() {
    Object.assign = function(t) {
      if (t == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var e = Object(t), i = 1; i < arguments.length; i++) {
        var n = arguments[i];
        if (n != null)
          for (var o in n)
            Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    };
  }(), Object.assign($.prototype, {
    addEventListener: function(t, e) {
      this._listeners === void 0 && (this._listeners = {});
      var i = this._listeners;
      i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
    },
    hasEventListener: function(t, e) {
      if (this._listeners === void 0)
        return !1;
      var i = this._listeners;
      return i[t] !== void 0 && i[t].indexOf(e) !== -1;
    },
    removeEventListener: function(t, e) {
      this._listeners !== void 0 && (t = this._listeners[t], t !== void 0 && (e = t.indexOf(e), e !== -1 && t.splice(e, 1)));
    },
    dispatchEvent: function(t) {
      if (this._listeners !== void 0) {
        var e = this._listeners[t.type];
        if (e !== void 0) {
          t.target = this, e = e.slice(0);
          for (var i = 0, n = e.length; i < n; i++)
            e[i].call(this, t);
        }
      }
    }
  });
  var Je = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      for (var t = [], e = 0; 256 > e; e++)
        t[e] = (16 > e ? "0" : "") + e.toString(16);
      return function() {
        var i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, o = 4294967295 * Math.random() | 0, s = 4294967295 * Math.random() | 0;
        return (t[i & 255] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255] + "-" + t[n & 255] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[o & 63 | 128] + t[o >> 8 & 255] + "-" + t[o >> 16 & 255] + t[o >> 24 & 255] + t[s & 255] + t[s >> 8 & 255] + t[s >> 16 & 255] + t[s >> 24 & 255]).toUpperCase();
      };
    }(),
    clamp: function(t, e, i) {
      return Math.max(e, Math.min(i, t));
    },
    euclideanModulo: function(t, e) {
      return (t % e + e) % e;
    },
    mapLinear: function(t, e, i, n, o) {
      return n + (t - e) * (o - n) / (i - e);
    },
    lerp: function(t, e, i) {
      return (1 - i) * t + i * e;
    },
    smoothstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * (3 - 2 * t));
    },
    smootherstep: function(t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * t * (t * (6 * t - 15) + 10));
    },
    randInt: function(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function(t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function(t) {
      return t * (0.5 - Math.random());
    },
    degToRad: function(t) {
      return t * Je.DEG2RAD;
    },
    radToDeg: function(t) {
      return t * Je.RAD2DEG;
    },
    isPowerOfTwo: function(t) {
      return (t & t - 1) === 0 && t !== 0;
    },
    ceilPowerOfTwo: function(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    },
    floorPowerOfTwo: function(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }
  };
  Object.defineProperties(y.prototype, {
    width: {
      get: function() {
        return this.x;
      },
      set: function(t) {
        this.x = t;
      }
    },
    height: {
      get: function() {
        return this.y;
      },
      set: function(t) {
        this.y = t;
      }
    }
  }), Object.assign(y.prototype, {
    isVector2: !0,
    set: function(t, e) {
      return this.x = t, this.y = e, this;
    },
    setScalar: function(t) {
      return this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    },
    multiply: function(t) {
      return this.x *= t.x, this.y *= t.y, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this;
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    applyMatrix3: function(t) {
      var e = this.x, i = this.y;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this;
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    },
    clampScalar: function() {
      var t = new y(), e = new y();
      return function(i, n) {
        return t.set(i, i), e.set(n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y;
    },
    cross: function(t) {
      return this.x * t.y - this.y * t.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var t = Math.atan2(this.y, this.x);
      return 0 > t && (t += 2 * Math.PI), t;
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x;
      return t = this.y - t.y, e * e + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this;
    },
    rotateAround: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = this.x - t.x, o = this.y - t.y;
      return this.x = n * i - o * e + t.x, this.y = n * e + o * i + t.y, this;
    }
  }), Object.assign(pt.prototype, {
    isMatrix4: !0,
    set: function(t, e, i, n, o, s, l, h, c, p, f, d, v, w, P, R) {
      var I = this.elements;
      return I[0] = t, I[4] = e, I[8] = i, I[12] = n, I[1] = o, I[5] = s, I[9] = l, I[13] = h, I[2] = c, I[6] = p, I[10] = f, I[14] = d, I[3] = v, I[7] = w, I[11] = P, I[15] = R, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new pt().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this;
    },
    copyPosition: function(t) {
      var e = this.elements;
      return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this;
    },
    extractBasis: function(t, e, i) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
    },
    makeBasis: function(t, e, i) {
      return this.set(
        t.x,
        e.x,
        i.x,
        0,
        t.y,
        e.y,
        i.y,
        0,
        t.z,
        e.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    extractRotation: function() {
      var t = new S();
      return function(e) {
        var i = this.elements, n = e.elements, o = 1 / t.setFromMatrixColumn(e, 0).length(), s = 1 / t.setFromMatrixColumn(e, 1).length();
        return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * o, i[1] = n[1] * o, i[2] = n[2] * o, i[3] = 0, i[4] = n[4] * s, i[5] = n[5] * s, i[6] = n[6] * s, i[7] = 0, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
      };
    }(),
    makeRotationFromEuler: function(t) {
      t && t.isEuler || console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
      var e = this.elements, i = t.x, n = t.y, o = t.z, s = Math.cos(i);
      i = Math.sin(i);
      var l = Math.cos(n);
      n = Math.sin(n);
      var h = Math.cos(o);
      if (o = Math.sin(o), t.order === "XYZ") {
        t = s * h;
        var c = s * o, p = i * h, f = i * o;
        e[0] = l * h, e[4] = -l * o, e[8] = n, e[1] = c + p * n, e[5] = t - f * n, e[9] = -i * l, e[2] = f - t * n, e[6] = p + c * n, e[10] = s * l;
      } else
        t.order === "YXZ" ? (t = l * h, c = l * o, p = n * h, f = n * o, e[0] = t + f * i, e[4] = p * i - c, e[8] = s * n, e[1] = s * o, e[5] = s * h, e[9] = -i, e[2] = c * i - p, e[6] = f + t * i, e[10] = s * l) : t.order === "ZXY" ? (t = l * h, c = l * o, p = n * h, f = n * o, e[0] = t - f * i, e[4] = -s * o, e[8] = p + c * i, e[1] = c + p * i, e[5] = s * h, e[9] = f - t * i, e[2] = -s * n, e[6] = i, e[10] = s * l) : t.order === "ZYX" ? (t = s * h, c = s * o, p = i * h, f = i * o, e[0] = l * h, e[4] = p * n - c, e[8] = t * n + f, e[1] = l * o, e[5] = f * n + t, e[9] = c * n - p, e[2] = -n, e[6] = i * l, e[10] = s * l) : t.order === "YZX" ? (t = s * l, c = s * n, p = i * l, f = i * n, e[0] = l * h, e[4] = f - t * o, e[8] = p * o + c, e[1] = o, e[5] = s * h, e[9] = -i * h, e[2] = -n * h, e[6] = c * o + p, e[10] = t - f * o) : t.order === "XZY" && (t = s * l, c = s * n, p = i * l, f = i * n, e[0] = l * h, e[4] = -o, e[8] = n * h, e[1] = t * o + f, e[5] = s * h, e[9] = c * o - p, e[2] = p * o - c, e[6] = i * h, e[10] = f * o + t);
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    },
    makeRotationFromQuaternion: function() {
      var t = new S(0, 0, 0), e = new S(1, 1, 1);
      return function(i) {
        return this.compose(t, i, e);
      };
    }(),
    lookAt: function() {
      var t = new S(), e = new S(), i = new S();
      return function(n, o, s) {
        var l = this.elements;
        return i.subVectors(n, o), i.lengthSq() === 0 && (i.z = 1), i.normalize(), t.crossVectors(s, i), t.lengthSq() === 0 && (Math.abs(s.z) === 1 ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(s, i)), t.normalize(), e.crossVectors(i, t), l[0] = t.x, l[4] = e.x, l[8] = i.x, l[1] = t.y, l[5] = e.y, l[9] = i.y, l[2] = t.z, l[6] = e.z, l[10] = i.z, this;
      };
    }(),
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
      ), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var o = i[4], s = i[8], l = i[12], h = i[1], c = i[5], p = i[9], f = i[13], d = i[2], v = i[6], w = i[10], P = i[14], R = i[3], I = i[7], Q = i[11];
      i = i[15];
      var W = n[0], st = n[4], K = n[8], wt = n[12], C = n[1], D = n[5], ct = n[9], Dt = n[13], bt = n[2], St = n[6], oe = n[10], $t = n[14], me = n[3], ue = n[7], Wt = n[11];
      return n = n[15], e[0] = t * W + o * C + s * bt + l * me, e[4] = t * st + o * D + s * St + l * ue, e[8] = t * K + o * ct + s * oe + l * Wt, e[12] = t * wt + o * Dt + s * $t + l * n, e[1] = h * W + c * C + p * bt + f * me, e[5] = h * st + c * D + p * St + f * ue, e[9] = h * K + c * ct + p * oe + f * Wt, e[13] = h * wt + c * Dt + p * $t + f * n, e[2] = d * W + v * C + w * bt + P * me, e[6] = d * st + v * D + w * St + P * ue, e[10] = d * K + v * ct + w * oe + P * Wt, e[14] = d * wt + v * Dt + w * $t + P * n, e[3] = R * W + I * C + Q * bt + i * me, e[7] = R * st + I * D + Q * St + i * ue, e[11] = R * K + I * ct + Q * oe + i * Wt, e[15] = R * wt + I * Dt + Q * $t + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    },
    applyToBufferAttribute: function() {
      var t = new S();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    determinant: function() {
      var t = this.elements, e = t[0], i = t[4], n = t[8], o = t[12], s = t[1], l = t[5], h = t[9], c = t[13], p = t[2], f = t[6], d = t[10], v = t[14];
      return t[3] * (+o * h * f - n * c * f - o * l * d + i * c * d + n * l * v - i * h * v) + t[7] * (+e * h * v - e * c * d + o * s * d - n * s * v + n * c * p - o * h * p) + t[11] * (+e * c * f - e * l * v - o * s * f + i * s * v + o * l * p - i * c * p) + t[15] * (-n * l * p - e * h * f + e * l * d + n * s * f - i * s * d + i * h * p);
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    },
    setPosition: function(t) {
      var e = this.elements;
      return e[12] = t.x, e[13] = t.y, e[14] = t.z, this;
    },
    getInverse: function(t, e) {
      var i = this.elements, n = t.elements;
      t = n[0];
      var o = n[1], s = n[2], l = n[3], h = n[4], c = n[5], p = n[6], f = n[7], d = n[8], v = n[9], w = n[10], P = n[11], R = n[12], I = n[13], Q = n[14];
      n = n[15];
      var W = v * Q * f - I * w * f + I * p * P - c * Q * P - v * p * n + c * w * n, st = R * w * f - d * Q * f - R * p * P + h * Q * P + d * p * n - h * w * n, K = d * I * f - R * v * f + R * c * P - h * I * P - d * c * n + h * v * n, wt = R * v * p - d * I * p - R * c * w + h * I * w + d * c * Q - h * v * Q, C = t * W + o * st + s * K + l * wt;
      if (C === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / C, i[0] = W * e, i[1] = (I * w * l - v * Q * l - I * s * P + o * Q * P + v * s * n - o * w * n) * e, i[2] = (c * Q * l - I * p * l + I * s * f - o * Q * f - c * s * n + o * p * n) * e, i[3] = (v * p * l - c * w * l - v * s * f + o * w * f + c * s * P - o * p * P) * e, i[4] = st * e, i[5] = (d * Q * l - R * w * l + R * s * P - t * Q * P - d * s * n + t * w * n) * e, i[6] = (R * p * l - h * Q * l - R * s * f + t * Q * f + h * s * n - t * p * n) * e, i[7] = (h * w * l - d * p * l + d * s * f - t * w * f - h * s * P + t * p * P) * e, i[8] = K * e, i[9] = (R * v * l - d * I * l - R * o * P + t * I * P + d * o * n - t * v * n) * e, i[10] = (h * I * l - R * c * l + R * o * f - t * I * f - h * o * n + t * c * n) * e, i[11] = (d * c * l - h * v * l - d * o * f + t * v * f + h * o * P - t * c * P) * e, i[12] = wt * e, i[13] = (d * I * s - R * v * s + R * o * w - t * I * w - d * o * Q + t * v * Q) * e, i[14] = (R * c * s - h * I * s - R * o * p + t * I * p + h * o * Q - t * c * Q) * e, i[15] = (h * v * s - d * c * s + d * o * p - t * v * p - h * o * w + t * c * w) * e, this;
    },
    scale: function(t) {
      var e = this.elements, i = t.x, n = t.y;
      return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this;
    },
    getMaxScaleOnAxis: function() {
      var t = this.elements;
      return Math.sqrt(
        Math.max(
          t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
        )
      );
    },
    makeTranslation: function(t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
    },
    makeRotationX: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function(t) {
      var e = Math.cos(t);
      return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function(t, e) {
      var i = Math.cos(e);
      e = Math.sin(e);
      var n = 1 - i, o = t.x, s = t.y;
      t = t.z;
      var l = n * o, h = n * s;
      return this.set(
        l * o + i,
        l * s - e * t,
        l * t + e * s,
        0,
        l * s + e * t,
        h * s + i,
        h * t - e * o,
        0,
        l * t - e * s,
        h * t + e * o,
        n * t * t + i,
        0,
        0,
        0,
        0,
        1
      ), this;
    },
    makeScale: function(t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    },
    makeShear: function(t, e, i) {
      return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    },
    compose: function(t, e, i) {
      var n = this.elements, o = e._x, s = e._y, l = e._z, h = e._w, c = o + o, p = s + s, f = l + l;
      e = o * c;
      var d = o * p;
      o *= f;
      var v = s * p;
      s *= f, l *= f, c *= h, p *= h, h *= f, f = i.x;
      var w = i.y;
      return i = i.z, n[0] = (1 - (v + l)) * f, n[1] = (d + h) * f, n[2] = (o - p) * f, n[3] = 0, n[4] = (d - h) * w, n[5] = (1 - (e + l)) * w, n[6] = (s + c) * w, n[7] = 0, n[8] = (o + p) * i, n[9] = (s - c) * i, n[10] = (1 - (e + v)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
    },
    decompose: function() {
      var t = new S(), e = new pt();
      return function(i, n, o) {
        var s = this.elements, l = t.set(s[0], s[1], s[2]).length(), h = t.set(s[4], s[5], s[6]).length(), c = t.set(s[8], s[9], s[10]).length();
        0 > this.determinant() && (l = -l), i.x = s[12], i.y = s[13], i.z = s[14], e.copy(this), i = 1 / l, s = 1 / h;
        var p = 1 / c;
        return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= s, e.elements[5] *= s, e.elements[6] *= s, e.elements[8] *= p, e.elements[9] *= p, e.elements[10] *= p, n.setFromRotationMatrix(e), o.x = l, o.y = h, o.z = c, this;
      };
    }(),
    makePerspective: function(t, e, i, n, o, s) {
      s === void 0 && console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
      var l = this.elements;
      return l[0] = 2 * o / (e - t), l[4] = 0, l[8] = (e + t) / (e - t), l[12] = 0, l[1] = 0, l[5] = 2 * o / (i - n), l[9] = (i + n) / (i - n), l[13] = 0, l[2] = 0, l[6] = 0, l[10] = -(s + o) / (s - o), l[14] = -2 * s * o / (s - o), l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
    },
    makeOrthographic: function(t, e, i, n, o, s) {
      var l = this.elements, h = 1 / (e - t), c = 1 / (i - n), p = 1 / (s - o);
      return l[0] = 2 * h, l[4] = 0, l[8] = 0, l[12] = -((e + t) * h), l[1] = 0, l[5] = 2 * c, l[9] = 0, l[13] = -((i + n) * c), l[2] = 0, l[6] = 0, l[10] = -2 * p, l[14] = -((s + o) * p), l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 16 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 16 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
    }
  }), Object.assign(gt, {
    slerp: function(t, e, i, n) {
      return i.copy(t).slerp(e, n);
    },
    slerpFlat: function(t, e, i, n, o, s, l) {
      var h = i[n + 0], c = i[n + 1], p = i[n + 2];
      i = i[n + 3], n = o[s + 0];
      var f = o[s + 1], d = o[s + 2];
      if (o = o[s + 3], i !== o || h !== n || c !== f || p !== d) {
        s = 1 - l;
        var v = h * n + c * f + p * d + i * o, w = 0 <= v ? 1 : -1, P = 1 - v * v;
        P > Number.EPSILON && (P = Math.sqrt(P), v = Math.atan2(P, v * w), s = Math.sin(s * v) / P, l = Math.sin(l * v) / P), w *= l, h = h * s + n * w, c = c * s + f * w, p = p * s + d * w, i = i * s + o * w, s === 1 - l && (l = 1 / Math.sqrt(h * h + c * c + p * p + i * i), h *= l, c *= l, p *= l, i *= l);
      }
      t[e] = h, t[e + 1] = c, t[e + 2] = p, t[e + 3] = i;
    }
  }), Object.defineProperties(gt.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(t) {
        this._w = t, this.onChangeCallback();
      }
    }
  }), Object.assign(gt.prototype, {
    isQuaternion: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this;
    },
    setFromEuler: function(t, e) {
      if (!t || !t.isEuler)
        throw Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      var i = t._x, n = t._y, o = t._z;
      t = t.order;
      var s = Math.cos, l = Math.sin, h = s(i / 2), c = s(n / 2);
      return s = s(o / 2), i = l(i / 2), n = l(n / 2), o = l(o / 2), t === "XYZ" ? (this._x = i * c * s + h * n * o, this._y = h * n * s - i * c * o, this._z = h * c * o + i * n * s, this._w = h * c * s - i * n * o) : t === "YXZ" ? (this._x = i * c * s + h * n * o, this._y = h * n * s - i * c * o, this._z = h * c * o - i * n * s, this._w = h * c * s + i * n * o) : t === "ZXY" ? (this._x = i * c * s - h * n * o, this._y = h * n * s + i * c * o, this._z = h * c * o + i * n * s, this._w = h * c * s - i * n * o) : t === "ZYX" ? (this._x = i * c * s - h * n * o, this._y = h * n * s + i * c * o, this._z = h * c * o - i * n * s, this._w = h * c * s + i * n * o) : t === "YZX" ? (this._x = i * c * s + h * n * o, this._y = h * n * s + i * c * o, this._z = h * c * o - i * n * s, this._w = h * c * s - i * n * o) : t === "XZY" && (this._x = i * c * s - h * n * o, this._y = h * n * s - i * c * o, this._z = h * c * o + i * n * s, this._w = h * c * s + i * n * o), e !== !1 && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(t, e) {
      e /= 2;
      var i = Math.sin(e);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t) {
      var e = t.elements, i = e[0];
      t = e[4];
      var n = e[8], o = e[1], s = e[5], l = e[9], h = e[2], c = e[6];
      e = e[10];
      var p = i + s + e;
      return 0 < p ? (i = 0.5 / Math.sqrt(p + 1), this._w = 0.25 / i, this._x = (c - l) * i, this._y = (n - h) * i, this._z = (o - t) * i) : i > s && i > e ? (i = 2 * Math.sqrt(1 + i - s - e), this._w = (c - l) / i, this._x = 0.25 * i, this._y = (t + o) / i, this._z = (n + h) / i) : s > e ? (i = 2 * Math.sqrt(1 + s - i - e), this._w = (n - h) / i, this._x = (t + o) / i, this._y = 0.25 * i, this._z = (l + c) / i) : (i = 2 * Math.sqrt(1 + e - i - s), this._w = (o - t) / i, this._x = (n + h) / i, this._y = (l + c) / i, this._z = 0.25 * i), this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
      var t = new S(), e;
      return function(i, n) {
        return t === void 0 && (t = new S()), e = i.dot(n) + 1, 1e-6 > e ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize();
      };
    }(),
    angleTo: function(t) {
      return 2 * Math.acos(Math.abs(Je.clamp(this.dot(t), -1, 1)));
    },
    rotateTowards: function(t, e) {
      var i = this.angleTo(t);
      return i === 0 ? this : (this.slerp(t, Math.min(1, e / i)), this);
    },
    inverse: function() {
      return this.conjugate();
    },
    conjugate: function() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    },
    lengthSq: function() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
      return Math.sqrt(
        this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      );
    },
    normalize: function() {
      var t = this.length();
      return t === 0 ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
      ), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    },
    premultiply: function(t) {
      return this.multiplyQuaternions(t, this);
    },
    multiplyQuaternions: function(t, e) {
      var i = t._x, n = t._y, o = t._z;
      t = t._w;
      var s = e._x, l = e._y, h = e._z;
      return e = e._w, this._x = i * e + t * s + n * h - o * l, this._y = n * e + t * l + o * s - i * h, this._z = o * e + t * h + i * l - n * s, this._w = t * e - i * s - n * l - o * h, this.onChangeCallback(), this;
    },
    slerp: function(t, e) {
      if (e === 0)
        return this;
      if (e === 1)
        return this.copy(t);
      var i = this._x, n = this._y, o = this._z, s = this._w, l = s * t._w + i * t._x + n * t._y + o * t._z;
      if (0 > l ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, l = -l) : this.copy(t), 1 <= l)
        return this._w = s, this._x = i, this._y = n, this._z = o, this;
      if (t = 1 - l * l, t <= Number.EPSILON)
        return l = 1 - e, this._w = l * s + e * this._w, this._x = l * i + e * this._x, this._y = l * n + e * this._y, this._z = l * o + e * this._z, this.normalize();
      t = Math.sqrt(t);
      var h = Math.atan2(t, l);
      return l = Math.sin((1 - e) * h) / t, e = Math.sin(e * h) / t, this._w = s * l + this._w * e, this._x = i * l + this._x * e, this._y = n * l + this._y * e, this._z = o * l + this._z * e, this.onChangeCallback(), this;
    },
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(S.prototype, {
    isVector3: !0,
    set: function(t, e, i) {
      return this.x = t, this.y = e, this.z = i, this;
    },
    setScalar: function(t) {
      return this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    },
    multiply: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
      ), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    },
    multiplyVectors: function(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    },
    applyEuler: function() {
      var t = new gt();
      return function(e) {
        return e && e.isEuler || console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ), this.applyQuaternion(t.setFromEuler(e));
      };
    }(),
    applyAxisAngle: function() {
      var t = new gt();
      return function(e, i) {
        return this.applyQuaternion(t.setFromAxisAngle(e, i));
      };
    }(),
    applyMatrix3: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z;
      t = t.elements;
      var o = 1 / (t[3] * e + t[7] * i + t[11] * n + t[15]);
      return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * o, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * o, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * o, this;
    },
    applyQuaternion: function(t) {
      var e = this.x, i = this.y, n = this.z, o = t.x, s = t.y, l = t.z;
      t = t.w;
      var h = t * e + s * n - l * i, c = t * i + l * e - o * n, p = t * n + o * i - s * e;
      return e = -o * e - s * i - l * n, this.x = h * t + e * -o + c * -l - p * -s, this.y = c * t + e * -s + p * -o - h * -l, this.z = p * t + e * -l + h * -s - c * -o, this;
    },
    project: function(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    },
    unproject: function() {
      var t = new pt();
      return function(e) {
        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(
          e.matrixWorld
        );
      };
    }(),
    transformDirection: function(t) {
      var e = this.x, i = this.y, n = this.z;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize();
    },
    divide: function(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    },
    clampScalar: function() {
      var t = new S(), e = new S();
      return function(i, n) {
        return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    cross: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
      ), this.crossVectors(t, e)) : this.crossVectors(this, t);
    },
    crossVectors: function(t, e) {
      var i = t.x, n = t.y;
      t = t.z;
      var o = e.x, s = e.y;
      return e = e.z, this.x = n * e - t * s, this.y = t * o - i * e, this.z = i * s - n * o, this;
    },
    projectOnVector: function(t) {
      var e = t.dot(this) / t.lengthSq();
      return this.copy(t).multiplyScalar(e);
    },
    projectOnPlane: function() {
      var t = new S();
      return function(e) {
        return t.copy(this).projectOnVector(e), this.sub(t);
      };
    }(),
    reflect: function() {
      var t = new S();
      return function(e) {
        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
      };
    }(),
    angleTo: function(t) {
      return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(Je.clamp(t, -1, 1));
    },
    distanceTo: function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function(t) {
      var e = this.x - t.x, i = this.y - t.y;
      return t = this.z - t.z, e * e + i * i + t * t;
    },
    manhattanDistanceTo: function(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    },
    setFromSpherical: function(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    },
    setFromSphericalCoords: function(t, e, i) {
      var n = Math.sin(e) * t;
      return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
    },
    setFromCylindrical: function(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    },
    setFromCylindricalCoords: function(t, e, i) {
      return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
    },
    setFromMatrixPosition: function(t) {
      return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this;
    },
    setFromMatrixScale: function(t) {
      var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length();
      return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this;
    },
    setFromMatrixColumn: function(t, e) {
      return this.fromArray(t.elements, 4 * e);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
  }), Object.assign(Mt.prototype, {
    isMatrix3: !0,
    set: function(t, e, i, n, o, s, l, h, c) {
      var p = this.elements;
      return p[0] = t, p[1] = n, p[2] = l, p[3] = e, p[4] = o, p[5] = h, p[6] = i, p[7] = s, p[8] = c, this;
    },
    identity: function() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(t) {
      var e = this.elements;
      return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this;
    },
    setFromMatrix4: function(t) {
      return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    },
    applyToBufferAttribute: function() {
      var t = new S();
      return function(e) {
        for (var i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
        return e;
      };
    }(),
    multiply: function(t) {
      return this.multiplyMatrices(this, t);
    },
    premultiply: function(t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function(t, e) {
      var i = t.elements, n = e.elements;
      e = this.elements, t = i[0];
      var o = i[3], s = i[6], l = i[1], h = i[4], c = i[7], p = i[2], f = i[5];
      i = i[8];
      var d = n[0], v = n[3], w = n[6], P = n[1], R = n[4], I = n[7], Q = n[2], W = n[5];
      return n = n[8], e[0] = t * d + o * P + s * Q, e[3] = t * v + o * R + s * W, e[6] = t * w + o * I + s * n, e[1] = l * d + h * P + c * Q, e[4] = l * v + h * R + c * W, e[7] = l * w + h * I + c * n, e[2] = p * d + f * P + i * Q, e[5] = p * v + f * R + i * W, e[8] = p * w + f * I + i * n, this;
    },
    multiplyScalar: function(t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    },
    determinant: function() {
      var t = this.elements, e = t[0], i = t[1], n = t[2], o = t[3], s = t[4], l = t[5], h = t[6], c = t[7];
      return t = t[8], e * s * t - e * l * c - i * o * t + i * l * h + n * o * c - n * s * h;
    },
    getInverse: function(t, e) {
      t && t.isMatrix4 && console.error(
        "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
      );
      var i = t.elements;
      t = this.elements;
      var n = i[0], o = i[1], s = i[2], l = i[3], h = i[4], c = i[5], p = i[6], f = i[7];
      i = i[8];
      var d = i * h - c * f, v = c * p - i * l, w = f * l - h * p, P = n * d + o * v + s * w;
      if (P === 0) {
        if (e === !0)
          throw Error(
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
          );
        return console.warn(
          "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"
        ), this.identity();
      }
      return e = 1 / P, t[0] = d * e, t[1] = (s * f - i * o) * e, t[2] = (c * o - s * h) * e, t[3] = v * e, t[4] = (i * n - s * p) * e, t[5] = (s * l - c * n) * e, t[6] = w * e, t[7] = (o * p - f * n) * e, t[8] = (h * n - o * l) * e, this;
    },
    transpose: function() {
      var t = this.elements, e = t[1];
      return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    },
    getNormalMatrix: function(t) {
      return this.setFromMatrix4(t).getInverse(this).transpose();
    },
    transposeIntoArray: function(t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    },
    setUvTransform: function(t, e, i, n, o, s, l) {
      var h = Math.cos(o);
      o = Math.sin(o), this.set(
        i * h,
        i * o,
        -i * (h * s + o * l) + s + t,
        -n * o,
        n * h,
        -n * (-o * s + h * l) + l + e,
        0,
        0,
        1
      );
    },
    scale: function(t, e) {
      var i = this.elements;
      return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this;
    },
    rotate: function(t) {
      var e = Math.cos(t);
      t = Math.sin(t);
      var i = this.elements, n = i[0], o = i[3], s = i[6], l = i[1], h = i[4], c = i[7];
      return i[0] = e * n + t * l, i[3] = e * o + t * h, i[6] = e * s + t * c, i[1] = -t * n + e * l, i[4] = -t * o + e * h, i[7] = -t * s + e * c, this;
    },
    translate: function(t, e) {
      var i = this.elements;
      return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this;
    },
    equals: function(t) {
      var e = this.elements;
      t = t.elements;
      for (var i = 0; 9 > i; i++)
        if (e[i] !== t[i])
          return !1;
      return !0;
    },
    fromArray: function(t, e) {
      e === void 0 && (e = 0);
      for (var i = 0; 9 > i; i++)
        this.elements[i] = t[i + e];
      return this;
    },
    toArray: function(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
    }
  });
  var Mo = {
    getDataURL: function(t) {
      if (typeof HTMLCanvasElement > "u")
        return t.src;
      if (t instanceof HTMLCanvasElement)
        var e = t;
      else {
        e = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        ), e.width = t.width, e.height = t.height;
        var i = e.getContext("2d");
        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height);
      }
      return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
    }
  }, Jo = 0;
  kt.DEFAULT_IMAGE = void 0, kt.DEFAULT_MAPPING = 300, kt.prototype = Object.assign(Object.create($.prototype), {
    constructor: kt,
    isTexture: !0,
    updateMatrix: function() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
    },
    toJSON: function(t) {
      var e = t === void 0 || typeof t == "string";
      if (!e && t.textures[this.uuid] !== void 0)
        return t.textures[this.uuid];
      var i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY
      };
      if (this.image !== void 0) {
        var n = this.image;
        if (n.uuid === void 0 && (n.uuid = Je.generateUUID()), !e && t.images[n.uuid] === void 0) {
          if (Array.isArray(n))
            for (var o = [], s = 0, l = n.length; s < l; s++)
              o.push(Mo.getDataURL(n[s]));
          else
            o = Mo.getDataURL(n);
          t.images[n.uuid] = { uuid: n.uuid, url: o };
        }
        i.image = n.uuid;
      }
      return e || (t.textures[this.uuid] = i), i;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function(t) {
      if (this.mapping !== 300)
        return t;
      if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x)
        switch (this.wrapS) {
          case 1e3:
            t.x -= Math.floor(t.x);
            break;
          case 1001:
            t.x = 0 > t.x ? 0 : 1;
            break;
          case 1002:
            t.x = Math.abs(Math.floor(t.x) % 2) === 1 ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x);
        }
      if (0 > t.y || 1 < t.y)
        switch (this.wrapT) {
          case 1e3:
            t.y -= Math.floor(t.y);
            break;
          case 1001:
            t.y = 0 > t.y ? 0 : 1;
            break;
          case 1002:
            t.y = Math.abs(Math.floor(t.y) % 2) === 1 ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y);
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
  }), Object.defineProperty(kt.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(nt.prototype, {
    isVector4: !0,
    set: function(t, e, i, n) {
      return this.x = t, this.y = e, this.z = i, this.w = n, this;
    },
    setScalar: function(t) {
      return this.w = this.z = this.y = this.x = t, this;
    },
    setX: function(t) {
      return this.x = t, this;
    },
    setY: function(t) {
      return this.y = t, this;
    },
    setZ: function(t) {
      return this.z = t, this;
    },
    setW: function(t) {
      return this.w = t, this;
    },
    setComponent: function(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw Error("index is out of range: " + t);
      }
      return this;
    },
    getComponent: function(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw Error("index is out of range: " + t);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
    },
    add: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
      ), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    },
    addScalar: function(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    },
    addVectors: function(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    },
    addScaledVector: function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    },
    sub: function(t, e) {
      return e !== void 0 ? (console.warn(
        "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
      ), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    },
    subScalar: function(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    },
    subVectors: function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    },
    multiplyScalar: function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    },
    applyMatrix4: function(t) {
      var e = this.x, i = this.y, n = this.z, o = this.w;
      return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * o, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * o, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * o, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * o, this;
    },
    divideScalar: function(t) {
      return this.multiplyScalar(1 / t);
    },
    setAxisAngleFromQuaternion: function(t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    },
    setAxisAngleFromRotationMatrix: function(t) {
      t = t.elements;
      var e = t[0], i = t[4], n = t[8], o = t[1], s = t[5], l = t[9], h = t[2], c = t[6], p = t[10];
      return 0.01 > Math.abs(i - o) && 0.01 > Math.abs(n - h) && 0.01 > Math.abs(l - c) ? 0.1 > Math.abs(i + o) && 0.1 > Math.abs(n + h) && 0.1 > Math.abs(l + c) && 0.1 > Math.abs(e + s + p - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, e = (e + 1) / 2, s = (s + 1) / 2, p = (p + 1) / 2, i = (i + o) / 4, n = (n + h) / 4, l = (l + c) / 4, e > s && e > p ? 0.01 > e ? (c = 0, i = h = 0.707106781) : (c = Math.sqrt(e), h = i / c, i = n / c) : s > p ? 0.01 > s ? (c = 0.707106781, h = 0, i = 0.707106781) : (h = Math.sqrt(s), c = i / h, i = l / h) : 0.01 > p ? (h = c = 0.707106781, i = 0) : (i = Math.sqrt(p), c = n / i, h = l / i), this.set(c, h, i, t), this) : (t = Math.sqrt((c - l) * (c - l) + (n - h) * (n - h) + (o - i) * (o - i)), 1e-3 > Math.abs(t) && (t = 1), this.x = (c - l) / t, this.y = (n - h) / t, this.z = (o - i) / t, this.w = Math.acos((e + s + p - 1) / 2), this);
    },
    min: function(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    },
    max: function(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    },
    clamp: function(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    },
    clampScalar: function() {
      var t, e;
      return function(i, n) {
        return t === void 0 && (t = new nt(), e = new nt()), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e);
      };
    }(),
    clampLength: function(t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(t, Math.min(e, i))
      );
    },
    floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    },
    ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    },
    round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
      return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this;
    },
    negate: function() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    },
    lerpVectors: function(t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t);
    },
    equals: function(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    },
    fromBufferAttribute: function(t, e, i) {
      return i !== void 0 && console.warn(
        "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
      ), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
  }), Tt.prototype = Object.assign(Object.create($.prototype), {
    constructor: Tt,
    isWebGLRenderTarget: !0,
    setSize: function(t, e) {
      (this.width !== t || this.height !== e) && (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Rt.prototype = Object.create(Tt.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isWebGLRenderTargetCube = !0, vt.prototype = Object.create(kt.prototype), vt.prototype.constructor = vt, vt.prototype.isDataTexture = !0, Object.assign(Nt.prototype, {
    isBox3: !0,
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromArray: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0, h = 0, c = t.length; h < c; h += 3) {
        var p = t[h], f = t[h + 1], d = t[h + 2];
        p < e && (e = p), f < i && (i = f), d < n && (n = d), p > o && (o = p), f > s && (s = f), d > l && (l = d);
      }
      return this.min.set(e, i, n), this.max.set(o, s, l), this;
    },
    setFromBufferAttribute: function(t) {
      for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0, h = 0, c = t.count; h < c; h++) {
        var p = t.getX(h), f = t.getY(h), d = t.getZ(h);
        p < e && (e = p), f < i && (i = f), d < n && (n = d), p > o && (o = p), f > s && (s = f), d > l && (l = d);
      }
      return this.min.set(e, i, n), this.max.set(o, s, l), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new S();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    setFromObject: function(t) {
      return this.makeEmpty(), this.expandByObject(t);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new S()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), t = new S()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    expandByObject: function() {
      function t(s) {
        var l = s.geometry;
        if (l !== void 0) {
          if (l.isGeometry)
            for (l = l.vertices, i = 0, n = l.length; i < n; i++)
              o.copy(l[i]), o.applyMatrix4(s.matrixWorld), e.expandByPoint(o);
          else if (l.isBufferGeometry && (l = l.attributes.position, l !== void 0))
            for (i = 0, n = l.count; i < n; i++)
              o.fromBufferAttribute(l, i).applyMatrix4(s.matrixWorld), e.expandByPoint(o);
        }
      }
      var e, i, n, o = new S();
      return function(s) {
        return e = this, s.updateMatrixWorld(!0), s.traverse(t), this;
      };
    }(),
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new S()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    },
    intersectsSphere: function() {
      var t = new S();
      return function(e) {
        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius;
      };
    }(),
    intersectsPlane: function(t) {
      if (0 < t.normal.x)
        var e = t.normal.x * this.min.x, i = t.normal.x * this.max.x;
      else
        e = t.normal.x * this.max.x, i = t.normal.x * this.min.x;
      return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
    },
    intersectsTriangle: function() {
      function t(d) {
        var v, w = 0;
        for (v = d.length - 3; w <= v; w += 3) {
          h.fromArray(d, w);
          var P = p.x * Math.abs(h.x) + p.y * Math.abs(h.y) + p.z * Math.abs(h.z), R = e.dot(h), I = i.dot(h), Q = n.dot(h);
          if (Math.max(-Math.max(R, I, Q), Math.min(R, I, Q)) > P)
            return !1;
        }
        return !0;
      }
      var e = new S(), i = new S(), n = new S(), o = new S(), s = new S(), l = new S(), h = new S(), c = new S(), p = new S(), f = new S();
      return function(d) {
        return this.isEmpty() || (this.getCenter(c), p.subVectors(this.max, c), e.subVectors(d.a, c), i.subVectors(d.b, c), n.subVectors(d.c, c), o.subVectors(i, e), s.subVectors(n, i), l.subVectors(e, n), d = [
          0,
          -o.z,
          o.y,
          0,
          -s.z,
          s.y,
          0,
          -l.z,
          l.y,
          o.z,
          0,
          -o.x,
          s.z,
          0,
          -s.x,
          l.z,
          0,
          -l.x,
          -o.y,
          o.x,
          0,
          -s.y,
          s.x,
          0,
          -l.y,
          l.x,
          0
        ], !t(d)) || (d = [1, 0, 0, 0, 1, 0, 0, 0, 1], !t(d)) ? !1 : (f.crossVectors(o, s), d = [f.x, f.y, f.z], t(d));
      };
    }(),
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new S()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new S();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    getBoundingSphere: function() {
      var t = new S();
      return function(e) {
        return e === void 0 && (console.warn(
          "THREE.Box3: .getBoundingSphere() target is now required"
        ), e = new Ut()), this.getCenter(e.center), e.radius = 0.5 * this.getSize(t).length(), e;
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    applyMatrix4: function() {
      var t = [
        new S(),
        new S(),
        new S(),
        new S(),
        new S(),
        new S(),
        new S(),
        new S()
      ];
      return function(e) {
        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this);
      };
    }(),
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(Ut.prototype, {
    set: function(t, e) {
      return this.center.copy(t), this.radius = e, this;
    },
    setFromPoints: function() {
      var t = new Nt();
      return function(e, i) {
        var n = this.center;
        i !== void 0 ? n.copy(i) : t.setFromPoints(e).getCenter(n);
        for (var o = i = 0, s = e.length; o < s; o++)
          i = Math.max(i, n.distanceToSquared(e[o]));
        return this.radius = Math.sqrt(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    },
    empty: function() {
      return 0 >= this.radius;
    },
    containsPoint: function(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(t) {
      return t.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    },
    intersectsBox: function(t) {
      return t.intersectsSphere(this);
    },
    intersectsPlane: function(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(t, e) {
      var i = this.center.distanceToSquared(t);
      return e === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new S()), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    },
    getBoundingBox: function(t) {
      return t === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Nt()), t.set(this.center, this.center), t.expandByScalar(this.radius), t;
    },
    applyMatrix4: function(t) {
      return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this;
    },
    translate: function(t) {
      return this.center.add(t), this;
    },
    equals: function(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
  }), Object.assign(Ct.prototype, {
    set: function(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    },
    setComponents: function(t, e, i, n) {
      return this.normal.set(t, e, i), this.constant = n, this;
    },
    setFromNormalAndCoplanarPoint: function(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
      var t = new S(), e = new S();
      return function(i, n, o) {
        return n = t.subVectors(o, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    },
    normalize: function() {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    },
    negate: function() {
      return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(t) {
      return this.normal.dot(t) + this.constant;
    },
    distanceToSphere: function(t) {
      return this.distanceToPoint(t.center) - t.radius;
    },
    projectPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new S()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    },
    intersectLine: function() {
      var t = new S();
      return function(e, i) {
        i === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new S());
        var n = e.delta(t), o = this.normal.dot(n);
        if (o === 0) {
          if (this.distanceToPoint(e.start) === 0)
            return i.copy(e.start);
        } else if (o = -(e.start.dot(this.normal) + this.constant) / o, !(0 > o || 1 < o))
          return i.copy(n).multiplyScalar(o).add(e.start);
      };
    }(),
    intersectsLine: function(t) {
      var e = this.distanceToPoint(t.start);
      return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e;
    },
    intersectsBox: function(t) {
      return t.intersectsPlane(this);
    },
    intersectsSphere: function(t) {
      return t.intersectsPlane(this);
    },
    coplanarPoint: function(t) {
      return t === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new S()), t.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
      var t = new S(), e = new Mt();
      return function(i, n) {
        return n = n || e.getNormalMatrix(i), i = this.coplanarPoint(t).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this;
      };
    }(),
    translate: function(t) {
      return this.constant -= t.dot(this.normal), this;
    },
    equals: function(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
  }), Object.assign(at.prototype, {
    set: function(t, e, i, n, o, s) {
      var l = this.planes;
      return l[0].copy(t), l[1].copy(e), l[2].copy(i), l[3].copy(n), l[4].copy(o), l[5].copy(s), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        e[i].copy(t.planes[i]);
      return this;
    },
    setFromMatrix: function(t) {
      var e = this.planes, i = t.elements;
      t = i[0];
      var n = i[1], o = i[2], s = i[3], l = i[4], h = i[5], c = i[6], p = i[7], f = i[8], d = i[9], v = i[10], w = i[11], P = i[12], R = i[13], I = i[14];
      return i = i[15], e[0].setComponents(s - t, p - l, w - f, i - P).normalize(), e[1].setComponents(s + t, p + l, w + f, i + P).normalize(), e[2].setComponents(s + n, p + h, w + d, i + R).normalize(), e[3].setComponents(s - n, p - h, w - d, i - R).normalize(), e[4].setComponents(s - o, p - c, w - v, i - I).normalize(), e[5].setComponents(s + o, p + c, w + v, i + I).normalize(), this;
    },
    intersectsObject: function() {
      var t = new Ut();
      return function(e) {
        var i = e.geometry;
        return i.boundingSphere === null && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSprite: function() {
      var t = new Ut();
      return function(e) {
        return t.center.set(0, 0, 0), t.radius = 0.7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t);
      };
    }(),
    intersectsSphere: function(t) {
      var e = this.planes, i = t.center;
      t = -t.radius;
      for (var n = 0; 6 > n; n++)
        if (e[n].distanceToPoint(i) < t)
          return !1;
      return !0;
    },
    intersectsBox: function() {
      var t = new S();
      return function(e) {
        for (var i = this.planes, n = 0; 6 > n; n++) {
          var o = i[n];
          if (t.x = 0 < o.normal.x ? e.max.x : e.min.x, t.y = 0 < o.normal.y ? e.max.y : e.min.y, t.z = 0 < o.normal.z ? e.max.z : e.min.z, 0 > o.distanceToPoint(t))
            return !1;
        }
        return !0;
      };
    }(),
    containsPoint: function(t) {
      for (var e = this.planes, i = 0; 6 > i; i++)
        if (0 > e[i].distanceToPoint(t))
          return !1;
      return !0;
    }
  });
  var li = {
    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif
`,
    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
`,
    alphatest_fragment: `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif
`,
    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif
`,
    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    begin_vertex: `
vec3 transformed = vec3( position );
`,
    beginnormal_vertex: `
vec3 objectNormal = vec3( normal );
`,
    bsdfs: `float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`,
    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif
`,
    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
	}
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;
		}
		if ( clipped ) discard;
	#endif
#endif
`,
    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
		varying vec3 vViewPosition;
	#endif
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif
`,
    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	varying vec3 vViewPosition;
#endif
`,
    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	vViewPosition = - mvPosition.xyz;
#endif
`,
    color_fragment: `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,
    color_pars_fragment: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif
`,
    color_pars_vertex: `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,
    color_vertex: `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`,
    common: `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
`,
    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_textureSize (1024.0)
int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}
#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;
	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	float powScale = exp2_packed.x * exp2_packed.y;
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;
	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);
	float rcpPowScale = 1.0 / powScale;
	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}
#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
vec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;
	level0 += min( floor( s + 0.5 ), 5.0 );
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
	vec4 result = mix(color10, color20, t);
	return vec4(result.rgb, 1.0);
}
#endif
`,
    defaultnormal_vertex: `vec3 transformedNormal = normalMatrix * objectNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
`,
    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif
`,
    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
#endif
`,
    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif
`,
    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif
`,
    encodings_fragment: `  gl_FragColor = linearToOutputTexel( gl_FragColor );
`,
    encodings_pars_fragment: `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`,
    envmap_fragment: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToVertex, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		vec2 sampleUV;
		reflectVec = normalize( reflectVec );
		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	envColor = envMapTexelToLinear( envColor );
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif
`,
    envmap_pars_fragment: `#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif
#ifdef USE_ENVMAP
	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif
`,
    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif
`,
    envmap_physical_pars_fragment: `#if defined( USE_ENVMAP ) && defined( PHYSICAL )
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
		#else
			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif
`,
    envmap_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif
`,
    fog_vertex: `#ifdef USE_FOG
	fogDepth = -mvPosition.z;
#endif
`,
    fog_pars_vertex: `#ifdef USE_FOG
	varying float fogDepth;
#endif
`,
    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`,
    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
`,
    gradientmap_pars_fragment: `#ifdef TOON
	uniform sampler2D gradientMap;
	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
		#ifdef USE_GRADIENTMAP
			return texture2D( gradientMap, coord ).rgb;
		#else
			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
		#endif
	}
#endif
`,
    lightmap_fragment: `#ifdef USE_LIGHTMAP
	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
#endif
`,
    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    lights_lambert_vertex: `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
#endif
`,
    lights_pars_begin: `uniform vec3 ambientLightColor;
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif
`,
    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,
    lights_phong_pars_fragment: `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	#ifdef TOON
		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#else
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;
	#endif
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
`,
    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`,
    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	#ifndef STANDARD
		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
	#ifndef STANDARD
		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}
`,
    lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
#endif
#if defined( RE_IndirectDiffuse )
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );
#endif
`,
    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif
#endif
`,
    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
#endif
`,
    logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
#endif
`,
    logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#else
		uniform float logDepthBufFC;
	#endif
#endif
`,
    logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
	#else
		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
		gl_Position.z *= gl_Position.w;
	#endif
#endif
`,
    map_fragment: `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif
`,
    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif
`,
    map_particle_fragment: `#ifdef USE_MAP
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
`,
    map_particle_pars_fragment: `#ifdef USE_MAP
	uniform mat3 uvTransform;
	uniform sampler2D map;
#endif
`,
    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif
`,
    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif
`,
    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
	#endif
#endif
`,
    normal_fragment_begin: `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
#endif
`,
    normal_fragment_maps: `#ifdef USE_NORMALMAP
	#ifdef OBJECTSPACE_NORMALMAP
		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
		#ifdef FLIP_SIDED
			normal = - normal;
		#endif
		#ifdef DOUBLE_SIDED
			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		normal = normalize( normalMatrix * normal );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif
`,
    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	#ifdef OBJECTSPACE_NORMALMAP
		uniform mat3 normalMatrix;
	#else
		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
			vec2 st0 = dFdx( vUv.st );
			vec2 st1 = dFdy( vUv.st );
			float scale = sign( st1.t * st0.s - st0.t * st1.s );
			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
			vec3 N = normalize( surf_norm );
			mat3 tsn = mat3( S, T, N );
			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
			mapN.xy *= normalScale;
			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			return normalize( tsn * mapN );
		}
	#endif
#endif
`,
    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,
    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
`,
    project_vertex: `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
gl_Position = projectionMatrix * mvPosition;
`,
    dithering_fragment: `#if defined( DITHERING )
  gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif
`,
    dithering_pars_fragment: `#if defined( DITHERING )
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif
`,
    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif
`,
    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    shadowmap_pars_fragment: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
		const vec2 offset = vec2( 0.0, 1.0 );
		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
		vec2 f = fract( uv * size + 0.5 );
		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );
		return c;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif
`,
    shadowmap_pars_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
#endif
`,
    shadowmap_vertex: `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#endif
#endif
`,
    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#endif
	#endif
	return shadow;
}
`,
    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif
`,
    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif
`,
    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif
`,
    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    tonemapping_fragment: `#if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif
`,
    tonemapping_pars_fragment: `#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
`,
    uv_pars_fragment: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
#endif`,
    uv_pars_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
`,
    uv_vertex: `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
#endif`,
    uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = uv2;
#endif`,
    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
#endif
`,
    background_frag: `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
}
`,
    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position, 1.0 );
	gl_Position.z = 1.0;
}
`,
    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor.a *= opacity;
}
`,
    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}
`,
    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
	#endif
}
`,
    depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
`,
    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}
`,
    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}
`,
    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV;
	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;
	gl_FragColor = texture2D( tEquirect, sampleUV );
}
`,
    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}
`,
    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	vLineDistance = scale * lineDistance;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`,
    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`,
    meshlambert_frag: `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshlambert_vert: `#define LAMBERT
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	vec4 matcapColor = texture2D( matcap, uv );
	matcapColor = matcapTexelToLinear( matcapColor );
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}
`,
    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    meshphysical_frag: `#define PHYSICAL
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,
    meshphysical_vert: `#define PHYSICAL
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    normal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}
`,
    normal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )
	vViewPosition = - mvPosition.xyz;
#endif
}
`,
    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}
`,
    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <fog_fragment>
}
`,
    shadow_vert: `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,
    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`,
    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`
  }, vn = {
    merge: function(t) {
      for (var e = {}, i = 0; i < t.length; i++) {
        var n = this.clone(t[i]), o;
        for (o in n)
          e[o] = n[o];
      }
      return e;
    },
    clone: function(t) {
      var e = {}, i;
      for (i in t) {
        e[i] = {};
        for (var n in t[i]) {
          var o = t[i][n];
          o && (o.isColor || o.isMatrix3 || o.isMatrix4 || o.isVector2 || o.isVector3 || o.isVector4 || o.isTexture) ? e[i][n] = o.clone() : Array.isArray(o) ? e[i][n] = o.slice() : e[i][n] = o;
        }
      }
      return e;
    }
  }, Tr = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Object.assign(Y.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function(t) {
      return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this;
    },
    setScalar: function(t) {
      return this.b = this.g = this.r = t, this;
    },
    setHex: function(t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, this;
    },
    setRGB: function(t, e, i) {
      return this.r = t, this.g = e, this.b = i, this;
    },
    setHSL: function() {
      function t(e, i, n) {
        return 0 > n && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (i - e) * n : 0.5 > n ? i : n < 2 / 3 ? e + 6 * (i - e) * (2 / 3 - n) : e;
      }
      return function(e, i, n) {
        return e = Je.euclideanModulo(e, 1), i = Je.clamp(i, 0, 1), n = Je.clamp(n, 0, 1), i === 0 ? this.r = this.g = this.b = n : (i = 0.5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this;
      };
    }(),
    setStyle: function(t) {
      function e(l) {
        l !== void 0 && 1 > parseFloat(l) && console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
      }
      var i;
      if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
        var n = i[2];
        switch (i[1]) {
          case "rgb":
          case "rgba":
            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
            if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            ))
              return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
            break;
          case "hsl":
          case "hsla":
            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
              n
            )) {
              n = parseFloat(i[1]) / 360;
              var o = parseInt(i[2], 10) / 100, s = parseInt(i[3], 10) / 100;
              return e(i[5]), this.setHSL(n, o, s);
            }
        }
      } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
        if (i = i[1], n = i.length, n === 3)
          return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
        if (n === 6)
          return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this;
      }
      return t && 0 < t.length && (i = Tr[t], i !== void 0 ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    },
    copyGammaToLinear: function(t, e) {
      return e === void 0 && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    copyLinearToGamma: function(t, e) {
      return e === void 0 && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    },
    convertGammaToLinear: function(t) {
      return this.copyGammaToLinear(this, t), this;
    },
    convertLinearToGamma: function(t) {
      return this.copyLinearToGamma(this, t), this;
    },
    copySRGBToLinear: function() {
      function t(e) {
        return 0.04045 > e ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    copyLinearToSRGB: function() {
      function t(e) {
        return 31308e-7 > e ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      return function(e) {
        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this;
      };
    }(),
    convertSRGBToLinear: function() {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function() {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(t) {
      t === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });
      var e = this.r, i = this.g, n = this.b, o = Math.max(e, i, n), s = Math.min(e, i, n), l, h = (s + o) / 2;
      if (s === o)
        s = l = 0;
      else {
        var c = o - s;
        switch (s = 0.5 >= h ? c / (o + s) : c / (2 - o - s), o) {
          case e:
            l = (i - n) / c + (i < n ? 6 : 0);
            break;
          case i:
            l = (n - e) / c + 2;
            break;
          case n:
            l = (e - i) / c + 4;
        }
        l /= 6;
      }
      return t.h = l, t.s = s, t.l = h, t;
    },
    getStyle: function() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function() {
      var t = {};
      return function(e, i, n) {
        return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this;
      };
    }(),
    add: function(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    },
    addColors: function(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    },
    addScalar: function(t) {
      return this.r += t, this.g += t, this.b += t, this;
    },
    sub: function(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    },
    multiply: function(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    },
    multiplyScalar: function(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    },
    lerp: function(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    },
    lerpHSL: function() {
      var t = { h: 0, s: 0, l: 0 }, e = { h: 0, s: 0, l: 0 };
      return function(i, n) {
        this.getHSL(t), i.getHSL(e), i = Je.lerp(t.h, e.h, n);
        var o = Je.lerp(t.s, e.s, n);
        return n = Je.lerp(t.l, e.l, n), this.setHSL(i, o, n), this;
      };
    }(),
    equals: function(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function(t, e) {
      return e === void 0 && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  var Re = {
    common: {
      diffuse: { value: new Y(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Mt() },
      alphaMap: { value: null }
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new y(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Y(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} }
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} }
      }
    },
    points: {
      diffuse: { value: new Y(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Mt() }
    },
    sprite: {
      diffuse: { value: new Y(15658734) },
      opacity: { value: 1 },
      center: { value: new y(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      uvTransform: { value: new Mt() }
    }
  }, Hr = {
    basic: {
      uniforms: vn.merge([
        Re.common,
        Re.specularmap,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.fog
      ]),
      vertexShader: li.meshbasic_vert,
      fragmentShader: li.meshbasic_frag
    },
    lambert: {
      uniforms: vn.merge([
        Re.common,
        Re.specularmap,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.fog,
        Re.lights,
        { emissive: { value: new Y(0) } }
      ]),
      vertexShader: li.meshlambert_vert,
      fragmentShader: li.meshlambert_frag
    },
    phong: {
      uniforms: vn.merge([
        Re.common,
        Re.specularmap,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.gradientmap,
        Re.fog,
        Re.lights,
        {
          emissive: { value: new Y(0) },
          specular: { value: new Y(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: li.meshphong_vert,
      fragmentShader: li.meshphong_frag
    },
    standard: {
      uniforms: vn.merge([
        Re.common,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.roughnessmap,
        Re.metalnessmap,
        Re.fog,
        Re.lights,
        {
          emissive: { value: new Y(0) },
          roughness: { value: 0.5 },
          metalness: { value: 0.5 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: li.meshphysical_vert,
      fragmentShader: li.meshphysical_frag
    },
    matcap: {
      uniforms: vn.merge([
        Re.common,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: li.meshmatcap_vert,
      fragmentShader: li.meshmatcap_frag
    },
    points: {
      uniforms: vn.merge([Re.points, Re.fog]),
      vertexShader: li.points_vert,
      fragmentShader: li.points_frag
    },
    dashed: {
      uniforms: vn.merge([
        Re.common,
        Re.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: li.linedashed_vert,
      fragmentShader: li.linedashed_frag
    },
    depth: {
      uniforms: vn.merge([Re.common, Re.displacementmap]),
      vertexShader: li.depth_vert,
      fragmentShader: li.depth_frag
    },
    normal: {
      uniforms: vn.merge([
        Re.common,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: li.normal_vert,
      fragmentShader: li.normal_frag
    },
    sprite: {
      uniforms: vn.merge([Re.sprite, Re.fog]),
      vertexShader: li.sprite_vert,
      fragmentShader: li.sprite_frag
    },
    background: {
      uniforms: { uvTransform: { value: new Mt() }, t2D: { value: null } },
      vertexShader: li.background_vert,
      fragmentShader: li.background_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: li.cube_vert,
      fragmentShader: li.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: li.equirect_vert,
      fragmentShader: li.equirect_frag
    },
    distanceRGBA: {
      uniforms: vn.merge([
        Re.common,
        Re.displacementmap,
        {
          referencePosition: { value: new S() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: li.distanceRGBA_vert,
      fragmentShader: li.distanceRGBA_frag
    },
    shadow: {
      uniforms: vn.merge([
        Re.lights,
        Re.fog,
        { color: { value: new Y(0) }, opacity: { value: 1 } }
      ]),
      vertexShader: li.shadow_vert,
      fragmentShader: li.shadow_frag
    }
  };
  Hr.physical = {
    uniforms: vn.merge([
      Hr.standard.uniforms,
      { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }
    ]),
    vertexShader: li.meshphysical_vert,
    fragmentShader: li.meshphysical_frag
  }, Object.assign(B.prototype, {
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
      for (var e = 0, i = t.vertexNormals.length; e < i; e++)
        this.vertexNormals[e] = t.vertexNormals[e].clone();
      for (e = 0, i = t.vertexColors.length; e < i; e++)
        this.vertexColors[e] = t.vertexColors[e].clone();
      return this;
    }
  }), E.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), E.DefaultOrder = "XYZ", Object.defineProperties(E.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x = t, this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y = t, this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(t) {
        this._z = t, this.onChangeCallback();
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(t) {
        this._order = t, this.onChangeCallback();
      }
    }
  }), Object.assign(E.prototype, {
    isEuler: !0,
    set: function(t, e, i, n) {
      return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(t, e, i) {
      var n = Je.clamp, o = t.elements;
      t = o[0];
      var s = o[4], l = o[8], h = o[1], c = o[5], p = o[9], f = o[2], d = o[6];
      return o = o[10], e = e || this._order, e === "XYZ" ? (this._y = Math.asin(n(l, -1, 1)), 0.99999 > Math.abs(l) ? (this._x = Math.atan2(-p, o), this._z = Math.atan2(-s, t)) : (this._x = Math.atan2(d, c), this._z = 0)) : e === "YXZ" ? (this._x = Math.asin(-n(p, -1, 1)), 0.99999 > Math.abs(p) ? (this._y = Math.atan2(l, o), this._z = Math.atan2(h, c)) : (this._y = Math.atan2(-f, t), this._z = 0)) : e === "ZXY" ? (this._x = Math.asin(n(d, -1, 1)), 0.99999 > Math.abs(d) ? (this._y = Math.atan2(-f, o), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(h, t))) : e === "ZYX" ? (this._y = Math.asin(-n(f, -1, 1)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(d, o), this._z = Math.atan2(h, t)) : (this._x = 0, this._z = Math.atan2(-s, c))) : e === "YZX" ? (this._z = Math.asin(n(h, -1, 1)), 0.99999 > Math.abs(h) ? (this._x = Math.atan2(-p, c), this._y = Math.atan2(-f, t)) : (this._x = 0, this._y = Math.atan2(l, o))) : e === "XZY" ? (this._z = Math.asin(-n(s, -1, 1)), 0.99999 > Math.abs(s) ? (this._x = Math.atan2(d, c), this._y = Math.atan2(l, t)) : (this._x = Math.atan2(-p, o), this._y = 0)) : console.warn(
        "THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e
      ), this._order = e, i !== !1 && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
      var t = new pt();
      return function(e, i, n) {
        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n);
      };
    }(),
    setFromVector3: function(t, e) {
      return this.set(t.x, t.y, t.z, e || this._order);
    },
    reorder: function() {
      var t = new gt();
      return function(e) {
        return t.setFromEuler(this), this.setFromQuaternion(t, e);
      };
    }(),
    equals: function(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    },
    fromArray: function(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this.onChangeCallback(), this;
    },
    toArray: function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    },
    toVector3: function(t) {
      return t ? t.set(this._x, this._y, this._z) : new S(this._x, this._y, this._z);
    },
    onChange: function(t) {
      return this.onChangeCallback = t, this;
    },
    onChangeCallback: function() {
    }
  }), Object.assign(Z.prototype, {
    set: function(t) {
      this.mask = 1 << t | 0;
    },
    enable: function(t) {
      this.mask = this.mask | 1 << t | 0;
    },
    toggle: function(t) {
      this.mask ^= 1 << t | 0;
    },
    disable: function(t) {
      this.mask &= ~(1 << t | 0);
    },
    test: function(t) {
      return (this.mask & t.mask) !== 0;
    }
  });
  var hh = 0;
  z.DefaultUp = new S(0, 1, 0), z.DefaultMatrixAutoUpdate = !0, z.prototype = Object.assign(Object.create($.prototype), {
    constructor: z,
    isObject3D: !0,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix: function(t) {
      this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(t) {
      return this.quaternion.premultiply(t), this;
    },
    setRotationFromAxisAngle: function(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    },
    setRotationFromEuler: function(t) {
      this.quaternion.setFromEuler(t, !0);
    },
    setRotationFromMatrix: function(t) {
      this.quaternion.setFromRotationMatrix(t);
    },
    setRotationFromQuaternion: function(t) {
      this.quaternion.copy(t);
    },
    rotateOnAxis: function() {
      var t = new gt();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this;
      };
    }(),
    rotateOnWorldAxis: function() {
      var t = new gt();
      return function(e, i) {
        return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this;
      };
    }(),
    rotateX: function() {
      var t = new S(1, 0, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateY: function() {
      var t = new S(0, 1, 0);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    rotateZ: function() {
      var t = new S(0, 0, 1);
      return function(e) {
        return this.rotateOnAxis(t, e);
      };
    }(),
    translateOnAxis: function() {
      var t = new S();
      return function(e, i) {
        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this;
      };
    }(),
    translateX: function() {
      var t = new S(1, 0, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateY: function() {
      var t = new S(0, 1, 0);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    translateZ: function() {
      var t = new S(0, 0, 1);
      return function(e) {
        return this.translateOnAxis(t, e);
      };
    }(),
    localToWorld: function(t) {
      return t.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
      var t = new pt();
      return function(e) {
        return e.applyMatrix4(t.getInverse(this.matrixWorld));
      };
    }(),
    lookAt: function() {
      var t = new gt(), e = new pt(), i = new S(), n = new S();
      return function(o, s, l) {
        o.isVector3 ? i.copy(o) : i.set(o, s, l), o = this.parent, this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), o && (e.extractRotation(o.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()));
      };
    }(),
    add: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.add(arguments[e]);
        return this;
      }
      return t === this ? (console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        t
      ), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error(
        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
        t
      ), this);
    },
    remove: function(t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++)
          this.remove(arguments[e]);
        return this;
      }
      return e = this.children.indexOf(t), e !== -1 && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(e, 1)), this;
    },
    getObjectById: function(t) {
      return this.getObjectByProperty("id", t);
    },
    getObjectByName: function(t) {
      return this.getObjectByProperty("name", t);
    },
    getObjectByProperty: function(t, e) {
      if (this[t] === e)
        return this;
      for (var i = 0, n = this.children.length; i < n; i++) {
        var o = this.children[i].getObjectByProperty(t, e);
        if (o !== void 0)
          return o;
      }
    },
    getWorldPosition: function(t) {
      return t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldPosition() target is now required"
      ), t = new S()), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
      var t = new S(), e = new S();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldQuaternion() target is now required"
        ), i = new gt()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i;
      };
    }(),
    getWorldScale: function() {
      var t = new S(), e = new gt();
      return function(i) {
        return i === void 0 && (console.warn(
          "THREE.Object3D: .getWorldScale() target is now required"
        ), i = new S()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i;
      };
    }(),
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Object3D: .getWorldDirection() target is now required"
      ), t = new S()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(t) {
      t(this);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].traverse(t);
    },
    traverseVisible: function(t) {
      if (this.visible !== !1) {
        t(this);
        for (var e = this.children, i = 0, n = e.length; i < n; i++)
          e[i].traverseVisible(t);
      }
    },
    traverseAncestors: function(t) {
      var e = this.parent;
      e !== null && (t(e), e.traverseAncestors(t));
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), this.matrixWorldNeedsUpdate = !1, t = !0);
      for (var e = this.children, i = 0, n = e.length; i < n; i++)
        e[i].updateMatrixWorld(t);
    },
    updateWorldMatrix: function(t, e) {
      var i = this.parent;
      if (t === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(
        this.parent.matrixWorld,
        this.matrix
      ), e === !0)
        for (t = this.children, e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0);
    },
    toJSON: function(t) {
      function e(f, d) {
        return f[d.uuid] === void 0 && (f[d.uuid] = d.toJSON(t)), d.uuid;
      }
      function i(f) {
        var d = [], v;
        for (v in f) {
          var w = f[v];
          delete w.metadata, d.push(w);
        }
        return d;
      }
      var n = t === void 0 || typeof t == "string", o = {};
      n && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      }, o.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var s = {};
      if (s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
        s.geometry = e(t.geometries, this.geometry);
        var l = this.geometry.parameters;
        if (l !== void 0 && l.shapes !== void 0)
          if (l = l.shapes, Array.isArray(l))
            for (var h = 0, c = l.length; h < c; h++)
              e(t.shapes, l[h]);
          else
            e(t.shapes, l);
      }
      if (this.material !== void 0)
        if (Array.isArray(this.material)) {
          for (l = [], h = 0, c = this.material.length; h < c; h++)
            l.push(e(t.materials, this.material[h]));
          s.material = l;
        } else
          s.material = e(t.materials, this.material);
      if (0 < this.children.length)
        for (s.children = [], h = 0; h < this.children.length; h++)
          s.children.push(this.children[h].toJSON(t).object);
      if (n) {
        n = i(t.geometries), h = i(t.materials), c = i(t.textures);
        var p = i(t.images);
        l = i(t.shapes), 0 < n.length && (o.geometries = n), 0 < h.length && (o.materials = h), 0 < c.length && (o.textures = c), 0 < p.length && (o.images = p), 0 < l.length && (o.shapes = l);
      }
      return o.object = s, o;
    },
    clone: function(t) {
      return new this.constructor().copy(this, t);
    },
    copy: function(t, e) {
      if (e === void 0 && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
        for (e = 0; e < t.children.length; e++)
          this.add(t.children[e].clone());
      return this;
    }
  });
  var uh = 0;
  X.prototype = Object.assign(Object.create($.prototype), {
    constructor: X,
    isGeometry: !0,
    applyMatrix: function(t) {
      for (var e = new Mt().getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++)
        this.vertices[i].applyMatrix4(t);
      for (i = 0, n = this.faces.length; i < n; i++) {
        t = this.faces[i], t.normal.applyMatrix3(e).normalize();
        for (var o = 0, s = t.vertexNormals.length; o < s; o++)
          t.vertexNormals[o].applyMatrix3(e).normalize();
      }
      return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
    },
    rotateX: function() {
      var t = new pt();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new pt();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new pt();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new pt();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new pt();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new z();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    fromBufferGeometry: function(t) {
      function e(P, R, I, Q) {
        var W = h === void 0 ? [] : [i.colors[P].clone(), i.colors[R].clone(), i.colors[I].clone()], st = l === void 0 ? [] : [
          new S().fromArray(l, 3 * P),
          new S().fromArray(l, 3 * R),
          new S().fromArray(l, 3 * I)
        ];
        Q = new B(P, R, I, st, W, Q), i.faces.push(Q), c !== void 0 && i.faceVertexUvs[0].push([
          new y().fromArray(c, 2 * P),
          new y().fromArray(c, 2 * R),
          new y().fromArray(c, 2 * I)
        ]), p !== void 0 && i.faceVertexUvs[1].push([
          new y().fromArray(p, 2 * P),
          new y().fromArray(p, 2 * R),
          new y().fromArray(p, 2 * I)
        ]);
      }
      var i = this, n = t.index !== null ? t.index.array : void 0, o = t.attributes, s = o.position.array, l = o.normal !== void 0 ? o.normal.array : void 0, h = o.color !== void 0 ? o.color.array : void 0, c = o.uv !== void 0 ? o.uv.array : void 0, p = o.uv2 !== void 0 ? o.uv2.array : void 0;
      p !== void 0 && (this.faceVertexUvs[1] = []);
      for (var f = o = 0; o < s.length; o += 3, f += 2)
        i.vertices.push(new S().fromArray(s, o)), h !== void 0 && i.colors.push(new Y().fromArray(h, o));
      var d = t.groups;
      if (0 < d.length)
        for (o = 0; o < d.length; o++) {
          s = d[o];
          var v = s.start, w = s.count;
          for (f = v, v += w; f < v; f += 3)
            n !== void 0 ? e(n[f], n[f + 1], n[f + 2], s.materialIndex) : e(f, f + 1, f + 2, s.materialIndex);
        }
      else if (n !== void 0)
        for (o = 0; o < n.length; o += 3)
          e(n[o], n[o + 1], n[o + 2]);
      else
        for (o = 0; o < s.length / 3; o += 3)
          e(o, o + 1, o + 2);
      return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
    },
    center: function() {
      var t = new S();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    normalize: function() {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center, e = this.boundingSphere.radius;
      e = e === 0 ? 1 : 1 / e;
      var i = new pt();
      return i.set(
        e,
        0,
        0,
        -e * t.x,
        0,
        e,
        0,
        -e * t.y,
        0,
        0,
        e,
        -e * t.z,
        0,
        0,
        0,
        1
      ), this.applyMatrix(i), this;
    },
    computeFaceNormals: function() {
      for (var t = new S(), e = new S(), i = 0, n = this.faces.length; i < n; i++) {
        var o = this.faces[i], s = this.vertices[o.a], l = this.vertices[o.b];
        t.subVectors(this.vertices[o.c], l), e.subVectors(s, l), t.cross(e), t.normalize(), o.normal.copy(t);
      }
    },
    computeVertexNormals: function(t) {
      t === void 0 && (t = !0);
      var e, i = Array(this.vertices.length), n = 0;
      for (e = this.vertices.length; n < e; n++)
        i[n] = new S();
      if (t) {
        var o = new S(), s = new S();
        for (t = 0, n = this.faces.length; t < n; t++) {
          e = this.faces[t];
          var l = this.vertices[e.a], h = this.vertices[e.b], c = this.vertices[e.c];
          o.subVectors(c, h), s.subVectors(l, h), o.cross(s), i[e.a].add(o), i[e.b].add(o), i[e.c].add(o);
        }
      } else
        for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++)
          e = this.faces[t], i[e.a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal);
      for (n = 0, e = this.vertices.length; n < e; n++)
        i[n].normalize();
      for (t = 0, n = this.faces.length; t < n; t++)
        e = this.faces[t], l = e.vertexNormals, l.length === 3 ? (l[0].copy(i[e.a]), l[1].copy(i[e.b]), l[2].copy(i[e.c])) : (l[0] = i[e.a].clone(), l[1] = i[e.b].clone(), l[2] = i[e.c].clone());
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function() {
      var t;
      this.computeFaceNormals();
      var e = 0;
      for (t = this.faces.length; e < t; e++) {
        var i = this.faces[e], n = i.vertexNormals;
        n.length === 3 ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone());
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function() {
      var t, e, i = 0;
      for (e = this.faces.length; i < e; i++) {
        var n = this.faces[i];
        n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
        var o = 0;
        for (t = n.vertexNormals.length; o < t; o++)
          n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone();
      }
      var s = new X();
      for (s.faces = this.faces, o = 0, t = this.morphTargets.length; o < t; o++) {
        if (!this.morphNormals[o]) {
          this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
          var l = this.morphNormals[o].vertexNormals;
          for (i = 0, e = this.faces.length; i < e; i++) {
            var h = new S(), c = { a: new S(), b: new S(), c: new S() };
            n.push(h), l.push(c);
          }
        }
        for (l = this.morphNormals[o], s.vertices = this.morphTargets[o].vertices, s.computeFaceNormals(), s.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++)
          n = this.faces[i], h = l.faceNormals[i], c = l.vertexNormals[i], h.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2]);
      }
      for (i = 0, e = this.faces.length; i < e; i++)
        n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new Nt()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      this.boundingSphere === null && (this.boundingSphere = new Ut()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(t, e, i) {
      if (t && t.isGeometry) {
        var n, o = this.vertices.length, s = this.vertices, l = t.vertices, h = this.faces, c = t.faces, p = this.faceVertexUvs[0], f = t.faceVertexUvs[0], d = this.colors, v = t.colors;
        i === void 0 && (i = 0), e !== void 0 && (n = new Mt().getNormalMatrix(e)), t = 0;
        for (var w = l.length; t < w; t++) {
          var P = l[t].clone();
          e !== void 0 && P.applyMatrix4(e), s.push(P);
        }
        for (t = 0, w = v.length; t < w; t++)
          d.push(v[t].clone());
        for (t = 0, w = c.length; t < w; t++) {
          l = c[t];
          var R = l.vertexNormals;
          for (v = l.vertexColors, d = new B(l.a + o, l.b + o, l.c + o), d.normal.copy(l.normal), n !== void 0 && d.normal.applyMatrix3(n).normalize(), e = 0, s = R.length; e < s; e++)
            P = R[e].clone(), n !== void 0 && P.applyMatrix3(n).normalize(), d.vertexNormals.push(P);
          for (d.color.copy(l.color), e = 0, s = v.length; e < s; e++)
            P = v[e], d.vertexColors.push(P.clone());
          d.materialIndex = l.materialIndex + i, h.push(d);
        }
        for (t = 0, w = f.length; t < w; t++)
          if (i = f[t], n = [], i !== void 0) {
            for (e = 0, s = i.length; e < s; e++)
              n.push(i[e].clone());
            p.push(n);
          }
      } else
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          t
        );
    },
    mergeMesh: function(t) {
      t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error(
        "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
        t
      );
    },
    mergeVertices: function() {
      var t = {}, e = [], i = [], n = Math.pow(10, 4), o, s = 0;
      for (o = this.vertices.length; s < o; s++) {
        var l = this.vertices[s];
        l = Math.round(l.x * n) + "_" + Math.round(l.y * n) + "_" + Math.round(l.z * n), t[l] === void 0 ? (t[l] = s, e.push(this.vertices[s]), i[s] = e.length - 1) : i[s] = i[t[l]];
      }
      for (t = [], s = 0, o = this.faces.length; s < o; s++)
        for (n = this.faces[s], n.a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], l = 0; 3 > l; l++)
          if (n[l] === n[(l + 1) % 3]) {
            t.push(s);
            break;
          }
      for (s = t.length - 1; 0 <= s; s--)
        for (n = t[s], this.faces.splice(n, 1), i = 0, o = this.faceVertexUvs.length; i < o; i++)
          this.faceVertexUvs[i].splice(n, 1);
      return s = this.vertices.length - e.length, this.vertices = e, s;
    },
    setFromPoints: function(t) {
      this.vertices = [];
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.vertices.push(new S(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++)
        t[i]._id = i;
      t.sort(function(c, p) {
        return c.materialIndex - p.materialIndex;
      });
      var n = this.faceVertexUvs[0], o = this.faceVertexUvs[1], s, l;
      for (n && n.length === e && (s = []), o && o.length === e && (l = []), i = 0; i < e; i++) {
        var h = t[i]._id;
        s && s.push(n[h]), l && l.push(o[h]);
      }
      s && (this.faceVertexUvs[0] = s), l && (this.faceVertexUvs[1] = l);
    },
    toJSON: function() {
      function t(wt, C, D) {
        return D ? wt | 1 << C : wt & ~(1 << C);
      }
      function e(wt) {
        var C = wt.x.toString() + wt.y.toString() + wt.z.toString();
        return p[C] !== void 0 || (p[C] = c.length / 3, c.push(wt.x, wt.y, wt.z)), p[C];
      }
      function i(wt) {
        var C = wt.r.toString() + wt.g.toString() + wt.b.toString();
        return d[C] !== void 0 || (d[C] = f.length, f.push(wt.getHex())), d[C];
      }
      function n(wt) {
        var C = wt.x.toString() + wt.y.toString();
        return w[C] !== void 0 || (w[C] = v.length / 2, v.push(wt.x, wt.y)), w[C];
      }
      var o = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      if (o.uuid = this.uuid, o.type = this.type, this.name !== "" && (o.name = this.name), this.parameters !== void 0) {
        var s = this.parameters, l;
        for (l in s)
          s[l] !== void 0 && (o[l] = s[l]);
        return o;
      }
      for (s = [], l = 0; l < this.vertices.length; l++) {
        var h = this.vertices[l];
        s.push(h.x, h.y, h.z);
      }
      h = [];
      var c = [], p = {}, f = [], d = {}, v = [], w = {};
      for (l = 0; l < this.faces.length; l++) {
        var P = this.faces[l], R = this.faceVertexUvs[0][l] !== void 0, I = 0 < P.normal.length(), Q = 0 < P.vertexNormals.length, W = P.color.r !== 1 || P.color.g !== 1 || P.color.b !== 1, st = 0 < P.vertexColors.length, K = 0;
        K = t(K, 0, 0), K = t(K, 1, !0), K = t(K, 2, !1), K = t(K, 3, R), K = t(K, 4, I), K = t(K, 5, Q), K = t(K, 6, W), K = t(K, 7, st), h.push(K), h.push(P.a, P.b, P.c), h.push(P.materialIndex), R && (R = this.faceVertexUvs[0][l], h.push(n(R[0]), n(R[1]), n(R[2]))), I && h.push(e(P.normal)), Q && (I = P.vertexNormals, h.push(e(I[0]), e(I[1]), e(I[2]))), W && h.push(i(P.color)), st && (P = P.vertexColors, h.push(i(P[0]), i(P[1]), i(P[2])));
      }
      return o.data = {}, o.data.vertices = s, o.data.normals = c, 0 < f.length && (o.data.colors = f), 0 < v.length && (o.data.uvs = [v]), o.data.faces = h, o;
    },
    clone: function() {
      return new X().copy(this);
    },
    copy: function(t) {
      var e, i, n;
      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var o = t.vertices, s = 0;
      for (e = o.length; s < e; s++)
        this.vertices.push(o[s].clone());
      for (o = t.colors, s = 0, e = o.length; s < e; s++)
        this.colors.push(o[s].clone());
      for (o = t.faces, s = 0, e = o.length; s < e; s++)
        this.faces.push(o[s].clone());
      for (s = 0, e = t.faceVertexUvs.length; s < e; s++) {
        var l = t.faceVertexUvs[s];
        for (this.faceVertexUvs[s] === void 0 && (this.faceVertexUvs[s] = []), o = 0, i = l.length; o < i; o++) {
          var h = l[o], c = [], p = 0;
          for (n = h.length; p < n; p++)
            c.push(h[p].clone());
          this.faceVertexUvs[s].push(c);
        }
      }
      for (p = t.morphTargets, s = 0, e = p.length; s < e; s++) {
        if (n = {}, n.name = p[s].name, p[s].vertices !== void 0)
          for (n.vertices = [], o = 0, i = p[s].vertices.length; o < i; o++)
            n.vertices.push(p[s].vertices[o].clone());
        if (p[s].normals !== void 0)
          for (n.normals = [], o = 0, i = p[s].normals.length; o < i; o++)
            n.normals.push(p[s].normals[o].clone());
        this.morphTargets.push(n);
      }
      for (p = t.morphNormals, s = 0, e = p.length; s < e; s++) {
        if (n = {}, p[s].vertexNormals !== void 0)
          for (n.vertexNormals = [], o = 0, i = p[s].vertexNormals.length; o < i; o++)
            l = p[s].vertexNormals[o], h = {}, h.a = l.a.clone(), h.b = l.b.clone(), h.c = l.c.clone(), n.vertexNormals.push(h);
        if (p[s].faceNormals !== void 0)
          for (n.faceNormals = [], o = 0, i = p[s].faceNormals.length; o < i; o++)
            n.faceNormals.push(p[s].faceNormals[o].clone());
        this.morphNormals.push(n);
      }
      for (o = t.skinWeights, s = 0, e = o.length; s < e; s++)
        this.skinWeights.push(o[s].clone());
      for (o = t.skinIndices, s = 0, e = o.length; s < e; s++)
        this.skinIndices.push(o[s].clone());
      for (o = t.lineDistances, s = 0, e = o.length; s < e; s++)
        this.lineDistances.push(o[s]);
      return s = t.boundingBox, s !== null && (this.boundingBox = s.clone()), s = t.boundingSphere, s !== null && (this.boundingSphere = s.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Object.defineProperty(it.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(it.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.itemSize : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.itemSize, i *= e.itemSize;
      for (var n = 0, o = this.itemSize; n < o; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    copyArray: function(t) {
      return this.array.set(t), this;
    },
    copyColorsArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          n
        ), s = new Y()), e[i++] = s.r, e[i++] = s.g, e[i++] = s.b;
      }
      return this;
    },
    copyVector2sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          n
        ), s = new y()), e[i++] = s.x, e[i++] = s.y;
      }
      return this;
    },
    copyVector3sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          n
        ), s = new S()), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z;
      }
      return this;
    },
    copyVector4sArray: function(t) {
      for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
        var s = t[n];
        s === void 0 && (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          n
        ), s = new nt()), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z, e[i++] = s.w;
      }
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    getX: function(t) {
      return this.array[t * this.itemSize];
    },
    setX: function(t, e) {
      return this.array[t * this.itemSize] = e, this;
    },
    getY: function(t) {
      return this.array[t * this.itemSize + 1];
    },
    setY: function(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    },
    getZ: function(t) {
      return this.array[t * this.itemSize + 2];
    },
    setZ: function(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    },
    getW: function(t) {
      return this.array[t * this.itemSize + 3];
    },
    setW: function(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    },
    setXY: function(t, e, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, o) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = o, this;
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }), _t.prototype = Object.create(it.prototype), _t.prototype.constructor = _t, dt.prototype = Object.create(it.prototype), dt.prototype.constructor = dt, zt.prototype = Object.create(it.prototype), zt.prototype.constructor = zt, Yt.prototype = Object.create(it.prototype), Yt.prototype.constructor = Yt, re.prototype = Object.create(it.prototype), re.prototype.constructor = re, se.prototype = Object.create(it.prototype), se.prototype.constructor = se, we.prototype = Object.create(it.prototype), we.prototype.constructor = we, Et.prototype = Object.create(it.prototype), Et.prototype.constructor = Et, ie.prototype = Object.create(it.prototype), ie.prototype.constructor = ie, Object.assign(ze.prototype, {
    computeGroups: function(t) {
      var e = [], i = void 0;
      t = t.faces;
      for (var n = 0; n < t.length; n++) {
        var o = t[n];
        if (o.materialIndex !== i) {
          i = o.materialIndex, s !== void 0 && (s.count = 3 * n - s.start, e.push(s));
          var s = { start: 3 * n, materialIndex: i };
        }
      }
      s !== void 0 && (s.count = 3 * n - s.start, e.push(s)), this.groups = e;
    },
    fromGeometry: function(t) {
      var e = t.faces, i = t.vertices, n = t.faceVertexUvs, o = n[0] && 0 < n[0].length, s = n[1] && 0 < n[1].length, l = t.morphTargets, h = l.length;
      if (0 < h) {
        for (var c = [], p = 0; p < h; p++)
          c[p] = { name: l[p].name, data: [] };
        this.morphTargets.position = c;
      }
      var f = t.morphNormals, d = f.length;
      if (0 < d) {
        var v = [];
        for (p = 0; p < d; p++)
          v[p] = { name: f[p].name, data: [] };
        this.morphTargets.normal = v;
      }
      var w = t.skinIndices, P = t.skinWeights, R = w.length === i.length, I = P.length === i.length;
      for (0 < i.length && e.length === 0 && console.error(
        "THREE.DirectGeometry: Faceless geometries are not supported."
      ), p = 0; p < e.length; p++) {
        var Q = e[p];
        this.vertices.push(i[Q.a], i[Q.b], i[Q.c]);
        var W = Q.vertexNormals;
        for (W.length === 3 ? this.normals.push(W[0], W[1], W[2]) : (W = Q.normal, this.normals.push(W, W, W)), W = Q.vertexColors, W.length === 3 ? this.colors.push(W[0], W[1], W[2]) : (W = Q.color, this.colors.push(W, W, W)), o === !0 && (W = n[0][p], W !== void 0 ? this.uvs.push(W[0], W[1], W[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
          p
        ), this.uvs.push(new y(), new y(), new y()))), s === !0 && (W = n[1][p], W !== void 0 ? this.uvs2.push(W[0], W[1], W[2]) : (console.warn(
          "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
          p
        ), this.uvs2.push(new y(), new y(), new y()))), W = 0; W < h; W++) {
          var st = l[W].vertices;
          c[W].data.push(st[Q.a], st[Q.b], st[Q.c]);
        }
        for (W = 0; W < d; W++)
          st = f[W].vertexNormals[p], v[W].data.push(st.a, st.b, st.c);
        R && this.skinIndices.push(w[Q.a], w[Q.b], w[Q.c]), I && this.skinWeights.push(P[Q.a], P[Q.b], P[Q.c]);
      }
      return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    }
  });
  var ch = 1;
  Ft.prototype = Object.assign(Object.create($.prototype), {
    constructor: Ft,
    isBufferGeometry: !0,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(t) {
      Array.isArray(t) ? this.index = new (65535 < nn(t) ? we : re)(t, 1) : this.index = t;
    },
    addAttribute: function(t, e, i) {
      return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? t === "index" ? (console.warn(
        "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
      ), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn(
        "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
      ), this.addAttribute(t, new it(e, i)));
    },
    getAttribute: function(t) {
      return this.attributes[t];
    },
    removeAttribute: function(t) {
      return delete this.attributes[t], this;
    },
    addGroup: function(t, e, i) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: i !== void 0 ? i : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    },
    applyMatrix: function(t) {
      var e = this.attributes.position;
      return e !== void 0 && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, e !== void 0 && (new Mt().getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    },
    rotateX: function() {
      var t = new pt();
      return function(e) {
        return t.makeRotationX(e), this.applyMatrix(t), this;
      };
    }(),
    rotateY: function() {
      var t = new pt();
      return function(e) {
        return t.makeRotationY(e), this.applyMatrix(t), this;
      };
    }(),
    rotateZ: function() {
      var t = new pt();
      return function(e) {
        return t.makeRotationZ(e), this.applyMatrix(t), this;
      };
    }(),
    translate: function() {
      var t = new pt();
      return function(e, i, n) {
        return t.makeTranslation(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    scale: function() {
      var t = new pt();
      return function(e, i, n) {
        return t.makeScale(e, i, n), this.applyMatrix(t), this;
      };
    }(),
    lookAt: function() {
      var t = new z();
      return function(e) {
        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
      };
    }(),
    center: function() {
      var t = new S();
      return function() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this;
      };
    }(),
    setFromObject: function(t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        t = new Et(3 * e.vertices.length, 3);
        var i = new Et(3 * e.colors.length, 3);
        this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new Et(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
      } else
        t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function(t) {
      for (var e = [], i = 0, n = t.length; i < n; i++) {
        var o = t[i];
        e.push(o.x, o.y, o.z || 0);
      }
      return this.addAttribute("position", new Et(e, 3)), this;
    },
    updateFromObject: function(t) {
      var e = t.geometry;
      if (t.isMesh) {
        var i = e.__directGeometry;
        if (e.elementsNeedUpdate === !0 && (i = void 0, e.elementsNeedUpdate = !1), i === void 0)
          return this.fromGeometry(e);
        i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i;
      }
      return e.verticesNeedUpdate === !0 && (i = this.attributes.position, i !== void 0 && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), e.normalsNeedUpdate === !0 && (i = this.attributes.normal, i !== void 0 && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), e.colorsNeedUpdate === !0 && (i = this.attributes.color, i !== void 0 && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, i !== void 0 && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, i !== void 0 && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
    },
    fromGeometry: function(t) {
      return t.__directGeometry = new ze().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
    },
    fromDirectGeometry: function(t) {
      var e = new Float32Array(3 * t.vertices.length);
      this.addAttribute("position", new it(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new it(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new it(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new it(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new it(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups;
      for (var i in t.morphTargets) {
        e = [];
        for (var n = t.morphTargets[i], o = 0, s = n.length; o < s; o++) {
          var l = n[o], h = new Et(3 * l.data.length, 3);
          h.name = l.name, e.push(h.copyVector3sArray(l.data));
        }
        this.morphAttributes[i] = e;
      }
      return 0 < t.skinIndices.length && (i = new Et(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new Et(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this;
    },
    computeBoundingBox: function() {
      this.boundingBox === null && (this.boundingBox = new Nt());
      var t = this.attributes.position;
      t !== void 0 ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error(
        'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
    },
    computeBoundingSphere: function() {
      var t = new Nt(), e = new S();
      return function() {
        this.boundingSphere === null && (this.boundingSphere = new Ut());
        var i = this.attributes.position;
        if (i) {
          var n = this.boundingSphere.center;
          t.setFromBufferAttribute(i), t.getCenter(n);
          for (var o = 0, s = 0, l = i.count; s < l; s++)
            e.x = i.getX(s), e.y = i.getY(s), e.z = i.getZ(s), o = Math.max(o, n.distanceToSquared(e));
          this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
        }
      };
    }(),
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
      var t = this.index, e = this.attributes;
      if (e.position) {
        var i = e.position.array;
        if (e.normal === void 0)
          this.addAttribute("normal", new it(new Float32Array(i.length), 3));
        else
          for (var n = e.normal.array, o = 0, s = n.length; o < s; o++)
            n[o] = 0;
        n = e.normal.array;
        var l = new S(), h = new S(), c = new S(), p = new S(), f = new S();
        if (t) {
          var d = t.array;
          for (o = 0, s = t.count; o < s; o += 3) {
            t = 3 * d[o + 0];
            var v = 3 * d[o + 1], w = 3 * d[o + 2];
            l.fromArray(i, t), h.fromArray(i, v), c.fromArray(i, w), p.subVectors(c, h), f.subVectors(l, h), p.cross(f), n[t] += p.x, n[t + 1] += p.y, n[t + 2] += p.z, n[v] += p.x, n[v + 1] += p.y, n[v + 2] += p.z, n[w] += p.x, n[w + 1] += p.y, n[w + 2] += p.z;
          }
        } else
          for (o = 0, s = i.length; o < s; o += 9)
            l.fromArray(i, o), h.fromArray(i, o + 3), c.fromArray(i, o + 6), p.subVectors(c, h), f.subVectors(l, h), p.cross(f), n[o] = p.x, n[o + 1] = p.y, n[o + 2] = p.z, n[o + 3] = p.x, n[o + 4] = p.y, n[o + 5] = p.z, n[o + 6] = p.x, n[o + 7] = p.y, n[o + 8] = p.z;
        this.normalizeNormals(), e.normal.needsUpdate = !0;
      }
    },
    merge: function(t, e) {
      if (t && t.isBufferGeometry) {
        e === void 0 && (e = 0, console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
        var i = this.attributes, n;
        for (n in i)
          if (t.attributes[n] !== void 0) {
            var o = i[n].array, s = t.attributes[n], l = s.array, h = 0;
            for (s = s.itemSize * e; h < l.length; h++, s++)
              o[s] = l[h];
          }
        return this;
      }
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
    },
    normalizeNormals: function() {
      var t = new S();
      return function() {
        for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++)
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z);
      };
    }(),
    toNonIndexed: function() {
      if (this.index === null)
        return console.warn(
          "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
        ), this;
      var t = new Ft(), e = this.index.array, i = this.attributes, n;
      for (n in i) {
        var o = i[n], s = o.array, l = o.itemSize, h = new s.constructor(e.length * l), c = 0;
        o = 0;
        for (var p = e.length; o < p; o++)
          for (var f = e[o] * l, d = 0; d < l; d++)
            h[c++] = s[f++];
        t.addAttribute(n, new it(h, l));
      }
      for (e = this.groups, o = 0, p = e.length; o < p; o++)
        i = e[o], t.addGroup(i.start, i.count, i.materialIndex);
      return t;
    },
    toJSON: function() {
      var t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), this.parameters !== void 0) {
        var e = this.parameters;
        for (o in e)
          e[o] !== void 0 && (t[o] = e[o]);
        return t;
      }
      t.data = { attributes: {} };
      var i = this.index;
      i !== null && (e = Array.prototype.slice.call(i.array), t.data.index = { type: i.array.constructor.name, array: e }), i = this.attributes;
      for (o in i) {
        var n = i[o];
        e = Array.prototype.slice.call(n.array), t.data.attributes[o] = {
          itemSize: n.itemSize,
          type: n.array.constructor.name,
          array: e,
          normalized: n.normalized
        };
      }
      var o = this.groups;
      return 0 < o.length && (t.data.groups = JSON.parse(JSON.stringify(o))), o = this.boundingSphere, o !== null && (t.data.boundingSphere = {
        center: o.center.toArray(),
        radius: o.radius
      }), t;
    },
    clone: function() {
      return new Ft().copy(this);
    },
    copy: function(t) {
      var e;
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
      var i = t.index;
      i !== null && this.setIndex(i.clone()), i = t.attributes;
      for (l in i)
        this.addAttribute(l, i[l].clone());
      var n = t.morphAttributes;
      for (l in n) {
        var o = [], s = n[l];
        for (i = 0, e = s.length; i < e; i++)
          o.push(s[i].clone());
        this.morphAttributes[l] = o;
      }
      var l = t.groups;
      for (i = 0, e = l.length; i < e; i++)
        n = l[i], this.addGroup(n.start, n.count, n.materialIndex);
      return l = t.boundingBox, l !== null && (this.boundingBox = l.clone()), l = t.boundingSphere, l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), $e.prototype = Object.create(X.prototype), $e.prototype.constructor = $e, Oi.prototype = Object.create(Ft.prototype), Oi.prototype.constructor = Oi, En.prototype = Object.create(X.prototype), En.prototype.constructor = En, Yi.prototype = Object.create(Ft.prototype), Yi.prototype.constructor = Yi;
  var Nl = 0;
  Oe.prototype = Object.assign(Object.create($.prototype), {
    constructor: Oe,
    isMaterial: !0,
    onBeforeCompile: function() {
    },
    setValues: function(t) {
      if (t !== void 0)
        for (var e in t) {
          var i = t[e];
          if (i === void 0)
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          else if (e === "shading")
            console.warn(
              "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
            ), this.flatShading = i === 1;
          else {
            var n = this[e];
            n === void 0 ? console.warn(
              "THREE." + this.type + ": '" + e + "' is not a property of this material."
            ) : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
          }
        }
    },
    toJSON: function(t) {
      function e(o) {
        var s = [], l;
        for (l in o) {
          var h = o[l];
          delete h.metadata, s.push(h);
        }
        return s;
      }
      var i = t === void 0 || typeof t == "string";
      i && (t = { textures: {}, images: {} });
      var n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      return n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearCoat !== void 0 && (n.clearCoat = this.clearCoat), this.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, this.combine !== void 0 && (n.combine = this.combine), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.size !== void 0 && (n.size = this.size), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.flatShading === !0 && (n.flatShading = this.flatShading), this.side !== 0 && (n.side = this.side), this.vertexColors !== 0 && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (n.morphTargets = !0), this.skinning === !0 && (n.skinning = !0), this.visible === !1 && (n.visible = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
      var e = t.clippingPlanes, i = null;
      if (e !== null) {
        var n = e.length;
        i = Array(n);
        for (var o = 0; o !== n; ++o)
          i[o] = e[o].clone();
      }
      return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  }), Ai.prototype = Object.create(Oe.prototype), Ai.prototype.constructor = Ai, Ai.prototype.isShaderMaterial = !0, Ai.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = vn.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this;
  }, Ai.prototype.toJSON = function(t) {
    var e = Oe.prototype.toJSON.call(this, t);
    e.uniforms = {};
    for (var i in this.uniforms) {
      var n = this.uniforms[i].value;
      e.uniforms[i] = n.isTexture ? { type: "t", value: n.toJSON(t).uuid } : n.isColor ? { type: "c", value: n.getHex() } : n.isVector2 ? { type: "v2", value: n.toArray() } : n.isVector3 ? { type: "v3", value: n.toArray() } : n.isVector4 ? { type: "v4", value: n.toArray() } : n.isMatrix4 ? { type: "m4", value: n.toArray() } : { value: n };
    }
    return 0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e;
  }, Object.assign(bn.prototype, {
    set: function(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Ray: .at() target is now required"), e = new S()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    },
    recast: function() {
      var t = new S();
      return function(e) {
        return this.origin.copy(this.at(e, t)), this;
      };
    }(),
    closestPointToPoint: function(t, e) {
      return e === void 0 && (console.warn(
        "THREE.Ray: .closestPointToPoint() target is now required"
      ), e = new S()), e.subVectors(t, this.origin), t = e.dot(this.direction), 0 > t ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    distanceToPoint: function(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    },
    distanceSqToPoint: function() {
      var t = new S();
      return function(e) {
        var i = t.subVectors(e, this.origin).dot(this.direction);
        return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e));
      };
    }(),
    distanceSqToSegment: function() {
      var t = new S(), e = new S(), i = new S();
      return function(n, o, s, l) {
        t.copy(n).add(o).multiplyScalar(0.5), e.copy(o).sub(n).normalize(), i.copy(this.origin).sub(t);
        var h = 0.5 * n.distanceTo(o), c = -this.direction.dot(e), p = i.dot(this.direction), f = -i.dot(e), d = i.lengthSq(), v = Math.abs(1 - c * c);
        if (0 < v) {
          n = c * f - p, o = c * p - f;
          var w = h * v;
          0 <= n ? o >= -w ? o <= w ? (h = 1 / v, n *= h, o *= h, c = n * (n + c * o + 2 * p) + o * (c * n + o + 2 * f) + d) : (o = h, n = Math.max(0, -(c * o + p)), c = -n * n + o * (o + 2 * f) + d) : (o = -h, n = Math.max(0, -(c * o + p)), c = -n * n + o * (o + 2 * f) + d) : o <= -w ? (n = Math.max(0, -(-c * h + p)), o = 0 < n ? -h : Math.min(Math.max(-h, -f), h), c = -n * n + o * (o + 2 * f) + d) : o <= w ? (n = 0, o = Math.min(Math.max(-h, -f), h), c = o * (o + 2 * f) + d) : (n = Math.max(0, -(c * h + p)), o = 0 < n ? h : Math.min(Math.max(-h, -f), h), c = -n * n + o * (o + 2 * f) + d);
        } else
          o = 0 < c ? -h : h, n = Math.max(0, -(c * o + p)), c = -n * n + o * (o + 2 * f) + d;
        return s && s.copy(this.direction).multiplyScalar(n).add(this.origin), l && l.copy(e).multiplyScalar(o).add(t), c;
      };
    }(),
    intersectSphere: function() {
      var t = new S();
      return function(e, i) {
        t.subVectors(e.center, this.origin);
        var n = t.dot(this.direction), o = t.dot(t) - n * n;
        return e = e.radius * e.radius, o > e ? null : (e = Math.sqrt(e - o), o = n - e, n += e, 0 > o && 0 > n ? null : 0 > o ? this.at(n, i) : this.at(o, i));
      };
    }(),
    intersectsSphere: function(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    },
    distanceToPlane: function(t) {
      var e = t.normal.dot(this.direction);
      return e === 0 ? t.distanceToPoint(this.origin) === 0 ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, 0 <= t ? t : null);
    },
    intersectPlane: function(t, e) {
      return t = this.distanceToPlane(t), t === null ? null : this.at(t, e);
    },
    intersectsPlane: function(t) {
      var e = t.distanceToPoint(this.origin);
      return e === 0 || 0 > t.normal.dot(this.direction) * e;
    },
    intersectBox: function(t, e) {
      var i = 1 / this.direction.x, n = 1 / this.direction.y, o = 1 / this.direction.z, s = this.origin;
      if (0 <= i) {
        var l = (t.min.x - s.x) * i;
        i *= t.max.x - s.x;
      } else
        l = (t.max.x - s.x) * i, i *= t.min.x - s.x;
      if (0 <= n) {
        var h = (t.min.y - s.y) * n;
        n *= t.max.y - s.y;
      } else
        h = (t.max.y - s.y) * n, n *= t.min.y - s.y;
      return l > n || h > i || ((h > l || l !== l) && (l = h), (n < i || i !== i) && (i = n), 0 <= o ? (h = (t.min.z - s.z) * o, t = (t.max.z - s.z) * o) : (h = (t.max.z - s.z) * o, t = (t.min.z - s.z) * o), l > t || h > i) ? null : ((h > l || l !== l) && (l = h), (t < i || i !== i) && (i = t), 0 > i ? null : this.at(0 <= l ? l : i, e));
    },
    intersectsBox: function() {
      var t = new S();
      return function(e) {
        return this.intersectBox(e, t) !== null;
      };
    }(),
    intersectTriangle: function() {
      var t = new S(), e = new S(), i = new S(), n = new S();
      return function(o, s, l, h, c) {
        if (e.subVectors(s, o), i.subVectors(l, o), n.crossVectors(e, i), s = this.direction.dot(n), 0 < s) {
          if (h)
            return null;
          h = 1;
        } else if (0 > s)
          h = -1, s = -s;
        else
          return null;
        return t.subVectors(this.origin, o), o = h * this.direction.dot(i.crossVectors(t, i)), 0 > o || (l = h * this.direction.dot(e.cross(t)), 0 > l || o + l > s) ? null : (o = -h * t.dot(n), 0 > o ? null : this.at(o / s, c));
      };
    }(),
    applyMatrix4: function(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    },
    equals: function(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
  }), Object.assign(ii, {
    getNormal: function() {
      var t = new S();
      return function(e, i, n, o) {
        return o === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new S()), o.subVectors(n, i), t.subVectors(e, i), o.cross(t), e = o.lengthSq(), 0 < e ? o.multiplyScalar(1 / Math.sqrt(e)) : o.set(0, 0, 0);
      };
    }(),
    getBarycoord: function() {
      var t = new S(), e = new S(), i = new S();
      return function(n, o, s, l, h) {
        t.subVectors(l, o), e.subVectors(s, o), i.subVectors(n, o), n = t.dot(t), o = t.dot(e), s = t.dot(i);
        var c = e.dot(e);
        l = e.dot(i);
        var p = n * c - o * o;
        return h === void 0 && (console.warn(
          "THREE.Triangle: .getBarycoord() target is now required"
        ), h = new S()), p === 0 ? h.set(-2, -1, -1) : (p = 1 / p, c = (c * s - o * l) * p, n = (n * l - o * s) * p, h.set(1 - c - n, n, c));
      };
    }(),
    containsPoint: function() {
      var t = new S();
      return function(e, i, n, o) {
        return ii.getBarycoord(e, i, n, o, t), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y;
      };
    }(),
    getUV: function() {
      var t = new S();
      return function(e, i, n, o, s, l, h, c) {
        return this.getBarycoord(e, i, n, o, t), c.set(0, 0), c.addScaledVector(s, t.x), c.addScaledVector(l, t.y), c.addScaledVector(h, t.z), c;
      };
    }()
  }), Object.assign(ii.prototype, {
    set: function(t, e, i) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
    },
    setFromPointsAndIndices: function(t, e, i, n) {
      return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    },
    getArea: function() {
      var t = new S(), e = new S();
      return function() {
        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), 0.5 * t.cross(e).length();
      };
    }(),
    getMidpoint: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new S()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(t) {
      return ii.getNormal(this.a, this.b, this.c, t);
    },
    getPlane: function(t) {
      return t === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new S()), t.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(t, e) {
      return ii.getBarycoord(t, this.a, this.b, this.c, e);
    },
    containsPoint: function(t) {
      return ii.containsPoint(t, this.a, this.b, this.c);
    },
    getUV: function(t, e, i, n, o) {
      return ii.getUV(t, this.a, this.b, this.c, e, i, n, o);
    },
    intersectsBox: function(t) {
      return t.intersectsTriangle(this);
    },
    closestPointToPoint: function() {
      var t = new S(), e = new S(), i = new S(), n = new S(), o = new S(), s = new S();
      return function(l, h) {
        h === void 0 && (console.warn(
          "THREE.Triangle: .closestPointToPoint() target is now required"
        ), h = new S());
        var c = this.a, p = this.b, f = this.c;
        t.subVectors(p, c), e.subVectors(f, c), n.subVectors(l, c);
        var d = t.dot(n), v = e.dot(n);
        if (0 >= d && 0 >= v)
          return h.copy(c);
        o.subVectors(l, p);
        var w = t.dot(o), P = e.dot(o);
        if (0 <= w && P <= w)
          return h.copy(p);
        var R = d * P - w * v;
        if (0 >= R && 0 <= d && 0 >= w)
          return p = d / (d - w), h.copy(c).addScaledVector(t, p);
        s.subVectors(l, f), l = t.dot(s);
        var I = e.dot(s);
        return 0 <= I && l <= I ? h.copy(f) : (d = l * v - d * I, 0 >= d && 0 <= v && 0 >= I ? (R = v / (v - I), h.copy(c).addScaledVector(e, R)) : (v = w * I - l * P, 0 >= v && 0 <= P - w && 0 <= l - I ? (i.subVectors(f, p), R = (P - w) / (P - w + (l - I)), h.copy(p).addScaledVector(i, R)) : (f = 1 / (v + d + R), p = d * f, R *= f, h.copy(c).addScaledVector(t, p).addScaledVector(e, R))));
      };
    }(),
    equals: function(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }), ui.prototype = Object.create(Oe.prototype), ui.prototype.constructor = ui, ui.prototype.isMeshBasicMaterial = !0, ui.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
  }, Ui.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Ui,
    isMesh: !0,
    setDrawMode: function(t) {
      this.drawMode = t;
    },
    copy: function(t) {
      return z.prototype.copy.call(this, t), this.drawMode = t.drawMode, t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign(
        {},
        t.morphTargetDictionary
      )), this;
    },
    updateMorphTargets: function() {
      var t = this.geometry;
      if (t.isBufferGeometry) {
        t = t.morphAttributes;
        var e = Object.keys(t);
        if (0 < e.length) {
          var i = t[e[0]];
          if (i !== void 0)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
              var n = i[t].name || String(t);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
            }
        }
      } else if (i = t.morphTargets, i !== void 0 && 0 < i.length)
        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++)
          n = i[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
    },
    raycast: function() {
      function t(I, Q, W, st, K, wt, C, D) {
        return (Q.side === 1 ? st.intersectTriangle(C, wt, K, !0, D) : st.intersectTriangle(K, wt, C, Q.side !== 2, D)) === null ? null : (R.copy(D), R.applyMatrix4(I.matrixWorld), Q = W.ray.origin.distanceTo(R), Q < W.near || Q > W.far ? null : { distance: Q, point: R.clone(), object: I });
      }
      function e(I, Q, W, st, K, wt, C, D, ct) {
        return s.fromBufferAttribute(K, C), l.fromBufferAttribute(K, D), h.fromBufferAttribute(K, ct), (I = t(I, Q, W, st, s, l, h, P)) && (wt && (d.fromBufferAttribute(wt, C), v.fromBufferAttribute(wt, D), w.fromBufferAttribute(wt, ct), I.uv = ii.getUV(P, s, l, h, d, v, w, new y())), wt = new B(C, D, ct), ii.getNormal(s, l, h, wt.normal), I.face = wt), I;
      }
      var i = new pt(), n = new bn(), o = new Ut(), s = new S(), l = new S(), h = new S(), c = new S(), p = new S(), f = new S(), d = new y(), v = new y(), w = new y(), P = new S(), R = new S();
      return function(I, Q) {
        var W = this.geometry, st = this.material, K = this.matrixWorld;
        if (st !== void 0 && (W.boundingSphere === null && W.computeBoundingSphere(), o.copy(W.boundingSphere), o.applyMatrix4(K), I.ray.intersectsSphere(o) !== !1 && (i.getInverse(K), n.copy(I.ray).applyMatrix4(i), W.boundingBox === null || n.intersectsBox(W.boundingBox) !== !1))) {
          if (W.isBufferGeometry) {
            var wt = W.index, C = W.attributes.position, D = W.attributes.uv, ct = W.groups;
            W = W.drawRange;
            var Dt;
            if (wt !== null)
              if (Array.isArray(st)) {
                var bt = 0;
                for (Dt = ct.length; bt < Dt; bt++) {
                  var St = ct[bt], oe = st[St.materialIndex];
                  K = Math.max(St.start, W.start);
                  var $t = Math.min(St.start + St.count, W.start + W.count);
                  for (St = K; St < $t; St += 3) {
                    K = wt.getX(St);
                    var me = wt.getX(St + 1), ue = wt.getX(St + 2);
                    (K = e(this, oe, I, n, C, D, K, me, ue)) && (K.faceIndex = Math.floor(St / 3), Q.push(K));
                  }
                }
              } else
                for (K = Math.max(0, W.start), $t = Math.min(wt.count, W.start + W.count), bt = K, Dt = $t; bt < Dt; bt += 3)
                  K = wt.getX(bt), me = wt.getX(bt + 1), ue = wt.getX(bt + 2), (K = e(this, st, I, n, C, D, K, me, ue)) && (K.faceIndex = Math.floor(bt / 3), Q.push(K));
            else if (C !== void 0)
              if (Array.isArray(st))
                for (bt = 0, Dt = ct.length; bt < Dt; bt++)
                  for (St = ct[bt], oe = st[St.materialIndex], K = Math.max(St.start, W.start), $t = Math.min(St.start + St.count, W.start + W.count), St = K; St < $t; St += 3)
                    K = St, me = St + 1, ue = St + 2, (K = e(this, oe, I, n, C, D, K, me, ue)) && (K.faceIndex = Math.floor(St / 3), Q.push(K));
              else
                for (K = Math.max(0, W.start), $t = Math.min(C.count, W.start + W.count), bt = K, Dt = $t; bt < Dt; bt += 3)
                  K = bt, me = bt + 1, ue = bt + 2, (K = e(this, st, I, n, C, D, K, me, ue)) && (K.faceIndex = Math.floor(bt / 3), Q.push(K));
          } else if (W.isGeometry) {
            for (C = Array.isArray(st), D = W.vertices, ct = W.faces, K = W.faceVertexUvs[0], 0 < K.length && (wt = K), St = 0, $t = ct.length; St < $t; St++)
              if (me = ct[St], K = C ? st[me.materialIndex] : st, K !== void 0) {
                if (bt = D[me.a], Dt = D[me.b], oe = D[me.c], K.morphTargets === !0) {
                  ue = W.morphTargets;
                  var Wt = this.morphTargetInfluences;
                  s.set(0, 0, 0), l.set(0, 0, 0), h.set(0, 0, 0);
                  for (var Ee = 0, Be = ue.length; Ee < Be; Ee++) {
                    var Ye = Wt[Ee];
                    if (Ye !== 0) {
                      var hn = ue[Ee].vertices;
                      s.addScaledVector(c.subVectors(hn[me.a], bt), Ye), l.addScaledVector(p.subVectors(hn[me.b], Dt), Ye), h.addScaledVector(f.subVectors(hn[me.c], oe), Ye);
                    }
                  }
                  s.add(bt), l.add(Dt), h.add(oe), bt = s, Dt = l, oe = h;
                }
                (K = t(this, K, I, n, bt, Dt, oe, P)) && (wt && wt[St] && (ue = wt[St], d.copy(ue[0]), v.copy(ue[1]), w.copy(ue[2]), K.uv = ii.getUV(P, bt, Dt, oe, d, v, w, new y())), K.face = me, K.faceIndex = St, Q.push(K));
              }
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), A.prototype = Object.create(kt.prototype), A.prototype.constructor = A, A.prototype.isCubeTexture = !0, Object.defineProperty(A.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(t) {
      this.image = t;
    }
  }), k.prototype = Object.create(kt.prototype), k.prototype.constructor = k, k.prototype.isDataTexture3D = !0;
  var cl = new kt(), ph = new k(), Bl = new A(), Fa = [], Is = [], fa = new Float32Array(16), Ul = new Float32Array(9), pl = new Float32Array(4);
  ls.prototype.updateCache = function(t) {
    var e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), ht(e, t);
  }, Hs.prototype.setValue = function(t, e, i) {
    for (var n = this.seq, o = 0, s = n.length; o !== s; ++o) {
      var l = n[o];
      l.setValue(t, e[l.id], i);
    }
  };
  var fl = /([\w\d_]+)(\])?(\[|\.)?/g;
  Rr.prototype.setValue = function(t, e, i) {
    e = this.map[e], e !== void 0 && e.setValue(t, i, this.renderer);
  }, Rr.prototype.setOptional = function(t, e, i) {
    e = e[i], e !== void 0 && this.setValue(t, i, e);
  }, Rr.upload = function(t, e, i, n) {
    for (var o = 0, s = e.length; o !== s; ++o) {
      var l = e[o], h = i[l.id];
      h.needsUpdate !== !1 && l.setValue(t, h.value, n);
    }
  }, Rr.seqWithValue = function(t, e) {
    for (var i = [], n = 0, o = t.length; n !== o; ++n) {
      var s = t[n];
      s.id in e && i.push(s);
    }
    return i;
  };
  var no = 0, dl = 0;
  Vt.prototype = Object.create(Oe.prototype), Vt.prototype.constructor = Vt, Vt.prototype.isMeshDepthMaterial = !0, Vt.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }, It.prototype = Object.create(Oe.prototype), It.prototype.constructor = It, It.prototype.isMeshDistanceMaterial = !0, It.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }, qe.prototype = Object.assign(Object.create(z.prototype), {
    constructor: qe,
    isGroup: !0
  }), ye.prototype = Object.assign(Object.create(z.prototype), {
    constructor: ye,
    isCamera: !0,
    copy: function(t, e) {
      return z.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    },
    getWorldDirection: function(t) {
      t === void 0 && (console.warn(
        "THREE.Camera: .getWorldDirection() target is now required"
      ), t = new S()), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(t) {
      z.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), ee.prototype = Object.assign(Object.create(ye.prototype), {
    constructor: ee,
    isPerspectiveCamera: !0,
    copy: function(t, e) {
      return ye.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    },
    setFocalLength: function(t) {
      t = 0.5 * this.getFilmHeight() / t, this.fov = 2 * Je.RAD2DEG * Math.atan(t), this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      var t = Math.tan(0.5 * Je.DEG2RAD * this.fov);
      return 0.5 * this.getFilmHeight() / t;
    },
    getEffectiveFOV: function() {
      return 2 * Je.RAD2DEG * Math.atan(Math.tan(0.5 * Je.DEG2RAD * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(t, e, i, n, o, s) {
      this.aspect = t / e, this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = o, this.view.height = s, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = this.near, e = t * Math.tan(0.5 * Je.DEG2RAD * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, o = -0.5 * n, s = this.view;
      if (this.view !== null && this.view.enabled) {
        var l = s.fullWidth, h = s.fullHeight;
        o += s.offsetX * n / l, e -= s.offsetY * i / h, n *= s.width / l, i *= s.height / h;
      }
      s = this.filmOffset, s !== 0 && (o += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = z.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }), _e.prototype = Object.assign(Object.create(ee.prototype), {
    constructor: _e,
    isArrayCamera: !0
  });
  var To = new S(), tr = new S();
  de.prototype.isFogExp2 = !0, de.prototype.clone = function() {
    return new de(this.color, this.density);
  }, de.prototype.toJSON = function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }, sn.prototype.isFog = !0, sn.prototype.clone = function() {
    return new sn(this.color, this.near, this.far);
  }, sn.prototype.toJSON = function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }, An.prototype = Object.assign(Object.create(z.prototype), {
    constructor: An,
    copy: function(t, e) {
      return z.prototype.copy.call(this, t, e), t.background !== null && (this.background = t.background.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    },
    toJSON: function(t) {
      var e = z.prototype.toJSON.call(this, t);
      return this.background !== null && (e.object.background = this.background.toJSON(t)), this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
    }
  }), Object.defineProperty(gi.prototype, "needsUpdate", {
    set: function(t) {
      t === !0 && this.version++;
    }
  }), Object.assign(gi.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function() {
    },
    setArray: function(t) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      return this.count = t !== void 0 ? t.length / this.stride : 0, this.array = t, this;
    },
    setDynamic: function(t) {
      return this.dynamic = t, this;
    },
    copy: function(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this;
    },
    copyAt: function(t, e, i) {
      t *= this.stride, i *= e.stride;
      for (var n = 0, o = this.stride; n < o; n++)
        this.array[t + n] = e.array[i + n];
      return this;
    },
    set: function(t, e) {
      return e === void 0 && (e = 0), this.array.set(t, e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    onUpload: function(t) {
      return this.onUploadCallback = t, this;
    }
  }), Object.defineProperties(vi.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    }
  }), Object.assign(vi.prototype, {
    isInterleavedBufferAttribute: !0,
    setX: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    },
    setY: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    },
    setZ: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    },
    setW: function(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    },
    getX: function(t) {
      return this.data.array[t * this.data.stride + this.offset];
    },
    getY: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    },
    getZ: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    },
    getW: function(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    },
    setXY: function(t, e, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
    },
    setXYZ: function(t, e, i, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
    },
    setXYZW: function(t, e, i, n, o) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = o, this;
    }
  }), Ti.prototype = Object.create(Oe.prototype), Ti.prototype.constructor = Ti, Ti.prototype.isSpriteMaterial = !0, Ti.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
  };
  var Ds;
  Gi.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Gi,
    isSprite: !0,
    raycast: function() {
      function t(w, P, R, I, Q, W) {
        o.subVectors(w, R).addScalar(0.5).multiply(I), Q !== void 0 ? (s.x = W * o.x - Q * o.y, s.y = Q * o.x + W * o.y) : s.copy(o), w.copy(P), w.x += s.x, w.y += s.y, w.applyMatrix4(l);
      }
      var e = new S(), i = new S(), n = new S(), o = new y(), s = new y(), l = new pt(), h = new S(), c = new S(), p = new S(), f = new y(), d = new y(), v = new y();
      return function(w, P) {
        i.setFromMatrixScale(this.matrixWorld), l.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
        var R = this.material.rotation;
        if (R !== 0)
          var I = Math.cos(R), Q = Math.sin(R);
        R = this.center, t(h.set(-0.5, -0.5, 0), n, R, i, Q, I), t(c.set(0.5, -0.5, 0), n, R, i, Q, I), t(p.set(0.5, 0.5, 0), n, R, i, Q, I), f.set(0, 0), d.set(1, 0), v.set(1, 1);
        var W = w.ray.intersectTriangle(h, c, p, !1, e);
        W === null && (t(c.set(-0.5, 0.5, 0), n, R, i, Q, I), d.set(0, 1), W = w.ray.intersectTriangle(h, p, c, !1, e), W === null) || (Q = w.ray.origin.distanceTo(e), Q < w.near || Q > w.far || P.push({
          distance: Q,
          point: e.clone(),
          uv: ii.getUV(e, h, c, p, f, d, v, new y()),
          face: null,
          object: this
        }));
      };
    }(),
    clone: function() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function(t) {
      return z.prototype.copy.call(this, t), t.center !== void 0 && this.center.copy(t.center), this;
    }
  }), Hi.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Hi,
    copy: function(t) {
      z.prototype.copy.call(this, t, !1), t = t.levels;
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.addLevel(n.object.clone(), n.distance);
      }
      return this;
    },
    addLevel: function(t, e) {
      e === void 0 && (e = 0), e = Math.abs(e);
      for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++)
        ;
      i.splice(n, 0, { distance: e, object: t }), this.add(t);
    },
    getObjectForDistance: function(t) {
      for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
        ;
      return e[i - 1].object;
    },
    raycast: function() {
      var t = new S();
      return function(e, i) {
        t.setFromMatrixPosition(this.matrixWorld);
        var n = e.ray.origin.distanceTo(t);
        this.getObjectForDistance(n).raycast(e, i);
      };
    }(),
    update: function() {
      var t = new S(), e = new S();
      return function(i) {
        var n = this.levels;
        if (1 < n.length) {
          t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0;
          for (var o = 1, s = n.length; o < s && i >= n[o].distance; o++)
            n[o - 1].object.visible = !1, n[o].object.visible = !0;
          for (; o < s; o++)
            n[o].object.visible = !1;
        }
      };
    }(),
    toJSON: function(t) {
      t = z.prototype.toJSON.call(this, t), t.object.levels = [];
      for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
        var o = e[i];
        t.object.levels.push({ object: o.object.uuid, distance: o.distance });
      }
      return t;
    }
  }), Object.assign(Wi.prototype, {
    calculateInverses: function() {
      this.boneInverses = [];
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var i = new pt();
        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i);
      }
    },
    pose: function() {
      var t, e, i = 0;
      for (e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
      for (i = 0, e = this.bones.length; i < e; i++)
        (t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
    },
    update: function() {
      var t = new pt(), e = new pt();
      return function() {
        for (var i = this.bones, n = this.boneInverses, o = this.boneMatrices, s = this.boneTexture, l = 0, h = i.length; l < h; l++)
          t.multiplyMatrices(i[l] ? i[l].matrixWorld : e, n[l]), t.toArray(o, 16 * l);
        s !== void 0 && (s.needsUpdate = !0);
      };
    }(),
    clone: function() {
      return new Wi(this.bones, this.boneInverses);
    },
    getBoneByName: function(t) {
      for (var e = 0, i = this.bones.length; e < i; e++) {
        var n = this.bones[e];
        if (n.name === t)
          return n;
      }
    }
  }), ji.prototype = Object.assign(Object.create(z.prototype), {
    constructor: ji,
    isBone: !0
  }), Mi.prototype = Object.assign(Object.create(Ui.prototype), {
    constructor: Mi,
    isSkinnedMesh: !0,
    initBones: function() {
      var t = [], e;
      if (this.geometry && this.geometry.bones !== void 0) {
        var i = 0;
        for (e = this.geometry.bones.length; i < e; i++) {
          var n = this.geometry.bones[i], o = new ji();
          t.push(o), o.name = n.name, o.position.fromArray(n.pos), o.quaternion.fromArray(n.rotq), n.scl !== void 0 && o.scale.fromArray(n.scl);
        }
        for (i = 0, e = this.geometry.bones.length; i < e; i++)
          n = this.geometry.bones[i], n.parent !== -1 && n.parent !== null && t[n.parent] !== void 0 ? t[n.parent].add(t[i]) : this.add(t[i]);
      }
      return this.updateMatrixWorld(!0), t;
    },
    bind: function(t, e) {
      this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      var t;
      if (this.geometry && this.geometry.isGeometry)
        for (t = 0; t < this.geometry.skinWeights.length; t++) {
          var e = this.geometry.skinWeights[t], i = 1 / e.manhattanLength();
          i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0);
        }
      else if (this.geometry && this.geometry.isBufferGeometry) {
        e = new nt();
        var n = this.geometry.attributes.skinWeight;
        for (t = 0; t < n.count; t++)
          e.x = n.getX(t), e.y = n.getY(t), e.z = n.getZ(t), e.w = n.getW(t), i = 1 / e.manhattanLength(), i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), n.setXYZW(t, e.x, e.y, e.z, e.w);
      }
    },
    updateMatrixWorld: function(t) {
      Ui.prototype.updateMatrixWorld.call(this, t), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn(
        "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
      );
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), yi.prototype = Object.create(Oe.prototype), yi.prototype.constructor = yi, yi.prototype.isLineBasicMaterial = !0, yi.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
  }, Pi.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Pi,
    isLine: !0,
    computeLineDistances: function() {
      var t = new S(), e = new S();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, o = [0], s = 1, l = n.count; s < l; s++)
              t.fromBufferAttribute(n, s - 1), e.fromBufferAttribute(n, s), o[s] = o[s - 1], o[s] += t.distanceTo(e);
            i.addAttribute("lineDistance", new Et(o, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, o = i.lineDistances, o[0] = 0, s = 1, l = n.length; s < l; s++)
            o[s] = o[s - 1], o[s] += n[s - 1].distanceTo(n[s]);
        return this;
      };
    }(),
    raycast: function() {
      var t = new pt(), e = new bn(), i = new Ut();
      return function(n, o) {
        var s = n.linePrecision, l = this.geometry, h = this.matrixWorld;
        if (l.boundingSphere === null && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(h), i.radius += s, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(h), e.copy(n.ray).applyMatrix4(t), s /= (this.scale.x + this.scale.y + this.scale.z) / 3, s *= s;
          var c = new S(), p = new S();
          h = new S();
          var f = new S(), d = this && this.isLineSegments ? 2 : 1;
          if (l.isBufferGeometry) {
            var v = l.index, w = l.attributes.position.array;
            if (v !== null) {
              v = v.array, l = 0;
              for (var P = v.length - 1; l < P; l += d) {
                var R = v[l + 1];
                c.fromArray(w, 3 * v[l]), p.fromArray(w, 3 * R), R = e.distanceSqToSegment(c, p, f, h), R > s || (f.applyMatrix4(this.matrixWorld), R = n.ray.origin.distanceTo(f), R < n.near || R > n.far || o.push({
                  distance: R,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: l,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
              }
            } else
              for (l = 0, P = w.length / 3 - 1; l < P; l += d)
                c.fromArray(w, 3 * l), p.fromArray(w, 3 * l + 3), R = e.distanceSqToSegment(c, p, f, h), R > s || (f.applyMatrix4(this.matrixWorld), R = n.ray.origin.distanceTo(f), R < n.near || R > n.far || o.push({
                  distance: R,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: l,
                  face: null,
                  faceIndex: null,
                  object: this
                }));
          } else if (l.isGeometry)
            for (c = l.vertices, p = c.length, l = 0; l < p - 1; l += d)
              R = e.distanceSqToSegment(c[l], c[l + 1], f, h), R > s || (f.applyMatrix4(this.matrixWorld), R = n.ray.origin.distanceTo(f), R < n.near || R > n.far || o.push({
                distance: R,
                point: h.clone().applyMatrix4(this.matrixWorld),
                index: l,
                face: null,
                faceIndex: null,
                object: this
              }));
        }
      };
    }(),
    copy: function(t) {
      return z.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), ti.prototype = Object.assign(Object.create(Pi.prototype), {
    constructor: ti,
    isLineSegments: !0,
    computeLineDistances: function() {
      var t = new S(), e = new S();
      return function() {
        var i = this.geometry;
        if (i.isBufferGeometry)
          if (i.index === null) {
            for (var n = i.attributes.position, o = [], s = 0, l = n.count; s < l; s += 2)
              t.fromBufferAttribute(n, s), e.fromBufferAttribute(n, s + 1), o[s] = s === 0 ? 0 : o[s - 1], o[s + 1] = o[s] + t.distanceTo(e);
            i.addAttribute("lineDistance", new Et(o, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (i.isGeometry)
          for (n = i.vertices, o = i.lineDistances, s = 0, l = n.length; s < l; s += 2)
            t.copy(n[s]), e.copy(n[s + 1]), o[s] = s === 0 ? 0 : o[s - 1], o[s + 1] = o[s] + t.distanceTo(e);
        return this;
      };
    }()
  }), Or.prototype = Object.assign(Object.create(Pi.prototype), {
    constructor: Or,
    isLineLoop: !0
  }), xn.prototype = Object.create(Oe.prototype), xn.prototype.constructor = xn, xn.prototype.isPointsMaterial = !0, xn.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
  }, cs.prototype = Object.assign(Object.create(z.prototype), {
    constructor: cs,
    isPoints: !0,
    raycast: function() {
      var t = new pt(), e = new bn(), i = new Ut();
      return function(n, o) {
        function s(I, Q) {
          var W = e.distanceSqToPoint(I);
          W < f && (e.closestPointToPoint(I, d), d.applyMatrix4(c), I = n.ray.origin.distanceTo(d), I < n.near || I > n.far || o.push({
            distance: I,
            distanceToRay: Math.sqrt(W),
            point: d.clone(),
            index: Q,
            face: null,
            object: l
          }));
        }
        var l = this, h = this.geometry, c = this.matrixWorld, p = n.params.Points.threshold;
        if (h.boundingSphere === null && h.computeBoundingSphere(), i.copy(h.boundingSphere), i.applyMatrix4(c), i.radius += p, n.ray.intersectsSphere(i) !== !1) {
          t.getInverse(c), e.copy(n.ray).applyMatrix4(t), p /= (this.scale.x + this.scale.y + this.scale.z) / 3;
          var f = p * p;
          p = new S();
          var d = new S();
          if (h.isBufferGeometry) {
            var v = h.index;
            if (h = h.attributes.position.array, v !== null) {
              var w = v.array;
              v = 0;
              for (var P = w.length; v < P; v++) {
                var R = w[v];
                p.fromArray(h, 3 * R), s(p, R);
              }
            } else
              for (v = 0, w = h.length / 3; v < w; v++)
                p.fromArray(h, 3 * v), s(p, v);
          } else
            for (p = h.vertices, v = 0, w = p.length; v < w; v++)
              s(p[v], v);
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  }), Ka.prototype = Object.assign(Object.create(kt.prototype), {
    constructor: Ka,
    isVideoTexture: !0,
    update: function() {
      var t = this.image;
      t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  }), ho.prototype = Object.create(kt.prototype), ho.prototype.constructor = ho, ho.prototype.isCompressedTexture = !0, Vs.prototype = Object.create(kt.prototype), Vs.prototype.constructor = Vs, Vs.prototype.isCanvasTexture = !0, Ws.prototype = Object.create(kt.prototype), Ws.prototype.constructor = Ws, Ws.prototype.isDepthTexture = !0, ps.prototype = Object.create(Ft.prototype), ps.prototype.constructor = ps, js.prototype = Object.create(X.prototype), js.prototype.constructor = js, fs.prototype = Object.create(Ft.prototype), fs.prototype.constructor = fs, Li.prototype = Object.create(X.prototype), Li.prototype.constructor = Li, ri.prototype = Object.create(Ft.prototype), ri.prototype.constructor = ri, Xs.prototype = Object.create(X.prototype), Xs.prototype.constructor = Xs, ds.prototype = Object.create(ri.prototype), ds.prototype.constructor = ds, qs.prototype = Object.create(X.prototype), qs.prototype.constructor = qs, Ro.prototype = Object.create(ri.prototype), Ro.prototype.constructor = Ro, Ys.prototype = Object.create(X.prototype), Ys.prototype.constructor = Ys, ms.prototype = Object.create(ri.prototype), ms.prototype.constructor = ms, gs.prototype = Object.create(X.prototype), gs.prototype.constructor = gs, vs.prototype = Object.create(ri.prototype), vs.prototype.constructor = vs, Ji.prototype = Object.create(X.prototype), Ji.prototype.constructor = Ji, uo.prototype = Object.create(Ft.prototype), uo.prototype.constructor = uo, _r.prototype = Object.create(X.prototype), _r.prototype.constructor = _r, bo.prototype = Object.create(Ft.prototype), bo.prototype.constructor = bo, Oo.prototype = Object.create(X.prototype), Oo.prototype.constructor = Oo, wn.prototype = Object.create(Ft.prototype), wn.prototype.constructor = wn;
  var Fl = {
    triangulate: function(t, e, i) {
      i = i || 2;
      var n = e && e.length, o = n ? e[0] * i : t.length, s = tl(t, 0, o, i, !0), l = [];
      if (!s)
        return l;
      var h;
      if (n) {
        var c = i;
        n = [];
        var p, f = 0;
        for (p = e.length; f < p; f++) {
          var d = e[f] * c, v = f < p - 1 ? e[f + 1] * c : t.length;
          d = tl(t, d, v, c, !1), d === d.next && (d.steiner = !0), n.push($n(d));
        }
        for (n.sort(El), f = 0; f < n.length; f++)
          e = n[f], c = s, (c = Al(e, c)) && (e = Zs(c, e), ys(e, e.next)), s = ys(s, s.next);
      }
      if (t.length > 80 * i) {
        var w = h = t[0], P = n = t[1];
        for (c = i; c < o; c += i)
          f = t[c], e = t[c + 1], f < w && (w = f), e < P && (P = e), f > h && (h = f), e > n && (n = e);
        h = Math.max(h - w, n - P), h = h !== 0 ? 1 / h : 0;
      }
      return _s(s, l, i, w, P, h), l;
    }
  }, kr = {
    area: function(t) {
      for (var e = t.length, i = 0, n = e - 1, o = 0; o < e; n = o++)
        i += t[n].x * t[o].y - t[o].x * t[n].y;
      return 0.5 * i;
    },
    isClockWise: function(t) {
      return 0 > kr.area(t);
    },
    triangulateShape: function(t, e) {
      var i = [], n = [], o = [];
      Ca(t), Pl(i, t);
      var s = t.length;
      for (e.forEach(Ca), t = 0; t < e.length; t++)
        n.push(s), s += e[t].length, Pl(i, e[t]);
      for (e = Fl.triangulate(i, n), t = 0; t < e.length; t += 3)
        o.push(e.slice(t, t + 3));
      return o;
    }
  };
  Zr.prototype = Object.create(X.prototype), Zr.prototype.constructor = Zr, Zr.prototype.toJSON = function() {
    var t = X.prototype.toJSON.call(this);
    return Ll(this.parameters.shapes, this.parameters.options, t);
  }, Dr.prototype = Object.create(Ft.prototype), Dr.prototype.constructor = Dr, Dr.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return Ll(this.parameters.shapes, this.parameters.options, t);
  };
  var da = {
    generateTopUV: function(t, e, i, n, o) {
      t = e[3 * n], n = e[3 * n + 1];
      var s = e[3 * o];
      return o = e[3 * o + 1], [new y(e[3 * i], e[3 * i + 1]), new y(t, n), new y(s, o)];
    },
    generateSideWallUV: function(t, e, i, n, o, s) {
      t = e[3 * i];
      var l = e[3 * i + 1];
      i = e[3 * i + 2];
      var h = e[3 * n], c = e[3 * n + 1];
      n = e[3 * n + 2];
      var p = e[3 * o], f = e[3 * o + 1];
      o = e[3 * o + 2];
      var d = e[3 * s], v = e[3 * s + 1];
      return e = e[3 * s + 2], 0.01 > Math.abs(l - c) ? [new y(t, 1 - i), new y(h, 1 - n), new y(p, 1 - o), new y(d, 1 - e)] : [new y(l, 1 - i), new y(c, 1 - n), new y(f, 1 - o), new y(v, 1 - e)];
    }
  };
  Js.prototype = Object.create(X.prototype), Js.prototype.constructor = Js, Do.prototype = Object.create(Dr.prototype), Do.prototype.constructor = Do, co.prototype = Object.create(X.prototype), co.prototype.constructor = co, ar.prototype = Object.create(Ft.prototype), ar.prototype.constructor = ar, $s.prototype = Object.create(X.prototype), $s.prototype.constructor = $s, zo.prototype = Object.create(Ft.prototype), zo.prototype.constructor = zo, xs.prototype = Object.create(X.prototype), xs.prototype.constructor = xs, po.prototype = Object.create(Ft.prototype), po.prototype.constructor = po, Jr.prototype = Object.create(X.prototype), Jr.prototype.constructor = Jr, Jr.prototype.toJSON = function() {
    var t = X.prototype.toJSON.call(this);
    return Cl(this.parameters.shapes, t);
  }, fo.prototype = Object.create(Ft.prototype), fo.prototype.constructor = fo, fo.prototype.toJSON = function() {
    var t = Ft.prototype.toJSON.call(this);
    return Cl(this.parameters.shapes, t);
  }, mo.prototype = Object.create(Ft.prototype), mo.prototype.constructor = mo, $r.prototype = Object.create(X.prototype), $r.prototype.constructor = $r, Qr.prototype = Object.create(Ft.prototype), Qr.prototype.constructor = Qr, ws.prototype = Object.create($r.prototype), ws.prototype.constructor = ws, Mn.prototype = Object.create(Qr.prototype), Mn.prototype.constructor = Mn, No.prototype = Object.create(X.prototype), No.prototype.constructor = No, zr.prototype = Object.create(Ft.prototype), zr.prototype.constructor = zr;
  var Qi = Object.freeze({
    WireframeGeometry: ps,
    ParametricGeometry: js,
    ParametricBufferGeometry: fs,
    TetrahedronGeometry: Xs,
    TetrahedronBufferGeometry: ds,
    OctahedronGeometry: qs,
    OctahedronBufferGeometry: Ro,
    IcosahedronGeometry: Ys,
    IcosahedronBufferGeometry: ms,
    DodecahedronGeometry: gs,
    DodecahedronBufferGeometry: vs,
    PolyhedronGeometry: Li,
    PolyhedronBufferGeometry: ri,
    TubeGeometry: Ji,
    TubeBufferGeometry: uo,
    TorusKnotGeometry: _r,
    TorusKnotBufferGeometry: bo,
    TorusGeometry: Oo,
    TorusBufferGeometry: wn,
    TextGeometry: Js,
    TextBufferGeometry: Do,
    SphereGeometry: co,
    SphereBufferGeometry: ar,
    RingGeometry: $s,
    RingBufferGeometry: zo,
    PlaneGeometry: En,
    PlaneBufferGeometry: Yi,
    LatheGeometry: xs,
    LatheBufferGeometry: po,
    ShapeGeometry: Jr,
    ShapeBufferGeometry: fo,
    ExtrudeGeometry: Zr,
    ExtrudeBufferGeometry: Dr,
    EdgesGeometry: mo,
    ConeGeometry: ws,
    ConeBufferGeometry: Mn,
    CylinderGeometry: $r,
    CylinderBufferGeometry: Qr,
    CircleGeometry: No,
    CircleBufferGeometry: zr,
    BoxGeometry: $e,
    BoxBufferGeometry: Oi
  });
  go.prototype = Object.create(Oe.prototype), go.prototype.constructor = go, go.prototype.isShadowMaterial = !0, go.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this;
  }, Bo.prototype = Object.create(Ai.prototype), Bo.prototype.constructor = Bo, Bo.prototype.isRawShaderMaterial = !0, Nr.prototype = Object.create(Oe.prototype), Nr.prototype.constructor = Nr, Nr.prototype.isMeshStandardMaterial = !0, Nr.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Uo.prototype = Object.create(Nr.prototype), Uo.prototype.constructor = Uo, Uo.prototype.isMeshPhysicalMaterial = !0, Uo.prototype.copy = function(t) {
    return Nr.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this;
  }, xr.prototype = Object.create(Oe.prototype), xr.prototype.constructor = xr, xr.prototype.isMeshPhongMaterial = !0, xr.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Fo.prototype = Object.create(xr.prototype), Fo.prototype.constructor = Fo, Fo.prototype.isMeshToonMaterial = !0, Fo.prototype.copy = function(t) {
    return xr.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this;
  }, Go.prototype = Object.create(Oe.prototype), Go.prototype.constructor = Go, Go.prototype.isMeshNormalMaterial = !0, Go.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, lr.prototype = Object.create(Oe.prototype), lr.prototype.constructor = lr, lr.prototype.isMeshLambertMaterial = !0, lr.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Ho.prototype = Object.create(Oe.prototype), Ho.prototype.constructor = Ho, Ho.prototype.isMeshMatcapMaterial = !0, Ho.prototype.copy = function(t) {
    return Oe.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, ko.prototype = Object.create(yi.prototype), ko.prototype.constructor = ko, ko.prototype.isLineDashedMaterial = !0, ko.prototype.copy = function(t) {
    return yi.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
  };
  var Gl = Object.freeze({
    ShadowMaterial: go,
    SpriteMaterial: Ti,
    RawShaderMaterial: Bo,
    ShaderMaterial: Ai,
    PointsMaterial: xn,
    MeshPhysicalMaterial: Uo,
    MeshStandardMaterial: Nr,
    MeshPhongMaterial: xr,
    MeshToonMaterial: Fo,
    MeshNormalMaterial: Go,
    MeshLambertMaterial: lr,
    MeshDepthMaterial: Vt,
    MeshDistanceMaterial: It,
    MeshBasicMaterial: ui,
    MeshMatcapMaterial: Ho,
    LineDashedMaterial: ko,
    LineBasicMaterial: yi,
    Material: Oe
  }), Ln = {
    arraySlice: function(t, e, i) {
      return Ln.isTypedArray(t) ? new t.constructor(t.subarray(e, i !== void 0 ? i : t.length)) : t.slice(e, i);
    },
    convertArray: function(t, e, i) {
      return !t || !i && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t);
    },
    isTypedArray: function(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function(t) {
      for (var e = t.length, i = Array(e), n = 0; n !== e; ++n)
        i[n] = n;
      return i.sort(function(o, s) {
        return t[o] - t[s];
      }), i;
    },
    sortedArray: function(t, e, i) {
      for (var n = t.length, o = new t.constructor(n), s = 0, l = 0; l !== n; ++s)
        for (var h = i[s] * e, c = 0; c !== e; ++c)
          o[l++] = t[h + c];
      return o;
    },
    flattenJSON: function(t, e, i, n) {
      for (var o = 1, s = t[0]; s !== void 0 && s[n] === void 0; )
        s = t[o++];
      if (s !== void 0) {
        var l = s[n];
        if (l !== void 0)
          if (Array.isArray(l))
            do
              l = s[n], l !== void 0 && (e.push(s.time), i.push.apply(i, l)), s = t[o++];
            while (s !== void 0);
          else if (l.toArray !== void 0)
            do
              l = s[n], l !== void 0 && (e.push(s.time), l.toArray(i, i.length)), s = t[o++];
            while (s !== void 0);
          else
            do
              l = s[n], l !== void 0 && (e.push(s.time), i.push(l)), s = t[o++];
            while (s !== void 0);
      }
    }
  };
  Object.assign(On.prototype, {
    evaluate: function(t) {
      var e = this.parameterPositions, i = this._cachedIndex, n = e[i], o = e[i - 1];
      t: {
        e: {
          i: {
            n:
              if (!(t < n)) {
                for (var s = i + 2; ; ) {
                  if (n === void 0) {
                    if (t < o)
                      break n;
                    return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, o);
                  }
                  if (i === s)
                    break;
                  if (o = n, n = e[++i], t < n)
                    break e;
                }
                n = e.length;
                break i;
              }
            if (t >= o)
              break t;
            for (s = e[1], t < s && (i = 2, o = s), s = i - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t, n);
              if (i === s)
                break;
              if (n = o, o = e[--i - 1], t >= o)
                break e;
            }
            n = i, i = 0;
          }
          for (; i < n; )
            o = i + n >>> 1, t < e[o] ? n = o : i = o + 1;
          if (n = e[i], o = e[i - 1], o === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t, n);
          if (n === void 0)
            return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, o, t);
        }
        this._cachedIndex = i, this.intervalChanged_(i, o, n);
      }
      return this.interpolate_(i, o, t, n);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(t) {
      var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize;
      t *= n;
      for (var o = 0; o !== n; ++o)
        e[o] = i[t + o];
      return e;
    },
    interpolate_: function() {
      throw Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  }), Object.assign(On.prototype, {
    beforeStart_: On.prototype.copySampleValue_,
    afterEnd_: On.prototype.copySampleValue_
  }), Qs.prototype = Object.assign(Object.create(On.prototype), {
    constructor: Qs,
    DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
    intervalChanged_: function(t, e, i) {
      var n = this.parameterPositions, o = t - 2, s = t + 1, l = n[o], h = n[s];
      if (l === void 0)
        switch (this.getSettings_().endingStart) {
          case 2401:
            o = t, l = 2 * e - i;
            break;
          case 2402:
            o = n.length - 2, l = e + n[o] - n[o + 1];
            break;
          default:
            o = t, l = i;
        }
      if (h === void 0)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            s = t, h = 2 * i - e;
            break;
          case 2402:
            s = 1, h = i + n[1] - n[0];
            break;
          default:
            s = t - 1, h = e;
        }
      t = 0.5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - l), this._weightNext = t / (h - i), this._offsetPrev = o * n, this._offsetNext = s * n;
    },
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, s = this.sampleValues, l = this.valueSize;
      t *= l;
      var h = t - l, c = this._offsetPrev, p = this._offsetNext, f = this._weightPrev, d = this._weightNext, v = (i - e) / (n - e);
      for (i = v * v, n = i * v, e = -f * n + 2 * f * i - f * v, f = (1 + f) * n + (-1.5 - 2 * f) * i + (-0.5 + f) * v + 1, v = (-1 - d) * n + (1.5 + d) * i + 0.5 * v, d = d * n - d * i, i = 0; i !== l; ++i)
        o[i] = e * s[c + i] + f * s[h + i] + v * s[t + i] + d * s[p + i];
      return o;
    }
  }), hr.prototype = Object.assign(Object.create(On.prototype), {
    constructor: hr,
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, s = this.sampleValues, l = this.valueSize;
      t *= l;
      var h = t - l;
      for (e = (i - e) / (n - e), i = 1 - e, n = 0; n !== l; ++n)
        o[n] = s[h + n] * i + s[t + n] * e;
      return o;
    }
  }), Vo.prototype = Object.assign(Object.create(On.prototype), {
    constructor: Vo,
    interpolate_: function(t) {
      return this.copySampleValue_(t - 1);
    }
  }), Object.assign(Tn, {
    toJSON: function(t) {
      var e = t.constructor;
      if (e.toJSON !== void 0)
        e = e.toJSON(t);
      else {
        e = {
          name: t.name,
          times: Ln.convertArray(t.times, Array),
          values: Ln.convertArray(t.values, Array)
        };
        var i = t.getInterpolation();
        i !== t.DefaultInterpolation && (e.interpolation = i);
      }
      return e.type = t.ValueTypeName, e;
    }
  }), Object.assign(Tn.prototype, {
    constructor: Tn,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function(t) {
      return new Vo(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodLinear: function(t) {
      return new hr(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: function(t) {
      return new Qs(this.times, this.values, this.getValueSize(), t);
    },
    setInterpolation: function(t) {
      switch (t) {
        case 2300:
          var e = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (e === void 0) {
        if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, this.createInterpolant === void 0)
          if (t !== this.DefaultInterpolation)
            this.setInterpolation(this.DefaultInterpolation);
          else
            throw Error(e);
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return this.createInterpolant = e, this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(t) {
      if (t !== 0)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] += t;
      return this;
    },
    scale: function(t) {
      if (t !== 1)
        for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
          e[i] *= t;
      return this;
    },
    trim: function(t, e) {
      for (var i = this.times, n = i.length, o = 0, s = n - 1; o !== n && i[o] < t; )
        ++o;
      for (; s !== -1 && i[s] > e; )
        --s;
      return ++s, (o !== 0 || s !== n) && (o >= s && (s = Math.max(s, 1), o = s - 1), t = this.getValueSize(), this.times = Ln.arraySlice(i, o, s), this.values = Ln.arraySlice(this.values, o * t, s * t)), this;
    },
    validate: function() {
      var t = !0, e = this.getValueSize();
      e - Math.floor(e) !== 0 && (console.error(
        "THREE.KeyframeTrack: Invalid value size in track.",
        this
      ), t = !1);
      var i = this.times;
      e = this.values;
      var n = i.length;
      n === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      for (var o = null, s = 0; s !== n; s++) {
        var l = i[s];
        if (typeof l == "number" && isNaN(l)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            s,
            l
          ), t = !1;
          break;
        }
        if (o !== null && o > l) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            s,
            l,
            o
          ), t = !1;
          break;
        }
        o = l;
      }
      if (e !== void 0 && Ln.isTypedArray(e)) {
        for (s = 0, i = e.length; s !== i; ++s)
          if (n = e[s], isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              s,
              n
            ), t = !1;
            break;
          }
      }
      return t;
    },
    optimize: function() {
      for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === 2302, o = 1, s = t.length - 1, l = 1; l < s; ++l) {
        var h = !1, c = t[l];
        if (c !== t[l + 1] && (l !== 1 || c !== c[0]))
          if (n)
            h = !0;
          else {
            var p = l * i, f = p - i, d = p + i;
            for (c = 0; c !== i; ++c) {
              var v = e[p + c];
              if (v !== e[f + c] || v !== e[d + c]) {
                h = !0;
                break;
              }
            }
          }
        if (h) {
          if (l !== o)
            for (t[o] = t[l], h = l * i, p = o * i, c = 0; c !== i; ++c)
              e[p + c] = e[h + c];
          ++o;
        }
      }
      if (0 < s) {
        for (t[o] = t[s], h = s * i, p = o * i, c = 0; c !== i; ++c)
          e[p + c] = e[h + c];
        ++o;
      }
      return o !== t.length && (this.times = Ln.arraySlice(t, 0, o), this.values = Ln.arraySlice(e, 0, o * i)), this;
    }
  }), Ra.prototype = Object.assign(Object.create(Tn.prototype), {
    constructor: Ra,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), ba.prototype = Object.assign(Object.create(Tn.prototype), {
    constructor: ba,
    ValueTypeName: "color"
  }), wr.prototype = Object.assign(Object.create(Tn.prototype), {
    constructor: wr,
    ValueTypeName: "number"
  }), Gn.prototype = Object.assign(Object.create(On.prototype), {
    constructor: Gn,
    interpolate_: function(t, e, i, n) {
      var o = this.resultBuffer, s = this.sampleValues, l = this.valueSize;
      for (t *= l, e = (i - e) / (n - e), i = t + l; t !== i; t += 4)
        gt.slerpFlat(o, 0, s, t - l, s, t, e);
      return o;
    }
  }), Ms.prototype = Object.assign(Object.create(Tn.prototype), {
    constructor: Ms,
    ValueTypeName: "quaternion",
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodLinear: function(t) {
      return new Gn(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: void 0
  }), Oa.prototype = Object.assign(Object.create(Tn.prototype), {
    constructor: Oa,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), Ts.prototype = Object.assign(Object.create(Tn.prototype), {
    constructor: Ts,
    ValueTypeName: "vector"
  }), Object.assign(Qn, {
    parse: function(t) {
      for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), o = 0, s = i.length; o !== s; ++o)
        e.push(lh(i[o]).scale(n));
      return new Qn(t.name, t.duration, e);
    },
    toJSON: function(t) {
      var e = [], i = t.tracks;
      t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid };
      for (var n = 0, o = i.length; n !== o; ++n)
        e.push(Tn.toJSON(i[n]));
      return t;
    },
    CreateFromMorphTargetSequence: function(t, e, i, n) {
      for (var o = e.length, s = [], l = 0; l < o; l++) {
        var h = [], c = [];
        h.push((l + o - 1) % o, l, (l + 1) % o), c.push(0, 1, 0);
        var p = Ln.getKeyframeOrder(h);
        h = Ln.sortedArray(h, 1, p), c = Ln.sortedArray(c, 1, p), n || h[0] !== 0 || (h.push(o), c.push(c[0])), s.push(
          new wr(".morphTargetInfluences[" + e[l].name + "]", h, c).scale(1 / i)
        );
      }
      return new Qn(t, -1, s);
    },
    findByName: function(t, e) {
      var i = t;
      for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)
        if (i[t].name === e)
          return i[t];
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(t, e, i) {
      for (var n = {}, o = /^([\w-]*?)([\d]+)$/, s = 0, l = t.length; s < l; s++) {
        var h = t[s], c = h.name.match(o);
        if (c && 1 < c.length) {
          var p = c[1];
          (c = n[p]) || (n[p] = c = []), c.push(h);
        }
      }
      t = [];
      for (p in n)
        t.push(Qn.CreateFromMorphTargetSequence(p, n[p], e, i));
      return t;
    },
    parseAnimation: function(t, e) {
      if (!t)
        return console.error(
          "THREE.AnimationClip: No animation in JSONLoader data."
        ), null;
      var i = function(R, I, Q, W, st) {
        if (Q.length !== 0) {
          var K = [], wt = [];
          Ln.flattenJSON(Q, K, wt, W), K.length !== 0 && st.push(new R(I, K, wt));
        }
      }, n = [], o = t.name || "default", s = t.length || -1, l = t.fps || 30;
      t = t.hierarchy || [];
      for (var h = 0; h < t.length; h++) {
        var c = t[h].keys;
        if (c && c.length !== 0)
          if (c[0].morphTargets) {
            s = {};
            for (var p = 0; p < c.length; p++)
              if (c[p].morphTargets)
                for (var f = 0; f < c[p].morphTargets.length; f++)
                  s[c[p].morphTargets[f]] = -1;
            for (var d in s) {
              var v = [], w = [];
              for (f = 0; f !== c[p].morphTargets.length; ++f) {
                var P = c[p];
                v.push(P.time), w.push(P.morphTarget === d ? 1 : 0);
              }
              n.push(new wr(".morphTargetInfluence[" + d + "]", v, w));
            }
            s = s.length * (l || 1);
          } else
            p = ".bones[" + e[h].name + "]", i(Ts, p + ".position", c, "pos", n), i(Ms, p + ".quaternion", c, "rot", n), i(Ts, p + ".scale", c, "scl", n);
      }
      return n.length === 0 ? null : new Qn(o, s, n);
    }
  }), Object.assign(Qn.prototype, {
    resetDuration: function() {
      for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
        var n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return this.duration = t, this;
    },
    trim: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    },
    validate: function() {
      for (var t = !0, e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    },
    optimize: function() {
      for (var t = 0; t < this.tracks.length; t++)
        this.tracks[t].optimize();
      return this;
    }
  });
  var Vr = {
    enabled: !1,
    files: {},
    add: function(t, e) {
      this.enabled !== !1 && (this.files[t] = e);
    },
    get: function(t) {
      if (this.enabled !== !1)
        return this.files[t];
    },
    remove: function(t) {
      delete this.files[t];
    },
    clear: function() {
      this.files = {};
    }
  }, zn = new vo(), pr = {};
  Object.assign(lt.prototype, {
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var o = this, s = Vr.get(t);
      if (s !== void 0)
        return o.manager.itemStart(t), setTimeout(function() {
          e && e(s), o.manager.itemEnd(t);
        }, 0), s;
      if (pr[t] !== void 0)
        pr[t].push({ onLoad: e, onProgress: i, onError: n });
      else {
        var l = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (l) {
          i = l[1];
          var h = !!l[2];
          l = l[3], l = decodeURIComponent(l), h && (l = atob(l));
          try {
            var c = (this.responseType || "").toLowerCase();
            switch (c) {
              case "arraybuffer":
              case "blob":
                var p = new Uint8Array(l.length);
                for (h = 0; h < l.length; h++)
                  p[h] = l.charCodeAt(h);
                var f = c === "blob" ? new Blob([p.buffer], { type: i }) : p.buffer;
                break;
              case "document":
                f = new DOMParser().parseFromString(l, i);
                break;
              case "json":
                f = JSON.parse(l);
                break;
              default:
                f = l;
            }
            setTimeout(function() {
              e && e(f), o.manager.itemEnd(t);
            }, 0);
          } catch (v) {
            setTimeout(function() {
              n && n(v), o.manager.itemError(t), o.manager.itemEnd(t);
            }, 0);
          }
        } else {
          pr[t] = [], pr[t].push({ onLoad: e, onProgress: i, onError: n });
          var d = new XMLHttpRequest();
          d.open("GET", t, !0), d.addEventListener(
            "load",
            function(v) {
              var w = this.response;
              Vr.add(t, w);
              var P = pr[t];
              if (delete pr[t], this.status === 200 || this.status === 0) {
                this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var R = 0, I = P.length; R < I; R++) {
                  var Q = P[R];
                  Q.onLoad && Q.onLoad(w);
                }
              } else {
                for (R = 0, I = P.length; R < I; R++)
                  Q = P[R], Q.onError && Q.onError(v);
                o.manager.itemError(t);
              }
              o.manager.itemEnd(t);
            },
            !1
          ), d.addEventListener(
            "progress",
            function(v) {
              for (var w = pr[t], P = 0, R = w.length; P < R; P++) {
                var I = w[P];
                I.onProgress && I.onProgress(v);
              }
            },
            !1
          ), d.addEventListener(
            "error",
            function(v) {
              var w = pr[t];
              delete pr[t];
              for (var P = 0, R = w.length; P < R; P++) {
                var I = w[P];
                I.onError && I.onError(v);
              }
              o.manager.itemError(t), o.manager.itemEnd(t);
            },
            !1
          ), d.addEventListener(
            "abort",
            function(v) {
              var w = pr[t];
              delete pr[t];
              for (var P = 0, R = w.length; P < R; P++) {
                var I = w[P];
                I.onError && I.onError(v);
              }
              o.manager.itemError(t), o.manager.itemEnd(t);
            },
            !1
          ), this.responseType !== void 0 && (d.responseType = this.responseType), this.withCredentials !== void 0 && (d.withCredentials = this.withCredentials), d.overrideMimeType && d.overrideMimeType(
            this.mimeType !== void 0 ? this.mimeType : "text/plain"
          );
          for (h in this.requestHeader)
            d.setRequestHeader(h, this.requestHeader[h]);
          d.send(null);
        }
        return o.manager.itemStart(t), d;
      }
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResponseType: function(t) {
      return this.responseType = t, this;
    },
    setWithCredentials: function(t) {
      return this.withCredentials = t, this;
    },
    setMimeType: function(t) {
      return this.mimeType = t, this;
    },
    setRequestHeader: function(t) {
      return this.requestHeader = t, this;
    }
  }), Object.assign(Ot.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new lt(o.manager);
      s.setPath(o.path), s.load(
        t,
        function(l) {
          e(o.parse(JSON.parse(l)));
        },
        i,
        n
      );
    },
    parse: function(t, e) {
      for (var i = [], n = 0; n < t.length; n++) {
        var o = Qn.parse(t[n]);
        i.push(o);
      }
      e(i);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(At.prototype, {
    load: function(t, e, i, n) {
      function o(v) {
        c.load(
          t[v],
          function(w) {
            w = s._parser(w, !0), l[v] = {
              width: w.width,
              height: w.height,
              format: w.format,
              mipmaps: w.mipmaps
            }, p += 1, p === 6 && (w.mipmapCount === 1 && (h.minFilter = 1006), h.format = w.format, h.needsUpdate = !0, e && e(h));
          },
          i,
          n
        );
      }
      var s = this, l = [], h = new ho();
      h.image = l;
      var c = new lt(this.manager);
      if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(t))
        for (var p = 0, f = 0, d = t.length; f < d; ++f)
          o(f);
      else
        c.load(
          t,
          function(v) {
            if (v = s._parser(v, !0), v.isCubemap)
              for (var w = v.mipmaps.length / v.mipmapCount, P = 0; P < w; P++) {
                l[P] = { mipmaps: [] };
                for (var R = 0; R < v.mipmapCount; R++)
                  l[P].mipmaps.push(v.mipmaps[P * v.mipmapCount + R]), l[P].format = v.format, l[P].width = v.width, l[P].height = v.height;
              }
            else
              h.image.width = v.width, h.image.height = v.height, h.mipmaps = v.mipmaps;
            v.mipmapCount === 1 && (h.minFilter = 1006), h.format = v.format, h.needsUpdate = !0, e && e(h);
          },
          i,
          n
        );
      return h;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(xe.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new vt(), l = new lt(this.manager);
      return l.setResponseType("arraybuffer"), l.setPath(this.path), l.load(
        t,
        function(h) {
          (h = o._parser(h)) && (h.image !== void 0 ? s.image = h.image : h.data !== void 0 && (s.image.width = h.width, s.image.height = h.height, s.image.data = h.data), s.wrapS = h.wrapS !== void 0 ? h.wrapS : 1001, s.wrapT = h.wrapT !== void 0 ? h.wrapT : 1001, s.magFilter = h.magFilter !== void 0 ? h.magFilter : 1006, s.minFilter = h.minFilter !== void 0 ? h.minFilter : 1008, s.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1, h.format !== void 0 && (s.format = h.format), h.type !== void 0 && (s.type = h.type), h.mipmaps !== void 0 && (s.mipmaps = h.mipmaps), h.mipmapCount === 1 && (s.minFilter = 1006), s.needsUpdate = !0, e && e(s, h));
        },
        i,
        n
      ), s;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Ve.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function o() {
        c.removeEventListener("load", o, !1), c.removeEventListener("error", s, !1), Vr.add(t, this), e && e(this), l.manager.itemEnd(t);
      }
      function s(p) {
        c.removeEventListener("load", o, !1), c.removeEventListener("error", s, !1), n && n(p), l.manager.itemError(t), l.manager.itemEnd(t);
      }
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var l = this, h = Vr.get(t);
      if (h !== void 0)
        return l.manager.itemStart(t), setTimeout(function() {
          e && e(h), l.manager.itemEnd(t);
        }, 0), h;
      var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      return c.addEventListener("load", o, !1), c.addEventListener("error", s, !1), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (c.crossOrigin = this.crossOrigin), l.manager.itemStart(t), c.src = t, c;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(_i.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      function o(c) {
        l.load(
          t[c],
          function(p) {
            s.images[c] = p, h++, h === 6 && (s.needsUpdate = !0, e && e(s));
          },
          void 0,
          n
        );
      }
      var s = new A(), l = new Ve(this.manager);
      l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
      var h = 0;
      for (i = 0; i < t.length; ++i)
        o(i);
      return s;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Xi.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = new kt(), s = new Ve(this.manager);
      return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(
        t,
        function(l) {
          o.image = l, l = 0 < t.search(/\.jpe?g$/i) || t.search(/^data:image\/jpeg/) === 0, o.format = l ? 1022 : 1023, o.needsUpdate = !0, e !== void 0 && e(o);
        },
        i,
        n
      ), o;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(he.prototype, {
    getPoint: function() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    },
    getPointAt: function(t, e) {
      return t = this.getUtoTmapping(t), this.getPoint(t, e);
    },
    getPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return e;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 5);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPointAt(i / t));
      return e;
    },
    getLength: function() {
      var t = this.getLengths();
      return t[t.length - 1];
    },
    getLengths: function(t) {
      if (t === void 0 && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      var e = [], i = this.getPoint(0), n, o = 0;
      for (e.push(0), n = 1; n <= t; n++) {
        var s = this.getPoint(n / t);
        o += s.distanceTo(i), e.push(o), i = s;
      }
      return this.cacheArcLengths = e;
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.getLengths();
    },
    getUtoTmapping: function(t, e) {
      var i = this.getLengths(), n = i.length;
      e = e || t * i[n - 1];
      for (var o = 0, s = n - 1, l; o <= s; )
        if (t = Math.floor(o + (s - o) / 2), l = i[t] - e, 0 > l)
          o = t + 1;
        else if (0 < l)
          s = t - 1;
        else {
          s = t;
          break;
        }
      return t = s, i[t] === e ? t / (n - 1) : (o = i[t], (t + (e - o) / (i[t + 1] - o)) / (n - 1));
    },
    getTangent: function(t) {
      var e = t - 1e-4;
      return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize();
    },
    getTangentAt: function(t) {
      return t = this.getUtoTmapping(t), this.getTangent(t);
    },
    computeFrenetFrames: function(t, e) {
      var i = new S(), n = [], o = [], s = [], l = new S(), h = new pt(), c;
      for (c = 0; c <= t; c++) {
        var p = c / t;
        n[c] = this.getTangentAt(p), n[c].normalize();
      }
      o[0] = new S(), s[0] = new S(), c = Number.MAX_VALUE, p = Math.abs(n[0].x);
      var f = Math.abs(n[0].y), d = Math.abs(n[0].z);
      for (p <= c && (c = p, i.set(1, 0, 0)), f <= c && (c = f, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), l.crossVectors(n[0], i).normalize(), o[0].crossVectors(n[0], l), s[0].crossVectors(n[0], o[0]), c = 1; c <= t; c++)
        o[c] = o[c - 1].clone(), s[c] = s[c - 1].clone(), l.crossVectors(n[c - 1], n[c]), l.length() > Number.EPSILON && (l.normalize(), i = Math.acos(Je.clamp(n[c - 1].dot(n[c]), -1, 1)), o[c].applyMatrix4(h.makeRotationAxis(l, i))), s[c].crossVectors(n[c], o[c]);
      if (e === !0)
        for (i = Math.acos(Je.clamp(o[0].dot(o[t]), -1, 1)), i /= t, 0 < n[0].dot(l.crossVectors(o[0], o[t])) && (i = -i), c = 1; c <= t; c++)
          o[c].applyMatrix4(h.makeRotationAxis(n[c], i * c)), s[c].crossVectors(n[c], o[c]);
      return { tangents: n, normals: o, binormals: s };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    },
    toJSON: function() {
      var t = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" }
      };
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    },
    fromJSON: function(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  }), In.prototype = Object.create(he.prototype), In.prototype.constructor = In, In.prototype.isEllipseCurve = !0, In.prototype.getPoint = function(t, e) {
    e = e || new y();
    for (var i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, o = Math.abs(n) < Number.EPSILON; 0 > n; )
      n += i;
    for (; n > i; )
      n -= i;
    n < Number.EPSILON && (n = o ? 0 : i), this.aClockwise !== !0 || o || (n = n === i ? -i : n - i), i = this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(i);
    var s = this.aY + this.yRadius * Math.sin(i);
    return this.aRotation !== 0 && (i = Math.cos(this.aRotation), n = Math.sin(this.aRotation), o = t - this.aX, s -= this.aY, t = o * i - s * n + this.aX, s = o * n + s * i + this.aY), e.set(t, s);
  }, In.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, In.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }, In.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, Ss.prototype = Object.create(In.prototype), Ss.prototype.constructor = Ss, Ss.prototype.isArcCurve = !0;
  var ln = new S(), ma = new Hn(), Ga = new Hn(), fr = new Hn();
  fn.prototype = Object.create(he.prototype), fn.prototype.constructor = fn, fn.prototype.isCatmullRomCurve3 = !0, fn.prototype.getPoint = function(t, e) {
    e = e || new S();
    var i = this.points, n = i.length;
    t *= n - (this.closed ? 0 : 1);
    var o = Math.floor(t);
    if (t -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : t === 0 && o === n - 1 && (o = n - 2, t = 1), this.closed || 0 < o)
      var s = i[(o - 1) % n];
    else
      ln.subVectors(i[0], i[1]).add(i[0]), s = ln;
    var l = i[o % n], h = i[(o + 1) % n];
    if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (ln.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = ln), this.curveType === "centripetal" || this.curveType === "chordal") {
      var c = this.curveType === "chordal" ? 0.5 : 0.25;
      n = Math.pow(s.distanceToSquared(l), c), o = Math.pow(l.distanceToSquared(h), c), c = Math.pow(h.distanceToSquared(i), c), 1e-4 > o && (o = 1), 1e-4 > n && (n = o), 1e-4 > c && (c = o), ma.initNonuniformCatmullRom(s.x, l.x, h.x, i.x, n, o, c), Ga.initNonuniformCatmullRom(s.y, l.y, h.y, i.y, n, o, c), fr.initNonuniformCatmullRom(s.z, l.z, h.z, i.z, n, o, c);
    } else
      this.curveType === "catmullrom" && (ma.initCatmullRom(s.x, l.x, h.x, i.x, this.tension), Ga.initCatmullRom(s.y, l.y, h.y, i.y, this.tension), fr.initCatmullRom(s.z, l.z, h.z, i.z, this.tension));
    return e.set(ma.calc(t), Ga.calc(t), fr.calc(t)), e;
  }, fn.prototype.copy = function(t) {
    he.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, fn.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }, fn.prototype.fromJSON = function(t) {
    he.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new S().fromArray(n));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, kn.prototype = Object.create(he.prototype), kn.prototype.constructor = kn, kn.prototype.isCubicBezierCurve = !0, kn.prototype.getPoint = function(t, e) {
    e = e || new y();
    var i = this.v0, n = this.v1, o = this.v2, s = this.v3;
    return e.set(yo(t, i.x, n.x, o.x, s.x), yo(t, i.y, n.y, o.y, s.y)), e;
  }, kn.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, kn.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, kn.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, si.prototype = Object.create(he.prototype), si.prototype.constructor = si, si.prototype.isCubicBezierCurve3 = !0, si.prototype.getPoint = function(t, e) {
    e = e || new S();
    var i = this.v0, n = this.v1, o = this.v2, s = this.v3;
    return e.set(
      yo(t, i.x, n.x, o.x, s.x),
      yo(t, i.y, n.y, o.y, s.y),
      yo(t, i.z, n.z, o.z, s.z)
    ), e;
  }, si.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, si.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, si.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, Vn.prototype = Object.create(he.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isLineCurve = !0, Vn.prototype.getPoint = function(t, e) {
    return e = e || new y(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, Vn.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, Vn.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
  }, Vn.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Vn.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Vn.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, ur.prototype = Object.create(he.prototype), ur.prototype.constructor = ur, ur.prototype.isLineCurve3 = !0, ur.prototype.getPoint = function(t, e) {
    return e = e || new S(), t === 1 ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e;
  }, ur.prototype.getPointAt = function(t, e) {
    return this.getPoint(t, e);
  }, ur.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, ur.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, ur.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Wn.prototype = Object.create(he.prototype), Wn.prototype.constructor = Wn, Wn.prototype.isQuadraticBezierCurve = !0, Wn.prototype.getPoint = function(t, e) {
    e = e || new y();
    var i = this.v0, n = this.v1, o = this.v2;
    return e.set(Br(t, i.x, n.x, o.x), Br(t, i.y, n.y, o.y)), e;
  }, Wn.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Wn.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Wn.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Ur.prototype = Object.create(he.prototype), Ur.prototype.constructor = Ur, Ur.prototype.isQuadraticBezierCurve3 = !0, Ur.prototype.getPoint = function(t, e) {
    e = e || new S();
    var i = this.v0, n = this.v1, o = this.v2;
    return e.set(Br(t, i.x, n.x, o.x), Br(t, i.y, n.y, o.y), Br(t, i.z, n.z, o.z)), e;
  }, Ur.prototype.copy = function(t) {
    return he.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Ur.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Ur.prototype.fromJSON = function(t) {
    return he.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Mr.prototype = Object.create(he.prototype), Mr.prototype.constructor = Mr, Mr.prototype.isSplineCurve = !0, Mr.prototype.getPoint = function(t, e) {
    e = e || new y();
    var i = this.points, n = (i.length - 1) * t;
    t = Math.floor(n), n -= t;
    var o = i[t === 0 ? t : t - 1], s = i[t], l = i[t > i.length - 2 ? i.length - 1 : t + 1];
    return i = i[t > i.length - 3 ? i.length - 1 : t + 2], e.set(Rl(n, o.x, s.x, l.x, i.x), Rl(n, o.y, s.y, l.y, i.y)), e;
  }, Mr.prototype.copy = function(t) {
    he.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++)
      this.points.push(t.points[e].clone());
    return this;
  }, Mr.prototype.toJSON = function() {
    var t = he.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++)
      t.points.push(this.points[e].toArray());
    return t;
  }, Mr.prototype.fromJSON = function(t) {
    he.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var n = t.points[e];
      this.points.push(new y().fromArray(n));
    }
    return this;
  };
  var Ha = Object.freeze({
    ArcCurve: Ss,
    CatmullRomCurve3: fn,
    CubicBezierCurve: kn,
    CubicBezierCurve3: si,
    EllipseCurve: In,
    LineCurve: Vn,
    LineCurve3: ur,
    QuadraticBezierCurve: Wn,
    QuadraticBezierCurve3: Ur,
    SplineCurve: Mr
  });
  Kr.prototype = Object.assign(Object.create(he.prototype), {
    constructor: Kr,
    add: function(t) {
      this.curves.push(t);
    },
    closePath: function() {
      var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Vn(e, t));
    },
    getPoint: function(t) {
      var e = t * this.getLength(), i = this.getCurveLengths();
      for (t = 0; t < i.length; ) {
        if (i[t] >= e)
          return e = i[t] - e, t = this.curves[t], i = t.getLength(), t.getPointAt(i === 0 ? 0 : 1 - e / i);
        t++;
      }
      return null;
    },
    getLength: function() {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
        e += this.curves[i].getLength(), t.push(e);
      return this.cacheLengths = t;
    },
    getSpacedPoints: function(t) {
      t === void 0 && (t = 40);
      for (var e = [], i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]), e;
    },
    getPoints: function(t) {
      t = t || 12;
      for (var e = [], i, n = 0, o = this.curves; n < o.length; n++) {
        var s = o[n];
        s = s.getPoints(
          s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
        );
        for (var l = 0; l < s.length; l++) {
          var h = s[l];
          i && i.equals(h) || (e.push(h), i = h);
        }
      }
      return this.autoClose && 1 < e.length && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
    },
    copy: function(t) {
      he.prototype.copy.call(this, t), this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++)
        this.curves.push(t.curves[e].clone());
      return this.autoClose = t.autoClose, this;
    },
    toJSON: function() {
      var t = he.prototype.toJSON.call(this);
      t.autoClose = this.autoClose, t.curves = [];
      for (var e = 0, i = this.curves.length; e < i; e++)
        t.curves.push(this.curves[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      he.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var n = t.curves[e];
        this.curves.push(new Ha[n.type]().fromJSON(n));
      }
      return this;
    }
  }), jn.prototype = Object.assign(Object.create(Kr.prototype), {
    constructor: jn,
    setFromPoints: function(t) {
      this.moveTo(t[0].x, t[0].y);
      for (var e = 1, i = t.length; e < i; e++)
        this.lineTo(t[e].x, t[e].y);
    },
    moveTo: function(t, e) {
      this.currentPoint.set(t, e);
    },
    lineTo: function(t, e) {
      var i = new Vn(this.currentPoint.clone(), new y(t, e));
      this.curves.push(i), this.currentPoint.set(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      t = new Wn(this.currentPoint.clone(), new y(t, e), new y(i, n)), this.curves.push(t), this.currentPoint.set(i, n);
    },
    bezierCurveTo: function(t, e, i, n, o, s) {
      t = new kn(
        this.currentPoint.clone(),
        new y(t, e),
        new y(i, n),
        new y(o, s)
      ), this.curves.push(t), this.currentPoint.set(o, s);
    },
    splineThru: function(t) {
      var e = [this.currentPoint.clone()].concat(t);
      e = new Mr(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
    },
    arc: function(t, e, i, n, o, s) {
      this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, o, s);
    },
    absarc: function(t, e, i, n, o, s) {
      this.absellipse(t, e, i, i, n, o, s);
    },
    ellipse: function(t, e, i, n, o, s, l, h) {
      this.absellipse(
        t + this.currentPoint.x,
        e + this.currentPoint.y,
        i,
        n,
        o,
        s,
        l,
        h
      );
    },
    absellipse: function(t, e, i, n, o, s, l, h) {
      t = new In(t, e, i, n, o, s, l, h), 0 < this.curves.length && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t);
    },
    copy: function(t) {
      return Kr.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
    },
    toJSON: function() {
      var t = Kr.prototype.toJSON.call(this);
      return t.currentPoint = this.currentPoint.toArray(), t;
    },
    fromJSON: function(t) {
      return Kr.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
    }
  }), Dn.prototype = Object.assign(Object.create(jn.prototype), {
    constructor: Dn,
    getPointsHoles: function(t) {
      for (var e = [], i = 0, n = this.holes.length; i < n; i++)
        e[i] = this.holes[i].getPoints(t);
      return e;
    },
    extractPoints: function(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    },
    copy: function(t) {
      jn.prototype.copy.call(this, t), this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++)
        this.holes.push(t.holes[e].clone());
      return this;
    },
    toJSON: function() {
      var t = jn.prototype.toJSON.call(this);
      t.uuid = this.uuid, t.holes = [];
      for (var e = 0, i = this.holes.length; e < i; e++)
        t.holes.push(this.holes[e].toJSON());
      return t;
    },
    fromJSON: function(t) {
      jn.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++) {
        var n = t.holes[e];
        this.holes.push(new jn().fromJSON(n));
      }
      return this;
    }
  }), Bi.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Bi,
    isLight: !0,
    copy: function(t) {
      return z.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
    },
    toJSON: function(t) {
      return t = z.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
  }), Ks.prototype = Object.assign(Object.create(Bi.prototype), {
    constructor: Ks,
    isHemisphereLight: !0,
    copy: function(t) {
      return Bi.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    }
  }), Object.assign(Fr.prototype, {
    copy: function(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var t = {};
      return this.bias !== 0 && (t.bias = this.bias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
  }), ta.prototype = Object.assign(Object.create(Fr.prototype), {
    constructor: ta,
    isSpotLightShadow: !0,
    update: function(t) {
      var e = this.camera, i = 2 * Je.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height;
      t = t.distance || e.far, (i !== e.fov || n !== e.aspect || t !== e.far) && (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix());
    }
  }), ea.prototype = Object.assign(Object.create(Bi.prototype), {
    constructor: ea,
    isSpotLight: !0,
    copy: function(t) {
      return Bi.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), Wo.prototype = Object.assign(Object.create(Bi.prototype), {
    constructor: Wo,
    isPointLight: !0,
    copy: function(t) {
      return Bi.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }), Es.prototype = Object.assign(Object.create(ye.prototype), {
    constructor: Es,
    isOrthographicCamera: !0,
    copy: function(t, e) {
      return ye.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
    },
    setViewOffset: function(t, e, i, n, o, s) {
      this.view === null && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = o, this.view.height = s, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, o = i - t;
      if (i += t, t = n + e, e = n - e, this.view !== null && this.view.enabled) {
        i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight);
        var s = (this.right - this.left) / this.view.width;
        n = (this.top - this.bottom) / this.view.height, o += this.view.offsetX / i * s, i = o + this.view.width / i * s, t -= this.view.offsetY / e * n, e = t - this.view.height / e * n;
      }
      this.projectionMatrix.makeOrthographic(o, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(t) {
      return t = z.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }), _o.prototype = Object.assign(Object.create(Fr.prototype), {
    constructor: _o
  }), Gr.prototype = Object.assign(Object.create(Bi.prototype), {
    constructor: Gr,
    isDirectionalLight: !0,
    copy: function(t) {
      return Bi.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }), jo.prototype = Object.assign(Object.create(Bi.prototype), {
    constructor: jo,
    isAmbientLight: !0
  }), Ia.prototype = Object.assign(Object.create(Bi.prototype), {
    constructor: Ia,
    isRectAreaLight: !0,
    copy: function(t) {
      return Bi.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
    },
    toJSON: function(t) {
      return t = Bi.prototype.toJSON.call(this, t), t.object.width = this.width, t.object.height = this.height, t;
    }
  }), Object.assign(Da.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new lt(o.manager);
      s.setPath(o.path), s.load(
        t,
        function(l) {
          e(o.parse(JSON.parse(l)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      function e(l) {
        return i[l] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", l), i[l];
      }
      var i = this.textures, n = new Gl[t.type]();
      if (t.uuid !== void 0 && (n.uuid = t.uuid), t.name !== void 0 && (n.name = t.name), t.color !== void 0 && n.color.setHex(t.color), t.roughness !== void 0 && (n.roughness = t.roughness), t.metalness !== void 0 && (n.metalness = t.metalness), t.emissive !== void 0 && n.emissive.setHex(t.emissive), t.specular !== void 0 && n.specular.setHex(t.specular), t.shininess !== void 0 && (n.shininess = t.shininess), t.clearCoat !== void 0 && (n.clearCoat = t.clearCoat), t.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = t.clearCoatRoughness), t.vertexColors !== void 0 && (n.vertexColors = t.vertexColors), t.fog !== void 0 && (n.fog = t.fog), t.flatShading !== void 0 && (n.flatShading = t.flatShading), t.blending !== void 0 && (n.blending = t.blending), t.combine !== void 0 && (n.combine = t.combine), t.side !== void 0 && (n.side = t.side), t.opacity !== void 0 && (n.opacity = t.opacity), t.transparent !== void 0 && (n.transparent = t.transparent), t.alphaTest !== void 0 && (n.alphaTest = t.alphaTest), t.depthTest !== void 0 && (n.depthTest = t.depthTest), t.depthWrite !== void 0 && (n.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (n.colorWrite = t.colorWrite), t.wireframe !== void 0 && (n.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (n.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (n.rotation = t.rotation), t.linewidth !== 1 && (n.linewidth = t.linewidth), t.dashSize !== void 0 && (n.dashSize = t.dashSize), t.gapSize !== void 0 && (n.gapSize = t.gapSize), t.scale !== void 0 && (n.scale = t.scale), t.polygonOffset !== void 0 && (n.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = t.polygonOffsetUnits), t.skinning !== void 0 && (n.skinning = t.skinning), t.morphTargets !== void 0 && (n.morphTargets = t.morphTargets), t.dithering !== void 0 && (n.dithering = t.dithering), t.visible !== void 0 && (n.visible = t.visible), t.userData !== void 0 && (n.userData = t.userData), t.uniforms !== void 0)
        for (var o in t.uniforms) {
          var s = t.uniforms[o];
          switch (n.uniforms[o] = {}, s.type) {
            case "t":
              n.uniforms[o].value = e(s.value);
              break;
            case "c":
              n.uniforms[o].value = new Y().setHex(s.value);
              break;
            case "v2":
              n.uniforms[o].value = new y().fromArray(s.value);
              break;
            case "v3":
              n.uniforms[o].value = new S().fromArray(s.value);
              break;
            case "v4":
              n.uniforms[o].value = new nt().fromArray(s.value);
              break;
            case "m4":
              n.uniforms[o].value = new pt().fromArray(s.value);
              break;
            default:
              n.uniforms[o].value = s.value;
          }
        }
      return t.defines !== void 0 && (n.defines = t.defines), t.vertexShader !== void 0 && (n.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (n.fragmentShader = t.fragmentShader), t.shading !== void 0 && (n.flatShading = t.shading === 1), t.size !== void 0 && (n.size = t.size), t.sizeAttenuation !== void 0 && (n.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (n.map = e(t.map)), t.alphaMap !== void 0 && (n.alphaMap = e(t.alphaMap), n.transparent = !0), t.bumpMap !== void 0 && (n.bumpMap = e(t.bumpMap)), t.bumpScale !== void 0 && (n.bumpScale = t.bumpScale), t.normalMap !== void 0 && (n.normalMap = e(t.normalMap)), t.normalMapType !== void 0 && (n.normalMapType = t.normalMapType), t.normalScale !== void 0 && (o = t.normalScale, Array.isArray(o) === !1 && (o = [o, o]), n.normalScale = new y().fromArray(o)), t.displacementMap !== void 0 && (n.displacementMap = e(t.displacementMap)), t.displacementScale !== void 0 && (n.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (n.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (n.roughnessMap = e(t.roughnessMap)), t.metalnessMap !== void 0 && (n.metalnessMap = e(t.metalnessMap)), t.emissiveMap !== void 0 && (n.emissiveMap = e(t.emissiveMap)), t.emissiveIntensity !== void 0 && (n.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (n.specularMap = e(t.specularMap)), t.envMap !== void 0 && (n.envMap = e(t.envMap)), t.envMapIntensity !== void 0 && (n.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (n.reflectivity = t.reflectivity), t.lightMap !== void 0 && (n.lightMap = e(t.lightMap)), t.lightMapIntensity !== void 0 && (n.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (n.aoMap = e(t.aoMap)), t.aoMapIntensity !== void 0 && (n.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (n.gradientMap = e(t.gradientMap)), n;
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setTextures: function(t) {
      return this.textures = t, this;
    }
  });
  var $o = {
    decodeText: function(t) {
      if (typeof TextDecoder < "u")
        return new TextDecoder().decode(t);
      for (var e = "", i = 0, n = t.length; i < n; i++)
        e += String.fromCharCode(t[i]);
      return decodeURIComponent(escape(e));
    },
    extractUrlBase: function(t) {
      var e = t.lastIndexOf("/");
      return e === -1 ? "./" : t.substr(0, e + 1);
    }
  };
  Object.assign(il.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new lt(o.manager);
      s.setPath(o.path), s.load(
        t,
        function(l) {
          e(o.parse(JSON.parse(l)));
        },
        i,
        n
      );
    },
    parse: function(t) {
      var e = new Ft(), i = t.data.index;
      i !== void 0 && (i = new So[i.type](i.array), e.setIndex(new it(i, 1)));
      var n = t.data.attributes;
      for (s in n) {
        var o = n[s];
        i = new So[o.type](o.array), e.addAttribute(s, new it(i, o.itemSize, o.normalized));
      }
      var s = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (s !== void 0)
        for (i = 0, n = s.length; i !== n; ++i)
          o = s[i], e.addGroup(o.start, o.count, o.materialIndex);
      return t = t.data.boundingSphere, t !== void 0 && (s = new S(), t.center !== void 0 && s.fromArray(t.center), e.boundingSphere = new Ut(s, t.radius)), e;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var So = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  to.Handlers = {
    handlers: [],
    add: function(t, e) {
      this.handlers.push(t, e);
    },
    get: function(t) {
      for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
        var o = e[i + 1];
        if (e[i].test(t))
          return o;
      }
      return null;
    }
  }, Object.assign(to.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {
    },
    onLoadProgress: function() {
    },
    onLoadComplete: function() {
    },
    initMaterials: function(t, e, i) {
      for (var n = [], o = 0; o < t.length; ++o)
        n[o] = this.createMaterial(t[o], e, i);
      return n;
    },
    createMaterial: function() {
      var t = {
        NoBlending: 0,
        NormalBlending: 1,
        AdditiveBlending: 2,
        SubtractiveBlending: 3,
        MultiplyBlending: 4,
        CustomBlending: 5
      }, e = new Y(), i = new Xi(), n = new Da();
      return function(o, s, l) {
        function h(v, w, P, R, I) {
          v = s + v;
          var Q = to.Handlers.get(v);
          return Q !== null ? v = Q.load(v) : (i.setCrossOrigin(l), v = i.load(v)), w !== void 0 && (v.repeat.fromArray(w), w[0] !== 1 && (v.wrapS = 1e3), w[1] !== 1 && (v.wrapT = 1e3)), P !== void 0 && v.offset.fromArray(P), R !== void 0 && (R[0] === "repeat" && (v.wrapS = 1e3), R[0] === "mirror" && (v.wrapS = 1002), R[1] === "repeat" && (v.wrapT = 1e3), R[1] === "mirror" && (v.wrapT = 1002)), I !== void 0 && (v.anisotropy = I), w = Je.generateUUID(), c[w] = v, w;
        }
        var c = {}, p = { uuid: Je.generateUUID(), type: "MeshLambertMaterial" }, f;
        for (f in o) {
          var d = o[f];
          switch (f) {
            case "DbgColor":
            case "DbgIndex":
            case "opticalDensity":
            case "illumination":
              break;
            case "DbgName":
              p.name = d;
              break;
            case "blending":
              p.blending = t[d];
              break;
            case "colorAmbient":
            case "mapAmbient":
              console.warn(
                "THREE.Loader.createMaterial:",
                f,
                "is no longer supported."
              );
              break;
            case "colorDiffuse":
              p.color = e.fromArray(d).getHex();
              break;
            case "colorSpecular":
              p.specular = e.fromArray(d).getHex();
              break;
            case "colorEmissive":
              p.emissive = e.fromArray(d).getHex();
              break;
            case "specularCoef":
              p.shininess = d;
              break;
            case "shading":
              d.toLowerCase() === "basic" && (p.type = "MeshBasicMaterial"), d.toLowerCase() === "phong" && (p.type = "MeshPhongMaterial"), d.toLowerCase() === "standard" && (p.type = "MeshStandardMaterial");
              break;
            case "mapDiffuse":
              p.map = h(
                d,
                o.mapDiffuseRepeat,
                o.mapDiffuseOffset,
                o.mapDiffuseWrap,
                o.mapDiffuseAnisotropy
              );
              break;
            case "mapDiffuseRepeat":
            case "mapDiffuseOffset":
            case "mapDiffuseWrap":
            case "mapDiffuseAnisotropy":
              break;
            case "mapEmissive":
              p.emissiveMap = h(
                d,
                o.mapEmissiveRepeat,
                o.mapEmissiveOffset,
                o.mapEmissiveWrap,
                o.mapEmissiveAnisotropy
              );
              break;
            case "mapEmissiveRepeat":
            case "mapEmissiveOffset":
            case "mapEmissiveWrap":
            case "mapEmissiveAnisotropy":
              break;
            case "mapLight":
              p.lightMap = h(
                d,
                o.mapLightRepeat,
                o.mapLightOffset,
                o.mapLightWrap,
                o.mapLightAnisotropy
              );
              break;
            case "mapLightRepeat":
            case "mapLightOffset":
            case "mapLightWrap":
            case "mapLightAnisotropy":
              break;
            case "mapAO":
              p.aoMap = h(
                d,
                o.mapAORepeat,
                o.mapAOOffset,
                o.mapAOWrap,
                o.mapAOAnisotropy
              );
              break;
            case "mapAORepeat":
            case "mapAOOffset":
            case "mapAOWrap":
            case "mapAOAnisotropy":
              break;
            case "mapBump":
              p.bumpMap = h(
                d,
                o.mapBumpRepeat,
                o.mapBumpOffset,
                o.mapBumpWrap,
                o.mapBumpAnisotropy
              );
              break;
            case "mapBumpScale":
              p.bumpScale = d;
              break;
            case "mapBumpRepeat":
            case "mapBumpOffset":
            case "mapBumpWrap":
            case "mapBumpAnisotropy":
              break;
            case "mapNormal":
              p.normalMap = h(
                d,
                o.mapNormalRepeat,
                o.mapNormalOffset,
                o.mapNormalWrap,
                o.mapNormalAnisotropy
              );
              break;
            case "mapNormalFactor":
              p.normalScale = d;
              break;
            case "mapNormalRepeat":
            case "mapNormalOffset":
            case "mapNormalWrap":
            case "mapNormalAnisotropy":
              break;
            case "mapSpecular":
              p.specularMap = h(
                d,
                o.mapSpecularRepeat,
                o.mapSpecularOffset,
                o.mapSpecularWrap,
                o.mapSpecularAnisotropy
              );
              break;
            case "mapSpecularRepeat":
            case "mapSpecularOffset":
            case "mapSpecularWrap":
            case "mapSpecularAnisotropy":
              break;
            case "mapMetalness":
              p.metalnessMap = h(
                d,
                o.mapMetalnessRepeat,
                o.mapMetalnessOffset,
                o.mapMetalnessWrap,
                o.mapMetalnessAnisotropy
              );
              break;
            case "mapMetalnessRepeat":
            case "mapMetalnessOffset":
            case "mapMetalnessWrap":
            case "mapMetalnessAnisotropy":
              break;
            case "mapRoughness":
              p.roughnessMap = h(
                d,
                o.mapRoughnessRepeat,
                o.mapRoughnessOffset,
                o.mapRoughnessWrap,
                o.mapRoughnessAnisotropy
              );
              break;
            case "mapRoughnessRepeat":
            case "mapRoughnessOffset":
            case "mapRoughnessWrap":
            case "mapRoughnessAnisotropy":
              break;
            case "mapAlpha":
              p.alphaMap = h(
                d,
                o.mapAlphaRepeat,
                o.mapAlphaOffset,
                o.mapAlphaWrap,
                o.mapAlphaAnisotropy
              );
              break;
            case "mapAlphaRepeat":
            case "mapAlphaOffset":
            case "mapAlphaWrap":
            case "mapAlphaAnisotropy":
              break;
            case "flipSided":
              p.side = 1;
              break;
            case "doubleSided":
              p.side = 2;
              break;
            case "transparency":
              console.warn(
                "THREE.Loader.createMaterial: transparency has been renamed to opacity"
              ), p.opacity = d;
              break;
            case "depthTest":
            case "depthWrite":
            case "colorWrite":
            case "opacity":
            case "reflectivity":
            case "transparent":
            case "visible":
            case "wireframe":
              p[f] = d;
              break;
            case "vertexColors":
              d === !0 && (p.vertexColors = 2), d === "face" && (p.vertexColors = 1);
              break;
            default:
              console.error("THREE.Loader.createMaterial: Unsupported", f, d);
          }
        }
        return p.type === "MeshBasicMaterial" && delete p.emissive, p.type !== "MeshPhongMaterial" && delete p.specular, 1 > p.opacity && (p.transparent = !0), n.setTextures(c), n.parse(p);
      };
    }()
  }), Object.assign(Xo.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = this, s = this.path === void 0 ? $o.extractUrlBase(t) : this.path, l = new lt(this.manager);
      l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
        t,
        function(h) {
          h = JSON.parse(h);
          var c = h.metadata;
          if (c !== void 0 && (c = c.type, c !== void 0 && c.toLowerCase() === "object")) {
            console.error(
              "THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead."
            );
            return;
          }
          h = o.parse(h, s), e(h.geometry, h.materials);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function() {
      return function(t, e) {
        t.data !== void 0 && (t = t.data), t.scale = t.scale !== void 0 ? 1 / t.scale : 1;
        var i = new X(), n = t, o, s, l, h = n.faces, c = n.vertices, p = n.normals, f = n.colors, d = n.scale, v = 0;
        if (n.uvs !== void 0) {
          for (o = 0; o < n.uvs.length; o++)
            n.uvs[o].length && v++;
          for (o = 0; o < v; o++)
            i.faceVertexUvs[o] = [];
        }
        var w = 0;
        for (l = c.length; w < l; )
          o = new S(), o.x = c[w++] * d, o.y = c[w++] * d, o.z = c[w++] * d, i.vertices.push(o);
        for (w = 0, l = h.length; w < l; ) {
          c = h[w++];
          var P = c & 1, R = c & 2;
          o = c & 8;
          var I = c & 16, Q = c & 32;
          if (d = c & 64, c &= 128, P) {
            P = new B(), P.a = h[w], P.b = h[w + 1], P.c = h[w + 3];
            var W = new B();
            if (W.a = h[w + 1], W.b = h[w + 2], W.c = h[w + 3], w += 4, R && (R = h[w++], P.materialIndex = R, W.materialIndex = R), R = i.faces.length, o)
              for (o = 0; o < v; o++) {
                var st = n.uvs[o];
                for (i.faceVertexUvs[o][R] = [], i.faceVertexUvs[o][R + 1] = [], s = 0; 4 > s; s++) {
                  var K = h[w++], wt = st[2 * K];
                  K = st[2 * K + 1], wt = new y(wt, K), s !== 2 && i.faceVertexUvs[o][R].push(wt), s !== 0 && i.faceVertexUvs[o][R + 1].push(wt);
                }
              }
            if (I && (I = 3 * h[w++], P.normal.set(p[I++], p[I++], p[I]), W.normal.copy(P.normal)), Q)
              for (o = 0; 4 > o; o++)
                I = 3 * h[w++], Q = new S(p[I++], p[I++], p[I]), o !== 2 && P.vertexNormals.push(Q), o !== 0 && W.vertexNormals.push(Q);
            if (d && (d = h[w++], d = f[d], P.color.setHex(d), W.color.setHex(d)), c)
              for (o = 0; 4 > o; o++)
                d = h[w++], d = f[d], o !== 2 && P.vertexColors.push(new Y(d)), o !== 0 && W.vertexColors.push(new Y(d));
            i.faces.push(P), i.faces.push(W);
          } else {
            if (P = new B(), P.a = h[w++], P.b = h[w++], P.c = h[w++], R && (R = h[w++], P.materialIndex = R), R = i.faces.length, o)
              for (o = 0; o < v; o++)
                for (st = n.uvs[o], i.faceVertexUvs[o][R] = [], s = 0; 3 > s; s++)
                  K = h[w++], wt = st[2 * K], K = st[2 * K + 1], wt = new y(wt, K), i.faceVertexUvs[o][R].push(wt);
            if (I && (I = 3 * h[w++], P.normal.set(p[I++], p[I++], p[I])), Q)
              for (o = 0; 3 > o; o++)
                I = 3 * h[w++], Q = new S(p[I++], p[I++], p[I]), P.vertexNormals.push(Q);
            if (d && (d = h[w++], P.color.setHex(f[d])), c)
              for (o = 0; 3 > o; o++)
                d = h[w++], P.vertexColors.push(new Y(f[d]));
            i.faces.push(P);
          }
        }
        if (n = t, w = n.influencesPerVertex !== void 0 ? n.influencesPerVertex : 2, n.skinWeights)
          for (l = 0, h = n.skinWeights.length; l < h; l += w)
            i.skinWeights.push(
              new nt(
                n.skinWeights[l],
                1 < w ? n.skinWeights[l + 1] : 0,
                2 < w ? n.skinWeights[l + 2] : 0,
                3 < w ? n.skinWeights[l + 3] : 0
              )
            );
        if (n.skinIndices)
          for (l = 0, h = n.skinIndices.length; l < h; l += w)
            i.skinIndices.push(
              new nt(
                n.skinIndices[l],
                1 < w ? n.skinIndices[l + 1] : 0,
                2 < w ? n.skinIndices[l + 2] : 0,
                3 < w ? n.skinIndices[l + 3] : 0
              )
            );
        if (i.bones = n.bones, i.bones && 0 < i.bones.length && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && console.warn(
          "When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match."
        ), l = t, h = l.scale, l.morphTargets !== void 0)
          for (n = 0, w = l.morphTargets.length; n < w; n++)
            for (i.morphTargets[n] = {}, i.morphTargets[n].name = l.morphTargets[n].name, i.morphTargets[n].vertices = [], p = i.morphTargets[n].vertices, f = l.morphTargets[n].vertices, v = 0, c = f.length; v < c; v += 3)
              d = new S(), d.x = f[v] * h, d.y = f[v + 1] * h, d.z = f[v + 2] * h, p.push(d);
        if (l.morphColors !== void 0 && 0 < l.morphColors.length)
          for (console.warn(
            'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
          ), h = i.faces, l = l.morphColors[0].colors, n = 0, w = h.length; n < w; n++)
            h[n].color.fromArray(l, 3 * n);
        for (l = t, n = [], w = [], l.animation !== void 0 && w.push(l.animation), l.animations !== void 0 && (l.animations.length ? w = w.concat(l.animations) : w.push(l.animations)), l = 0; l < w.length; l++)
          (h = Qn.parseAnimation(w[l], i.bones)) && n.push(h);
        return i.morphTargets && (w = Qn.CreateClipsFromMorphTargetSequences(i.morphTargets, 10), n = n.concat(w)), 0 < n.length && (i.animations = n), i.computeFaceNormals(), i.computeBoundingSphere(), t.materials === void 0 || t.materials.length === 0 ? { geometry: i } : (t = to.prototype.initMaterials(
          t.materials,
          this.resourcePath || e,
          this.crossOrigin
        ), { geometry: i, materials: t });
      };
    }()
  }), Object.assign(ia.prototype, {
    crossOrigin: "anonymous",
    load: function(t, e, i, n) {
      var o = this, s = this.path === void 0 ? $o.extractUrlBase(t) : this.path;
      this.resourcePath = this.resourcePath || s, s = new lt(o.manager), s.setPath(this.path), s.load(
        t,
        function(l) {
          var h = null;
          try {
            h = JSON.parse(l);
          } catch (c) {
            n !== void 0 && n(c), console.error(
              "THREE:ObjectLoader: Can't parse " + t + ".",
              c.message
            );
            return;
          }
          l = h.metadata, l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry" ? console.error(
            "THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead."
          ) : o.parse(h, e);
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    },
    setResourcePath: function(t) {
      return this.resourcePath = t, this;
    },
    setCrossOrigin: function(t) {
      return this.crossOrigin = t, this;
    },
    parse: function(t, e) {
      var i = this.parseShape(t.shapes);
      i = this.parseGeometries(t.geometries, i);
      var n = this.parseImages(t.images, function() {
        e !== void 0 && e(o);
      });
      n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n);
      var o = this.parseObject(t.object, i, n);
      return t.animations && (o.animations = this.parseAnimations(t.animations)), t.images !== void 0 && t.images.length !== 0 || e === void 0 || e(o), o;
    },
    parseShape: function(t) {
      var e = {};
      if (t !== void 0)
        for (var i = 0, n = t.length; i < n; i++) {
          var o = new Dn().fromJSON(t[i]);
          e[o.uuid] = o;
        }
      return e;
    },
    parseGeometries: function(t, e) {
      var i = {};
      if (t !== void 0)
        for (var n = new Xo(), o = new il(), s = 0, l = t.length; s < l; s++) {
          var h = t[s];
          switch (h.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              var c = new Qi[h.type](
                h.width,
                h.height,
                h.widthSegments,
                h.heightSegments
              );
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
              c = new Qi[h.type](
                h.width,
                h.height,
                h.depth,
                h.widthSegments,
                h.heightSegments,
                h.depthSegments
              );
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              c = new Qi[h.type](
                h.radius,
                h.segments,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              c = new Qi[h.type](
                h.radiusTop,
                h.radiusBottom,
                h.height,
                h.radialSegments,
                h.heightSegments,
                h.openEnded,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              c = new Qi[h.type](
                h.radius,
                h.height,
                h.radialSegments,
                h.heightSegments,
                h.openEnded,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              c = new Qi[h.type](
                h.radius,
                h.widthSegments,
                h.heightSegments,
                h.phiStart,
                h.phiLength,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              c = new Qi[h.type](h.radius, h.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              c = new Qi[h.type](
                h.innerRadius,
                h.outerRadius,
                h.thetaSegments,
                h.phiSegments,
                h.thetaStart,
                h.thetaLength
              );
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              c = new Qi[h.type](
                h.radius,
                h.tube,
                h.radialSegments,
                h.tubularSegments,
                h.arc
              );
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              c = new Qi[h.type](
                h.radius,
                h.tube,
                h.tubularSegments,
                h.radialSegments,
                h.p,
                h.q
              );
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              c = new Qi[h.type](h.points, h.segments, h.phiStart, h.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              c = new Qi[h.type](h.vertices, h.indices, h.radius, h.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              c = [];
              for (var p = 0, f = h.shapes.length; p < f; p++) {
                var d = e[h.shapes[p]];
                c.push(d);
              }
              c = new Qi[h.type](c, h.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              for (c = [], p = 0, f = h.shapes.length; p < f; p++)
                d = e[h.shapes[p]], c.push(d);
              p = h.options.extrudePath, p !== void 0 && (h.options.extrudePath = new Ha[p.type]().fromJSON(p)), c = new Qi[h.type](c, h.options);
              break;
            case "BufferGeometry":
              c = o.parse(h);
              break;
            case "Geometry":
              c = n.parse(h, this.resourcePath).geometry;
              break;
            default:
              console.warn(
                'THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"'
              );
              continue;
          }
          c.uuid = h.uuid, h.name !== void 0 && (c.name = h.name), c.isBufferGeometry === !0 && h.userData !== void 0 && (c.userData = h.userData), i[h.uuid] = c;
        }
      return i;
    },
    parseMaterials: function(t, e) {
      var i = {}, n = {};
      if (t !== void 0) {
        var o = new Da();
        o.setTextures(e), e = 0;
        for (var s = t.length; e < s; e++) {
          var l = t[e];
          if (l.type === "MultiMaterial") {
            for (var h = [], c = 0; c < l.materials.length; c++) {
              var p = l.materials[c];
              i[p.uuid] === void 0 && (i[p.uuid] = o.parse(p)), h.push(i[p.uuid]);
            }
            n[l.uuid] = h;
          } else
            n[l.uuid] = o.parse(l), i[l.uuid] = n[l.uuid];
        }
      }
      return n;
    },
    parseAnimations: function(t) {
      for (var e = [], i = 0; i < t.length; i++) {
        var n = t[i], o = Qn.parse(n);
        n.uuid !== void 0 && (o.uuid = n.uuid), e.push(o);
      }
      return e;
    },
    parseImages: function(t, e) {
      function i(v) {
        return n.manager.itemStart(v), s.load(
          v,
          function() {
            n.manager.itemEnd(v);
          },
          void 0,
          function() {
            n.manager.itemError(v), n.manager.itemEnd(v);
          }
        );
      }
      var n = this, o = {};
      if (t !== void 0 && 0 < t.length) {
        e = new vo(e);
        var s = new Ve(e);
        s.setCrossOrigin(this.crossOrigin), e = 0;
        for (var l = t.length; e < l; e++) {
          var h = t[e], c = h.url;
          if (Array.isArray(c)) {
            o[h.uuid] = [];
            for (var p = 0, f = c.length; p < f; p++) {
              var d = c[p];
              d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d, o[h.uuid].push(i(d));
            }
          } else
            d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : n.resourcePath + h.url, o[h.uuid] = i(d);
        }
      }
      return o;
    },
    parseTextures: function(t, e) {
      function i(c, p) {
        return typeof c == "number" ? c : (console.warn(
          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
          c
        ), p[c]);
      }
      var n = {};
      if (t !== void 0)
        for (var o = 0, s = t.length; o < s; o++) {
          var l = t[o];
          l.image === void 0 && console.warn(
            'THREE.ObjectLoader: No "image" specified for',
            l.uuid
          ), e[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
          var h = Array.isArray(e[l.image]) ? new A(e[l.image]) : new kt(e[l.image]);
          h.needsUpdate = !0, h.uuid = l.uuid, l.name !== void 0 && (h.name = l.name), l.mapping !== void 0 && (h.mapping = i(l.mapping, Hl)), l.offset !== void 0 && h.offset.fromArray(l.offset), l.repeat !== void 0 && h.repeat.fromArray(l.repeat), l.center !== void 0 && h.center.fromArray(l.center), l.rotation !== void 0 && (h.rotation = l.rotation), l.wrap !== void 0 && (h.wrapS = i(l.wrap[0], Cn), h.wrapT = i(l.wrap[1], Cn)), l.format !== void 0 && (h.format = l.format), l.minFilter !== void 0 && (h.minFilter = i(l.minFilter, ka)), l.magFilter !== void 0 && (h.magFilter = i(l.magFilter, ka)), l.anisotropy !== void 0 && (h.anisotropy = l.anisotropy), l.flipY !== void 0 && (h.flipY = l.flipY), n[l.uuid] = h;
        }
      return n;
    },
    parseObject: function(t, e, i) {
      function n(p) {
        return e[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), e[p];
      }
      function o(p) {
        if (p !== void 0) {
          if (Array.isArray(p)) {
            for (var f = [], d = 0, v = p.length; d < v; d++) {
              var w = p[d];
              i[w] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", w), f.push(i[w]);
            }
            return f;
          }
          return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p];
        }
      }
      switch (t.type) {
        case "Scene":
          var s = new An();
          t.background !== void 0 && Number.isInteger(t.background) && (s.background = new Y(t.background)), t.fog !== void 0 && (t.fog.type === "Fog" ? s.fog = new sn(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (s.fog = new de(t.fog.color, t.fog.density)));
          break;
        case "PerspectiveCamera":
          s = new ee(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (s.focus = t.focus), t.zoom !== void 0 && (s.zoom = t.zoom), t.filmGauge !== void 0 && (s.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (s.filmOffset = t.filmOffset), t.view !== void 0 && (s.view = Object.assign({}, t.view));
          break;
        case "OrthographicCamera":
          s = new Es(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (s.zoom = t.zoom), t.view !== void 0 && (s.view = Object.assign({}, t.view));
          break;
        case "AmbientLight":
          s = new jo(t.color, t.intensity);
          break;
        case "DirectionalLight":
          s = new Gr(t.color, t.intensity);
          break;
        case "PointLight":
          s = new Wo(t.color, t.intensity, t.distance, t.decay);
          break;
        case "RectAreaLight":
          s = new Ia(t.color, t.intensity, t.width, t.height);
          break;
        case "SpotLight":
          s = new ea(
            t.color,
            t.intensity,
            t.distance,
            t.angle,
            t.penumbra,
            t.decay
          );
          break;
        case "HemisphereLight":
          s = new Ks(t.color, t.groundColor, t.intensity);
          break;
        case "SkinnedMesh":
          console.warn(
            "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
          );
        case "Mesh":
          s = n(t.geometry);
          var l = o(t.material);
          s = s.bones && 0 < s.bones.length ? new Mi(s, l) : new Ui(s, l);
          break;
        case "LOD":
          s = new Hi();
          break;
        case "Line":
          s = new Pi(n(t.geometry), o(t.material), t.mode);
          break;
        case "LineLoop":
          s = new Or(n(t.geometry), o(t.material));
          break;
        case "LineSegments":
          s = new ti(n(t.geometry), o(t.material));
          break;
        case "PointCloud":
        case "Points":
          s = new cs(n(t.geometry), o(t.material));
          break;
        case "Sprite":
          s = new Gi(o(t.material));
          break;
        case "Group":
          s = new qe();
          break;
        default:
          s = new z();
      }
      if (s.uuid = t.uuid, t.name !== void 0 && (s.name = t.name), t.matrix !== void 0 ? (s.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (t.position !== void 0 && s.position.fromArray(t.position), t.rotation !== void 0 && s.rotation.fromArray(t.rotation), t.quaternion !== void 0 && s.quaternion.fromArray(t.quaternion), t.scale !== void 0 && s.scale.fromArray(t.scale)), t.castShadow !== void 0 && (s.castShadow = t.castShadow), t.receiveShadow !== void 0 && (s.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (s.shadow.bias = t.shadow.bias), t.shadow.radius !== void 0 && (s.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (s.visible = t.visible), t.frustumCulled !== void 0 && (s.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (s.renderOrder = t.renderOrder), t.userData !== void 0 && (s.userData = t.userData), t.layers !== void 0 && (s.layers.mask = t.layers), t.children !== void 0) {
        l = t.children;
        for (var h = 0; h < l.length; h++)
          s.add(this.parseObject(l[h], e, i));
      }
      if (t.type === "LOD")
        for (t = t.levels, l = 0; l < t.length; l++) {
          h = t[l];
          var c = s.getObjectByProperty("uuid", h.object);
          c !== void 0 && s.addLevel(c, h.distance);
        }
      return s;
    }
  });
  var Hl = {
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307
  }, Cn = {
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002
  }, ka = {
    NearestFilter: 1003,
    NearestMipMapNearestFilter: 1004,
    NearestMipMapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipMapNearestFilter: 1007,
    LinearMipMapLinearFilter: 1008
  };
  nl.prototype = {
    constructor: nl,
    setOptions: function(t) {
      return this.options = t, this;
    },
    load: function(t, e, i, n) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      var o = this, s = Vr.get(t);
      if (s !== void 0)
        return o.manager.itemStart(t), setTimeout(function() {
          e && e(s), o.manager.itemEnd(t);
        }, 0), s;
      fetch(t).then(function(l) {
        return l.blob();
      }).then(function(l) {
        return createImageBitmap(l, o.options);
      }).then(function(l) {
        Vr.add(t, l), e && e(l), o.manager.itemEnd(t);
      }).catch(function(l) {
        n && n(l), o.manager.itemError(t), o.manager.itemEnd(t);
      });
    },
    setCrossOrigin: function() {
      return this;
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }, Object.assign(za.prototype, {
    moveTo: function(t, e) {
      this.currentPath = new jn(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e);
    },
    lineTo: function(t, e) {
      this.currentPath.lineTo(t, e);
    },
    quadraticCurveTo: function(t, e, i, n) {
      this.currentPath.quadraticCurveTo(t, e, i, n);
    },
    bezierCurveTo: function(t, e, i, n, o, s) {
      this.currentPath.bezierCurveTo(t, e, i, n, o, s);
    },
    splineThru: function(t) {
      this.currentPath.splineThru(t);
    },
    toShapes: function(t, e) {
      function i(I) {
        for (var Q = [], W = 0, st = I.length; W < st; W++) {
          var K = I[W], wt = new Dn();
          wt.curves = K.curves, Q.push(wt);
        }
        return Q;
      }
      function n(I, Q) {
        for (var W = Q.length, st = !1, K = W - 1, wt = 0; wt < W; K = wt++) {
          var C = Q[K], D = Q[wt], ct = D.x - C.x, Dt = D.y - C.y;
          if (Math.abs(Dt) > Number.EPSILON) {
            if (0 > Dt && (C = Q[wt], ct = -ct, D = Q[K], Dt = -Dt), !(I.y < C.y || I.y > D.y))
              if (I.y === C.y) {
                if (I.x === C.x)
                  return !0;
              } else {
                if (K = Dt * (I.x - C.x) - ct * (I.y - C.y), K === 0)
                  return !0;
                0 > K || (st = !st);
              }
          } else if (I.y === C.y && (D.x <= I.x && I.x <= C.x || C.x <= I.x && I.x <= D.x))
            return !0;
        }
        return st;
      }
      var o = kr.isClockWise, s = this.subPaths;
      if (s.length === 0)
        return [];
      if (e === !0)
        return i(s);
      if (e = [], s.length === 1) {
        var l = s[0], h = new Dn();
        return h.curves = l.curves, e.push(h), e;
      }
      var c = !o(s[0].getPoints());
      c = t ? !c : c, h = [];
      var p = [], f = [], d = 0;
      p[d] = void 0, f[d] = [];
      for (var v = 0, w = s.length; v < w; v++) {
        l = s[v];
        var P = l.getPoints(), R = o(P);
        (R = t ? !R : R) ? (!c && p[d] && d++, p[d] = { s: new Dn(), p: P }, p[d].s.curves = l.curves, c && d++, f[d] = []) : f[d].push({ h: l, p: P[0] });
      }
      if (!p[0])
        return i(s);
      if (1 < p.length) {
        for (v = !1, t = [], o = 0, s = p.length; o < s; o++)
          h[o] = [];
        for (o = 0, s = p.length; o < s; o++)
          for (l = f[o], R = 0; R < l.length; R++) {
            for (c = l[R], d = !0, P = 0; P < p.length; P++)
              n(c.p, p[P].p) && (o !== P && t.push({ froms: o, tos: P, hole: R }), d ? (d = !1, h[P].push(c)) : v = !0);
            d && h[o].push(c);
          }
        0 < t.length && (v || (f = h));
      }
      for (v = 0, o = p.length; v < o; v++)
        for (h = p[v].s, e.push(h), t = f[v], s = 0, l = t.length; s < l; s++)
          h.holes.push(t[s].h);
      return e;
    }
  }), Object.assign(rl.prototype, {
    isFont: !0,
    generateShapes: function(t, e) {
      e === void 0 && (e = 100);
      var i = [], n = e;
      e = this.data;
      var o = Array.from ? Array.from(t) : String(t).split("");
      n /= e.resolution;
      var s = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
      t = [];
      for (var l = 0, h = 0, c = 0; c < o.length; c++) {
        var p = o[c];
        if (p === `
`)
          l = 0, h -= s;
        else {
          var f = n, d = l, v = h;
          if (p = e.glyphs[p] || e.glyphs["?"]) {
            var w = new za();
            if (p.o)
              for (var P = p._cachedOutline || (p._cachedOutline = p.o.split(" ")), R = 0, I = P.length; R < I; )
                switch (P[R++]) {
                  case "m":
                    var Q = P[R++] * f + d, W = P[R++] * f + v;
                    w.moveTo(Q, W);
                    break;
                  case "l":
                    Q = P[R++] * f + d, W = P[R++] * f + v, w.lineTo(Q, W);
                    break;
                  case "q":
                    var st = P[R++] * f + d, K = P[R++] * f + v, wt = P[R++] * f + d, C = P[R++] * f + v;
                    w.quadraticCurveTo(wt, C, st, K);
                    break;
                  case "b":
                    st = P[R++] * f + d, K = P[R++] * f + v, wt = P[R++] * f + d, C = P[R++] * f + v, Q = P[R++] * f + d, W = P[R++] * f + v, w.bezierCurveTo(wt, C, Q, W, st, K);
                }
            f = { offsetX: p.ha * f, path: w };
          } else
            f = void 0;
          l += f.offsetX, t.push(f.path);
        }
      }
      for (e = 0, o = t.length; e < o; e++)
        Array.prototype.push.apply(i, t[e].toShapes());
      return i;
    }
  }), Object.assign(bl.prototype, {
    load: function(t, e, i, n) {
      var o = this, s = new lt(this.manager);
      s.setPath(this.path), s.load(
        t,
        function(l) {
          try {
            var h = JSON.parse(l);
          } catch {
            console.warn(
              "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
            ), h = JSON.parse(l.substring(65, l.length - 2));
          }
          l = o.parse(h), e && e(l);
        },
        i,
        n
      );
    },
    parse: function(t) {
      return new rl(t);
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  });
  var Va, ml = {
    getContext: function() {
      return Va === void 0 && (Va = new (window.AudioContext || window.webkitAudioContext)()), Va;
    },
    setContext: function(t) {
      Va = t;
    }
  };
  Object.assign($i.prototype, {
    load: function(t, e, i, n) {
      var o = new lt(this.manager);
      o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(
        t,
        function(s) {
          s = s.slice(0), ml.getContext().decodeAudioData(s, function(l) {
            e(l);
          });
        },
        i,
        n
      );
    },
    setPath: function(t) {
      return this.path = t, this;
    }
  }), Object.assign(Sn.prototype, {
    update: function() {
      var t, e, i, n, o, s, l, h, c = new pt(), p = new pt();
      return function(f) {
        if (t !== this || e !== f.focus || i !== f.fov || n !== f.aspect * this.aspect || o !== f.near || s !== f.far || l !== f.zoom || h !== this.eyeSep) {
          t = this, e = f.focus, i = f.fov, n = f.aspect * this.aspect, o = f.near, s = f.far, l = f.zoom;
          var d = f.projectionMatrix.clone();
          h = this.eyeSep / 2;
          var v = h * o / e, w = o * Math.tan(Je.DEG2RAD * i * 0.5) / l;
          p.elements[12] = -h, c.elements[12] = h;
          var P = -w * n + v, R = w * n + v;
          d.elements[0] = 2 * o / (R - P), d.elements[8] = (R + P) / (R - P), this.cameraL.projectionMatrix.copy(d), P = -w * n - v, R = w * n - v, d.elements[0] = 2 * o / (R - P), d.elements[8] = (R + P) / (R - P), this.cameraR.projectionMatrix.copy(d);
        }
        this.cameraL.matrixWorld.copy(f.matrixWorld).multiply(p), this.cameraR.matrixWorld.copy(f.matrixWorld).multiply(c);
      };
    }()
  }), na.prototype = Object.create(z.prototype), na.prototype.constructor = na, Object.assign(ol.prototype, {
    start: function() {
      this.oldTime = this.startTime = (typeof performance > "u" ? Date : performance).now(), this.elapsedTime = 0, this.running = !0;
    },
    stop: function() {
      this.getElapsedTime(), this.autoStart = this.running = !1;
    },
    getElapsedTime: function() {
      return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
      var t = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        var e = (typeof performance > "u" ? Date : performance).now();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }
      return t;
    }
  }), Na.prototype = Object.assign(Object.create(z.prototype), {
    constructor: Na,
    getInput: function() {
      return this.gain;
    },
    removeFilter: function() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    },
    getFilter: function() {
      return this.filter;
    },
    setFilter: function(t) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    },
    getMasterVolume: function() {
      return this.gain.gain.value;
    },
    setMasterVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    },
    updateMatrixWorld: function() {
      var t = new S(), e = new gt(), i = new S(), n = new S(), o = new ol();
      return function(s) {
        z.prototype.updateMatrixWorld.call(this, s), s = this.context.listener;
        var l = this.up;
        if (this.timeDelta = o.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), s.positionX) {
          var h = this.context.currentTime + this.timeDelta;
          s.positionX.linearRampToValueAtTime(t.x, h), s.positionY.linearRampToValueAtTime(t.y, h), s.positionZ.linearRampToValueAtTime(t.z, h), s.forwardX.linearRampToValueAtTime(n.x, h), s.forwardY.linearRampToValueAtTime(n.y, h), s.forwardZ.linearRampToValueAtTime(n.z, h), s.upX.linearRampToValueAtTime(l.x, h), s.upY.linearRampToValueAtTime(l.y, h), s.upZ.linearRampToValueAtTime(l.z, h);
        } else
          s.setPosition(t.x, t.y, t.z), s.setOrientation(n.x, n.y, n.z, l.x, l.y, l.z);
      };
    }()
  }), As.prototype = Object.assign(Object.create(z.prototype), {
    constructor: As,
    getOutput: function() {
      return this.gain;
    },
    setNodeSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    },
    setMediaElementSource: function(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    },
    setBuffer: function(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    },
    play: function() {
      if (this.isPlaying === !0)
        console.warn("THREE.Audio: Audio is already playing.");
      else if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else {
        var t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect();
      }
    },
    pause: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.isPlaying === !0 && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
    },
    stop: function() {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
    },
    connect: function() {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this;
    },
    disconnect: function() {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this;
    },
    getFilters: function() {
      return this.filters;
    },
    setFilters: function(t) {
      return t || (t = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this;
    },
    getFilter: function() {
      return this.getFilters()[0];
    },
    setFilter: function(t) {
      return this.setFilters(t ? [t] : []);
    },
    setPlaybackRate: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(
          this.playbackRate,
          this.context.currentTime
        ), this;
    },
    getPlaybackRate: function() {
      return this.playbackRate;
    },
    onEnded: function() {
      this.isPlaying = !1;
    },
    getLoop: function() {
      return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    },
    setLoop: function(t) {
      if (this.hasPlaybackControl === !1)
        console.warn("THREE.Audio: this Audio has no playback control.");
      else
        return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    },
    getVolume: function() {
      return this.gain.gain.value;
    },
    setVolume: function(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    }
  }), ra.prototype = Object.assign(Object.create(As.prototype), {
    constructor: ra,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(t) {
      return this.panner.refDistance = t, this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(t) {
      return this.panner.rolloffFactor = t, this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(t) {
      return this.panner.distanceModel = t, this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(t) {
      return this.panner.maxDistance = t, this;
    },
    setDirectionalCone: function(t, e, i) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this;
    },
    updateMatrixWorld: function() {
      var t = new S(), e = new gt(), i = new S(), n = new S();
      return function(o) {
        if (z.prototype.updateMatrixWorld.call(this, o), o = this.panner, this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), o.positionX) {
          var s = this.context.currentTime + this.listener.timeDelta;
          o.positionX.linearRampToValueAtTime(t.x, s), o.positionY.linearRampToValueAtTime(t.y, s), o.positionZ.linearRampToValueAtTime(t.z, s), o.orientationX.linearRampToValueAtTime(n.x, s), o.orientationY.linearRampToValueAtTime(n.y, s), o.orientationZ.linearRampToValueAtTime(n.z, s);
        } else
          o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z);
      };
    }()
  }), Object.assign(qo.prototype, {
    getFrequencyData: function() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    },
    getAverageFrequency: function() {
      for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)
        t += e[i];
      return t / e.length;
    }
  }), Object.assign(oa.prototype, {
    accumulate: function(t, e) {
      var i = this.buffer, n = this.valueSize;
      t = t * n + n;
      var o = this.cumulativeWeight;
      if (o === 0) {
        for (o = 0; o !== n; ++o)
          i[t + o] = i[o];
        o = e;
      } else
        o += e, this._mixBufferRegion(i, t, 0, e / o, n);
      this.cumulativeWeight = o;
    },
    apply: function(t) {
      var e = this.valueSize, i = this.buffer;
      t = t * e + e;
      var n = this.cumulativeWeight, o = this.binding;
      this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e;
      for (var s = e + e; n !== s; ++n)
        if (i[n] !== i[n + e]) {
          o.setValue(i, t);
          break;
        }
    },
    saveOriginalState: function() {
      var t = this.buffer, e = this.valueSize, i = 3 * e;
      this.binding.getValue(t, i);
      for (var n = e; n !== i; ++n)
        t[n] = t[i + n % e];
      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
      this.binding.setValue(this.buffer, 3 * this.valueSize);
    },
    _select: function(t, e, i, n, o) {
      if (0.5 <= n)
        for (n = 0; n !== o; ++n)
          t[e + n] = t[i + n];
    },
    _slerp: function(t, e, i, n) {
      gt.slerpFlat(t, e, t, e, t, i, n);
    },
    _lerp: function(t, e, i, n, o) {
      for (var s = 1 - n, l = 0; l !== o; ++l) {
        var h = e + l;
        t[h] = t[h] * s + t[i + l] * n;
      }
    }
  }), Object.assign(Yo.prototype, {
    getValue: function(t, e) {
      this.bind();
      var i = this._bindings[this._targetGroup.nCachedObjects_];
      i !== void 0 && i.getValue(t, e);
    },
    setValue: function(t, e) {
      for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, o = i.length; n !== o; ++n)
        i[n].setValue(t, e);
    },
    bind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].bind();
    },
    unbind: function() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].unbind();
    }
  }), Object.assign(an, {
    Composite: Yo,
    create: function(t, e, i) {
      return t && t.isAnimationObjectGroup ? new an.Composite(t, e, i) : new an(t, e, i);
    },
    sanitizeNodeName: function() {
      var t = /[\[\]\.:\/]/g;
      return function(e) {
        return e.replace(/\s/g, "_").replace(t, "");
      };
    }(),
    parseTrackName: function() {
      var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
      t = /(WCOD+)?/.source.replace("WCOD", t);
      var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
        "WC",
        "[^\\[\\]\\.:\\/]"
      ), n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), o = new RegExp("^" + e + t + i + n + "$"), s = ["material", "materials", "bones"];
      return function(l) {
        var h = o.exec(l);
        if (!h)
          throw Error("PropertyBinding: Cannot parse trackName: " + l);
        h = {
          nodeName: h[2],
          objectName: h[3],
          objectIndex: h[4],
          propertyName: h[5],
          propertyIndex: h[6]
        };
        var c = h.nodeName && h.nodeName.lastIndexOf(".");
        if (c !== void 0 && c !== -1) {
          var p = h.nodeName.substring(c + 1);
          s.indexOf(p) !== -1 && (h.nodeName = h.nodeName.substring(0, c), h.objectName = p);
        }
        if (h.propertyName === null || h.propertyName.length === 0)
          throw Error(
            "PropertyBinding: can not parse propertyName from trackName: " + l
          );
        return h;
      };
    }(),
    findNode: function(t, e) {
      if (!e || e === "" || e === "root" || e === "." || e === -1 || e === t.name || e === t.uuid)
        return t;
      if (t.skeleton) {
        var i = t.skeleton.getBoneByName(e);
        if (i !== void 0)
          return i;
      }
      if (t.children) {
        var n = function(o) {
          for (var s = 0; s < o.length; s++) {
            var l = o[s];
            if (l.name === e || l.uuid === e || (l = n(l.children)))
              return l;
          }
          return null;
        };
        if (t = n(t.children))
          return t;
      }
      return null;
    }
  }), Object.assign(an.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
    GetterByBindingType: [
      function(t, e) {
        t[e] = this.node[this.propertyName];
      },
      function(t, e) {
        for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
          t[e++] = i[n];
      },
      function(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      },
      function(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function(t, e) {
          this.targetObject[this.propertyName] = t[e];
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
          this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          for (var i = this.resolvedProperty, n = 0, o = i.length; n !== o; ++n)
            i[n] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ],
      [
        function(t, e) {
          this.resolvedProperty.fromArray(t, e);
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
        },
        function(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
      ]
    ],
    getValue: function(t, e) {
      this.bind(), this.getValue(t, e);
    },
    setValue: function(t, e) {
      this.bind(), this.setValue(t, e);
    },
    bind: function() {
      var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, o = e.propertyIndex;
      if (t || (this.node = t = an.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
        if (i) {
          var s = e.objectIndex;
          switch (i) {
            case "materials":
              if (!t.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!t.material.materials) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
                return;
              }
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
                return;
              }
              for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                if (t[i].name === s) {
                  s = i;
                  break;
                }
              break;
            default:
              if (t[i] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
                return;
              }
              t = t[i];
          }
          if (s !== void 0) {
            if (t[s] === void 0) {
              console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                t
              );
              return;
            }
            t = t[s];
          }
        }
        if (s = t[n], s === void 0)
          console.error(
            "THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.",
            t
          );
        else {
          if (e = this.Versioning.None, this.targetObject = t, t.needsUpdate !== void 0 ? e = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, o !== void 0) {
            if (n === "morphTargetInfluences") {
              if (!t.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (t.geometry.isBufferGeometry) {
                if (!t.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                  if (t.geometry.morphAttributes.position[i].name === o) {
                    o = i;
                    break;
                  }
              } else {
                if (!t.geometry.morphTargets) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                    this
                  );
                  return;
                }
                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                  if (t.geometry.morphTargets[i].name === o) {
                    o = i;
                    break;
                  }
              }
            }
            i = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = o;
          } else
            s.fromArray !== void 0 && s.toArray !== void 0 ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (i = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e];
        }
      } else
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."
        );
    },
    unbind: function() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }), Object.assign(an.prototype, {
    _getValue_unbound: an.prototype.getValue,
    _setValue_unbound: an.prototype.setValue
  }), Object.assign(Ps.prototype, {
    isAnimationObjectGroup: !0,
    add: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._paths, s = this._parsedPaths, l = this._bindings, h = l.length, c = void 0, p = 0, f = arguments.length; p !== f; ++p) {
        var d = arguments[p], v = d.uuid, w = n[v];
        if (w === void 0) {
          w = e++, n[v] = w, t.push(d), v = 0;
          for (var P = h; v !== P; ++v)
            l[v].push(new an(d, o[v], s[v]));
        } else if (w < i) {
          c = t[w];
          var R = --i;
          for (P = t[R], n[P.uuid] = w, t[w] = P, n[v] = R, t[R] = d, v = 0, P = h; v !== P; ++v) {
            var I = l[v], Q = I[w];
            I[w] = I[R], Q === void 0 && (Q = new an(d, o[v], s[v])), I[R] = Q;
          }
        } else
          t[w] !== c && console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
      }
      this.nCachedObjects_ = i;
    },
    remove: function() {
      for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, o = n.length, s = 0, l = arguments.length; s !== l; ++s) {
        var h = arguments[s], c = h.uuid, p = i[c];
        if (p !== void 0 && p >= e) {
          var f = e++, d = t[f];
          for (i[d.uuid] = p, t[p] = d, i[c] = f, t[f] = h, h = 0, c = o; h !== c; ++h) {
            d = n[h];
            var v = d[p];
            d[p] = d[f], d[f] = v;
          }
        }
      }
      this.nCachedObjects_ = e;
    },
    uncache: function() {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, o = this._bindings, s = o.length, l = 0, h = arguments.length; l !== h; ++l) {
        var c = arguments[l].uuid, p = n[c];
        if (p !== void 0)
          if (delete n[c], p < i) {
            c = --i;
            var f = t[c], d = --e, v = t[d];
            for (n[f.uuid] = p, t[p] = f, n[v.uuid] = c, t[c] = v, t.pop(), f = 0, v = s; f !== v; ++f) {
              var w = o[f], P = w[d];
              w[p] = w[c], w[c] = P, w.pop();
            }
          } else
            for (d = --e, v = t[d], n[v.uuid] = p, t[p] = v, t.pop(), f = 0, v = s; f !== v; ++f)
              w = o[f], w[p] = w[d], w.pop();
      }
      this.nCachedObjects_ = i;
    },
    subscribe_: function(t, e) {
      var i = this._bindingsIndicesByPath, n = i[t], o = this._bindings;
      if (n !== void 0)
        return o[n];
      var s = this._paths, l = this._parsedPaths, h = this._objects, c = this.nCachedObjects_, p = Array(h.length);
      for (n = o.length, i[t] = n, s.push(t), l.push(e), o.push(p), i = c, n = h.length; i !== n; ++i)
        p[i] = new an(h[i], t, e);
      return p;
    },
    unsubscribe_: function(t) {
      var e = this._bindingsIndicesByPath, i = e[t];
      if (i !== void 0) {
        var n = this._paths, o = this._parsedPaths, s = this._bindings, l = s.length - 1, h = s[l];
        e[t[l]] = i, s[i] = h, s.pop(), o[i] = o[l], o.pop(), n[i] = n[l], n.pop();
      }
    }
  }), Object.assign(sa.prototype, {
    play: function() {
      return this._mixer._activateAction(this), this;
    },
    stop: function() {
      return this._mixer._deactivateAction(this), this.reset();
    },
    reset: function() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    },
    isRunning: function() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(t) {
      return this._startTime = t, this;
    },
    setLoop: function(t, e) {
      return this.loop = t, this.repetitions = e, this;
    },
    setEffectiveWeight: function(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(t) {
      return this._scheduleFading(t, 0, 1);
    },
    fadeOut: function(t) {
      return this._scheduleFading(t, 1, 0);
    },
    crossFadeFrom: function(t, e, i) {
      if (t.fadeOut(e), this.fadeIn(e), i) {
        i = this._clip.duration;
        var n = t._clip.duration, o = i / n;
        t.warp(1, n / i, e), this.warp(o, 1, e);
      }
      return this;
    },
    crossFadeTo: function(t, e, i) {
      return t.crossFadeFrom(this, e, i);
    },
    stopFading: function() {
      var t = this._weightInterpolant;
      return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    setEffectiveTimeScale: function(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    },
    syncWith: function(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    },
    halt: function(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    },
    warp: function(t, e, i) {
      var n = this._mixer, o = n.time, s = this._timeScaleInterpolant, l = this.timeScale;
      return s === null && (this._timeScaleInterpolant = s = n._lendControlInterpolant()), n = s.parameterPositions, s = s.sampleValues, n[0] = o, n[1] = o + i, s[0] = t / l, s[1] = e / l, this;
    },
    stopWarping: function() {
      var t = this._timeScaleInterpolant;
      return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(t, e, i, n) {
      if (this.enabled) {
        var o = this._startTime;
        if (o !== null) {
          if (e = (t - o) * i, 0 > e || i === 0)
            return;
          this._startTime = null, e *= i;
        }
        if (e *= this._updateTimeScale(t), i = this._updateTime(e), t = this._updateWeight(t), 0 < t) {
          e = this._interpolants, o = this._propertyBindings;
          for (var s = 0, l = e.length; s !== l; ++s)
            e[s].evaluate(i), o[s].accumulate(n, t);
        }
      } else
        this._updateWeight(t);
    },
    _updateWeight: function(t) {
      var e = 0;
      if (this.enabled) {
        e = this.weight;
        var i = this._weightInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
        }
      }
      return this._effectiveWeight = e;
    },
    _updateTimeScale: function(t) {
      var e = 0;
      if (!this.paused) {
        e = this.timeScale;
        var i = this._timeScaleInterpolant;
        if (i !== null) {
          var n = i.evaluate(t)[0];
          e *= n, t > i.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
        }
      }
      return this._effectiveTimeScale = e;
    },
    _updateTime: function(t) {
      var e = this.time + t, i = this._clip.duration, n = this.loop, o = this._loopCount, s = n === 2202;
      if (t === 0)
        return o === -1 ? e : s && (o & 1) === 1 ? i - e : e;
      if (n === 2200)
        t: {
          if (o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i)
            e = i;
          else if (0 > e)
            e = 0;
          else
            break t;
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 > t ? -1 : 1
          });
        }
      else {
        if (o === -1 && (0 <= t ? (o = 0, this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)), e >= i || 0 > e) {
          n = Math.floor(e / i), e -= i * n, o += Math.abs(n);
          var l = this.repetitions - o;
          0 >= l ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 < t ? 1 : -1
          })) : (l === 1 ? (t = 0 > t, this._setEndings(t, !t, s)) : this._setEndings(!1, !1, s), this._loopCount = o, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: n
          }));
        }
        if (s && (o & 1) === 1)
          return this.time = e, i - e;
      }
      return this.time = e;
    },
    _setEndings: function(t, e, i) {
      var n = this._interpolantSettings;
      i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    },
    _scheduleFading: function(t, e, i) {
      var n = this._mixer, o = n.time, s = this._weightInterpolant;
      return s === null && (this._weightInterpolant = s = n._lendControlInterpolant()), n = s.parameterPositions, s = s.sampleValues, n[0] = o, s[0] = e, n[1] = o + t, s[1] = i, this;
    }
  }), xo.prototype = Object.assign(Object.create($.prototype), {
    constructor: xo,
    _bindAction: function(t, e) {
      var i = t._localRoot || this._root, n = t._clip.tracks, o = n.length, s = t._propertyBindings;
      t = t._interpolants;
      var l = i.uuid, h = this._bindingsByRootAndName, c = h[l];
      for (c === void 0 && (c = {}, h[l] = c), h = 0; h !== o; ++h) {
        var p = n[h], f = p.name, d = c[f];
        if (d === void 0) {
          if (d = s[h], d !== void 0) {
            d._cacheIndex === null && (++d.referenceCount, this._addInactiveBinding(d, l, f));
            continue;
          }
          d = new oa(
            an.create(i, f, e && e._propertyBindings[h].binding.parsedPath),
            p.ValueTypeName,
            p.getValueSize()
          ), ++d.referenceCount, this._addInactiveBinding(d, l, f);
        }
        s[h] = d, t[h].resultBuffer = d.buffer;
      }
    },
    _activateAction: function(t) {
      if (!this._isActiveAction(t)) {
        if (t._cacheIndex === null) {
          var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
          this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
        }
        for (e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var o = e[i];
          o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
        }
        this._lendAction(t);
      }
    },
    _deactivateAction: function(t) {
      if (this._isActiveAction(t)) {
        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var o = e[i];
          --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
        }
        this._takeBackAction(t);
      }
    },
    _initMemoryManager: function() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },
          get inUse() {
            return t._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return t._bindings.length;
          },
          get inUse() {
            return t._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },
          get inUse() {
            return t._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(t) {
      return t = t._cacheIndex, t !== null && t < this._nActiveActions;
    },
    _addInactiveAction: function(t, e, i) {
      var n = this._actions, o = this._actionsByClip, s = o[e];
      s === void 0 ? (s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, o[e] = s) : (e = s.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t;
    },
    _removeInactiveAction: function(t) {
      var e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
      i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid, i = this._actionsByClip, n = i[e];
      var o = n.knownActions, s = o[o.length - 1], l = t._byClipCacheIndex;
      s._byClipCacheIndex = l, o[l] = s, o.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], o.length === 0 && delete i[e], this._removeInactiveBindingsForAction(t);
    },
    _removeInactiveBindingsForAction: function(t) {
      t = t._propertyBindings;
      for (var e = 0, i = t.length; e !== i; ++e) {
        var n = t[e];
        --n.referenceCount === 0 && this._removeInactiveBinding(n);
      }
    },
    _lendAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _takeBackAction: function(t) {
      var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _addInactiveBinding: function(t, e, i) {
      var n = this._bindingsByRootAndName, o = n[e], s = this._bindings;
      o === void 0 && (o = {}, n[e] = o), o[i] = t, t._cacheIndex = s.length, s.push(t);
    },
    _removeInactiveBinding: function(t) {
      var e = this._bindings, i = t.binding, n = i.rootNode.uuid;
      i = i.path;
      var o = this._bindingsByRootAndName, s = o[n], l = e[e.length - 1];
      t = t._cacheIndex, l._cacheIndex = t, e[t] = l, e.pop(), delete s[i];
      t: {
        for (var h in s)
          break t;
        delete o[n];
      }
    },
    _lendBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _takeBackBinding: function(t) {
      var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, o = e[n];
      t._cacheIndex = n, e[n] = t, o._cacheIndex = i, e[i] = o;
    },
    _lendControlInterpolant: function() {
      var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
      return i === void 0 && (i = new hr(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      ), i.__cacheIndex = e, t[e] = i), i;
    },
    _takeBackControlInterpolant: function(t) {
      var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, o = e[n];
      t.__cacheIndex = n, e[n] = t, o.__cacheIndex = i, e[i] = o;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(t, e) {
      var i = e || this._root, n = i.uuid;
      i = typeof t == "string" ? Qn.findByName(i, t) : t, t = i !== null ? i.uuid : t;
      var o = this._actionsByClip[t], s = null;
      if (o !== void 0) {
        if (s = o.actionByRoot[n], s !== void 0)
          return s;
        s = o.knownActions[0], i === null && (i = s._clip);
      }
      return i === null ? null : (e = new sa(this, i, e), this._bindAction(e, s), this._addInactiveAction(e, t, n), e);
    },
    existingAction: function(t, e) {
      var i = e || this._root;
      return e = i.uuid, i = typeof t == "string" ? Qn.findByName(i, t) : t, t = this._actionsByClip[i ? i.uuid : t], t !== void 0 && t.actionByRoot[e] || null;
    },
    stopAllAction: function() {
      for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, o = this._nActiveBindings = this._nActiveActions = 0; o !== e; ++o)
        t[o].reset();
      for (o = 0; o !== n; ++o)
        i[o].useCount = 0;
      return this;
    },
    update: function(t) {
      t *= this.timeScale;
      for (var e = this._actions, i = this._nActiveActions, n = this.time += t, o = Math.sign(t), s = this._accuIndex ^= 1, l = 0; l !== i; ++l)
        e[l]._update(n, t, o, s);
      for (t = this._bindings, e = this._nActiveBindings, l = 0; l !== e; ++l)
        t[l].apply(s);
      return this;
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(t) {
      var e = this._actions;
      t = t.uuid;
      var i = this._actionsByClip, n = i[t];
      if (n !== void 0) {
        n = n.knownActions;
        for (var o = 0, s = n.length; o !== s; ++o) {
          var l = n[o];
          this._deactivateAction(l);
          var h = l._cacheIndex, c = e[e.length - 1];
          l._cacheIndex = null, l._byClipCacheIndex = null, c._cacheIndex = h, e[h] = c, e.pop(), this._removeInactiveBindingsForAction(l);
        }
        delete i[t];
      }
    },
    uncacheRoot: function(t) {
      t = t.uuid;
      var e = this._actionsByClip;
      for (n in e) {
        var i = e[n].actionByRoot[t];
        i !== void 0 && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
      var n = this._bindingsByRootAndName[t];
      if (n !== void 0)
        for (var o in n)
          t = n[o], t.restoreOriginalState(), this._removeInactiveBinding(t);
    },
    uncacheAction: function(t, e) {
      t = this.existingAction(t, e), t !== null && (this._deactivateAction(t), this._removeInactiveAction(t));
    }
  }), Ba.prototype.clone = function() {
    return new Ba(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }, sl.prototype = Object.assign(Object.create(Ft.prototype), {
    constructor: sl,
    isInstancedBufferGeometry: !0,
    copy: function(t) {
      return Ft.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  }), al.prototype = Object.assign(Object.create(gi.prototype), {
    constructor: al,
    isInstancedInterleavedBuffer: !0,
    copy: function(t) {
      return gi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), ll.prototype = Object.assign(Object.create(it.prototype), {
    constructor: ll,
    isInstancedBufferAttribute: !0,
    copy: function(t) {
      return it.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }), Object.assign(Ol.prototype, {
    linePrecision: 1,
    set: function(t, e) {
      this.ray.set(t, e);
    },
    setFromCamera: function(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
    },
    intersectObject: function(t, e, i) {
      return i = i || [], Zo(t, this, i, e), i.sort(aa), i;
    },
    intersectObjects: function(t, e, i) {
      if (i = i || [], Array.isArray(t) === !1)
        return console.warn(
          "THREE.Raycaster.intersectObjects: objects is not an Array."
        ), i;
      for (var n = 0, o = t.length; n < o; n++)
        Zo(t[n], this, i, e);
      return i.sort(aa), i;
    }
  }), Object.assign(hl.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.phi = e, this.theta = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    },
    makeSafe: function() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + e * e + i * i), this.radius === 0 ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(Je.clamp(e / this.radius, -1, 1))), this;
    }
  }), Object.assign(O.prototype, {
    set: function(t, e, i) {
      return this.radius = t, this.theta = e, this.y = i, this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    },
    setFromVector3: function(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    },
    setFromCartesianCoords: function(t, e, i) {
      return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this;
    }
  }), Object.assign(wo.prototype, {
    set: function(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromPoints: function(t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function() {
      var t = new y();
      return function(e, i) {
        return i = t.copy(i).multiplyScalar(0.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new y()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(t) {
      return t === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), t = new y()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    },
    expandByPoint: function(t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function(t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    containsPoint: function(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    },
    containsBox: function(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    },
    getParameter: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new y()), e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y)
      );
    },
    intersectsBox: function(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    },
    clampPoint: function(t, e) {
      return e === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new y()), e.copy(t).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var t = new y();
      return function(e) {
        return t.copy(e).clamp(this.min, this.max).sub(e).length();
      };
    }(),
    intersect: function(t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    },
    union: function(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    translate: function(t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }), Object.assign(Ls.prototype, {
    set: function(t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    },
    getCenter: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new S()), t.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(t) {
      return t === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), t = new S()), t.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(t, e) {
      return e === void 0 && (console.warn("THREE.Line3: .at() target is now required"), e = new S()), this.delta(e).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
      var t = new S(), e = new S();
      return function(i, n) {
        return t.subVectors(i, this.start), e.subVectors(this.end, this.start), i = e.dot(e), i = e.dot(t) / i, n && (i = Je.clamp(i, 0, 1)), i;
      };
    }(),
    closestPointToPoint: function(t, e, i) {
      return t = this.closestPointToPointParameter(t, e), i === void 0 && (console.warn(
        "THREE.Line3: .closestPointToPoint() target is now required"
      ), i = new S()), this.delta(i).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    },
    equals: function(t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }
  }), Pn.prototype = Object.create(z.prototype), Pn.prototype.constructor = Pn, Pn.prototype.isImmediateRenderObject = !0, ni.prototype = Object.create(ti.prototype), ni.prototype.constructor = ni, ni.prototype.update = function() {
    var t = new S(), e = new S(), i = new Mt();
    return function() {
      var n = ["a", "b", "c"];
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var o = this.object.matrixWorld, s = this.geometry.attributes.position, l = this.object.geometry;
      if (l && l.isGeometry)
        for (var h = l.vertices, c = l.faces, p = l = 0, f = c.length; p < f; p++)
          for (var d = c[p], v = 0, w = d.vertexNormals.length; v < w; v++) {
            var P = d.vertexNormals[v];
            t.copy(h[d[n[v]]]).applyMatrix4(o), e.copy(P).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1;
          }
      else if (l && l.isBufferGeometry)
        for (n = l.attributes.position, h = l.attributes.normal, v = l = 0, w = n.count; v < w; v++)
          t.set(n.getX(v), n.getY(v), n.getZ(v)).applyMatrix4(o), e.set(h.getX(v), h.getY(v), h.getZ(v)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), s.setXYZ(l, t.x, t.y, t.z), l += 1, s.setXYZ(l, e.x, e.y, e.z), l += 1;
      s.needsUpdate = !0;
    };
  }(), Cs.prototype = Object.create(z.prototype), Cs.prototype.constructor = Cs, Cs.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }, Cs.prototype.update = function() {
    var t = new S(), e = new S();
    return function() {
      this.light.updateMatrixWorld();
      var i = this.light.distance ? this.light.distance : 1e3, n = i * Math.tan(this.light.angle);
      this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    };
  }(), Rs.prototype = Object.create(ti.prototype), Rs.prototype.constructor = Rs, Rs.prototype.updateMatrixWorld = function() {
    var t = new S(), e = new pt(), i = new pt();
    return function(n) {
      var o = this.bones, s = this.geometry, l = s.getAttribute("position");
      i.getInverse(this.root.matrixWorld);
      for (var h = 0, c = 0; h < o.length; h++) {
        var p = o[h];
        p.parent && p.parent.isBone && (e.multiplyMatrices(i, p.matrixWorld), t.setFromMatrixPosition(e), l.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(i, p.parent.matrixWorld), t.setFromMatrixPosition(e), l.setXYZ(c + 1, t.x, t.y, t.z), c += 2);
      }
      s.getAttribute("position").needsUpdate = !0, z.prototype.updateMatrixWorld.call(this, n);
    };
  }(), cr.prototype = Object.create(Ui.prototype), cr.prototype.constructor = cr, cr.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
  }, cr.prototype.update = function() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }, bs.prototype = Object.create(z.prototype), bs.prototype.constructor = bs, bs.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, bs.prototype.update = function() {
    var t = 0.5 * this.light.width, e = 0.5 * this.light.height, i = this.line.geometry.attributes.position, n = i.array;
    n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, this.color !== void 0 ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
  }, Os.prototype = Object.create(z.prototype), Os.prototype.constructor = Os, Os.prototype.dispose = function() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }, Os.prototype.update = function() {
    var t = new S(), e = new Y(), i = new Y();
    return function() {
      var n = this.children[0];
      if (this.color !== void 0)
        this.material.color.set(this.color);
      else {
        var o = n.geometry.getAttribute("color");
        e.copy(this.light.color), i.copy(this.light.groundColor);
        for (var s = 0, l = o.count; s < l; s++) {
          var h = s < l / 2 ? e : i;
          o.setXYZ(s, h.r, h.g, h.b);
        }
        o.needsUpdate = !0;
      }
      n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }(), la.prototype = Object.create(ti.prototype), la.prototype.constructor = la, Ua.prototype = Object.create(ti.prototype), Ua.prototype.constructor = Ua, ha.prototype = Object.create(ti.prototype), ha.prototype.constructor = ha, ha.prototype.update = function() {
    var t = new S(), e = new S(), i = new Mt();
    return function() {
      this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
      var n = this.object.matrixWorld, o = this.geometry.attributes.position, s = this.object.geometry, l = s.vertices;
      s = s.faces;
      for (var h = 0, c = 0, p = s.length; c < p; c++) {
        var f = s[c], d = f.normal;
        t.copy(l[f.a]).add(l[f.b]).add(l[f.c]).divideScalar(3).applyMatrix4(n), e.copy(d).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(h, t.x, t.y, t.z), h += 1, o.setXYZ(h, e.x, e.y, e.z), h += 1;
      }
      o.needsUpdate = !0;
    };
  }(), Xn.prototype = Object.create(z.prototype), Xn.prototype.constructor = Xn, Xn.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }, Xn.prototype.update = function() {
    var t = new S(), e = new S(), i = new S();
    return function() {
      t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length();
    };
  }(), ua.prototype = Object.create(ti.prototype), ua.prototype.constructor = ua, ua.prototype.update = function() {
    function t(s, l, h, c) {
      if (n.set(l, h, c).unproject(o), s = i[s], s !== void 0)
        for (l = e.getAttribute("position"), h = 0, c = s.length; h < c; h++)
          l.setXYZ(s[h], n.x, n.y, n.z);
    }
    var e, i, n = new S(), o = new ye();
    return function() {
      e = this.geometry, i = this.pointMap, o.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", 0.7, 1.1, -1), t("u2", -0.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0;
    };
  }(), eo.prototype = Object.create(ti.prototype), eo.prototype.constructor = eo, eo.prototype.update = function() {
    var t = new Nt();
    return function(e) {
      if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && t.setFromObject(this.object), !t.isEmpty()) {
        e = t.min;
        var i = t.max, n = this.geometry.attributes.position, o = n.array;
        o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = e.x, o[4] = i.y, o[5] = i.z, o[6] = e.x, o[7] = e.y, o[8] = i.z, o[9] = i.x, o[10] = e.y, o[11] = i.z, o[12] = i.x, o[13] = i.y, o[14] = e.z, o[15] = e.x, o[16] = i.y, o[17] = e.z, o[18] = e.x, o[19] = e.y, o[20] = e.z, o[21] = i.x, o[22] = e.y, o[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
      }
    };
  }(), eo.prototype.setFromObject = function(t) {
    return this.object = t, this.update(), this;
  }, eo.prototype.copy = function(t) {
    return ti.prototype.copy.call(this, t), this.object = t.object, this;
  }, eo.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, ca.prototype = Object.create(ti.prototype), ca.prototype.constructor = ca, ca.prototype.updateMatrixWorld = function(t) {
    var e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), z.prototype.updateMatrixWorld.call(this, t));
  }, pa.prototype = Object.create(Pi.prototype), pa.prototype.constructor = pa, pa.prototype.updateMatrixWorld = function(t) {
    var e = -this.plane.constant;
    1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), z.prototype.updateMatrixWorld.call(this, t);
  };
  var Wa, ga;
  io.prototype = Object.create(z.prototype), io.prototype.constructor = io, io.prototype.setDirection = function() {
    var t = new S(), e;
    return function(i) {
      0.99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e));
    };
  }(), io.prototype.setLength = function(t, e, i) {
    e === void 0 && (e = 0.2 * t), i === void 0 && (i = 0.2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix();
  }, io.prototype.setColor = function(t) {
    this.line.material.color.copy(t), this.cone.material.color.copy(t);
  }, io.prototype.copy = function(t) {
    return z.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
  }, io.prototype.clone = function() {
    return new this.constructor().copy(this);
  }, Kn.prototype = Object.create(ti.prototype), Kn.prototype.constructor = Kn, he.create = function(t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(he.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
  }, Object.assign(Kr.prototype, {
    createPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getPoints(t), this.createGeometry(t);
    },
    createSpacedPointsGeometry: function(t) {
      return console.warn(
        "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      ), t = this.getSpacedPoints(t), this.createGeometry(t);
    },
    createGeometry: function(t) {
      console.warn(
        "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      for (var e = new X(), i = 0, n = t.length; i < n; i++) {
        var o = t[i];
        e.vertices.push(new S(o.x, o.y, o.z || 0));
      }
      return e;
    }
  }), Object.assign(jn.prototype, {
    fromPoints: function(t) {
      console.warn(
        "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
      ), this.setFromPoints(t);
    }
  }), Dl.prototype = Object.create(fn.prototype), zl.prototype = Object.create(fn.prototype), ul.prototype = Object.create(fn.prototype), Object.assign(ul.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error(
        "THREE.Spline: .reparametrizeByArcLength() has been removed."
      );
    }
  }), la.prototype.setColors = function() {
    console.error(
      "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
  }, Rs.prototype.update = function() {
    console.error(
      "THREE.SkeletonHelper: update() no longer needs to be called."
    );
  }, Object.assign(to.prototype, {
    extractUrlBase: function(t) {
      return console.warn(
        "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
      ), $o.extractUrlBase(t);
    }
  }), Object.assign(Xo.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(ia.prototype, {
    setTexturePath: function(t) {
      return console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ), this.setResourcePath(t);
    }
  }), Object.assign(wo.prototype, {
    center: function(t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    size: function(t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), Object.assign(Nt.prototype, {
    center: function(t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    },
    empty: function() {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    },
    size: function(t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    }
  }), Ls.prototype.center = function(t) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  }, Object.assign(Je, {
    random16: function() {
      return console.warn(
        "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
      ), Math.random();
    },
    nearestPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
      ), Je.floorPowerOfTwo(t);
    },
    nextPowerOfTwo: function(t) {
      return console.warn(
        "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
      ), Je.ceilPowerOfTwo(t);
    }
  }), Object.assign(Mt.prototype, {
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
      ), t.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  }), Object.assign(pt.prototype, {
    extractPosition: function(t) {
      return console.warn(
        "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
      ), this.copyPosition(t);
    },
    flattenToArrayOffset: function(t, e) {
      return console.warn(
        "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ), this.toArray(t, e);
    },
    getPosition: function() {
      var t;
      return function() {
        return t === void 0 && (t = new S()), console.warn(
          "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
        ), t.setFromMatrixColumn(this, 3);
      };
    }(),
    setRotationFromQuaternion: function(t) {
      return console.warn(
        "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
      ), this.makeRotationFromQuaternion(t);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector4: function(t) {
      return console.warn(
        "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(t) {
      console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
      ), t.transformDirection(this);
    },
    crossVector: function(t) {
      return console.warn(
        "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ), t.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(t) {
      return console.warn(
        "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
      ), this.applyToBufferAttribute(t);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(t, e, i, n, o, s) {
      return console.warn(
        "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
      ), this.makePerspective(t, e, n, i, o, s);
    }
  }), Ct.prototype.isIntersectionLine = function(t) {
    return console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ), this.intersectsLine(t);
  }, gt.prototype.multiplyVector3 = function(t) {
    return console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ), t.applyQuaternion(this);
  }, Object.assign(bn.prototype, {
    isIntersectionBox: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
      ), this.intersectsBox(t);
    },
    isIntersectionPlane: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
      ), this.intersectsPlane(t);
    },
    isIntersectionSphere: function(t) {
      return console.warn(
        "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ), this.intersectsSphere(t);
    }
  }), Object.assign(ii.prototype, {
    area: function() {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    },
    barycoordFromPoint: function(t, e) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), this.getBarycoord(t, e);
    },
    midpoint: function(t) {
      return console.warn(
        "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
      ), this.getMidpoint(t);
    },
    normal: function(t) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), this.getNormal(t);
    },
    plane: function(t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    }
  }), Object.assign(ii, {
    barycoordFromPoint: function(t, e, i, n, o) {
      return console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ), ii.getBarycoord(t, e, i, n, o);
    },
    normal: function(t, e, i, n) {
      return console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ), ii.getNormal(t, e, i, n);
    }
  }), Object.assign(Dn.prototype, {
    extractAllPoints: function(t) {
      return console.warn(
        "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
      ), this.extractPoints(t);
    },
    extrude: function(t) {
      return console.warn(
        "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
      ), new Zr(this, t);
    },
    makeGeometry: function(t) {
      return console.warn(
        "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
      ), new Jr(this, t);
    }
  }), Object.assign(y.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(S.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
      );
    },
    setEulerFromQuaternion: function() {
      console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
      );
    },
    getPositionFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
      ), this.setFromMatrixPosition(t);
    },
    getScaleFromMatrix: function(t) {
      return console.warn(
        "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
      ), this.setFromMatrixScale(t);
    },
    getColumnFromMatrix: function(t, e) {
      return console.warn(
        "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
      ), this.setFromMatrixColumn(e, t);
    },
    applyProjection: function(t) {
      return console.warn(
        "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
      ), this.applyMatrix4(t);
    },
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    distanceToManhattan: function(t) {
      return console.warn(
        "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ), this.manhattanDistanceTo(t);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(nt.prototype, {
    fromAttribute: function(t, e, i) {
      return console.warn(
        "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ), this.fromBufferAttribute(t, e, i);
    },
    lengthManhattan: function() {
      return console.warn(
        "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
      ), this.manhattanLength();
    }
  }), Object.assign(X.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
  }), Object.assign(z.prototype, {
    getChildByName: function(t) {
      return console.warn(
        "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
      ), this.getObjectByName(t);
    },
    renderDepth: function() {
      console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
      );
    },
    translate: function(t, e) {
      return console.warn(
        "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
      ), this.translateOnAxis(e, t);
    },
    getWorldRotation: function() {
      console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
      );
    }
  }), Object.defineProperties(z.prototype, {
    eulerOrder: {
      get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      },
      set: function(t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
      set: function() {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      }
    }
  }), Object.defineProperties(Hi.prototype, {
    objects: {
      get: function() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      }
    }
  }), Object.defineProperty(Wi.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  }), Object.defineProperty(he.prototype, "__arcLengthDivisions", {
    get: function() {
      return console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions;
    },
    set: function(t) {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ), this.arcLengthDivisions = t;
    }
  }), ee.prototype.setLens = function(t, e) {
    console.warn(
      "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    ), e !== void 0 && (this.filmGauge = e), this.setFocalLength(t);
  }, Object.defineProperties(Bi.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
        ), this.shadow.camera.fov = t;
      }
    },
    shadowCameraLeft: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
        ), this.shadow.camera.left = t;
      }
    },
    shadowCameraRight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
        ), this.shadow.camera.right = t;
      }
    },
    shadowCameraTop: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
        ), this.shadow.camera.top = t;
      }
    },
    shadowCameraBottom: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
        ), this.shadow.camera.bottom = t;
      }
    },
    shadowCameraNear: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
        ), this.shadow.camera.near = t;
      }
    },
    shadowCameraFar: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
        ), this.shadow.camera.far = t;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn(
          "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
        );
      }
    },
    shadowBias: {
      set: function(t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
        ), this.shadow.mapSize.width = t;
      }
    },
    shadowMapHeight: {
      set: function(t) {
        console.warn(
          "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
        ), this.shadow.mapSize.height = t;
      }
    }
  }), Object.defineProperties(it.prototype, {
    length: {
      get: function() {
        return console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ), this.array.length;
      }
    },
    copyIndicesArray: function() {
      console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
      );
    }
  }), Object.assign(Ft.prototype, {
    addIndex: function(t) {
      console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
      ), this.setIndex(t);
    },
    addDrawCall: function(t, e, i) {
      i !== void 0 && console.warn(
        "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
      ), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    },
    clearDrawCalls: function() {
      console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
      ), this.clearGroups();
    },
    computeTangents: function() {
      console.warn(
        "THREE.BufferGeometry: .computeTangents() has been removed."
      );
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
  }), Object.defineProperties(Ft.prototype, {
    drawcalls: {
      get: function() {
        return console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ), this.groups;
      }
    },
    offsets: {
      get: function() {
        return console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ), this.groups;
      }
    }
  }), Object.assign(Dr.prototype, {
    getArrays: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
      );
    },
    addShapeList: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
      );
    },
    addShape: function() {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
      );
    }
  }), Object.defineProperties(Ba.prototype, {
    dynamic: {
      set: function() {
        console.warn(
          "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
        );
      }
    },
    onUpdate: {
      value: function() {
        return console.warn(
          "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
        ), this;
      }
    }
  }), Object.defineProperties(Oe.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new Y();
      }
    },
    shading: {
      get: function() {
        console.error(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        );
      },
      set: function(t) {
        console.warn(
          "THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."
        ), this.flatShading = t === 1;
      }
    }
  }), Object.defineProperties(xr.prototype, {
    metal: {
      get: function() {
        return console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
        ), !1;
      },
      set: function() {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
        );
      }
    }
  }), Object.defineProperties(Ai.prototype, {
    derivatives: {
      get: function() {
        return console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives;
      },
      set: function(t) {
        console.warn(
          "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ), this.extensions.derivatives = t;
      }
    }
  }), Object.assign(ne.prototype, {
    clearTarget: function(t, e, i, n) {
      console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
      ), this.setRenderTarget(t), this.clear(e, i, n);
    },
    animate: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
      ), this.setAnimationLoop(t);
    },
    getCurrentRenderTarget: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
      ), this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
      ), this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      return console.warn(
        "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
      ), this.capabilities.precision;
    },
    resetGLState: function() {
      return console.warn(
        "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
      ), this.state.reset();
    },
    supportsFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      ), this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      ), this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      ), this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      ), this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      ), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      ), this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
      ), this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      return console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      ), this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(t) {
      console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
      ), this.setScissorTest(t);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }
  }), Object.defineProperties(ne.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
        ), this.shadowMap.enabled = t;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
        ), this.shadowMap.type = t;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(Kt.prototype, {
    cullFace: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function() {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      }
    }
  }), Object.defineProperties(Tt.prototype, {
    wrapS: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
      }
    },
    wrapT: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
      }
    },
    magFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ), this.texture.magFilter = t;
      }
    },
    minFilter: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ), this.texture.minFilter = t;
      }
    },
    anisotropy: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ), this.texture.anisotropy = t;
      }
    },
    offset: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ), this.texture.offset = t;
      }
    },
    repeat: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ), this.texture.repeat = t;
      }
    },
    format: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ), this.texture.format = t;
      }
    },
    type: {
      get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      },
      set: function(t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
      }
    },
    generateMipmaps: {
      get: function() {
        return console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps;
      },
      set: function(t) {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ), this.texture.generateMipmaps = t;
      }
    }
  }), Object.defineProperties(Qe.prototype, {
    standing: {
      set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      }
    },
    userHeight: {
      set: function() {
        console.warn("THREE.WebVRManager: .userHeight has been removed.");
      }
    }
  }), As.prototype.load = function(t) {
    console.warn(
      "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
    );
    var e = this;
    return new $i().load(t, function(i) {
      e.setBuffer(i);
    }), this;
  }, qo.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  }, na.prototype.updateCubeMap = function(t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
  }, Mo.crossOrigin = void 0, Mo.loadTexture = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    var o = new Xi();
    return o.setCrossOrigin(this.crossOrigin), t = o.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, Mo.loadTextureCube = function(t, e, i, n) {
    console.warn(
      "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    var o = new _i();
    return o.setCrossOrigin(this.crossOrigin), t = o.load(t, i, void 0, n), e && (t.mapping = e), t;
  }, Mo.loadCompressedTexture = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
  }, Mo.loadCompressedTextureCube = function() {
    console.error(
      "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
  }, g.WebGLRenderTargetCube = Rt, g.WebGLRenderTarget = Tt, g.WebGLRenderer = ne, g.ShaderLib = Hr, g.UniformsLib = Re, g.UniformsUtils = vn, g.ShaderChunk = li, g.FogExp2 = de, g.Fog = sn, g.Scene = An, g.Sprite = Gi, g.LOD = Hi, g.SkinnedMesh = Mi, g.Skeleton = Wi, g.Bone = ji, g.Mesh = Ui, g.LineSegments = ti, g.LineLoop = Or, g.Line = Pi, g.Points = cs, g.Group = qe, g.VideoTexture = Ka, g.DataTexture = vt, g.DataTexture3D = k, g.CompressedTexture = ho, g.CubeTexture = A, g.CanvasTexture = Vs, g.DepthTexture = Ws, g.Texture = kt, g.AnimationLoader = Ot, g.CompressedTextureLoader = At, g.DataTextureLoader = xe, g.CubeTextureLoader = _i, g.TextureLoader = Xi, g.ObjectLoader = ia, g.MaterialLoader = Da, g.BufferGeometryLoader = il, g.DefaultLoadingManager = zn, g.LoadingManager = vo, g.JSONLoader = Xo, g.ImageLoader = Ve, g.ImageBitmapLoader = nl, g.FontLoader = bl, g.FileLoader = lt, g.Loader = to, g.LoaderUtils = $o, g.Cache = Vr, g.AudioLoader = $i, g.SpotLightShadow = ta, g.SpotLight = ea, g.PointLight = Wo, g.RectAreaLight = Ia, g.HemisphereLight = Ks, g.DirectionalLightShadow = _o, g.DirectionalLight = Gr, g.AmbientLight = jo, g.LightShadow = Fr, g.Light = Bi, g.StereoCamera = Sn, g.PerspectiveCamera = ee, g.OrthographicCamera = Es, g.CubeCamera = na, g.ArrayCamera = _e, g.Camera = ye, g.AudioListener = Na, g.PositionalAudio = ra, g.AudioContext = ml, g.AudioAnalyser = qo, g.Audio = As, g.VectorKeyframeTrack = Ts, g.StringKeyframeTrack = Oa, g.QuaternionKeyframeTrack = Ms, g.NumberKeyframeTrack = wr, g.ColorKeyframeTrack = ba, g.BooleanKeyframeTrack = Ra, g.PropertyMixer = oa, g.PropertyBinding = an, g.KeyframeTrack = Tn, g.AnimationUtils = Ln, g.AnimationObjectGroup = Ps, g.AnimationMixer = xo, g.AnimationClip = Qn, g.Uniform = Ba, g.InstancedBufferGeometry = sl, g.BufferGeometry = Ft, g.Geometry = X, g.InterleavedBufferAttribute = vi, g.InstancedInterleavedBuffer = al, g.InterleavedBuffer = gi, g.InstancedBufferAttribute = ll, g.Face3 = B, g.Object3D = z, g.Raycaster = Ol, g.Layers = Z, g.EventDispatcher = $, g.Clock = ol, g.QuaternionLinearInterpolant = Gn, g.LinearInterpolant = hr, g.DiscreteInterpolant = Vo, g.CubicInterpolant = Qs, g.Interpolant = On, g.Triangle = ii, g.Math = Je, g.Spherical = hl, g.Cylindrical = O, g.Plane = Ct, g.Frustum = at, g.Sphere = Ut, g.Ray = bn, g.Matrix4 = pt, g.Matrix3 = Mt, g.Box3 = Nt, g.Box2 = wo, g.Line3 = Ls, g.Euler = E, g.Vector4 = nt, g.Vector3 = S, g.Vector2 = y, g.Quaternion = gt, g.Color = Y, g.ImmediateRenderObject = Pn, g.VertexNormalsHelper = ni, g.SpotLightHelper = Cs, g.SkeletonHelper = Rs, g.PointLightHelper = cr, g.RectAreaLightHelper = bs, g.HemisphereLightHelper = Os, g.GridHelper = la, g.PolarGridHelper = Ua, g.FaceNormalsHelper = ha, g.DirectionalLightHelper = Xn, g.CameraHelper = ua, g.BoxHelper = eo, g.Box3Helper = ca, g.PlaneHelper = pa, g.ArrowHelper = io, g.AxesHelper = Kn, g.Shape = Dn, g.Path = jn, g.ShapePath = za, g.Font = rl, g.CurvePath = Kr, g.Curve = he, g.ImageUtils = Mo, g.ShapeUtils = kr, g.WebGLUtils = Me, g.WireframeGeometry = ps, g.ParametricGeometry = js, g.ParametricBufferGeometry = fs, g.TetrahedronGeometry = Xs, g.TetrahedronBufferGeometry = ds, g.OctahedronGeometry = qs, g.OctahedronBufferGeometry = Ro, g.IcosahedronGeometry = Ys, g.IcosahedronBufferGeometry = ms, g.DodecahedronGeometry = gs, g.DodecahedronBufferGeometry = vs, g.PolyhedronGeometry = Li, g.PolyhedronBufferGeometry = ri, g.TubeGeometry = Ji, g.TubeBufferGeometry = uo, g.TorusKnotGeometry = _r, g.TorusKnotBufferGeometry = bo, g.TorusGeometry = Oo, g.TorusBufferGeometry = wn, g.TextGeometry = Js, g.TextBufferGeometry = Do, g.SphereGeometry = co, g.SphereBufferGeometry = ar, g.RingGeometry = $s, g.RingBufferGeometry = zo, g.PlaneGeometry = En, g.PlaneBufferGeometry = Yi, g.LatheGeometry = xs, g.LatheBufferGeometry = po, g.ShapeGeometry = Jr, g.ShapeBufferGeometry = fo, g.ExtrudeGeometry = Zr, g.ExtrudeBufferGeometry = Dr, g.EdgesGeometry = mo, g.ConeGeometry = ws, g.ConeBufferGeometry = Mn, g.CylinderGeometry = $r, g.CylinderBufferGeometry = Qr, g.CircleGeometry = No, g.CircleBufferGeometry = zr, g.BoxGeometry = $e, g.BoxBufferGeometry = Oi, g.ShadowMaterial = go, g.SpriteMaterial = Ti, g.RawShaderMaterial = Bo, g.ShaderMaterial = Ai, g.PointsMaterial = xn, g.MeshPhysicalMaterial = Uo, g.MeshStandardMaterial = Nr, g.MeshPhongMaterial = xr, g.MeshToonMaterial = Fo, g.MeshNormalMaterial = Go, g.MeshLambertMaterial = lr, g.MeshDepthMaterial = Vt, g.MeshDistanceMaterial = It, g.MeshBasicMaterial = ui, g.MeshMatcapMaterial = Ho, g.LineDashedMaterial = ko, g.LineBasicMaterial = yi, g.Material = Oe, g.Float64BufferAttribute = ie, g.Float32BufferAttribute = Et, g.Uint32BufferAttribute = we, g.Int32BufferAttribute = se, g.Uint16BufferAttribute = re, g.Int16BufferAttribute = Yt, g.Uint8ClampedBufferAttribute = zt, g.Uint8BufferAttribute = dt, g.Int8BufferAttribute = _t, g.BufferAttribute = it, g.ArcCurve = Ss, g.CatmullRomCurve3 = fn, g.CubicBezierCurve = kn, g.CubicBezierCurve3 = si, g.EllipseCurve = In, g.LineCurve = Vn, g.LineCurve3 = ur, g.QuadraticBezierCurve = Wn, g.QuadraticBezierCurve3 = Ur, g.SplineCurve = Mr, g.REVISION = "98", g.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, g.CullFaceNone = 0, g.CullFaceBack = 1, g.CullFaceFront = 2, g.CullFaceFrontBack = 3, g.FrontFaceDirectionCW = 0, g.FrontFaceDirectionCCW = 1, g.BasicShadowMap = 0, g.PCFShadowMap = 1, g.PCFSoftShadowMap = 2, g.FrontSide = 0, g.BackSide = 1, g.DoubleSide = 2, g.FlatShading = 1, g.SmoothShading = 2, g.NoColors = 0, g.FaceColors = 1, g.VertexColors = 2, g.NoBlending = 0, g.NormalBlending = 1, g.AdditiveBlending = 2, g.SubtractiveBlending = 3, g.MultiplyBlending = 4, g.CustomBlending = 5, g.AddEquation = 100, g.SubtractEquation = 101, g.ReverseSubtractEquation = 102, g.MinEquation = 103, g.MaxEquation = 104, g.ZeroFactor = 200, g.OneFactor = 201, g.SrcColorFactor = 202, g.OneMinusSrcColorFactor = 203, g.SrcAlphaFactor = 204, g.OneMinusSrcAlphaFactor = 205, g.DstAlphaFactor = 206, g.OneMinusDstAlphaFactor = 207, g.DstColorFactor = 208, g.OneMinusDstColorFactor = 209, g.SrcAlphaSaturateFactor = 210, g.NeverDepth = 0, g.AlwaysDepth = 1, g.LessDepth = 2, g.LessEqualDepth = 3, g.EqualDepth = 4, g.GreaterEqualDepth = 5, g.GreaterDepth = 6, g.NotEqualDepth = 7, g.MultiplyOperation = 0, g.MixOperation = 1, g.AddOperation = 2, g.NoToneMapping = 0, g.LinearToneMapping = 1, g.ReinhardToneMapping = 2, g.Uncharted2ToneMapping = 3, g.CineonToneMapping = 4, g.UVMapping = 300, g.CubeReflectionMapping = 301, g.CubeRefractionMapping = 302, g.EquirectangularReflectionMapping = 303, g.EquirectangularRefractionMapping = 304, g.SphericalReflectionMapping = 305, g.CubeUVReflectionMapping = 306, g.CubeUVRefractionMapping = 307, g.RepeatWrapping = 1e3, g.ClampToEdgeWrapping = 1001, g.MirroredRepeatWrapping = 1002, g.NearestFilter = 1003, g.NearestMipMapNearestFilter = 1004, g.NearestMipMapLinearFilter = 1005, g.LinearFilter = 1006, g.LinearMipMapNearestFilter = 1007, g.LinearMipMapLinearFilter = 1008, g.UnsignedByteType = 1009, g.ByteType = 1010, g.ShortType = 1011, g.UnsignedShortType = 1012, g.IntType = 1013, g.UnsignedIntType = 1014, g.FloatType = 1015, g.HalfFloatType = 1016, g.UnsignedShort4444Type = 1017, g.UnsignedShort5551Type = 1018, g.UnsignedShort565Type = 1019, g.UnsignedInt248Type = 1020, g.AlphaFormat = 1021, g.RGBFormat = 1022, g.RGBAFormat = 1023, g.LuminanceFormat = 1024, g.LuminanceAlphaFormat = 1025, g.RGBEFormat = 1023, g.DepthFormat = 1026, g.DepthStencilFormat = 1027, g.RedFormat = 1028, g.RGB_S3TC_DXT1_Format = 33776, g.RGBA_S3TC_DXT1_Format = 33777, g.RGBA_S3TC_DXT3_Format = 33778, g.RGBA_S3TC_DXT5_Format = 33779, g.RGB_PVRTC_4BPPV1_Format = 35840, g.RGB_PVRTC_2BPPV1_Format = 35841, g.RGBA_PVRTC_4BPPV1_Format = 35842, g.RGBA_PVRTC_2BPPV1_Format = 35843, g.RGB_ETC1_Format = 36196, g.RGBA_ASTC_4x4_Format = 37808, g.RGBA_ASTC_5x4_Format = 37809, g.RGBA_ASTC_5x5_Format = 37810, g.RGBA_ASTC_6x5_Format = 37811, g.RGBA_ASTC_6x6_Format = 37812, g.RGBA_ASTC_8x5_Format = 37813, g.RGBA_ASTC_8x6_Format = 37814, g.RGBA_ASTC_8x8_Format = 37815, g.RGBA_ASTC_10x5_Format = 37816, g.RGBA_ASTC_10x6_Format = 37817, g.RGBA_ASTC_10x8_Format = 37818, g.RGBA_ASTC_10x10_Format = 37819, g.RGBA_ASTC_12x10_Format = 37820, g.RGBA_ASTC_12x12_Format = 37821, g.LoopOnce = 2200, g.LoopRepeat = 2201, g.LoopPingPong = 2202, g.InterpolateDiscrete = 2300, g.InterpolateLinear = 2301, g.InterpolateSmooth = 2302, g.ZeroCurvatureEnding = 2400, g.ZeroSlopeEnding = 2401, g.WrapAroundEnding = 2402, g.TrianglesDrawMode = 0, g.TriangleStripDrawMode = 1, g.TriangleFanDrawMode = 2, g.LinearEncoding = 3e3, g.sRGBEncoding = 3001, g.GammaEncoding = 3007, g.RGBEEncoding = 3002, g.LogLuvEncoding = 3003, g.RGBM7Encoding = 3004, g.RGBM16Encoding = 3005, g.RGBDEncoding = 3006, g.BasicDepthPacking = 3200, g.RGBADepthPacking = 3201, g.TangentSpaceNormalMap = 0, g.ObjectSpaceNormalMap = 1, g.CubeGeometry = $e, g.Face4 = function(t, e, i, n, o, s, l) {
    return console.warn(
      "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
    ), new B(t, e, i, o, s, l);
  }, g.LineStrip = 0, g.LinePieces = 1, g.MeshFaceMaterial = function(t) {
    return console.warn(
      "THREE.MeshFaceMaterial has been removed. Use an Array instead."
    ), t;
  }, g.MultiMaterial = function(t) {
    return t === void 0 && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
      return t.slice();
    }, t;
  }, g.PointCloud = function(t, e) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new cs(t, e);
  }, g.Particle = function(t) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Gi(t);
  }, g.ParticleSystem = function(t, e) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new cs(t, e);
  }, g.PointCloudMaterial = function(t) {
    return console.warn(
      "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
    ), new xn(t);
  }, g.ParticleBasicMaterial = function(t) {
    return console.warn(
      "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
    ), new xn(t);
  }, g.ParticleSystemMaterial = function(t) {
    return console.warn(
      "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
    ), new xn(t);
  }, g.Vertex = function(t, e, i) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new S(t, e, i);
  }, g.DynamicBufferAttribute = function(t, e) {
    return console.warn(
      "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
    ), new it(t, e).setDynamic(!0);
  }, g.Int8Attribute = function(t, e) {
    return console.warn(
      "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
    ), new _t(t, e);
  }, g.Uint8Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
    ), new dt(t, e);
  }, g.Uint8ClampedAttribute = function(t, e) {
    return console.warn(
      "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
    ), new zt(t, e);
  }, g.Int16Attribute = function(t, e) {
    return console.warn(
      "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
    ), new Yt(t, e);
  }, g.Uint16Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
    ), new re(t, e);
  }, g.Int32Attribute = function(t, e) {
    return console.warn(
      "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
    ), new se(t, e);
  }, g.Uint32Attribute = function(t, e) {
    return console.warn(
      "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
    ), new we(t, e);
  }, g.Float32Attribute = function(t, e) {
    return console.warn(
      "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
    ), new Et(t, e);
  }, g.Float64Attribute = function(t, e) {
    return console.warn(
      "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
    ), new ie(t, e);
  }, g.ClosedSplineCurve3 = Dl, g.SplineCurve3 = zl, g.Spline = ul, g.AxisHelper = function(t) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Kn(t);
  }, g.BoundingBoxHelper = function(t, e) {
    return console.warn(
      "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
    ), new eo(t, e);
  }, g.EdgesHelper = function(t, e) {
    return console.warn(
      "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
    ), new ti(
      new mo(t.geometry),
      new yi({ color: e !== void 0 ? e : 16777215 })
    );
  }, g.WireframeHelper = function(t, e) {
    return console.warn(
      "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
    ), new ti(
      new ps(t.geometry),
      new yi({ color: e !== void 0 ? e : 16777215 })
    );
  }, g.XHRLoader = function(t) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new lt(t);
  }, g.BinaryTextureLoader = function(t) {
    return console.warn(
      "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
    ), new xe(t);
  }, g.GeometryUtils = {
    merge: function(t, e, i) {
      if (console.warn(
        "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
      ), e.isMesh) {
        e.matrixAutoUpdate && e.updateMatrix();
        var n = e.matrix;
        e = e.geometry;
      }
      t.merge(e, n, i);
    },
    center: function(t) {
      return console.warn(
        "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
      ), t.center();
    }
  }, g.Projector = function() {
    console.error(
      "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
    ), this.projectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .projectVector() is now vector.project()."
      ), t.project(e);
    }, this.unprojectVector = function(t, e) {
      console.warn(
        "THREE.Projector: .unprojectVector() is now vector.unproject()."
      ), t.unproject(e);
    }, this.pickingRay = function() {
      console.error(
        "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
      );
    };
  }, g.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  }, g.SceneUtils = {
    createMultiMaterialObject: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    detach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    },
    attach: function() {
      console.error(
        "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
      );
    }
  }, g.LensFlare = function() {
    console.error(
      "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
    );
  }, Object.defineProperty(g, "__esModule", { value: !0 });
});
THREE.Sky = function() {
  var g = THREE.Sky.SkyShader, $ = new THREE.ShaderMaterial({
    fragmentShader: g.fragmentShader,
    vertexShader: g.vertexShader,
    uniforms: THREE.UniformsUtils.clone(g.uniforms),
    side: THREE.BackSide
  });
  THREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), $);
};
THREE.Sky.prototype = Object.create(THREE.Mesh.prototype);
THREE.Sky.SkyShader = {
  uniforms: {
    luminance: { value: 1 },
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new THREE.Vector3() }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    // wavelength of used primaries, according to preetham
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
    // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    // mie stuff
    // K coefficient for the primaries
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    // earth shadow hack
    // cutoffAngle = pi / 1.95;
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    // set z to camera.far
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    // extinction (absorbtion + out scattering)
    // rayleigh coefficients
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    // mie coefficients
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join(`
`),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float luminance;",
    "uniform float mieDirectionalG;",
    "const vec3 cameraPos = vec3( 0.0, 1.0, 0.0 );",
    // constants for atmospheric scattering
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    // refractive index of air
    "const float N = 2.545E25;",
    // number of molecules per unit volume for air at
    // 288.15K and 1013mb (sea level -45 celsius)
    // optical length at zenith for molecules
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const vec3 up = vec3( 0.0, 1.0, 0.0 );",
    // 66 arc seconds -> degrees, and the cosine of that
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    // 3.0 / ( 16.0 * pi )
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    // 1.0 / ( 4.0 * pi )
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    // Filmic ToneMapping http://filmicgames.com/archives/75
    "const float A = 0.15;",
    "const float B = 0.50;",
    "const float C = 0.10;",
    "const float D = 0.20;",
    "const float E = 0.02;",
    "const float F = 0.30;",
    "const float whiteScale = 1.0748724675633854;",
    // 1.0 / Uncharted2Tonemap(1000.0)
    "vec3 Uncharted2Tonemap( vec3 x ) {",
    "	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
    "}",
    "void main() {",
    // optical length
    // cutoff angle at 90 to avoid singularity in next formula.
    "	float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    // combined extinction factor
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    // in scattering
    "	float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    // nightsky
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    // composition + solar disc
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );",
    "	vec3 color = curr * whiteScale;",
    "	vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "}"
  ].join(`
`)
};
(function(g) {
  typeof module > "u" ? window.charming = g : module.exports = g;
})(function(g, $) {
  $ = $ || {};
  var y = $.tagName || "span", pt = $.classPrefix != null ? $.classPrefix : "char", gt = 1, S = function(Mt) {
    for (var kt = Mt.parentNode, nt = Mt.nodeValue, Tt = nt.length, Rt = -1; ++Rt < Tt; ) {
      var vt = document.createElement(y);
      pt && (vt.className = pt + gt, gt++), vt.appendChild(document.createTextNode(nt[Rt])), kt.insertBefore(vt, Mt);
    }
    kt.removeChild(Mt);
  };
  return function Mt(kt) {
    for (var nt = [].slice.call(kt.childNodes), Tt = nt.length, Rt = -1; ++Rt < Tt; )
      Mt(nt[Rt]);
    kt.nodeType === Node.TEXT_NODE && S(kt);
  }(g), g;
});
class Km {
  constructor($, y = []) {
    mars3d ? (this.map = $, this.tilesetLayer, this.modelArr = y, this.bimObliquePhotographyId = [], this.editDate = {
      id: null
    }) : console.error("未引入指定插件");
  }
  /**
   * 给 modelArr 添加数据
   * @param  { Object } mode 模型数据
   */
  pushModel($) {
    this.modelArr.push($);
  }
  /**
   * add 模型方法
   * @param  { Object || String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  add($, y) {
    const pt = /* @__PURE__ */ new Map([["click", mars3d.EventType.click]]);
    return new Promise((gt, S) => {
      let Mt, kt, nt, Tt, Rt, vt, Nt, Ut, Ct;
      if (typeof $ != "object") {
        let Y = this.query($);
        Y || S("缺少树结构");
        let { id: _, bimModelExcavationDetails: x, bimModel: B } = Y;
        Mt = _, kt = B.modelType, nt = B.tender, Tt = B.releasedDistance, Rt = B.modelName, vt = B.isDynamicReleased, Nt = {
          bimModelExcavationDetails: x
        }, Ut = Y.url, Ct = B.modelColor;
      } else
        Mt = $.modelId, kt = $.modelType, nt = $.tender, Tt = $.releasedDistance, Rt = $.modelTitle, vt = $.permission, Nt = $.customize, Ut = $.url, Ct = $.color;
      let at = this.map.getLayer($, "modelId");
      if (at)
        return gt(at), !1;
      if (Ut.indexOf("tileset.json") < 0)
        return console.error("链接不完整", Rt), gt({
          tite: "【模型】" + Rt + "数据地址有误",
          type: "error",
          id: Mt,
          url: Ut
        }), !1;
      new Cesium.Resource({
        url: Ut
      }).fetchJson().then((_) => {
        let x = null, B = { enabled: !0, precise: !1 }, E = [];
        Ct && (x = {
          color: { conditions: [["true", "rgba(255, 255, 0, 1)"]] }
        }), window.bimClip && window.bimClip.activeObj[Mt] && (Object.keys(window.bimClip.activeObj[Mt]).forEach((Z) => {
          let { item: z } = window.bimClip.activeObj[Mt][Z], { bimModelExcavationDetails: X } = z, { excavationDetails: it } = X;
          E.push({
            positions: JSON.parse(it).excavationDetails,
            id: Number(Z)
          });
        }), E.length > 0 && (B.area = E)), this.tilesetLayer = new mars3d.layer.TilesetLayer({
          modelId: Mt,
          modelType: kt,
          tender: nt,
          releasedDistance: Tt,
          modelTitle: Rt,
          permission: vt,
          customize: Nt,
          url: encodeURI(Ut),
          flat: {
            precise: !1
          },
          skipLevelOfDetail: !0,
          loadSiblings: !0,
          cullRequestsWhileMoving: !0,
          cullRequestsWhileMovingMultiplier: 10,
          preferLeaves: !0,
          progressiveResolutionHeightFraction: 0.5,
          dynamicScreenSpaceError: !0,
          preloadWhenHidden: !1,
          style: x,
          clip: B,
          cacheBytes: 1073741824 * 2,
          // 1024MB = 1024*1024*1024
          maximumCacheOverflowBytes: 2147483648 * 2
          // 2048MB = 2048*1024*1024
          // 1.04版本
          // customShader: new Cesium.CustomShader({
          //   lightingModel: Cesium.LightingModel.UNLIT,
          // }),
        }), this.tilesetLayer.bindPopup((Z) => {
          if (Z.graphic) {
            const z = Z.graphic.attr;
            let X = null, it = null;
            return JSON.stringify(z) !== "{}" ? (z.name && (X = z.name.lastIndexOf("@")), X && X > -1 && (it = z.name.slice(0, X)), z.name ? `&nbsp;&nbsp;<span>${it || z.name}</span>&nbsp;&nbsp;` : `&nbsp;&nbsp;<span>${Rt}</span>&nbsp;&nbsp;`) : `&nbsp;&nbsp;<span>${Rt}</span>&nbsp;&nbsp;`;
          } else
            return `&nbsp;&nbsp;<span>${Rt}</span>&nbsp;&nbsp;`;
        }), this.tilesetLayer.readyPromise.then((Z) => {
          console.log("加载完成", this.tilesetLayer, Z), gt(Z);
          let { modelId: z } = Z.options;
          Z.clip.options.area.forEach((X) => {
            window.bimClip.activeObj[z][X.id].id == null && (window.bimClip.activeObj[z][X.id].id = X.id);
          });
        }).catch((Z) => {
          gt();
        }), this.tilesetLayer.on("click", (Z) => {
          Z.layer.style == null && Z.layer.openHighlight(
            {
              color: "rgba(255,0,0,1)"
            },
            !0
          );
        }), y && Object.keys(y).forEach((Z) => {
          this.tilesetLayer.on(pt.get(Z), (z) => {
            y[Z](z);
          });
        }), kt == 0 && this.bimObliquePhotographyId.push(Mt), this.map.addLayer(this.tilesetLayer);
      }).catch((_) => {
        console.error("数据加载失败", Rt), gt({
          tite: "【模型】" + Rt + "数据加载失败",
          type: "error",
          id: Mt,
          url: Ut
        });
      });
    });
  }
  /**
   * 移除模型方法
   * @param  { String } id 模型id
   *
   */
  remove($) {
    this.map.getLayer($, "modelId") && (this.map.getLayer($, "modelId").closeHighlight(), this.map.removeLayer(this.map.getLayer($, "modelId")));
  }
  /**
   * 选中模型
   * @param  { String } id 模型id
   *
   */
  selected($, y = !0) {
    return new Promise((pt, gt) => {
      let S = this.map.getLayer($, "modelId");
      S ? (y && S.flyTo(), S.style == null && S.openHighlight(
        {
          color: "rgba(255,0,0,1)"
        },
        !0
      ), pt(S)) : this.add($).then((Mt) => {
        Mt && (y && Mt.flyTo(), Mt.style == null && Mt.openHighlight(
          {
            color: "rgba(255,0,0,1)"
          },
          !0
        ), pt(Mt));
      });
    });
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.modelArr = [], this.bimObliquePhotographyId = [], this.tilesetLayer = null;
  }
  /**
   * 查询动态释放模型方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query($) {
    return this.modelArr.length == 0 ? !1 : this.modelArr.find((y) => y.id == $);
  }
  /**
   * 用户操作的模型
   * @param  { String } id 模型属性
   */
  postEditDate($) {
    this.editDate = {
      id: $
    };
  }
  /**
   * 更新模型颜色
   * @param  { String } id 模型属性
   * @param  { String | Number } newColor 需要着色的颜色
   * @param  { String } selectcontent 判断逻辑 默认是全部染色
   */
  editColor($, y, pt = "true") {
    let gt = this.map.getLayer($, "modelId");
    if (this.postEditDate($), y)
      gt.style = {
        color: {
          conditions: [[pt, y]]
        }
      };
    else {
      let S = this.query($).modelColor;
      S ? gt.style = {
        color: { conditions: [[pt, S]] }
      } : gt.style = null;
    }
  }
  /**
   * 更新模型透明度
   * @param  { String } id 模型属性
   * @param  { String | Number } opacity 透明度值
   */
  editOpacity($, y) {
    this.map.getLayer($, "modelId").opacity = y;
  }
  /**
   * 模型挖洞
   */
  addClip($) {
    return new Promise((y, pt) => {
      window.bimClip ? y(bimClip.clipModelAdd($)) : pt("挖洞工具未初始化");
    });
  }
  /**
   * 模型挖洞 移除
   */
  removeClip($) {
    window.bimClip ? window.bimClip.clipModelremoveClip($) : console.log("挖洞工具未初始化");
  }
  // tilesetLayer.clip.clear()
}
const eh = (g) => Object.prototype.toString.call(g) === "[object Object]";
function nh() {
  const g = Array.from(arguments);
  if (g.length < 2)
    return g[0];
  let $ = g[0];
  return g.shift(), g.forEach((y) => {
    if (eh(y)) {
      eh($) || ($ = {});
      for (let pt in y)
        $[pt] && eh(y[pt]) ? $[pt] = nh($[pt], y[pt]) : $[pt] = y[pt];
    } else
      y instanceof Array && ($ instanceof Array || ($ = []), y.forEach((pt, gt) => {
        eh(pt) ? $[gt] = nh($[gt]) : $[gt] = pt;
      }));
  }), $;
}
let ih = {};
const Xm = (g, $) => (ih = {}, console.log("ZHANG", g, $), g.difference && g.difference.length > 0 && g.difference.forEach((y) => {
  nh(ih, {
    [y]: g.vectorStyle[y]
  });
}), $.difference && $.difference.length > 0 && $.difference.forEach((y) => {
  nh(ih, {
    label: {
      [y]: $.labelStyle[y]
    }
  });
}), ih);
var Sl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qm(g) {
  return g && g.__esModule && Object.prototype.hasOwnProperty.call(g, "default") ? g.default : g;
}
var rh = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
rh.exports;
(function(g, $) {
  (function() {
    var y, pt = "4.17.21", gt = 200, S = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", Mt = "Expected a function", kt = "Invalid `variable` option passed into `_.template`", nt = "__lodash_hash_undefined__", Tt = 500, Rt = "__lodash_placeholder__", vt = 1, Nt = 2, Ut = 4, Ct = 1, at = 2, Y = 1, _ = 2, x = 4, B = 8, E = 16, Z = 32, z = 64, X = 128, it = 256, _t = 512, dt = 30, zt = "...", Yt = 800, re = 16, se = 1, we = 2, Et = 3, ie = 1 / 0, ze = 9007199254740991, nn = 17976931348623157e292, Ft = 0 / 0, $e = 4294967295, Oi = $e - 1, En = $e >>> 1, Yi = [
      ["ary", X],
      ["bind", Y],
      ["bindKey", _],
      ["curry", B],
      ["curryRight", E],
      ["flip", _t],
      ["partial", Z],
      ["partialRight", z],
      ["rearg", it]
    ], Oe = "[object Arguments]", Ai = "[object Array]", bn = "[object AsyncFunction]", ii = "[object Boolean]", ui = "[object Date]", Ui = "[object DOMException]", vr = "[object Error]", Pr = "[object Function]", Zn = "[object GeneratorFunction]", Fi = "[object Map]", Un = "[object Number]", rn = "[object Null]", Ze = "[object Object]", _n = "[object Promise]", lo = "[object Proxy]", Fn = "[object RegExp]", Ni = "[object Set]", A = "[object String]", k = "[object Symbol]", j = "[object Undefined]", q = "[object WeakMap]", ht = "[object WeakSet]", Lt = "[object ArrayBuffer]", Gt = "[object DataView]", Pt = "[object Float32Array]", Ae = "[object Float64Array]", Se = "[object Int8Array]", te = "[object Int16Array]", Pe = "[object Int32Array]", ci = "[object Uint8Array]", wi = "[object Uint8ClampedArray]", Ke = "[object Uint16Array]", mi = "[object Uint32Array]", Yr = /\b__p \+= '';/g, or = /\b(__p \+=) '' \+/g, Zi = /(__e\(.*?\)|\b__t\)) \+\n'';/g, os = /&(?:amp|lt|gt|quot|#39);/g, Ii = /[&<>"']/g, Za = RegExp(os.source), Lr = RegExp(Ii.source), wa = /<%-([\s\S]+?)%>/g, on = /<%([\s\S]+?)%>/g, ss = /<%=([\s\S]+?)%>/g, Po = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Jn = /^\w*$/, as = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Gs = /[\\^$.*+?()[\]{}|]/g, Ma = RegExp(Gs.source), Cr = /^\s+/, Ja = /\s/, ls = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Hs = /\{\n\/\* \[wrapped with (.+)\] \*/, Rr = /,? & /, ks = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, hs = /[()=,{}\[\]\/\s]/, us = /\\(\\)?/g, br = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ta = /\w*$/, $a = /^[-+]0x[0-9a-f]+$/i, Qa = /^0b[01]+$/i, Lo = /^\[object .+?Constructor\]$/, Co = /^0o[0-7]+$/i, Sa = /^(?:0|[1-9]\d*)$/, Ea = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, yr = /($^)/, M = /['\n\r\u2028\u2029\\]/g, b = "\\ud800-\\udfff", U = "\\u0300-\\u036f", N = "\\ufe20-\\ufe2f", T = "\\u20d0-\\u20ff", rt = U + N + T, F = "\\u2700-\\u27bf", ut = "a-z\\xdf-\\xf6\\xf8-\\xff", xt = "\\xac\\xb1\\xd7\\xf7", ft = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", et = "\\u2000-\\u206f", Xt = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Vt = "A-Z\\xc0-\\xd6\\xd8-\\xde", It = "\\ufe0e\\ufe0f", Kt = xt + ft + et + Xt, qt = "['’]", Le = "[" + b + "]", Me = "[" + Kt + "]", qe = "[" + rt + "]", ye = "\\d+", ee = "[" + F + "]", _e = "[" + ut + "]", Zt = "[^" + b + Kt + ye + F + ut + Vt + "]", Qe = "\\ud83c[\\udffb-\\udfff]", fe = "(?:" + qe + "|" + Qe + ")", ne = "[^" + b + "]", de = "(?:\\ud83c[\\udde6-\\uddff]){2}", sn = "[\\ud800-\\udbff][\\udc00-\\udfff]", An = "[" + Vt + "]", gi = "\\u200d", vi = "(?:" + _e + "|" + Zt + ")", Ti = "(?:" + An + "|" + Zt + ")", Gi = "(?:" + qt + "(?:d|ll|m|re|s|t|ve))?", Hi = "(?:" + qt + "(?:D|LL|M|RE|S|T|VE))?", Wi = fe + "?", ji = "[" + It + "]?", Mi = "(?:" + gi + "(?:" + [ne, de, sn].join("|") + ")" + ji + Wi + ")*", yi = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Pi = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ti = ji + Wi + Mi, Or = "(?:" + [ee, de, sn].join("|") + ")" + ti, xn = "(?:" + [ne + qe + "?", qe, de, sn, Le].join("|") + ")", cs = RegExp(qt, "g"), Ka = RegExp(qe, "g"), ho = RegExp(Qe + "(?=" + Qe + ")|" + xn + ti, "g"), Vs = RegExp([
      An + "?" + _e + "+" + Gi + "(?=" + [Me, An, "$"].join("|") + ")",
      Ti + "+" + Hi + "(?=" + [Me, An + vi, "$"].join("|") + ")",
      An + "?" + vi + "+" + Gi,
      An + "+" + Hi,
      Pi,
      yi,
      ye,
      Or
    ].join("|"), "g"), Ws = RegExp("[" + gi + b + rt + It + "]"), ps = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, js = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], fs = -1, Li = {};
    Li[Pt] = Li[Ae] = Li[Se] = Li[te] = Li[Pe] = Li[ci] = Li[wi] = Li[Ke] = Li[mi] = !0, Li[Oe] = Li[Ai] = Li[Lt] = Li[ii] = Li[Gt] = Li[ui] = Li[vr] = Li[Pr] = Li[Fi] = Li[Un] = Li[Ze] = Li[Fn] = Li[Ni] = Li[A] = Li[q] = !1;
    var ri = {};
    ri[Oe] = ri[Ai] = ri[Lt] = ri[Gt] = ri[ii] = ri[ui] = ri[Pt] = ri[Ae] = ri[Se] = ri[te] = ri[Pe] = ri[Fi] = ri[Un] = ri[Ze] = ri[Fn] = ri[Ni] = ri[A] = ri[k] = ri[ci] = ri[wi] = ri[Ke] = ri[mi] = !0, ri[vr] = ri[Pr] = ri[q] = !1;
    var Xs = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, ds = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, qs = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Ro = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Ys = parseFloat, ms = parseInt, gs = typeof Sl == "object" && Sl && Sl.Object === Object && Sl, vs = typeof self == "object" && self && self.Object === Object && self, Ji = gs || vs || Function("return this")(), uo = $ && !$.nodeType && $, _r = uo && !0 && g && !g.nodeType && g, bo = _r && _r.exports === uo, Oo = bo && gs.process, wn = function() {
      try {
        var lt = _r && _r.require && _r.require("util").types;
        return lt || Oo && Oo.binding && Oo.binding("util");
      } catch {
      }
    }(), tl = wn && wn.isArrayBuffer, ys = wn && wn.isDate, _s = wn && wn.isMap, El = wn && wn.isRegExp, Al = wn && wn.isSet, Aa = wn && wn.isTypedArray;
    function $n(lt, Ot, At) {
      switch (At.length) {
        case 0:
          return lt.call(Ot);
        case 1:
          return lt.call(Ot, At[0]);
        case 2:
          return lt.call(Ot, At[0], At[1]);
        case 3:
          return lt.call(Ot, At[0], At[1], At[2]);
      }
      return lt.apply(Ot, At);
    }
    function Pa(lt, Ot, At, xe) {
      for (var Ve = -1, _i = lt == null ? 0 : lt.length; ++Ve < _i; ) {
        var Xi = lt[Ve];
        Ot(xe, Xi, At(Xi), lt);
      }
      return xe;
    }
    function Di(lt, Ot) {
      for (var At = -1, xe = lt == null ? 0 : lt.length; ++At < xe && Ot(lt[At], At, lt) !== !1; )
        ;
      return lt;
    }
    function Io(lt, Ot) {
      for (var At = lt == null ? 0 : lt.length; At-- && Ot(lt[At], At, lt) !== !1; )
        ;
      return lt;
    }
    function el(lt, Ot) {
      for (var At = -1, xe = lt == null ? 0 : lt.length; ++At < xe; )
        if (!Ot(lt[At], At, lt))
          return !1;
      return !0;
    }
    function sr(lt, Ot) {
      for (var At = -1, xe = lt == null ? 0 : lt.length, Ve = 0, _i = []; ++At < xe; ) {
        var Xi = lt[At];
        Ot(Xi, At, lt) && (_i[Ve++] = Xi);
      }
      return _i;
    }
    function Zs(lt, Ot) {
      var At = lt == null ? 0 : lt.length;
      return !!At && ar(lt, Ot, 0) > -1;
    }
    function La(lt, Ot, At) {
      for (var xe = -1, Ve = lt == null ? 0 : lt.length; ++xe < Ve; )
        if (At(Ot, lt[xe]))
          return !0;
      return !1;
    }
    function Ri(lt, Ot) {
      for (var At = -1, xe = lt == null ? 0 : lt.length, Ve = Array(xe); ++At < xe; )
        Ve[At] = Ot(lt[At], At, lt);
      return Ve;
    }
    function Ir(lt, Ot) {
      for (var At = -1, xe = Ot.length, Ve = lt.length; ++At < xe; )
        lt[Ve + At] = Ot[At];
      return lt;
    }
    function Ca(lt, Ot, At, xe) {
      var Ve = -1, _i = lt == null ? 0 : lt.length;
      for (xe && _i && (At = lt[++Ve]); ++Ve < _i; )
        At = Ot(At, lt[Ve], Ve, lt);
      return At;
    }
    function Pl(lt, Ot, At, xe) {
      var Ve = lt == null ? 0 : lt.length;
      for (xe && Ve && (At = lt[--Ve]); Ve--; )
        At = Ot(At, lt[Ve], Ve, lt);
      return At;
    }
    function Zr(lt, Ot) {
      for (var At = -1, xe = lt == null ? 0 : lt.length; ++At < xe; )
        if (Ot(lt[At], At, lt))
          return !0;
      return !1;
    }
    var Dr = po("length");
    function Ll(lt) {
      return lt.split("");
    }
    function Js(lt) {
      return lt.match(ks) || [];
    }
    function Do(lt, Ot, At) {
      var xe;
      return At(lt, function(Ve, _i, Xi) {
        if (Ot(Ve, _i, Xi))
          return xe = _i, !1;
      }), xe;
    }
    function co(lt, Ot, At, xe) {
      for (var Ve = lt.length, _i = At + (xe ? 1 : -1); xe ? _i-- : ++_i < Ve; )
        if (Ot(lt[_i], _i, lt))
          return _i;
      return -1;
    }
    function ar(lt, Ot, At) {
      return Ot === Ot ? Ra(lt, Ot, At) : co(lt, zo, At);
    }
    function $s(lt, Ot, At, xe) {
      for (var Ve = At - 1, _i = lt.length; ++Ve < _i; )
        if (xe(lt[Ve], Ot))
          return Ve;
      return -1;
    }
    function zo(lt) {
      return lt !== lt;
    }
    function xs(lt, Ot) {
      var At = lt == null ? 0 : lt.length;
      return At ? mo(lt, Ot) / At : Ft;
    }
    function po(lt) {
      return function(Ot) {
        return Ot == null ? y : Ot[lt];
      };
    }
    function Jr(lt) {
      return function(Ot) {
        return lt == null ? y : lt[Ot];
      };
    }
    function fo(lt, Ot, At, xe, Ve) {
      return Ve(lt, function(_i, Xi, he) {
        At = xe ? (xe = !1, _i) : Ot(At, _i, Xi, he);
      }), At;
    }
    function Cl(lt, Ot) {
      var At = lt.length;
      for (lt.sort(Ot); At--; )
        lt[At] = lt[At].value;
      return lt;
    }
    function mo(lt, Ot) {
      for (var At, xe = -1, Ve = lt.length; ++xe < Ve; ) {
        var _i = Ot(lt[xe]);
        _i !== y && (At = At === y ? _i : At + _i);
      }
      return At;
    }
    function $r(lt, Ot) {
      for (var At = -1, xe = Array(lt); ++At < lt; )
        xe[At] = Ot(At);
      return xe;
    }
    function Qr(lt, Ot) {
      return Ri(Ot, function(At) {
        return [At, lt[At]];
      });
    }
    function ws(lt) {
      return lt && lt.slice(0, Ms(lt) + 1).replace(Cr, "");
    }
    function Mn(lt) {
      return function(Ot) {
        return lt(Ot);
      };
    }
    function No(lt, Ot) {
      return Ri(Ot, function(At) {
        return lt[At];
      });
    }
    function zr(lt, Ot) {
      return lt.has(Ot);
    }
    function go(lt, Ot) {
      for (var At = -1, xe = lt.length; ++At < xe && ar(Ot, lt[At], 0) > -1; )
        ;
      return At;
    }
    function Bo(lt, Ot) {
      for (var At = lt.length; At-- && ar(Ot, lt[At], 0) > -1; )
        ;
      return At;
    }
    function Nr(lt, Ot) {
      for (var At = lt.length, xe = 0; At--; )
        lt[At] === Ot && ++xe;
      return xe;
    }
    var Uo = Jr(Xs), xr = Jr(ds);
    function Fo(lt) {
      return "\\" + Ro[lt];
    }
    function Go(lt, Ot) {
      return lt == null ? y : lt[Ot];
    }
    function lr(lt) {
      return Ws.test(lt);
    }
    function Ho(lt) {
      return ps.test(lt);
    }
    function ko(lt) {
      for (var Ot, At = []; !(Ot = lt.next()).done; )
        At.push(Ot.value);
      return At;
    }
    function On(lt) {
      var Ot = -1, At = Array(lt.size);
      return lt.forEach(function(xe, Ve) {
        At[++Ot] = [Ve, xe];
      }), At;
    }
    function Qs(lt, Ot) {
      return function(At) {
        return lt(Ot(At));
      };
    }
    function hr(lt, Ot) {
      for (var At = -1, xe = lt.length, Ve = 0, _i = []; ++At < xe; ) {
        var Xi = lt[At];
        (Xi === Ot || Xi === Rt) && (lt[At] = Rt, _i[Ve++] = At);
      }
      return _i;
    }
    function Vo(lt) {
      var Ot = -1, At = Array(lt.size);
      return lt.forEach(function(xe) {
        At[++Ot] = xe;
      }), At;
    }
    function Tn(lt) {
      var Ot = -1, At = Array(lt.size);
      return lt.forEach(function(xe) {
        At[++Ot] = [xe, xe];
      }), At;
    }
    function Ra(lt, Ot, At) {
      for (var xe = At - 1, Ve = lt.length; ++xe < Ve; )
        if (lt[xe] === Ot)
          return xe;
      return -1;
    }
    function ba(lt, Ot, At) {
      for (var xe = At + 1; xe--; )
        if (lt[xe] === Ot)
          return xe;
      return xe;
    }
    function wr(lt) {
      return lr(lt) ? Ts(lt) : Dr(lt);
    }
    function Gn(lt) {
      return lr(lt) ? Qn(lt) : Ll(lt);
    }
    function Ms(lt) {
      for (var Ot = lt.length; Ot-- && Ja.test(lt.charAt(Ot)); )
        ;
      return Ot;
    }
    var Oa = Jr(qs);
    function Ts(lt) {
      for (var Ot = ho.lastIndex = 0; ho.test(lt); )
        ++Ot;
      return Ot;
    }
    function Qn(lt) {
      return lt.match(ho) || [];
    }
    function ah(lt) {
      return lt.match(Vs) || [];
    }
    var lh = function lt(Ot) {
      Ot = Ot == null ? Ji : vo.defaults(Ji.Object(), Ot, vo.pick(Ji, js));
      var At = Ot.Array, xe = Ot.Date, Ve = Ot.Error, _i = Ot.Function, Xi = Ot.Math, he = Ot.Object, In = Ot.RegExp, Ss = Ot.String, Hn = Ot.TypeError, fn = At.prototype, Rl = _i.prototype, Br = he.prototype, yo = Ot["__core-js_shared__"], kn = Rl.toString, si = Br.hasOwnProperty, Vn = 0, ur = function() {
        var r = /[^.]+$/.exec(yo && yo.keys && yo.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : "";
      }(), Wn = Br.toString, Ur = kn.call(he), Mr = Ji._, Kr = In(
        "^" + kn.call(si).replace(Gs, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), jn = bo ? Ot.Buffer : y, Dn = Ot.Symbol, Bi = Ot.Uint8Array, Ks = jn ? jn.allocUnsafe : y, Fr = Qs(he.getPrototypeOf, he), ta = he.create, ea = Br.propertyIsEnumerable, Wo = fn.splice, Es = Dn ? Dn.isConcatSpreadable : y, _o = Dn ? Dn.iterator : y, Gr = Dn ? Dn.toStringTag : y, jo = function() {
        try {
          var r = ya(he, "defineProperty");
          return r({}, "", {}), r;
        } catch {
        }
      }(), Ia = Ot.clearTimeout !== Ji.clearTimeout && Ot.clearTimeout, Da = xe && xe.now !== Ji.Date.now && xe.now, il = Ot.setTimeout !== Ji.setTimeout && Ot.setTimeout, to = Xi.ceil, Xo = Xi.floor, ia = he.getOwnPropertySymbols, nl = jn ? jn.isBuffer : y, za = Ot.isFinite, rl = fn.join, bl = Qs(he.keys, he), $i = Xi.max, Sn = Xi.min, na = xe.now, ol = Ot.parseInt, Na = Xi.random, As = fn.reverse, ra = ya(Ot, "DataView"), qo = ya(Ot, "Map"), oa = ya(Ot, "Promise"), Yo = ya(Ot, "Set"), an = ya(Ot, "WeakMap"), Ps = ya(he, "create"), sa = an && new an(), xo = {}, Ba = _a(ra), sl = _a(qo), al = _a(oa), ll = _a(Yo), Ol = _a(an), aa = Dn ? Dn.prototype : y, Zo = aa ? aa.valueOf : y, hl = aa ? aa.toString : y;
      function O(r) {
        if (pn(r) && !ei(r) && !(r instanceof ni)) {
          if (r instanceof Pn)
            return r;
          if (si.call(r, "__wrapped__"))
            return tu(r);
        }
        return new Pn(r);
      }
      var wo = function() {
        function r() {
        }
        return function(a) {
          if (!en(a))
            return {};
          if (ta)
            return ta(a);
          r.prototype = a;
          var u = new r();
          return r.prototype = y, u;
        };
      }();
      function Ls() {
      }
      function Pn(r, a) {
        this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!a, this.__index__ = 0, this.__values__ = y;
      }
      O.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: wa,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: on,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ss,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: O
        }
      }, O.prototype = Ls.prototype, O.prototype.constructor = O, Pn.prototype = wo(Ls.prototype), Pn.prototype.constructor = Pn;
      function ni(r) {
        this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = $e, this.__views__ = [];
      }
      function Cs() {
        var r = new ni(this.__wrapped__);
        return r.__actions__ = Nn(this.__actions__), r.__dir__ = this.__dir__, r.__filtered__ = this.__filtered__, r.__iteratees__ = Nn(this.__iteratees__), r.__takeCount__ = this.__takeCount__, r.__views__ = Nn(this.__views__), r;
      }
      function Il() {
        if (this.__filtered__) {
          var r = new ni(this);
          r.__dir__ = -1, r.__filtered__ = !0;
        } else
          r = this.clone(), r.__dir__ *= -1;
        return r;
      }
      function Rs() {
        var r = this.__wrapped__.value(), a = this.__dir__, u = ei(r), m = a < 0, L = u ? r.length : 0, G = Vu(0, L, this.__views__), J = G.start, ot = G.end, mt = ot - J, Ht = m ? ot : J - 1, jt = this.__iteratees__, Jt = jt.length, ve = 0, De = Sn(mt, this.__takeCount__);
        if (!u || !m && L == mt && De == mt)
          return He(r, this.__actions__);
        var je = [];
        t:
          for (; mt-- && ve < De; ) {
            Ht += a;
            for (var ai = -1, Xe = r[Ht]; ++ai < Jt; ) {
              var fi = jt[ai], xi = fi.iteratee, Er = fi.type, nr = xi(Xe);
              if (Er == we)
                Xe = nr;
              else if (!nr) {
                if (Er == se)
                  continue t;
                break t;
              }
            }
            je[ve++] = Xe;
          }
        return je;
      }
      ni.prototype = wo(Ls.prototype), ni.prototype.constructor = ni;
      function cr(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.clear(); ++a < u; ) {
          var m = r[a];
          this.set(m[0], m[1]);
        }
      }
      function bs() {
        this.__data__ = Ps ? Ps(null) : {}, this.size = 0;
      }
      function Os(r) {
        var a = this.has(r) && delete this.__data__[r];
        return this.size -= a ? 1 : 0, a;
      }
      function la(r) {
        var a = this.__data__;
        if (Ps) {
          var u = a[r];
          return u === nt ? y : u;
        }
        return si.call(a, r) ? a[r] : y;
      }
      function Ua(r) {
        var a = this.__data__;
        return Ps ? a[r] !== y : si.call(a, r);
      }
      function ha(r, a) {
        var u = this.__data__;
        return this.size += this.has(r) ? 0 : 1, u[r] = Ps && a === y ? nt : a, this;
      }
      cr.prototype.clear = bs, cr.prototype.delete = Os, cr.prototype.get = la, cr.prototype.has = Ua, cr.prototype.set = ha;
      function Xn(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.clear(); ++a < u; ) {
          var m = r[a];
          this.set(m[0], m[1]);
        }
      }
      function ua() {
        this.__data__ = [], this.size = 0;
      }
      function eo(r) {
        var a = this.__data__, u = fa(a, r);
        if (u < 0)
          return !1;
        var m = a.length - 1;
        return u == m ? a.pop() : Wo.call(a, u, 1), --this.size, !0;
      }
      function ca(r) {
        var a = this.__data__, u = fa(a, r);
        return u < 0 ? y : a[u][1];
      }
      function pa(r) {
        return fa(this.__data__, r) > -1;
      }
      function io(r, a) {
        var u = this.__data__, m = fa(u, r);
        return m < 0 ? (++this.size, u.push([r, a])) : u[m][1] = a, this;
      }
      Xn.prototype.clear = ua, Xn.prototype.delete = eo, Xn.prototype.get = ca, Xn.prototype.has = pa, Xn.prototype.set = io;
      function Kn(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.clear(); ++a < u; ) {
          var m = r[a];
          this.set(m[0], m[1]);
        }
      }
      function Dl() {
        this.size = 0, this.__data__ = {
          hash: new cr(),
          map: new (qo || Xn)(),
          string: new cr()
        };
      }
      function zl(r) {
        var a = jl(this, r).delete(r);
        return this.size -= a ? 1 : 0, a;
      }
      function ul(r) {
        return jl(this, r).get(r);
      }
      function Je(r) {
        return jl(this, r).has(r);
      }
      function Mo(r, a) {
        var u = jl(this, r), m = u.size;
        return u.set(r, a), this.size += u.size == m ? 0 : 1, this;
      }
      Kn.prototype.clear = Dl, Kn.prototype.delete = zl, Kn.prototype.get = ul, Kn.prototype.has = Je, Kn.prototype.set = Mo;
      function Jo(r) {
        var a = -1, u = r == null ? 0 : r.length;
        for (this.__data__ = new Kn(); ++a < u; )
          this.add(r[a]);
      }
      function li(r) {
        return this.__data__.set(r, nt), this;
      }
      function vn(r) {
        return this.__data__.has(r);
      }
      Jo.prototype.add = Jo.prototype.push = li, Jo.prototype.has = vn;
      function Tr(r) {
        var a = this.__data__ = new Xn(r);
        this.size = a.size;
      }
      function Re() {
        this.__data__ = new Xn(), this.size = 0;
      }
      function Hr(r) {
        var a = this.__data__, u = a.delete(r);
        return this.size = a.size, u;
      }
      function hh(r) {
        return this.__data__.get(r);
      }
      function uh(r) {
        return this.__data__.has(r);
      }
      function ch(r, a) {
        var u = this.__data__;
        if (u instanceof Xn) {
          var m = u.__data__;
          if (!qo || m.length < gt - 1)
            return m.push([r, a]), this.size = ++u.size, this;
          u = this.__data__ = new Kn(m);
        }
        return u.set(r, a), this.size = u.size, this;
      }
      Tr.prototype.clear = Re, Tr.prototype.delete = Hr, Tr.prototype.get = hh, Tr.prototype.has = uh, Tr.prototype.set = ch;
      function Nl(r, a) {
        var u = ei(r), m = !u && xa(r), L = !u && !m && Fs(r), G = !u && !m && !L && qa(r), J = u || m || L || G, ot = J ? $r(r.length, Ss) : [], mt = ot.length;
        for (var Ht in r)
          (a || si.call(r, Ht)) && !(J && // Safari 9 has enumerable `arguments.length` in strict mode.
          (Ht == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          L && (Ht == "offset" || Ht == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          G && (Ht == "buffer" || Ht == "byteLength" || Ht == "byteOffset") || // Skip index properties.
          es(Ht, mt))) && ot.push(Ht);
        return ot;
      }
      function cl(r) {
        var a = r.length;
        return a ? r[$t(0, a - 1)] : y;
      }
      function ph(r, a) {
        return Xl(Nn(r), To(a, 0, r.length));
      }
      function Bl(r) {
        return Xl(Nn(r));
      }
      function Fa(r, a, u) {
        (u !== y && !so(r[a], u) || u === y && !(a in r)) && no(r, a, u);
      }
      function Is(r, a, u) {
        var m = r[a];
        (!(si.call(r, a) && so(m, u)) || u === y && !(a in r)) && no(r, a, u);
      }
      function fa(r, a) {
        for (var u = r.length; u--; )
          if (so(r[u][0], a))
            return u;
        return -1;
      }
      function Ul(r, a, u, m) {
        return Qi(r, function(L, G, J) {
          a(m, L, u(L), J);
        }), m;
      }
      function pl(r, a) {
        return r && dn(a, Rn(a), r);
      }
      function fl(r, a) {
        return r && dn(a, mr(a), r);
      }
      function no(r, a, u) {
        a == "__proto__" && jo ? jo(r, a, {
          configurable: !0,
          enumerable: !0,
          value: u,
          writable: !0
        }) : r[a] = u;
      }
      function dl(r, a) {
        for (var u = -1, m = a.length, L = At(m), G = r == null; ++u < m; )
          L[u] = G ? y : Lh(r, a[u]);
        return L;
      }
      function To(r, a, u) {
        return r === r && (u !== y && (r = r <= u ? r : u), a !== y && (r = r >= a ? r : a)), r;
      }
      function tr(r, a, u, m, L, G) {
        var J, ot = a & vt, mt = a & Nt, Ht = a & Ut;
        if (u && (J = L ? u(r, m, L, G) : u(r)), J !== y)
          return J;
        if (!en(r))
          return r;
        var jt = ei(r);
        if (jt) {
          if (J = ju(r), !ot)
            return Nn(r, J);
        } else {
          var Jt = Yn(r), ve = Jt == Pr || Jt == Zn;
          if (Fs(r))
            return ro(r, ot);
          if (Jt == Ze || Jt == Oe || ve && !L) {
            if (J = mt || ve ? {} : jh(r), !ot)
              return mt ? kl(r, fl(J, r)) : Wr(r, pl(J, r));
          } else {
            if (!ri[Jt])
              return L ? r : {};
            J = Xu(r, Jt, ot);
          }
        }
        G || (G = new Tr());
        var De = G.get(r);
        if (De)
          return De;
        G.set(r, J), xu(r) ? r.forEach(function(Xe) {
          J.add(tr(Xe, a, u, Xe, r, G));
        }) : yu(r) && r.forEach(function(Xe, fi) {
          J.set(fi, tr(Xe, a, u, fi, r, G));
        });
        var je = Ht ? mt ? dh : fh : mt ? mr : Rn, ai = jt ? y : je(r);
        return Di(ai || r, function(Xe, fi) {
          ai && (fi = Xe, Xe = r[fi]), Is(J, fi, tr(Xe, a, u, fi, r, G));
        }), J;
      }
      function Ds(r) {
        var a = Rn(r);
        return function(u) {
          return Fl(u, r, a);
        };
      }
      function Fl(r, a, u) {
        var m = u.length;
        if (r == null)
          return !m;
        for (r = he(r); m--; ) {
          var L = u[m], G = a[L], J = r[L];
          if (J === y && !(L in r) || !G(J))
            return !1;
        }
        return !0;
      }
      function kr(r, a, u) {
        if (typeof r != "function")
          throw new Hn(Mt);
        return Ml(function() {
          r.apply(y, u);
        }, a);
      }
      function da(r, a, u, m) {
        var L = -1, G = Zs, J = !0, ot = r.length, mt = [], Ht = a.length;
        if (!ot)
          return mt;
        u && (a = Ri(a, Mn(u))), m ? (G = La, J = !1) : a.length >= gt && (G = zr, J = !1, a = new Jo(a));
        t:
          for (; ++L < ot; ) {
            var jt = r[L], Jt = u == null ? jt : u(jt);
            if (jt = m || jt !== 0 ? jt : 0, J && Jt === Jt) {
              for (var ve = Ht; ve--; )
                if (a[ve] === Jt)
                  continue t;
              mt.push(jt);
            } else
              G(a, Jt, m) || mt.push(jt);
          }
        return mt;
      }
      var Qi = H(fr), Gl = H(Ha, !0);
      function Ln(r, a) {
        var u = !0;
        return Qi(r, function(m, L, G) {
          return u = !!a(m, L, G), u;
        }), u;
      }
      function Vr(r, a, u) {
        for (var m = -1, L = r.length; ++m < L; ) {
          var G = r[m], J = a(G);
          if (J != null && (ot === y ? J === J && !Sr(J) : u(J, ot)))
            var ot = J, mt = G;
        }
        return mt;
      }
      function zn(r, a, u, m) {
        var L = r.length;
        for (u = oi(u), u < 0 && (u = -u > L ? 0 : L + u), m = m === y || m > L ? L : oi(m), m < 0 && (m += L), m = u > m ? 0 : Mu(m); u < m; )
          r[u++] = a;
        return r;
      }
      function pr(r, a) {
        var u = [];
        return Qi(r, function(m, L, G) {
          a(m, L, G) && u.push(m);
        }), u;
      }
      function ln(r, a, u, m, L) {
        var G = -1, J = r.length;
        for (u || (u = Yu), L || (L = []); ++G < J; ) {
          var ot = r[G];
          a > 0 && u(ot) ? a > 1 ? ln(ot, a - 1, u, m, L) : Ir(L, ot) : m || (L[L.length] = ot);
        }
        return L;
      }
      var ma = tt(), Ga = tt(!0);
      function fr(r, a) {
        return r && ma(r, a, Rn);
      }
      function Ha(r, a) {
        return r && Ga(r, a, Rn);
      }
      function $o(r, a) {
        return sr(a, function(u) {
          return is(r[u]);
        });
      }
      function So(r, a) {
        a = Ie(a, r);
        for (var u = 0, m = a.length; r != null && u < m; )
          r = r[Ao(a[u++])];
        return u && u == m ? r : y;
      }
      function Hl(r, a, u) {
        var m = a(r);
        return ei(r) ? m : Ir(m, u(r));
      }
      function Cn(r) {
        return r == null ? r === y ? j : rn : Gr && Gr in he(r) ? ku(r) : ec(r);
      }
      function ka(r, a) {
        return r > a;
      }
      function Va(r, a) {
        return r != null && si.call(r, a);
      }
      function ml(r, a) {
        return r != null && a in he(r);
      }
      function Wa(r, a, u) {
        return r >= Sn(a, u) && r < $i(a, u);
      }
      function ga(r, a, u) {
        for (var m = u ? La : Zs, L = r[0].length, G = r.length, J = G, ot = At(G), mt = 1 / 0, Ht = []; J--; ) {
          var jt = r[J];
          J && a && (jt = Ri(jt, Mn(a))), mt = Sn(jt.length, mt), ot[J] = !u && (a || L >= 120 && jt.length >= 120) ? new Jo(J && jt) : y;
        }
        jt = r[0];
        var Jt = -1, ve = ot[0];
        t:
          for (; ++Jt < L && Ht.length < mt; ) {
            var De = jt[Jt], je = a ? a(De) : De;
            if (De = u || De !== 0 ? De : 0, !(ve ? zr(ve, je) : m(Ht, je, u))) {
              for (J = G; --J; ) {
                var ai = ot[J];
                if (!(ai ? zr(ai, je) : m(r[J], je, u)))
                  continue t;
              }
              ve && ve.push(je), Ht.push(De);
            }
          }
        return Ht;
      }
      function t(r, a, u, m) {
        return fr(r, function(L, G, J) {
          a(m, u(L), G, J);
        }), m;
      }
      function e(r, a, u) {
        a = Ie(a, r), r = Zh(r, a);
        var m = r == null ? r : r[Ao(Xr(a))];
        return m == null ? y : $n(m, r, u);
      }
      function i(r) {
        return pn(r) && Cn(r) == Oe;
      }
      function n(r) {
        return pn(r) && Cn(r) == Lt;
      }
      function o(r) {
        return pn(r) && Cn(r) == ui;
      }
      function s(r, a, u, m, L) {
        return r === a ? !0 : r == null || a == null || !pn(r) && !pn(a) ? r !== r && a !== a : l(r, a, u, m, s, L);
      }
      function l(r, a, u, m, L, G) {
        var J = ei(r), ot = ei(a), mt = J ? Ai : Yn(r), Ht = ot ? Ai : Yn(a);
        mt = mt == Oe ? Ze : mt, Ht = Ht == Oe ? Ze : Ht;
        var jt = mt == Ze, Jt = Ht == Ze, ve = mt == Ht;
        if (ve && Fs(r)) {
          if (!Fs(a))
            return !1;
          J = !0, jt = !1;
        }
        if (ve && !jt)
          return G || (G = new Tr()), J || qa(r) ? kh(r, a, u, m, L, G) : Gu(r, a, mt, u, m, L, G);
        if (!(u & Ct)) {
          var De = jt && si.call(r, "__wrapped__"), je = Jt && si.call(a, "__wrapped__");
          if (De || je) {
            var ai = De ? r.value() : r, Xe = je ? a.value() : a;
            return G || (G = new Tr()), L(ai, Xe, u, m, G);
          }
        }
        return ve ? (G || (G = new Tr()), Hu(r, a, u, m, L, G)) : !1;
      }
      function h(r) {
        return pn(r) && Yn(r) == Fi;
      }
      function c(r, a, u, m) {
        var L = u.length, G = L, J = !m;
        if (r == null)
          return !G;
        for (r = he(r); L--; ) {
          var ot = u[L];
          if (J && ot[2] ? ot[1] !== r[ot[0]] : !(ot[0] in r))
            return !1;
        }
        for (; ++L < G; ) {
          ot = u[L];
          var mt = ot[0], Ht = r[mt], jt = ot[1];
          if (J && ot[2]) {
            if (Ht === y && !(mt in r))
              return !1;
          } else {
            var Jt = new Tr();
            if (m)
              var ve = m(Ht, jt, mt, r, a, Jt);
            if (!(ve === y ? s(jt, Ht, Ct | at, m, Jt) : ve))
              return !1;
          }
        }
        return !0;
      }
      function p(r) {
        if (!en(r) || Ju(r))
          return !1;
        var a = is(r) ? Kr : Lo;
        return a.test(_a(r));
      }
      function f(r) {
        return pn(r) && Cn(r) == Fn;
      }
      function d(r) {
        return pn(r) && Yn(r) == Ni;
      }
      function v(r) {
        return pn(r) && Ql(r.length) && !!Li[Cn(r)];
      }
      function w(r) {
        return typeof r == "function" ? r : r == null ? gr : typeof r == "object" ? ei(r) ? st(r[0], r[1]) : W(r) : Iu(r);
      }
      function P(r) {
        if (!wl(r))
          return bl(r);
        var a = [];
        for (var u in he(r))
          si.call(r, u) && u != "constructor" && a.push(u);
        return a;
      }
      function R(r) {
        if (!en(r))
          return tc(r);
        var a = wl(r), u = [];
        for (var m in r)
          m == "constructor" && (a || !si.call(r, m)) || u.push(m);
        return u;
      }
      function I(r, a) {
        return r < a;
      }
      function Q(r, a) {
        var u = -1, m = dr(r) ? At(r.length) : [];
        return Qi(r, function(L, G, J) {
          m[++u] = a(L, G, J);
        }), m;
      }
      function W(r) {
        var a = gh(r);
        return a.length == 1 && a[0][2] ? qh(a[0][0], a[0][1]) : function(u) {
          return u === r || c(u, r, a);
        };
      }
      function st(r, a) {
        return yh(r) && Xh(a) ? qh(Ao(r), a) : function(u) {
          var m = Lh(u, r);
          return m === y && m === a ? Ch(u, r) : s(a, m, Ct | at);
        };
      }
      function K(r, a, u, m, L) {
        r !== a && ma(a, function(G, J) {
          if (L || (L = new Tr()), en(G))
            wt(r, a, J, u, K, m, L);
          else {
            var ot = m ? m(xh(r, J), G, J + "", r, a, L) : y;
            ot === y && (ot = G), Fa(r, J, ot);
          }
        }, mr);
      }
      function wt(r, a, u, m, L, G, J) {
        var ot = xh(r, u), mt = xh(a, u), Ht = J.get(mt);
        if (Ht) {
          Fa(r, u, Ht);
          return;
        }
        var jt = G ? G(ot, mt, u + "", r, a, J) : y, Jt = jt === y;
        if (Jt) {
          var ve = ei(mt), De = !ve && Fs(mt), je = !ve && !De && qa(mt);
          jt = mt, ve || De || je ? ei(ot) ? jt = ot : mn(ot) ? jt = Nn(ot) : De ? (Jt = !1, jt = ro(mt, !0)) : je ? (Jt = !1, jt = va(mt, !0)) : jt = [] : Tl(mt) || xa(mt) ? (jt = ot, xa(ot) ? jt = Tu(ot) : (!en(ot) || is(ot)) && (jt = jh(mt))) : Jt = !1;
        }
        Jt && (J.set(mt, jt), L(jt, mt, m, G, J), J.delete(mt)), Fa(r, u, jt);
      }
      function C(r, a) {
        var u = r.length;
        if (u)
          return a += a < 0 ? u : 0, es(a, u) ? r[a] : y;
      }
      function D(r, a, u) {
        a.length ? a = Ri(a, function(G) {
          return ei(G) ? function(J) {
            return So(J, G.length === 1 ? G[0] : G);
          } : G;
        }) : a = [gr];
        var m = -1;
        a = Ri(a, Mn(ke()));
        var L = Q(r, function(G, J, ot) {
          var mt = Ri(a, function(Ht) {
            return Ht(G);
          });
          return { criteria: mt, index: ++m, value: G };
        });
        return Cl(L, function(G, J) {
          return Eo(G, J, u);
        });
      }
      function ct(r, a) {
        return Dt(r, a, function(u, m) {
          return Ch(r, m);
        });
      }
      function Dt(r, a, u) {
        for (var m = -1, L = a.length, G = {}; ++m < L; ) {
          var J = a[m], ot = So(r, J);
          u(ot, J) && Ye(G, Ie(J, r), ot);
        }
        return G;
      }
      function bt(r) {
        return function(a) {
          return So(a, r);
        };
      }
      function St(r, a, u, m) {
        var L = m ? $s : ar, G = -1, J = a.length, ot = r;
        for (r === a && (a = Nn(a)), u && (ot = Ri(r, Mn(u))); ++G < J; )
          for (var mt = 0, Ht = a[G], jt = u ? u(Ht) : Ht; (mt = L(ot, jt, mt, m)) > -1; )
            ot !== r && Wo.call(ot, mt, 1), Wo.call(r, mt, 1);
        return r;
      }
      function oe(r, a) {
        for (var u = r ? a.length : 0, m = u - 1; u--; ) {
          var L = a[u];
          if (u == m || L !== G) {
            var G = L;
            es(L) ? Wo.call(r, L, 1) : Ei(r, L);
          }
        }
        return r;
      }
      function $t(r, a) {
        return r + Xo(Na() * (a - r + 1));
      }
      function me(r, a, u, m) {
        for (var L = -1, G = $i(to((a - r) / (u || 1)), 0), J = At(G); G--; )
          J[m ? G : ++L] = r, r += u;
        return J;
      }
      function ue(r, a) {
        var u = "";
        if (!r || a < 1 || a > ze)
          return u;
        do
          a % 2 && (u += r), a = Xo(a / 2), a && (r += r);
        while (a);
        return u;
      }
      function Wt(r, a) {
        return wh(Yh(r, a, gr), r + "");
      }
      function Ee(r) {
        return cl(Ya(r));
      }
      function Be(r, a) {
        var u = Ya(r);
        return Xl(u, To(a, 0, u.length));
      }
      function Ye(r, a, u, m) {
        if (!en(r))
          return r;
        a = Ie(a, r);
        for (var L = -1, G = a.length, J = G - 1, ot = r; ot != null && ++L < G; ) {
          var mt = Ao(a[L]), Ht = u;
          if (mt === "__proto__" || mt === "constructor" || mt === "prototype")
            return r;
          if (L != J) {
            var jt = ot[mt];
            Ht = m ? m(jt, mt, ot) : y, Ht === y && (Ht = en(jt) ? jt : es(a[L + 1]) ? [] : {});
          }
          Is(ot, mt, Ht), ot = ot[mt];
        }
        return r;
      }
      var hn = sa ? function(r, a) {
        return sa.set(r, a), r;
      } : gr, Ki = jo ? function(r, a) {
        return jo(r, "toString", {
          configurable: !0,
          enumerable: !1,
          value: bh(a),
          writable: !0
        });
      } : gr;
      function Ci(r) {
        return Xl(Ya(r));
      }
      function Si(r, a, u) {
        var m = -1, L = r.length;
        a < 0 && (a = -a > L ? 0 : L + a), u = u > L ? L : u, u < 0 && (u += L), L = a > u ? 0 : u - a >>> 0, a >>>= 0;
        for (var G = At(L); ++m < L; )
          G[m] = r[m + a];
        return G;
      }
      function ki(r, a) {
        var u;
        return Qi(r, function(m, L, G) {
          return u = a(m, L, G), !u;
        }), !!u;
      }
      function un(r, a, u) {
        var m = 0, L = r == null ? m : r.length;
        if (typeof a == "number" && a === a && L <= En) {
          for (; m < L; ) {
            var G = m + L >>> 1, J = r[G];
            J !== null && !Sr(J) && (u ? J <= a : J < a) ? m = G + 1 : L = G;
          }
          return L;
        }
        return ce(r, a, gr, u);
      }
      function ce(r, a, u, m) {
        var L = 0, G = r == null ? 0 : r.length;
        if (G === 0)
          return 0;
        a = u(a);
        for (var J = a !== a, ot = a === null, mt = Sr(a), Ht = a === y; L < G; ) {
          var jt = Xo((L + G) / 2), Jt = u(r[jt]), ve = Jt !== y, De = Jt === null, je = Jt === Jt, ai = Sr(Jt);
          if (J)
            var Xe = m || je;
          else
            Ht ? Xe = je && (m || ve) : ot ? Xe = je && ve && (m || !De) : mt ? Xe = je && ve && !De && (m || !ai) : De || ai ? Xe = !1 : Xe = m ? Jt <= a : Jt < a;
          Xe ? L = jt + 1 : G = jt;
        }
        return Sn(G, Oi);
      }
      function Ue(r, a) {
        for (var u = -1, m = r.length, L = 0, G = []; ++u < m; ) {
          var J = r[u], ot = a ? a(J) : J;
          if (!u || !so(ot, mt)) {
            var mt = ot;
            G[L++] = J === 0 ? 0 : J;
          }
        }
        return G;
      }
      function yt(r) {
        return typeof r == "number" ? r : Sr(r) ? Ft : +r;
      }
      function be(r) {
        if (typeof r == "string")
          return r;
        if (ei(r))
          return Ri(r, be) + "";
        if (Sr(r))
          return hl ? hl.call(r) : "";
        var a = r + "";
        return a == "0" && 1 / r == -ie ? "-0" : a;
      }
      function Fe(r, a, u) {
        var m = -1, L = Zs, G = r.length, J = !0, ot = [], mt = ot;
        if (u)
          J = !1, L = La;
        else if (G >= gt) {
          var Ht = a ? null : Us(r);
          if (Ht)
            return Vo(Ht);
          J = !1, L = zr, mt = new Jo();
        } else
          mt = a ? [] : ot;
        t:
          for (; ++m < G; ) {
            var jt = r[m], Jt = a ? a(jt) : jt;
            if (jt = u || jt !== 0 ? jt : 0, J && Jt === Jt) {
              for (var ve = mt.length; ve--; )
                if (mt[ve] === Jt)
                  continue t;
              a && mt.push(Jt), ot.push(jt);
            } else
              L(mt, Jt, u) || (mt !== ot && mt.push(Jt), ot.push(jt));
          }
        return ot;
      }
      function Ei(r, a) {
        return a = Ie(a, r), r = Zh(r, a), r == null || delete r[Ao(Xr(a))];
      }
      function pe(r, a, u, m) {
        return Ye(r, a, u(So(r, a)), m);
      }
      function Ce(r, a, u, m) {
        for (var L = r.length, G = m ? L : -1; (m ? G-- : ++G < L) && a(r[G], G, r); )
          ;
        return u ? Si(r, m ? 0 : G, m ? G + 1 : L) : Si(r, m ? G + 1 : 0, m ? L : G);
      }
      function He(r, a) {
        var u = r;
        return u instanceof ni && (u = u.value()), Ca(a, function(m, L) {
          return L.func.apply(L.thisArg, Ir([m], L.args));
        }, u);
      }
      function pi(r, a, u) {
        var m = r.length;
        if (m < 2)
          return m ? Fe(r[0]) : [];
        for (var L = -1, G = At(m); ++L < m; )
          for (var J = r[L], ot = -1; ++ot < m; )
            ot != L && (G[L] = da(G[L] || J, r[ot], a, u));
        return Fe(ln(G, 1), a, u);
      }
      function hi(r, a, u) {
        for (var m = -1, L = r.length, G = a.length, J = {}; ++m < L; ) {
          var ot = m < G ? a[m] : y;
          u(J, r[m], ot);
        }
        return J;
      }
      function Bt(r) {
        return mn(r) ? r : [];
      }
      function Ge(r) {
        return typeof r == "function" ? r : gr;
      }
      function Ie(r, a) {
        return ei(r) ? r : yh(r, a) ? [r] : Kh(bi(r));
      }
      var We = Wt;
      function tn(r, a, u) {
        var m = r.length;
        return u = u === y ? m : u, !a && u >= m ? r : Si(r, a, u);
      }
      var cn = Ia || function(r) {
        return Ji.clearTimeout(r);
      };
      function ro(r, a) {
        if (a)
          return r.slice();
        var u = r.length, m = Ks ? Ks(u) : new r.constructor(u);
        return r.copy(m), m;
      }
      function zs(r) {
        var a = new r.constructor(r.byteLength);
        return new Bi(a).set(new Bi(r)), a;
      }
      function gl(r, a) {
        var u = a ? zs(r.buffer) : r.buffer;
        return new r.constructor(u, r.byteOffset, r.byteLength);
      }
      function Ns(r) {
        var a = new r.constructor(r.source, Ta.exec(r));
        return a.lastIndex = r.lastIndex, a;
      }
      function Qo(r) {
        return Zo ? he(Zo.call(r)) : {};
      }
      function va(r, a) {
        var u = a ? zs(r.buffer) : r.buffer;
        return new r.constructor(u, r.byteOffset, r.length);
      }
      function Ko(r, a) {
        if (r !== a) {
          var u = r !== y, m = r === null, L = r === r, G = Sr(r), J = a !== y, ot = a === null, mt = a === a, Ht = Sr(a);
          if (!ot && !Ht && !G && r > a || G && J && mt && !ot && !Ht || m && J && mt || !u && mt || !L)
            return 1;
          if (!m && !G && !Ht && r < a || Ht && u && L && !m && !G || ot && u && L || !J && L || !mt)
            return -1;
        }
        return 0;
      }
      function Eo(r, a, u) {
        for (var m = -1, L = r.criteria, G = a.criteria, J = L.length, ot = u.length; ++m < J; ) {
          var mt = Ko(L[m], G[m]);
          if (mt) {
            if (m >= ot)
              return mt;
            var Ht = u[m];
            return mt * (Ht == "desc" ? -1 : 1);
          }
        }
        return r.index - a.index;
      }
      function vl(r, a, u, m) {
        for (var L = -1, G = r.length, J = u.length, ot = -1, mt = a.length, Ht = $i(G - J, 0), jt = At(mt + Ht), Jt = !m; ++ot < mt; )
          jt[ot] = a[ot];
        for (; ++L < J; )
          (Jt || L < G) && (jt[u[L]] = r[L]);
        for (; Ht--; )
          jt[ot++] = r[L++];
        return jt;
      }
      function yl(r, a, u, m) {
        for (var L = -1, G = r.length, J = -1, ot = u.length, mt = -1, Ht = a.length, jt = $i(G - ot, 0), Jt = At(jt + Ht), ve = !m; ++L < jt; )
          Jt[L] = r[L];
        for (var De = L; ++mt < Ht; )
          Jt[De + mt] = a[mt];
        for (; ++J < ot; )
          (ve || L < G) && (Jt[De + u[J]] = r[L++]);
        return Jt;
      }
      function Nn(r, a) {
        var u = -1, m = r.length;
        for (a || (a = At(m)); ++u < m; )
          a[u] = r[u];
        return a;
      }
      function dn(r, a, u, m) {
        var L = !u;
        u || (u = {});
        for (var G = -1, J = a.length; ++G < J; ) {
          var ot = a[G], mt = m ? m(u[ot], r[ot], ot, u, r) : y;
          mt === y && (mt = r[ot]), L ? no(u, ot, mt) : Is(u, ot, mt);
        }
        return u;
      }
      function Wr(r, a) {
        return dn(r, vh(r), a);
      }
      function kl(r, a) {
        return dn(r, Vh(r), a);
      }
      function Bs(r, a) {
        return function(u, m) {
          var L = ei(u) ? Pa : Ul, G = a ? a() : {};
          return L(u, r, ke(m, 2), G);
        };
      }
      function oo(r) {
        return Wt(function(a, u) {
          var m = -1, L = u.length, G = L > 1 ? u[L - 1] : y, J = L > 2 ? u[2] : y;
          for (G = r.length > 3 && typeof G == "function" ? (L--, G) : y, J && ir(u[0], u[1], J) && (G = L < 3 ? y : G, L = 1), a = he(a); ++m < L; ) {
            var ot = u[m];
            ot && r(a, ot, m, G);
          }
          return a;
        });
      }
      function H(r, a) {
        return function(u, m) {
          if (u == null)
            return u;
          if (!dr(u))
            return r(u, m);
          for (var L = u.length, G = a ? L : -1, J = he(u); (a ? G-- : ++G < L) && m(J[G], G, J) !== !1; )
            ;
          return u;
        };
      }
      function tt(r) {
        return function(a, u, m) {
          for (var L = -1, G = he(a), J = m(a), ot = J.length; ot--; ) {
            var mt = J[r ? ot : ++L];
            if (u(G[mt], mt, G) === !1)
              break;
          }
          return a;
        };
      }
      function V(r, a, u) {
        var m = a & Y, L = Te(r);
        function G() {
          var J = this && this !== Ji && this instanceof G ? L : r;
          return J.apply(m ? u : this, arguments);
        }
        return G;
      }
      function ae(r) {
        return function(a) {
          a = bi(a);
          var u = lr(a) ? Gn(a) : y, m = u ? u[0] : a.charAt(0), L = u ? tn(u, 1).join("") : a.slice(1);
          return m[r]() + L;
        };
      }
      function ge(r) {
        return function(a) {
          return Ca(bu(Ru(a).replace(cs, "")), r, "");
        };
      }
      function Te(r) {
        return function() {
          var a = arguments;
          switch (a.length) {
            case 0:
              return new r();
            case 1:
              return new r(a[0]);
            case 2:
              return new r(a[0], a[1]);
            case 3:
              return new r(a[0], a[1], a[2]);
            case 4:
              return new r(a[0], a[1], a[2], a[3]);
            case 5:
              return new r(a[0], a[1], a[2], a[3], a[4]);
            case 6:
              return new r(a[0], a[1], a[2], a[3], a[4], a[5]);
            case 7:
              return new r(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
          }
          var u = wo(r.prototype), m = r.apply(u, a);
          return en(m) ? m : u;
        };
      }
      function le(r, a, u) {
        var m = Te(r);
        function L() {
          for (var G = arguments.length, J = At(G), ot = G, mt = Xa(L); ot--; )
            J[ot] = arguments[ot];
          var Ht = G < 3 && J[0] !== mt && J[G - 1] !== mt ? [] : hr(J, mt);
          if (G -= Ht.length, G < u)
            return xl(
              r,
              a,
              zi,
              L.placeholder,
              y,
              J,
              Ht,
              y,
              y,
              u - G
            );
          var jt = this && this !== Ji && this instanceof L ? m : r;
          return $n(jt, this, J);
        }
        return L;
      }
      function Ne(r) {
        return function(a, u, m) {
          var L = he(a);
          if (!dr(a)) {
            var G = ke(u, 3);
            a = Rn(a), u = function(ot) {
              return G(L[ot], ot, L);
            };
          }
          var J = r(a, u, m);
          return J > -1 ? L[G ? a[J] : J] : y;
        };
      }
      function di(r) {
        return ts(function(a) {
          var u = a.length, m = u, L = Pn.prototype.thru;
          for (r && a.reverse(); m--; ) {
            var G = a[m];
            if (typeof G != "function")
              throw new Hn(Mt);
            if (L && !J && Wl(G) == "wrapper")
              var J = new Pn([], !0);
          }
          for (m = J ? m : u; ++m < u; ) {
            G = a[m];
            var ot = Wl(G), mt = ot == "wrapper" ? mh(G) : y;
            mt && _h(mt[0]) && mt[1] == (X | B | Z | it) && !mt[4].length && mt[9] == 1 ? J = J[Wl(mt[0])].apply(J, mt[3]) : J = G.length == 1 && _h(G) ? J[ot]() : J.thru(G);
          }
          return function() {
            var Ht = arguments, jt = Ht[0];
            if (J && Ht.length == 1 && ei(jt))
              return J.plant(jt).value();
            for (var Jt = 0, ve = u ? a[Jt].apply(this, Ht) : jt; ++Jt < u; )
              ve = a[Jt].call(this, ve);
            return ve;
          };
        });
      }
      function zi(r, a, u, m, L, G, J, ot, mt, Ht) {
        var jt = a & X, Jt = a & Y, ve = a & _, De = a & (B | E), je = a & _t, ai = ve ? y : Te(r);
        function Xe() {
          for (var fi = arguments.length, xi = At(fi), Er = fi; Er--; )
            xi[Er] = arguments[Er];
          if (De)
            var nr = Xa(Xe), Ar = Nr(xi, nr);
          if (m && (xi = vl(xi, m, L, De)), G && (xi = yl(xi, G, J, De)), fi -= Ar, De && fi < Ht) {
            var gn = hr(xi, nr);
            return xl(
              r,
              a,
              zi,
              Xe.placeholder,
              u,
              xi,
              gn,
              ot,
              mt,
              Ht - fi
            );
          }
          var ao = Jt ? u : this, rs = ve ? ao[r] : r;
          return fi = xi.length, ot ? xi = ic(xi, ot) : je && fi > 1 && xi.reverse(), jt && mt < fi && (xi.length = mt), this && this !== Ji && this instanceof Xe && (rs = ai || Te(rs)), rs.apply(ao, xi);
        }
        return Xe;
      }
      function Qt(r, a) {
        return function(u, m) {
          return t(u, r, a(m), {});
        };
      }
      function er(r, a) {
        return function(u, m) {
          var L;
          if (u === y && m === y)
            return a;
          if (u !== y && (L = u), m !== y) {
            if (L === y)
              return m;
            typeof u == "string" || typeof m == "string" ? (u = be(u), m = be(m)) : (u = yt(u), m = yt(m)), L = r(u, m);
          }
          return L;
        };
      }
      function yn(r) {
        return ts(function(a) {
          return a = Ri(a, Mn(ke())), Wt(function(u) {
            var m = this;
            return r(a, function(L) {
              return $n(L, m, u);
            });
          });
        });
      }
      function Vi(r, a) {
        a = a === y ? " " : be(a);
        var u = a.length;
        if (u < 2)
          return u ? ue(a, r) : a;
        var m = ue(a, to(r / wr(a)));
        return lr(a) ? tn(Gn(m), 0, r).join("") : m.slice(0, r);
      }
      function qn(r, a, u, m) {
        var L = a & Y, G = Te(r);
        function J() {
          for (var ot = -1, mt = arguments.length, Ht = -1, jt = m.length, Jt = At(jt + mt), ve = this && this !== Ji && this instanceof J ? G : r; ++Ht < jt; )
            Jt[Ht] = m[Ht];
          for (; mt--; )
            Jt[Ht++] = arguments[++ot];
          return $n(ve, L ? u : this, Jt);
        }
        return J;
      }
      function _l(r) {
        return function(a, u, m) {
          return m && typeof m != "number" && ir(a, u, m) && (u = m = y), a = ns(a), u === y ? (u = a, a = 0) : u = ns(u), m = m === y ? a < u ? 1 : -1 : ns(m), me(a, u, m, r);
        };
      }
      function jr(r) {
        return function(a, u) {
          return typeof a == "string" && typeof u == "string" || (a = qr(a), u = qr(u)), r(a, u);
        };
      }
      function xl(r, a, u, m, L, G, J, ot, mt, Ht) {
        var jt = a & B, Jt = jt ? J : y, ve = jt ? y : J, De = jt ? G : y, je = jt ? y : G;
        a |= jt ? Z : z, a &= ~(jt ? z : Z), a & x || (a &= ~(Y | _));
        var ai = [
          r,
          a,
          L,
          De,
          Jt,
          je,
          ve,
          ot,
          mt,
          Ht
        ], Xe = u.apply(y, ai);
        return _h(r) && Jh(Xe, ai), Xe.placeholder = m, $h(Xe, r, a);
      }
      function ja(r) {
        var a = Xi[r];
        return function(u, m) {
          if (u = qr(u), m = m == null ? 0 : Sn(oi(m), 292), m && za(u)) {
            var L = (bi(u) + "e").split("e"), G = a(L[0] + "e" + (+L[1] + m));
            return L = (bi(G) + "e").split("e"), +(L[0] + "e" + (+L[1] - m));
          }
          return a(u);
        };
      }
      var Us = Yo && 1 / Vo(new Yo([, -0]))[1] == ie ? function(r) {
        return new Yo(r);
      } : Dh;
      function Vl(r) {
        return function(a) {
          var u = Yn(a);
          return u == Fi ? On(a) : u == Ni ? Tn(a) : Qr(a, r(a));
        };
      }
      function Bn(r, a, u, m, L, G, J, ot) {
        var mt = a & _;
        if (!mt && typeof r != "function")
          throw new Hn(Mt);
        var Ht = m ? m.length : 0;
        if (Ht || (a &= ~(Z | z), m = L = y), J = J === y ? J : $i(oi(J), 0), ot = ot === y ? ot : oi(ot), Ht -= L ? L.length : 0, a & z) {
          var jt = m, Jt = L;
          m = L = y;
        }
        var ve = mt ? y : mh(r), De = [
          r,
          a,
          u,
          m,
          L,
          jt,
          Jt,
          G,
          J,
          ot
        ];
        if (ve && Ku(De, ve), r = De[0], a = De[1], u = De[2], m = De[3], L = De[4], ot = De[9] = De[9] === y ? mt ? 0 : r.length : $i(De[9] - Ht, 0), !ot && a & (B | E) && (a &= ~(B | E)), !a || a == Y)
          var je = V(r, a, u);
        else
          a == B || a == E ? je = le(r, a, ot) : (a == Z || a == (Y | Z)) && !L.length ? je = qn(r, a, u, m) : je = zi.apply(y, De);
        var ai = ve ? hn : Jh;
        return $h(ai(je, De), r, a);
      }
      function Gh(r, a, u, m) {
        return r === y || so(r, Br[u]) && !si.call(m, u) ? a : r;
      }
      function Hh(r, a, u, m, L, G) {
        return en(r) && en(a) && (G.set(a, r), K(r, a, y, Hh, G), G.delete(a)), r;
      }
      function Fu(r) {
        return Tl(r) ? y : r;
      }
      function kh(r, a, u, m, L, G) {
        var J = u & Ct, ot = r.length, mt = a.length;
        if (ot != mt && !(J && mt > ot))
          return !1;
        var Ht = G.get(r), jt = G.get(a);
        if (Ht && jt)
          return Ht == a && jt == r;
        var Jt = -1, ve = !0, De = u & at ? new Jo() : y;
        for (G.set(r, a), G.set(a, r); ++Jt < ot; ) {
          var je = r[Jt], ai = a[Jt];
          if (m)
            var Xe = J ? m(ai, je, Jt, a, r, G) : m(je, ai, Jt, r, a, G);
          if (Xe !== y) {
            if (Xe)
              continue;
            ve = !1;
            break;
          }
          if (De) {
            if (!Zr(a, function(fi, xi) {
              if (!zr(De, xi) && (je === fi || L(je, fi, u, m, G)))
                return De.push(xi);
            })) {
              ve = !1;
              break;
            }
          } else if (!(je === ai || L(je, ai, u, m, G))) {
            ve = !1;
            break;
          }
        }
        return G.delete(r), G.delete(a), ve;
      }
      function Gu(r, a, u, m, L, G, J) {
        switch (u) {
          case Gt:
            if (r.byteLength != a.byteLength || r.byteOffset != a.byteOffset)
              return !1;
            r = r.buffer, a = a.buffer;
          case Lt:
            return !(r.byteLength != a.byteLength || !G(new Bi(r), new Bi(a)));
          case ii:
          case ui:
          case Un:
            return so(+r, +a);
          case vr:
            return r.name == a.name && r.message == a.message;
          case Fn:
          case A:
            return r == a + "";
          case Fi:
            var ot = On;
          case Ni:
            var mt = m & Ct;
            if (ot || (ot = Vo), r.size != a.size && !mt)
              return !1;
            var Ht = J.get(r);
            if (Ht)
              return Ht == a;
            m |= at, J.set(r, a);
            var jt = kh(ot(r), ot(a), m, L, G, J);
            return J.delete(r), jt;
          case k:
            if (Zo)
              return Zo.call(r) == Zo.call(a);
        }
        return !1;
      }
      function Hu(r, a, u, m, L, G) {
        var J = u & Ct, ot = fh(r), mt = ot.length, Ht = fh(a), jt = Ht.length;
        if (mt != jt && !J)
          return !1;
        for (var Jt = mt; Jt--; ) {
          var ve = ot[Jt];
          if (!(J ? ve in a : si.call(a, ve)))
            return !1;
        }
        var De = G.get(r), je = G.get(a);
        if (De && je)
          return De == a && je == r;
        var ai = !0;
        G.set(r, a), G.set(a, r);
        for (var Xe = J; ++Jt < mt; ) {
          ve = ot[Jt];
          var fi = r[ve], xi = a[ve];
          if (m)
            var Er = J ? m(xi, fi, ve, a, r, G) : m(fi, xi, ve, r, a, G);
          if (!(Er === y ? fi === xi || L(fi, xi, u, m, G) : Er)) {
            ai = !1;
            break;
          }
          Xe || (Xe = ve == "constructor");
        }
        if (ai && !Xe) {
          var nr = r.constructor, Ar = a.constructor;
          nr != Ar && "constructor" in r && "constructor" in a && !(typeof nr == "function" && nr instanceof nr && typeof Ar == "function" && Ar instanceof Ar) && (ai = !1);
        }
        return G.delete(r), G.delete(a), ai;
      }
      function ts(r) {
        return wh(Yh(r, y, nu), r + "");
      }
      function fh(r) {
        return Hl(r, Rn, vh);
      }
      function dh(r) {
        return Hl(r, mr, Vh);
      }
      var mh = sa ? function(r) {
        return sa.get(r);
      } : Dh;
      function Wl(r) {
        for (var a = r.name + "", u = xo[a], m = si.call(xo, a) ? u.length : 0; m--; ) {
          var L = u[m], G = L.func;
          if (G == null || G == r)
            return L.name;
        }
        return a;
      }
      function Xa(r) {
        var a = si.call(O, "placeholder") ? O : r;
        return a.placeholder;
      }
      function ke() {
        var r = O.iteratee || Oh;
        return r = r === Oh ? w : r, arguments.length ? r(arguments[0], arguments[1]) : r;
      }
      function jl(r, a) {
        var u = r.__data__;
        return Zu(a) ? u[typeof a == "string" ? "string" : "hash"] : u.map;
      }
      function gh(r) {
        for (var a = Rn(r), u = a.length; u--; ) {
          var m = a[u], L = r[m];
          a[u] = [m, L, Xh(L)];
        }
        return a;
      }
      function ya(r, a) {
        var u = Go(r, a);
        return p(u) ? u : y;
      }
      function ku(r) {
        var a = si.call(r, Gr), u = r[Gr];
        try {
          r[Gr] = y;
          var m = !0;
        } catch {
        }
        var L = Wn.call(r);
        return m && (a ? r[Gr] = u : delete r[Gr]), L;
      }
      var vh = ia ? function(r) {
        return r == null ? [] : (r = he(r), sr(ia(r), function(a) {
          return ea.call(r, a);
        }));
      } : zh, Vh = ia ? function(r) {
        for (var a = []; r; )
          Ir(a, vh(r)), r = Fr(r);
        return a;
      } : zh, Yn = Cn;
      (ra && Yn(new ra(new ArrayBuffer(1))) != Gt || qo && Yn(new qo()) != Fi || oa && Yn(oa.resolve()) != _n || Yo && Yn(new Yo()) != Ni || an && Yn(new an()) != q) && (Yn = function(r) {
        var a = Cn(r), u = a == Ze ? r.constructor : y, m = u ? _a(u) : "";
        if (m)
          switch (m) {
            case Ba:
              return Gt;
            case sl:
              return Fi;
            case al:
              return _n;
            case ll:
              return Ni;
            case Ol:
              return q;
          }
        return a;
      });
      function Vu(r, a, u) {
        for (var m = -1, L = u.length; ++m < L; ) {
          var G = u[m], J = G.size;
          switch (G.type) {
            case "drop":
              r += J;
              break;
            case "dropRight":
              a -= J;
              break;
            case "take":
              a = Sn(a, r + J);
              break;
            case "takeRight":
              r = $i(r, a - J);
              break;
          }
        }
        return { start: r, end: a };
      }
      function Wu(r) {
        var a = r.match(Hs);
        return a ? a[1].split(Rr) : [];
      }
      function Wh(r, a, u) {
        a = Ie(a, r);
        for (var m = -1, L = a.length, G = !1; ++m < L; ) {
          var J = Ao(a[m]);
          if (!(G = r != null && u(r, J)))
            break;
          r = r[J];
        }
        return G || ++m != L ? G : (L = r == null ? 0 : r.length, !!L && Ql(L) && es(J, L) && (ei(r) || xa(r)));
      }
      function ju(r) {
        var a = r.length, u = new r.constructor(a);
        return a && typeof r[0] == "string" && si.call(r, "index") && (u.index = r.index, u.input = r.input), u;
      }
      function jh(r) {
        return typeof r.constructor == "function" && !wl(r) ? wo(Fr(r)) : {};
      }
      function Xu(r, a, u) {
        var m = r.constructor;
        switch (a) {
          case Lt:
            return zs(r);
          case ii:
          case ui:
            return new m(+r);
          case Gt:
            return gl(r, u);
          case Pt:
          case Ae:
          case Se:
          case te:
          case Pe:
          case ci:
          case wi:
          case Ke:
          case mi:
            return va(r, u);
          case Fi:
            return new m();
          case Un:
          case A:
            return new m(r);
          case Fn:
            return Ns(r);
          case Ni:
            return new m();
          case k:
            return Qo(r);
        }
      }
      function qu(r, a) {
        var u = a.length;
        if (!u)
          return r;
        var m = u - 1;
        return a[m] = (u > 1 ? "& " : "") + a[m], a = a.join(u > 2 ? ", " : " "), r.replace(ls, `{
/* [wrapped with ` + a + `] */
`);
      }
      function Yu(r) {
        return ei(r) || xa(r) || !!(Es && r && r[Es]);
      }
      function es(r, a) {
        var u = typeof r;
        return a = a ?? ze, !!a && (u == "number" || u != "symbol" && Sa.test(r)) && r > -1 && r % 1 == 0 && r < a;
      }
      function ir(r, a, u) {
        if (!en(u))
          return !1;
        var m = typeof a;
        return (m == "number" ? dr(u) && es(a, u.length) : m == "string" && a in u) ? so(u[a], r) : !1;
      }
      function yh(r, a) {
        if (ei(r))
          return !1;
        var u = typeof r;
        return u == "number" || u == "symbol" || u == "boolean" || r == null || Sr(r) ? !0 : Jn.test(r) || !Po.test(r) || a != null && r in he(a);
      }
      function Zu(r) {
        var a = typeof r;
        return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? r !== "__proto__" : r === null;
      }
      function _h(r) {
        var a = Wl(r), u = O[a];
        if (typeof u != "function" || !(a in ni.prototype))
          return !1;
        if (r === u)
          return !0;
        var m = mh(u);
        return !!m && r === m[0];
      }
      function Ju(r) {
        return !!ur && ur in r;
      }
      var $u = yo ? is : Nh;
      function wl(r) {
        var a = r && r.constructor, u = typeof a == "function" && a.prototype || Br;
        return r === u;
      }
      function Xh(r) {
        return r === r && !en(r);
      }
      function qh(r, a) {
        return function(u) {
          return u == null ? !1 : u[r] === a && (a !== y || r in he(u));
        };
      }
      function Qu(r) {
        var a = Jl(r, function(m) {
          return u.size === Tt && u.clear(), m;
        }), u = a.cache;
        return a;
      }
      function Ku(r, a) {
        var u = r[1], m = a[1], L = u | m, G = L < (Y | _ | X), J = m == X && u == B || m == X && u == it && r[7].length <= a[8] || m == (X | it) && a[7].length <= a[8] && u == B;
        if (!(G || J))
          return r;
        m & Y && (r[2] = a[2], L |= u & Y ? 0 : x);
        var ot = a[3];
        if (ot) {
          var mt = r[3];
          r[3] = mt ? vl(mt, ot, a[4]) : ot, r[4] = mt ? hr(r[3], Rt) : a[4];
        }
        return ot = a[5], ot && (mt = r[5], r[5] = mt ? yl(mt, ot, a[6]) : ot, r[6] = mt ? hr(r[5], Rt) : a[6]), ot = a[7], ot && (r[7] = ot), m & X && (r[8] = r[8] == null ? a[8] : Sn(r[8], a[8])), r[9] == null && (r[9] = a[9]), r[0] = a[0], r[1] = L, r;
      }
      function tc(r) {
        var a = [];
        if (r != null)
          for (var u in he(r))
            a.push(u);
        return a;
      }
      function ec(r) {
        return Wn.call(r);
      }
      function Yh(r, a, u) {
        return a = $i(a === y ? r.length - 1 : a, 0), function() {
          for (var m = arguments, L = -1, G = $i(m.length - a, 0), J = At(G); ++L < G; )
            J[L] = m[a + L];
          L = -1;
          for (var ot = At(a + 1); ++L < a; )
            ot[L] = m[L];
          return ot[a] = u(J), $n(r, this, ot);
        };
      }
      function Zh(r, a) {
        return a.length < 2 ? r : So(r, Si(a, 0, -1));
      }
      function ic(r, a) {
        for (var u = r.length, m = Sn(a.length, u), L = Nn(r); m--; ) {
          var G = a[m];
          r[m] = es(G, u) ? L[G] : y;
        }
        return r;
      }
      function xh(r, a) {
        if (!(a === "constructor" && typeof r[a] == "function") && a != "__proto__")
          return r[a];
      }
      var Jh = Qh(hn), Ml = il || function(r, a) {
        return Ji.setTimeout(r, a);
      }, wh = Qh(Ki);
      function $h(r, a, u) {
        var m = a + "";
        return wh(r, qu(m, nc(Wu(m), u)));
      }
      function Qh(r) {
        var a = 0, u = 0;
        return function() {
          var m = na(), L = re - (m - u);
          if (u = m, L > 0) {
            if (++a >= Yt)
              return arguments[0];
          } else
            a = 0;
          return r.apply(y, arguments);
        };
      }
      function Xl(r, a) {
        var u = -1, m = r.length, L = m - 1;
        for (a = a === y ? m : a; ++u < a; ) {
          var G = $t(u, L), J = r[G];
          r[G] = r[u], r[u] = J;
        }
        return r.length = a, r;
      }
      var Kh = Qu(function(r) {
        var a = [];
        return r.charCodeAt(0) === 46 && a.push(""), r.replace(as, function(u, m, L, G) {
          a.push(L ? G.replace(us, "$1") : m || u);
        }), a;
      });
      function Ao(r) {
        if (typeof r == "string" || Sr(r))
          return r;
        var a = r + "";
        return a == "0" && 1 / r == -ie ? "-0" : a;
      }
      function _a(r) {
        if (r != null) {
          try {
            return kn.call(r);
          } catch {
          }
          try {
            return r + "";
          } catch {
          }
        }
        return "";
      }
      function nc(r, a) {
        return Di(Yi, function(u) {
          var m = "_." + u[0];
          a & u[1] && !Zs(r, m) && r.push(m);
        }), r.sort();
      }
      function tu(r) {
        if (r instanceof ni)
          return r.clone();
        var a = new Pn(r.__wrapped__, r.__chain__);
        return a.__actions__ = Nn(r.__actions__), a.__index__ = r.__index__, a.__values__ = r.__values__, a;
      }
      function rc(r, a, u) {
        (u ? ir(r, a, u) : a === y) ? a = 1 : a = $i(oi(a), 0);
        var m = r == null ? 0 : r.length;
        if (!m || a < 1)
          return [];
        for (var L = 0, G = 0, J = At(to(m / a)); L < m; )
          J[G++] = Si(r, L, L += a);
        return J;
      }
      function oc(r) {
        for (var a = -1, u = r == null ? 0 : r.length, m = 0, L = []; ++a < u; ) {
          var G = r[a];
          G && (L[m++] = G);
        }
        return L;
      }
      function sc() {
        var r = arguments.length;
        if (!r)
          return [];
        for (var a = At(r - 1), u = arguments[0], m = r; m--; )
          a[m - 1] = arguments[m];
        return Ir(ei(u) ? Nn(u) : [u], ln(a, 1));
      }
      var ac = Wt(function(r, a) {
        return mn(r) ? da(r, ln(a, 1, mn, !0)) : [];
      }), lc = Wt(function(r, a) {
        var u = Xr(a);
        return mn(u) && (u = y), mn(r) ? da(r, ln(a, 1, mn, !0), ke(u, 2)) : [];
      }), hc = Wt(function(r, a) {
        var u = Xr(a);
        return mn(u) && (u = y), mn(r) ? da(r, ln(a, 1, mn, !0), y, u) : [];
      });
      function uc(r, a, u) {
        var m = r == null ? 0 : r.length;
        return m ? (a = u || a === y ? 1 : oi(a), Si(r, a < 0 ? 0 : a, m)) : [];
      }
      function cc(r, a, u) {
        var m = r == null ? 0 : r.length;
        return m ? (a = u || a === y ? 1 : oi(a), a = m - a, Si(r, 0, a < 0 ? 0 : a)) : [];
      }
      function pc(r, a) {
        return r && r.length ? Ce(r, ke(a, 3), !0, !0) : [];
      }
      function fc(r, a) {
        return r && r.length ? Ce(r, ke(a, 3), !0) : [];
      }
      function dc(r, a, u, m) {
        var L = r == null ? 0 : r.length;
        return L ? (u && typeof u != "number" && ir(r, a, u) && (u = 0, m = L), zn(r, a, u, m)) : [];
      }
      function eu(r, a, u) {
        var m = r == null ? 0 : r.length;
        if (!m)
          return -1;
        var L = u == null ? 0 : oi(u);
        return L < 0 && (L = $i(m + L, 0)), co(r, ke(a, 3), L);
      }
      function iu(r, a, u) {
        var m = r == null ? 0 : r.length;
        if (!m)
          return -1;
        var L = m - 1;
        return u !== y && (L = oi(u), L = u < 0 ? $i(m + L, 0) : Sn(L, m - 1)), co(r, ke(a, 3), L, !0);
      }
      function nu(r) {
        var a = r == null ? 0 : r.length;
        return a ? ln(r, 1) : [];
      }
      function mc(r) {
        var a = r == null ? 0 : r.length;
        return a ? ln(r, ie) : [];
      }
      function gc(r, a) {
        var u = r == null ? 0 : r.length;
        return u ? (a = a === y ? 1 : oi(a), ln(r, a)) : [];
      }
      function vc(r) {
        for (var a = -1, u = r == null ? 0 : r.length, m = {}; ++a < u; ) {
          var L = r[a];
          m[L[0]] = L[1];
        }
        return m;
      }
      function ru(r) {
        return r && r.length ? r[0] : y;
      }
      function yc(r, a, u) {
        var m = r == null ? 0 : r.length;
        if (!m)
          return -1;
        var L = u == null ? 0 : oi(u);
        return L < 0 && (L = $i(m + L, 0)), ar(r, a, L);
      }
      function _c(r) {
        var a = r == null ? 0 : r.length;
        return a ? Si(r, 0, -1) : [];
      }
      var xc = Wt(function(r) {
        var a = Ri(r, Bt);
        return a.length && a[0] === r[0] ? ga(a) : [];
      }), wc = Wt(function(r) {
        var a = Xr(r), u = Ri(r, Bt);
        return a === Xr(u) ? a = y : u.pop(), u.length && u[0] === r[0] ? ga(u, ke(a, 2)) : [];
      }), Mc = Wt(function(r) {
        var a = Xr(r), u = Ri(r, Bt);
        return a = typeof a == "function" ? a : y, a && u.pop(), u.length && u[0] === r[0] ? ga(u, y, a) : [];
      });
      function Tc(r, a) {
        return r == null ? "" : rl.call(r, a);
      }
      function Xr(r) {
        var a = r == null ? 0 : r.length;
        return a ? r[a - 1] : y;
      }
      function Sc(r, a, u) {
        var m = r == null ? 0 : r.length;
        if (!m)
          return -1;
        var L = m;
        return u !== y && (L = oi(u), L = L < 0 ? $i(m + L, 0) : Sn(L, m - 1)), a === a ? ba(r, a, L) : co(r, zo, L, !0);
      }
      function Ec(r, a) {
        return r && r.length ? C(r, oi(a)) : y;
      }
      var Ac = Wt(ou);
      function ou(r, a) {
        return r && r.length && a && a.length ? St(r, a) : r;
      }
      function Pc(r, a, u) {
        return r && r.length && a && a.length ? St(r, a, ke(u, 2)) : r;
      }
      function Lc(r, a, u) {
        return r && r.length && a && a.length ? St(r, a, y, u) : r;
      }
      var Cc = ts(function(r, a) {
        var u = r == null ? 0 : r.length, m = dl(r, a);
        return oe(r, Ri(a, function(L) {
          return es(L, u) ? +L : L;
        }).sort(Ko)), m;
      });
      function Rc(r, a) {
        var u = [];
        if (!(r && r.length))
          return u;
        var m = -1, L = [], G = r.length;
        for (a = ke(a, 3); ++m < G; ) {
          var J = r[m];
          a(J, m, r) && (u.push(J), L.push(m));
        }
        return oe(r, L), u;
      }
      function Mh(r) {
        return r == null ? r : As.call(r);
      }
      function bc(r, a, u) {
        var m = r == null ? 0 : r.length;
        return m ? (u && typeof u != "number" && ir(r, a, u) ? (a = 0, u = m) : (a = a == null ? 0 : oi(a), u = u === y ? m : oi(u)), Si(r, a, u)) : [];
      }
      function Oc(r, a) {
        return un(r, a);
      }
      function Ic(r, a, u) {
        return ce(r, a, ke(u, 2));
      }
      function Dc(r, a) {
        var u = r == null ? 0 : r.length;
        if (u) {
          var m = un(r, a);
          if (m < u && so(r[m], a))
            return m;
        }
        return -1;
      }
      function zc(r, a) {
        return un(r, a, !0);
      }
      function Nc(r, a, u) {
        return ce(r, a, ke(u, 2), !0);
      }
      function Bc(r, a) {
        var u = r == null ? 0 : r.length;
        if (u) {
          var m = un(r, a, !0) - 1;
          if (so(r[m], a))
            return m;
        }
        return -1;
      }
      function Uc(r) {
        return r && r.length ? Ue(r) : [];
      }
      function Fc(r, a) {
        return r && r.length ? Ue(r, ke(a, 2)) : [];
      }
      function Gc(r) {
        var a = r == null ? 0 : r.length;
        return a ? Si(r, 1, a) : [];
      }
      function Hc(r, a, u) {
        return r && r.length ? (a = u || a === y ? 1 : oi(a), Si(r, 0, a < 0 ? 0 : a)) : [];
      }
      function kc(r, a, u) {
        var m = r == null ? 0 : r.length;
        return m ? (a = u || a === y ? 1 : oi(a), a = m - a, Si(r, a < 0 ? 0 : a, m)) : [];
      }
      function Vc(r, a) {
        return r && r.length ? Ce(r, ke(a, 3), !1, !0) : [];
      }
      function Wc(r, a) {
        return r && r.length ? Ce(r, ke(a, 3)) : [];
      }
      var jc = Wt(function(r) {
        return Fe(ln(r, 1, mn, !0));
      }), Xc = Wt(function(r) {
        var a = Xr(r);
        return mn(a) && (a = y), Fe(ln(r, 1, mn, !0), ke(a, 2));
      }), qc = Wt(function(r) {
        var a = Xr(r);
        return a = typeof a == "function" ? a : y, Fe(ln(r, 1, mn, !0), y, a);
      });
      function Yc(r) {
        return r && r.length ? Fe(r) : [];
      }
      function Zc(r, a) {
        return r && r.length ? Fe(r, ke(a, 2)) : [];
      }
      function Jc(r, a) {
        return a = typeof a == "function" ? a : y, r && r.length ? Fe(r, y, a) : [];
      }
      function Th(r) {
        if (!(r && r.length))
          return [];
        var a = 0;
        return r = sr(r, function(u) {
          if (mn(u))
            return a = $i(u.length, a), !0;
        }), $r(a, function(u) {
          return Ri(r, po(u));
        });
      }
      function su(r, a) {
        if (!(r && r.length))
          return [];
        var u = Th(r);
        return a == null ? u : Ri(u, function(m) {
          return $n(a, y, m);
        });
      }
      var $c = Wt(function(r, a) {
        return mn(r) ? da(r, a) : [];
      }), Qc = Wt(function(r) {
        return pi(sr(r, mn));
      }), Kc = Wt(function(r) {
        var a = Xr(r);
        return mn(a) && (a = y), pi(sr(r, mn), ke(a, 2));
      }), tp = Wt(function(r) {
        var a = Xr(r);
        return a = typeof a == "function" ? a : y, pi(sr(r, mn), y, a);
      }), ep = Wt(Th);
      function ip(r, a) {
        return hi(r || [], a || [], Is);
      }
      function np(r, a) {
        return hi(r || [], a || [], Ye);
      }
      var rp = Wt(function(r) {
        var a = r.length, u = a > 1 ? r[a - 1] : y;
        return u = typeof u == "function" ? (r.pop(), u) : y, su(r, u);
      });
      function au(r) {
        var a = O(r);
        return a.__chain__ = !0, a;
      }
      function op(r, a) {
        return a(r), r;
      }
      function ql(r, a) {
        return a(r);
      }
      var sp = ts(function(r) {
        var a = r.length, u = a ? r[0] : 0, m = this.__wrapped__, L = function(G) {
          return dl(G, r);
        };
        return a > 1 || this.__actions__.length || !(m instanceof ni) || !es(u) ? this.thru(L) : (m = m.slice(u, +u + (a ? 1 : 0)), m.__actions__.push({
          func: ql,
          args: [L],
          thisArg: y
        }), new Pn(m, this.__chain__).thru(function(G) {
          return a && !G.length && G.push(y), G;
        }));
      });
      function ap() {
        return au(this);
      }
      function lp() {
        return new Pn(this.value(), this.__chain__);
      }
      function hp() {
        this.__values__ === y && (this.__values__ = wu(this.value()));
        var r = this.__index__ >= this.__values__.length, a = r ? y : this.__values__[this.__index__++];
        return { done: r, value: a };
      }
      function up() {
        return this;
      }
      function cp(r) {
        for (var a, u = this; u instanceof Ls; ) {
          var m = tu(u);
          m.__index__ = 0, m.__values__ = y, a ? L.__wrapped__ = m : a = m;
          var L = m;
          u = u.__wrapped__;
        }
        return L.__wrapped__ = r, a;
      }
      function pp() {
        var r = this.__wrapped__;
        if (r instanceof ni) {
          var a = r;
          return this.__actions__.length && (a = new ni(this)), a = a.reverse(), a.__actions__.push({
            func: ql,
            args: [Mh],
            thisArg: y
          }), new Pn(a, this.__chain__);
        }
        return this.thru(Mh);
      }
      function fp() {
        return He(this.__wrapped__, this.__actions__);
      }
      var dp = Bs(function(r, a, u) {
        si.call(r, u) ? ++r[u] : no(r, u, 1);
      });
      function mp(r, a, u) {
        var m = ei(r) ? el : Ln;
        return u && ir(r, a, u) && (a = y), m(r, ke(a, 3));
      }
      function gp(r, a) {
        var u = ei(r) ? sr : pr;
        return u(r, ke(a, 3));
      }
      var vp = Ne(eu), yp = Ne(iu);
      function _p(r, a) {
        return ln(Yl(r, a), 1);
      }
      function xp(r, a) {
        return ln(Yl(r, a), ie);
      }
      function wp(r, a, u) {
        return u = u === y ? 1 : oi(u), ln(Yl(r, a), u);
      }
      function lu(r, a) {
        var u = ei(r) ? Di : Qi;
        return u(r, ke(a, 3));
      }
      function hu(r, a) {
        var u = ei(r) ? Io : Gl;
        return u(r, ke(a, 3));
      }
      var Mp = Bs(function(r, a, u) {
        si.call(r, u) ? r[u].push(a) : no(r, u, [a]);
      });
      function Tp(r, a, u, m) {
        r = dr(r) ? r : Ya(r), u = u && !m ? oi(u) : 0;
        var L = r.length;
        return u < 0 && (u = $i(L + u, 0)), Kl(r) ? u <= L && r.indexOf(a, u) > -1 : !!L && ar(r, a, u) > -1;
      }
      var Sp = Wt(function(r, a, u) {
        var m = -1, L = typeof a == "function", G = dr(r) ? At(r.length) : [];
        return Qi(r, function(J) {
          G[++m] = L ? $n(a, J, u) : e(J, a, u);
        }), G;
      }), Ep = Bs(function(r, a, u) {
        no(r, u, a);
      });
      function Yl(r, a) {
        var u = ei(r) ? Ri : Q;
        return u(r, ke(a, 3));
      }
      function Ap(r, a, u, m) {
        return r == null ? [] : (ei(a) || (a = a == null ? [] : [a]), u = m ? y : u, ei(u) || (u = u == null ? [] : [u]), D(r, a, u));
      }
      var Pp = Bs(function(r, a, u) {
        r[u ? 0 : 1].push(a);
      }, function() {
        return [[], []];
      });
      function Lp(r, a, u) {
        var m = ei(r) ? Ca : fo, L = arguments.length < 3;
        return m(r, ke(a, 4), u, L, Qi);
      }
      function Cp(r, a, u) {
        var m = ei(r) ? Pl : fo, L = arguments.length < 3;
        return m(r, ke(a, 4), u, L, Gl);
      }
      function Rp(r, a) {
        var u = ei(r) ? sr : pr;
        return u(r, $l(ke(a, 3)));
      }
      function bp(r) {
        var a = ei(r) ? cl : Ee;
        return a(r);
      }
      function Op(r, a, u) {
        (u ? ir(r, a, u) : a === y) ? a = 1 : a = oi(a);
        var m = ei(r) ? ph : Be;
        return m(r, a);
      }
      function Ip(r) {
        var a = ei(r) ? Bl : Ci;
        return a(r);
      }
      function Dp(r) {
        if (r == null)
          return 0;
        if (dr(r))
          return Kl(r) ? wr(r) : r.length;
        var a = Yn(r);
        return a == Fi || a == Ni ? r.size : P(r).length;
      }
      function zp(r, a, u) {
        var m = ei(r) ? Zr : ki;
        return u && ir(r, a, u) && (a = y), m(r, ke(a, 3));
      }
      var Np = Wt(function(r, a) {
        if (r == null)
          return [];
        var u = a.length;
        return u > 1 && ir(r, a[0], a[1]) ? a = [] : u > 2 && ir(a[0], a[1], a[2]) && (a = [a[0]]), D(r, ln(a, 1), []);
      }), Zl = Da || function() {
        return Ji.Date.now();
      };
      function Bp(r, a) {
        if (typeof a != "function")
          throw new Hn(Mt);
        return r = oi(r), function() {
          if (--r < 1)
            return a.apply(this, arguments);
        };
      }
      function uu(r, a, u) {
        return a = u ? y : a, a = r && a == null ? r.length : a, Bn(r, X, y, y, y, y, a);
      }
      function cu(r, a) {
        var u;
        if (typeof a != "function")
          throw new Hn(Mt);
        return r = oi(r), function() {
          return --r > 0 && (u = a.apply(this, arguments)), r <= 1 && (a = y), u;
        };
      }
      var Sh = Wt(function(r, a, u) {
        var m = Y;
        if (u.length) {
          var L = hr(u, Xa(Sh));
          m |= Z;
        }
        return Bn(r, m, a, u, L);
      }), pu = Wt(function(r, a, u) {
        var m = Y | _;
        if (u.length) {
          var L = hr(u, Xa(pu));
          m |= Z;
        }
        return Bn(a, m, r, u, L);
      });
      function fu(r, a, u) {
        a = u ? y : a;
        var m = Bn(r, B, y, y, y, y, y, a);
        return m.placeholder = fu.placeholder, m;
      }
      function du(r, a, u) {
        a = u ? y : a;
        var m = Bn(r, E, y, y, y, y, y, a);
        return m.placeholder = du.placeholder, m;
      }
      function mu(r, a, u) {
        var m, L, G, J, ot, mt, Ht = 0, jt = !1, Jt = !1, ve = !0;
        if (typeof r != "function")
          throw new Hn(Mt);
        a = qr(a) || 0, en(u) && (jt = !!u.leading, Jt = "maxWait" in u, G = Jt ? $i(qr(u.maxWait) || 0, a) : G, ve = "trailing" in u ? !!u.trailing : ve);
        function De(gn) {
          var ao = m, rs = L;
          return m = L = y, Ht = gn, J = r.apply(rs, ao), J;
        }
        function je(gn) {
          return Ht = gn, ot = Ml(fi, a), jt ? De(gn) : J;
        }
        function ai(gn) {
          var ao = gn - mt, rs = gn - Ht, Du = a - ao;
          return Jt ? Sn(Du, G - rs) : Du;
        }
        function Xe(gn) {
          var ao = gn - mt, rs = gn - Ht;
          return mt === y || ao >= a || ao < 0 || Jt && rs >= G;
        }
        function fi() {
          var gn = Zl();
          if (Xe(gn))
            return xi(gn);
          ot = Ml(fi, ai(gn));
        }
        function xi(gn) {
          return ot = y, ve && m ? De(gn) : (m = L = y, J);
        }
        function Er() {
          ot !== y && cn(ot), Ht = 0, m = mt = L = ot = y;
        }
        function nr() {
          return ot === y ? J : xi(Zl());
        }
        function Ar() {
          var gn = Zl(), ao = Xe(gn);
          if (m = arguments, L = this, mt = gn, ao) {
            if (ot === y)
              return je(mt);
            if (Jt)
              return cn(ot), ot = Ml(fi, a), De(mt);
          }
          return ot === y && (ot = Ml(fi, a)), J;
        }
        return Ar.cancel = Er, Ar.flush = nr, Ar;
      }
      var Up = Wt(function(r, a) {
        return kr(r, 1, a);
      }), Fp = Wt(function(r, a, u) {
        return kr(r, qr(a) || 0, u);
      });
      function Gp(r) {
        return Bn(r, _t);
      }
      function Jl(r, a) {
        if (typeof r != "function" || a != null && typeof a != "function")
          throw new Hn(Mt);
        var u = function() {
          var m = arguments, L = a ? a.apply(this, m) : m[0], G = u.cache;
          if (G.has(L))
            return G.get(L);
          var J = r.apply(this, m);
          return u.cache = G.set(L, J) || G, J;
        };
        return u.cache = new (Jl.Cache || Kn)(), u;
      }
      Jl.Cache = Kn;
      function $l(r) {
        if (typeof r != "function")
          throw new Hn(Mt);
        return function() {
          var a = arguments;
          switch (a.length) {
            case 0:
              return !r.call(this);
            case 1:
              return !r.call(this, a[0]);
            case 2:
              return !r.call(this, a[0], a[1]);
            case 3:
              return !r.call(this, a[0], a[1], a[2]);
          }
          return !r.apply(this, a);
        };
      }
      function Hp(r) {
        return cu(2, r);
      }
      var kp = We(function(r, a) {
        a = a.length == 1 && ei(a[0]) ? Ri(a[0], Mn(ke())) : Ri(ln(a, 1), Mn(ke()));
        var u = a.length;
        return Wt(function(m) {
          for (var L = -1, G = Sn(m.length, u); ++L < G; )
            m[L] = a[L].call(this, m[L]);
          return $n(r, this, m);
        });
      }), Eh = Wt(function(r, a) {
        var u = hr(a, Xa(Eh));
        return Bn(r, Z, y, a, u);
      }), gu = Wt(function(r, a) {
        var u = hr(a, Xa(gu));
        return Bn(r, z, y, a, u);
      }), Vp = ts(function(r, a) {
        return Bn(r, it, y, y, y, a);
      });
      function Wp(r, a) {
        if (typeof r != "function")
          throw new Hn(Mt);
        return a = a === y ? a : oi(a), Wt(r, a);
      }
      function jp(r, a) {
        if (typeof r != "function")
          throw new Hn(Mt);
        return a = a == null ? 0 : $i(oi(a), 0), Wt(function(u) {
          var m = u[a], L = tn(u, 0, a);
          return m && Ir(L, m), $n(r, this, L);
        });
      }
      function Xp(r, a, u) {
        var m = !0, L = !0;
        if (typeof r != "function")
          throw new Hn(Mt);
        return en(u) && (m = "leading" in u ? !!u.leading : m, L = "trailing" in u ? !!u.trailing : L), mu(r, a, {
          leading: m,
          maxWait: a,
          trailing: L
        });
      }
      function qp(r) {
        return uu(r, 1);
      }
      function Yp(r, a) {
        return Eh(Ge(a), r);
      }
      function Zp() {
        if (!arguments.length)
          return [];
        var r = arguments[0];
        return ei(r) ? r : [r];
      }
      function Jp(r) {
        return tr(r, Ut);
      }
      function $p(r, a) {
        return a = typeof a == "function" ? a : y, tr(r, Ut, a);
      }
      function Qp(r) {
        return tr(r, vt | Ut);
      }
      function Kp(r, a) {
        return a = typeof a == "function" ? a : y, tr(r, vt | Ut, a);
      }
      function tf(r, a) {
        return a == null || Fl(r, a, Rn(a));
      }
      function so(r, a) {
        return r === a || r !== r && a !== a;
      }
      var ef = jr(ka), nf = jr(function(r, a) {
        return r >= a;
      }), xa = i(function() {
        return arguments;
      }()) ? i : function(r) {
        return pn(r) && si.call(r, "callee") && !ea.call(r, "callee");
      }, ei = At.isArray, rf = tl ? Mn(tl) : n;
      function dr(r) {
        return r != null && Ql(r.length) && !is(r);
      }
      function mn(r) {
        return pn(r) && dr(r);
      }
      function of(r) {
        return r === !0 || r === !1 || pn(r) && Cn(r) == ii;
      }
      var Fs = nl || Nh, sf = ys ? Mn(ys) : o;
      function af(r) {
        return pn(r) && r.nodeType === 1 && !Tl(r);
      }
      function lf(r) {
        if (r == null)
          return !0;
        if (dr(r) && (ei(r) || typeof r == "string" || typeof r.splice == "function" || Fs(r) || qa(r) || xa(r)))
          return !r.length;
        var a = Yn(r);
        if (a == Fi || a == Ni)
          return !r.size;
        if (wl(r))
          return !P(r).length;
        for (var u in r)
          if (si.call(r, u))
            return !1;
        return !0;
      }
      function hf(r, a) {
        return s(r, a);
      }
      function uf(r, a, u) {
        u = typeof u == "function" ? u : y;
        var m = u ? u(r, a) : y;
        return m === y ? s(r, a, y, u) : !!m;
      }
      function Ah(r) {
        if (!pn(r))
          return !1;
        var a = Cn(r);
        return a == vr || a == Ui || typeof r.message == "string" && typeof r.name == "string" && !Tl(r);
      }
      function cf(r) {
        return typeof r == "number" && za(r);
      }
      function is(r) {
        if (!en(r))
          return !1;
        var a = Cn(r);
        return a == Pr || a == Zn || a == bn || a == lo;
      }
      function vu(r) {
        return typeof r == "number" && r == oi(r);
      }
      function Ql(r) {
        return typeof r == "number" && r > -1 && r % 1 == 0 && r <= ze;
      }
      function en(r) {
        var a = typeof r;
        return r != null && (a == "object" || a == "function");
      }
      function pn(r) {
        return r != null && typeof r == "object";
      }
      var yu = _s ? Mn(_s) : h;
      function pf(r, a) {
        return r === a || c(r, a, gh(a));
      }
      function ff(r, a, u) {
        return u = typeof u == "function" ? u : y, c(r, a, gh(a), u);
      }
      function df(r) {
        return _u(r) && r != +r;
      }
      function mf(r) {
        if ($u(r))
          throw new Ve(S);
        return p(r);
      }
      function gf(r) {
        return r === null;
      }
      function vf(r) {
        return r == null;
      }
      function _u(r) {
        return typeof r == "number" || pn(r) && Cn(r) == Un;
      }
      function Tl(r) {
        if (!pn(r) || Cn(r) != Ze)
          return !1;
        var a = Fr(r);
        if (a === null)
          return !0;
        var u = si.call(a, "constructor") && a.constructor;
        return typeof u == "function" && u instanceof u && kn.call(u) == Ur;
      }
      var Ph = El ? Mn(El) : f;
      function yf(r) {
        return vu(r) && r >= -ze && r <= ze;
      }
      var xu = Al ? Mn(Al) : d;
      function Kl(r) {
        return typeof r == "string" || !ei(r) && pn(r) && Cn(r) == A;
      }
      function Sr(r) {
        return typeof r == "symbol" || pn(r) && Cn(r) == k;
      }
      var qa = Aa ? Mn(Aa) : v;
      function _f(r) {
        return r === y;
      }
      function xf(r) {
        return pn(r) && Yn(r) == q;
      }
      function wf(r) {
        return pn(r) && Cn(r) == ht;
      }
      var Mf = jr(I), Tf = jr(function(r, a) {
        return r <= a;
      });
      function wu(r) {
        if (!r)
          return [];
        if (dr(r))
          return Kl(r) ? Gn(r) : Nn(r);
        if (_o && r[_o])
          return ko(r[_o]());
        var a = Yn(r), u = a == Fi ? On : a == Ni ? Vo : Ya;
        return u(r);
      }
      function ns(r) {
        if (!r)
          return r === 0 ? r : 0;
        if (r = qr(r), r === ie || r === -ie) {
          var a = r < 0 ? -1 : 1;
          return a * nn;
        }
        return r === r ? r : 0;
      }
      function oi(r) {
        var a = ns(r), u = a % 1;
        return a === a ? u ? a - u : a : 0;
      }
      function Mu(r) {
        return r ? To(oi(r), 0, $e) : 0;
      }
      function qr(r) {
        if (typeof r == "number")
          return r;
        if (Sr(r))
          return Ft;
        if (en(r)) {
          var a = typeof r.valueOf == "function" ? r.valueOf() : r;
          r = en(a) ? a + "" : a;
        }
        if (typeof r != "string")
          return r === 0 ? r : +r;
        r = ws(r);
        var u = Qa.test(r);
        return u || Co.test(r) ? ms(r.slice(2), u ? 2 : 8) : $a.test(r) ? Ft : +r;
      }
      function Tu(r) {
        return dn(r, mr(r));
      }
      function Sf(r) {
        return r ? To(oi(r), -ze, ze) : r === 0 ? r : 0;
      }
      function bi(r) {
        return r == null ? "" : be(r);
      }
      var Ef = oo(function(r, a) {
        if (wl(a) || dr(a)) {
          dn(a, Rn(a), r);
          return;
        }
        for (var u in a)
          si.call(a, u) && Is(r, u, a[u]);
      }), Su = oo(function(r, a) {
        dn(a, mr(a), r);
      }), th = oo(function(r, a, u, m) {
        dn(a, mr(a), r, m);
      }), Af = oo(function(r, a, u, m) {
        dn(a, Rn(a), r, m);
      }), Pf = ts(dl);
      function Lf(r, a) {
        var u = wo(r);
        return a == null ? u : pl(u, a);
      }
      var Cf = Wt(function(r, a) {
        r = he(r);
        var u = -1, m = a.length, L = m > 2 ? a[2] : y;
        for (L && ir(a[0], a[1], L) && (m = 1); ++u < m; )
          for (var G = a[u], J = mr(G), ot = -1, mt = J.length; ++ot < mt; ) {
            var Ht = J[ot], jt = r[Ht];
            (jt === y || so(jt, Br[Ht]) && !si.call(r, Ht)) && (r[Ht] = G[Ht]);
          }
        return r;
      }), Rf = Wt(function(r) {
        return r.push(y, Hh), $n(Eu, y, r);
      });
      function bf(r, a) {
        return Do(r, ke(a, 3), fr);
      }
      function Of(r, a) {
        return Do(r, ke(a, 3), Ha);
      }
      function If(r, a) {
        return r == null ? r : ma(r, ke(a, 3), mr);
      }
      function Df(r, a) {
        return r == null ? r : Ga(r, ke(a, 3), mr);
      }
      function zf(r, a) {
        return r && fr(r, ke(a, 3));
      }
      function Nf(r, a) {
        return r && Ha(r, ke(a, 3));
      }
      function Bf(r) {
        return r == null ? [] : $o(r, Rn(r));
      }
      function Uf(r) {
        return r == null ? [] : $o(r, mr(r));
      }
      function Lh(r, a, u) {
        var m = r == null ? y : So(r, a);
        return m === y ? u : m;
      }
      function Ff(r, a) {
        return r != null && Wh(r, a, Va);
      }
      function Ch(r, a) {
        return r != null && Wh(r, a, ml);
      }
      var Gf = Qt(function(r, a, u) {
        a != null && typeof a.toString != "function" && (a = Wn.call(a)), r[a] = u;
      }, bh(gr)), Hf = Qt(function(r, a, u) {
        a != null && typeof a.toString != "function" && (a = Wn.call(a)), si.call(r, a) ? r[a].push(u) : r[a] = [u];
      }, ke), kf = Wt(e);
      function Rn(r) {
        return dr(r) ? Nl(r) : P(r);
      }
      function mr(r) {
        return dr(r) ? Nl(r, !0) : R(r);
      }
      function Vf(r, a) {
        var u = {};
        return a = ke(a, 3), fr(r, function(m, L, G) {
          no(u, a(m, L, G), m);
        }), u;
      }
      function Wf(r, a) {
        var u = {};
        return a = ke(a, 3), fr(r, function(m, L, G) {
          no(u, L, a(m, L, G));
        }), u;
      }
      var jf = oo(function(r, a, u) {
        K(r, a, u);
      }), Eu = oo(function(r, a, u, m) {
        K(r, a, u, m);
      }), Xf = ts(function(r, a) {
        var u = {};
        if (r == null)
          return u;
        var m = !1;
        a = Ri(a, function(G) {
          return G = Ie(G, r), m || (m = G.length > 1), G;
        }), dn(r, dh(r), u), m && (u = tr(u, vt | Nt | Ut, Fu));
        for (var L = a.length; L--; )
          Ei(u, a[L]);
        return u;
      });
      function qf(r, a) {
        return Au(r, $l(ke(a)));
      }
      var Yf = ts(function(r, a) {
        return r == null ? {} : ct(r, a);
      });
      function Au(r, a) {
        if (r == null)
          return {};
        var u = Ri(dh(r), function(m) {
          return [m];
        });
        return a = ke(a), Dt(r, u, function(m, L) {
          return a(m, L[0]);
        });
      }
      function Zf(r, a, u) {
        a = Ie(a, r);
        var m = -1, L = a.length;
        for (L || (L = 1, r = y); ++m < L; ) {
          var G = r == null ? y : r[Ao(a[m])];
          G === y && (m = L, G = u), r = is(G) ? G.call(r) : G;
        }
        return r;
      }
      function Jf(r, a, u) {
        return r == null ? r : Ye(r, a, u);
      }
      function $f(r, a, u, m) {
        return m = typeof m == "function" ? m : y, r == null ? r : Ye(r, a, u, m);
      }
      var Pu = Vl(Rn), Lu = Vl(mr);
      function Qf(r, a, u) {
        var m = ei(r), L = m || Fs(r) || qa(r);
        if (a = ke(a, 4), u == null) {
          var G = r && r.constructor;
          L ? u = m ? new G() : [] : en(r) ? u = is(G) ? wo(Fr(r)) : {} : u = {};
        }
        return (L ? Di : fr)(r, function(J, ot, mt) {
          return a(u, J, ot, mt);
        }), u;
      }
      function Kf(r, a) {
        return r == null ? !0 : Ei(r, a);
      }
      function td(r, a, u) {
        return r == null ? r : pe(r, a, Ge(u));
      }
      function ed(r, a, u, m) {
        return m = typeof m == "function" ? m : y, r == null ? r : pe(r, a, Ge(u), m);
      }
      function Ya(r) {
        return r == null ? [] : No(r, Rn(r));
      }
      function id(r) {
        return r == null ? [] : No(r, mr(r));
      }
      function nd(r, a, u) {
        return u === y && (u = a, a = y), u !== y && (u = qr(u), u = u === u ? u : 0), a !== y && (a = qr(a), a = a === a ? a : 0), To(qr(r), a, u);
      }
      function rd(r, a, u) {
        return a = ns(a), u === y ? (u = a, a = 0) : u = ns(u), r = qr(r), Wa(r, a, u);
      }
      function od(r, a, u) {
        if (u && typeof u != "boolean" && ir(r, a, u) && (a = u = y), u === y && (typeof a == "boolean" ? (u = a, a = y) : typeof r == "boolean" && (u = r, r = y)), r === y && a === y ? (r = 0, a = 1) : (r = ns(r), a === y ? (a = r, r = 0) : a = ns(a)), r > a) {
          var m = r;
          r = a, a = m;
        }
        if (u || r % 1 || a % 1) {
          var L = Na();
          return Sn(r + L * (a - r + Ys("1e-" + ((L + "").length - 1))), a);
        }
        return $t(r, a);
      }
      var sd = ge(function(r, a, u) {
        return a = a.toLowerCase(), r + (u ? Cu(a) : a);
      });
      function Cu(r) {
        return Rh(bi(r).toLowerCase());
      }
      function Ru(r) {
        return r = bi(r), r && r.replace(Ea, Uo).replace(Ka, "");
      }
      function ad(r, a, u) {
        r = bi(r), a = be(a);
        var m = r.length;
        u = u === y ? m : To(oi(u), 0, m);
        var L = u;
        return u -= a.length, u >= 0 && r.slice(u, L) == a;
      }
      function ld(r) {
        return r = bi(r), r && Lr.test(r) ? r.replace(Ii, xr) : r;
      }
      function hd(r) {
        return r = bi(r), r && Ma.test(r) ? r.replace(Gs, "\\$&") : r;
      }
      var ud = ge(function(r, a, u) {
        return r + (u ? "-" : "") + a.toLowerCase();
      }), cd = ge(function(r, a, u) {
        return r + (u ? " " : "") + a.toLowerCase();
      }), pd = ae("toLowerCase");
      function fd(r, a, u) {
        r = bi(r), a = oi(a);
        var m = a ? wr(r) : 0;
        if (!a || m >= a)
          return r;
        var L = (a - m) / 2;
        return Vi(Xo(L), u) + r + Vi(to(L), u);
      }
      function dd(r, a, u) {
        r = bi(r), a = oi(a);
        var m = a ? wr(r) : 0;
        return a && m < a ? r + Vi(a - m, u) : r;
      }
      function md(r, a, u) {
        r = bi(r), a = oi(a);
        var m = a ? wr(r) : 0;
        return a && m < a ? Vi(a - m, u) + r : r;
      }
      function gd(r, a, u) {
        return u || a == null ? a = 0 : a && (a = +a), ol(bi(r).replace(Cr, ""), a || 0);
      }
      function vd(r, a, u) {
        return (u ? ir(r, a, u) : a === y) ? a = 1 : a = oi(a), ue(bi(r), a);
      }
      function yd() {
        var r = arguments, a = bi(r[0]);
        return r.length < 3 ? a : a.replace(r[1], r[2]);
      }
      var _d = ge(function(r, a, u) {
        return r + (u ? "_" : "") + a.toLowerCase();
      });
      function xd(r, a, u) {
        return u && typeof u != "number" && ir(r, a, u) && (a = u = y), u = u === y ? $e : u >>> 0, u ? (r = bi(r), r && (typeof a == "string" || a != null && !Ph(a)) && (a = be(a), !a && lr(r)) ? tn(Gn(r), 0, u) : r.split(a, u)) : [];
      }
      var wd = ge(function(r, a, u) {
        return r + (u ? " " : "") + Rh(a);
      });
      function Md(r, a, u) {
        return r = bi(r), u = u == null ? 0 : To(oi(u), 0, r.length), a = be(a), r.slice(u, u + a.length) == a;
      }
      function Td(r, a, u) {
        var m = O.templateSettings;
        u && ir(r, a, u) && (a = y), r = bi(r), a = th({}, a, m, Gh);
        var L = th({}, a.imports, m.imports, Gh), G = Rn(L), J = No(L, G), ot, mt, Ht = 0, jt = a.interpolate || yr, Jt = "__p += '", ve = In(
          (a.escape || yr).source + "|" + jt.source + "|" + (jt === ss ? br : yr).source + "|" + (a.evaluate || yr).source + "|$",
          "g"
        ), De = "//# sourceURL=" + (si.call(a, "sourceURL") ? (a.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++fs + "]") + `
`;
        r.replace(ve, function(Xe, fi, xi, Er, nr, Ar) {
          return xi || (xi = Er), Jt += r.slice(Ht, Ar).replace(M, Fo), fi && (ot = !0, Jt += `' +
__e(` + fi + `) +
'`), nr && (mt = !0, Jt += `';
` + nr + `;
__p += '`), xi && (Jt += `' +
((__t = (` + xi + `)) == null ? '' : __t) +
'`), Ht = Ar + Xe.length, Xe;
        }), Jt += `';
`;
        var je = si.call(a, "variable") && a.variable;
        if (!je)
          Jt = `with (obj) {
` + Jt + `
}
`;
        else if (hs.test(je))
          throw new Ve(kt);
        Jt = (mt ? Jt.replace(Yr, "") : Jt).replace(or, "$1").replace(Zi, "$1;"), Jt = "function(" + (je || "obj") + `) {
` + (je ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ot ? ", __e = _.escape" : "") + (mt ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Jt + `return __p
}`;
        var ai = Ou(function() {
          return _i(G, De + "return " + Jt).apply(y, J);
        });
        if (ai.source = Jt, Ah(ai))
          throw ai;
        return ai;
      }
      function Sd(r) {
        return bi(r).toLowerCase();
      }
      function Ed(r) {
        return bi(r).toUpperCase();
      }
      function Ad(r, a, u) {
        if (r = bi(r), r && (u || a === y))
          return ws(r);
        if (!r || !(a = be(a)))
          return r;
        var m = Gn(r), L = Gn(a), G = go(m, L), J = Bo(m, L) + 1;
        return tn(m, G, J).join("");
      }
      function Pd(r, a, u) {
        if (r = bi(r), r && (u || a === y))
          return r.slice(0, Ms(r) + 1);
        if (!r || !(a = be(a)))
          return r;
        var m = Gn(r), L = Bo(m, Gn(a)) + 1;
        return tn(m, 0, L).join("");
      }
      function Ld(r, a, u) {
        if (r = bi(r), r && (u || a === y))
          return r.replace(Cr, "");
        if (!r || !(a = be(a)))
          return r;
        var m = Gn(r), L = go(m, Gn(a));
        return tn(m, L).join("");
      }
      function Cd(r, a) {
        var u = dt, m = zt;
        if (en(a)) {
          var L = "separator" in a ? a.separator : L;
          u = "length" in a ? oi(a.length) : u, m = "omission" in a ? be(a.omission) : m;
        }
        r = bi(r);
        var G = r.length;
        if (lr(r)) {
          var J = Gn(r);
          G = J.length;
        }
        if (u >= G)
          return r;
        var ot = u - wr(m);
        if (ot < 1)
          return m;
        var mt = J ? tn(J, 0, ot).join("") : r.slice(0, ot);
        if (L === y)
          return mt + m;
        if (J && (ot += mt.length - ot), Ph(L)) {
          if (r.slice(ot).search(L)) {
            var Ht, jt = mt;
            for (L.global || (L = In(L.source, bi(Ta.exec(L)) + "g")), L.lastIndex = 0; Ht = L.exec(jt); )
              var Jt = Ht.index;
            mt = mt.slice(0, Jt === y ? ot : Jt);
          }
        } else if (r.indexOf(be(L), ot) != ot) {
          var ve = mt.lastIndexOf(L);
          ve > -1 && (mt = mt.slice(0, ve));
        }
        return mt + m;
      }
      function Rd(r) {
        return r = bi(r), r && Za.test(r) ? r.replace(os, Oa) : r;
      }
      var bd = ge(function(r, a, u) {
        return r + (u ? " " : "") + a.toUpperCase();
      }), Rh = ae("toUpperCase");
      function bu(r, a, u) {
        return r = bi(r), a = u ? y : a, a === y ? Ho(r) ? ah(r) : Js(r) : r.match(a) || [];
      }
      var Ou = Wt(function(r, a) {
        try {
          return $n(r, y, a);
        } catch (u) {
          return Ah(u) ? u : new Ve(u);
        }
      }), Od = ts(function(r, a) {
        return Di(a, function(u) {
          u = Ao(u), no(r, u, Sh(r[u], r));
        }), r;
      });
      function Id(r) {
        var a = r == null ? 0 : r.length, u = ke();
        return r = a ? Ri(r, function(m) {
          if (typeof m[1] != "function")
            throw new Hn(Mt);
          return [u(m[0]), m[1]];
        }) : [], Wt(function(m) {
          for (var L = -1; ++L < a; ) {
            var G = r[L];
            if ($n(G[0], this, m))
              return $n(G[1], this, m);
          }
        });
      }
      function Dd(r) {
        return Ds(tr(r, vt));
      }
      function bh(r) {
        return function() {
          return r;
        };
      }
      function zd(r, a) {
        return r == null || r !== r ? a : r;
      }
      var Nd = di(), Bd = di(!0);
      function gr(r) {
        return r;
      }
      function Oh(r) {
        return w(typeof r == "function" ? r : tr(r, vt));
      }
      function Ud(r) {
        return W(tr(r, vt));
      }
      function Fd(r, a) {
        return st(r, tr(a, vt));
      }
      var Gd = Wt(function(r, a) {
        return function(u) {
          return e(u, r, a);
        };
      }), Hd = Wt(function(r, a) {
        return function(u) {
          return e(r, u, a);
        };
      });
      function Ih(r, a, u) {
        var m = Rn(a), L = $o(a, m);
        u == null && !(en(a) && (L.length || !m.length)) && (u = a, a = r, r = this, L = $o(a, Rn(a)));
        var G = !(en(u) && "chain" in u) || !!u.chain, J = is(r);
        return Di(L, function(ot) {
          var mt = a[ot];
          r[ot] = mt, J && (r.prototype[ot] = function() {
            var Ht = this.__chain__;
            if (G || Ht) {
              var jt = r(this.__wrapped__), Jt = jt.__actions__ = Nn(this.__actions__);
              return Jt.push({ func: mt, args: arguments, thisArg: r }), jt.__chain__ = Ht, jt;
            }
            return mt.apply(r, Ir([this.value()], arguments));
          });
        }), r;
      }
      function kd() {
        return Ji._ === this && (Ji._ = Mr), this;
      }
      function Dh() {
      }
      function Vd(r) {
        return r = oi(r), Wt(function(a) {
          return C(a, r);
        });
      }
      var Wd = yn(Ri), jd = yn(el), Xd = yn(Zr);
      function Iu(r) {
        return yh(r) ? po(Ao(r)) : bt(r);
      }
      function qd(r) {
        return function(a) {
          return r == null ? y : So(r, a);
        };
      }
      var Yd = _l(), Zd = _l(!0);
      function zh() {
        return [];
      }
      function Nh() {
        return !1;
      }
      function Jd() {
        return {};
      }
      function $d() {
        return "";
      }
      function Qd() {
        return !0;
      }
      function Kd(r, a) {
        if (r = oi(r), r < 1 || r > ze)
          return [];
        var u = $e, m = Sn(r, $e);
        a = ke(a), r -= $e;
        for (var L = $r(m, a); ++u < r; )
          a(u);
        return L;
      }
      function tm(r) {
        return ei(r) ? Ri(r, Ao) : Sr(r) ? [r] : Nn(Kh(bi(r)));
      }
      function em(r) {
        var a = ++Vn;
        return bi(r) + a;
      }
      var im = er(function(r, a) {
        return r + a;
      }, 0), nm = ja("ceil"), rm = er(function(r, a) {
        return r / a;
      }, 1), om = ja("floor");
      function sm(r) {
        return r && r.length ? Vr(r, gr, ka) : y;
      }
      function am(r, a) {
        return r && r.length ? Vr(r, ke(a, 2), ka) : y;
      }
      function lm(r) {
        return xs(r, gr);
      }
      function hm(r, a) {
        return xs(r, ke(a, 2));
      }
      function um(r) {
        return r && r.length ? Vr(r, gr, I) : y;
      }
      function cm(r, a) {
        return r && r.length ? Vr(r, ke(a, 2), I) : y;
      }
      var pm = er(function(r, a) {
        return r * a;
      }, 1), fm = ja("round"), dm = er(function(r, a) {
        return r - a;
      }, 0);
      function mm(r) {
        return r && r.length ? mo(r, gr) : 0;
      }
      function gm(r, a) {
        return r && r.length ? mo(r, ke(a, 2)) : 0;
      }
      return O.after = Bp, O.ary = uu, O.assign = Ef, O.assignIn = Su, O.assignInWith = th, O.assignWith = Af, O.at = Pf, O.before = cu, O.bind = Sh, O.bindAll = Od, O.bindKey = pu, O.castArray = Zp, O.chain = au, O.chunk = rc, O.compact = oc, O.concat = sc, O.cond = Id, O.conforms = Dd, O.constant = bh, O.countBy = dp, O.create = Lf, O.curry = fu, O.curryRight = du, O.debounce = mu, O.defaults = Cf, O.defaultsDeep = Rf, O.defer = Up, O.delay = Fp, O.difference = ac, O.differenceBy = lc, O.differenceWith = hc, O.drop = uc, O.dropRight = cc, O.dropRightWhile = pc, O.dropWhile = fc, O.fill = dc, O.filter = gp, O.flatMap = _p, O.flatMapDeep = xp, O.flatMapDepth = wp, O.flatten = nu, O.flattenDeep = mc, O.flattenDepth = gc, O.flip = Gp, O.flow = Nd, O.flowRight = Bd, O.fromPairs = vc, O.functions = Bf, O.functionsIn = Uf, O.groupBy = Mp, O.initial = _c, O.intersection = xc, O.intersectionBy = wc, O.intersectionWith = Mc, O.invert = Gf, O.invertBy = Hf, O.invokeMap = Sp, O.iteratee = Oh, O.keyBy = Ep, O.keys = Rn, O.keysIn = mr, O.map = Yl, O.mapKeys = Vf, O.mapValues = Wf, O.matches = Ud, O.matchesProperty = Fd, O.memoize = Jl, O.merge = jf, O.mergeWith = Eu, O.method = Gd, O.methodOf = Hd, O.mixin = Ih, O.negate = $l, O.nthArg = Vd, O.omit = Xf, O.omitBy = qf, O.once = Hp, O.orderBy = Ap, O.over = Wd, O.overArgs = kp, O.overEvery = jd, O.overSome = Xd, O.partial = Eh, O.partialRight = gu, O.partition = Pp, O.pick = Yf, O.pickBy = Au, O.property = Iu, O.propertyOf = qd, O.pull = Ac, O.pullAll = ou, O.pullAllBy = Pc, O.pullAllWith = Lc, O.pullAt = Cc, O.range = Yd, O.rangeRight = Zd, O.rearg = Vp, O.reject = Rp, O.remove = Rc, O.rest = Wp, O.reverse = Mh, O.sampleSize = Op, O.set = Jf, O.setWith = $f, O.shuffle = Ip, O.slice = bc, O.sortBy = Np, O.sortedUniq = Uc, O.sortedUniqBy = Fc, O.split = xd, O.spread = jp, O.tail = Gc, O.take = Hc, O.takeRight = kc, O.takeRightWhile = Vc, O.takeWhile = Wc, O.tap = op, O.throttle = Xp, O.thru = ql, O.toArray = wu, O.toPairs = Pu, O.toPairsIn = Lu, O.toPath = tm, O.toPlainObject = Tu, O.transform = Qf, O.unary = qp, O.union = jc, O.unionBy = Xc, O.unionWith = qc, O.uniq = Yc, O.uniqBy = Zc, O.uniqWith = Jc, O.unset = Kf, O.unzip = Th, O.unzipWith = su, O.update = td, O.updateWith = ed, O.values = Ya, O.valuesIn = id, O.without = $c, O.words = bu, O.wrap = Yp, O.xor = Qc, O.xorBy = Kc, O.xorWith = tp, O.zip = ep, O.zipObject = ip, O.zipObjectDeep = np, O.zipWith = rp, O.entries = Pu, O.entriesIn = Lu, O.extend = Su, O.extendWith = th, Ih(O, O), O.add = im, O.attempt = Ou, O.camelCase = sd, O.capitalize = Cu, O.ceil = nm, O.clamp = nd, O.clone = Jp, O.cloneDeep = Qp, O.cloneDeepWith = Kp, O.cloneWith = $p, O.conformsTo = tf, O.deburr = Ru, O.defaultTo = zd, O.divide = rm, O.endsWith = ad, O.eq = so, O.escape = ld, O.escapeRegExp = hd, O.every = mp, O.find = vp, O.findIndex = eu, O.findKey = bf, O.findLast = yp, O.findLastIndex = iu, O.findLastKey = Of, O.floor = om, O.forEach = lu, O.forEachRight = hu, O.forIn = If, O.forInRight = Df, O.forOwn = zf, O.forOwnRight = Nf, O.get = Lh, O.gt = ef, O.gte = nf, O.has = Ff, O.hasIn = Ch, O.head = ru, O.identity = gr, O.includes = Tp, O.indexOf = yc, O.inRange = rd, O.invoke = kf, O.isArguments = xa, O.isArray = ei, O.isArrayBuffer = rf, O.isArrayLike = dr, O.isArrayLikeObject = mn, O.isBoolean = of, O.isBuffer = Fs, O.isDate = sf, O.isElement = af, O.isEmpty = lf, O.isEqual = hf, O.isEqualWith = uf, O.isError = Ah, O.isFinite = cf, O.isFunction = is, O.isInteger = vu, O.isLength = Ql, O.isMap = yu, O.isMatch = pf, O.isMatchWith = ff, O.isNaN = df, O.isNative = mf, O.isNil = vf, O.isNull = gf, O.isNumber = _u, O.isObject = en, O.isObjectLike = pn, O.isPlainObject = Tl, O.isRegExp = Ph, O.isSafeInteger = yf, O.isSet = xu, O.isString = Kl, O.isSymbol = Sr, O.isTypedArray = qa, O.isUndefined = _f, O.isWeakMap = xf, O.isWeakSet = wf, O.join = Tc, O.kebabCase = ud, O.last = Xr, O.lastIndexOf = Sc, O.lowerCase = cd, O.lowerFirst = pd, O.lt = Mf, O.lte = Tf, O.max = sm, O.maxBy = am, O.mean = lm, O.meanBy = hm, O.min = um, O.minBy = cm, O.stubArray = zh, O.stubFalse = Nh, O.stubObject = Jd, O.stubString = $d, O.stubTrue = Qd, O.multiply = pm, O.nth = Ec, O.noConflict = kd, O.noop = Dh, O.now = Zl, O.pad = fd, O.padEnd = dd, O.padStart = md, O.parseInt = gd, O.random = od, O.reduce = Lp, O.reduceRight = Cp, O.repeat = vd, O.replace = yd, O.result = Zf, O.round = fm, O.runInContext = lt, O.sample = bp, O.size = Dp, O.snakeCase = _d, O.some = zp, O.sortedIndex = Oc, O.sortedIndexBy = Ic, O.sortedIndexOf = Dc, O.sortedLastIndex = zc, O.sortedLastIndexBy = Nc, O.sortedLastIndexOf = Bc, O.startCase = wd, O.startsWith = Md, O.subtract = dm, O.sum = mm, O.sumBy = gm, O.template = Td, O.times = Kd, O.toFinite = ns, O.toInteger = oi, O.toLength = Mu, O.toLower = Sd, O.toNumber = qr, O.toSafeInteger = Sf, O.toString = bi, O.toUpper = Ed, O.trim = Ad, O.trimEnd = Pd, O.trimStart = Ld, O.truncate = Cd, O.unescape = Rd, O.uniqueId = em, O.upperCase = bd, O.upperFirst = Rh, O.each = lu, O.eachRight = hu, O.first = ru, Ih(O, function() {
        var r = {};
        return fr(O, function(a, u) {
          si.call(O.prototype, u) || (r[u] = a);
        }), r;
      }(), { chain: !1 }), O.VERSION = pt, Di(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(r) {
        O[r].placeholder = O;
      }), Di(["drop", "take"], function(r, a) {
        ni.prototype[r] = function(u) {
          u = u === y ? 1 : $i(oi(u), 0);
          var m = this.__filtered__ && !a ? new ni(this) : this.clone();
          return m.__filtered__ ? m.__takeCount__ = Sn(u, m.__takeCount__) : m.__views__.push({
            size: Sn(u, $e),
            type: r + (m.__dir__ < 0 ? "Right" : "")
          }), m;
        }, ni.prototype[r + "Right"] = function(u) {
          return this.reverse()[r](u).reverse();
        };
      }), Di(["filter", "map", "takeWhile"], function(r, a) {
        var u = a + 1, m = u == se || u == Et;
        ni.prototype[r] = function(L) {
          var G = this.clone();
          return G.__iteratees__.push({
            iteratee: ke(L, 3),
            type: u
          }), G.__filtered__ = G.__filtered__ || m, G;
        };
      }), Di(["head", "last"], function(r, a) {
        var u = "take" + (a ? "Right" : "");
        ni.prototype[r] = function() {
          return this[u](1).value()[0];
        };
      }), Di(["initial", "tail"], function(r, a) {
        var u = "drop" + (a ? "" : "Right");
        ni.prototype[r] = function() {
          return this.__filtered__ ? new ni(this) : this[u](1);
        };
      }), ni.prototype.compact = function() {
        return this.filter(gr);
      }, ni.prototype.find = function(r) {
        return this.filter(r).head();
      }, ni.prototype.findLast = function(r) {
        return this.reverse().find(r);
      }, ni.prototype.invokeMap = Wt(function(r, a) {
        return typeof r == "function" ? new ni(this) : this.map(function(u) {
          return e(u, r, a);
        });
      }), ni.prototype.reject = function(r) {
        return this.filter($l(ke(r)));
      }, ni.prototype.slice = function(r, a) {
        r = oi(r);
        var u = this;
        return u.__filtered__ && (r > 0 || a < 0) ? new ni(u) : (r < 0 ? u = u.takeRight(-r) : r && (u = u.drop(r)), a !== y && (a = oi(a), u = a < 0 ? u.dropRight(-a) : u.take(a - r)), u);
      }, ni.prototype.takeRightWhile = function(r) {
        return this.reverse().takeWhile(r).reverse();
      }, ni.prototype.toArray = function() {
        return this.take($e);
      }, fr(ni.prototype, function(r, a) {
        var u = /^(?:filter|find|map|reject)|While$/.test(a), m = /^(?:head|last)$/.test(a), L = O[m ? "take" + (a == "last" ? "Right" : "") : a], G = m || /^find/.test(a);
        L && (O.prototype[a] = function() {
          var J = this.__wrapped__, ot = m ? [1] : arguments, mt = J instanceof ni, Ht = ot[0], jt = mt || ei(J), Jt = function(fi) {
            var xi = L.apply(O, Ir([fi], ot));
            return m && ve ? xi[0] : xi;
          };
          jt && u && typeof Ht == "function" && Ht.length != 1 && (mt = jt = !1);
          var ve = this.__chain__, De = !!this.__actions__.length, je = G && !ve, ai = mt && !De;
          if (!G && jt) {
            J = ai ? J : new ni(this);
            var Xe = r.apply(J, ot);
            return Xe.__actions__.push({ func: ql, args: [Jt], thisArg: y }), new Pn(Xe, ve);
          }
          return je && ai ? r.apply(this, ot) : (Xe = this.thru(Jt), je ? m ? Xe.value()[0] : Xe.value() : Xe);
        });
      }), Di(["pop", "push", "shift", "sort", "splice", "unshift"], function(r) {
        var a = fn[r], u = /^(?:push|sort|unshift)$/.test(r) ? "tap" : "thru", m = /^(?:pop|shift)$/.test(r);
        O.prototype[r] = function() {
          var L = arguments;
          if (m && !this.__chain__) {
            var G = this.value();
            return a.apply(ei(G) ? G : [], L);
          }
          return this[u](function(J) {
            return a.apply(ei(J) ? J : [], L);
          });
        };
      }), fr(ni.prototype, function(r, a) {
        var u = O[a];
        if (u) {
          var m = u.name + "";
          si.call(xo, m) || (xo[m] = []), xo[m].push({ name: a, func: u });
        }
      }), xo[zi(y, _).name] = [{
        name: "wrapper",
        func: y
      }], ni.prototype.clone = Cs, ni.prototype.reverse = Il, ni.prototype.value = Rs, O.prototype.at = sp, O.prototype.chain = ap, O.prototype.commit = lp, O.prototype.next = hp, O.prototype.plant = cp, O.prototype.reverse = pp, O.prototype.toJSON = O.prototype.valueOf = O.prototype.value = fp, O.prototype.first = O.prototype.head, _o && (O.prototype[_o] = up), O;
    }, vo = lh();
    _r ? ((_r.exports = vo)._ = vo, uo._ = vo) : Ji._ = vo;
  }).call(Sl);
})(rh, rh.exports);
var Ym = rh.exports;
const Zm = /* @__PURE__ */ qm(Ym);
class tg {
  constructor($, y = []) {
    /**
     * 矢量数据简化
     * @param {*} geojson  geojson数据
     * @returns  { Object }
     */
    zu(this, "simplifyFunc", ($) => {
      try {
        $ = turf.simplify($, {
          tolerance: 5e-4,
          highQuality: !1,
          mutate: !0
        });
      } catch {
      }
      return $;
    });
    mars3d ? (this.map = $, this.vectorArr = y, this.geoJsonType = /* @__PURE__ */ new Map([
      ["Point"],
      ["LineString"],
      ["Polygon"],
      ["MultiPoint"],
      ["MultiLineString"],
      ["MultiPolygon"]
    ]), this.avoidanceArr = [], this.editDate = {
      id: ""
    }) : console.error("未引入指定插件");
  }
  /**
   * 移除矢量数据
   * @param  { String } id 矢量数据id
   *
   */
  remove($) {
    this.map.removeLayer(this.map.getLayer($, "vectorId")), window.dynamicMasking.remove($);
  }
  /**
   * add 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  add($, y) {
    return new Promise((pt, gt) => {
      let S;
      if (typeof $ != "object") {
        let vt = this.map.getLayer($, "vectorId");
        if (vt)
          return pt(vt);
        S = this.query($);
      } else {
        let vt = this.map.getLayer($.id, "vectorId");
        if (vt)
          return pt(vt);
        S = $;
      }
      let { value: Mt, url: kt, id: nt, title: Tt } = S;
      new Cesium.Resource({
        url: kt
      }).fetchJson().then((vt) => {
        let { id: Nt, title: Ut, shpInfo: Ct } = S, { attributes: at, geometryType: Y, geometryCount: _, pointCount: x } = Ct, {
          width: B,
          materialType: E,
          materialOptions: Z,
          clampToGround: z,
          distanceDisplayCondition: X,
          distanceDisplayCondition_near: it,
          distanceDisplayCondition_far: _t,
          zIndex: dt,
          label: zt,
          fill: Yt,
          diffHeight: re,
          outline: se,
          outlineStyle: we,
          color: Et,
          pixelSize: ie,
          outlineColor: ze,
          outlineWidth: nn
        } = JSON.parse(at), Ft;
        switch (console.log("geometryType", Y), zt.color = Cesium.Color.fromCssColorString(zt.color).withAlpha(
          0
        ), zt.outlineColor = Cesium.Color.fromCssColorString(
          zt.outlineColor
        ).withAlpha(1e-3), zt.backgroundColor = Cesium.Color.fromCssColorString(
          zt.backgroundColor
        ).withAlpha(1e-3), zt.background = !1, zt.outline = !1, zt.show = !1, Y) {
          case "LineString":
          case "MultiLineString":
            zt.backgroundPadding = 5, Ft = new mars3d.layer.GeoJsonLayer({
              data: vt,
              vectorId: Nt,
              format: x > 1e4 ? this.simplifyFunc : null,
              symbol: {
                type: "polylineC",
                styleOptions: {
                  width: B,
                  clampToGround: z,
                  distanceDisplayCondition: X,
                  distanceDisplayCondition_far: _t,
                  distanceDisplayCondition_near: it,
                  materialType: E,
                  materialOptions: Z,
                  label: zt
                }
              },
              popup: `&nbsp;&nbsp; ${Ut} &nbsp;&nbsp;`,
              hasZIndex: !0,
              zIndex: dt
            });
            break;
          case "Polygon":
          case "MultiPolygon":
            console.log("attributes", E, Z), E == "PolyGrass" && (Z = {
              evenColor: new Cesium.Color(0.25, 0.4, 0.1, 1),
              oddColor: new Cesium.Color(0.1, 0.1, 0.1, 1),
              frequency: 1.5
              // 斑驳
            }), Ft = new mars3d.layer.GeoJsonLayer({
              data: vt,
              vectorId: Nt,
              format: x > 1e4 ? this.simplifyFunc : null,
              symbol: {
                type: "polygon",
                styleOptions: {
                  fill: Yt,
                  diffHeight: re,
                  clampToGround: z,
                  materialType: E,
                  materialOptions: Z,
                  distanceDisplayCondition: X,
                  distanceDisplayCondition_far: _t,
                  distanceDisplayCondition_near: it,
                  outlineStyle: we,
                  outline: se,
                  label: zt
                }
              },
              popup: `&nbsp;&nbsp; ${Ut} &nbsp;&nbsp;`
            });
            break;
          case "Point":
          case "MultiPoint":
            console.log(JSON.parse(at)), Ft = new mars3d.layer.GeoJsonLayer({
              data: vt,
              vectorId: Nt,
              format: x > 1e4 ? this.simplifyFunc : null,
              symbol: {
                type: "pointP",
                styleOptions: {
                  color: Et,
                  pixelSize: ie,
                  outline: se,
                  outlineColor: ze,
                  outlineWidth: nn,
                  visibleDepth: !1,
                  label: zt
                }
              }
            });
            break;
        }
        window.map.addLayer(Ft), Ft.bindPopup((Oi) => {
          console.log("event", Oi);
        });
        let $e = Zm.debounce((Oi) => {
          console.log("测试shp矢量加载完成"), window.dynamicMasking.add(Oi, JSON.parse(at));
        }, 500);
        Ft.readyPromise.then((Oi) => {
          $e(Oi), pt(Oi);
        }).catch((Oi) => {
          console.error("测试shp矢量加载失败", Oi), pt({
            tite: "【矢量】" + modelTitle + "加载失败",
            type: "error",
            id: modelId,
            url: kt
          });
        });
      }).catch((vt) => {
        console.error("数据有误", vt), pt({
          tite: "【矢量】" + modelTitle + "数据有误",
          type: "error",
          id: modelId,
          url: kt
        });
      });
    });
  }
  /**
   * 更新 矢量数据
   * @param  { String } modelParameter 模型属性 或者 模型id
   * @param  { Object } fn 自定义注册事件
   */
  updateData($) {
    this.vectorArr = $;
  }
  /**
   * 处理kml数据
   * @param  { Object } item 查询出来的对象
   * @returns { Object } 样式对象
   */
  processingKML($) {
    let y, pt = 2e3, gt = !0, { kmlInfo: S } = $, {
      fill: Mt,
      areaColor: kt,
      areaSideColor: nt,
      transparency: Tt,
      isAreaSideColor: Rt,
      minDistinct: vt,
      textDistinct: Nt,
      textSize: Ut,
      textColor: Ct,
      fontStyle: at,
      outLine: Y,
      sideColor: _,
      backGround: x,
      backGroundColor: B,
      clampToGround: E
    } = S;
    console.log("minDistinct", vt);
    let Z = {
      fill: Mt,
      color: kt,
      opacity: Tt || 0.5,
      outline: Rt,
      outlineColor: nt,
      outlineWidth: 2,
      clampToGround: E,
      // distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1000000),
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: Nt || 1e6,
      distanceDisplayCondition_near: vt || 0,
      classificationType: y,
      opacity: String(Tt)
    }, z = {
      text: "{name}",
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      pixelOffsetY: -10,
      font_size: 26,
      color: Ct || "#ffffff",
      font_family: at || "黑体",
      outline: Y || !0,
      outlineColor: _ || "#000000",
      outlineWidth: 4,
      scaleByDistance: !0,
      distanceDisplayCondition: !0,
      distanceDisplayCondition_far: Nt || 1e6,
      distanceDisplayCondition_near: vt || 0,
      background: x || !1,
      backgroundColor: B || "",
      visibleDepth: gt,
      clampToGround: E || !1,
      disableDepthTestDistance: pt
    };
    return {
      ...Z,
      label: z
    };
  }
  /**
   * 选中矢量
   * @param  { String } id 模型id
   *
   */
  selected($) {
    this.map.getLayer($, "vectorId").flyTo();
  }
  /**
   * 查询矢量数据的对象
   * @param  { String } id 矢量id
   * @returns { Object || Boolean } 查询出来的树对象 或者 false
   */
  query($) {
    return this.vectorArr.length == 0 ? !1 : this.vectorArr.find((y) => y.id == $);
  }
  /**
   * 批量编辑矢量
   * @param  { String } id 对象id
   * @param  { Object } vector 矢量对象
   * @param  { Object } label  注记对象
   * @returns { Object }
   */
  editVector($, y, pt) {
    let gt = this.map.getLayer($, "vectorId"), S = Xm(y, pt);
    console.log("编辑数据", S), gt && (gt.eachGraphic((Mt) => {
      Mt.label.show === !1 && (delete Mt.label.outline, delete Mt.label.background, delete Mt.label.outlineColor, delete Mt.label.backgroundColor), Mt.setStyle({
        ...S
      });
    }), dynamicMasking.modify($, S));
  }
  /**
   * 加载国家边界线
   *
   * @returns { any }
   */
  nationalBoundaries() {
    let $ = "./gis/nationalBoundaries.json", y = new mars3d.layer.GeoJsonLayer({
      name: "国界",
      url: $,
      format: (pt) => {
        try {
          pt = turf.simplify(pt, {
            tolerance: 1e-5,
            highQuality: !1,
            mutate: !0
          });
        } catch (gt) {
          console.error(gt);
        }
        return pt;
      },
      symbol: {
        type: "polylineC",
        styleOptions: {
          width: 2,
          materialType: "Color",
          materialOptions: {
            color: "#CD9B1D"
          },
          distanceDisplayCondition: !0,
          distanceDisplayCondition_near: 1e3,
          distanceDisplayCondition_far: 2e7,
          clampToGround: !0,
          classificationType: Cesium.ClassificationType.TERRAIN
        }
      }
    });
    map.addLayer(y);
  }
}
class eg {
  constructor($, y = []) {
    mars3d ? (this.map = $, this.terrainProviderArr = y, this.terrainProviderId = "", this.events = {}, this.map.on(mars3d.EventType.terrainLoadError, (pt) => {
      console.error("地形服务加载失败", pt), this.hide();
    }), this.map.viewer.scene.globe.tileLoadProgressEvent.addEventListener(
      (pt) => {
        this.map.viewer.scene.globe.tilesLoaded && this.emit("load", pt);
      }
    )) : console.error("未引入指定插件");
  }
  /**
   * add 添加地形
   * @param  { Object || String } terrainProviderParameter 地形属性 或者 地形id
   */
  add($) {
    let { url: y, id: pt } = $;
    if (this.terrainProviderId == pt && this.map.terrainProvider._layers)
      return !1;
    this.map.terrainProvider = mars3d.LayerUtil.createTerrainProvider({
      imageXyzId: pt,
      type: "xyz",
      url: y,
      //item.gisInfo.gisUrl,
      requestVertexNormals: !0,
      requestMetadata: !0
    }), this.terrainProviderId = pt;
  }
  /**
   * 开启地形
   *
   */
  show() {
    this.map.hasTerrain = !0;
  }
  /**
   * 隐藏地形
   *
   */
  hide() {
    this.map.hasTerrain = !1;
  }
  /**
   * events
   * 事件监听
   * @param  { string } event - 事件名 目前只支持enter和leave
   * @param  { function } fn - 回调函数
   * @returns { any }
   */
  on($, y) {
    $ == "load" ? this.events[$] ? this.events[$].push(y) : this.events[$] = [y] : console.log("未开放自定义");
  }
  /**
   * events
   * 事件触发
   * @param  { object | array } event - 事件名
   * @returns { any }
   */
  emit($, ...y) {
    this.events[$] != null && this.events[$].forEach((pt) => pt(...y));
  }
  /**
   * events
   * 事件移除
   * @param  { string } event - 事件名
   * @param  { function } callback - 回调函数
   * @returns { any }
   */
  off($, y) {
    this.events[$] = this.events[$].filter((pt) => pt !== y);
  }
  /**
   * events
   * 触发一次
   * @param  { string } event - 事件名
   * @param  { function }  fn - 回调函数
   * @returns { any }
   */
  once($, y) {
    const pt = () => {
      y(), this.off($, pt);
    };
    this.on($, pt);
  }
  /**
   * 地形裁剪
   */
  addClip($) {
    return new Promise((y, pt) => {
      window.bimClip ? y(bimClip.clipGisAdd($)) : pt("挖洞工具未初始化");
    });
  }
}
class ig {
  constructor($, y = []) {
    mars3d ? (this.map = $, this.elevationImageArr = y, this.elevationImageLayer, this.form = {
      brightnessVal: 1.3,
      //环境亮度配置
      msaaSamples: 4,
      //反锯齿配置
      surfaceOpacity: 1,
      //地表不透明度
      layerOpacity: 1,
      //瓦片透明度
      layerBrightness: 2,
      //瓦片亮度
      layerContrast: 1,
      //瓦片对比度
      layerHue: 0,
      //瓦片色彩
      layerSaturation: 1,
      //瓦片饱和度
      layerGamma: 1
      //瓦片伽马值
    }) : console.error("未引入指定插件");
  }
  /**
   * 给影像数组添加数据
   * @param  { Object } data 集合数据
   */
  pushVector($) {
    this.elevationImageArr.push($);
  }
  /**
   * 添加影像
   * @param  { Object || String } xyzParameter 影像属性 或者 影像id
   * @param  { Object } fn 监听函数
   *
   */
  add($, y) {
    let pt;
    if (typeof $ != "object" ? pt = $ : pt = $.imageXyzId, this.map.getLayer(pt, "imageXyzId"))
      return !1;
    const {
      layerOpacity: gt,
      layerBrightness: S,
      layerContrast: Mt,
      layerHue: kt,
      layerSaturation: nt,
      layerGamma: Tt,
      surfaceOpacity: Rt
    } = this.exposureEnvironmentSettings();
    return new Promise((vt, Nt) => {
      let Ut, Ct, at;
      if (typeof $ != "object") {
        let Y = this.query($);
        Y || Nt("缺少树结构");
        let { gisInfo: _ } = Y;
        Ut = _.id, at = _.order, Ct = Y.url;
      } else
        Ut = $.imageXyzId, Ct = $.url, at = $.zIndex;
      this.elevationImageLayer = new mars3d.layer.XyzLayer({
        imageXyzId: Ut,
        type: "xyz",
        url: Ct,
        //item.gisUrl,
        hasZIndex: !0,
        //是否可以调整图层顺序（在同类型图层间）
        zIndex: at.toString(),
        //图层顺序，数字大的在上面。（当hasZIndex为true时）
        brightness: S,
        //亮度0.0-1.0。
        opacity: gt,
        saturation: nt,
        contrast: Mt,
        hue: kt,
        gamma: Tt,
        alpha: Rt,
        show: !0
      }), this.elevationImageLayer.on(mars3d.EventType.load, (Y) => {
        vt(Y);
      }), this.map.addLayer(this.elevationImageLayer), y && Object.keys(y).forEach((Y) => {
        this.elevationImageLayer.on(fnType.get(Y), (_) => {
          y[Y](_);
        });
      });
    });
  }
  /**
   * 移除影像方法
   * @param  { String } id 影像id
   *
   */
  remove($) {
    console.log($), this.map.removeLayer(this.map.getLayer($, "imageXyzId"));
  }
  /**
   * 查询影像方法
   * @param  { String } id 模型属性
   * @returns { Object || Boolean } 查询出来的对象 或者 false
   */
  query($) {
    return this.elevationImageArr.length == 0 ? !1 : this.elevationImageArr.find((y) => y.id == $);
  }
  /**
   *
   * 初始化数据
   * @returns { any }
   */
  initial() {
    this.elevationImageArr = [], this.elevationImageLayer = null;
  }
  /**
   *
   * 是否读取本地化数据 来初始化地球
   * @returns { any }
   */
  exposureEnvironmentSettings() {
    return localStorage.getItem("environmentSettings") ? JSON.parse(localStorage.getItem("environmentSettings")) : (localStorage.setItem("environmentSettings", JSON.stringify(this.form)), JSON.parse(JSON.stringify(this.form)));
  }
}
const Jm = [Tm, jm], ng = {
  continuation: null,
  mapModali: null,
  install(g) {
    if (Jm.forEach((Mt, kt) => {
      g.component(Mt.name, Mt);
    }), this.continuation) {
      g.config.globalProperties.$continuation = this.continuation;
      return;
    }
    let $ = Nu(Dm), y = document.createElement("div"), pt = document.body;
    if (pt.appendChild(y), this.loading = $.mount(y), g.config.globalProperties.$loading = this.loading, window.$continuation = this.loading, this.mapModali) {
      g.config.globalProperties.$mapModali = this.mapModali;
      return;
    }
    let gt = Nu(Um), S = document.createElement("div");
    pt.appendChild(S), this.mapModali = gt.mount(S), g.config.globalProperties.$mapModali = this.mapModali, window.$mapModali = this.mapModali;
  }
};
export {
  jm as BimBackgroundPlate,
  Dm as BimCutscenes,
  ig as BimElevationImage,
  Km as BimModel,
  eg as BimTerrainProvider,
  tg as BimVector,
  Tm as Button,
  ng as ChbimPlugins,
  Um as MapModali
};
